<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/validator/PKIXValidator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../util/SignatureUtil.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ValidatorException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/validator/PKIXValidator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.validator;
 27 
 28 import java.util.*;
 29 
 30 import java.security.*;
 31 import java.security.cert.*;
 32 
 33 import javax.security.auth.x500.X500Principal;
 34 import sun.security.action.GetBooleanAction;

 35 import sun.security.provider.certpath.AlgorithmChecker;
 36 import sun.security.provider.certpath.PKIXExtendedParameters;
 37 
 38 /**
 39  * Validator implementation built on the PKIX CertPath API. This
 40  * implementation will be emphasized going forward.
 41  * &lt;p&gt;
 42  * Note that the validate() implementation tries to use a PKIX validator
 43  * if that appears possible and a PKIX builder otherwise. This increases
 44  * performance and currently also leads to better exception messages
 45  * in case of failures.
 46  * &lt;p&gt;
 47  * {@code PKIXValidator} objects are immutable once they have been created.
 48  * Please DO NOT add methods that can change the state of an instance once
 49  * it has been created.
 50  *
 51  * @author Andreas Sterbenz
 52  */
 53 public final class PKIXValidator extends Validator {
 54 
 55     /**
 56      * Flag indicating whether to enable revocation check for the PKIX trust
 57      * manager. Typically, this will only work if the PKIX implementation
 58      * supports CRL distribution points as we do not manually setup CertStores.
 59      */
 60     private static final boolean checkTLSRevocation = GetBooleanAction
 61             .privilegedGetProperty(&quot;com.sun.net.ssl.checkRevocation&quot;);
 62 












 63     private final Set&lt;X509Certificate&gt; trustedCerts;
 64     private final PKIXBuilderParameters parameterTemplate;
 65     private int certPathLength = -1;
 66 
 67     // needed only for the validator
 68     private final Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; trustedSubjects;
 69     private final CertificateFactory factory;
 70 
 71     private final boolean plugin;
 72 
 73     PKIXValidator(String variant, Collection&lt;X509Certificate&gt; trustedCerts) {
 74         super(TYPE_PKIX, variant);
 75         this.trustedCerts = (trustedCerts instanceof Set) ?
 76                             (Set&lt;X509Certificate&gt;)trustedCerts :
 77                             new HashSet&lt;X509Certificate&gt;(trustedCerts);
 78 
 79         Set&lt;TrustAnchor&gt; trustAnchors = new HashSet&lt;&gt;();
 80         for (X509Certificate cert : trustedCerts) {
 81             trustAnchors.add(new TrustAnchor(cert, null));
 82         }
</pre>
<hr />
<pre>
126      *    tied to those DNs.
127      */
128     private Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; setTrustedSubjects() {
129         Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; subjectMap = new HashMap&lt;&gt;();
130 
131         for (X509Certificate cert : trustedCerts) {
132             X500Principal dn = cert.getSubjectX500Principal();
133             List&lt;PublicKey&gt; keys;
134             if (subjectMap.containsKey(dn)) {
135                 keys = subjectMap.get(dn);
136             } else {
137                 keys = new ArrayList&lt;PublicKey&gt;();
138                 subjectMap.put(dn, keys);
139             }
140             keys.add(cert.getPublicKey());
141         }
142 
143         return subjectMap;
144     }
145 

146     public Collection&lt;X509Certificate&gt; getTrustedCertificates() {
147         return trustedCerts;
148     }
149 
150     /**
151      * Returns the length of the last certification path that is validated by
152      * CertPathValidator. This is intended primarily as a callback mechanism
153      * for PKIXCertPathCheckers to determine the length of the certification
154      * path that is being validated. It is necessary since engineValidate()
155      * may modify the length of the path.
156      *
157      * @return the length of the last certification path passed to
158      *   CertPathValidator.validate, or -1 if it has not been invoked yet
159      */
160     public int getCertPathLength() { // mutable, should be private
161         return certPathLength;
162     }
163 
164     /**
165      * Set J2SE global default PKIX parameters. Currently, hardcoded to disable
</pre>
<hr />
<pre>
177     /**
178      * Return the PKIX parameters used by this instance. An application may
179      * modify the parameters but must make sure not to perform any concurrent
180      * validations.
181      */
182     public PKIXBuilderParameters getParameters() { // mutable, should be private
183         return parameterTemplate;
184     }
185 
186     @Override
187     X509Certificate[] engineValidate(X509Certificate[] chain,
188             Collection&lt;X509Certificate&gt; otherCerts,
189             List&lt;byte[]&gt; responseList,
190             AlgorithmConstraints constraints,
191             Object parameter) throws CertificateException {
192         if ((chain == null) || (chain.length == 0)) {
193             throw new CertificateException
194                 (&quot;null or zero-length certificate chain&quot;);
195         }
196 

197         // Use PKIXExtendedParameters for timestamp and variant additions
198         PKIXBuilderParameters pkixParameters = null;
199         try {
200             pkixParameters = new PKIXExtendedParameters(
201                     (PKIXBuilderParameters) parameterTemplate.clone(),
202                     (parameter instanceof Timestamp) ?
203                             (Timestamp) parameter : null,
204                     variant);
205         } catch (InvalidAlgorithmParameterException e) {
206             // ignore exception
207         }
208 
209         // add new algorithm constraints checker
210         if (constraints != null) {
211             pkixParameters.addCertPathChecker(
212                     new AlgorithmChecker(constraints, null, variant));
213         }
214 
215         // attach it to the PKIXBuilderParameters.
216         if (!responseList.isEmpty()) {
217             addResponses(pkixParameters, chain, responseList);
218         }
219 
220         // check that chain is in correct order and check if chain contains
221         // trust anchor
222         X500Principal prevIssuer = null;
223         for (int i = 0; i &lt; chain.length; i++) {
224             X509Certificate cert = chain[i];
225             X500Principal dn = cert.getSubjectX500Principal();
<span class="line-removed">226             if (i != 0 &amp;&amp; !dn.equals(prevIssuer)) {</span>
<span class="line-removed">227                 // chain is not ordered correctly, call builder instead</span>
<span class="line-removed">228                 return doBuild(chain, otherCerts, pkixParameters);</span>
<span class="line-removed">229             }</span>
230 
<span class="line-modified">231             // Check if chain[i] is already trusted. It may be inside</span>
<span class="line-modified">232             // trustedCerts, or has the same dn and public key as a cert</span>
<span class="line-removed">233             // inside trustedCerts. The latter happens when a CA has</span>
<span class="line-removed">234             // updated its cert with a stronger signature algorithm in JRE</span>
<span class="line-removed">235             // but the weak one is still in circulation.</span>
<span class="line-removed">236 </span>
<span class="line-removed">237             if (trustedCerts.contains(cert) ||          // trusted cert</span>
<span class="line-removed">238                     (trustedSubjects.containsKey(dn) &amp;&amp; // replacing ...</span>
<span class="line-removed">239                      trustedSubjects.get(dn).contains(  // ... weak cert</span>
<span class="line-removed">240                         cert.getPublicKey()))) {</span>
<span class="line-removed">241                 if (i == 0) {</span>
242                     return new X509Certificate[] {chain[0]};
243                 }
<span class="line-modified">244                 // Remove and call validator on partial chain [0 .. i-1]</span>
<span class="line-modified">245                 X509Certificate[] newChain = new X509Certificate[i];</span>
<span class="line-modified">246                 System.arraycopy(chain, 0, newChain, 0, i);</span>
<span class="line-modified">247                 return doValidate(newChain, pkixParameters);</span>















248             }
249             prevIssuer = cert.getIssuerX500Principal();
250         }
251 
252         // apparently issued by trust anchor?
253         X509Certificate last = chain[chain.length - 1];
254         X500Principal issuer = last.getIssuerX500Principal();
255         X500Principal subject = last.getSubjectX500Principal();
256         if (trustedSubjects.containsKey(issuer) &amp;&amp;
257                 isSignatureValid(trustedSubjects.get(issuer), last)) {
258             return doValidate(chain, pkixParameters);
259         }
260 
261         // don&#39;t fallback to builder if called from plugin/webstart
262         if (plugin) {
263             // Validate chain even if no trust anchor is found. This
264             // allows plugin/webstart to make sure the chain is
265             // otherwise valid
266             if (chain.length &gt; 1) {
267                 X509Certificate[] newChain =
</pre>
<hr />
<pre>
290     }
291 
292     private boolean isSignatureValid(List&lt;PublicKey&gt; keys,
293             X509Certificate sub) {
294         if (plugin) {
295             for (PublicKey key: keys) {
296                 try {
297                     sub.verify(key);
298                     return true;
299                 } catch (Exception ex) {
300                     continue;
301                 }
302             }
303             return false;
304         }
305         return true; // only check if PLUGIN is set
306     }
307 
308     private static X509Certificate[] toArray(CertPath path, TrustAnchor anchor)
309             throws CertificateException {
<span class="line-removed">310         List&lt;? extends java.security.cert.Certificate&gt; list =</span>
<span class="line-removed">311                                                 path.getCertificates();</span>
<span class="line-removed">312         X509Certificate[] chain = new X509Certificate[list.size() + 1];</span>
<span class="line-removed">313         list.toArray(chain);</span>
314         X509Certificate trustedCert = anchor.getTrustedCert();
315         if (trustedCert == null) {
316             throw new ValidatorException
317                 (&quot;TrustAnchor must be specified as certificate&quot;);
318         }







319         chain[chain.length - 1] = trustedCert;
320         return chain;
321     }
322 
323     /**
324      * Set the check date (for debugging).
325      */
326     private void setDate(PKIXBuilderParameters params) {
327         @SuppressWarnings(&quot;deprecation&quot;)
328         Date date = validationDate;
329         if (date != null) {
330             params.setDate(date);
331         }
332     }
333 
334     private X509Certificate[] doValidate(X509Certificate[] chain,
335             PKIXBuilderParameters params) throws CertificateException {
336         try {
337             setDate(params);
338 
339             // do the validation
340             CertPathValidator validator = CertPathValidator.getInstance(&quot;PKIX&quot;);
341             CertPath path = factory.generateCertPath(Arrays.asList(chain));
342             certPathLength = chain.length;
343             PKIXCertPathValidatorResult result =
344                 (PKIXCertPathValidatorResult)validator.validate(path, params);
345 
346             return toArray(path, result.getTrustAnchor());
347         } catch (GeneralSecurityException e) {
348             throw new ValidatorException
349                 (&quot;PKIX path validation failed: &quot; + e.toString(), e);
350         }
351     }
352 



































353     private X509Certificate[] doBuild(X509Certificate[] chain,
354         Collection&lt;X509Certificate&gt; otherCerts,
355         PKIXBuilderParameters params) throws CertificateException {
356 
357         try {
358             setDate(params);
359 
360             // setup target constraints
361             X509CertSelector selector = new X509CertSelector();
362             selector.setCertificate(chain[0]);
363             params.setTargetCertConstraints(selector);
364 
365             // setup CertStores
366             Collection&lt;X509Certificate&gt; certs =
367                                         new ArrayList&lt;X509Certificate&gt;();
368             certs.addAll(Arrays.asList(chain));
369             if (otherCerts != null) {
370                 certs.addAll(otherCerts);
371             }
372             CertStore store = CertStore.getInstance(&quot;Collection&quot;,
</pre>
<hr />
<pre>
382         } catch (GeneralSecurityException e) {
383             throw new ValidatorException
384                 (&quot;PKIX path building failed: &quot; + e.toString(), e);
385         }
386     }
387 
388     /**
389      * For OCSP Stapling, add responses that came in during the handshake
390      * into a {@code PKIXRevocationChecker} so we can evaluate them.
391      *
392      * @param pkixParams the pkixParameters object that will be used in
393      * path validation.
394      * @param chain the chain of certificates to verify
395      * @param responseList a {@code List} of zero or more byte arrays, each
396      * one being a DER-encoded OCSP response (per RFC 6960).  Entries
397      * in the List must match the order of the certificates in the
398      * chain parameter.
399      */
400     private static void addResponses(PKIXBuilderParameters pkixParams,
401             X509Certificate[] chain, List&lt;byte[]&gt; responseList) {
<span class="line-modified">402 </span>
<span class="line-modified">403         if (pkixParams.isRevocationEnabled()) {</span>
<span class="line-modified">404             try {</span>
<span class="line-modified">405                 // Make a modifiable copy of the CertPathChecker list</span>
<span class="line-modified">406                 PKIXRevocationChecker revChecker = null;</span>
<span class="line-modified">407                 List&lt;PKIXCertPathChecker&gt; checkerList =</span>
<span class="line-modified">408                         new ArrayList&lt;&gt;(pkixParams.getCertPathCheckers());</span>
<span class="line-modified">409 </span>
<span class="line-modified">410                 // Find the first PKIXRevocationChecker in the list</span>
<span class="line-modified">411                 for (PKIXCertPathChecker checker : checkerList) {</span>
<span class="line-modified">412                     if (checker instanceof PKIXRevocationChecker) {</span>
<span class="line-modified">413                         revChecker = (PKIXRevocationChecker)checker;</span>
<span class="line-modified">414                         break;</span>
<span class="line-removed">415                     }</span>
416                 }

417 
<span class="line-modified">418                 // If we still haven&#39;t found one, make one</span>
<span class="line-modified">419                 if (revChecker == null) {</span>






420                     revChecker = (PKIXRevocationChecker)CertPathValidator.
421                             getInstance(&quot;PKIX&quot;).getRevocationChecker();
<span class="line-modified">422                     checkerList.add(revChecker);</span>


423                 }

424 
<span class="line-modified">425                 // Each response in the list should be in parallel with</span>
<span class="line-modified">426                 // the certificate list.  If there is a zero-length response</span>
<span class="line-modified">427                 // treat it as being absent.  If the user has provided their</span>
<span class="line-modified">428                 // own PKIXRevocationChecker with pre-populated responses, do</span>
<span class="line-modified">429                 // not overwrite them with the ones from the handshake.</span>
<span class="line-modified">430                 Map&lt;X509Certificate, byte[]&gt; responseMap =</span>
<span class="line-modified">431                         revChecker.getOcspResponses();</span>
<span class="line-modified">432                 int limit = Integer.min(chain.length, responseList.size());</span>
<span class="line-modified">433                 for (int idx = 0; idx &lt; limit; idx++) {</span>
<span class="line-modified">434                     byte[] respBytes = responseList.get(idx);</span>
<span class="line-modified">435                     if (respBytes != null &amp;&amp; respBytes.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">436                             !responseMap.containsKey(chain[idx])) {</span>
<span class="line-modified">437                         responseMap.put(chain[idx], respBytes);</span>
<span class="line-removed">438                     }</span>
439                 }


440 
<span class="line-modified">441                 // Add the responses and push it all back into the</span>
<span class="line-modified">442                 // PKIXBuilderParameters</span>
<span class="line-modified">443                 revChecker.setOcspResponses(responseMap);</span>


444                 pkixParams.setCertPathCheckers(checkerList);
<span class="line-removed">445             } catch (NoSuchAlgorithmException exc) {</span>
<span class="line-removed">446                 // This should not occur, but if it does happen then</span>
<span class="line-removed">447                 // stapled OCSP responses won&#39;t be part of revocation checking.</span>
<span class="line-removed">448                 // Clients can still fall back to other means of revocation</span>
<span class="line-removed">449                 // checking.</span>
450             }





451         }
452     }
453 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.validator;
 27 
 28 import java.util.*;
 29 
 30 import java.security.*;
 31 import java.security.cert.*;
 32 
 33 import javax.security.auth.x500.X500Principal;
 34 import sun.security.action.GetBooleanAction;
<span class="line-added"> 35 import sun.security.action.GetPropertyAction;</span>
 36 import sun.security.provider.certpath.AlgorithmChecker;
 37 import sun.security.provider.certpath.PKIXExtendedParameters;
 38 
 39 /**
 40  * Validator implementation built on the PKIX CertPath API. This
 41  * implementation will be emphasized going forward.
 42  * &lt;p&gt;
 43  * Note that the validate() implementation tries to use a PKIX validator
 44  * if that appears possible and a PKIX builder otherwise. This increases
 45  * performance and currently also leads to better exception messages
 46  * in case of failures.
 47  * &lt;p&gt;
 48  * {@code PKIXValidator} objects are immutable once they have been created.
 49  * Please DO NOT add methods that can change the state of an instance once
 50  * it has been created.
 51  *
 52  * @author Andreas Sterbenz
 53  */
 54 public final class PKIXValidator extends Validator {
 55 
 56     /**
 57      * Flag indicating whether to enable revocation check for the PKIX trust
 58      * manager. Typically, this will only work if the PKIX implementation
 59      * supports CRL distribution points as we do not manually setup CertStores.
 60      */
 61     private static final boolean checkTLSRevocation = GetBooleanAction
 62             .privilegedGetProperty(&quot;com.sun.net.ssl.checkRevocation&quot;);
 63 
<span class="line-added"> 64     /**</span>
<span class="line-added"> 65      * System property that if set (or set to &quot;true&quot;), allows trust anchor</span>
<span class="line-added"> 66      * certificates to be used if they do not have the proper CA extensions.</span>
<span class="line-added"> 67      * Set to false if prop is not set, or set to any other value.</span>
<span class="line-added"> 68      */</span>
<span class="line-added"> 69     private static final boolean ALLOW_NON_CA_ANCHOR = allowNonCaAnchor();</span>
<span class="line-added"> 70     private static boolean allowNonCaAnchor() {</span>
<span class="line-added"> 71         String prop = GetPropertyAction</span>
<span class="line-added"> 72             .privilegedGetProperty(&quot;jdk.security.allowNonCaAnchor&quot;);</span>
<span class="line-added"> 73         return prop != null &amp;&amp; (prop.isEmpty() || prop.equalsIgnoreCase(&quot;true&quot;));</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75 </span>
 76     private final Set&lt;X509Certificate&gt; trustedCerts;
 77     private final PKIXBuilderParameters parameterTemplate;
 78     private int certPathLength = -1;
 79 
 80     // needed only for the validator
 81     private final Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; trustedSubjects;
 82     private final CertificateFactory factory;
 83 
 84     private final boolean plugin;
 85 
 86     PKIXValidator(String variant, Collection&lt;X509Certificate&gt; trustedCerts) {
 87         super(TYPE_PKIX, variant);
 88         this.trustedCerts = (trustedCerts instanceof Set) ?
 89                             (Set&lt;X509Certificate&gt;)trustedCerts :
 90                             new HashSet&lt;X509Certificate&gt;(trustedCerts);
 91 
 92         Set&lt;TrustAnchor&gt; trustAnchors = new HashSet&lt;&gt;();
 93         for (X509Certificate cert : trustedCerts) {
 94             trustAnchors.add(new TrustAnchor(cert, null));
 95         }
</pre>
<hr />
<pre>
139      *    tied to those DNs.
140      */
141     private Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; setTrustedSubjects() {
142         Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; subjectMap = new HashMap&lt;&gt;();
143 
144         for (X509Certificate cert : trustedCerts) {
145             X500Principal dn = cert.getSubjectX500Principal();
146             List&lt;PublicKey&gt; keys;
147             if (subjectMap.containsKey(dn)) {
148                 keys = subjectMap.get(dn);
149             } else {
150                 keys = new ArrayList&lt;PublicKey&gt;();
151                 subjectMap.put(dn, keys);
152             }
153             keys.add(cert.getPublicKey());
154         }
155 
156         return subjectMap;
157     }
158 
<span class="line-added">159     @Override</span>
160     public Collection&lt;X509Certificate&gt; getTrustedCertificates() {
161         return trustedCerts;
162     }
163 
164     /**
165      * Returns the length of the last certification path that is validated by
166      * CertPathValidator. This is intended primarily as a callback mechanism
167      * for PKIXCertPathCheckers to determine the length of the certification
168      * path that is being validated. It is necessary since engineValidate()
169      * may modify the length of the path.
170      *
171      * @return the length of the last certification path passed to
172      *   CertPathValidator.validate, or -1 if it has not been invoked yet
173      */
174     public int getCertPathLength() { // mutable, should be private
175         return certPathLength;
176     }
177 
178     /**
179      * Set J2SE global default PKIX parameters. Currently, hardcoded to disable
</pre>
<hr />
<pre>
191     /**
192      * Return the PKIX parameters used by this instance. An application may
193      * modify the parameters but must make sure not to perform any concurrent
194      * validations.
195      */
196     public PKIXBuilderParameters getParameters() { // mutable, should be private
197         return parameterTemplate;
198     }
199 
200     @Override
201     X509Certificate[] engineValidate(X509Certificate[] chain,
202             Collection&lt;X509Certificate&gt; otherCerts,
203             List&lt;byte[]&gt; responseList,
204             AlgorithmConstraints constraints,
205             Object parameter) throws CertificateException {
206         if ((chain == null) || (chain.length == 0)) {
207             throw new CertificateException
208                 (&quot;null or zero-length certificate chain&quot;);
209         }
210 
<span class="line-added">211 </span>
212         // Use PKIXExtendedParameters for timestamp and variant additions
213         PKIXBuilderParameters pkixParameters = null;
214         try {
215             pkixParameters = new PKIXExtendedParameters(
216                     (PKIXBuilderParameters) parameterTemplate.clone(),
217                     (parameter instanceof Timestamp) ?
218                             (Timestamp) parameter : null,
219                     variant);
220         } catch (InvalidAlgorithmParameterException e) {
221             // ignore exception
222         }
223 
224         // add new algorithm constraints checker
225         if (constraints != null) {
226             pkixParameters.addCertPathChecker(
227                     new AlgorithmChecker(constraints, null, variant));
228         }
229 
230         // attach it to the PKIXBuilderParameters.
231         if (!responseList.isEmpty()) {
232             addResponses(pkixParameters, chain, responseList);
233         }
234 
235         // check that chain is in correct order and check if chain contains
236         // trust anchor
237         X500Principal prevIssuer = null;
238         for (int i = 0; i &lt; chain.length; i++) {
239             X509Certificate cert = chain[i];
240             X500Principal dn = cert.getSubjectX500Principal();




241 
<span class="line-modified">242             if (i == 0) {</span>
<span class="line-modified">243                 if (trustedCerts.contains(cert)) {</span>









244                     return new X509Certificate[] {chain[0]};
245                 }
<span class="line-modified">246             } else {</span>
<span class="line-modified">247                 if (!dn.equals(prevIssuer)) {</span>
<span class="line-modified">248                     // chain is not ordered correctly, call builder instead</span>
<span class="line-modified">249                     return doBuild(chain, otherCerts, pkixParameters);</span>
<span class="line-added">250                 }</span>
<span class="line-added">251                 // Check if chain[i] is already trusted. It may be inside</span>
<span class="line-added">252                 // trustedCerts, or has the same dn and public key as a cert</span>
<span class="line-added">253                 // inside trustedCerts. The latter happens when a CA has</span>
<span class="line-added">254                 // updated its cert with a stronger signature algorithm in JRE</span>
<span class="line-added">255                 // but the weak one is still in circulation.</span>
<span class="line-added">256                 if (trustedCerts.contains(cert) ||          // trusted cert</span>
<span class="line-added">257                         (trustedSubjects.containsKey(dn) &amp;&amp; // replacing ...</span>
<span class="line-added">258                          trustedSubjects.get(dn).contains(  // ... weak cert</span>
<span class="line-added">259                             cert.getPublicKey()))) {</span>
<span class="line-added">260                     // Remove and call validator on partial chain [0 .. i-1]</span>
<span class="line-added">261                     X509Certificate[] newChain = new X509Certificate[i];</span>
<span class="line-added">262                     System.arraycopy(chain, 0, newChain, 0, i);</span>
<span class="line-added">263                     return doValidate(newChain, pkixParameters);</span>
<span class="line-added">264                 }</span>
265             }
266             prevIssuer = cert.getIssuerX500Principal();
267         }
268 
269         // apparently issued by trust anchor?
270         X509Certificate last = chain[chain.length - 1];
271         X500Principal issuer = last.getIssuerX500Principal();
272         X500Principal subject = last.getSubjectX500Principal();
273         if (trustedSubjects.containsKey(issuer) &amp;&amp;
274                 isSignatureValid(trustedSubjects.get(issuer), last)) {
275             return doValidate(chain, pkixParameters);
276         }
277 
278         // don&#39;t fallback to builder if called from plugin/webstart
279         if (plugin) {
280             // Validate chain even if no trust anchor is found. This
281             // allows plugin/webstart to make sure the chain is
282             // otherwise valid
283             if (chain.length &gt; 1) {
284                 X509Certificate[] newChain =
</pre>
<hr />
<pre>
307     }
308 
309     private boolean isSignatureValid(List&lt;PublicKey&gt; keys,
310             X509Certificate sub) {
311         if (plugin) {
312             for (PublicKey key: keys) {
313                 try {
314                     sub.verify(key);
315                     return true;
316                 } catch (Exception ex) {
317                     continue;
318                 }
319             }
320             return false;
321         }
322         return true; // only check if PLUGIN is set
323     }
324 
325     private static X509Certificate[] toArray(CertPath path, TrustAnchor anchor)
326             throws CertificateException {




327         X509Certificate trustedCert = anchor.getTrustedCert();
328         if (trustedCert == null) {
329             throw new ValidatorException
330                 (&quot;TrustAnchor must be specified as certificate&quot;);
331         }
<span class="line-added">332 </span>
<span class="line-added">333         verifyTrustAnchor(trustedCert);</span>
<span class="line-added">334 </span>
<span class="line-added">335         List&lt;? extends java.security.cert.Certificate&gt; list =</span>
<span class="line-added">336                                                 path.getCertificates();</span>
<span class="line-added">337         X509Certificate[] chain = new X509Certificate[list.size() + 1];</span>
<span class="line-added">338         list.toArray(chain);</span>
339         chain[chain.length - 1] = trustedCert;
340         return chain;
341     }
342 
343     /**
344      * Set the check date (for debugging).
345      */
346     private void setDate(PKIXBuilderParameters params) {
347         @SuppressWarnings(&quot;deprecation&quot;)
348         Date date = validationDate;
349         if (date != null) {
350             params.setDate(date);
351         }
352     }
353 
354     private X509Certificate[] doValidate(X509Certificate[] chain,
355             PKIXBuilderParameters params) throws CertificateException {
356         try {
357             setDate(params);
358 
359             // do the validation
360             CertPathValidator validator = CertPathValidator.getInstance(&quot;PKIX&quot;);
361             CertPath path = factory.generateCertPath(Arrays.asList(chain));
362             certPathLength = chain.length;
363             PKIXCertPathValidatorResult result =
364                 (PKIXCertPathValidatorResult)validator.validate(path, params);
365 
366             return toArray(path, result.getTrustAnchor());
367         } catch (GeneralSecurityException e) {
368             throw new ValidatorException
369                 (&quot;PKIX path validation failed: &quot; + e.toString(), e);
370         }
371     }
372 
<span class="line-added">373     /**</span>
<span class="line-added">374      * Verify that a trust anchor certificate is a CA certificate.</span>
<span class="line-added">375      */</span>
<span class="line-added">376     private static void verifyTrustAnchor(X509Certificate trustedCert)</span>
<span class="line-added">377         throws ValidatorException {</span>
<span class="line-added">378 </span>
<span class="line-added">379         // skip check if jdk.security.allowNonCAAnchor system property is set</span>
<span class="line-added">380         if (ALLOW_NON_CA_ANCHOR) {</span>
<span class="line-added">381             return;</span>
<span class="line-added">382         }</span>
<span class="line-added">383 </span>
<span class="line-added">384         // allow v1 trust anchor certificates</span>
<span class="line-added">385         if (trustedCert.getVersion() &lt; 3) {</span>
<span class="line-added">386             return;</span>
<span class="line-added">387         }</span>
<span class="line-added">388 </span>
<span class="line-added">389         // check that the BasicConstraints cA field is not set to false</span>
<span class="line-added">390         if (trustedCert.getBasicConstraints() == -1) {</span>
<span class="line-added">391             throw new ValidatorException</span>
<span class="line-added">392                 (&quot;TrustAnchor with subject \&quot;&quot; +</span>
<span class="line-added">393                  trustedCert.getSubjectX500Principal() +</span>
<span class="line-added">394                  &quot;\&quot; is not a CA certificate&quot;);</span>
<span class="line-added">395         }</span>
<span class="line-added">396 </span>
<span class="line-added">397         // check that the KeyUsage extension, if included, asserts the</span>
<span class="line-added">398         // keyCertSign bit</span>
<span class="line-added">399         boolean[] keyUsageBits = trustedCert.getKeyUsage();</span>
<span class="line-added">400         if (keyUsageBits != null &amp;&amp; !keyUsageBits[5]) {</span>
<span class="line-added">401             throw new ValidatorException</span>
<span class="line-added">402                 (&quot;TrustAnchor with subject \&quot;&quot; +</span>
<span class="line-added">403                  trustedCert.getSubjectX500Principal() +</span>
<span class="line-added">404                  &quot;\&quot; does not have keyCertSign bit set in KeyUsage extension&quot;);</span>
<span class="line-added">405         }</span>
<span class="line-added">406     }</span>
<span class="line-added">407 </span>
408     private X509Certificate[] doBuild(X509Certificate[] chain,
409         Collection&lt;X509Certificate&gt; otherCerts,
410         PKIXBuilderParameters params) throws CertificateException {
411 
412         try {
413             setDate(params);
414 
415             // setup target constraints
416             X509CertSelector selector = new X509CertSelector();
417             selector.setCertificate(chain[0]);
418             params.setTargetCertConstraints(selector);
419 
420             // setup CertStores
421             Collection&lt;X509Certificate&gt; certs =
422                                         new ArrayList&lt;X509Certificate&gt;();
423             certs.addAll(Arrays.asList(chain));
424             if (otherCerts != null) {
425                 certs.addAll(otherCerts);
426             }
427             CertStore store = CertStore.getInstance(&quot;Collection&quot;,
</pre>
<hr />
<pre>
437         } catch (GeneralSecurityException e) {
438             throw new ValidatorException
439                 (&quot;PKIX path building failed: &quot; + e.toString(), e);
440         }
441     }
442 
443     /**
444      * For OCSP Stapling, add responses that came in during the handshake
445      * into a {@code PKIXRevocationChecker} so we can evaluate them.
446      *
447      * @param pkixParams the pkixParameters object that will be used in
448      * path validation.
449      * @param chain the chain of certificates to verify
450      * @param responseList a {@code List} of zero or more byte arrays, each
451      * one being a DER-encoded OCSP response (per RFC 6960).  Entries
452      * in the List must match the order of the certificates in the
453      * chain parameter.
454      */
455     private static void addResponses(PKIXBuilderParameters pkixParams,
456             X509Certificate[] chain, List&lt;byte[]&gt; responseList) {
<span class="line-modified">457         try {</span>
<span class="line-modified">458             boolean createdRevChk = false;</span>
<span class="line-modified">459 </span>
<span class="line-modified">460             // Obtain the current CertPathChecker list</span>
<span class="line-modified">461             PKIXRevocationChecker revChecker = null;</span>
<span class="line-modified">462             List&lt;PKIXCertPathChecker&gt; checkerList =</span>
<span class="line-modified">463                     pkixParams.getCertPathCheckers();</span>
<span class="line-modified">464 </span>
<span class="line-modified">465             // Find the first PKIXRevocationChecker in the list</span>
<span class="line-modified">466             for (PKIXCertPathChecker checker : checkerList) {</span>
<span class="line-modified">467                 if (checker instanceof PKIXRevocationChecker) {</span>
<span class="line-modified">468                     revChecker = (PKIXRevocationChecker)checker;</span>
<span class="line-modified">469                     break;</span>

470                 }
<span class="line-added">471             }</span>
472 
<span class="line-modified">473             // If we still haven&#39;t found one, make one, unless revocation</span>
<span class="line-modified">474             // is disabled - then there&#39;s no point adding OCSP responses.</span>
<span class="line-added">475             // If a PKIXRevocationChecker was added externally, then we</span>
<span class="line-added">476             // must add the responses since revocation checking is performed</span>
<span class="line-added">477             // independent of the revocation flag (per the</span>
<span class="line-added">478             // PKIXRevocationChecker spec).</span>
<span class="line-added">479             if (revChecker == null) {</span>
<span class="line-added">480                 if (pkixParams.isRevocationEnabled()) {</span>
481                     revChecker = (PKIXRevocationChecker)CertPathValidator.
482                             getInstance(&quot;PKIX&quot;).getRevocationChecker();
<span class="line-modified">483                     createdRevChk = true;</span>
<span class="line-added">484                 } else {</span>
<span class="line-added">485                     return;</span>
486                 }
<span class="line-added">487             }</span>
488 
<span class="line-modified">489             // Each response in the list should be in parallel with</span>
<span class="line-modified">490             // the certificate list.  If there is a zero-length response</span>
<span class="line-modified">491             // treat it as being absent.  If the user has provided their</span>
<span class="line-modified">492             // own PKIXRevocationChecker with pre-populated responses, do</span>
<span class="line-modified">493             // not overwrite them with the ones from the handshake.</span>
<span class="line-modified">494             Map&lt;X509Certificate, byte[]&gt; responseMap =</span>
<span class="line-modified">495                     revChecker.getOcspResponses();</span>
<span class="line-modified">496             int limit = Integer.min(chain.length, responseList.size());</span>
<span class="line-modified">497             for (int idx = 0; idx &lt; limit; idx++) {</span>
<span class="line-modified">498                 byte[] respBytes = responseList.get(idx);</span>
<span class="line-modified">499                 if (respBytes != null &amp;&amp; respBytes.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">500                         !responseMap.containsKey(chain[idx])) {</span>
<span class="line-modified">501                     responseMap.put(chain[idx], respBytes);</span>

502                 }
<span class="line-added">503             }</span>
<span class="line-added">504             revChecker.setOcspResponses(responseMap);</span>
505 
<span class="line-modified">506             // Add the responses and push it all back into the</span>
<span class="line-modified">507             // PKIXBuilderParameters</span>
<span class="line-modified">508             if (createdRevChk) {</span>
<span class="line-added">509                 pkixParams.addCertPathChecker(revChecker);</span>
<span class="line-added">510             } else {</span>
511                 pkixParams.setCertPathCheckers(checkerList);





512             }
<span class="line-added">513         } catch (NoSuchAlgorithmException exc) {</span>
<span class="line-added">514             // This should not occur, but if it does happen then</span>
<span class="line-added">515             // stapled OCSP responses won&#39;t be part of revocation checking.</span>
<span class="line-added">516             // Clients can still fall back to other means of revocation</span>
<span class="line-added">517             // checking.</span>
518         }
519     }
520 }
</pre>
</td>
</tr>
</table>
<center><a href="../util/SignatureUtil.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ValidatorException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
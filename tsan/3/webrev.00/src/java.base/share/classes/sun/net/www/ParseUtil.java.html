<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/net/www/ParseUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www;
 27 
 28 import java.io.File;
 29 import java.net.MalformedURLException;
 30 import java.net.URI;
 31 import java.net.URISyntaxException;
 32 import java.net.URL;
 33 import java.nio.ByteBuffer;
 34 import java.nio.CharBuffer;
 35 import java.nio.charset.CharacterCodingException;
 36 import java.nio.charset.CharsetDecoder;
 37 import java.nio.charset.CoderResult;
 38 import java.nio.charset.CodingErrorAction;
 39 
 40 import sun.nio.cs.ThreadLocalCoders;
 41 import sun.nio.cs.UTF_8;
 42 
 43 /**
 44  * A class that contains useful routines common to sun.net.www
 45  * @author  Mike McCloskey
 46  */
 47 
 48 public final class ParseUtil {
 49 
 50     private ParseUtil() {}
 51 
 52     /**
 53      * Constructs an encoded version of the specified path string suitable
 54      * for use in the construction of a URL.
 55      *
 56      * A path separator is replaced by a forward slash. The string is UTF8
 57      * encoded. The % escape sequence is used for characters that are above
 58      * 0x7F or those defined in RFC2396 as reserved or excluded in the path
 59      * component of a URL.
 60      */
 61     public static String encodePath(String path) {
 62         return encodePath(path, true);
 63     }
 64     /*
 65      * flag indicates whether path uses platform dependent
 66      * File.separatorChar or not. True indicates path uses platform
 67      * dependent File.separatorChar.
 68      */
 69     public static String encodePath(String path, boolean flag) {
 70         if (flag &amp;&amp; File.separatorChar != &#39;/&#39;) {
 71             return encodePath(path, 0, File.separatorChar);
 72         } else {
 73             int index = firstEncodeIndex(path);
 74             if (index &gt; -1) {
 75                 return encodePath(path, index, &#39;/&#39;);
 76             } else {
 77                 return path;
 78             }
 79         }
 80     }
 81 
 82     private static int firstEncodeIndex(String path) {
 83         int len = path.length();
 84         for (int i = 0; i &lt; len; i++) {
 85             char c = path.charAt(i);
 86             // Ordering in the following test is performance sensitive,
 87             // and typically paths have most chars in the a-z range, then
 88             // in the symbol range &#39;&amp;&#39;-&#39;:&#39; (includes &#39;.&#39;, &#39;/&#39; and &#39;0&#39;-&#39;9&#39;)
 89             // and more rarely in the A-Z range.
 90             if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39; ||
 91                 c &gt;= &#39;&amp;&#39; &amp;&amp; c &lt;= &#39;:&#39; ||
 92                 c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {
 93                 continue;
 94             } else if (c &gt; 0x007F || match(c, L_ENCODED, H_ENCODED)) {
 95                 return i;
 96             }
 97         }
 98         return -1;
 99     }
100 
101     private static String encodePath(String path, int index, char sep) {
102         char[] pathCC = path.toCharArray();
103         char[] retCC = new char[pathCC.length * 2 + 16 - index];
104         if (index &gt; 0) {
105             System.arraycopy(pathCC, 0, retCC, 0, index);
106         }
107         int retLen = index;
108 
109         for (int i = index; i &lt; pathCC.length; i++) {
110             char c = pathCC[i];
111             if (c == sep)
112                 retCC[retLen++] = &#39;/&#39;;
113             else {
114                 if (c &lt;= 0x007F) {
115                     if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39; ||
116                         c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39; ||
117                         c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
118                         retCC[retLen++] = c;
119                     } else if (match(c, L_ENCODED, H_ENCODED)) {
120                         retLen = escape(retCC, c, retLen);
121                     } else {
122                         retCC[retLen++] = c;
123                     }
124                 } else if (c &gt; 0x07FF) {
125                     retLen = escape(retCC, (char)(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)), retLen);
126                     retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  6) &amp; 0x3F)), retLen);
127                     retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  0) &amp; 0x3F)), retLen);
128                 } else {
129                     retLen = escape(retCC, (char)(0xC0 | ((c &gt;&gt;  6) &amp; 0x1F)), retLen);
130                     retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  0) &amp; 0x3F)), retLen);
131                 }
132             }
133             //worst case scenario for character [0x7ff-] every single
134             //character will be encoded into 9 characters.
135             if (retLen + 9 &gt; retCC.length) {
136                 int newLen = retCC.length * 2 + 16;
137                 if (newLen &lt; 0) {
138                     newLen = Integer.MAX_VALUE;
139                 }
140                 char[] buf = new char[newLen];
141                 System.arraycopy(retCC, 0, buf, 0, retLen);
142                 retCC = buf;
143             }
144         }
145         return new String(retCC, 0, retLen);
146     }
147 
148     /**
149      * Appends the URL escape sequence for the specified char to the
150      * specified character array.
151      */
152     private static int escape(char[] cc, char c, int index) {
153         cc[index++] = &#39;%&#39;;
154         cc[index++] = Character.forDigit((c &gt;&gt; 4) &amp; 0xF, 16);
155         cc[index++] = Character.forDigit(c &amp; 0xF, 16);
156         return index;
157     }
158 
159     /**
160      * Un-escape and return the character at position i in string s.
161      */
162     private static byte unescape(String s, int i) {
163         return (byte) Integer.parseInt(s, i + 1, i + 3, 16);
164     }
165 
166 
167     /**
168      * Returns a new String constructed from the specified String by replacing
169      * the URL escape sequences and UTF8 encoding with the characters they
170      * represent.
171      */
172     public static String decode(String s) {
173         int n = s.length();
174         if ((n == 0) || (s.indexOf(&#39;%&#39;) &lt; 0))
175             return s;
176 
177         StringBuilder sb = new StringBuilder(n);
178         ByteBuffer bb = ByteBuffer.allocate(n);
179         CharBuffer cb = CharBuffer.allocate(n);
180         CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)
181             .onMalformedInput(CodingErrorAction.REPORT)
182             .onUnmappableCharacter(CodingErrorAction.REPORT);
183 
184         char c = s.charAt(0);
185         for (int i = 0; i &lt; n;) {
186             assert c == s.charAt(i);
187             if (c != &#39;%&#39;) {
188                 sb.append(c);
189                 if (++i &gt;= n)
190                     break;
191                 c = s.charAt(i);
192                 continue;
193             }
194             bb.clear();
195             int ui = i;
196             for (;;) {
197                 assert (n - i &gt;= 2);
198                 try {
199                     bb.put(unescape(s, i));
200                 } catch (NumberFormatException e) {
201                     throw new IllegalArgumentException();
202                 }
203                 i += 3;
204                 if (i &gt;= n)
205                     break;
206                 c = s.charAt(i);
207                 if (c != &#39;%&#39;)
208                     break;
209             }
210             bb.flip();
211             cb.clear();
212             dec.reset();
213             CoderResult cr = dec.decode(bb, cb, true);
214             if (cr.isError())
215                 throw new IllegalArgumentException(&quot;Error decoding percent encoded characters&quot;);
216             cr = dec.flush(cb);
217             if (cr.isError())
218                 throw new IllegalArgumentException(&quot;Error decoding percent encoded characters&quot;);
219             sb.append(cb.flip().toString());
220         }
221 
222         return sb.toString();
223     }
224 
225     /**
226      * Returns a canonical version of the specified string.
227      */
228     public static String canonizeString(String file) {
229         int len = file.length();
230         if (len == 0 || (file.indexOf(&quot;./&quot;) == -1 &amp;&amp; file.charAt(len - 1) != &#39;.&#39;)) {
231             return file;
232         } else {
233             return doCanonize(file);
234         }
235     }
236 
237     private static String doCanonize(String file) {
238         int i, lim;
239 
240         // Remove embedded /../
241         while ((i = file.indexOf(&quot;/../&quot;)) &gt;= 0) {
242             if ((lim = file.lastIndexOf(&#39;/&#39;, i - 1)) &gt;= 0) {
243                 file = file.substring(0, lim) + file.substring(i + 3);
244             } else {
245                 file = file.substring(i + 3);
246             }
247         }
248         // Remove embedded /./
249         while ((i = file.indexOf(&quot;/./&quot;)) &gt;= 0) {
250             file = file.substring(0, i) + file.substring(i + 2);
251         }
252         // Remove trailing ..
253         while (file.endsWith(&quot;/..&quot;)) {
254             i = file.indexOf(&quot;/..&quot;);
255             if ((lim = file.lastIndexOf(&#39;/&#39;, i - 1)) &gt;= 0) {
256                 file = file.substring(0, lim+1);
257             } else {
258                 file = file.substring(0, i);
259             }
260         }
261         // Remove trailing .
262         if (file.endsWith(&quot;/.&quot;))
263             file = file.substring(0, file.length() -1);
264 
265         return file;
266     }
267 
268     public static URL fileToEncodedURL(File file)
269         throws MalformedURLException
270     {
271         String path = file.getAbsolutePath();
272         path = ParseUtil.encodePath(path);
273         if (!path.startsWith(&quot;/&quot;)) {
274             path = &quot;/&quot; + path;
275         }
276         if (!path.endsWith(&quot;/&quot;) &amp;&amp; file.isDirectory()) {
277             path = path + &quot;/&quot;;
278         }
279         return new URL(&quot;file&quot;, &quot;&quot;, path);
280     }
281 
282     public static java.net.URI toURI(URL url) {
283         String protocol = url.getProtocol();
284         String auth = url.getAuthority();
285         String path = url.getPath();
286         String query = url.getQuery();
287         String ref = url.getRef();
288         if (path != null &amp;&amp; !(path.startsWith(&quot;/&quot;)))
289             path = &quot;/&quot; + path;
290 
291         //
292         // In java.net.URI class, a port number of -1 implies the default
293         // port number. So get it stripped off before creating URI instance.
294         //
295         if (auth != null &amp;&amp; auth.endsWith(&quot;:-1&quot;))
296             auth = auth.substring(0, auth.length() - 3);
297 
298         java.net.URI uri;
299         try {
300             uri = createURI(protocol, auth, path, query, ref);
301         } catch (java.net.URISyntaxException e) {
302             uri = null;
303         }
304         return uri;
305     }
306 
307     //
308     // createURI() and its auxiliary code are cloned from java.net.URI.
309     // Most of the code are just copy and paste, except that quote()
310     // has been modified to avoid double-escape.
311     //
312     // Usually it is unacceptable, but we&#39;re forced to do it because
313     // otherwise we need to change public API, namely java.net.URI&#39;s
314     // multi-argument constructors. It turns out that the changes cause
315     // incompatibilities so can&#39;t be done.
316     //
317     private static URI createURI(String scheme,
318                                  String authority,
319                                  String path,
320                                  String query,
321                                  String fragment) throws URISyntaxException
322     {
323         String s = toString(scheme, null,
324                             authority, null, null, -1,
325                             path, query, fragment);
326         checkPath(s, scheme, path);
327         return new URI(s);
328     }
329 
330     private static String toString(String scheme,
331                             String opaquePart,
332                             String authority,
333                             String userInfo,
334                             String host,
335                             int port,
336                             String path,
337                             String query,
338                             String fragment)
339     {
340         StringBuilder sb = new StringBuilder();
341         if (scheme != null) {
342             sb.append(scheme);
343             sb.append(&#39;:&#39;);
344         }
345         appendSchemeSpecificPart(sb, opaquePart,
346                                  authority, userInfo, host, port,
347                                  path, query);
348         appendFragment(sb, fragment);
349         return sb.toString();
350     }
351 
352     private static void appendSchemeSpecificPart(StringBuilder sb,
353                                           String opaquePart,
354                                           String authority,
355                                           String userInfo,
356                                           String host,
357                                           int port,
358                                           String path,
359                                           String query)
360     {
361         if (opaquePart != null) {
362             /* check if SSP begins with an IPv6 address
363              * because we must not quote a literal IPv6 address
364              */
365             if (opaquePart.startsWith(&quot;//[&quot;)) {
366                 int end =  opaquePart.indexOf(&#39;]&#39;);
367                 if (end != -1 &amp;&amp; opaquePart.indexOf(&#39;:&#39;)!=-1) {
368                     String doquote, dontquote;
369                     if (end == opaquePart.length()) {
370                         dontquote = opaquePart;
371                         doquote = &quot;&quot;;
372                     } else {
373                         dontquote = opaquePart.substring(0,end+1);
374                         doquote = opaquePart.substring(end+1);
375                     }
376                     sb.append (dontquote);
377                     sb.append(quote(doquote, L_URIC, H_URIC));
378                 }
379             } else {
380                 sb.append(quote(opaquePart, L_URIC, H_URIC));
381             }
382         } else {
383             appendAuthority(sb, authority, userInfo, host, port);
384             if (path != null)
385                 sb.append(quote(path, L_PATH, H_PATH));
386             if (query != null) {
387                 sb.append(&#39;?&#39;);
388                 sb.append(quote(query, L_URIC, H_URIC));
389             }
390         }
391     }
392 
393     private static void appendAuthority(StringBuilder sb,
394                                  String authority,
395                                  String userInfo,
396                                  String host,
397                                  int port)
398     {
399         if (host != null) {
400             sb.append(&quot;//&quot;);
401             if (userInfo != null) {
402                 sb.append(quote(userInfo, L_USERINFO, H_USERINFO));
403                 sb.append(&#39;@&#39;);
404             }
405             boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)
406                                     &amp;&amp; !host.startsWith(&quot;[&quot;)
407                                     &amp;&amp; !host.endsWith(&quot;]&quot;));
408             if (needBrackets) sb.append(&#39;[&#39;);
409             sb.append(host);
410             if (needBrackets) sb.append(&#39;]&#39;);
411             if (port != -1) {
412                 sb.append(&#39;:&#39;);
413                 sb.append(port);
414             }
415         } else if (authority != null) {
416             sb.append(&quot;//&quot;);
417             if (authority.startsWith(&quot;[&quot;)) {
418                 int end = authority.indexOf(&#39;]&#39;);
419                 if (end != -1 &amp;&amp; authority.indexOf(&#39;:&#39;)!=-1) {
420                     String doquote, dontquote;
421                     if (end == authority.length()) {
422                         dontquote = authority;
423                         doquote = &quot;&quot;;
424                     } else {
425                         dontquote = authority.substring(0,end+1);
426                         doquote = authority.substring(end+1);
427                     }
428                     sb.append (dontquote);
429                     sb.append(quote(doquote,
430                             L_REG_NAME | L_SERVER,
431                             H_REG_NAME | H_SERVER));
432                 }
433             } else {
434                 sb.append(quote(authority,
435                             L_REG_NAME | L_SERVER,
436                             H_REG_NAME | H_SERVER));
437             }
438         }
439     }
440 
441     private static void appendFragment(StringBuilder sb, String fragment) {
442         if (fragment != null) {
443             sb.append(&#39;#&#39;);
444             sb.append(quote(fragment, L_URIC, H_URIC));
445         }
446     }
447 
448     // Quote any characters in s that are not permitted
449     // by the given mask pair
450     //
451     private static String quote(String s, long lowMask, long highMask) {
452         int n = s.length();
453         StringBuilder sb = null;
454         boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);
455         for (int i = 0; i &lt; s.length(); i++) {
456             char c = s.charAt(i);
457             if (c &lt; &#39;\u0080&#39;) {
458                 if (!match(c, lowMask, highMask) &amp;&amp; !isEscaped(s, i)) {
459                     if (sb == null) {
460                         sb = new StringBuilder();
461                         sb.append(s, 0, i);
462                     }
463                     appendEscape(sb, (byte)c);
464                 } else {
465                     if (sb != null)
466                         sb.append(c);
467                 }
468             } else if (allowNonASCII
469                        &amp;&amp; (Character.isSpaceChar(c)
470                            || Character.isISOControl(c))) {
471                 if (sb == null) {
472                     sb = new StringBuilder();
473                     sb.append(s, 0, i);
474                 }
475                 appendEncoded(sb, c);
476             } else {
477                 if (sb != null)
478                     sb.append(c);
479             }
480         }
481         return (sb == null) ? s : sb.toString();
482     }
483 
484     //
485     // To check if the given string has an escaped triplet
486     // at the given position
487     //
488     private static boolean isEscaped(String s, int pos) {
489         if (s == null || (s.length() &lt;= (pos + 2)))
490             return false;
491 
492         return s.charAt(pos) == &#39;%&#39;
493                &amp;&amp; match(s.charAt(pos + 1), L_HEX, H_HEX)
494                &amp;&amp; match(s.charAt(pos + 2), L_HEX, H_HEX);
495     }
496 
497     private static void appendEncoded(StringBuilder sb, char c) {
498         ByteBuffer bb = null;
499         try {
500             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)
501                 .encode(CharBuffer.wrap(&quot;&quot; + c));
502         } catch (CharacterCodingException x) {
503             assert false;
504         }
505         while (bb.hasRemaining()) {
506             int b = bb.get() &amp; 0xff;
507             if (b &gt;= 0x80)
508                 appendEscape(sb, (byte)b);
509             else
510                 sb.append((char)b);
511         }
512     }
513 
514     private static final char[] hexDigits = {
515         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
516         &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
517     };
518 
519     private static void appendEscape(StringBuilder sb, byte b) {
520         sb.append(&#39;%&#39;);
521         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
522         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
523     }
524 
525     // Tell whether the given character is permitted by the given mask pair
526     private static boolean match(char c, long lowMask, long highMask) {
527         if (c &lt; 64)
528             return ((1L &lt;&lt; c) &amp; lowMask) != 0;
529         if (c &lt; 128)
530             return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;
531         return false;
532     }
533 
534     // If a scheme is given then the path, if given, must be absolute
535     //
536     private static void checkPath(String s, String scheme, String path)
537         throws URISyntaxException
538     {
539         if (scheme != null) {
540             if (path != null &amp;&amp; !path.isEmpty() &amp;&amp; path.charAt(0) != &#39;/&#39;)
541                 throw new URISyntaxException(s,
542                                              &quot;Relative path in absolute URI&quot;);
543         }
544     }
545 
546 
547     // -- Character classes for parsing --
548 
549     // To save startup time, we manually calculate the low-/highMask constants.
550     // For reference, the following methods were used to calculate the values:
551 
552     // Compute a low-order mask for the characters
553     // between first and last, inclusive
554     //    private static long lowMask(char first, char last) {
555     //        long m = 0;
556     //        int f = Math.max(Math.min(first, 63), 0);
557     //        int l = Math.max(Math.min(last, 63), 0);
558     //        for (int i = f; i &lt;= l; i++)
559     //            m |= 1L &lt;&lt; i;
560     //        return m;
561     //    }
562 
563     // Compute the low-order mask for the characters in the given string
564     //    private static long lowMask(String chars) {
565     //        int n = chars.length();
566     //        long m = 0;
567     //        for (int i = 0; i &lt; n; i++) {
568     //            char c = chars.charAt(i);
569     //            if (c &lt; 64)
570     //                m |= (1L &lt;&lt; c);
571     //        }
572     //        return m;
573     //    }
574 
575     // Compute a high-order mask for the characters
576     // between first and last, inclusive
577     //    private static long highMask(char first, char last) {
578     //        long m = 0;
579     //        int f = Math.max(Math.min(first, 127), 64) - 64;
580     //        int l = Math.max(Math.min(last, 127), 64) - 64;
581     //        for (int i = f; i &lt;= l; i++)
582     //            m |= 1L &lt;&lt; i;
583     //        return m;
584     //    }
585 
586     // Compute the high-order mask for the characters in the given string
587     //    private static long highMask(String chars) {
588     //        int n = chars.length();
589     //        long m = 0;
590     //        for (int i = 0; i &lt; n; i++) {
591     //            char c = chars.charAt(i);
592     //            if ((c &gt;= 64) &amp;&amp; (c &lt; 128))
593     //                m |= (1L &lt;&lt; (c - 64));
594     //        }
595     //        return m;
596     //     }
597 
598 
599     // Character-class masks
600 
601     // digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
602     //            &quot;8&quot; | &quot;9&quot;
603     private static final long L_DIGIT = 0x3FF000000000000L; // lowMask(&#39;0&#39;, &#39;9&#39;);
604     private static final long H_DIGIT = 0L;
605 
606     // hex           =  digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |
607     //                          &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
608     private static final long L_HEX = L_DIGIT;
609     private static final long H_HEX = 0x7E0000007EL; // highMask(&#39;A&#39;, &#39;F&#39;) | highMask(&#39;a&#39;, &#39;f&#39;);
610 
611     // upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |
612     //            &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |
613     //            &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;
614     private static final long L_UPALPHA = 0L;
615     private static final long H_UPALPHA = 0x7FFFFFEL; // highMask(&#39;A&#39;, &#39;Z&#39;);
616 
617     // lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |
618     //            &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |
619     //            &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;
620     private static final long L_LOWALPHA = 0L;
621     private static final long H_LOWALPHA = 0x7FFFFFE00000000L; // highMask(&#39;a&#39;, &#39;z&#39;);
622 
623     // alpha         = lowalpha | upalpha
624     private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;
625     private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;
626 
627     // alphanum      = alpha | digit
628     private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;
629     private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;
630 
631     // mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;&#39;&quot; |
632     //                 &quot;(&quot; | &quot;)&quot;
633     private static final long L_MARK = 0x678200000000L; // lowMask(&quot;-_.!~*&#39;()&quot;);
634     private static final long H_MARK = 0x4000000080000000L; // highMask(&quot;-_.!~*&#39;()&quot;);
635 
636     // unreserved    = alphanum | mark
637     private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;
638     private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;
639 
640     // reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |
641     //                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;
642     // Added per RFC2732: &quot;[&quot;, &quot;]&quot;
643     private static final long L_RESERVED = 0xAC00985000000000L; // lowMask(&quot;;/?:@&amp;=+$,[]&quot;);
644     private static final long H_RESERVED = 0x28000001L; // highMask(&quot;;/?:@&amp;=+$,[]&quot;);
645 
646     // The zero&#39;th bit is used to indicate that escape pairs and non-US-ASCII
647     // characters are allowed; this is handled by the scanEscape method below.
648     private static final long L_ESCAPED = 1L;
649     private static final long H_ESCAPED = 0L;
650 
651     // uric          = reserved | unreserved | escaped
652     private static final long L_URIC = L_RESERVED | L_UNRESERVED | L_ESCAPED;
653     private static final long H_URIC = H_RESERVED | H_UNRESERVED | H_ESCAPED;
654 
655     // pchar         = unreserved | escaped |
656     //                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
657     private static final long L_PCHAR
658             = L_UNRESERVED | L_ESCAPED | 0x2400185000000000L; // lowMask(&quot;:@&amp;=+$,&quot;);
659     private static final long H_PCHAR
660             = H_UNRESERVED | H_ESCAPED | 0x1L; // highMask(&quot;:@&amp;=+$,&quot;);
661 
662     // All valid path characters
663     private static final long L_PATH = L_PCHAR | 0x800800000000000L; // lowMask(&quot;;/&quot;);
664     private static final long H_PATH = H_PCHAR; // highMask(&quot;;/&quot;) == 0x0L;
665 
666     // Dash, for use in domainlabel and toplabel
667     private static final long L_DASH = 0x200000000000L; // lowMask(&quot;-&quot;);
668     private static final long H_DASH = 0x0L; // highMask(&quot;-&quot;);
669 
670     // userinfo      = *( unreserved | escaped |
671     //                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )
672     private static final long L_USERINFO
673             = L_UNRESERVED | L_ESCAPED | 0x2C00185000000000L; // lowMask(&quot;;:&amp;=+$,&quot;);
674     private static final long H_USERINFO
675             = H_UNRESERVED | H_ESCAPED; // | highMask(&quot;;:&amp;=+$,&quot;) == 0L;
676 
677     // reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |
678     //                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )
679     private static final long L_REG_NAME
680             = L_UNRESERVED | L_ESCAPED | 0x2C00185000000000L; // lowMask(&quot;$,;:@&amp;=+&quot;);
681     private static final long H_REG_NAME
682             = H_UNRESERVED | H_ESCAPED | 0x1L; // highMask(&quot;$,;:@&amp;=+&quot;);
683 
684     // All valid characters for server-based authorities
685     private static final long L_SERVER
686             = L_USERINFO | L_ALPHANUM | L_DASH | 0x400400000000000L; // lowMask(&quot;.:@[]&quot;);
687     private static final long H_SERVER
688             = H_USERINFO | H_ALPHANUM | H_DASH | 0x28000001L; // highMask(&quot;.:@[]&quot;);
689 
690     // Characters that are encoded in the path component of a URI.
691     //
692     // These characters are reserved in the path segment as described in
693     // RFC2396 section 3.3:
694     //     &quot;=&quot; | &quot;;&quot; | &quot;?&quot; | &quot;/&quot;
695     //
696     // These characters are defined as excluded in RFC2396 section 2.4.3
697     // and must be escaped if they occur in the data part of a URI:
698     //     &quot;#&quot; | &quot; &quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;%&quot; | &quot;\&quot;&quot; | &quot;{&quot; | &quot;}&quot; | &quot;|&quot; | &quot;\\&quot; | &quot;^&quot; |
699     //     &quot;[&quot; | &quot;]&quot; | &quot;`&quot;
700     //
701     // Also US ASCII control characters 00-1F and 7F.
702 
703     // lowMask((char)0, (char)31) | lowMask(&quot;=;?/# &lt;&gt;%\&quot;{}|\\^[]`&quot;);
704     private static final long L_ENCODED = 0xF800802DFFFFFFFFL;
705 
706     // highMask((char)0x7F, (char)0x7F) | highMask(&quot;=;?/# &lt;&gt;%\&quot;{}|\\^[]`&quot;);
707     private static final long H_ENCODED = 0xB800000178000000L;
708 
709 }
    </pre>
  </body>
</html>
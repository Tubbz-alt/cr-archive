<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/ManifestDigester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
<a name="2" id="anc2"></a><span class="line-modified"> 28 import java.security.MessageDigest;</span>
 29 import java.util.ArrayList;
 30 import java.util.HashMap;
 31 import java.io.ByteArrayOutputStream;
<a name="3" id="anc3"></a><span class="line-added"> 32 import java.io.OutputStream;</span>
<span class="line-added"> 33 import java.io.IOException;</span>
 34 import java.util.List;
 35 
 36 import static java.nio.charset.StandardCharsets.UTF_8;
 37 
 38 /**
 39  * This class is used to compute digests on sections of the Manifest.
 40  * Please note that multiple sections might have the same name, and they
 41  * all belong to a single Entry.
 42  */
 43 public class ManifestDigester {
 44 
<a name="4" id="anc4"></a><span class="line-added"> 45     /**</span>
<span class="line-added"> 46      * The part &quot;{@code Manifest-Main-Attributes}&quot; of the main attributes</span>
<span class="line-added"> 47      * digest header name in a signature file as described in the jar</span>
<span class="line-added"> 48      * specification:</span>
<span class="line-added"> 49      * &lt;blockquote&gt;{@code x-Digest-Manifest-Main-Attributes}</span>
<span class="line-added"> 50      * (where x is the standard name of a {@link MessageDigest} algorithm):</span>
<span class="line-added"> 51      * The value of this attribute is the digest value of the main attributes</span>
<span class="line-added"> 52      * of the manifest.&lt;/blockquote&gt;</span>
<span class="line-added"> 53      * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#signature-file&quot;&gt;</span>
<span class="line-added"> 54      * JAR File Specification, section Signature File&lt;/a&gt;</span>
<span class="line-added"> 55      * @see #getMainAttsEntry</span>
<span class="line-added"> 56      */</span>
 57     public static final String MF_MAIN_ATTRS = &quot;Manifest-Main-Attributes&quot;;
 58 
 59     /** the raw bytes of the manifest */
<a name="5" id="anc5"></a><span class="line-modified"> 60     private final byte[] rawBytes;</span>
 61 
<a name="6" id="anc6"></a><span class="line-modified"> 62     private final Entry mainAttsEntry;</span>
<span class="line-modified"> 63 </span>
<span class="line-added"> 64     /** individual sections by their names */</span>
<span class="line-added"> 65     private final HashMap&lt;String, Entry&gt; entries = new HashMap&lt;&gt;();</span>
 66 
 67     /** state returned by findSection */
 68     static class Position {
 69         int endOfFirstLine; // not including newline character
 70 
 71         int endOfSection; // end of section, not including the blank line
 72                           // between sections
 73         int startOfNext;  // the start of the next section
 74     }
 75 
 76     /**
 77      * find a section in the manifest.
 78      *
 79      * @param offset should point to the starting offset with in the
 80      * raw bytes of the next section.
 81      *
 82      * @pos set by
 83      *
 84      * @return false if end of bytes has been reached, otherwise returns
 85      *          true
 86      */
 87     @SuppressWarnings(&quot;fallthrough&quot;)
 88     private boolean findSection(int offset, Position pos)
 89     {
 90         int i = offset, len = rawBytes.length;
<a name="7" id="anc7"></a><span class="line-modified"> 91         int last = offset - 1;</span>
 92         int next;
 93         boolean allBlank = true;
 94 
<a name="8" id="anc8"></a><span class="line-modified"> 95         /* denotes that a position is not yet assigned.</span>
<span class="line-added"> 96          * As a primitive type int it cannot be null</span>
<span class="line-added"> 97          * and -1 would be confused with (i - 1) when i == 0 */</span>
<span class="line-added"> 98         final int UNASSIGNED = Integer.MIN_VALUE;</span>
<span class="line-added"> 99 </span>
<span class="line-added">100         pos.endOfFirstLine = UNASSIGNED;</span>
101 
102         while (i &lt; len) {
103             byte b = rawBytes[i];
104             switch(b) {
105             case &#39;\r&#39;:
<a name="9" id="anc9"></a><span class="line-modified">106                 if (pos.endOfFirstLine == UNASSIGNED)</span>
107                     pos.endOfFirstLine = i-1;
<a name="10" id="anc10"></a><span class="line-modified">108                 if (i &lt; len - 1 &amp;&amp; rawBytes[i + 1] == &#39;\n&#39;)</span>
109                     i++;
110                 /* fall through */
111             case &#39;\n&#39;:
<a name="11" id="anc11"></a><span class="line-modified">112                 if (pos.endOfFirstLine == UNASSIGNED)</span>
113                     pos.endOfFirstLine = i-1;
114                 if (allBlank || (i == len-1)) {
<a name="12" id="anc12"></a><span class="line-modified">115                     pos.endOfSection = allBlank ? last : i;</span>



116                     pos.startOfNext = i+1;
117                     return true;
118                 }
119                 else {
120                     // start of a new line
121                     last = i;
122                     allBlank = true;
123                 }
124                 break;
125             default:
126                 allBlank = false;
127                 break;
128             }
129             i++;
130         }
131         return false;
132     }
133 
134     public ManifestDigester(byte[] bytes)
135     {
136         rawBytes = bytes;
<a name="13" id="anc13"></a>
137 
138         Position pos = new Position();
139 
<a name="14" id="anc14"></a><span class="line-modified">140         if (!findSection(0, pos)) {</span>
<span class="line-added">141             mainAttsEntry = null;</span>
142             return; // XXX: exception?
<a name="15" id="anc15"></a><span class="line-added">143         }</span>
144 
145         // create an entry for main attributes
<a name="16" id="anc16"></a><span class="line-modified">146         mainAttsEntry = new Entry().addSection(new Section(</span>
<span class="line-modified">147                 0, pos.endOfSection + 1, pos.startOfNext, rawBytes));</span>
148 
149         int start = pos.startOfNext;
150         while(findSection(start, pos)) {
151             int len = pos.endOfFirstLine-start+1;
152             int sectionLen = pos.endOfSection-start+1;
153             int sectionLenWithBlank = pos.startOfNext-start;
154 
<a name="17" id="anc17"></a><span class="line-modified">155             if (len &gt;= 6) { // 6 == &quot;Name: &quot;.length()</span>
156                 if (isNameAttr(bytes, start)) {
157                     ByteArrayOutputStream nameBuf = new ByteArrayOutputStream();
158                     nameBuf.write(bytes, start+6, len-6);
159 
160                     int i = start + len;
161                     if ((i-start) &lt; sectionLen) {
<a name="18" id="anc18"></a><span class="line-modified">162                         if (bytes[i] == &#39;\r&#39;</span>
<span class="line-added">163                                 &amp;&amp; i + 1 - start &lt; sectionLen</span>
<span class="line-added">164                                 &amp;&amp; bytes[i + 1] == &#39;\n&#39;) {</span>
165                             i += 2;
166                         } else {
167                             i += 1;
168                         }
169                     }
170 
171                     while ((i-start) &lt; sectionLen) {
172                         if (bytes[i++] == &#39; &#39;) {
173                             // name is wrapped
174                             int wrapStart = i;
175                             while (((i-start) &lt; sectionLen)
<a name="19" id="anc19"></a><span class="line-modified">176                                     &amp;&amp; (bytes[i] != &#39;\r&#39;)</span>
<span class="line-modified">177                                     &amp;&amp; (bytes[i] != &#39;\n&#39;)) i++;</span>
<span class="line-modified">178                             int wrapLen = i - wrapStart;</span>
<span class="line-modified">179                             if (i - start &lt; sectionLen) {</span>
<span class="line-modified">180                                 i++;</span>
<span class="line-modified">181                                 if (bytes[i - 1] == &#39;\r&#39;</span>
<span class="line-modified">182                                     &amp;&amp; i - start &lt; sectionLen</span>
<span class="line-modified">183                                     &amp;&amp; bytes[i] == &#39;\n&#39;)</span>
<span class="line-added">184                                         i++;</span>
<span class="line-added">185                             }</span>
186 
187                             nameBuf.write(bytes, wrapStart, wrapLen);
188                         } else {
189                             break;
190                         }
191                     }
192 
<a name="20" id="anc20"></a><span class="line-modified">193                     entries.computeIfAbsent(nameBuf.toString(UTF_8),</span>
194                                             dummy -&gt; new Entry())
195                             .addSection(new Section(start, sectionLen,
196                                     sectionLenWithBlank, rawBytes));
197                 }
198             }
199             start = pos.startOfNext;
200         }
201     }
202 
203     private boolean isNameAttr(byte[] bytes, int start)
204     {
205         return ((bytes[start] == &#39;N&#39;) || (bytes[start] == &#39;n&#39;)) &amp;&amp;
206                ((bytes[start+1] == &#39;a&#39;) || (bytes[start+1] == &#39;A&#39;)) &amp;&amp;
207                ((bytes[start+2] == &#39;m&#39;) || (bytes[start+2] == &#39;M&#39;)) &amp;&amp;
208                ((bytes[start+3] == &#39;e&#39;) || (bytes[start+3] == &#39;E&#39;)) &amp;&amp;
209                (bytes[start+4] == &#39;:&#39;) &amp;&amp;
210                (bytes[start+5] == &#39; &#39;);
211     }
212 
213     public static class Entry {
214 
215         // One Entry for one name, and one name can have multiple sections.
216         // According to the JAR File Specification: &quot;If there are multiple
217         // individual sections for the same file entry, the attributes in
218         // these sections are merged.&quot;
219         private List&lt;Section&gt; sections = new ArrayList&lt;&gt;();
220         boolean oldStyle;
221 
222         private Entry addSection(Section sec)
223         {
224             sections.add(sec);
225             return this;
226         }
227 
<a name="21" id="anc21"></a><span class="line-added">228         /**</span>
<span class="line-added">229          * Check if the sections (particularly the last one of usually only one)</span>
<span class="line-added">230          * are properly delimited with a trailing blank line so that another</span>
<span class="line-added">231          * section can be correctly appended and return {@code true} or return</span>
<span class="line-added">232          * {@code false} to indicate that reproduction is not advised and should</span>
<span class="line-added">233          * be carried out with a clean &quot;normalized&quot; newly-written manifest.</span>
<span class="line-added">234          *</span>
<span class="line-added">235          * @see #reproduceRaw</span>
<span class="line-added">236          */</span>
<span class="line-added">237         public boolean isProperlyDelimited() {</span>
<span class="line-added">238             return sections.stream().allMatch(</span>
<span class="line-added">239                     Section::isProperlySectionDelimited);</span>
<span class="line-added">240         }</span>
<span class="line-added">241 </span>
<span class="line-added">242         public void reproduceRaw(OutputStream out) throws IOException {</span>
<span class="line-added">243             for (Section sec : sections) {</span>
<span class="line-added">244                 out.write(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);</span>
<span class="line-added">245             }</span>
<span class="line-added">246         }</span>
<span class="line-added">247 </span>
248         public byte[] digest(MessageDigest md)
249         {
250             md.reset();
251             for (Section sec : sections) {
252                 if (oldStyle) {
253                     Section.doOldStyle(md, sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
254                 } else {
255                     md.update(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
256                 }
257             }
258             return md.digest();
259         }
260 
261         /** Netscape doesn&#39;t include the new line. Intel and JavaSoft do */
262 
263         public byte[] digestWorkaround(MessageDigest md)
264         {
265             md.reset();
266             for (Section sec : sections) {
267                 md.update(sec.rawBytes, sec.offset, sec.length);
268             }
269             return md.digest();
270         }
271     }
272 
273     private static class Section {
274         int offset;
275         int length;
276         int lengthWithBlankLine;
277         byte[] rawBytes;
278 
279         public Section(int offset, int length,
280                      int lengthWithBlankLine, byte[] rawBytes)
281         {
282             this.offset = offset;
283             this.length = length;
284             this.lengthWithBlankLine = lengthWithBlankLine;
285             this.rawBytes = rawBytes;
286         }
287 
<a name="22" id="anc22"></a><span class="line-added">288         /**</span>
<span class="line-added">289          * Returns {@code true} if the raw section is terminated with a blank</span>
<span class="line-added">290          * line so that another section can possibly be appended resulting in a</span>
<span class="line-added">291          * valid manifest and {@code false} otherwise.</span>
<span class="line-added">292          */</span>
<span class="line-added">293         private boolean isProperlySectionDelimited() {</span>
<span class="line-added">294             return lengthWithBlankLine &gt; length;</span>
<span class="line-added">295         }</span>
<span class="line-added">296 </span>
297         private static void doOldStyle(MessageDigest md,
298                                 byte[] bytes,
299                                 int offset,
300                                 int length)
301         {
302             // this is too gross to even document, but here goes
303             // the 1.1 jar verification code ignored spaces at the
304             // end of lines when calculating digests, so that is
305             // what this code does. It only gets called if we
306             // are parsing a 1.1 signed signature file
307             int i = offset;
308             int start = offset;
309             int max = offset + length;
310             int prev = -1;
311             while(i &lt;max) {
312                 if ((bytes[i] == &#39;\r&#39;) &amp;&amp; (prev == &#39; &#39;)) {
313                     md.update(bytes, start, i-start-1);
314                     start = i;
315                 }
316                 prev = bytes[i];
317                 i++;
318             }
319             md.update(bytes, start, i-start);
320         }
321     }
322 
<a name="23" id="anc23"></a><span class="line-added">323     /**</span>
<span class="line-added">324      * @see #MF_MAIN_ATTRS</span>
<span class="line-added">325      */</span>
<span class="line-added">326     public Entry getMainAttsEntry() {</span>
<span class="line-added">327         return mainAttsEntry;</span>
<span class="line-added">328     }</span>
<span class="line-added">329 </span>
<span class="line-added">330     /**</span>
<span class="line-added">331      * @see #MF_MAIN_ATTRS</span>
<span class="line-added">332      */</span>
<span class="line-added">333     public Entry getMainAttsEntry(boolean oldStyle) {</span>
<span class="line-added">334         mainAttsEntry.oldStyle = oldStyle;</span>
<span class="line-added">335         return mainAttsEntry;</span>
<span class="line-added">336     }</span>
<span class="line-added">337 </span>
<span class="line-added">338     public Entry get(String name) {</span>
<span class="line-added">339         return entries.get(name);</span>
<span class="line-added">340     }</span>
<span class="line-added">341 </span>
342     public Entry get(String name, boolean oldStyle) {
<a name="24" id="anc24"></a><span class="line-modified">343         Entry e = get(name);</span>
<span class="line-modified">344         if (e == null &amp;&amp; MF_MAIN_ATTRS.equals(name)) {</span>
<span class="line-added">345             e = getMainAttsEntry();</span>
<span class="line-added">346         }</span>
<span class="line-added">347         if (e != null) {</span>
348             e.oldStyle = oldStyle;
<a name="25" id="anc25"></a><span class="line-added">349         }</span>
350         return e;
351     }
352 
353     public byte[] manifestDigest(MessageDigest md) {
354         md.reset();
355         md.update(rawBytes, 0, rawBytes.length);
356         return md.digest();
357     }
358 
359 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
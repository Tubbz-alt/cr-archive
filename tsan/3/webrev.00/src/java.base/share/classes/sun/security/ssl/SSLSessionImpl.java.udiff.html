<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSessionContextImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,28 +22,37 @@</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package sun.security.ssl;
  
<span class="udiff-line-added">+ import sun.security.x509.X509CertImpl;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ import java.io.IOException;</span>
<span class="udiff-line-added">+ import java.lang.reflect.Array;</span>
  import java.math.BigInteger;
  import java.net.InetAddress;
<span class="udiff-line-added">+ import java.nio.ByteBuffer;</span>
  import java.security.Principal;
  import java.security.PrivateKey;
  import java.security.cert.CertificateEncodingException;
  import java.security.cert.X509Certificate;
  import java.util.ArrayList;
<span class="udiff-line-added">+ import java.util.Arrays;</span>
  import java.util.Queue;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.Enumeration;
  import java.util.List;
<span class="udiff-line-removed">- import java.util.Optional;</span>
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentLinkedQueue;
<span class="udiff-line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import javax.crypto.SecretKey;
<span class="udiff-line-added">+ import javax.crypto.spec.SecretKeySpec;</span>
  import javax.net.ssl.ExtendedSSLSession;
<span class="udiff-line-added">+ import javax.net.ssl.SNIHostName;</span>
  import javax.net.ssl.SNIServerName;
<span class="udiff-line-added">+ import javax.net.ssl.SSLException;</span>
  import javax.net.ssl.SSLPeerUnverifiedException;
  import javax.net.ssl.SSLPermission;
  import javax.net.ssl.SSLSessionBindingEvent;
  import javax.net.ssl.SSLSessionBindingListener;
  import javax.net.ssl.SSLSessionContext;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,11 +104,11 @@</span>
      private SSLSessionContextImpl       context;
      private boolean             invalidated;
      private X509Certificate[]   localCerts;
      private PrivateKey          localPrivateKey;
      private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
<span class="udiff-line-modified-removed">-     private String[]            peerSupportedSignAlgs;      // for certificate</span>
<span class="udiff-line-modified-added">+     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate</span>
      private boolean             useDefaultPeerSignAlgs = false;
      private List&lt;byte[]&gt;        statusResponses;
      private SecretKey           resumptionMasterSecret;
      private SecretKey           preSharedKey;
      private byte[]              pskIdentity;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,11 +141,13 @@</span>
      // Counter used to create unique nonces in NewSessionTicket
      private BigInteger ticketNonceCounter = BigInteger.ONE;
  
      // The endpoint identification algorithm used to check certificates
      // in this session.
<span class="udiff-line-modified-removed">-     private final String              identificationProtocol;</span>
<span class="udiff-line-modified-added">+     private final String        identificationProtocol;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private final ReentrantLock sessionLock = new ReentrantLock();</span>
  
      /*
       * Create a new non-rejoinable session, using the default (null)
       * cipher spec.  This constructor returns a session which could
       * be used either by a client or by a server, as a connection is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -225,11 +236,12 @@</span>
          this.port = baseSession.getPeerPort();
          this.localSupportedSignAlgs =
                  baseSession.localSupportedSignAlgs == null ?
                  Collections.emptySet() : baseSession.localSupportedSignAlgs;
          this.peerSupportedSignAlgs =
<span class="udiff-line-modified-removed">-                 baseSession.getPeerSupportedSignatureAlgorithms();</span>
<span class="udiff-line-modified-added">+                 baseSession.peerSupportedSignAlgs == null ?</span>
<span class="udiff-line-added">+                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;</span>
          this.serverNameIndication = baseSession.serverNameIndication;
          this.requestedServerNames = baseSession.getRequestedServerNames();
          this.masterSecret = baseSession.getMasterSecret();
          this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
          this.creationTime = baseSession.getCreationTime();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -247,10 +259,454 @@</span>
          if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
               SSLLogger.finest(&quot;Session initialized:  &quot; + this);
          }
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * &lt; 2 bytes &gt; protocolVersion</span>
<span class="udiff-line-added">+      * &lt; 2 bytes &gt; cipherSuite</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; localSupportedSignAlgs entries</span>
<span class="udiff-line-added">+      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs</span>
<span class="udiff-line-added">+      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries</span>
<span class="udiff-line-added">+      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs</span>
<span class="udiff-line-added">+      * &lt; 2 bytes &gt; preSharedKey length</span>
<span class="udiff-line-added">+      * &lt; length in bytes &gt; preSharedKey</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; pskIdentity length</span>
<span class="udiff-line-added">+      * &lt; length in bytes &gt; pskIdentity</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; masterSecret length</span>
<span class="udiff-line-added">+      *   &lt; 1 byte &gt; masterSecret algorithm length</span>
<span class="udiff-line-added">+      *   &lt; length in bytes &gt; masterSecret algorithm</span>
<span class="udiff-line-added">+      *   &lt; 2 bytes &gt; masterSecretKey length</span>
<span class="udiff-line-added">+      *   &lt; length in bytes&gt; masterSecretKey</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; useExtendedMasterSecret</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; identificationProtocol length</span>
<span class="udiff-line-added">+      * &lt; length in bytes &gt; identificationProtocol</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; serverNameIndication length</span>
<span class="udiff-line-added">+      * &lt; length in bytes &gt; serverNameIndication</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; Number of requestedServerNames entries</span>
<span class="udiff-line-added">+      *   &lt; 1 byte &gt; ServerName length</span>
<span class="udiff-line-added">+      *   &lt; length in bytes &gt; ServerName</span>
<span class="udiff-line-added">+      * &lt; 4 bytes &gt; creationTime</span>
<span class="udiff-line-added">+      * &lt; 2 byte &gt; status response length</span>
<span class="udiff-line-added">+      *   &lt; 2 byte &gt; status response entry length</span>
<span class="udiff-line-added">+      *   &lt; length in byte &gt; status response entry</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; Length of peer host</span>
<span class="udiff-line-added">+      *   &lt; length in bytes &gt; peer host</span>
<span class="udiff-line-added">+      * &lt; 2 bytes&gt; peer port</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; Number of peerCerts entries</span>
<span class="udiff-line-added">+      *   &lt; 4 byte &gt; peerCert length</span>
<span class="udiff-line-added">+      *   &lt; length in bytes &gt; peerCert</span>
<span class="udiff-line-added">+      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)</span>
<span class="udiff-line-added">+      *   Certificate</span>
<span class="udiff-line-added">+      *     &lt; 1 byte &gt; Number of Certificate entries</span>
<span class="udiff-line-added">+      *       &lt; 4 byte&gt; Certificate length</span>
<span class="udiff-line-added">+      *       &lt; length in bytes&gt; Certificate</span>
<span class="udiff-line-added">+      *   PSK</span>
<span class="udiff-line-added">+      *     &lt; 1 byte &gt; Number of PSK entries</span>
<span class="udiff-line-added">+      *       &lt; 1 bytes &gt; PSK algorithm length</span>
<span class="udiff-line-added">+      *       &lt; length in bytes &gt; PSK algorithm string</span>
<span class="udiff-line-added">+      *       &lt; 4 bytes &gt; PSK key length</span>
<span class="udiff-line-added">+      *       &lt; length in bytes&gt; PSK key</span>
<span class="udiff-line-added">+      *       &lt; 4 bytes &gt; PSK identity length</span>
<span class="udiff-line-added">+      *       &lt; length in bytes&gt; PSK identity</span>
<span class="udiff-line-added">+      *   Anonymous</span>
<span class="udiff-line-added">+      *     &lt; 1 byte &gt;</span>
<span class="udiff-line-added">+      * &lt; 4 bytes &gt; maximumPacketSize</span>
<span class="udiff-line-added">+      * &lt; 4 bytes &gt; negotiatedMaxFragSize</span>
<span class="udiff-line-added">+     */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {</span>
<span class="udiff-line-added">+         int i = 0;</span>
<span class="udiff-line-added">+         byte[] b;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         boundValues = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-added">+         this.protocolVersion =</span>
<span class="udiff-line-added">+                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="udiff-line-added">+             this.sessionId = new SessionId(false, null);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // The CH session id may reset this if it&#39;s provided</span>
<span class="udiff-line-added">+             this.sessionId = new SessionId(true,</span>
<span class="udiff-line-added">+                     hc.sslContext.getSecureRandom());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         this.cipherSuite =</span>
<span class="udiff-line-added">+                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Local Supported signature algorithms</span>
<span class="udiff-line-added">+         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+         i = Byte.toUnsignedInt(buf.get());</span>
<span class="udiff-line-added">+         while (i-- &gt; 0) {</span>
<span class="udiff-line-added">+             list.add(SignatureScheme.valueOf(</span>
<span class="udiff-line-added">+                     Short.toUnsignedInt(buf.getShort())));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Peer Supported signature algorithms</span>
<span class="udiff-line-added">+         i = Byte.toUnsignedInt(buf.get());</span>
<span class="udiff-line-added">+         list.clear();</span>
<span class="udiff-line-added">+         while (i-- &gt; 0) {</span>
<span class="udiff-line-added">+             list.add(SignatureScheme.valueOf(</span>
<span class="udiff-line-added">+                     Short.toUnsignedInt(buf.getShort())));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // PSK</span>
<span class="udiff-line-added">+         i = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+         if (i &gt; 0) {</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             // Get algorithm string</span>
<span class="udiff-line-added">+             buf.get(b, 0, i);</span>
<span class="udiff-line-added">+             // Encoded length</span>
<span class="udiff-line-added">+             i = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+             // Encoded SecretKey</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             buf.get(b);</span>
<span class="udiff-line-added">+             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             this.preSharedKey = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // PSK identity</span>
<span class="udiff-line-added">+         i = buf.get();</span>
<span class="udiff-line-added">+         if (i &gt; 0) {</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             buf.get(b);</span>
<span class="udiff-line-added">+             this.pskIdentity = b;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             this.pskIdentity = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Master secret length of secret key algorithm  (one byte)</span>
<span class="udiff-line-added">+         i = buf.get();</span>
<span class="udiff-line-added">+         if (i &gt; 0) {</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             // Get algorithm string</span>
<span class="udiff-line-added">+             buf.get(b, 0, i);</span>
<span class="udiff-line-added">+             // Encoded length</span>
<span class="udiff-line-added">+             i = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+             // Encoded SecretKey</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             buf.get(b);</span>
<span class="udiff-line-added">+             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             this.masterSecret = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // Use extended master secret</span>
<span class="udiff-line-added">+         this.useExtendedMasterSecret = (buf.get() != 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Identification Protocol</span>
<span class="udiff-line-added">+         i = buf.get();</span>
<span class="udiff-line-added">+         if (i == 0) {</span>
<span class="udiff-line-added">+             identificationProtocol = null;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             identificationProtocol =</span>
<span class="udiff-line-added">+                     buf.get(b, 0, i).asCharBuffer().toString();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // SNI</span>
<span class="udiff-line-added">+         i = buf.get();  // length</span>
<span class="udiff-line-added">+         if (i == 0) {</span>
<span class="udiff-line-added">+             serverNameIndication = null;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             buf.get(b, 0, b.length);</span>
<span class="udiff-line-added">+             serverNameIndication = new SNIHostName(b);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // List of SNIServerName</span>
<span class="udiff-line-added">+         int len = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+         if (len == 0) {</span>
<span class="udiff-line-added">+             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             requestedServerNames = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+             while (len &gt; 0) {</span>
<span class="udiff-line-added">+                 int l = buf.get();</span>
<span class="udiff-line-added">+                 b = new byte[l];</span>
<span class="udiff-line-added">+                 buf.get(b, 0, l);</span>
<span class="udiff-line-added">+                 requestedServerNames.add(new SNIHostName(new String(b)));</span>
<span class="udiff-line-added">+                 len--;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         maximumPacketSize = buf.getInt();</span>
<span class="udiff-line-added">+         negotiatedMaxFragLen = buf.getInt();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Get creation time</span>
<span class="udiff-line-added">+         this.creationTime = buf.getLong();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Get Buffer sizes</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Status Response</span>
<span class="udiff-line-added">+         len = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+         if (len == 0) {</span>
<span class="udiff-line-added">+             statusResponses = Collections.emptyList();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             statusResponses = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         while (len-- &gt; 0) {</span>
<span class="udiff-line-added">+             b = new byte[Short.toUnsignedInt(buf.getShort())];</span>
<span class="udiff-line-added">+             buf.get(b);</span>
<span class="udiff-line-added">+             statusResponses.add(b);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Get Peer host &amp; port</span>
<span class="udiff-line-added">+         i = Byte.toUnsignedInt(buf.get());</span>
<span class="udiff-line-added">+         if (i == 0) {</span>
<span class="udiff-line-added">+             this.host = new String();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             b = new byte[i];</span>
<span class="udiff-line-added">+             this.host = buf.get(b).toString();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         this.port = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Peer certs</span>
<span class="udiff-line-added">+         i = buf.get();</span>
<span class="udiff-line-added">+         if (i == 0) {</span>
<span class="udiff-line-added">+             this.peerCerts = null;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             this.peerCerts = new X509Certificate[i];</span>
<span class="udiff-line-added">+             int j = 0;</span>
<span class="udiff-line-added">+             while (i &gt; j) {</span>
<span class="udiff-line-added">+                 b = new byte[buf.getInt()];</span>
<span class="udiff-line-added">+                 buf.get(b);</span>
<span class="udiff-line-added">+                 try {</span>
<span class="udiff-line-added">+                     this.peerCerts[j] = new X509CertImpl(b);</span>
<span class="udiff-line-added">+                 } catch (Exception e) {</span>
<span class="udiff-line-added">+                     throw new IOException(e);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 j++;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Get local certs of PSK</span>
<span class="udiff-line-added">+         switch (buf.get()) {</span>
<span class="udiff-line-added">+             case 0:</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case 1:</span>
<span class="udiff-line-added">+                 // number of certs</span>
<span class="udiff-line-added">+                 len = buf.get();</span>
<span class="udiff-line-added">+                 this.localCerts = new X509Certificate[len];</span>
<span class="udiff-line-added">+                 i = 0;</span>
<span class="udiff-line-added">+                 while (len &gt; i) {</span>
<span class="udiff-line-added">+                     b = new byte[buf.getInt()];</span>
<span class="udiff-line-added">+                     buf.get(b);</span>
<span class="udiff-line-added">+                     try {</span>
<span class="udiff-line-added">+                         this.localCerts[i] = new X509CertImpl(b);</span>
<span class="udiff-line-added">+                     } catch (Exception e) {</span>
<span class="udiff-line-added">+                         throw new IOException(e);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     i++;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case 2:</span>
<span class="udiff-line-added">+                 // pre-shared key</span>
<span class="udiff-line-added">+                 // Length of pre-shared key algorithm  (one byte)</span>
<span class="udiff-line-added">+                 i = buf.get();</span>
<span class="udiff-line-added">+                 b = new byte[i];</span>
<span class="udiff-line-added">+                 String alg = buf.get(b, 0, i).asCharBuffer().toString();</span>
<span class="udiff-line-added">+                 // Get length of encoding</span>
<span class="udiff-line-added">+                 i = Short.toUnsignedInt(buf.getShort());</span>
<span class="udiff-line-added">+                 // Get encoding</span>
<span class="udiff-line-added">+                 b = new byte[i];</span>
<span class="udiff-line-added">+                 buf.get(b);</span>
<span class="udiff-line-added">+                 this.preSharedKey = new SecretKeySpec(b, alg);</span>
<span class="udiff-line-added">+                 // Get identity len</span>
<span class="udiff-line-added">+                 this.pskIdentity = new byte[buf.get()];</span>
<span class="udiff-line-added">+                 buf.get(pskIdentity);</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 throw new SSLException(&quot;Failed local certs of session.&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         context = (SSLSessionContextImpl)</span>
<span class="udiff-line-added">+                 hc.sslContext.engineGetServerSessionContext();</span>
<span class="udiff-line-added">+         this.lastUsedTime = System.currentTimeMillis();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Some situations we cannot provide a stateless ticket, but after it</span>
<span class="udiff-line-added">+     // has been negotiated</span>
<span class="udiff-line-added">+     boolean isStatelessable(HandshakeContext hc) {</span>
<span class="udiff-line-added">+         if (!hc.statelessResumption) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // If there is no getMasterSecret with TLS1.2 or under, do not resume.</span>
<span class="udiff-line-added">+         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="udiff-line-added">+                 getMasterSecret().getEncoded() == null) {</span>
<span class="udiff-line-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +</span>
<span class="udiff-line-added">+                         &quot; ticket&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {</span>
<span class="udiff-line-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +</span>
<span class="udiff-line-added">+                         &quot; stateless ticket&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Write out a SSLSessionImpl in a byte array for a stateless session ticket</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     byte[] write() throws Exception {</span>
<span class="udiff-line-added">+         byte[] b;</span>
<span class="udiff-line-added">+         HandshakeOutStream hos = new HandshakeOutStream(null);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         hos.putInt16(protocolVersion.id);</span>
<span class="udiff-line-added">+         hos.putInt16(cipherSuite.id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Local Supported signature algorithms</span>
<span class="udiff-line-added">+         hos.putInt8(localSupportedSignAlgs.size());</span>
<span class="udiff-line-added">+         for (SignatureScheme s : localSupportedSignAlgs) {</span>
<span class="udiff-line-added">+             hos.putInt16(s.id);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Peer Supported signature algorithms</span>
<span class="udiff-line-added">+         hos.putInt8(peerSupportedSignAlgs.size());</span>
<span class="udiff-line-added">+         for (SignatureScheme s : peerSupportedSignAlgs) {</span>
<span class="udiff-line-added">+             hos.putInt16(s.id);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // PSK</span>
<span class="udiff-line-added">+         if (preSharedKey == null ||</span>
<span class="udiff-line-added">+                 preSharedKey.getAlgorithm() == null) {</span>
<span class="udiff-line-added">+             hos.putInt16(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             hos.putInt16(preSharedKey.getAlgorithm().length());</span>
<span class="udiff-line-added">+             if (preSharedKey.getAlgorithm().length() != 0) {</span>
<span class="udiff-line-added">+                 hos.write(preSharedKey.getAlgorithm().getBytes());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             b = preSharedKey.getEncoded();</span>
<span class="udiff-line-added">+             hos.putInt16(b.length);</span>
<span class="udiff-line-added">+             hos.write(b, 0, b.length);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // PSK Identity</span>
<span class="udiff-line-added">+         if (pskIdentity == null) {</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             hos.putInt8(pskIdentity.length);</span>
<span class="udiff-line-added">+             hos.write(pskIdentity, 0, pskIdentity.length);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Master Secret</span>
<span class="udiff-line-added">+         if (getMasterSecret() == null ||</span>
<span class="udiff-line-added">+                 getMasterSecret().getAlgorithm() == null) {</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             hos.putInt8(getMasterSecret().getAlgorithm().length());</span>
<span class="udiff-line-added">+             if (getMasterSecret().getAlgorithm().length() != 0) {</span>
<span class="udiff-line-added">+                 hos.write(getMasterSecret().getAlgorithm().getBytes());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             b = getMasterSecret().getEncoded();</span>
<span class="udiff-line-added">+             hos.putInt16(b.length);</span>
<span class="udiff-line-added">+             hos.write(b, 0, b.length);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         hos.putInt8(useExtendedMasterSecret ? 1 : 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Identification Protocol</span>
<span class="udiff-line-added">+         if (identificationProtocol == null) {</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             hos.putInt8(identificationProtocol.length());</span>
<span class="udiff-line-added">+             hos.write(identificationProtocol.getBytes(), 0,</span>
<span class="udiff-line-added">+                     identificationProtocol.length());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // SNI</span>
<span class="udiff-line-added">+         if (serverNameIndication == null) {</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             b = serverNameIndication.getEncoded();</span>
<span class="udiff-line-added">+             hos.putInt8(b.length);</span>
<span class="udiff-line-added">+             hos.write(b, 0, b.length);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // List of SNIServerName</span>
<span class="udiff-line-added">+         hos.putInt16(requestedServerNames.size());</span>
<span class="udiff-line-added">+         if (requestedServerNames.size() &gt; 0) {</span>
<span class="udiff-line-added">+             for (SNIServerName host : requestedServerNames) {</span>
<span class="udiff-line-added">+                 b = host.getEncoded();</span>
<span class="udiff-line-added">+                 hos.putInt8(b.length);</span>
<span class="udiff-line-added">+                 hos.write(b, 0, b.length);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Buffer sizes</span>
<span class="udiff-line-added">+         hos.putInt32(maximumPacketSize);</span>
<span class="udiff-line-added">+         hos.putInt32(negotiatedMaxFragLen);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // creation time</span>
<span class="udiff-line-added">+         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);</span>
<span class="udiff-line-added">+         hos.writeBytes(buffer.putLong(creationTime).array());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Status Responses</span>
<span class="udiff-line-added">+         List&lt;byte[]&gt; list = getStatusResponses();</span>
<span class="udiff-line-added">+         int l = list.size();</span>
<span class="udiff-line-added">+         hos.putInt16(l);</span>
<span class="udiff-line-added">+         for (byte[] e : list) {</span>
<span class="udiff-line-added">+             hos.putInt16(e.length);</span>
<span class="udiff-line-added">+             hos.write(e);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // peer Host &amp; Port</span>
<span class="udiff-line-added">+         if (host == null || host.length() == 0) {</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             hos.putInt8(host.length());</span>
<span class="udiff-line-added">+             hos.writeBytes(host.getBytes());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         hos.putInt16(port);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Peer cert</span>
<span class="udiff-line-added">+         if (peerCerts == null || peerCerts.length == 0) {</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             hos.putInt8(peerCerts.length);</span>
<span class="udiff-line-added">+             for (X509Certificate c : peerCerts) {</span>
<span class="udiff-line-added">+                 b = c.getEncoded();</span>
<span class="udiff-line-added">+                 hos.putInt32(b.length);</span>
<span class="udiff-line-added">+                 hos.writeBytes(b);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Client identity</span>
<span class="udiff-line-added">+         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {</span>
<span class="udiff-line-added">+             // certificate based</span>
<span class="udiff-line-added">+             hos.putInt8(1);</span>
<span class="udiff-line-added">+             hos.putInt8(localCerts.length);</span>
<span class="udiff-line-added">+             for (X509Certificate c : localCerts) {</span>
<span class="udiff-line-added">+                 b = c.getEncoded();</span>
<span class="udiff-line-added">+                 hos.putInt32(b.length);</span>
<span class="udiff-line-added">+                 hos.writeBytes(b);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (preSharedKey != null) {</span>
<span class="udiff-line-added">+             // pre-shared key</span>
<span class="udiff-line-added">+             hos.putInt8(2);</span>
<span class="udiff-line-added">+             hos.putInt8(preSharedKey.getAlgorithm().length());</span>
<span class="udiff-line-added">+             hos.write(preSharedKey.getAlgorithm().getBytes());</span>
<span class="udiff-line-added">+             b = preSharedKey.getEncoded();</span>
<span class="udiff-line-added">+             hos.putInt32(b.length);</span>
<span class="udiff-line-added">+             hos.writeBytes(b);</span>
<span class="udiff-line-added">+             hos.putInt32(pskIdentity.length);</span>
<span class="udiff-line-added">+             hos.writeBytes(pskIdentity);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // anonymous</span>
<span class="udiff-line-added">+             hos.putInt8(0);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return hos.toByteArray();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      void setMasterSecret(SecretKey secret) {
          masterSecret = secret;
      }
  
      void setResumptionMasterSecret(SecretKey secret) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -273,33 +729,46 @@</span>
          this.pskIdentity = pskIdentity;
      }
  
      BigInteger incrTicketNonceCounter() {
          BigInteger result = ticketNonceCounter;
<span class="udiff-line-modified-removed">-         ticketNonceCounter = ticketNonceCounter.add(BigInteger.valueOf(1));</span>
<span class="udiff-line-modified-added">+         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);</span>
          return result;
      }
  
<span class="udiff-line-added">+     boolean isPSKable() {</span>
<span class="udiff-line-added">+         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Returns the master secret ... treat with extreme caution!
       */
      SecretKey getMasterSecret() {
          return masterSecret;
      }
  
<span class="udiff-line-modified-removed">-     Optional&lt;SecretKey&gt; getResumptionMasterSecret() {</span>
<span class="udiff-line-modified-removed">-         return Optional.ofNullable(resumptionMasterSecret);</span>
<span class="udiff-line-modified-added">+     SecretKey getResumptionMasterSecret() {</span>
<span class="udiff-line-modified-added">+         return resumptionMasterSecret;</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized Optional&lt;SecretKey&gt; getPreSharedKey() {</span>
<span class="udiff-line-modified-removed">-         return Optional.ofNullable(preSharedKey);</span>
<span class="udiff-line-modified-added">+     SecretKey getPreSharedKey() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return preSharedKey;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized Optional&lt;SecretKey&gt; consumePreSharedKey() {</span>
<span class="udiff-line-modified-removed">-         Optional&lt;SecretKey&gt; result = Optional.ofNullable(preSharedKey);</span>
<span class="udiff-line-modified-removed">-         preSharedKey = null;</span>
<span class="udiff-line-modified-removed">-         return result;</span>
<span class="udiff-line-modified-added">+     SecretKey consumePreSharedKey() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             return preSharedKey;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             preSharedKey = null;</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      int getTicketAgeAdd() {
          return ticketAgeAdd;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -310,14 +779,22 @@</span>
  
      /* PSK identities created from new_session_ticket messages should only
       * be used once. This method will return the identity and then clear it
       * so it cannot be used again.
       */
<span class="udiff-line-modified-removed">-     synchronized Optional&lt;byte[]&gt; consumePskIdentity() {</span>
<span class="udiff-line-modified-removed">-         Optional&lt;byte[]&gt; result = Optional.ofNullable(pskIdentity);</span>
<span class="udiff-line-modified-removed">-         pskIdentity = null;</span>
<span class="udiff-line-modified-removed">-         return result;</span>
<span class="udiff-line-modified-added">+     byte[] consumePskIdentity() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             return pskIdentity;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             pskIdentity = null;</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     byte[] getPskIdentity() {</span>
<span class="udiff-line-added">+         return pskIdentity;</span>
      }
  
      void setPeerCertificates(X509Certificate[] peer) {
          if (peerCerts == null) {
              peerCerts = peer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -332,12 +809,11 @@</span>
          localPrivateKey = privateKey;
      }
  
      void setPeerSupportedSignatureAlgorithms(
              Collection&lt;SignatureScheme&gt; signatureSchemes) {
<span class="udiff-line-modified-removed">-         peerSupportedSignAlgs =</span>
<span class="udiff-line-removed">-             SignatureScheme.getAlgorithmNames(signatureSchemes);</span>
<span class="udiff-line-modified-added">+         peerSupportedSignAlgs = signatureSchemes;</span>
      }
  
      // TLS 1.2 only
      //
      // Per RFC 5246, If the client supports only the default hash
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -347,20 +823,24 @@</span>
      // and signature algorithms (and it is willing to use them
      // for verifying messages sent by the server, i.e., server
      // certificates and server key exchange), it MUST send the
      // signature_algorithms extension, listing the algorithms it
      // is willing to accept.
<span class="udiff-line-added">+     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =</span>
<span class="udiff-line-added">+             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,</span>
<span class="udiff-line-added">+                     SignatureScheme.DSA_SHA1,</span>
<span class="udiff-line-added">+                     SignatureScheme.ECDSA_SHA1));</span>
<span class="udiff-line-added">+ </span>
      void setUseDefaultPeerSignAlgs() {
          useDefaultPeerSignAlgs = true;
<span class="udiff-line-modified-removed">-         peerSupportedSignAlgs = new String[] {</span>
<span class="udiff-line-removed">-             &quot;SHA1withRSA&quot;, &quot;SHA1withDSA&quot;, &quot;SHA1withECDSA&quot;};</span>
<span class="udiff-line-modified-added">+         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;</span>
      }
  
      // Returns the connection session.
      SSLSessionImpl finish() {
          if (useDefaultPeerSignAlgs) {
<span class="udiff-line-modified-removed">-             this.peerSupportedSignAlgs = new String[0];</span>
<span class="udiff-line-modified-added">+             peerSupportedSignAlgs = Collections.emptySet();</span>
          }
  
          return this;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -383,17 +863,26 @@</span>
       * for example sessions that haven&#39;t been used for a while (say,
       * a working day) won&#39;t be resumable, and sessions might have a
       * maximum lifetime in any case.
       */
      boolean isRejoinable() {
<span class="udiff-line-added">+         // TLS 1.3 can have no session id</span>
<span class="udiff-line-added">+         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="udiff-line-added">+             return (!invalidated &amp;&amp; isLocalAuthenticationValid());</span>
<span class="udiff-line-added">+         }</span>
          return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
<span class="udiff-line-modified-removed">-             !invalidated &amp;&amp; isLocalAuthenticationValid();</span>
<span class="udiff-line-modified-added">+                 !invalidated &amp;&amp; isLocalAuthenticationValid();</span>
      }
  
      @Override
<span class="udiff-line-modified-removed">-     public synchronized boolean isValid() {</span>
<span class="udiff-line-modified-removed">-         return isRejoinable();</span>
<span class="udiff-line-modified-added">+     public boolean isValid() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return isRejoinable();</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Check if the authentication used when establishing this session
       * is still valid. Returns true if no authentication was used
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -772,42 +1261,49 @@</span>
      /**
       * Invalidate a session.  Active connections may still exist, but
       * no connections will be able to rejoin this session.
       */
      @Override
<span class="udiff-line-modified-removed">-     public synchronized void invalidate() {</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="udiff-line-modified-removed">-         // attempted when we get a handshaking error on a brand</span>
<span class="udiff-line-modified-removed">-         // new connection, with no &quot;real&quot; session yet.</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         if (this == nullSession) {</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     public void invalidate() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             //</span>
<span class="udiff-line-modified-added">+             // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="udiff-line-modified-added">+             // attempted when we get a handshaking error on a brand</span>
<span class="udiff-line-modified-added">+             // new connection, with no &quot;real&quot; session yet.</span>
<span class="udiff-line-modified-added">+             //</span>
<span class="udiff-line-modified-added">+             if (this == nullSession) {</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (context != null) {</span>
<span class="udiff-line-modified-removed">-             context.remove(sessionId);</span>
<span class="udiff-line-modified-removed">-             context = null;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if (invalidated) {</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         invalidated = true;</span>
<span class="udiff-line-modified-removed">-         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {</span>
<span class="udiff-line-modified-removed">-              SSLLogger.finest(&quot;Invalidated session:  &quot; + this);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         for (SSLSessionImpl child : childSessions) {</span>
<span class="udiff-line-modified-removed">-             child.invalidate();</span>
<span class="udiff-line-modified-added">+             if (context != null) {</span>
<span class="udiff-line-modified-added">+                 context.remove(sessionId);</span>
<span class="udiff-line-modified-added">+                 context = null;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (invalidated) {</span>
<span class="udiff-line-modified-added">+                 return;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             invalidated = true;</span>
<span class="udiff-line-modified-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {</span>
<span class="udiff-line-modified-added">+                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             for (SSLSessionImpl child : childSessions) {</span>
<span class="udiff-line-added">+                 child.invalidate();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
          }
      }
  
      /*
       * Table of application-specific session data indexed by an application
       * key and the calling security context. This is important since
       * sessions can be shared across different protection domains.
       */
      private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
<span class="udiff-line-added">+     boolean updateNST;</span>
  
      /**
       * Assigns a session value.  Session change events are given if
       * appropriate, to any original value as well as the new value.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -830,10 +1326,13 @@</span>
              SSLSessionBindingEvent e;
  
              e = new SSLSessionBindingEvent(this, key);
              ((SSLSessionBindingListener)value).valueBound(e);
          }
<span class="udiff-line-added">+         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="udiff-line-added">+             updateNST = true;</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Returns the specified session value.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -865,10 +1364,13 @@</span>
              SSLSessionBindingEvent e;
  
              e = new SSLSessionBindingEvent(this, key);
              ((SSLSessionBindingListener)value).valueUnbound(e);
          }
<span class="udiff-line-added">+         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="udiff-line-added">+             updateNST = true;</span>
<span class="udiff-line-added">+         }</span>
      }
  
  
      /**
       * Lists the names of the session values.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -907,76 +1409,91 @@</span>
  
      /**
       * Expand the buffer size of both SSL/TLS network packet and
       * application data.
       */
<span class="udiff-line-modified-removed">-     protected synchronized void expandBufferSizes() {</span>
<span class="udiff-line-modified-removed">-         acceptLargeFragments = true;</span>
<span class="udiff-line-modified-added">+     protected void expandBufferSizes() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             acceptLargeFragments = true;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Gets the current size of the largest SSL/TLS packet that is expected
       * when using this session.
       */
      @Override
<span class="udiff-line-modified-removed">-     public synchronized int getPacketBufferSize() {</span>
<span class="udiff-line-modified-removed">-         // Use the bigger packet size calculated from maximumPacketSize</span>
<span class="udiff-line-modified-removed">-         // and negotiatedMaxFragLen.</span>
<span class="udiff-line-modified-removed">-         int packetSize = 0;</span>
<span class="udiff-line-modified-removed">-         if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             packetSize = cipherSuite.calculatePacketSize(</span>
<span class="udiff-line-modified-removed">-                     negotiatedMaxFragLen, protocolVersion,</span>
<span class="udiff-line-modified-removed">-                     protocolVersion.isDTLS);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     public int getPacketBufferSize() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             // Use the bigger packet size calculated from maximumPacketSize</span>
<span class="udiff-line-modified-added">+             // and negotiatedMaxFragLen.</span>
<span class="udiff-line-modified-added">+             int packetSize = 0;</span>
<span class="udiff-line-modified-added">+             if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 packetSize = cipherSuite.calculatePacketSize(</span>
<span class="udiff-line-modified-added">+                         negotiatedMaxFragLen, protocolVersion,</span>
<span class="udiff-line-added">+                         protocolVersion.isDTLS);</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (maximumPacketSize &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             return (maximumPacketSize &gt; packetSize) ?</span>
<span class="udiff-line-modified-removed">-                     maximumPacketSize : packetSize;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+             if (maximumPacketSize &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 return (maximumPacketSize &gt; packetSize) ?</span>
<span class="udiff-line-modified-added">+                         maximumPacketSize : packetSize;</span>
<span class="udiff-line-modified-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (packetSize != 0) {</span>
<span class="udiff-line-modified-removed">-            return packetSize;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+             if (packetSize != 0) {</span>
<span class="udiff-line-modified-added">+                return packetSize;</span>
<span class="udiff-line-modified-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (protocolVersion.isDTLS) {</span>
<span class="udiff-line-modified-removed">-             return DTLSRecord.maxRecordSize;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             return acceptLargeFragments ?</span>
<span class="udiff-line-modified-removed">-                     SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="udiff-line-modified-added">+             if (protocolVersion.isDTLS) {</span>
<span class="udiff-line-modified-added">+                 return DTLSRecord.maxRecordSize;</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-modified-added">+                 return acceptLargeFragments ?</span>
<span class="udiff-line-modified-added">+                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
          }
      }
  
      /**
       * Gets the current size of the largest application data that is
       * expected when using this session.
       */
      @Override
<span class="udiff-line-modified-removed">-     public synchronized int getApplicationBufferSize() {</span>
<span class="udiff-line-modified-removed">-         // Use the bigger fragment size calculated from maximumPacketSize</span>
<span class="udiff-line-modified-removed">-         // and negotiatedMaxFragLen.</span>
<span class="udiff-line-modified-removed">-         int fragmentSize = 0;</span>
<span class="udiff-line-modified-removed">-         if (maximumPacketSize &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             fragmentSize = cipherSuite.calculateFragSize(</span>
<span class="udiff-line-modified-removed">-                     maximumPacketSize, protocolVersion,</span>
<span class="udiff-line-modified-removed">-                     protocolVersion.isDTLS);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     public int getApplicationBufferSize() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             // Use the bigger fragment size calculated from maximumPacketSize</span>
<span class="udiff-line-modified-added">+             // and negotiatedMaxFragLen.</span>
<span class="udiff-line-modified-added">+             int fragmentSize = 0;</span>
<span class="udiff-line-modified-added">+             if (maximumPacketSize &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 fragmentSize = cipherSuite.calculateFragSize(</span>
<span class="udiff-line-modified-added">+                         maximumPacketSize, protocolVersion,</span>
<span class="udiff-line-added">+                         protocolVersion.isDTLS);</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             return (negotiatedMaxFragLen &gt; fragmentSize) ?</span>
<span class="udiff-line-modified-removed">-                     negotiatedMaxFragLen : fragmentSize;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+             if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="udiff-line-modified-added">+                 return (negotiatedMaxFragLen &gt; fragmentSize) ?</span>
<span class="udiff-line-modified-added">+                         negotiatedMaxFragLen : fragmentSize;</span>
<span class="udiff-line-modified-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (fragmentSize != 0) {</span>
<span class="udiff-line-modified-removed">-             return fragmentSize;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+             if (fragmentSize != 0) {</span>
<span class="udiff-line-modified-added">+                 return fragmentSize;</span>
<span class="udiff-line-modified-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         if (protocolVersion.isDTLS) {</span>
<span class="udiff-line-modified-removed">-             return Record.maxDataSize;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             int maxPacketSize = acceptLargeFragments ?</span>
<span class="udiff-line-modified-removed">-                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="udiff-line-modified-removed">-             return (maxPacketSize - SSLRecord.headerSize);</span>
<span class="udiff-line-modified-added">+             if (protocolVersion.isDTLS) {</span>
<span class="udiff-line-modified-added">+                 return Record.maxDataSize;</span>
<span class="udiff-line-modified-added">+             } else {</span>
<span class="udiff-line-modified-added">+                 int maxPacketSize = acceptLargeFragments ?</span>
<span class="udiff-line-modified-added">+                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="udiff-line-modified-added">+                 return (maxPacketSize - SSLRecord.headerSize);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
          }
      }
  
      /**
       * Sets the negotiated maximum fragment length, as specified by the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -984,33 +1501,52 @@</span>
       *
       * @param  negotiatedMaxFragLen
       *         the negotiated maximum fragment length, or {@code -1} if
       *         no such length has been negotiated.
       */
<span class="udiff-line-modified-removed">-     synchronized void setNegotiatedMaxFragSize(</span>
<span class="udiff-line-modified-added">+     void setNegotiatedMaxFragSize(</span>
              int negotiatedMaxFragLen) {
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         this.negotiatedMaxFragLen = negotiatedMaxFragLen;</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-added">+             this.negotiatedMaxFragLen = negotiatedMaxFragLen;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Get the negotiated maximum fragment length, as specified by the
       * max_fragment_length ClientHello extension in RFC 6066.
       *
       * @return the negotiated maximum fragment length, or {@code -1} if
       *         no such length has been negotiated.
       */
<span class="udiff-line-modified-removed">-     synchronized int getNegotiatedMaxFragSize() {</span>
<span class="udiff-line-modified-removed">-         return negotiatedMaxFragLen;</span>
<span class="udiff-line-modified-added">+     int getNegotiatedMaxFragSize() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return negotiatedMaxFragLen;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized void setMaximumPacketSize(int maximumPacketSize) {</span>
<span class="udiff-line-modified-removed">-         this.maximumPacketSize = maximumPacketSize;</span>
<span class="udiff-line-modified-added">+     void setMaximumPacketSize(int maximumPacketSize) {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             this.maximumPacketSize = maximumPacketSize;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized int getMaximumPacketSize() {</span>
<span class="udiff-line-modified-removed">-         return maximumPacketSize;</span>
<span class="udiff-line-modified-added">+     int getMaximumPacketSize() {</span>
<span class="udiff-line-modified-added">+         sessionLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return maximumPacketSize;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             sessionLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Gets an array of supported signature algorithm names that the local
       * side is willing to verify.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1032,15 +1568,11 @@</span>
       * Gets an array of supported signature algorithms that the peer is
       * able to verify.
       */
      @Override
      public String[] getPeerSupportedSignatureAlgorithms() {
<span class="udiff-line-modified-removed">-         if (peerSupportedSignAlgs != null) {</span>
<span class="udiff-line-removed">-             return peerSupportedSignAlgs.clone();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return new String[0];</span>
<span class="udiff-line-modified-added">+         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);</span>
      }
  
      /**
       * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
       * of the requested Server Name Indication (SNI) extension.
</pre>
<center><a href="SSLSessionContextImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
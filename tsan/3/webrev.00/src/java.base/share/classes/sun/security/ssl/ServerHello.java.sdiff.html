<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/ServerHello.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLTransport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ServerHelloDone.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ServerHello.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.AlgorithmConstraints;

  31 import java.security.GeneralSecurityException;
  32 import java.text.MessageFormat;
  33 import java.util.Arrays;

  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Locale;
  37 import java.util.Map;
<span class="line-removed">  38 import java.util.Optional;</span>
  39 import javax.crypto.SecretKey;
  40 import javax.crypto.spec.IvParameterSpec;
  41 import javax.net.ssl.SSLException;
  42 import javax.net.ssl.SSLHandshakeException;
  43 import javax.net.ssl.SSLProtocolException;
  44 import sun.security.ssl.CipherSuite.KeyExchange;
  45 import sun.security.ssl.ClientHello.ClientHelloMessage;
  46 import sun.security.ssl.SSLCipher.SSLReadCipher;
  47 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  49 import sun.security.ssl.SupportedVersionsExtension.SHSupportedVersionsSpec;
  50 


  51 /**
  52  * Pack of the ServerHello/HelloRetryRequest handshake message.
  53  */
  54 final class ServerHello {
  55     static final SSLConsumer handshakeConsumer =
  56         new ServerHelloConsumer();
  57     static final HandshakeProducer t12HandshakeProducer =
  58         new T12ServerHelloProducer();
  59     static final HandshakeProducer t13HandshakeProducer =
  60         new T13ServerHelloProducer();
  61     static final HandshakeProducer hrrHandshakeProducer =
  62         new T13HelloRetryRequestProducer();
  63 
  64     static final HandshakeProducer hrrReproducer =
  65         new T13HelloRetryRequestReproducer();
  66 
  67     private static final HandshakeConsumer t12HandshakeConsumer =
  68         new T12ServerHelloConsumer();
  69     private static final HandshakeConsumer t13HandshakeConsumer =
  70         new T13ServerHelloConsumer();
</pre>
<hr />
<pre>
 321                     }
 322                 }
 323 
 324                 if ((ke != null) &amp;&amp;
 325                         (shc.sslConfig.clientAuthType !=
 326                                 ClientAuthType.CLIENT_AUTH_NONE) &amp;&amp;
 327                         !shc.negotiatedCipherSuite.isAnonymous()) {
 328                     for (SSLHandshake hs :
 329                             ke.getRelatedHandshakers(shc)) {
 330                         if (hs == SSLHandshake.CERTIFICATE) {
 331                             shc.handshakeProducers.put(
 332                                     SSLHandshake.CERTIFICATE_REQUEST.id,
 333                                     SSLHandshake.CERTIFICATE_REQUEST);
 334                             break;
 335                         }
 336                     }
 337                 }
 338                 shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO_DONE.id,
 339                         SSLHandshake.SERVER_HELLO_DONE);
 340             } else {









 341                 shc.handshakeSession = shc.resumingSession;
 342                 shc.negotiatedProtocol =
 343                         shc.resumingSession.getProtocolVersion();
 344                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 345                 shc.handshakeHash.determine(
 346                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 347             }
 348 
 349             // Generate the ServerHello handshake message.
 350             ServerHelloMessage shm = new ServerHelloMessage(shc,
 351                     shc.negotiatedProtocol,
 352                     shc.handshakeSession.getSessionId(),
 353                     shc.negotiatedCipherSuite,
 354                     new RandomCookie(shc),
 355                     clientHello);
 356             shc.serverHelloRandom = shm.serverRandom;
 357 
 358             // Produce extensions for ServerHello handshake message.
 359             SSLExtension[] serverHelloExtensions =
 360                 shc.sslConfig.getEnabledExtensions(
</pre>
<hr />
<pre>
 407             for (CipherSuite cs : preferred) {
 408                 if (!HandshakeContext.isNegotiable(
 409                         proposed, shc.negotiatedProtocol, cs)) {
 410                     continue;
 411                 }
 412 
 413                 if (shc.sslConfig.clientAuthType ==
 414                         ClientAuthType.CLIENT_AUTH_REQUIRED) {
 415                     if ((cs.keyExchange == KeyExchange.K_DH_ANON) ||
 416                         (cs.keyExchange == KeyExchange.K_ECDH_ANON)) {
 417                         continue;
 418                     }
 419                 }
 420 
 421                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 422                         cs.keyExchange, shc.negotiatedProtocol);
 423                 if (ke == null) {
 424                     continue;
 425                 }
 426                 if (!ServerHandshakeContext.legacyAlgorithmConstraints.permits(
<span class="line-modified"> 427                         null, cs.name, null)) {</span>
 428                     legacySuites.add(cs);
 429                     continue;
 430                 }
 431 
 432                 SSLPossession[] hcds = ke.createPossessions(shc);
 433                 if ((hcds == null) || (hcds.length == 0)) {
 434                     continue;
 435                 }
 436 
 437                 // The cipher suite has been negotiated.
 438                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 439                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 440                 }
 441 
 442                 return new KeyExchangeProperties(cs, ke, hcds);
 443             }
 444 
 445             for (CipherSuite cs : legacySuites) {
 446                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 447                         cs.keyExchange,  shc.negotiatedProtocol);
</pre>
<hr />
<pre>
 475         }
 476     }
 477 
 478     /**
 479      * The &quot;ServerHello&quot; handshake message producer.
 480      */
 481     private static final
 482             class T13ServerHelloProducer implements HandshakeProducer {
 483         // Prevent instantiation of this class.
 484         private T13ServerHelloProducer() {
 485             // blank
 486         }
 487 
 488         @Override
 489         public byte[] produce(ConnectionContext context,
 490                 HandshakeMessage message) throws IOException {
 491             // The producing happens in server side only.
 492             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 493             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 494 



 495             // If client hasn&#39;t specified a session we can resume, start a
 496             // new one and choose its cipher suite and compression options,
 497             // unless new session creation is disabled for this connection!
 498             if (!shc.isResumption || shc.resumingSession == null) {
 499                 if (!shc.sslConfig.enableSessionCreation) {
 500                     throw new SSLException(
 501                         &quot;Not resumption, and no new session is allowed&quot;);
 502                 }
 503 
 504                 if (shc.localSupportedSignAlgs == null) {
 505                     shc.localSupportedSignAlgs =
 506                         SignatureScheme.getSupportedAlgorithms(
 507                                 shc.algorithmConstraints, shc.activeProtocols);
 508                 }
 509 
 510                 SSLSessionImpl session =
 511                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 512                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 513                 shc.handshakeSession = session;
 514 
</pre>
<hr />
<pre>
 527                 shc.negotiatedCipherSuite = cipherSuite;
 528                 shc.handshakeSession.setSuite(cipherSuite);
 529                 shc.handshakeHash.determine(
 530                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 531             } else {
 532                 shc.handshakeSession = shc.resumingSession;
 533 
 534                 // consider the handshake extension impact
 535                 SSLExtension[] enabledExtensions =
 536                 shc.sslConfig.getEnabledExtensions(
 537                 SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 538                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 539 
 540                 shc.negotiatedProtocol =
 541                         shc.resumingSession.getProtocolVersion();
 542                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 543                 shc.handshakeHash.determine(
 544                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 545 
 546                 setUpPskKD(shc,
<span class="line-modified"> 547                         shc.resumingSession.consumePreSharedKey().get());</span>
 548 
 549                 // The session can&#39;t be resumed again---remove it from cache
<span class="line-removed"> 550                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="line-removed"> 551                     shc.sslContext.engineGetServerSessionContext();</span>
 552                 sessionCache.remove(shc.resumingSession.getSessionId());
 553             }
 554 
 555             // update the responders
 556             shc.handshakeProducers.put(SSLHandshake.ENCRYPTED_EXTENSIONS.id,
 557                     SSLHandshake.ENCRYPTED_EXTENSIONS);
 558             shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 559                     SSLHandshake.FINISHED);
 560 
 561             // Generate the ServerHello handshake message.
 562             ServerHelloMessage shm = new ServerHelloMessage(shc,
 563                     ProtocolVersion.TLS12,      // use legacy version
 564                     clientHello.sessionId,      // echo back
 565                     shc.negotiatedCipherSuite,
 566                     new RandomCookie(shc),
 567                     clientHello);
 568             shc.serverHelloRandom = shm.serverRandom;
 569 
 570             // Produce extensions for ServerHello handshake message.
 571             SSLExtension[] serverHelloExtensions =
</pre>
<hr />
<pre>
 663             } catch (GeneralSecurityException gse) {
 664                 // unlikely
 665                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 666                         &quot;Missing cipher algorithm&quot;, gse);
 667             }
 668 
 669             if (writeCipher == null) {
 670                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 671                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 672                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 673                     &quot;)&quot;);
 674             }
 675 
 676             shc.baseWriteSecret = writeSecret;
 677             shc.conContext.outputRecord.changeWriteCiphers(
 678                     writeCipher, (clientHello.sessionId.length() != 0));
 679 
 680             // Update the context for master key derivation.
 681             shc.handshakeKeyDerivation = kd;
 682 





 683             // The handshake message has been delivered.
 684             return null;
 685         }
 686 
 687         private static CipherSuite chooseCipherSuite(
 688                 ServerHandshakeContext shc,
 689                 ClientHelloMessage clientHello) throws IOException {
 690             List&lt;CipherSuite&gt; preferred;
 691             List&lt;CipherSuite&gt; proposed;
 692             if (shc.sslConfig.preferLocalCipherSuites) {
 693                 preferred = shc.activeCipherSuites;
 694                 proposed = clientHello.cipherSuites;
 695             } else {
 696                 preferred = clientHello.cipherSuites;
 697                 proposed = shc.activeCipherSuites;
 698             }
 699 
 700             CipherSuite legacySuite = null;
 701             AlgorithmConstraints legacyConstraints =
 702                     ServerHandshakeContext.legacyAlgorithmConstraints;
 703             for (CipherSuite cs : preferred) {
 704                 if (!HandshakeContext.isNegotiable(
 705                         proposed, shc.negotiatedProtocol, cs)) {
 706                     continue;
 707                 }
 708 
 709                 if ((legacySuite == null) &amp;&amp;
<span class="line-modified"> 710                         !legacyConstraints.permits(null, cs.name, null)) {</span>


 711                     legacySuite = cs;
 712                     continue;
 713                 }
 714 
 715                 // The cipher suite has been negotiated.
 716                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 717                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 718                 }
 719                 return cs;
 720             }
 721 
 722             if (legacySuite != null) {
 723                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 724                     SSLLogger.warning(
 725                             &quot;use legacy cipher suite &quot; + legacySuite.name);
 726                 }
 727                 return legacySuite;
 728             }
 729 
 730             // no cipher suites in common
</pre>
<hr />
<pre>
1082                     }
1083                 }
1084             }
1085 
1086             // Check and launch ClientHello extensions.
1087             extTypes = chc.sslConfig.getEnabledExtensions(
1088                     SSLHandshake.SERVER_HELLO);
1089             serverHello.extensions.consumeOnLoad(chc, extTypes);
1090 
1091             if (!chc.isResumption) {
1092                 if (chc.resumingSession != null) {
1093                     // in case the resumption happens next time.
1094                     chc.resumingSession.invalidate();
1095                     chc.resumingSession = null;
1096                 }
1097 
1098                 if (!chc.sslConfig.enableSessionCreation) {
1099                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1100                         &quot;New session creation is disabled&quot;);
1101                 }
<span class="line-modified">1102                 chc.handshakeSession = new SSLSessionImpl(chc,</span>
<span class="line-modified">1103                         chc.negotiatedCipherSuite,</span>
<span class="line-modified">1104                         serverHello.sessionId);</span>














1105                 chc.handshakeSession.setMaximumPacketSize(
1106                         chc.sslConfig.maximumPacketSize);
1107             }
1108 
1109             //
1110             // update
1111             //
1112             serverHello.extensions.consumeOnTrade(chc, extTypes);
1113 
1114             // update the consumers and producers
1115             if (chc.isResumption) {
1116                 SSLTrafficKeyDerivation kdg =
1117                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1118                 if (kdg == null) {
1119                     // unlikely
1120                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1121                             &quot;Not supported key derivation: &quot; +
1122                             chc.negotiatedProtocol);
1123                 } else {
1124                     chc.handshakeKeyDerivation = kdg.createKeyDerivation(
1125                             chc, chc.resumingSession.getMasterSecret());
1126                 }
1127 





1128                 chc.conContext.consumers.putIfAbsent(
1129                         ContentType.CHANGE_CIPHER_SPEC.id,
1130                         ChangeCipherSpec.t10Consumer);
1131                 chc.handshakeConsumers.put(
1132                         SSLHandshake.FINISHED.id,
1133                         SSLHandshake.FINISHED);
1134             } else {
1135                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
1136                         chc.negotiatedCipherSuite.keyExchange,
1137                         chc.negotiatedProtocol);
1138                 chc.handshakeKeyExchange = ke;
1139                 if (ke != null) {
1140                     for (SSLHandshake handshake :
1141                             ke.getRelatedHandshakers(chc)) {
1142                         chc.handshakeConsumers.put(handshake.id, handshake);
1143                     }
1144                 }
1145 
1146                 chc.handshakeConsumers.put(SSLHandshake.SERVER_HELLO_DONE.id,
1147                         SSLHandshake.SERVER_HELLO_DONE);
</pre>
<hr />
<pre>
1206                     SSLHandshake.SERVER_HELLO);
1207             serverHello.extensions.consumeOnLoad(chc, extTypes);
1208             if (!chc.isResumption) {
1209                 if (chc.resumingSession != null) {
1210                     // in case the resumption happens next time.
1211                     chc.resumingSession.invalidate();
1212                     chc.resumingSession = null;
1213                 }
1214 
1215                 if (!chc.sslConfig.enableSessionCreation) {
1216                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1217                         &quot;New session creation is disabled&quot;);
1218                 }
1219                 chc.handshakeSession = new SSLSessionImpl(chc,
1220                         chc.negotiatedCipherSuite,
1221                         serverHello.sessionId);
1222                 chc.handshakeSession.setMaximumPacketSize(
1223                         chc.sslConfig.maximumPacketSize);
1224             } else {
1225                 // The PSK is consumed to allow it to be deleted
<span class="line-modified">1226                 Optional&lt;SecretKey&gt; psk =</span>
1227                         chc.resumingSession.consumePreSharedKey();
<span class="line-modified">1228                 if(!psk.isPresent()) {</span>
1229                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1230                     &quot;No PSK available. Unable to resume.&quot;);
1231                 }
1232 
1233                 chc.handshakeSession = chc.resumingSession;
1234 
<span class="line-modified">1235                 setUpPskKD(chc, psk.get());</span>
1236             }
1237 
1238             //
1239             // update
1240             //
1241             serverHello.extensions.consumeOnTrade(chc, extTypes);
1242 
1243             // Change client/server handshake traffic secrets.
1244             // Refresh handshake hash
1245             chc.handshakeHash.update();
1246 
1247             SSLKeyExchange ke = chc.handshakeKeyExchange;
1248             if (ke == null) {
1249                 // unlikely
1250                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1251                         &quot;Not negotiated key shares&quot;);
1252             }
1253 
1254             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(chc);
1255             SecretKey handshakeSecret = handshakeKD.deriveKey(
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.AlgorithmConstraints;
<span class="line-added">  31 import java.security.CryptoPrimitive;</span>
  32 import java.security.GeneralSecurityException;
  33 import java.text.MessageFormat;
  34 import java.util.Arrays;
<span class="line-added">  35 import java.util.EnumSet;</span>
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import java.util.Map;

  40 import javax.crypto.SecretKey;
  41 import javax.crypto.spec.IvParameterSpec;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLProtocolException;
  45 import sun.security.ssl.CipherSuite.KeyExchange;
  46 import sun.security.ssl.ClientHello.ClientHelloMessage;
  47 import sun.security.ssl.SSLCipher.SSLReadCipher;
  48 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  49 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  50 import sun.security.ssl.SupportedVersionsExtension.SHSupportedVersionsSpec;
  51 
<span class="line-added">  52 import static sun.security.ssl.SSLExtension.SH_SESSION_TICKET;</span>
<span class="line-added">  53 </span>
  54 /**
  55  * Pack of the ServerHello/HelloRetryRequest handshake message.
  56  */
  57 final class ServerHello {
  58     static final SSLConsumer handshakeConsumer =
  59         new ServerHelloConsumer();
  60     static final HandshakeProducer t12HandshakeProducer =
  61         new T12ServerHelloProducer();
  62     static final HandshakeProducer t13HandshakeProducer =
  63         new T13ServerHelloProducer();
  64     static final HandshakeProducer hrrHandshakeProducer =
  65         new T13HelloRetryRequestProducer();
  66 
  67     static final HandshakeProducer hrrReproducer =
  68         new T13HelloRetryRequestReproducer();
  69 
  70     private static final HandshakeConsumer t12HandshakeConsumer =
  71         new T12ServerHelloConsumer();
  72     private static final HandshakeConsumer t13HandshakeConsumer =
  73         new T13ServerHelloConsumer();
</pre>
<hr />
<pre>
 324                     }
 325                 }
 326 
 327                 if ((ke != null) &amp;&amp;
 328                         (shc.sslConfig.clientAuthType !=
 329                                 ClientAuthType.CLIENT_AUTH_NONE) &amp;&amp;
 330                         !shc.negotiatedCipherSuite.isAnonymous()) {
 331                     for (SSLHandshake hs :
 332                             ke.getRelatedHandshakers(shc)) {
 333                         if (hs == SSLHandshake.CERTIFICATE) {
 334                             shc.handshakeProducers.put(
 335                                     SSLHandshake.CERTIFICATE_REQUEST.id,
 336                                     SSLHandshake.CERTIFICATE_REQUEST);
 337                             break;
 338                         }
 339                     }
 340                 }
 341                 shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO_DONE.id,
 342                         SSLHandshake.SERVER_HELLO_DONE);
 343             } else {
<span class="line-added"> 344                 // stateless and use the client session id (RFC 5077 3.4)</span>
<span class="line-added"> 345                 if (shc.statelessResumption) {</span>
<span class="line-added"> 346                     shc.resumingSession = new SSLSessionImpl(shc.resumingSession,</span>
<span class="line-added"> 347                             (clientHello.sessionId.length() == 0) ?</span>
<span class="line-added"> 348                                     new SessionId(true,</span>
<span class="line-added"> 349                                             shc.sslContext.getSecureRandom()) :</span>
<span class="line-added"> 350                                     new SessionId(clientHello.sessionId.getId())</span>
<span class="line-added"> 351                     );</span>
<span class="line-added"> 352                 }</span>
 353                 shc.handshakeSession = shc.resumingSession;
 354                 shc.negotiatedProtocol =
 355                         shc.resumingSession.getProtocolVersion();
 356                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 357                 shc.handshakeHash.determine(
 358                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 359             }
 360 
 361             // Generate the ServerHello handshake message.
 362             ServerHelloMessage shm = new ServerHelloMessage(shc,
 363                     shc.negotiatedProtocol,
 364                     shc.handshakeSession.getSessionId(),
 365                     shc.negotiatedCipherSuite,
 366                     new RandomCookie(shc),
 367                     clientHello);
 368             shc.serverHelloRandom = shm.serverRandom;
 369 
 370             // Produce extensions for ServerHello handshake message.
 371             SSLExtension[] serverHelloExtensions =
 372                 shc.sslConfig.getEnabledExtensions(
</pre>
<hr />
<pre>
 419             for (CipherSuite cs : preferred) {
 420                 if (!HandshakeContext.isNegotiable(
 421                         proposed, shc.negotiatedProtocol, cs)) {
 422                     continue;
 423                 }
 424 
 425                 if (shc.sslConfig.clientAuthType ==
 426                         ClientAuthType.CLIENT_AUTH_REQUIRED) {
 427                     if ((cs.keyExchange == KeyExchange.K_DH_ANON) ||
 428                         (cs.keyExchange == KeyExchange.K_ECDH_ANON)) {
 429                         continue;
 430                     }
 431                 }
 432 
 433                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 434                         cs.keyExchange, shc.negotiatedProtocol);
 435                 if (ke == null) {
 436                     continue;
 437                 }
 438                 if (!ServerHandshakeContext.legacyAlgorithmConstraints.permits(
<span class="line-modified"> 439                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), cs.name, null)) {</span>
 440                     legacySuites.add(cs);
 441                     continue;
 442                 }
 443 
 444                 SSLPossession[] hcds = ke.createPossessions(shc);
 445                 if ((hcds == null) || (hcds.length == 0)) {
 446                     continue;
 447                 }
 448 
 449                 // The cipher suite has been negotiated.
 450                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 451                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 452                 }
 453 
 454                 return new KeyExchangeProperties(cs, ke, hcds);
 455             }
 456 
 457             for (CipherSuite cs : legacySuites) {
 458                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 459                         cs.keyExchange,  shc.negotiatedProtocol);
</pre>
<hr />
<pre>
 487         }
 488     }
 489 
 490     /**
 491      * The &quot;ServerHello&quot; handshake message producer.
 492      */
 493     private static final
 494             class T13ServerHelloProducer implements HandshakeProducer {
 495         // Prevent instantiation of this class.
 496         private T13ServerHelloProducer() {
 497             // blank
 498         }
 499 
 500         @Override
 501         public byte[] produce(ConnectionContext context,
 502                 HandshakeMessage message) throws IOException {
 503             // The producing happens in server side only.
 504             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 505             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 506 
<span class="line-added"> 507             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="line-added"> 508                     shc.sslContext.engineGetServerSessionContext();</span>
<span class="line-added"> 509 </span>
 510             // If client hasn&#39;t specified a session we can resume, start a
 511             // new one and choose its cipher suite and compression options,
 512             // unless new session creation is disabled for this connection!
 513             if (!shc.isResumption || shc.resumingSession == null) {
 514                 if (!shc.sslConfig.enableSessionCreation) {
 515                     throw new SSLException(
 516                         &quot;Not resumption, and no new session is allowed&quot;);
 517                 }
 518 
 519                 if (shc.localSupportedSignAlgs == null) {
 520                     shc.localSupportedSignAlgs =
 521                         SignatureScheme.getSupportedAlgorithms(
 522                                 shc.algorithmConstraints, shc.activeProtocols);
 523                 }
 524 
 525                 SSLSessionImpl session =
 526                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 527                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 528                 shc.handshakeSession = session;
 529 
</pre>
<hr />
<pre>
 542                 shc.negotiatedCipherSuite = cipherSuite;
 543                 shc.handshakeSession.setSuite(cipherSuite);
 544                 shc.handshakeHash.determine(
 545                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 546             } else {
 547                 shc.handshakeSession = shc.resumingSession;
 548 
 549                 // consider the handshake extension impact
 550                 SSLExtension[] enabledExtensions =
 551                 shc.sslConfig.getEnabledExtensions(
 552                 SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 553                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 554 
 555                 shc.negotiatedProtocol =
 556                         shc.resumingSession.getProtocolVersion();
 557                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 558                 shc.handshakeHash.determine(
 559                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 560 
 561                 setUpPskKD(shc,
<span class="line-modified"> 562                         shc.resumingSession.consumePreSharedKey());</span>
 563 
 564                 // The session can&#39;t be resumed again---remove it from cache


 565                 sessionCache.remove(shc.resumingSession.getSessionId());
 566             }
 567 
 568             // update the responders
 569             shc.handshakeProducers.put(SSLHandshake.ENCRYPTED_EXTENSIONS.id,
 570                     SSLHandshake.ENCRYPTED_EXTENSIONS);
 571             shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 572                     SSLHandshake.FINISHED);
 573 
 574             // Generate the ServerHello handshake message.
 575             ServerHelloMessage shm = new ServerHelloMessage(shc,
 576                     ProtocolVersion.TLS12,      // use legacy version
 577                     clientHello.sessionId,      // echo back
 578                     shc.negotiatedCipherSuite,
 579                     new RandomCookie(shc),
 580                     clientHello);
 581             shc.serverHelloRandom = shm.serverRandom;
 582 
 583             // Produce extensions for ServerHello handshake message.
 584             SSLExtension[] serverHelloExtensions =
</pre>
<hr />
<pre>
 676             } catch (GeneralSecurityException gse) {
 677                 // unlikely
 678                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 679                         &quot;Missing cipher algorithm&quot;, gse);
 680             }
 681 
 682             if (writeCipher == null) {
 683                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 684                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 685                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 686                     &quot;)&quot;);
 687             }
 688 
 689             shc.baseWriteSecret = writeSecret;
 690             shc.conContext.outputRecord.changeWriteCiphers(
 691                     writeCipher, (clientHello.sessionId.length() != 0));
 692 
 693             // Update the context for master key derivation.
 694             shc.handshakeKeyDerivation = kd;
 695 
<span class="line-added"> 696             // Check if the server supports stateless resumption</span>
<span class="line-added"> 697             if (sessionCache.statelessEnabled()) {</span>
<span class="line-added"> 698                 shc.statelessResumption = true;</span>
<span class="line-added"> 699             }</span>
<span class="line-added"> 700 </span>
 701             // The handshake message has been delivered.
 702             return null;
 703         }
 704 
 705         private static CipherSuite chooseCipherSuite(
 706                 ServerHandshakeContext shc,
 707                 ClientHelloMessage clientHello) throws IOException {
 708             List&lt;CipherSuite&gt; preferred;
 709             List&lt;CipherSuite&gt; proposed;
 710             if (shc.sslConfig.preferLocalCipherSuites) {
 711                 preferred = shc.activeCipherSuites;
 712                 proposed = clientHello.cipherSuites;
 713             } else {
 714                 preferred = clientHello.cipherSuites;
 715                 proposed = shc.activeCipherSuites;
 716             }
 717 
 718             CipherSuite legacySuite = null;
 719             AlgorithmConstraints legacyConstraints =
 720                     ServerHandshakeContext.legacyAlgorithmConstraints;
 721             for (CipherSuite cs : preferred) {
 722                 if (!HandshakeContext.isNegotiable(
 723                         proposed, shc.negotiatedProtocol, cs)) {
 724                     continue;
 725                 }
 726 
 727                 if ((legacySuite == null) &amp;&amp;
<span class="line-modified"> 728                         !legacyConstraints.permits(</span>
<span class="line-added"> 729                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-added"> 730                                 cs.name, null)) {</span>
 731                     legacySuite = cs;
 732                     continue;
 733                 }
 734 
 735                 // The cipher suite has been negotiated.
 736                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 737                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 738                 }
 739                 return cs;
 740             }
 741 
 742             if (legacySuite != null) {
 743                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 744                     SSLLogger.warning(
 745                             &quot;use legacy cipher suite &quot; + legacySuite.name);
 746                 }
 747                 return legacySuite;
 748             }
 749 
 750             // no cipher suites in common
</pre>
<hr />
<pre>
1102                     }
1103                 }
1104             }
1105 
1106             // Check and launch ClientHello extensions.
1107             extTypes = chc.sslConfig.getEnabledExtensions(
1108                     SSLHandshake.SERVER_HELLO);
1109             serverHello.extensions.consumeOnLoad(chc, extTypes);
1110 
1111             if (!chc.isResumption) {
1112                 if (chc.resumingSession != null) {
1113                     // in case the resumption happens next time.
1114                     chc.resumingSession.invalidate();
1115                     chc.resumingSession = null;
1116                 }
1117 
1118                 if (!chc.sslConfig.enableSessionCreation) {
1119                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1120                         &quot;New session creation is disabled&quot;);
1121                 }
<span class="line-modified">1122 </span>
<span class="line-modified">1123                 if (serverHello.sessionId.length() == 0 &amp;&amp;</span>
<span class="line-modified">1124                         chc.statelessResumption) {</span>
<span class="line-added">1125                     SessionId newId = new SessionId(true,</span>
<span class="line-added">1126                             chc.sslContext.getSecureRandom());</span>
<span class="line-added">1127                     chc.handshakeSession = new SSLSessionImpl(chc,</span>
<span class="line-added">1128                             chc.negotiatedCipherSuite, newId);</span>
<span class="line-added">1129 </span>
<span class="line-added">1130                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">1131                         SSLLogger.fine(&quot;Locally assigned Session Id: &quot; +</span>
<span class="line-added">1132                                 newId.toString());</span>
<span class="line-added">1133                     }</span>
<span class="line-added">1134                 } else {</span>
<span class="line-added">1135                     chc.handshakeSession = new SSLSessionImpl(chc,</span>
<span class="line-added">1136                             chc.negotiatedCipherSuite,</span>
<span class="line-added">1137                             serverHello.sessionId);</span>
<span class="line-added">1138                 }</span>
1139                 chc.handshakeSession.setMaximumPacketSize(
1140                         chc.sslConfig.maximumPacketSize);
1141             }
1142 
1143             //
1144             // update
1145             //
1146             serverHello.extensions.consumeOnTrade(chc, extTypes);
1147 
1148             // update the consumers and producers
1149             if (chc.isResumption) {
1150                 SSLTrafficKeyDerivation kdg =
1151                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1152                 if (kdg == null) {
1153                     // unlikely
1154                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1155                             &quot;Not supported key derivation: &quot; +
1156                             chc.negotiatedProtocol);
1157                 } else {
1158                     chc.handshakeKeyDerivation = kdg.createKeyDerivation(
1159                             chc, chc.resumingSession.getMasterSecret());
1160                 }
1161 
<span class="line-added">1162                 if (chc.statelessResumption) {</span>
<span class="line-added">1163                     chc.handshakeConsumers.putIfAbsent(</span>
<span class="line-added">1164                             SSLHandshake.NEW_SESSION_TICKET.id,</span>
<span class="line-added">1165                             SSLHandshake.NEW_SESSION_TICKET);</span>
<span class="line-added">1166                 }</span>
1167                 chc.conContext.consumers.putIfAbsent(
1168                         ContentType.CHANGE_CIPHER_SPEC.id,
1169                         ChangeCipherSpec.t10Consumer);
1170                 chc.handshakeConsumers.put(
1171                         SSLHandshake.FINISHED.id,
1172                         SSLHandshake.FINISHED);
1173             } else {
1174                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
1175                         chc.negotiatedCipherSuite.keyExchange,
1176                         chc.negotiatedProtocol);
1177                 chc.handshakeKeyExchange = ke;
1178                 if (ke != null) {
1179                     for (SSLHandshake handshake :
1180                             ke.getRelatedHandshakers(chc)) {
1181                         chc.handshakeConsumers.put(handshake.id, handshake);
1182                     }
1183                 }
1184 
1185                 chc.handshakeConsumers.put(SSLHandshake.SERVER_HELLO_DONE.id,
1186                         SSLHandshake.SERVER_HELLO_DONE);
</pre>
<hr />
<pre>
1245                     SSLHandshake.SERVER_HELLO);
1246             serverHello.extensions.consumeOnLoad(chc, extTypes);
1247             if (!chc.isResumption) {
1248                 if (chc.resumingSession != null) {
1249                     // in case the resumption happens next time.
1250                     chc.resumingSession.invalidate();
1251                     chc.resumingSession = null;
1252                 }
1253 
1254                 if (!chc.sslConfig.enableSessionCreation) {
1255                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1256                         &quot;New session creation is disabled&quot;);
1257                 }
1258                 chc.handshakeSession = new SSLSessionImpl(chc,
1259                         chc.negotiatedCipherSuite,
1260                         serverHello.sessionId);
1261                 chc.handshakeSession.setMaximumPacketSize(
1262                         chc.sslConfig.maximumPacketSize);
1263             } else {
1264                 // The PSK is consumed to allow it to be deleted
<span class="line-modified">1265                 SecretKey psk =</span>
1266                         chc.resumingSession.consumePreSharedKey();
<span class="line-modified">1267                 if(psk == null) {</span>
1268                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1269                     &quot;No PSK available. Unable to resume.&quot;);
1270                 }
1271 
1272                 chc.handshakeSession = chc.resumingSession;
1273 
<span class="line-modified">1274                 setUpPskKD(chc, psk);</span>
1275             }
1276 
1277             //
1278             // update
1279             //
1280             serverHello.extensions.consumeOnTrade(chc, extTypes);
1281 
1282             // Change client/server handshake traffic secrets.
1283             // Refresh handshake hash
1284             chc.handshakeHash.update();
1285 
1286             SSLKeyExchange ke = chc.handshakeKeyExchange;
1287             if (ke == null) {
1288                 // unlikely
1289                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1290                         &quot;Not negotiated key shares&quot;);
1291             }
1292 
1293             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(chc);
1294             SecretKey handshakeSecret = handshakeKD.deriveKey(
</pre>
</td>
</tr>
</table>
<center><a href="SSLTransport.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ServerHelloDone.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
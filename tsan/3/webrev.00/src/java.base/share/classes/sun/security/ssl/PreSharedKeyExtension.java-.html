<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Objects;
 36 import java.util.Optional;
 37 import java.util.Collection;
 38 import javax.crypto.Mac;
 39 import javax.crypto.SecretKey;
 40 import javax.net.ssl.SSLPeerUnverifiedException;
 41 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 42 import sun.security.ssl.ClientHello.ClientHelloMessage;
 43 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 44 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 45 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 46 import static sun.security.ssl.SSLExtension.*;
 47 
 48 /**
 49  * Pack of the &quot;pre_shared_key&quot; extension.
 50  */
 51 final class PreSharedKeyExtension {
 52     static final HandshakeProducer chNetworkProducer =
 53             new CHPreSharedKeyProducer();
 54     static final ExtensionConsumer chOnLoadConsumer =
 55             new CHPreSharedKeyConsumer();
 56     static final HandshakeAbsence chOnLoadAbsence =
 57             new CHPreSharedKeyAbsence();
 58     static final HandshakeConsumer chOnTradeConsumer =
 59             new CHPreSharedKeyUpdate();
 60     static final SSLStringizer chStringizer =
 61             new CHPreSharedKeyStringizer();
 62 
 63     static final HandshakeProducer shNetworkProducer =
 64             new SHPreSharedKeyProducer();
 65     static final ExtensionConsumer shOnLoadConsumer =
 66             new SHPreSharedKeyConsumer();
 67     static final HandshakeAbsence shOnLoadAbsence =
 68             new SHPreSharedKeyAbsence();
 69     static final SSLStringizer shStringizer =
 70             new SHPreSharedKeyStringizer();
 71 
 72     private static final class PskIdentity {
 73         final byte[] identity;
 74         final int obfuscatedAge;
 75 
 76         PskIdentity(byte[] identity, int obfuscatedAge) {
 77             this.identity = identity;
 78             this.obfuscatedAge = obfuscatedAge;
 79         }
 80 
 81         int getEncodedLength() {
 82             return 2 + identity.length + 4;
 83         }
 84 
 85         void writeEncoded(ByteBuffer m) throws IOException {
 86             Record.putBytes16(m, identity);
 87             Record.putInt32(m, obfuscatedAge);
 88         }
 89 
 90         @Override
 91         public String toString() {
 92             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;,&quot; +
 93                 obfuscatedAge + &quot;}&quot;;
 94         }
 95     }
 96 
 97     private static final
 98             class CHPreSharedKeySpec implements SSLExtensionSpec {
 99         final List&lt;PskIdentity&gt; identities;
100         final List&lt;byte[]&gt; binders;
101 
102         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
103             this.identities = identities;
104             this.binders = binders;
105         }
106 
107         CHPreSharedKeySpec(HandshakeContext context,
108                 ByteBuffer m) throws IOException {
109             // struct {
110             //     PskIdentity identities&lt;7..2^16-1&gt;;
111             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
112             // } OfferedPsks;
113             if (m.remaining() &lt; 44) {
114                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
115                     &quot;Invalid pre_shared_key extension: &quot; +
116                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;);
117             }
118 
119             int idEncodedLength = Record.getInt16(m);
120             if (idEncodedLength &lt; 7) {
121                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
122                     &quot;Invalid pre_shared_key extension: &quot; +
123                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;);
124             }
125 
126             identities = new ArrayList&lt;&gt;();
127             int idReadLength = 0;
128             while (idReadLength &lt; idEncodedLength) {
129                 byte[] id = Record.getBytes16(m);
130                 if (id.length &lt; 1) {
131                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
132                         &quot;Invalid pre_shared_key extension: &quot; +
133                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;);
134                 }
135                 int obfuscatedTicketAge = Record.getInt32(m);
136 
137                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
138                 identities.add(pskId);
139                 idReadLength += pskId.getEncodedLength();
140             }
141 
142             if (m.remaining() &lt; 35) {
143                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
144                         &quot;Invalid pre_shared_key extension: &quot; +
145                         &quot;insufficient binders data (length=&quot; +
146                         m.remaining() + &quot;)&quot;);
147             }
148 
149             int bindersEncodedLen = Record.getInt16(m);
150             if (bindersEncodedLen &lt; 33) {
151                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
152                         &quot;Invalid pre_shared_key extension: &quot; +
153                         &quot;insufficient binders (length=&quot; +
154                         bindersEncodedLen + &quot;)&quot;);
155             }
156 
157             binders = new ArrayList&lt;&gt;();
158             int bindersReadLength = 0;
159             while (bindersReadLength &lt; bindersEncodedLen) {
160                 byte[] binder = Record.getBytes8(m);
161                 if (binder.length &lt; 32) {
162                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
163                             &quot;Invalid pre_shared_key extension: &quot; +
164                             &quot;insufficient binder entry (length=&quot; +
165                             binder.length + &quot;)&quot;);
166                 }
167                 binders.add(binder);
168                 bindersReadLength += 1 + binder.length;
169             }
170         }
171 
172         int getIdsEncodedLength() {
173             int idEncodedLength = 0;
174             for (PskIdentity curId : identities) {
175                 idEncodedLength += curId.getEncodedLength();
176             }
177 
178             return idEncodedLength;
179         }
180 
181         int getBindersEncodedLength() {
182             int binderEncodedLength = 0;
183             for (byte[] curBinder : binders) {
184                 binderEncodedLength += 1 + curBinder.length;
185             }
186 
187             return binderEncodedLength;
188         }
189 
190         byte[] getEncoded() throws IOException {
191             int idsEncodedLength = getIdsEncodedLength();
192             int bindersEncodedLength = getBindersEncodedLength();
193             int encodedLength = 4 + idsEncodedLength + bindersEncodedLength;
194             byte[] buffer = new byte[encodedLength];
195             ByteBuffer m = ByteBuffer.wrap(buffer);
196             Record.putInt16(m, idsEncodedLength);
197             for (PskIdentity curId : identities) {
198                 curId.writeEncoded(m);
199             }
200             Record.putInt16(m, bindersEncodedLength);
201             for (byte[] curBinder : binders) {
202                 Record.putBytes8(m, curBinder);
203             }
204 
205             return buffer;
206         }
207 
208         @Override
209         public String toString() {
210             MessageFormat messageFormat = new MessageFormat(
211                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
212                 &quot;  \&quot;identities\&quot;    : \&quot;{0}\&quot;,\n&quot; +
213                 &quot;  \&quot;binders\&quot;       : \&quot;{1}\&quot;,\n&quot; +
214                 &quot;&#39;}&#39;&quot;,
215                 Locale.ENGLISH);
216 
217             Object[] messageFields = {
218                 Utilities.indent(identitiesString()),
219                 Utilities.indent(bindersString())
220             };
221 
222             return messageFormat.format(messageFields);
223         }
224 
225         String identitiesString() {
226             StringBuilder result = new StringBuilder();
227             for (PskIdentity curId : identities) {
228                 result.append(curId.toString() + &quot;\n&quot;);
229             }
230 
231             return result.toString();
232         }
233 
234         String bindersString() {
235             StringBuilder result = new StringBuilder();
236             for (byte[] curBinder : binders) {
237                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
238             }
239 
240             return result.toString();
241         }
242     }
243 
244     private static final
245             class CHPreSharedKeyStringizer implements SSLStringizer {
246         @Override
247         public String toString(ByteBuffer buffer) {
248             try {
249                 // As the HandshakeContext parameter of CHPreSharedKeySpec
250                 // constructor is used for fatal alert only, we can use
251                 // null HandshakeContext here as we don&#39;t care about exception.
252                 //
253                 // Please take care of this code if the CHPreSharedKeySpec
254                 // constructor is updated in the future.
255                 return (new CHPreSharedKeySpec(null, buffer)).toString();
256             } catch (Exception ex) {
257                 // For debug logging only, so please swallow exceptions.
258                 return ex.getMessage();
259             }
260         }
261     }
262 
263     private static final
264             class SHPreSharedKeySpec implements SSLExtensionSpec {
265         final int selectedIdentity;
266 
267         SHPreSharedKeySpec(int selectedIdentity) {
268             this.selectedIdentity = selectedIdentity;
269         }
270 
271         SHPreSharedKeySpec(HandshakeContext context,
272                 ByteBuffer m) throws IOException {
273             if (m.remaining() &lt; 2) {
274                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
275                         &quot;Invalid pre_shared_key extension: &quot; +
276                         &quot;insufficient selected_identity (length=&quot; +
277                         m.remaining() + &quot;)&quot;);
278             }
279             this.selectedIdentity = Record.getInt16(m);
280         }
281 
282         byte[] getEncoded() throws IOException {
283             return new byte[] {
284                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
285                 (byte)(selectedIdentity &amp; 0xFF)
286             };
287         }
288 
289         @Override
290         public String toString() {
291             MessageFormat messageFormat = new MessageFormat(
292                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
293                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
294                 &quot;&#39;}&#39;&quot;,
295                 Locale.ENGLISH);
296 
297             Object[] messageFields = {
298                 Utilities.byte16HexString(selectedIdentity)
299             };
300 
301             return messageFormat.format(messageFields);
302         }
303     }
304 
305     private static final
306             class SHPreSharedKeyStringizer implements SSLStringizer {
307         @Override
308         public String toString(ByteBuffer buffer) {
309             try {
310                 // As the HandshakeContext parameter of SHPreSharedKeySpec
311                 // constructor is used for fatal alert only, we can use
312                 // null HandshakeContext here as we don&#39;t care about exception.
313                 //
314                 // Please take care of this code if the SHPreSharedKeySpec
315                 // constructor is updated in the future.
316                 return (new SHPreSharedKeySpec(null, buffer)).toString();
317             } catch (Exception ex) {
318                 // For debug logging only, so please swallow exceptions.
319                 return ex.getMessage();
320             }
321         }
322     }
323 
324     private static final
325             class CHPreSharedKeyConsumer implements ExtensionConsumer {
326         // Prevent instantiation of this class.
327         private CHPreSharedKeyConsumer() {
328             // blank
329         }
330 
331         @Override
332         public void consume(ConnectionContext context,
333                             HandshakeMessage message,
334                             ByteBuffer buffer) throws IOException {
335             ClientHelloMessage clientHello = (ClientHelloMessage) message;
336             ServerHandshakeContext shc = (ServerHandshakeContext)context;
337             // Is it a supported and enabled extension?
338             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
339                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
340                     SSLLogger.fine(
341                             &quot;Ignore unavailable pre_shared_key extension&quot;);
342                 }
343                 return;     // ignore the extension
344             }
345 
346             // Parse the extension.
347             CHPreSharedKeySpec pskSpec = null;
348             try {
349                 pskSpec = new CHPreSharedKeySpec(shc, buffer);
350             } catch (IOException ioe) {
351                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
352             }
353 
354             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
355             if (!shc.handshakeExtensions.containsKey(
356                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
357                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
358                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
359                         &quot;extension is not the last extension&quot;);
360             }
361 
362             // error if id and binder lists are not the same length
363             if (pskSpec.identities.size() != pskSpec.binders.size()) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;PSK extension has incorrect number of binders&quot;);
366             }
367 
368             if (shc.isResumption) {     // resumingSession may not be set
369                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
370                         shc.sslContext.engineGetServerSessionContext();
371                 int idIndex = 0;
372                 for (PskIdentity requestedId : pskSpec.identities) {
373                     SSLSessionImpl s = sessionCache.get(requestedId.identity);
374                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
375                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
376                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
377                         }
378 
379                         // binder will be checked later
380                         shc.resumingSession = s;
381                         shc.handshakeExtensions.put(SH_PRE_SHARED_KEY,
382                             new SHPreSharedKeySpec(idIndex));   // for the index
383                         break;
384                     }
385 
386                     ++idIndex;
387                 }
388 
389                 if (idIndex == pskSpec.identities.size()) {
390                     // no resumable session
391                     shc.isResumption = false;
392                     shc.resumingSession = null;
393                 }
394             }
395 
396             // update the context
397             shc.handshakeExtensions.put(
398                 SSLExtension.CH_PRE_SHARED_KEY, pskSpec);
399         }
400     }
401 
402     private static boolean canRejoin(ClientHelloMessage clientHello,
403         ServerHandshakeContext shc, SSLSessionImpl s) {
404 
405         boolean result = s.isRejoinable() &amp;&amp; s.getPreSharedKey().isPresent();
406 
407         // Check protocol version
408         if (result &amp;&amp; s.getProtocolVersion() != shc.negotiatedProtocol) {
409             if (SSLLogger.isOn &amp;&amp;
410                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
411 
412                 SSLLogger.finest(&quot;Can&#39;t resume, incorrect protocol version&quot;);
413             }
414             result = false;
415         }
416 
417         // Make sure that the server handshake context&#39;s localSupportedSignAlgs
418         // field is populated.  This is particularly important when
419         // client authentication was used in an initial session and it is
420         // now being resumed.
421         if (shc.localSupportedSignAlgs == null) {
422             shc.localSupportedSignAlgs =
423                     SignatureScheme.getSupportedAlgorithms(
424                             shc.algorithmConstraints, shc.activeProtocols);
425         }
426 
427         // Validate the required client authentication.
428         if (result &amp;&amp;
429             (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {
430             try {
431                 s.getPeerPrincipal();
432             } catch (SSLPeerUnverifiedException e) {
433                 if (SSLLogger.isOn &amp;&amp;
434                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
435                     SSLLogger.finest(
436                         &quot;Can&#39;t resume, &quot; +
437                         &quot;client authentication is required&quot;);
438                 }
439                 result = false;
440             }
441 
442             // Make sure the list of supported signature algorithms matches
443             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
444                 s.getLocalSupportedSignatureSchemes();
445             if (result &amp;&amp;
446                 !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
447 
448                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
449                     SSLLogger.fine(&quot;Can&#39;t resume. Session uses different &quot; +
450                         &quot;signature algorithms&quot;);
451                 }
452                 result = false;
453             }
454         }
455 
456         // ensure that the endpoint identification algorithm matches the
457         // one in the session
458         String identityAlg = shc.sslConfig.identificationProtocol;
459         if (result &amp;&amp; identityAlg != null) {
460             String sessionIdentityAlg = s.getIdentificationProtocol();
461             if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {
462                 if (SSLLogger.isOn &amp;&amp;
463                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
464 
465                     SSLLogger.finest(&quot;Can&#39;t resume, endpoint id&quot; +
466                         &quot; algorithm does not match, requested: &quot; +
467                         identityAlg + &quot;, cached: &quot; + sessionIdentityAlg);
468                 }
469                 result = false;
470             }
471         }
472 
473         // Ensure cipher suite can be negotiated
474         if (result &amp;&amp; (!shc.isNegotiable(s.getSuite()) ||
475             !clientHello.cipherSuites.contains(s.getSuite()))) {
476             if (SSLLogger.isOn &amp;&amp;
477                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
478                 SSLLogger.finest(
479                     &quot;Can&#39;t resume, unavailable session cipher suite&quot;);
480             }
481             result = false;
482         }
483 
484         return result;
485     }
486 
487     private static final
488             class CHPreSharedKeyUpdate implements HandshakeConsumer {
489         // Prevent instantiation of this class.
490         private CHPreSharedKeyUpdate() {
491             // blank
492         }
493 
494         @Override
495         public void consume(ConnectionContext context,
496                 HandshakeMessage message) throws IOException {
497             ServerHandshakeContext shc = (ServerHandshakeContext)context;
498             if (!shc.isResumption || shc.resumingSession == null) {
499                 // not resuming---nothing to do
500                 return;
501             }
502 
503             CHPreSharedKeySpec chPsk = (CHPreSharedKeySpec)
504                     shc.handshakeExtensions.get(SSLExtension.CH_PRE_SHARED_KEY);
505             SHPreSharedKeySpec shPsk = (SHPreSharedKeySpec)
506                     shc.handshakeExtensions.get(SSLExtension.SH_PRE_SHARED_KEY);
507             if (chPsk == null || shPsk == null) {
508                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
509                         &quot;Required extensions are unavailable&quot;);
510             }
511 
512             byte[] binder = chPsk.binders.get(shPsk.selectedIdentity);
513 
514             // set up PSK binder hash
515             HandshakeHash pskBinderHash = shc.handshakeHash.copy();
516             byte[] lastMessage = pskBinderHash.removeLastReceived();
517             ByteBuffer messageBuf = ByteBuffer.wrap(lastMessage);
518             // skip the type and length
519             messageBuf.position(4);
520             // read to find the beginning of the binders
521             ClientHelloMessage.readPartial(shc.conContext, messageBuf);
522             int length = messageBuf.position();
523             messageBuf.position(0);
524             pskBinderHash.receive(messageBuf, length);
525 
526             checkBinder(shc, shc.resumingSession, pskBinderHash, binder);
527         }
528     }
529 
530     private static void checkBinder(ServerHandshakeContext shc,
531             SSLSessionImpl session,
532             HandshakeHash pskBinderHash, byte[] binder) throws IOException {
533         Optional&lt;SecretKey&gt; pskOpt = session.getPreSharedKey();
534         if (!pskOpt.isPresent()) {
535             throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
536                     &quot;Session has no PSK&quot;);
537         }
538         SecretKey psk = pskOpt.get();
539 
540         SecretKey binderKey = deriveBinderKey(shc, psk, session);
541         byte[] computedBinder =
542                 computeBinder(shc, binderKey, session, pskBinderHash);
543         if (!Arrays.equals(binder, computedBinder)) {
544             throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
545                     &quot;Incorect PSK binder value&quot;);
546         }
547     }
548 
549     // Class that produces partial messages used to compute binder hash
550     static final class PartialClientHelloMessage extends HandshakeMessage {
551 
552         private final ClientHello.ClientHelloMessage msg;
553         private final CHPreSharedKeySpec psk;
554 
555         PartialClientHelloMessage(HandshakeContext ctx,
556                                   ClientHello.ClientHelloMessage msg,
557                                   CHPreSharedKeySpec psk) {
558             super(ctx);
559 
560             this.msg = msg;
561             this.psk = psk;
562         }
563 
564         @Override
565         SSLHandshake handshakeType() {
566             return msg.handshakeType();
567         }
568 
569         private int pskTotalLength() {
570             return psk.getIdsEncodedLength() +
571                 psk.getBindersEncodedLength() + 8;
572         }
573 
574         @Override
575         int messageLength() {
576 
577             if (msg.extensions.get(SSLExtension.CH_PRE_SHARED_KEY) != null) {
578                 return msg.messageLength();
579             } else {
580                 return msg.messageLength() + pskTotalLength();
581             }
582         }
583 
584         @Override
585         void send(HandshakeOutStream hos) throws IOException {
586             msg.sendCore(hos);
587 
588             // complete extensions
589             int extsLen = msg.extensions.length();
590             if (msg.extensions.get(SSLExtension.CH_PRE_SHARED_KEY) == null) {
591                 extsLen += pskTotalLength();
592             }
593             hos.putInt16(extsLen - 2);
594             // write the complete extensions
595             for (SSLExtension ext : SSLExtension.values()) {
596                 byte[] extData = msg.extensions.get(ext);
597                 if (extData == null) {
598                     continue;
599                 }
600                 // the PSK could be there from an earlier round
601                 if (ext == SSLExtension.CH_PRE_SHARED_KEY) {
602                     continue;
603                 }
604                 int extID = ext.id;
605                 hos.putInt16(extID);
606                 hos.putBytes16(extData);
607             }
608 
609             // partial PSK extension
610             int extID = SSLExtension.CH_PRE_SHARED_KEY.id;
611             hos.putInt16(extID);
612             byte[] encodedPsk = psk.getEncoded();
613             hos.putInt16(encodedPsk.length);
614             hos.write(encodedPsk, 0, psk.getIdsEncodedLength() + 2);
615         }
616     }
617 
618     private static final
619             class CHPreSharedKeyProducer implements HandshakeProducer {
620         // Prevent instantiation of this class.
621         private CHPreSharedKeyProducer() {
622             // blank
623         }
624 
625         @Override
626         public byte[] produce(ConnectionContext context,
627                 HandshakeMessage message) throws IOException {
628 
629             // The producing happens in client side only.
630             ClientHandshakeContext chc = (ClientHandshakeContext)context;
631             if (!chc.isResumption || chc.resumingSession == null) {
632                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
633                     SSLLogger.fine(&quot;No session to resume.&quot;);
634                 }
635                 return null;
636             }
637 
638             // Make sure the list of supported signature algorithms matches
639             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
640                 chc.resumingSession.getLocalSupportedSignatureSchemes();
641             if (!chc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
642                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
643                     SSLLogger.fine(&quot;Existing session uses different &quot; +
644                         &quot;signature algorithms&quot;);
645                 }
646                 return null;
647             }
648 
649             // The session must have a pre-shared key
650             Optional&lt;SecretKey&gt; pskOpt = chc.resumingSession.getPreSharedKey();
651             if (!pskOpt.isPresent()) {
652                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
653                     SSLLogger.fine(&quot;Existing session has no PSK.&quot;);
654                 }
655                 return null;
656             }
657             SecretKey psk = pskOpt.get();
658             // The PSK ID can only be used in one connections, but this method
659             // may be called twice in a connection if the server sends HRR.
660             // ID is saved in the context so it can be used in the second call.
661             Optional&lt;byte[]&gt; pskIdOpt = Optional.ofNullable(chc.pskIdentity)
662                 .or(chc.resumingSession::consumePskIdentity);
663             if (!pskIdOpt.isPresent()) {
664                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
665                     SSLLogger.fine(
666                         &quot;PSK has no identity, or identity was already used&quot;);
667                 }
668                 return null;
669             }
670             chc.pskIdentity = pskIdOpt.get();
671 
672             //The session cannot be used again. Remove it from the cache.
673             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
674                 chc.sslContext.engineGetClientSessionContext();
675             sessionCache.remove(chc.resumingSession.getSessionId());
676 
677             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
678                 SSLLogger.fine(
679                     &quot;Found resumable session. Preparing PSK message.&quot;);
680             }
681 
682             List&lt;PskIdentity&gt; identities = new ArrayList&lt;&gt;();
683             int ageMillis = (int)(System.currentTimeMillis() -
684                     chc.resumingSession.getTicketCreationTime());
685             int obfuscatedAge =
686                     ageMillis + chc.resumingSession.getTicketAgeAdd();
687             identities.add(new PskIdentity(chc.pskIdentity, obfuscatedAge));
688 
689             SecretKey binderKey =
690                     deriveBinderKey(chc, psk, chc.resumingSession);
691             ClientHelloMessage clientHello = (ClientHelloMessage)message;
692             CHPreSharedKeySpec pskPrototype = createPskPrototype(
693                 chc.resumingSession.getSuite().hashAlg.hashLength, identities);
694             HandshakeHash pskBinderHash = chc.handshakeHash.copy();
695 
696             byte[] binder = computeBinder(chc, binderKey, pskBinderHash,
697                     chc.resumingSession, chc, clientHello, pskPrototype);
698 
699             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
700             binders.add(binder);
701 
702             CHPreSharedKeySpec pskMessage =
703                     new CHPreSharedKeySpec(identities, binders);
704             chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);
705             return pskMessage.getEncoded();
706         }
707 
708         private CHPreSharedKeySpec createPskPrototype(
709                 int hashLength, List&lt;PskIdentity&gt; identities) {
710             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
711             byte[] binderProto = new byte[hashLength];
712             for (PskIdentity curId : identities) {
713                 binders.add(binderProto);
714             }
715 
716             return new CHPreSharedKeySpec(identities, binders);
717         }
718     }
719 
720     private static byte[] computeBinder(
721             HandshakeContext context, SecretKey binderKey,
722             SSLSessionImpl session,
723             HandshakeHash pskBinderHash) throws IOException {
724 
725         pskBinderHash.determine(
726                 session.getProtocolVersion(), session.getSuite());
727         pskBinderHash.update();
728         byte[] digest = pskBinderHash.digest();
729 
730         return computeBinder(context, binderKey, session, digest);
731     }
732 
733     private static byte[] computeBinder(
734             HandshakeContext context, SecretKey binderKey,
735             HandshakeHash hash, SSLSessionImpl session,
736             HandshakeContext ctx, ClientHello.ClientHelloMessage hello,
737             CHPreSharedKeySpec pskPrototype) throws IOException {
738 
739         PartialClientHelloMessage partialMsg =
740                 new PartialClientHelloMessage(ctx, hello, pskPrototype);
741 
742         SSLEngineOutputRecord record = new SSLEngineOutputRecord(hash);
743         HandshakeOutStream hos = new HandshakeOutStream(record);
744         partialMsg.write(hos);
745 
746         hash.determine(session.getProtocolVersion(), session.getSuite());
747         hash.update();
748         byte[] digest = hash.digest();
749 
750         return computeBinder(context, binderKey, session, digest);
751     }
752 
753     private static byte[] computeBinder(HandshakeContext context,
754             SecretKey binderKey,
755             SSLSessionImpl session, byte[] digest) throws IOException {
756         try {
757             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
758             HKDF hkdf = new HKDF(hashAlg.name);
759             byte[] label = (&quot;tls13 finished&quot;).getBytes();
760             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
761                     label, new byte[0], hashAlg.hashLength);
762             SecretKey finishedKey = hkdf.expand(
763                     binderKey, hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
764 
765             String hmacAlg =
766                 &quot;Hmac&quot; + hashAlg.name.replace(&quot;-&quot;, &quot;&quot;);
767             try {
768                 Mac hmac = Mac.getInstance(hmacAlg);
769                 hmac.init(finishedKey);
770                 return hmac.doFinal(digest);
771             } catch (NoSuchAlgorithmException | InvalidKeyException ex) {
772                 throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
773             }
774         } catch (GeneralSecurityException ex) {
775             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
776         }
777     }
778 
779     private static SecretKey deriveBinderKey(HandshakeContext context,
780             SecretKey psk, SSLSessionImpl session) throws IOException {
781         try {
782             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
783             HKDF hkdf = new HKDF(hashAlg.name);
784             byte[] zeros = new byte[hashAlg.hashLength];
785             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
786 
787             byte[] label = (&quot;tls13 res binder&quot;).getBytes();
788             MessageDigest md = MessageDigest.getInstance(hashAlg.name);
789             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
790                     label, md.digest(new byte[0]), hashAlg.hashLength);
791             return hkdf.expand(earlySecret,
792                     hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
793         } catch (GeneralSecurityException ex) {
794             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
795         }
796     }
797 
798     private static final
799             class CHPreSharedKeyAbsence implements HandshakeAbsence {
800         @Override
801         public void absent(ConnectionContext context,
802                            HandshakeMessage message) throws IOException {
803 
804             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
805                 SSLLogger.fine(
806                 &quot;Handling pre_shared_key absence.&quot;);
807             }
808 
809             ServerHandshakeContext shc = (ServerHandshakeContext)context;
810 
811             // Resumption is only determined by PSK, when enabled
812             shc.resumingSession = null;
813             shc.isResumption = false;
814         }
815     }
816 
817     private static final
818             class SHPreSharedKeyConsumer implements ExtensionConsumer {
819         // Prevent instantiation of this class.
820         private SHPreSharedKeyConsumer() {
821             // blank
822         }
823 
824         @Override
825         public void consume(ConnectionContext context,
826             HandshakeMessage message, ByteBuffer buffer) throws IOException {
827             // The consuming happens in client side only.
828             ClientHandshakeContext chc = (ClientHandshakeContext)context;
829 
830             // Is it a response of the specific request?
831             if (!chc.handshakeExtensions.containsKey(
832                     SSLExtension.CH_PRE_SHARED_KEY)) {
833                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
834                     &quot;Server sent unexpected pre_shared_key extension&quot;);
835             }
836 
837             SHPreSharedKeySpec shPsk = new SHPreSharedKeySpec(chc, buffer);
838             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
839                 SSLLogger.fine(
840                     &quot;Received pre_shared_key extension: &quot;, shPsk);
841             }
842 
843             if (shPsk.selectedIdentity != 0) {
844                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
845                     &quot;Selected identity index is not in correct range.&quot;);
846             }
847 
848             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
849                 SSLLogger.fine(
850                         &quot;Resuming session: &quot;, chc.resumingSession);
851             }
852         }
853     }
854 
855     private static final
856             class SHPreSharedKeyAbsence implements HandshakeAbsence {
857         @Override
858         public void absent(ConnectionContext context,
859                 HandshakeMessage message) throws IOException {
860             ClientHandshakeContext chc = (ClientHandshakeContext)context;
861 
862             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
863                 SSLLogger.fine(&quot;Handling pre_shared_key absence.&quot;);
864             }
865 
866             // The server refused to resume, or the client did not
867             // request 1.3 resumption.
868             chc.resumingSession = null;
869             chc.isResumption = false;
870         }
871     }
872 
873     private static final
874             class SHPreSharedKeyProducer implements HandshakeProducer {
875         // Prevent instantiation of this class.
876         private SHPreSharedKeyProducer() {
877             // blank
878         }
879 
880         @Override
881         public byte[] produce(ConnectionContext context,
882                 HandshakeMessage message) throws IOException {
883             ServerHandshakeContext shc = (ServerHandshakeContext)context;
884             SHPreSharedKeySpec psk = (SHPreSharedKeySpec)
885                     shc.handshakeExtensions.get(SH_PRE_SHARED_KEY);
886             if (psk == null) {
887                 return null;
888             }
889 
890             return psk.getEncoded();
891         }
892     }
893 }
    </pre>
  </body>
</html>
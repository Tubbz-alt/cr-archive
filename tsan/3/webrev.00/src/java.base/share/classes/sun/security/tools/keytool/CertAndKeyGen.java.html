<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/tools/keytool/CertAndKeyGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.tools.keytool;
 27 
 28 import java.io.IOException;
 29 import java.security.cert.X509Certificate;
 30 import java.security.cert.CertificateException;
 31 import java.security.cert.CertificateEncodingException;
 32 import java.security.*;
 33 import java.security.spec.AlgorithmParameterSpec;
 34 import java.security.spec.ECGenParameterSpec;
 35 import java.security.spec.NamedParameterSpec;
 36 import java.util.Date;
 37 
 38 import sun.security.pkcs10.PKCS10;
 39 import sun.security.x509.*;
 40 
 41 /**
 42  * Generate a pair of keys, and provide access to them.  This class is
 43  * provided primarily for ease of use.
 44  *
 45  * &lt;P&gt;This provides some simple certificate management functionality.
 46  * Specifically, it allows you to create self-signed X.509 certificates
 47  * as well as PKCS 10 based certificate signing requests.
 48  *
 49  * &lt;P&gt;Keys for some public key signature algorithms have algorithm
 50  * parameters, such as DSS/DSA.  Some sites&#39; Certificate Authorities
 51  * adopt fixed algorithm parameters, which speeds up some operations
 52  * including key generation and signing.  &lt;em&gt;At this time, this interface
 53  * supports initializing with a named group.&lt;/em&gt;
 54  *
 55  * &lt;P&gt;Also, note that at this time only signature-capable keys may be
 56  * acquired through this interface.  Diffie-Hellman keys, used for secure
 57  * key exchange, may be supported later.
 58  *
 59  * @author David Brownell
 60  * @author Hemma Prafullchandra
 61  * @see PKCS10
 62  * @see X509CertImpl
 63  */
 64 public final class CertAndKeyGen {
 65     /**
 66      * Creates a CertAndKeyGen object for a particular key type
 67      * and signature algorithm.
 68      *
 69      * @param keyType type of key, e.g. &quot;RSA&quot;, &quot;DSA&quot;
 70      * @param sigAlg name of the signature algorithm, e.g. &quot;MD5WithRSA&quot;,
 71      *          &quot;MD2WithRSA&quot;, &quot;SHAwithDSA&quot;. If set to null, a default
 72      *          algorithm matching the private key will be chosen after
 73      *          the first keypair is generated.
 74      * @exception NoSuchAlgorithmException on unrecognized algorithms.
 75      */
 76     public CertAndKeyGen (String keyType, String sigAlg)
 77     throws NoSuchAlgorithmException
 78     {
 79         keyGen = KeyPairGenerator.getInstance(keyType);
 80         this.sigAlg = sigAlg;
 81         this.keyType = keyType;
 82     }
 83 
 84     /**
 85      * Creates a CertAndKeyGen object for a particular key type,
 86      * signature algorithm, and provider.
 87      *
 88      * @param keyType type of key, e.g. &quot;RSA&quot;, &quot;DSA&quot;
 89      * @param sigAlg name of the signature algorithm, e.g. &quot;MD5WithRSA&quot;,
 90      *          &quot;MD2WithRSA&quot;, &quot;SHAwithDSA&quot;. If set to null, a default
 91      *          algorithm matching the private key will be chosen after
 92      *          the first keypair is generated.
 93      * @param providerName name of the provider
 94      * @exception NoSuchAlgorithmException on unrecognized algorithms.
 95      * @exception NoSuchProviderException on unrecognized providers.
 96      */
 97     public CertAndKeyGen (String keyType, String sigAlg, String providerName)
 98     throws NoSuchAlgorithmException, NoSuchProviderException
 99     {
100         if (providerName == null) {
101             keyGen = KeyPairGenerator.getInstance(keyType);
102         } else {
103             try {
104                 keyGen = KeyPairGenerator.getInstance(keyType, providerName);
105             } catch (Exception e) {
106                 // try first available provider instead
107                 keyGen = KeyPairGenerator.getInstance(keyType);
108             }
109         }
110         this.sigAlg = sigAlg;
111         this.keyType = keyType;
112     }
113 
114     /**
115      * Sets the source of random numbers used when generating keys.
116      * If you do not provide one, a system default facility is used.
117      * You may wish to provide your own source of random numbers
118      * to get a reproducible sequence of keys and signatures, or
119      * because you may be able to take advantage of strong sources
120      * of randomness/entropy in your environment.
121      */
122     public void         setRandom (SecureRandom generator)
123     {
124         prng = generator;
125     }
126 
127     public void generate(String name) {
128         try {
129             if (prng == null) {
130                 prng = new SecureRandom();
131             }
132             try {
133                 keyGen.initialize(new NamedParameterSpec(name), prng);
134             } catch (InvalidAlgorithmParameterException e) {
135                 if (keyType.equalsIgnoreCase(&quot;EC&quot;)) {
136                     // EC has another NamedParameterSpec
137                     keyGen.initialize(new ECGenParameterSpec(name), prng);
138                 } else {
139                     throw e;
140                 }
141             }
142 
143         } catch (Exception e) {
144             throw new IllegalArgumentException(e.getMessage());
145         }
146         generateInternal();
147     }
148 
149     // want &quot;public void generate (X509Certificate)&quot; ... inherit DSA/D-H param
150 
151     public void generate(int keyBits) {
152         if (keyBits != -1) {
153             try {
154                 if (prng == null) {
155                     prng = new SecureRandom();
156                 }
157                 keyGen.initialize(keyBits, prng);
158 
159             } catch (Exception e) {
160                 throw new IllegalArgumentException(e.getMessage());
161             }
162         }
163         generateInternal();
164     }
165 
166     /**
167      * Generates a random public/private key pair.
168      *
169      * &lt;P&gt;Note that not all public key algorithms are currently
170      * supported for use in X.509 certificates.  If the algorithm
171      * you specified does not produce X.509 compatible keys, an
172      * invalid key exception is thrown.
173      *
174      * @exception IllegalArgumentException if the environment does not
175      *  provide X.509 public keys for this signature algorithm.
176      */
177     private void generateInternal() {
178         KeyPair pair = keyGen.generateKeyPair();
179         publicKey = pair.getPublic();
180         privateKey = pair.getPrivate();
181 
182         // publicKey&#39;s format must be X.509 otherwise
183         // the whole CertGen part of this class is broken.
184         if (!&quot;X.509&quot;.equalsIgnoreCase(publicKey.getFormat())) {
185             throw new IllegalArgumentException(&quot;Public key format is &quot;
186                 + publicKey.getFormat() + &quot;, must be X.509&quot;);
187         }
188 
189         if (sigAlg == null) {
190             sigAlg = AlgorithmId.getDefaultSigAlgForKey(privateKey);
191             if (sigAlg == null) {
192                 throw new IllegalArgumentException(
193                         &quot;Cannot derive signature algorithm from &quot;
194                                 + privateKey.getAlgorithm());
195             }
196         }
197     }
198 
199     /**
200      * Returns the public key of the generated key pair if it is of type
201      * &lt;code&gt;X509Key&lt;/code&gt;, or null if the public key is of a different type.
202      *
203      * XXX Note: This behaviour is needed for backwards compatibility.
204      * What this method really should return is the public key of the
205      * generated key pair, regardless of whether or not it is an instance of
206      * &lt;code&gt;X509Key&lt;/code&gt;. Accordingly, the return type of this method
207      * should be &lt;code&gt;PublicKey&lt;/code&gt;.
208      */
209     public X509Key getPublicKey()
210     {
211         if (!(publicKey instanceof X509Key)) {
212             return null;
213         }
214         return (X509Key)publicKey;
215     }
216 
217     /**
218      * Always returns the public key of the generated key pair. Used
219      * by KeyTool only.
220      *
221      * The publicKey is not necessarily to be an instance of
222      * X509Key in some JCA/JCE providers, for example SunPKCS11.
223      */
224     public PublicKey getPublicKeyAnyway() {
225         return publicKey;
226     }
227 
228     /**
229      * Returns the private key of the generated key pair.
230      *
231      * &lt;P&gt;&lt;STRONG&gt;&lt;em&gt;Be extremely careful when handling private keys.
232      * When private keys are not kept secret, they lose their ability
233      * to securely authenticate specific entities ... that is a huge
234      * security risk!&lt;/em&gt;&lt;/STRONG&gt;
235      */
236     public PrivateKey getPrivateKey ()
237     {
238         return privateKey;
239     }
240 
241     /**
242      * Returns a self-signed X.509v3 certificate for the public key.
243      * The certificate is immediately valid. No extensions.
244      *
245      * &lt;P&gt;Such certificates normally are used to identify a &quot;Certificate
246      * Authority&quot; (CA).  Accordingly, they will not always be accepted by
247      * other parties.  However, such certificates are also useful when
248      * you are bootstrapping your security infrastructure, or deploying
249      * system prototypes.
250      *
251      * @param myname X.500 name of the subject (who is also the issuer)
252      * @param firstDate the issue time of the certificate
253      * @param validity how long the certificate should be valid, in seconds
254      * @exception CertificateException on certificate handling errors.
255      * @exception InvalidKeyException on key handling errors.
256      * @exception SignatureException on signature handling errors.
257      * @exception NoSuchAlgorithmException on unrecognized algorithms.
258      * @exception NoSuchProviderException on unrecognized providers.
259      */
260     public X509Certificate getSelfCertificate (
261             X500Name myname, Date firstDate, long validity)
262     throws CertificateException, InvalidKeyException, SignatureException,
263         NoSuchAlgorithmException, NoSuchProviderException
264     {
265         return getSelfCertificate(myname, firstDate, validity, null);
266     }
267 
268     // Like above, plus a CertificateExtensions argument, which can be null.
269     public X509Certificate getSelfCertificate (X500Name myname, Date firstDate,
270             long validity, CertificateExtensions ext)
271     throws CertificateException, InvalidKeyException, SignatureException,
272         NoSuchAlgorithmException, NoSuchProviderException
273     {
274         X509CertImpl    cert;
275         Date            lastDate;
276 
277         try {
278             lastDate = new Date ();
279             lastDate.setTime (firstDate.getTime () + validity * 1000);
280 
281             CertificateValidity interval =
282                                    new CertificateValidity(firstDate,lastDate);
283 
284             X509CertInfo info = new X509CertInfo();
285             AlgorithmParameterSpec params = AlgorithmId
286                     .getDefaultAlgorithmParameterSpec(sigAlg, privateKey);
287             // Add all mandatory attributes
288             info.set(X509CertInfo.VERSION,
289                      new CertificateVersion(CertificateVersion.V3));
290             if (prng == null) {
291                 prng = new SecureRandom();
292             }
293             info.set(X509CertInfo.SERIAL_NUMBER,
294                     CertificateSerialNumber.newRandom64bit(prng));
295             AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlg, params);
296             info.set(X509CertInfo.ALGORITHM_ID,
297                      new CertificateAlgorithmId(algID));
298             info.set(X509CertInfo.SUBJECT, myname);
299             info.set(X509CertInfo.KEY, new CertificateX509Key(publicKey));
300             info.set(X509CertInfo.VALIDITY, interval);
301             info.set(X509CertInfo.ISSUER, myname);
302             if (ext != null) info.set(X509CertInfo.EXTENSIONS, ext);
303 
304             cert = new X509CertImpl(info);
305             cert.sign(privateKey,
306                     params,
307                     sigAlg,
308                     null);
309 
310             return (X509Certificate)cert;
311 
312         } catch (IOException e) {
313              throw new CertificateEncodingException(&quot;getSelfCert: &quot; +
314                                                     e.getMessage());
315         } catch (InvalidAlgorithmParameterException e2) {
316             throw new SignatureException(
317                     &quot;Unsupported PSSParameterSpec: &quot; + e2.getMessage());
318         }
319     }
320 
321     // Keep the old method
322     public X509Certificate getSelfCertificate (X500Name myname, long validity)
323     throws CertificateException, InvalidKeyException, SignatureException,
324         NoSuchAlgorithmException, NoSuchProviderException
325     {
326         return getSelfCertificate(myname, new Date(), validity);
327     }
328 
329     /**
330      * Returns a PKCS #10 certificate request.  The caller uses either
331      * &lt;code&gt;PKCS10.print&lt;/code&gt; or &lt;code&gt;PKCS10.toByteArray&lt;/code&gt;
332      * operations on the result, to get the request in an appropriate
333      * transmission format.
334      *
335      * &lt;P&gt;PKCS #10 certificate requests are sent, along with some proof
336      * of identity, to Certificate Authorities (CAs) which then issue
337      * X.509 public key certificates.
338      *
339      * @param myname X.500 name of the subject
340      * @exception InvalidKeyException on key handling errors.
341      * @exception SignatureException on signature handling errors.
342      */
343     // This method is not used inside JDK. Will not update it.
344     public PKCS10 getCertRequest (X500Name myname)
345     throws InvalidKeyException, SignatureException
346     {
347         PKCS10  req = new PKCS10 (publicKey);
348 
349         try {
350             Signature signature = Signature.getInstance(sigAlg);
351             signature.initSign (privateKey);
352             req.encodeAndSign(myname, signature);
353 
354         } catch (CertificateException e) {
355             throw new SignatureException (sigAlg + &quot; CertificateException&quot;);
356 
357         } catch (IOException e) {
358             throw new SignatureException (sigAlg + &quot; IOException&quot;);
359 
360         } catch (NoSuchAlgorithmException e) {
361             // &quot;can&#39;t happen&quot;
362             throw new SignatureException (sigAlg + &quot; unavailable?&quot;);
363         }
364         return req;
365     }
366 
367     private SecureRandom        prng;
368     private String              keyType;
369     private String              sigAlg;
370     private KeyPairGenerator    keyGen;
371     private PublicKey           publicKey;
372     private PrivateKey          privateKey;
373 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/nio/ch/Reflect.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.*;
 29 import java.lang.reflect.*;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 
 33 
 34 class Reflect {                                 // package-private
 35 
 36     private Reflect() { }
 37 
 38     private static class ReflectionError extends Error {
 39         private static final long serialVersionUID = -8659519328078164097L;
 40         ReflectionError(Throwable x) {
 41             super(x);
 42         }
 43     }
 44 
 45     private static void setAccessible(final AccessibleObject ao) {
 46         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 47                 public Void run() {
 48                     ao.setAccessible(true);
 49                     return null;
 50                 }});
 51     }
 52 
 53     static Constructor&lt;?&gt; lookupConstructor(String className,
 54                                             Class&lt;?&gt;[] paramTypes)
 55     {
 56         try {
 57             Class&lt;?&gt; cl = Class.forName(className);
 58             Constructor&lt;?&gt; c = cl.getDeclaredConstructor(paramTypes);
 59             setAccessible(c);
 60             return c;
 61         } catch (ClassNotFoundException | NoSuchMethodException x) {
 62             throw new ReflectionError(x);
 63         }
 64     }
 65 
 66     static Object invoke(Constructor&lt;?&gt; c, Object[] args) {
 67         try {
 68             return c.newInstance(args);
 69         } catch (InstantiationException |
 70                  IllegalAccessException |
 71                  InvocationTargetException x) {
 72             throw new ReflectionError(x);
 73         }
 74     }
 75 
 76     static Method lookupMethod(String className,
 77                                String methodName,
 78                                Class&lt;?&gt;... paramTypes)
 79     {
 80         try {
 81             Class&lt;?&gt; cl = Class.forName(className);
 82             Method m = cl.getDeclaredMethod(methodName, paramTypes);
 83             setAccessible(m);
 84             return m;
 85         } catch (ClassNotFoundException | NoSuchMethodException x) {
 86             throw new ReflectionError(x);
 87         }
 88     }
 89 
 90     static Object invoke(Method m, Object ob, Object[] args) {
 91         try {
 92             return m.invoke(ob, args);
 93         } catch (IllegalAccessException | InvocationTargetException x) {
 94             throw new ReflectionError(x);
 95         }
 96     }
 97 
 98     static Object invokeIO(Method m, Object ob, Object[] args)
 99         throws IOException
100     {
101         try {
102             return m.invoke(ob, args);
103         } catch (IllegalAccessException x) {
104             throw new ReflectionError(x);
105         } catch (InvocationTargetException x) {
106             if (IOException.class.isInstance(x.getCause()))
107                 throw (IOException)x.getCause();
108             throw new ReflectionError(x);
109         }
110     }
111 
112     static Field lookupField(String className, String fieldName) {
113         try {
114             Class&lt;?&gt; cl = Class.forName(className);
115             Field f = cl.getDeclaredField(fieldName);
116             setAccessible(f);
117             return f;
118         } catch (ClassNotFoundException | NoSuchFieldException x) {
119             throw new ReflectionError(x);
120         }
121     }
122 
123     static Object get(Object ob, Field f) {
124         try {
125             return f.get(ob);
126         } catch (IllegalAccessException x) {
127             throw new ReflectionError(x);
128         }
129     }
130 
131     static Object get(Field f) {
132         return get(null, f);
133     }
134 
135     static void set(Object ob, Field f, Object val) {
136         try {
137             f.set(ob, val);
138         } catch (IllegalAccessException x) {
139             throw new ReflectionError(x);
140         }
141     }
142 
143     static void setInt(Object ob, Field f, int val) {
144         try {
145             f.setInt(ob, val);
146         } catch (IllegalAccessException x) {
147             throw new ReflectionError(x);
148         }
149     }
150 
151     static void setBoolean(Object ob, Field f, boolean val) {
152         try {
153             f.setBoolean(ob, val);
154         } catch (IllegalAccessException x) {
155             throw new ReflectionError(x);
156         }
157     }
158 
159 }
    </pre>
  </body>
</html>
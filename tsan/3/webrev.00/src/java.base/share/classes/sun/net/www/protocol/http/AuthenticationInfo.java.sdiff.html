<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AuthCacheValue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BasicAuthentication.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www.protocol.http;
 27 
 28 import java.io.IOException;
 29 import java.io.ObjectInputStream;
 30 import java.net.PasswordAuthentication;
 31 import java.net.URL;
 32 import java.util.HashMap;
 33 import java.util.Objects;

 34 
 35 import sun.net.www.HeaderParser;
 36 
 37 
 38 /**
 39  * AuthenticationInfo: Encapsulate the information needed to
 40  * authenticate a user to a server.
 41  *
 42  * @author Jon Payne
 43  * @author Herb Jellinek
 44  * @author Bill Foote
 45  */
 46 // REMIND:  It would be nice if this class understood about partial matching.
 47 //      If you&#39;re authorized for foo.com, chances are high you&#39;re also
 48 //      authorized for baz.foo.com.
 49 // NB:  When this gets implemented, be careful about the uncaching
 50 //      policy in HttpURLConnection.  A failure on baz.foo.com shouldn&#39;t
 51 //      uncache foo.com!
 52 
 53 public abstract class AuthenticationInfo extends AuthCacheValue implements Cloneable {
 54 

 55     static final long serialVersionUID = -2588378268010453259L;
 56 
 57     // Constants saying what kind of authroization this is.  This determines
 58     // the namespace in the hash table lookup.
 59     public static final char SERVER_AUTHENTICATION = &#39;s&#39;;
 60     public static final char PROXY_AUTHENTICATION = &#39;p&#39;;
 61 
 62     /**
 63      * If true, then simultaneous authentication requests to the same realm/proxy
 64      * are serialized, in order to avoid a user having to type the same username/passwords
 65      * repeatedly, via the Authenticator. Default is false, which means that this
 66      * behavior is switched off.
 67      */
 68     static final boolean serializeAuth;
 69     static {
 70         serializeAuth = java.security.AccessController.doPrivileged(
 71             new sun.security.action.GetBooleanAction(
 72                 &quot;http.auth.serializeRequests&quot;)).booleanValue();
 73     }
 74 
</pre>
<hr />
<pre>
108     /**
109      * Whether we should cache this instance in the AuthCache.
110      * This method returns {@code true} by default.
111      * Subclasses may override this method to add
112      * additional restrictions.
113      * @return {@code true} by default.
114      */
115     protected boolean useAuthCache() {
116         return true;
117     }
118 
119     /**
120      * requests is used to ensure that interaction with the
121      * Authenticator for a particular realm is single threaded.
122      * i.e. if multiple threads need to get credentials from the user
123      * at the same time, then all but the first will block until
124      * the first completes its authentication.
125      */
126     private static HashMap&lt;String,Thread&gt; requests = new HashMap&lt;&gt;();
127 
<span class="line-modified">128     /* check if a request for this destination is in progress</span>
<span class="line-modified">129      * return false immediately if not. Otherwise block until</span>
<span class="line-modified">130      * request is finished and return true</span>



131      */
<span class="line-modified">132     private static boolean requestIsInProgress (String key) {</span>
<span class="line-modified">133         if (!serializeAuth) {</span>
<span class="line-modified">134             /* behavior is disabled. Revert to concurrent requests */</span>
<span class="line-modified">135             return false;</span>



136         }
137         synchronized (requests) {







138             Thread t, c;
139             c = Thread.currentThread();
140             if ((t = requests.get(key)) == null) {
141                 requests.put (key, c);
<span class="line-modified">142                 return false;</span>

143             }
144             if (t == c) {
<span class="line-modified">145                 return false;</span>

146             }


147             while (requests.containsKey(key)) {
148                 try {
149                     requests.wait ();
150                 } catch (InterruptedException e) {}
151             }
152         }
153         /* entry may be in cache now. */
<span class="line-modified">154         return true;</span>
155     }
156 
157     /* signal completion of an authentication (whether it succeeded or not)
158      * so that other threads can continue.
159      */
160     private static void requestCompleted (String key) {
161         synchronized (requests) {
162             Thread thread = requests.get(key);
163             if (thread != null &amp;&amp; thread == Thread.currentThread()) {
164                 boolean waspresent = requests.remove(key) != null;
165                 assert waspresent;
166             }
167             requests.notifyAll();
168         }
169     }
170 
171     //public String toString () {
172         //return (&quot;{&quot;+type+&quot;:&quot;+authScheme+&quot;:&quot;+protocol+&quot;:&quot;+host+&quot;:&quot;+port+&quot;:&quot;+realm+&quot;:&quot;+path+&quot;}&quot;);
173     //}
174 
</pre>
<hr />
<pre>
301     /**
302      * Returns info for the URL, for an HTTP server auth.  Used when we
303      * do know the realm (i.e. when we&#39;re responding to a challenge).
304      * In this case we do not use the path because the protection space
305      * is identified by the host:port:realm only
306      */
307     static String getServerAuthKey(URL url, String realm, AuthScheme scheme,
308                                    String authenticatorKey) {
309         int port = url.getPort();
310         if (port == -1) {
311             port = url.getDefaultPort();
312         }
313         String key = SERVER_AUTHENTICATION + &quot;:&quot; + scheme + &quot;:&quot;
314                      + url.getProtocol().toLowerCase()
315                      + &quot;:&quot; + url.getHost().toLowerCase()
316                      + &quot;:&quot; + port + &quot;:&quot; + realm
317                      + &quot;;auth=&quot; + authenticatorKey;
318         return key;
319     }
320 




321     static AuthenticationInfo getServerAuth(String key) {
<span class="line-modified">322         AuthenticationInfo cached = getAuth(key, null);</span>
<span class="line-modified">323         if ((cached == null) &amp;&amp; requestIsInProgress (key)) {</span>
<span class="line-removed">324             /* check the cache again, it might contain an entry */</span>
<span class="line-removed">325             cached = getAuth(key, null);</span>
<span class="line-removed">326         }</span>
<span class="line-removed">327         return cached;</span>
328     }
329 
330 
331     /**
332      * Return the AuthenticationInfo object from the cache if it&#39;s path is
333      * a substring of the supplied URLs path.
334      */
335     static AuthenticationInfo getAuth(String key, URL url) {
336         if (url == null) {
337             return (AuthenticationInfo)cache.get (key, null);
338         } else {
339             return (AuthenticationInfo)cache.get (key, url.getPath());
340         }
341     }
342 
343     /**
344      * Returns a firewall authentication, for the given host/port.  Used
345      * for preemptive header-setting. Note, the protocol field is always
346      * blank for proxies.
347      */
</pre>
<hr />
<pre>
350         String key = PROXY_AUTHENTICATION + &quot;::&quot; + host.toLowerCase() + &quot;:&quot; + port
351                      + &quot;;auth=&quot; + authenticatorKey;
352         AuthenticationInfo result = (AuthenticationInfo) cache.get(key, null);
353         return result;
354     }
355 
356     /**
357      * Returns a firewall authentication, for the given host/port and realm.
358      * Used in response to a challenge. Note, the protocol field is always
359      * blank for proxies.
360      */
361     static String getProxyAuthKey(String host, int port, String realm,
362                                   AuthScheme scheme, String authenticatorKey) {
363         String key = PROXY_AUTHENTICATION + &quot;:&quot; + scheme
364                         + &quot;::&quot; + host.toLowerCase()
365                         + &quot;:&quot; + port + &quot;:&quot; + realm
366                         + &quot;;auth=&quot; + authenticatorKey;
367         return key;
368     }
369 




370     static AuthenticationInfo getProxyAuth(String key) {
<span class="line-modified">371         AuthenticationInfo cached = (AuthenticationInfo) cache.get(key, null);</span>
<span class="line-modified">372         if ((cached == null) &amp;&amp; requestIsInProgress (key)) {</span>
<span class="line-removed">373             /* check the cache again, it might contain an entry */</span>
<span class="line-removed">374             cached = (AuthenticationInfo) cache.get(key, null);</span>
<span class="line-removed">375         }</span>
<span class="line-removed">376         return cached;</span>
377     }
378 
379 
380     /**
381      * Add this authentication to the cache
382      */
383     void addToCache() {
384         String key = cacheKey(true);
385         if (useAuthCache()) {
386             cache.put(key, this);
387             if (supportsPreemptiveAuthorization()) {
388                 cache.put(cacheKey(false), this);
389             }
390         }
391         endAuthRequest(key);
392     }
393 
394     static void endAuthRequest (String key) {
395         if (!serializeAuth) {
396             return;
</pre>
<hr />
<pre>
463      * Give a key for hash table lookups.
464      * @param includeRealm if you want the realm considered.  Preemptively
465      *          setting an authorization is done before the realm is known.
466      */
467     String cacheKey(boolean includeRealm) {
468         // This must be kept in sync with the getXXXAuth() methods in this
469         // class.
470         String authenticatorKey = getAuthenticatorKey();
471         if (includeRealm) {
472             return type + &quot;:&quot; + authScheme + &quot;:&quot; + protocol + &quot;:&quot;
473                         + host + &quot;:&quot; + port + &quot;:&quot; + realm
474                      + &quot;;auth=&quot; + authenticatorKey;
475         } else {
476             return type + &quot;:&quot; + protocol + &quot;:&quot; + host + &quot;:&quot; + port
477                      + &quot;;auth=&quot; + authenticatorKey;
478         }
479     }
480 
481     String s1, s2;  /* used for serialization of pw */
482 

483     private synchronized void readObject(ObjectInputStream s)
484         throws IOException, ClassNotFoundException
485     {
486         s.defaultReadObject ();
487         pw = new PasswordAuthentication (s1, s2.toCharArray());
488         s1 = null; s2= null;
489         if (authenticatorKey == null) {
490             authenticatorKey = AuthenticatorKeys.DEFAULT;
491         }
492     }
493 

494     private synchronized void writeObject(java.io.ObjectOutputStream s)
495         throws IOException
496     {
497         Objects.requireNonNull(authenticatorKey);
498         s1 = pw.getUserName();
499         s2 = new String (pw.getPassword());
500         s.defaultWriteObject ();
501     }
502 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www.protocol.http;
 27 
 28 import java.io.IOException;
 29 import java.io.ObjectInputStream;
 30 import java.net.PasswordAuthentication;
 31 import java.net.URL;
 32 import java.util.HashMap;
 33 import java.util.Objects;
<span class="line-added"> 34 import java.util.function.Function;</span>
 35 
 36 import sun.net.www.HeaderParser;
 37 
 38 
 39 /**
 40  * AuthenticationInfo: Encapsulate the information needed to
 41  * authenticate a user to a server.
 42  *
 43  * @author Jon Payne
 44  * @author Herb Jellinek
 45  * @author Bill Foote
 46  */
 47 // REMIND:  It would be nice if this class understood about partial matching.
 48 //      If you&#39;re authorized for foo.com, chances are high you&#39;re also
 49 //      authorized for baz.foo.com.
 50 // NB:  When this gets implemented, be careful about the uncaching
 51 //      policy in HttpURLConnection.  A failure on baz.foo.com shouldn&#39;t
 52 //      uncache foo.com!
 53 
 54 public abstract class AuthenticationInfo extends AuthCacheValue implements Cloneable {
 55 
<span class="line-added"> 56     @java.io.Serial</span>
 57     static final long serialVersionUID = -2588378268010453259L;
 58 
 59     // Constants saying what kind of authroization this is.  This determines
 60     // the namespace in the hash table lookup.
 61     public static final char SERVER_AUTHENTICATION = &#39;s&#39;;
 62     public static final char PROXY_AUTHENTICATION = &#39;p&#39;;
 63 
 64     /**
 65      * If true, then simultaneous authentication requests to the same realm/proxy
 66      * are serialized, in order to avoid a user having to type the same username/passwords
 67      * repeatedly, via the Authenticator. Default is false, which means that this
 68      * behavior is switched off.
 69      */
 70     static final boolean serializeAuth;
 71     static {
 72         serializeAuth = java.security.AccessController.doPrivileged(
 73             new sun.security.action.GetBooleanAction(
 74                 &quot;http.auth.serializeRequests&quot;)).booleanValue();
 75     }
 76 
</pre>
<hr />
<pre>
110     /**
111      * Whether we should cache this instance in the AuthCache.
112      * This method returns {@code true} by default.
113      * Subclasses may override this method to add
114      * additional restrictions.
115      * @return {@code true} by default.
116      */
117     protected boolean useAuthCache() {
118         return true;
119     }
120 
121     /**
122      * requests is used to ensure that interaction with the
123      * Authenticator for a particular realm is single threaded.
124      * i.e. if multiple threads need to get credentials from the user
125      * at the same time, then all but the first will block until
126      * the first completes its authentication.
127      */
128     private static HashMap&lt;String,Thread&gt; requests = new HashMap&lt;&gt;();
129 
<span class="line-modified">130     /*</span>
<span class="line-modified">131      * check if AuthenticationInfo is available in the cache.</span>
<span class="line-modified">132      * If not, check if a request for this destination is in progress</span>
<span class="line-added">133      * and if so block until the other request is finished authenticating</span>
<span class="line-added">134      * and returns the cached authentication value.</span>
<span class="line-added">135      * Otherwise, returns the cached authentication value, which may be null.</span>
136      */
<span class="line-modified">137     private static AuthenticationInfo requestAuthentication(String key, Function&lt;String, AuthenticationInfo&gt; cache) {</span>
<span class="line-modified">138         AuthenticationInfo cached = cache.apply(key);</span>
<span class="line-modified">139         if (cached != null || !serializeAuth) {</span>
<span class="line-modified">140             // either we already have a value in the cache, and we can</span>
<span class="line-added">141             // use that immediately, or the serializeAuth behavior is disabled,</span>
<span class="line-added">142             // and we can revert to concurrent requests</span>
<span class="line-added">143             return cached;</span>
144         }
145         synchronized (requests) {
<span class="line-added">146             // check again after synchronizing, and if available</span>
<span class="line-added">147             // just return the cached value.</span>
<span class="line-added">148             cached = cache.apply(key);</span>
<span class="line-added">149             if (cached != null) return cached;</span>
<span class="line-added">150 </span>
<span class="line-added">151             // Otherwise, if no request is in progress, record this</span>
<span class="line-added">152             // thread as performing authentication and returns null.</span>
153             Thread t, c;
154             c = Thread.currentThread();
155             if ((t = requests.get(key)) == null) {
156                 requests.put (key, c);
<span class="line-modified">157                 assert cached == null;</span>
<span class="line-added">158                 return cached;</span>
159             }
160             if (t == c) {
<span class="line-modified">161                 assert cached == null;</span>
<span class="line-added">162                 return cached;</span>
163             }
<span class="line-added">164             // Otherwise, an other thread is currently performing authentication:</span>
<span class="line-added">165             // wait until it finishes.</span>
166             while (requests.containsKey(key)) {
167                 try {
168                     requests.wait ();
169                 } catch (InterruptedException e) {}
170             }
171         }
172         /* entry may be in cache now. */
<span class="line-modified">173         return cache.apply(key);</span>
174     }
175 
176     /* signal completion of an authentication (whether it succeeded or not)
177      * so that other threads can continue.
178      */
179     private static void requestCompleted (String key) {
180         synchronized (requests) {
181             Thread thread = requests.get(key);
182             if (thread != null &amp;&amp; thread == Thread.currentThread()) {
183                 boolean waspresent = requests.remove(key) != null;
184                 assert waspresent;
185             }
186             requests.notifyAll();
187         }
188     }
189 
190     //public String toString () {
191         //return (&quot;{&quot;+type+&quot;:&quot;+authScheme+&quot;:&quot;+protocol+&quot;:&quot;+host+&quot;:&quot;+port+&quot;:&quot;+realm+&quot;:&quot;+path+&quot;}&quot;);
192     //}
193 
</pre>
<hr />
<pre>
320     /**
321      * Returns info for the URL, for an HTTP server auth.  Used when we
322      * do know the realm (i.e. when we&#39;re responding to a challenge).
323      * In this case we do not use the path because the protection space
324      * is identified by the host:port:realm only
325      */
326     static String getServerAuthKey(URL url, String realm, AuthScheme scheme,
327                                    String authenticatorKey) {
328         int port = url.getPort();
329         if (port == -1) {
330             port = url.getDefaultPort();
331         }
332         String key = SERVER_AUTHENTICATION + &quot;:&quot; + scheme + &quot;:&quot;
333                      + url.getProtocol().toLowerCase()
334                      + &quot;:&quot; + url.getHost().toLowerCase()
335                      + &quot;:&quot; + port + &quot;:&quot; + realm
336                      + &quot;;auth=&quot; + authenticatorKey;
337         return key;
338     }
339 
<span class="line-added">340     private static AuthenticationInfo getCachedServerAuth(String key) {</span>
<span class="line-added">341         return getAuth(key, null);</span>
<span class="line-added">342     }</span>
<span class="line-added">343 </span>
344     static AuthenticationInfo getServerAuth(String key) {
<span class="line-modified">345         if (!serializeAuth) return getCachedServerAuth(key);</span>
<span class="line-modified">346         return requestAuthentication(key, AuthenticationInfo::getCachedServerAuth);</span>




347     }
348 
349 
350     /**
351      * Return the AuthenticationInfo object from the cache if it&#39;s path is
352      * a substring of the supplied URLs path.
353      */
354     static AuthenticationInfo getAuth(String key, URL url) {
355         if (url == null) {
356             return (AuthenticationInfo)cache.get (key, null);
357         } else {
358             return (AuthenticationInfo)cache.get (key, url.getPath());
359         }
360     }
361 
362     /**
363      * Returns a firewall authentication, for the given host/port.  Used
364      * for preemptive header-setting. Note, the protocol field is always
365      * blank for proxies.
366      */
</pre>
<hr />
<pre>
369         String key = PROXY_AUTHENTICATION + &quot;::&quot; + host.toLowerCase() + &quot;:&quot; + port
370                      + &quot;;auth=&quot; + authenticatorKey;
371         AuthenticationInfo result = (AuthenticationInfo) cache.get(key, null);
372         return result;
373     }
374 
375     /**
376      * Returns a firewall authentication, for the given host/port and realm.
377      * Used in response to a challenge. Note, the protocol field is always
378      * blank for proxies.
379      */
380     static String getProxyAuthKey(String host, int port, String realm,
381                                   AuthScheme scheme, String authenticatorKey) {
382         String key = PROXY_AUTHENTICATION + &quot;:&quot; + scheme
383                         + &quot;::&quot; + host.toLowerCase()
384                         + &quot;:&quot; + port + &quot;:&quot; + realm
385                         + &quot;;auth=&quot; + authenticatorKey;
386         return key;
387     }
388 
<span class="line-added">389     private static AuthenticationInfo getCachedProxyAuth(String key) {</span>
<span class="line-added">390         return (AuthenticationInfo) cache.get(key, null);</span>
<span class="line-added">391     }</span>
<span class="line-added">392 </span>
393     static AuthenticationInfo getProxyAuth(String key) {
<span class="line-modified">394         if (!serializeAuth) return getCachedProxyAuth(key);</span>
<span class="line-modified">395         return requestAuthentication(key, AuthenticationInfo::getCachedProxyAuth);</span>




396     }
397 
398 
399     /**
400      * Add this authentication to the cache
401      */
402     void addToCache() {
403         String key = cacheKey(true);
404         if (useAuthCache()) {
405             cache.put(key, this);
406             if (supportsPreemptiveAuthorization()) {
407                 cache.put(cacheKey(false), this);
408             }
409         }
410         endAuthRequest(key);
411     }
412 
413     static void endAuthRequest (String key) {
414         if (!serializeAuth) {
415             return;
</pre>
<hr />
<pre>
482      * Give a key for hash table lookups.
483      * @param includeRealm if you want the realm considered.  Preemptively
484      *          setting an authorization is done before the realm is known.
485      */
486     String cacheKey(boolean includeRealm) {
487         // This must be kept in sync with the getXXXAuth() methods in this
488         // class.
489         String authenticatorKey = getAuthenticatorKey();
490         if (includeRealm) {
491             return type + &quot;:&quot; + authScheme + &quot;:&quot; + protocol + &quot;:&quot;
492                         + host + &quot;:&quot; + port + &quot;:&quot; + realm
493                      + &quot;;auth=&quot; + authenticatorKey;
494         } else {
495             return type + &quot;:&quot; + protocol + &quot;:&quot; + host + &quot;:&quot; + port
496                      + &quot;;auth=&quot; + authenticatorKey;
497         }
498     }
499 
500     String s1, s2;  /* used for serialization of pw */
501 
<span class="line-added">502     @java.io.Serial</span>
503     private synchronized void readObject(ObjectInputStream s)
504         throws IOException, ClassNotFoundException
505     {
506         s.defaultReadObject ();
507         pw = new PasswordAuthentication (s1, s2.toCharArray());
508         s1 = null; s2= null;
509         if (authenticatorKey == null) {
510             authenticatorKey = AuthenticatorKeys.DEFAULT;
511         }
512     }
513 
<span class="line-added">514     @java.io.Serial</span>
515     private synchronized void writeObject(java.io.ObjectOutputStream s)
516         throws IOException
517     {
518         Objects.requireNonNull(authenticatorKey);
519         s1 = pw.getUserName();
520         s2 = new String (pw.getPassword());
521         s.defaultWriteObject ();
522     }
523 }
</pre>
</td>
</tr>
</table>
<center><a href="AuthCacheValue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BasicAuthentication.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
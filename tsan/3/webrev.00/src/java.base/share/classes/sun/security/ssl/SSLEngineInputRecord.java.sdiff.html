<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLEngineInputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLEngineImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineOutputRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLEngineInputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
270                     (handshakeBuffer.remaining() != 0)) {
271                 ByteBuffer bb = ByteBuffer.wrap(new byte[
272                         handshakeBuffer.remaining() + fragment.remaining()]);
273                 bb.put(handshakeBuffer);
274                 bb.put(fragment);
275                 handshakeFrag = bb.rewind();
276                 handshakeBuffer = null;
277             }
278 
279             ArrayList&lt;Plaintext&gt; plaintexts = new ArrayList&lt;&gt;(5);
280             while (handshakeFrag.hasRemaining()) {
281                 int remaining = handshakeFrag.remaining();
282                 if (remaining &lt; handshakeHeaderSize) {
283                     handshakeBuffer = ByteBuffer.wrap(new byte[remaining]);
284                     handshakeBuffer.put(handshakeFrag);
285                     handshakeBuffer.rewind();
286                     break;
287                 }
288 
289                 handshakeFrag.mark();
<span class="line-modified">290                 // skip the first byte: handshake type</span>

291                 byte handshakeType = handshakeFrag.get();






292                 int handshakeBodyLen = Record.getInt24(handshakeFrag);
293                 handshakeFrag.reset();
294                 int handshakeMessageLen =
295                         handshakeHeaderSize + handshakeBodyLen;
296                 if (remaining &lt; handshakeMessageLen) {
297                     handshakeBuffer = ByteBuffer.wrap(new byte[remaining]);
298                     handshakeBuffer.put(handshakeFrag);
299                     handshakeBuffer.rewind();
300                     break;
301                 } else if (remaining == handshakeMessageLen) {
302                     if (handshakeHash.isHashable(handshakeType)) {
303                         handshakeHash.receive(handshakeFrag);
304                     }
305 
306                     plaintexts.add(
307                         new Plaintext(contentType,
308                             majorVersion, minorVersion, -1, -1L, handshakeFrag)
309                     );
310                     break;
311                 } else {
</pre>
<hr />
<pre>
357                 throw new SSLHandshakeException(&quot;SSLv2Hello is not enabled&quot;);
358             }
359 
360             byte majorVersion = packet.get(srcPos + 3);
361             byte minorVersion = packet.get(srcPos + 4);
362 
363             if ((majorVersion == ProtocolVersion.SSL20Hello.major) &amp;&amp;
364                 (minorVersion == ProtocolVersion.SSL20Hello.minor)) {
365 
366                 /*
367                  * Looks like a V2 client hello, but not one saying
368                  * &quot;let&#39;s talk SSLv3&quot;.  So we need to send an SSLv2
369                  * error message, one that&#39;s treated as fatal by
370                  * clients (Otherwise we&#39;ll hang.)
371                  */
372                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
373                    SSLLogger.fine(
374                             &quot;Requested to negotiate unsupported SSLv2!&quot;);
375                 }
376 
<span class="line-modified">377                 // hack code, the exception is caught in SSLEngineImpl</span>
378                 // so that SSLv2 error message can be delivered properly.
379                 throw new UnsupportedOperationException(        // SSLv2Hello
380                         &quot;Unsupported SSL v2.0 ClientHello&quot;);
381             }
382 
383             /*
384              * If we can map this into a V3 ClientHello, read and
385              * hash the rest of the V2 handshake, turn it into a
386              * V3 ClientHello message, and pass it up.
387              */
388             packet.position(srcPos + 2);        // exclude the header
389             handshakeHash.receive(packet);
390             packet.position(srcPos);
391 
392             ByteBuffer converted = convertToClientHello(packet);
393 
394             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
395                 SSLLogger.fine(
396                         &quot;[Converted] ClientHello&quot;, converted);
397             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
270                     (handshakeBuffer.remaining() != 0)) {
271                 ByteBuffer bb = ByteBuffer.wrap(new byte[
272                         handshakeBuffer.remaining() + fragment.remaining()]);
273                 bb.put(handshakeBuffer);
274                 bb.put(fragment);
275                 handshakeFrag = bb.rewind();
276                 handshakeBuffer = null;
277             }
278 
279             ArrayList&lt;Plaintext&gt; plaintexts = new ArrayList&lt;&gt;(5);
280             while (handshakeFrag.hasRemaining()) {
281                 int remaining = handshakeFrag.remaining();
282                 if (remaining &lt; handshakeHeaderSize) {
283                     handshakeBuffer = ByteBuffer.wrap(new byte[remaining]);
284                     handshakeBuffer.put(handshakeFrag);
285                     handshakeBuffer.rewind();
286                     break;
287                 }
288 
289                 handshakeFrag.mark();
<span class="line-modified">290 </span>
<span class="line-added">291                 // Fail fast for unknown handshake message.</span>
292                 byte handshakeType = handshakeFrag.get();
<span class="line-added">293                 if (!SSLHandshake.isKnown(handshakeType)) {</span>
<span class="line-added">294                     throw new SSLProtocolException(</span>
<span class="line-added">295                         &quot;Unknown handshake type size, Handshake.msg_type = &quot; +</span>
<span class="line-added">296                         (handshakeType &amp; 0xFF));</span>
<span class="line-added">297                 }</span>
<span class="line-added">298 </span>
299                 int handshakeBodyLen = Record.getInt24(handshakeFrag);
300                 handshakeFrag.reset();
301                 int handshakeMessageLen =
302                         handshakeHeaderSize + handshakeBodyLen;
303                 if (remaining &lt; handshakeMessageLen) {
304                     handshakeBuffer = ByteBuffer.wrap(new byte[remaining]);
305                     handshakeBuffer.put(handshakeFrag);
306                     handshakeBuffer.rewind();
307                     break;
308                 } else if (remaining == handshakeMessageLen) {
309                     if (handshakeHash.isHashable(handshakeType)) {
310                         handshakeHash.receive(handshakeFrag);
311                     }
312 
313                     plaintexts.add(
314                         new Plaintext(contentType,
315                             majorVersion, minorVersion, -1, -1L, handshakeFrag)
316                     );
317                     break;
318                 } else {
</pre>
<hr />
<pre>
364                 throw new SSLHandshakeException(&quot;SSLv2Hello is not enabled&quot;);
365             }
366 
367             byte majorVersion = packet.get(srcPos + 3);
368             byte minorVersion = packet.get(srcPos + 4);
369 
370             if ((majorVersion == ProtocolVersion.SSL20Hello.major) &amp;&amp;
371                 (minorVersion == ProtocolVersion.SSL20Hello.minor)) {
372 
373                 /*
374                  * Looks like a V2 client hello, but not one saying
375                  * &quot;let&#39;s talk SSLv3&quot;.  So we need to send an SSLv2
376                  * error message, one that&#39;s treated as fatal by
377                  * clients (Otherwise we&#39;ll hang.)
378                  */
379                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
380                    SSLLogger.fine(
381                             &quot;Requested to negotiate unsupported SSLv2!&quot;);
382                 }
383 
<span class="line-modified">384                 // Note that the exception is caught in SSLEngineImpl</span>
385                 // so that SSLv2 error message can be delivered properly.
386                 throw new UnsupportedOperationException(        // SSLv2Hello
387                         &quot;Unsupported SSL v2.0 ClientHello&quot;);
388             }
389 
390             /*
391              * If we can map this into a V3 ClientHello, read and
392              * hash the rest of the V2 handshake, turn it into a
393              * V3 ClientHello message, and pass it up.
394              */
395             packet.position(srcPos + 2);        // exclude the header
396             handshakeHash.receive(packet);
397             packet.position(srcPos);
398 
399             ByteBuffer converted = convertToClientHello(packet);
400 
401             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
402                 SSLLogger.fine(
403                         &quot;[Converted] ClientHello&quot;, converted);
404             }
</pre>
</td>
</tr>
</table>
<center><a href="SSLEngineImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineOutputRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
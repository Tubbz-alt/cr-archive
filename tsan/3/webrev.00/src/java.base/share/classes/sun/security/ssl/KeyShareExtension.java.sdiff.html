<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NewSessionTicket.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<span class="line-removed"> 30 import java.security.CryptoPrimitive;</span>
 31 import java.security.GeneralSecurityException;
 32 import java.text.MessageFormat;
 33 import java.util.Arrays;
 34 import java.util.Collections;
<span class="line-removed"> 35 import java.util.EnumSet;</span>
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 import java.util.Locale;
 39 import java.util.Map;
 40 import javax.net.ssl.SSLProtocolException;
<span class="line-removed"> 41 import sun.security.ssl.DHKeyExchange.DHECredentials;</span>
<span class="line-removed"> 42 import sun.security.ssl.DHKeyExchange.DHEPossession;</span>
<span class="line-removed"> 43 import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;</span>
<span class="line-removed"> 44 import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;</span>
 45 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
 46 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 47 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-removed"> 49 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed"> 50 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
 51 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 52 import sun.security.util.HexDumpEncoder;
 53 
 54 /**
 55  * Pack of the &quot;key_share&quot; extensions.
 56  */
 57 final class KeyShareExtension {
 58     static final HandshakeProducer chNetworkProducer =
 59             new CHKeyShareProducer();
 60     static final ExtensionConsumer chOnLoadConsumer =
 61             new CHKeyShareConsumer();
 62     static final SSLStringizer chStringizer =
 63             new CHKeyShareStringizer();
 64 
 65     static final HandshakeProducer shNetworkProducer =
 66             new SHKeyShareProducer();
 67     static final ExtensionConsumer shOnLoadConsumer =
 68             new SHKeyShareConsumer();
 69     static final HandshakeAbsence shOnLoadAbsence =
 70             new SHKeyShareAbsence();
</pre>
<hr />
<pre>
247                     }
248                     return null;
249                 }
250             }
251 
252             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
253             for (NamedGroup ng : namedGroups) {
254                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
255                 if (ke == null) {
256                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
257                         SSLLogger.warning(
258                             &quot;No key exchange for named group &quot; + ng.name);
259                     }
260                     continue;
261                 }
262 
263                 SSLPossession[] poses = ke.createPossessions(chc);
264                 for (SSLPossession pos : poses) {
265                     // update the context
266                     chc.handshakePossessions.add(pos);
<span class="line-modified">267                     if (!(pos instanceof ECDHEPossession) &amp;&amp;</span>
<span class="line-removed">268                             !(pos instanceof DHEPossession)) {</span>
269                         // May need more possesion types in the future.
270                         continue;
271                     }
272 
273                     keyShares.add(new KeyShareEntry(ng.id, pos.encode()));
274                 }
275 
276                 // One key share entry only.  Too much key share entries makes
277                 // the ClientHello handshake message really big.
278                 if (!keyShares.isEmpty()) {
279                     break;
280                 }
281             }
282 
283             int listLen = 0;
284             for (KeyShareEntry entry : keyShares) {
285                 listLen += entry.getEncodedSize();
286             }
287             byte[] extData = new byte[listLen + 2];     //  2: list length
288             ByteBuffer m = ByteBuffer.wrap(extData);
</pre>
<hr />
<pre>
336             CHKeyShareSpec spec;
337             try {
338                 spec = new CHKeyShareSpec(buffer);
339             } catch (IOException ioe) {
340                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
341             }
342 
343             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
344             for (KeyShareEntry entry : spec.clientShares) {
345                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
346                 if (ng == null || !SupportedGroups.isActivatable(
347                         shc.sslConfig.algorithmConstraints, ng)) {
348                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
349                         SSLLogger.fine(
350                                 &quot;Ignore unsupported named group: &quot; +
351                                 NamedGroup.nameOf(entry.namedGroupId));
352                     }
353                     continue;
354                 }
355 
<span class="line-modified">356                 if (ng.type == NamedGroupType.NAMED_GROUP_ECDHE) {</span>
<span class="line-modified">357                     try {</span>
<span class="line-modified">358                         ECDHECredentials ecdhec =</span>
<span class="line-modified">359                             ECDHECredentials.valueOf(ng, entry.keyExchange);</span>
<span class="line-modified">360                         if (ecdhec != null) {</span>
<span class="line-modified">361                             if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">362                                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">363                                     ecdhec.popPublicKey)) {</span>
<span class="line-removed">364                                 SSLLogger.warning(</span>
<span class="line-removed">365                                         &quot;ECDHE key share entry does not &quot; +</span>
<span class="line-removed">366                                         &quot;comply to algorithm constraints&quot;);</span>
<span class="line-removed">367                             } else {</span>
<span class="line-removed">368                                 credentials.add(ecdhec);</span>
<span class="line-removed">369                             }</span>
<span class="line-removed">370                         }</span>
<span class="line-removed">371                     } catch (IOException | GeneralSecurityException ex) {</span>
<span class="line-removed">372                         SSLLogger.warning(</span>
<span class="line-removed">373                                 &quot;Cannot decode named group: &quot; +</span>
<span class="line-removed">374                                 NamedGroup.nameOf(entry.namedGroupId));</span>
<span class="line-removed">375                     }</span>
<span class="line-removed">376                 } else if (ng.type == NamedGroupType.NAMED_GROUP_FFDHE) {</span>
<span class="line-removed">377                     try {</span>
<span class="line-removed">378                         DHECredentials dhec =</span>
<span class="line-removed">379                                 DHECredentials.valueOf(ng, entry.keyExchange);</span>
<span class="line-removed">380                         if (dhec != null) {</span>
<span class="line-removed">381                             if (!shc.algorithmConstraints.permits(</span>
<span class="line-removed">382                                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">383                                     dhec.popPublicKey)) {</span>
<span class="line-removed">384                                 SSLLogger.warning(</span>
<span class="line-removed">385                                         &quot;DHE key share entry does not &quot; +</span>
<span class="line-removed">386                                         &quot;comply to algorithm constraints&quot;);</span>
<span class="line-removed">387                             } else {</span>
<span class="line-removed">388                                 credentials.add(dhec);</span>
<span class="line-removed">389                             }</span>
<span class="line-removed">390                         }</span>
<span class="line-removed">391                     } catch (IOException | GeneralSecurityException ex) {</span>
<span class="line-removed">392                         SSLLogger.warning(</span>
<span class="line-removed">393                                 &quot;Cannot decode named group: &quot; +</span>
<span class="line-removed">394                                 NamedGroup.nameOf(entry.namedGroupId));</span>
395                     }




396                 }
397             }
398 
399             if (!credentials.isEmpty()) {
400                 shc.handshakeCredentials.addAll(credentials);
401             } else {
402                 // New handshake credentials are required from the client side.
403                 shc.handshakeProducers.put(
404                         SSLHandshake.HELLO_RETRY_REQUEST.id,
405                         SSLHandshake.HELLO_RETRY_REQUEST);
406             }
407 
408             // update the context
409             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
410         }
411     }
412 
413     /**
414      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
415      */
</pre>
<hr />
<pre>
509                     SSLLogger.warning(
510                             &quot;Ignore, no available server key_share extension&quot;);
511                 }
512                 return null;
513             }
514 
515             // use requested key share entries
516             if ((shc.handshakeCredentials == null) ||
517                     shc.handshakeCredentials.isEmpty()) {
518                 // Unlikely, HelloRetryRequest should be used ealier.
519                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
520                     SSLLogger.warning(
521                             &quot;No available client key share entries&quot;);
522                 }
523                 return null;
524             }
525 
526             KeyShareEntry keyShare = null;
527             for (SSLCredentials cd : shc.handshakeCredentials) {
528                 NamedGroup ng = null;
<span class="line-modified">529                 if (cd instanceof ECDHECredentials) {</span>
<span class="line-modified">530                     ng = ((ECDHECredentials)cd).namedGroup;</span>
<span class="line-modified">531                 } else if (cd instanceof DHECredentials) {</span>
<span class="line-removed">532                     ng = ((DHECredentials)cd).namedGroup;</span>
533                 }
534 
535                 if (ng == null) {
536                     continue;
537                 }
538 
539                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
540                 if (ke == null) {
541                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
542                         SSLLogger.warning(
543                             &quot;No key exchange for named group &quot; + ng.name);
544                     }
545                     continue;
546                 }
547 
548                 SSLPossession[] poses = ke.createPossessions(shc);
549                 for (SSLPossession pos : poses) {
<span class="line-modified">550                     if (!(pos instanceof ECDHEPossession) &amp;&amp;</span>
<span class="line-removed">551                             !(pos instanceof DHEPossession)) {</span>
552                         // May need more possesion types in the future.
553                         continue;
554                     }
555 
556                     // update the context
557                     shc.handshakeKeyExchange = ke;
558                     shc.handshakePossessions.add(pos);
559                     keyShare = new KeyShareEntry(ng.id, pos.encode());
560                     break;
561                 }
562 
563                 if (keyShare != null) {
564                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
565                             ke.getHandshakeProducers(shc)) {
566                         shc.handshakeProducers.put(
567                                 me.getKey(), me.getValue());
568                     }
569 
<span class="line-modified">570                     // We have got one! Don&#39;t forgor to break.</span>
571                     break;
572                 }
573             }
574 
575             if (keyShare == null) {
576                 // Unlikely, HelloRetryRequest should be used instead ealier.
577                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
578                     SSLLogger.warning(
579                             &quot;No available server key_share extension&quot;);
580                 }
581                 return null;
582             }
583 
584             byte[] extData = keyShare.getEncoded();
585 
586             // update the context
587             SHKeyShareSpec spec = new SHKeyShareSpec(keyShare);
588             shc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
589 
590             return extData;
</pre>
<hr />
<pre>
626             } catch (IOException ioe) {
627                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
628             }
629 
630             KeyShareEntry keyShare = spec.serverShare;
631             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
632             if (ng == null || !SupportedGroups.isActivatable(
633                     chc.sslConfig.algorithmConstraints, ng)) {
634                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
635                         &quot;Unsupported named group: &quot; +
636                         NamedGroup.nameOf(keyShare.namedGroupId));
637             }
638 
639             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
640             if (ke == null) {
641                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
642                         &quot;No key exchange for named group &quot; + ng.name);
643             }
644 
645             SSLCredentials credentials = null;
<span class="line-modified">646             if (ng.type == NamedGroupType.NAMED_GROUP_ECDHE) {</span>
<span class="line-modified">647                 try {</span>
<span class="line-modified">648                     ECDHECredentials ecdhec =</span>
<span class="line-modified">649                             ECDHECredentials.valueOf(ng, keyShare.keyExchange);</span>
<span class="line-modified">650                     if (ecdhec != null) {</span>
<span class="line-modified">651                         if (!chc.algorithmConstraints.permits(</span>
<span class="line-removed">652                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">653                                 ecdhec.popPublicKey)) {</span>
<span class="line-removed">654                             throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-removed">655                                     &quot;ECDHE key share entry does not &quot; +</span>
<span class="line-removed">656                                     &quot;comply to algorithm constraints&quot;);</span>
<span class="line-removed">657                         } else {</span>
<span class="line-removed">658                             credentials = ecdhec;</span>
<span class="line-removed">659                         }</span>
<span class="line-removed">660                     }</span>
<span class="line-removed">661                 } catch (IOException | GeneralSecurityException ex) {</span>
<span class="line-removed">662                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-removed">663                             &quot;Cannot decode named group: &quot; +</span>
<span class="line-removed">664                             NamedGroup.nameOf(keyShare.namedGroupId));</span>
<span class="line-removed">665                 }</span>
<span class="line-removed">666             } else if (ng.type == NamedGroupType.NAMED_GROUP_FFDHE) {</span>
<span class="line-removed">667                 try {</span>
<span class="line-removed">668                     DHECredentials dhec =</span>
<span class="line-removed">669                             DHECredentials.valueOf(ng, keyShare.keyExchange);</span>
<span class="line-removed">670                     if (dhec != null) {</span>
<span class="line-removed">671                         if (!chc.algorithmConstraints.permits(</span>
<span class="line-removed">672                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">673                                 dhec.popPublicKey)) {</span>
<span class="line-removed">674                             throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-removed">675                                     &quot;DHE key share entry does not &quot; +</span>
<span class="line-removed">676                                     &quot;comply to algorithm constraints&quot;);</span>
<span class="line-removed">677                         } else {</span>
<span class="line-removed">678                             credentials = dhec;</span>
<span class="line-removed">679                         }</span>
<span class="line-removed">680                     }</span>
<span class="line-removed">681                 } catch (IOException | GeneralSecurityException ex) {</span>
<span class="line-removed">682                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-removed">683                             &quot;Cannot decode named group: &quot; +</span>
<span class="line-removed">684                             NamedGroup.nameOf(keyShare.namedGroupId));</span>
685                 }
<span class="line-modified">686             } else {</span>
687                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
<span class="line-modified">688                         &quot;Unsupported named group: &quot; +</span>
689                         NamedGroup.nameOf(keyShare.namedGroupId));
690             }
691 
692             if (credentials == null) {
693                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
694                         &quot;Unsupported named group: &quot; + ng.name);
695             }
696 
697             // update the context
698             chc.handshakeKeyExchange = ke;
699             chc.handshakeCredentials.add(credentials);
700             chc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
701         }
702     }
703 
704     /**
705      * The absence processing if the extension is not present in
706      * the ServerHello handshake message.
707      */
708     private static final class SHKeyShareAbsence implements HandshakeAbsence {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;

 30 import java.security.GeneralSecurityException;
 31 import java.text.MessageFormat;
 32 import java.util.Arrays;
 33 import java.util.Collections;

 34 import java.util.LinkedList;
 35 import java.util.List;
 36 import java.util.Locale;
 37 import java.util.Map;
 38 import javax.net.ssl.SSLProtocolException;




 39 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
 40 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 41 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;


 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.util.HexDumpEncoder;
 45 
 46 /**
 47  * Pack of the &quot;key_share&quot; extensions.
 48  */
 49 final class KeyShareExtension {
 50     static final HandshakeProducer chNetworkProducer =
 51             new CHKeyShareProducer();
 52     static final ExtensionConsumer chOnLoadConsumer =
 53             new CHKeyShareConsumer();
 54     static final SSLStringizer chStringizer =
 55             new CHKeyShareStringizer();
 56 
 57     static final HandshakeProducer shNetworkProducer =
 58             new SHKeyShareProducer();
 59     static final ExtensionConsumer shOnLoadConsumer =
 60             new SHKeyShareConsumer();
 61     static final HandshakeAbsence shOnLoadAbsence =
 62             new SHKeyShareAbsence();
</pre>
<hr />
<pre>
239                     }
240                     return null;
241                 }
242             }
243 
244             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
245             for (NamedGroup ng : namedGroups) {
246                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
247                 if (ke == null) {
248                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
249                         SSLLogger.warning(
250                             &quot;No key exchange for named group &quot; + ng.name);
251                     }
252                     continue;
253                 }
254 
255                 SSLPossession[] poses = ke.createPossessions(chc);
256                 for (SSLPossession pos : poses) {
257                     // update the context
258                     chc.handshakePossessions.add(pos);
<span class="line-modified">259                     if (!(pos instanceof NamedGroupPossession)) {</span>

260                         // May need more possesion types in the future.
261                         continue;
262                     }
263 
264                     keyShares.add(new KeyShareEntry(ng.id, pos.encode()));
265                 }
266 
267                 // One key share entry only.  Too much key share entries makes
268                 // the ClientHello handshake message really big.
269                 if (!keyShares.isEmpty()) {
270                     break;
271                 }
272             }
273 
274             int listLen = 0;
275             for (KeyShareEntry entry : keyShares) {
276                 listLen += entry.getEncodedSize();
277             }
278             byte[] extData = new byte[listLen + 2];     //  2: list length
279             ByteBuffer m = ByteBuffer.wrap(extData);
</pre>
<hr />
<pre>
327             CHKeyShareSpec spec;
328             try {
329                 spec = new CHKeyShareSpec(buffer);
330             } catch (IOException ioe) {
331                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
332             }
333 
334             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
335             for (KeyShareEntry entry : spec.clientShares) {
336                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
337                 if (ng == null || !SupportedGroups.isActivatable(
338                         shc.sslConfig.algorithmConstraints, ng)) {
339                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
340                         SSLLogger.fine(
341                                 &quot;Ignore unsupported named group: &quot; +
342                                 NamedGroup.nameOf(entry.namedGroupId));
343                     }
344                     continue;
345                 }
346 
<span class="line-modified">347                 try {</span>
<span class="line-modified">348                     SSLCredentials kaCred =</span>
<span class="line-modified">349                         ng.decodeCredentials(entry.keyExchange,</span>
<span class="line-modified">350                         shc.algorithmConstraints,</span>
<span class="line-modified">351                         s -&gt; SSLLogger.warning(s));</span>
<span class="line-modified">352                     if (kaCred != null) {</span>
<span class="line-modified">353                         credentials.add(kaCred);</span>
































354                     }
<span class="line-added">355                 } catch (GeneralSecurityException ex) {</span>
<span class="line-added">356                     SSLLogger.warning(</span>
<span class="line-added">357                         &quot;Cannot decode named group: &quot; +</span>
<span class="line-added">358                         NamedGroup.nameOf(entry.namedGroupId));</span>
359                 }
360             }
361 
362             if (!credentials.isEmpty()) {
363                 shc.handshakeCredentials.addAll(credentials);
364             } else {
365                 // New handshake credentials are required from the client side.
366                 shc.handshakeProducers.put(
367                         SSLHandshake.HELLO_RETRY_REQUEST.id,
368                         SSLHandshake.HELLO_RETRY_REQUEST);
369             }
370 
371             // update the context
372             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
373         }
374     }
375 
376     /**
377      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
378      */
</pre>
<hr />
<pre>
472                     SSLLogger.warning(
473                             &quot;Ignore, no available server key_share extension&quot;);
474                 }
475                 return null;
476             }
477 
478             // use requested key share entries
479             if ((shc.handshakeCredentials == null) ||
480                     shc.handshakeCredentials.isEmpty()) {
481                 // Unlikely, HelloRetryRequest should be used ealier.
482                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
483                     SSLLogger.warning(
484                             &quot;No available client key share entries&quot;);
485                 }
486                 return null;
487             }
488 
489             KeyShareEntry keyShare = null;
490             for (SSLCredentials cd : shc.handshakeCredentials) {
491                 NamedGroup ng = null;
<span class="line-modified">492                 if (cd instanceof NamedGroupCredentials) {</span>
<span class="line-modified">493                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;</span>
<span class="line-modified">494                     ng = creds.getNamedGroup();</span>

495                 }
496 
497                 if (ng == null) {
498                     continue;
499                 }
500 
501                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
502                 if (ke == null) {
503                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
504                         SSLLogger.warning(
505                             &quot;No key exchange for named group &quot; + ng.name);
506                     }
507                     continue;
508                 }
509 
510                 SSLPossession[] poses = ke.createPossessions(shc);
511                 for (SSLPossession pos : poses) {
<span class="line-modified">512                     if (!(pos instanceof NamedGroupPossession)) {</span>

513                         // May need more possesion types in the future.
514                         continue;
515                     }
516 
517                     // update the context
518                     shc.handshakeKeyExchange = ke;
519                     shc.handshakePossessions.add(pos);
520                     keyShare = new KeyShareEntry(ng.id, pos.encode());
521                     break;
522                 }
523 
524                 if (keyShare != null) {
525                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
526                             ke.getHandshakeProducers(shc)) {
527                         shc.handshakeProducers.put(
528                                 me.getKey(), me.getValue());
529                     }
530 
<span class="line-modified">531                     // We have got one! Don&#39;t forget to break.</span>
532                     break;
533                 }
534             }
535 
536             if (keyShare == null) {
537                 // Unlikely, HelloRetryRequest should be used instead ealier.
538                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
539                     SSLLogger.warning(
540                             &quot;No available server key_share extension&quot;);
541                 }
542                 return null;
543             }
544 
545             byte[] extData = keyShare.getEncoded();
546 
547             // update the context
548             SHKeyShareSpec spec = new SHKeyShareSpec(keyShare);
549             shc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
550 
551             return extData;
</pre>
<hr />
<pre>
587             } catch (IOException ioe) {
588                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
589             }
590 
591             KeyShareEntry keyShare = spec.serverShare;
592             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
593             if (ng == null || !SupportedGroups.isActivatable(
594                     chc.sslConfig.algorithmConstraints, ng)) {
595                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
596                         &quot;Unsupported named group: &quot; +
597                         NamedGroup.nameOf(keyShare.namedGroupId));
598             }
599 
600             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
601             if (ke == null) {
602                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
603                         &quot;No key exchange for named group &quot; + ng.name);
604             }
605 
606             SSLCredentials credentials = null;
<span class="line-modified">607             try {</span>
<span class="line-modified">608                 SSLCredentials kaCred = ng.decodeCredentials(</span>
<span class="line-modified">609                     keyShare.keyExchange, chc.algorithmConstraints,</span>
<span class="line-modified">610                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));</span>
<span class="line-modified">611                 if (kaCred != null) {</span>
<span class="line-modified">612                     credentials = kaCred;</span>

































613                 }
<span class="line-modified">614             } catch (GeneralSecurityException ex) {</span>
615                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
<span class="line-modified">616                         &quot;Cannot decode named group: &quot; +</span>
617                         NamedGroup.nameOf(keyShare.namedGroupId));
618             }
619 
620             if (credentials == null) {
621                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
622                         &quot;Unsupported named group: &quot; + ng.name);
623             }
624 
625             // update the context
626             chc.handshakeKeyExchange = ke;
627             chc.handshakeCredentials.add(credentials);
628             chc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
629         }
630     }
631 
632     /**
633      * The absence processing if the extension is not present in
634      * the ServerHello handshake message.
635      */
636     private static final class SHKeyShareAbsence implements HandshakeAbsence {
</pre>
</td>
</tr>
</table>
<center><a href="InputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NewSessionTicket.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
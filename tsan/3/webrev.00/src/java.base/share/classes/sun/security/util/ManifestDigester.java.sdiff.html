<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/ManifestDigester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LegacyAlgorithmConstraints.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/ManifestDigester.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
<span class="line-modified"> 28 import java.security.*;</span>
 29 import java.util.ArrayList;
 30 import java.util.HashMap;
 31 import java.io.ByteArrayOutputStream;


 32 import java.util.List;
 33 
 34 import static java.nio.charset.StandardCharsets.UTF_8;
 35 
 36 /**
 37  * This class is used to compute digests on sections of the Manifest.
 38  * Please note that multiple sections might have the same name, and they
 39  * all belong to a single Entry.
 40  */
 41 public class ManifestDigester {
 42 












 43     public static final String MF_MAIN_ATTRS = &quot;Manifest-Main-Attributes&quot;;
 44 
 45     /** the raw bytes of the manifest */
<span class="line-modified"> 46     private byte[] rawBytes;</span>
 47 
<span class="line-modified"> 48     /** the entries grouped by names */</span>
<span class="line-modified"> 49     private HashMap&lt;String, Entry&gt; entries; // key is a UTF-8 string</span>


 50 
 51     /** state returned by findSection */
 52     static class Position {
 53         int endOfFirstLine; // not including newline character
 54 
 55         int endOfSection; // end of section, not including the blank line
 56                           // between sections
 57         int startOfNext;  // the start of the next section
 58     }
 59 
 60     /**
 61      * find a section in the manifest.
 62      *
 63      * @param offset should point to the starting offset with in the
 64      * raw bytes of the next section.
 65      *
 66      * @pos set by
 67      *
 68      * @return false if end of bytes has been reached, otherwise returns
 69      *          true
 70      */
 71     @SuppressWarnings(&quot;fallthrough&quot;)
 72     private boolean findSection(int offset, Position pos)
 73     {
 74         int i = offset, len = rawBytes.length;
<span class="line-modified"> 75         int last = offset;</span>
 76         int next;
 77         boolean allBlank = true;
 78 
<span class="line-modified"> 79         pos.endOfFirstLine = -1;</span>





 80 
 81         while (i &lt; len) {
 82             byte b = rawBytes[i];
 83             switch(b) {
 84             case &#39;\r&#39;:
<span class="line-modified"> 85                 if (pos.endOfFirstLine == -1)</span>
 86                     pos.endOfFirstLine = i-1;
<span class="line-modified"> 87                 if ((i &lt; len) &amp;&amp;  (rawBytes[i+1] == &#39;\n&#39;))</span>
 88                     i++;
 89                 /* fall through */
 90             case &#39;\n&#39;:
<span class="line-modified"> 91                 if (pos.endOfFirstLine == -1)</span>
 92                     pos.endOfFirstLine = i-1;
 93                 if (allBlank || (i == len-1)) {
<span class="line-modified"> 94                     if (i == len-1)</span>
<span class="line-removed"> 95                         pos.endOfSection = i;</span>
<span class="line-removed"> 96                     else</span>
<span class="line-removed"> 97                         pos.endOfSection = last;</span>
 98                     pos.startOfNext = i+1;
 99                     return true;
100                 }
101                 else {
102                     // start of a new line
103                     last = i;
104                     allBlank = true;
105                 }
106                 break;
107             default:
108                 allBlank = false;
109                 break;
110             }
111             i++;
112         }
113         return false;
114     }
115 
116     public ManifestDigester(byte[] bytes)
117     {
118         rawBytes = bytes;
<span class="line-removed">119         entries = new HashMap&lt;&gt;();</span>
120 
121         Position pos = new Position();
122 
<span class="line-modified">123         if (!findSection(0, pos))</span>

124             return; // XXX: exception?

125 
126         // create an entry for main attributes
<span class="line-modified">127         entries.put(MF_MAIN_ATTRS, new Entry().addSection(</span>
<span class="line-modified">128                 new Section(0, pos.endOfSection + 1, pos.startOfNext, rawBytes)));</span>
129 
130         int start = pos.startOfNext;
131         while(findSection(start, pos)) {
132             int len = pos.endOfFirstLine-start+1;
133             int sectionLen = pos.endOfSection-start+1;
134             int sectionLenWithBlank = pos.startOfNext-start;
135 
<span class="line-modified">136             if (len &gt; 6) {</span>
137                 if (isNameAttr(bytes, start)) {
138                     ByteArrayOutputStream nameBuf = new ByteArrayOutputStream();
139                     nameBuf.write(bytes, start+6, len-6);
140 
141                     int i = start + len;
142                     if ((i-start) &lt; sectionLen) {
<span class="line-modified">143                         if (bytes[i] == &#39;\r&#39;) {</span>


144                             i += 2;
145                         } else {
146                             i += 1;
147                         }
148                     }
149 
150                     while ((i-start) &lt; sectionLen) {
151                         if (bytes[i++] == &#39; &#39;) {
152                             // name is wrapped
153                             int wrapStart = i;
154                             while (((i-start) &lt; sectionLen)
<span class="line-modified">155                                     &amp;&amp; (bytes[i++] != &#39;\n&#39;));</span>
<span class="line-modified">156                             if (bytes[i-1] != &#39;\n&#39;)</span>
<span class="line-modified">157                                 return; // XXX: exception?</span>
<span class="line-modified">158                             int wrapLen;</span>
<span class="line-modified">159                             if (bytes[i-2] == &#39;\r&#39;)</span>
<span class="line-modified">160                                 wrapLen = i-wrapStart-2;</span>
<span class="line-modified">161                             else</span>
<span class="line-modified">162                                 wrapLen = i-wrapStart-1;</span>


163 
164                             nameBuf.write(bytes, wrapStart, wrapLen);
165                         } else {
166                             break;
167                         }
168                     }
169 
<span class="line-modified">170                     entries.computeIfAbsent(new String(nameBuf.toByteArray(), UTF_8),</span>
171                                             dummy -&gt; new Entry())
172                             .addSection(new Section(start, sectionLen,
173                                     sectionLenWithBlank, rawBytes));
174                 }
175             }
176             start = pos.startOfNext;
177         }
178     }
179 
180     private boolean isNameAttr(byte[] bytes, int start)
181     {
182         return ((bytes[start] == &#39;N&#39;) || (bytes[start] == &#39;n&#39;)) &amp;&amp;
183                ((bytes[start+1] == &#39;a&#39;) || (bytes[start+1] == &#39;A&#39;)) &amp;&amp;
184                ((bytes[start+2] == &#39;m&#39;) || (bytes[start+2] == &#39;M&#39;)) &amp;&amp;
185                ((bytes[start+3] == &#39;e&#39;) || (bytes[start+3] == &#39;E&#39;)) &amp;&amp;
186                (bytes[start+4] == &#39;:&#39;) &amp;&amp;
187                (bytes[start+5] == &#39; &#39;);
188     }
189 
190     public static class Entry {
191 
192         // One Entry for one name, and one name can have multiple sections.
193         // According to the JAR File Specification: &quot;If there are multiple
194         // individual sections for the same file entry, the attributes in
195         // these sections are merged.&quot;
196         private List&lt;Section&gt; sections = new ArrayList&lt;&gt;();
197         boolean oldStyle;
198 
199         private Entry addSection(Section sec)
200         {
201             sections.add(sec);
202             return this;
203         }
204 




















205         public byte[] digest(MessageDigest md)
206         {
207             md.reset();
208             for (Section sec : sections) {
209                 if (oldStyle) {
210                     Section.doOldStyle(md, sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
211                 } else {
212                     md.update(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
213                 }
214             }
215             return md.digest();
216         }
217 
218         /** Netscape doesn&#39;t include the new line. Intel and JavaSoft do */
219 
220         public byte[] digestWorkaround(MessageDigest md)
221         {
222             md.reset();
223             for (Section sec : sections) {
224                 md.update(sec.rawBytes, sec.offset, sec.length);
225             }
226             return md.digest();
227         }
228     }
229 
230     private static class Section {
231         int offset;
232         int length;
233         int lengthWithBlankLine;
234         byte[] rawBytes;
235 
236         public Section(int offset, int length,
237                      int lengthWithBlankLine, byte[] rawBytes)
238         {
239             this.offset = offset;
240             this.length = length;
241             this.lengthWithBlankLine = lengthWithBlankLine;
242             this.rawBytes = rawBytes;
243         }
244 









245         private static void doOldStyle(MessageDigest md,
246                                 byte[] bytes,
247                                 int offset,
248                                 int length)
249         {
250             // this is too gross to even document, but here goes
251             // the 1.1 jar verification code ignored spaces at the
252             // end of lines when calculating digests, so that is
253             // what this code does. It only gets called if we
254             // are parsing a 1.1 signed signature file
255             int i = offset;
256             int start = offset;
257             int max = offset + length;
258             int prev = -1;
259             while(i &lt;max) {
260                 if ((bytes[i] == &#39;\r&#39;) &amp;&amp; (prev == &#39; &#39;)) {
261                     md.update(bytes, start, i-start-1);
262                     start = i;
263                 }
264                 prev = bytes[i];
265                 i++;
266             }
267             md.update(bytes, start, i-start);
268         }
269     }
270 



















271     public Entry get(String name, boolean oldStyle) {
<span class="line-modified">272         Entry e = entries.get(name);</span>
<span class="line-modified">273         if (e != null)</span>



274             e.oldStyle = oldStyle;

275         return e;
276     }
277 
278     public byte[] manifestDigest(MessageDigest md) {
279         md.reset();
280         md.update(rawBytes, 0, rawBytes.length);
281         return md.digest();
282     }
283 
284 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
<span class="line-modified"> 28 import java.security.MessageDigest;</span>
 29 import java.util.ArrayList;
 30 import java.util.HashMap;
 31 import java.io.ByteArrayOutputStream;
<span class="line-added"> 32 import java.io.OutputStream;</span>
<span class="line-added"> 33 import java.io.IOException;</span>
 34 import java.util.List;
 35 
 36 import static java.nio.charset.StandardCharsets.UTF_8;
 37 
 38 /**
 39  * This class is used to compute digests on sections of the Manifest.
 40  * Please note that multiple sections might have the same name, and they
 41  * all belong to a single Entry.
 42  */
 43 public class ManifestDigester {
 44 
<span class="line-added"> 45     /**</span>
<span class="line-added"> 46      * The part &quot;{@code Manifest-Main-Attributes}&quot; of the main attributes</span>
<span class="line-added"> 47      * digest header name in a signature file as described in the jar</span>
<span class="line-added"> 48      * specification:</span>
<span class="line-added"> 49      * &lt;blockquote&gt;{@code x-Digest-Manifest-Main-Attributes}</span>
<span class="line-added"> 50      * (where x is the standard name of a {@link MessageDigest} algorithm):</span>
<span class="line-added"> 51      * The value of this attribute is the digest value of the main attributes</span>
<span class="line-added"> 52      * of the manifest.&lt;/blockquote&gt;</span>
<span class="line-added"> 53      * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#signature-file&quot;&gt;</span>
<span class="line-added"> 54      * JAR File Specification, section Signature File&lt;/a&gt;</span>
<span class="line-added"> 55      * @see #getMainAttsEntry</span>
<span class="line-added"> 56      */</span>
 57     public static final String MF_MAIN_ATTRS = &quot;Manifest-Main-Attributes&quot;;
 58 
 59     /** the raw bytes of the manifest */
<span class="line-modified"> 60     private final byte[] rawBytes;</span>
 61 
<span class="line-modified"> 62     private final Entry mainAttsEntry;</span>
<span class="line-modified"> 63 </span>
<span class="line-added"> 64     /** individual sections by their names */</span>
<span class="line-added"> 65     private final HashMap&lt;String, Entry&gt; entries = new HashMap&lt;&gt;();</span>
 66 
 67     /** state returned by findSection */
 68     static class Position {
 69         int endOfFirstLine; // not including newline character
 70 
 71         int endOfSection; // end of section, not including the blank line
 72                           // between sections
 73         int startOfNext;  // the start of the next section
 74     }
 75 
 76     /**
 77      * find a section in the manifest.
 78      *
 79      * @param offset should point to the starting offset with in the
 80      * raw bytes of the next section.
 81      *
 82      * @pos set by
 83      *
 84      * @return false if end of bytes has been reached, otherwise returns
 85      *          true
 86      */
 87     @SuppressWarnings(&quot;fallthrough&quot;)
 88     private boolean findSection(int offset, Position pos)
 89     {
 90         int i = offset, len = rawBytes.length;
<span class="line-modified"> 91         int last = offset - 1;</span>
 92         int next;
 93         boolean allBlank = true;
 94 
<span class="line-modified"> 95         /* denotes that a position is not yet assigned.</span>
<span class="line-added"> 96          * As a primitive type int it cannot be null</span>
<span class="line-added"> 97          * and -1 would be confused with (i - 1) when i == 0 */</span>
<span class="line-added"> 98         final int UNASSIGNED = Integer.MIN_VALUE;</span>
<span class="line-added"> 99 </span>
<span class="line-added">100         pos.endOfFirstLine = UNASSIGNED;</span>
101 
102         while (i &lt; len) {
103             byte b = rawBytes[i];
104             switch(b) {
105             case &#39;\r&#39;:
<span class="line-modified">106                 if (pos.endOfFirstLine == UNASSIGNED)</span>
107                     pos.endOfFirstLine = i-1;
<span class="line-modified">108                 if (i &lt; len - 1 &amp;&amp; rawBytes[i + 1] == &#39;\n&#39;)</span>
109                     i++;
110                 /* fall through */
111             case &#39;\n&#39;:
<span class="line-modified">112                 if (pos.endOfFirstLine == UNASSIGNED)</span>
113                     pos.endOfFirstLine = i-1;
114                 if (allBlank || (i == len-1)) {
<span class="line-modified">115                     pos.endOfSection = allBlank ? last : i;</span>



116                     pos.startOfNext = i+1;
117                     return true;
118                 }
119                 else {
120                     // start of a new line
121                     last = i;
122                     allBlank = true;
123                 }
124                 break;
125             default:
126                 allBlank = false;
127                 break;
128             }
129             i++;
130         }
131         return false;
132     }
133 
134     public ManifestDigester(byte[] bytes)
135     {
136         rawBytes = bytes;

137 
138         Position pos = new Position();
139 
<span class="line-modified">140         if (!findSection(0, pos)) {</span>
<span class="line-added">141             mainAttsEntry = null;</span>
142             return; // XXX: exception?
<span class="line-added">143         }</span>
144 
145         // create an entry for main attributes
<span class="line-modified">146         mainAttsEntry = new Entry().addSection(new Section(</span>
<span class="line-modified">147                 0, pos.endOfSection + 1, pos.startOfNext, rawBytes));</span>
148 
149         int start = pos.startOfNext;
150         while(findSection(start, pos)) {
151             int len = pos.endOfFirstLine-start+1;
152             int sectionLen = pos.endOfSection-start+1;
153             int sectionLenWithBlank = pos.startOfNext-start;
154 
<span class="line-modified">155             if (len &gt;= 6) { // 6 == &quot;Name: &quot;.length()</span>
156                 if (isNameAttr(bytes, start)) {
157                     ByteArrayOutputStream nameBuf = new ByteArrayOutputStream();
158                     nameBuf.write(bytes, start+6, len-6);
159 
160                     int i = start + len;
161                     if ((i-start) &lt; sectionLen) {
<span class="line-modified">162                         if (bytes[i] == &#39;\r&#39;</span>
<span class="line-added">163                                 &amp;&amp; i + 1 - start &lt; sectionLen</span>
<span class="line-added">164                                 &amp;&amp; bytes[i + 1] == &#39;\n&#39;) {</span>
165                             i += 2;
166                         } else {
167                             i += 1;
168                         }
169                     }
170 
171                     while ((i-start) &lt; sectionLen) {
172                         if (bytes[i++] == &#39; &#39;) {
173                             // name is wrapped
174                             int wrapStart = i;
175                             while (((i-start) &lt; sectionLen)
<span class="line-modified">176                                     &amp;&amp; (bytes[i] != &#39;\r&#39;)</span>
<span class="line-modified">177                                     &amp;&amp; (bytes[i] != &#39;\n&#39;)) i++;</span>
<span class="line-modified">178                             int wrapLen = i - wrapStart;</span>
<span class="line-modified">179                             if (i - start &lt; sectionLen) {</span>
<span class="line-modified">180                                 i++;</span>
<span class="line-modified">181                                 if (bytes[i - 1] == &#39;\r&#39;</span>
<span class="line-modified">182                                     &amp;&amp; i - start &lt; sectionLen</span>
<span class="line-modified">183                                     &amp;&amp; bytes[i] == &#39;\n&#39;)</span>
<span class="line-added">184                                         i++;</span>
<span class="line-added">185                             }</span>
186 
187                             nameBuf.write(bytes, wrapStart, wrapLen);
188                         } else {
189                             break;
190                         }
191                     }
192 
<span class="line-modified">193                     entries.computeIfAbsent(nameBuf.toString(UTF_8),</span>
194                                             dummy -&gt; new Entry())
195                             .addSection(new Section(start, sectionLen,
196                                     sectionLenWithBlank, rawBytes));
197                 }
198             }
199             start = pos.startOfNext;
200         }
201     }
202 
203     private boolean isNameAttr(byte[] bytes, int start)
204     {
205         return ((bytes[start] == &#39;N&#39;) || (bytes[start] == &#39;n&#39;)) &amp;&amp;
206                ((bytes[start+1] == &#39;a&#39;) || (bytes[start+1] == &#39;A&#39;)) &amp;&amp;
207                ((bytes[start+2] == &#39;m&#39;) || (bytes[start+2] == &#39;M&#39;)) &amp;&amp;
208                ((bytes[start+3] == &#39;e&#39;) || (bytes[start+3] == &#39;E&#39;)) &amp;&amp;
209                (bytes[start+4] == &#39;:&#39;) &amp;&amp;
210                (bytes[start+5] == &#39; &#39;);
211     }
212 
213     public static class Entry {
214 
215         // One Entry for one name, and one name can have multiple sections.
216         // According to the JAR File Specification: &quot;If there are multiple
217         // individual sections for the same file entry, the attributes in
218         // these sections are merged.&quot;
219         private List&lt;Section&gt; sections = new ArrayList&lt;&gt;();
220         boolean oldStyle;
221 
222         private Entry addSection(Section sec)
223         {
224             sections.add(sec);
225             return this;
226         }
227 
<span class="line-added">228         /**</span>
<span class="line-added">229          * Check if the sections (particularly the last one of usually only one)</span>
<span class="line-added">230          * are properly delimited with a trailing blank line so that another</span>
<span class="line-added">231          * section can be correctly appended and return {@code true} or return</span>
<span class="line-added">232          * {@code false} to indicate that reproduction is not advised and should</span>
<span class="line-added">233          * be carried out with a clean &quot;normalized&quot; newly-written manifest.</span>
<span class="line-added">234          *</span>
<span class="line-added">235          * @see #reproduceRaw</span>
<span class="line-added">236          */</span>
<span class="line-added">237         public boolean isProperlyDelimited() {</span>
<span class="line-added">238             return sections.stream().allMatch(</span>
<span class="line-added">239                     Section::isProperlySectionDelimited);</span>
<span class="line-added">240         }</span>
<span class="line-added">241 </span>
<span class="line-added">242         public void reproduceRaw(OutputStream out) throws IOException {</span>
<span class="line-added">243             for (Section sec : sections) {</span>
<span class="line-added">244                 out.write(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);</span>
<span class="line-added">245             }</span>
<span class="line-added">246         }</span>
<span class="line-added">247 </span>
248         public byte[] digest(MessageDigest md)
249         {
250             md.reset();
251             for (Section sec : sections) {
252                 if (oldStyle) {
253                     Section.doOldStyle(md, sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
254                 } else {
255                     md.update(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
256                 }
257             }
258             return md.digest();
259         }
260 
261         /** Netscape doesn&#39;t include the new line. Intel and JavaSoft do */
262 
263         public byte[] digestWorkaround(MessageDigest md)
264         {
265             md.reset();
266             for (Section sec : sections) {
267                 md.update(sec.rawBytes, sec.offset, sec.length);
268             }
269             return md.digest();
270         }
271     }
272 
273     private static class Section {
274         int offset;
275         int length;
276         int lengthWithBlankLine;
277         byte[] rawBytes;
278 
279         public Section(int offset, int length,
280                      int lengthWithBlankLine, byte[] rawBytes)
281         {
282             this.offset = offset;
283             this.length = length;
284             this.lengthWithBlankLine = lengthWithBlankLine;
285             this.rawBytes = rawBytes;
286         }
287 
<span class="line-added">288         /**</span>
<span class="line-added">289          * Returns {@code true} if the raw section is terminated with a blank</span>
<span class="line-added">290          * line so that another section can possibly be appended resulting in a</span>
<span class="line-added">291          * valid manifest and {@code false} otherwise.</span>
<span class="line-added">292          */</span>
<span class="line-added">293         private boolean isProperlySectionDelimited() {</span>
<span class="line-added">294             return lengthWithBlankLine &gt; length;</span>
<span class="line-added">295         }</span>
<span class="line-added">296 </span>
297         private static void doOldStyle(MessageDigest md,
298                                 byte[] bytes,
299                                 int offset,
300                                 int length)
301         {
302             // this is too gross to even document, but here goes
303             // the 1.1 jar verification code ignored spaces at the
304             // end of lines when calculating digests, so that is
305             // what this code does. It only gets called if we
306             // are parsing a 1.1 signed signature file
307             int i = offset;
308             int start = offset;
309             int max = offset + length;
310             int prev = -1;
311             while(i &lt;max) {
312                 if ((bytes[i] == &#39;\r&#39;) &amp;&amp; (prev == &#39; &#39;)) {
313                     md.update(bytes, start, i-start-1);
314                     start = i;
315                 }
316                 prev = bytes[i];
317                 i++;
318             }
319             md.update(bytes, start, i-start);
320         }
321     }
322 
<span class="line-added">323     /**</span>
<span class="line-added">324      * @see #MF_MAIN_ATTRS</span>
<span class="line-added">325      */</span>
<span class="line-added">326     public Entry getMainAttsEntry() {</span>
<span class="line-added">327         return mainAttsEntry;</span>
<span class="line-added">328     }</span>
<span class="line-added">329 </span>
<span class="line-added">330     /**</span>
<span class="line-added">331      * @see #MF_MAIN_ATTRS</span>
<span class="line-added">332      */</span>
<span class="line-added">333     public Entry getMainAttsEntry(boolean oldStyle) {</span>
<span class="line-added">334         mainAttsEntry.oldStyle = oldStyle;</span>
<span class="line-added">335         return mainAttsEntry;</span>
<span class="line-added">336     }</span>
<span class="line-added">337 </span>
<span class="line-added">338     public Entry get(String name) {</span>
<span class="line-added">339         return entries.get(name);</span>
<span class="line-added">340     }</span>
<span class="line-added">341 </span>
342     public Entry get(String name, boolean oldStyle) {
<span class="line-modified">343         Entry e = get(name);</span>
<span class="line-modified">344         if (e == null &amp;&amp; MF_MAIN_ATTRS.equals(name)) {</span>
<span class="line-added">345             e = getMainAttsEntry();</span>
<span class="line-added">346         }</span>
<span class="line-added">347         if (e != null) {</span>
348             e.oldStyle = oldStyle;
<span class="line-added">349         }</span>
350         return e;
351     }
352 
353     public byte[] manifestDigest(MessageDigest md) {
354         md.reset();
355         md.update(rawBytes, 0, rawBytes.length);
356         return md.digest();
357     }
358 
359 }
</pre>
</td>
</tr>
</table>
<center><a href="LegacyAlgorithmConstraints.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocketAdaptor.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketAdaptor.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,14 +29,16 @@</span>
  import java.io.IOException;
  import java.net.InetSocketAddress;
  import java.net.ServerSocket;
  import java.net.SocketAddress;
  import java.net.SocketOption;
<span class="udiff-line-added">+ import java.net.SocketTimeoutException;</span>
  import java.net.StandardSocketOptions;
  import java.nio.channels.AlreadyBoundException;
  import java.nio.channels.AsynchronousCloseException;
  import java.nio.channels.ClosedChannelException;
<span class="udiff-line-added">+ import java.nio.channels.IllegalBlockingModeException;</span>
  import java.nio.channels.NotYetBoundException;
  import java.nio.channels.SelectionKey;
  import java.nio.channels.ServerSocketChannel;
  import java.nio.channels.SocketChannel;
  import java.nio.channels.spi.SelectorProvider;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56,11 +58,11 @@</span>
  class ServerSocketChannelImpl
      extends ServerSocketChannel
      implements SelChImpl
  {
      // Used to make native close and configure calls
<span class="udiff-line-modified-removed">-     private static NativeDispatcher nd;</span>
<span class="udiff-line-modified-added">+     private static final NativeDispatcher nd = new SocketDispatcher();</span>
  
      // Our file descriptor
      private final FileDescriptor fd;
      private final int fdVal;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74,12 +76,11 @@</span>
      // -- The following fields are protected by stateLock
  
      // Channel state, increases monotonically
      private static final int ST_INUSE = 0;
      private static final int ST_CLOSING = 1;
<span class="udiff-line-modified-removed">-     private static final int ST_KILLPENDING = 2;</span>
<span class="udiff-line-removed">-     private static final int ST_KILLED = 3;</span>
<span class="udiff-line-modified-added">+     private static final int ST_CLOSED = 2;</span>
      private int state;
  
      // ID of native thread currently blocked in this channel, for signalling
      private long thread;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,13 +94,13 @@</span>
      private ServerSocket socket;
  
      // -- End of fields protected by stateLock
  
  
<span class="udiff-line-modified-removed">-     ServerSocketChannelImpl(SelectorProvider sp) throws IOException {</span>
<span class="udiff-line-modified-added">+     ServerSocketChannelImpl(SelectorProvider sp) {</span>
          super(sp);
<span class="udiff-line-modified-removed">-         this.fd =  Net.serverSocket(true);</span>
<span class="udiff-line-modified-added">+         this.fd = Net.serverSocket(true);</span>
          this.fdVal = IOUtil.fdVal(fd);
      }
  
      ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
          throws IOException
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -144,10 +145,13 @@</span>
          throws IOException
      {
          Objects.requireNonNull(name);
          if (!supportedOptions().contains(name))
              throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<span class="udiff-line-added">+         if (!name.type().isInstance(value))</span>
<span class="udiff-line-added">+             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="udiff-line-added">+ </span>
          synchronized (stateLock) {
              ensureOpen();
  
              if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
                  // SO_REUSEADDR emulated when using exclusive bind
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,150 +252,247 @@</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  thread = 0;
<span class="udiff-line-removed">-                 // notify any thread waiting in implCloseSelectableChannel</span>
                  if (state == ST_CLOSING) {
<span class="udiff-line-modified-removed">-                     stateLock.notifyAll();</span>
<span class="udiff-line-modified-added">+                     tryFinishClose();</span>
                  }
              }
              end(completed);
          }
      }
  
      @Override
      public SocketChannel accept() throws IOException {
<span class="udiff-line-added">+         int n = 0;</span>
<span class="udiff-line-added">+         FileDescriptor newfd = new FileDescriptor();</span>
<span class="udiff-line-added">+         InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
<span class="udiff-line-added">+ </span>
          acceptLock.lock();
          try {
<span class="udiff-line-removed">-             int n = 0;</span>
<span class="udiff-line-removed">-             FileDescriptor newfd = new FileDescriptor();</span>
<span class="udiff-line-removed">-             InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
<span class="udiff-line-removed">- </span>
              boolean blocking = isBlocking();
              try {
                  begin(blocking);
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     n = accept(this.fd, newfd, isaa);</span>
<span class="udiff-line-modified-removed">-                 } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="udiff-line-modified-added">+                 n = Net.accept(this.fd, newfd, isaa);</span>
<span class="udiff-line-modified-added">+                 if (blocking) {</span>
<span class="udiff-line-modified-added">+                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="udiff-line-added">+                         park(Net.POLLIN);</span>
<span class="udiff-line-added">+                         n = Net.accept(this.fd, newfd, isaa);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
              } finally {
                  end(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             acceptLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             if (n &lt; 1)</span>
<span class="udiff-line-modified-removed">-                 return null;</span>
<span class="udiff-line-modified-added">+         if (n &gt; 0) {</span>
<span class="udiff-line-modified-added">+             return finishAccept(newfd, isaa[0]);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-             // newly accepted socket is initially in blocking mode</span>
<span class="udiff-line-modified-removed">-             IOUtil.configureBlocking(newfd, true);</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Accepts a new connection with a given timeout. This method requires the</span>
<span class="udiff-line-added">+      * channel to be configured in blocking mode.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @apiNote This method is for use by the socket adaptor.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param nanos the timeout, in nanoseconds</span>
<span class="udiff-line-added">+      * @throws IllegalBlockingModeException if the channel is configured non-blocking</span>
<span class="udiff-line-added">+      * @throws SocketTimeoutException if the timeout expires</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     SocketChannel blockingAccept(long nanos) throws IOException {</span>
<span class="udiff-line-added">+         int n = 0;</span>
<span class="udiff-line-added">+         FileDescriptor newfd = new FileDescriptor();</span>
<span class="udiff-line-added">+         InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
  
<span class="udiff-line-modified-removed">-             InetSocketAddress isa = isaa[0];</span>
<span class="udiff-line-modified-removed">-             SocketChannel sc = new SocketChannelImpl(provider(), newfd, isa);</span>
<span class="udiff-line-modified-added">+         acceptLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-added">+             // check that channel is configured blocking</span>
<span class="udiff-line-added">+             if (!isBlocking())</span>
<span class="udiff-line-added">+                 throw new IllegalBlockingModeException();</span>
  
<span class="udiff-line-modified-removed">-             // check permitted to accept connections from the remote address</span>
<span class="udiff-line-modified-removed">-             SecurityManager sm = System.getSecurityManager();</span>
<span class="udiff-line-modified-removed">-             if (sm != null) {</span>
<span class="udiff-line-modified-added">+             try {</span>
<span class="udiff-line-modified-added">+                 begin(true);</span>
<span class="udiff-line-modified-added">+                 // change socket to non-blocking</span>
<span class="udiff-line-added">+                 lockedConfigureBlocking(false);</span>
                  try {
<span class="udiff-line-modified-removed">-                     sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="udiff-line-modified-removed">-                 } catch (SecurityException x) {</span>
<span class="udiff-line-modified-removed">-                     sc.close();</span>
<span class="udiff-line-modified-removed">-                     throw x;</span>
<span class="udiff-line-modified-added">+                     long startNanos = System.nanoTime();</span>
<span class="udiff-line-modified-added">+                     n = Net.accept(fd, newfd, isaa);</span>
<span class="udiff-line-modified-added">+                     while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="udiff-line-modified-added">+                         long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="udiff-line-added">+                         if (remainingNanos &lt;= 0) {</span>
<span class="udiff-line-added">+                             throw new SocketTimeoutException(&quot;Accept timed out&quot;);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         park(Net.POLLIN, remainingNanos);</span>
<span class="udiff-line-added">+                         n = Net.accept(fd, newfd, isaa);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } finally {</span>
<span class="udiff-line-added">+                     // restore socket to blocking mode (if channel is open)</span>
<span class="udiff-line-added">+                     tryLockedConfigureBlocking(true);</span>
                  }
<span class="udiff-line-added">+             } finally {</span>
<span class="udiff-line-added">+                 end(true, n &gt; 0);</span>
              }
<span class="udiff-line-removed">-             return sc;</span>
<span class="udiff-line-removed">- </span>
          } finally {
              acceptLock.unlock();
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         assert n &gt; 0;</span>
<span class="udiff-line-added">+         return finishAccept(newfd, isaa[0]);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)</span>
<span class="udiff-line-added">+         throws IOException</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             // newly accepted socket is initially in blocking mode</span>
<span class="udiff-line-added">+             IOUtil.configureBlocking(newfd, true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // check permitted to accept connections from the remote address</span>
<span class="udiff-line-added">+             SecurityManager sm = System.getSecurityManager();</span>
<span class="udiff-line-added">+             if (sm != null) {</span>
<span class="udiff-line-added">+                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return new SocketChannelImpl(provider(), newfd, isa);</span>
<span class="udiff-line-added">+         } catch (Exception e) {</span>
<span class="udiff-line-added">+             nd.close(newfd);</span>
<span class="udiff-line-added">+             throw e;</span>
<span class="udiff-line-added">+         }</span>
      }
  
      @Override
      protected void implConfigureBlocking(boolean block) throws IOException {
          acceptLock.lock();
          try {
<span class="udiff-line-modified-removed">-             synchronized (stateLock) {</span>
<span class="udiff-line-removed">-                 ensureOpen();</span>
<span class="udiff-line-removed">-                 IOUtil.configureBlocking(fd, block);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             lockedConfigureBlocking(block);</span>
          } finally {
              acceptLock.unlock();
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Invoked by implCloseChannel to close the channel.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="udiff-line-modified-removed">-      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="udiff-line-modified-removed">-      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="udiff-line-modified-removed">-      * complete quickly.</span>
<span class="udiff-line-modified-added">+      * Adjust the blocking. acceptLock must already be held.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="udiff-line-modified-added">+         assert acceptLock.isHeldByCurrentThread();</span>
<span class="udiff-line-modified-added">+         synchronized (stateLock) {</span>
<span class="udiff-line-modified-added">+             ensureOpen();</span>
<span class="udiff-line-added">+             IOUtil.configureBlocking(fd, block);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Adjusts the blocking mode if the channel is open. acceptLock must already</span>
<span class="udiff-line-added">+      * be held.</span>
       *
<span class="udiff-line-modified-removed">-      * The socket is closed by this method when it is not registered with a</span>
<span class="udiff-line-modified-removed">-      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="udiff-line-removed">-      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="udiff-line-removed">-      * to blocking mode before the key is flushed from the Selector.</span>
<span class="udiff-line-modified-added">+      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="udiff-line-modified-added">+      *         the blocking mode was not adjusted because the channel is closed</span>
       */
<span class="udiff-line-modified-removed">-     @Override</span>
<span class="udiff-line-modified-removed">-     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="udiff-line-modified-removed">-         assert !isOpen();</span>
<span class="udiff-line-modified-added">+     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="udiff-line-modified-added">+         assert acceptLock.isHeldByCurrentThread();</span>
<span class="udiff-line-modified-added">+         synchronized (stateLock) {</span>
<span class="udiff-line-added">+             if (isOpen()) {</span>
<span class="udiff-line-added">+                 IOUtil.configureBlocking(fd, block);</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         boolean interrupted = false;</span>
<span class="udiff-line-modified-removed">-         boolean blocking;</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Closes the socket if there are no accept in progress and the channel is</span>
<span class="udiff-line-added">+      * not registered with a Selector.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private boolean tryClose() throws IOException {</span>
<span class="udiff-line-added">+         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="udiff-line-added">+         if ((thread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="udiff-line-added">+             state = ST_CLOSED;</span>
<span class="udiff-line-added">+             nd.close(fd);</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // set state to ST_CLOSING</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-added">+      * Invokes tryClose to attempt to close the socket.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void tryFinishClose() {</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             tryClose();</span>
<span class="udiff-line-added">+         } catch (IOException ignore) { }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Closes this channel when configured in blocking mode.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * If there is an accept in progress then the socket is pre-closed and the</span>
<span class="udiff-line-added">+      * accept thread is signalled, in which case the final close is deferred</span>
<span class="udiff-line-added">+      * until the accept aborts.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void implCloseBlockingMode() throws IOException {</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
              state = ST_CLOSING;
<span class="udiff-line-modified-removed">-             blocking = isBlocking();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // wait for any outstanding accept to complete</span>
<span class="udiff-line-removed">-         if (blocking) {</span>
<span class="udiff-line-removed">-             synchronized (stateLock) {</span>
<span class="udiff-line-removed">-                 assert state == ST_CLOSING;</span>
<span class="udiff-line-modified-added">+             if (!tryClose()) {</span>
                  long th = thread;
                  if (th != 0) {
                      nd.preClose(fd);
                      NativeThread.signal(th);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     // wait for accept operation to end</span>
<span class="udiff-line-removed">-                     while (thread != 0) {</span>
<span class="udiff-line-removed">-                         try {</span>
<span class="udiff-line-removed">-                             stateLock.wait();</span>
<span class="udiff-line-removed">-                         } catch (InterruptedException e) {</span>
<span class="udiff-line-removed">-                             interrupted = true;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
                  }
              }
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             // non-blocking mode: wait for accept to complete</span>
<span class="udiff-line-removed">-             acceptLock.lock();</span>
<span class="udiff-line-removed">-             acceptLock.unlock();</span>
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // set state to ST_KILLPENDING</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-added">+      * Closes this channel when configured in non-blocking mode.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * If the channel is registered with a Selector then the close is deferred</span>
<span class="udiff-line-added">+      * until the channel is flushed from all Selectors.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void implCloseNonBlockingMode() throws IOException {</span>
<span class="udiff-line-added">+         synchronized (stateLock) {</span>
<span class="udiff-line-added">+             assert state &lt; ST_CLOSING;</span>
<span class="udiff-line-added">+             state = ST_CLOSING;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // wait for any accept to complete before trying to close</span>
<span class="udiff-line-added">+         acceptLock.lock();</span>
<span class="udiff-line-added">+         acceptLock.unlock();</span>
          synchronized (stateLock) {
<span class="udiff-line-modified-removed">-             assert state == ST_CLOSING;</span>
<span class="udiff-line-modified-removed">-             state = ST_KILLPENDING;</span>
<span class="udiff-line-modified-added">+             if (state == ST_CLOSING) {</span>
<span class="udiff-line-modified-added">+                 tryClose();</span>
<span class="udiff-line-added">+             }</span>
          }
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // close socket if not registered with Selector</span>
<span class="udiff-line-modified-removed">-         if (!isRegistered())</span>
<span class="udiff-line-modified-removed">-             kill();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         // restore interrupt status</span>
<span class="udiff-line-modified-removed">-         if (interrupted)</span>
<span class="udiff-line-modified-removed">-             Thread.currentThread().interrupt();</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Invoked by implCloseChannel to close the channel.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     @Override</span>
<span class="udiff-line-modified-added">+     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="udiff-line-modified-added">+         assert !isOpen();</span>
<span class="udiff-line-modified-added">+         if (isBlocking()) {</span>
<span class="udiff-line-added">+             implCloseBlockingMode();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             implCloseNonBlockingMode();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      @Override
<span class="udiff-line-modified-removed">-     public void kill() throws IOException {</span>
<span class="udiff-line-modified-added">+     public void kill() {</span>
          synchronized (stateLock) {
<span class="udiff-line-modified-removed">-             if (state == ST_KILLPENDING) {</span>
<span class="udiff-line-modified-removed">-                 state = ST_KILLED;</span>
<span class="udiff-line-removed">-                 nd.close(fd);</span>
<span class="udiff-line-modified-added">+             if (state == ST_CLOSING) {</span>
<span class="udiff-line-modified-added">+                 tryFinishClose();</span>
              }
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -410,32 +511,10 @@</span>
          synchronized (stateLock) {
              return localAddress;
          }
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Poll this channel&#39;s socket for a new connection up to the given timeout.</span>
<span class="udiff-line-removed">-      * @return {@code true} if there is a connection to accept</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     boolean pollAccept(long timeout) throws IOException {</span>
<span class="udiff-line-removed">-         assert Thread.holdsLock(blockingLock()) &amp;&amp; isBlocking();</span>
<span class="udiff-line-removed">-         acceptLock.lock();</span>
<span class="udiff-line-removed">-         try {</span>
<span class="udiff-line-removed">-             boolean polled = false;</span>
<span class="udiff-line-removed">-             try {</span>
<span class="udiff-line-removed">-                 begin(true);</span>
<span class="udiff-line-removed">-                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="udiff-line-removed">-                 polled = (events != 0);</span>
<span class="udiff-line-removed">-             } finally {</span>
<span class="udiff-line-removed">-                 end(true, polled);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return polled;</span>
<span class="udiff-line-removed">-         } finally {</span>
<span class="udiff-line-removed">-             acceptLock.unlock();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Translates native poll revent set into a ready operation set
       */
      public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
          int intOps = ski.nioInterestOps();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -506,40 +585,6 @@</span>
              }
          }
          sb.append(&#39;]&#39;);
          return sb.toString();
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Accept a connection on a socket.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @implNote Wrap native call to allow instrumentation.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private int accept(FileDescriptor ssfd,</span>
<span class="udiff-line-removed">-                        FileDescriptor newfd,</span>
<span class="udiff-line-removed">-                        InetSocketAddress[] isaa)</span>
<span class="udiff-line-removed">-         throws IOException</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return accept0(ssfd, newfd, isaa);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // -- Native methods --</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Accepts a new connection, setting the given file descriptor to refer to</span>
<span class="udiff-line-removed">-     // the new socket and setting isaa[0] to the socket&#39;s remote address.</span>
<span class="udiff-line-removed">-     // Returns 1 on success, or IOStatus.UNAVAILABLE (if non-blocking and no</span>
<span class="udiff-line-removed">-     // connections are pending) or IOStatus.INTERRUPTED.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     private native int accept0(FileDescriptor ssfd,</span>
<span class="udiff-line-removed">-                                FileDescriptor newfd,</span>
<span class="udiff-line-removed">-                                InetSocketAddress[] isaa)</span>
<span class="udiff-line-removed">-         throws IOException;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static native void initIDs();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static {</span>
<span class="udiff-line-removed">-         IOUtil.load();</span>
<span class="udiff-line-removed">-         initIDs();</span>
<span class="udiff-line-removed">-         nd = new SocketDispatcher();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
  }
</pre>
<center><a href="ServerSocketAdaptor.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketAdaptor.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
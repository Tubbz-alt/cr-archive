<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/net/www/http/ChunkedInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.net.www.http;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.net.*;
 31 import sun.net.www.*;
 32 import sun.nio.cs.US_ASCII;
 33 
 34 /**
 35  * A &lt;code&gt;ChunkedInputStream&lt;/code&gt; provides a stream for reading a body of
 36  * a http message that can be sent as a series of chunks, each with its own
 37  * size indicator. Optionally the last chunk can be followed by trailers
 38  * containing entity-header fields.
 39  * &lt;p&gt;
 40  * A &lt;code&gt;ChunkedInputStream&lt;/code&gt; is also &lt;code&gt;Hurryable&lt;/code&gt; so it
 41  * can be hurried to the end of the stream if the bytes are available on
 42  * the underlying stream.
 43  */
 44 public
 45 class ChunkedInputStream extends InputStream implements Hurryable {
 46 
 47     /**
 48      * The underlying stream
 49      */
 50     private InputStream in;
 51 
 52     /**
 53      * The &lt;code&gt;HttpClient&lt;/code&gt; that should be notified when the chunked stream has
 54      * completed.
 55      */
 56     private HttpClient hc;
 57 
 58     /**
 59      * The &lt;code&gt;MessageHeader&lt;/code&gt; that is populated with any optional trailer
 60      * that appear after the last chunk.
 61      */
 62     private MessageHeader responses;
 63 
 64     /**
 65      * The size, in bytes, of the chunk that is currently being read.
 66      * This size is only valid if the current position in the underlying
 67      * input stream is inside a chunk (ie: state == STATE_READING_CHUNK).
 68      */
 69     private int chunkSize;
 70 
 71     /**
 72      * The number of bytes read from the underlying stream for the current
 73      * chunk. This value is always in the range &lt;code&gt;0&lt;/code&gt; through to
 74      * &lt;code&gt;chunkSize&lt;/code&gt;
 75      */
 76     private int chunkRead;
 77 
 78     /**
 79      * The internal buffer array where chunk data is available for the
 80      * application to read.
 81      */
 82     private byte chunkData[] = new byte[4096];
 83 
 84     /**
 85      * The current position in the buffer. It contains the index
 86      * of the next byte to read from &lt;code&gt;chunkData&lt;/code&gt;
 87      */
 88     private int chunkPos;
 89 
 90     /**
 91      * The index one greater than the index of the last valid byte in the
 92      * buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through
 93      * &lt;code&gt;chunkData.length&lt;/code&gt;.
 94      */
 95     private int chunkCount;
 96 
 97     /**
 98      * The internal buffer where bytes from the underlying stream can be
 99      * read. It may contain bytes representing chunk-size, chunk-data, or
100      * trailer fields.
101      */
102     private byte rawData[] = new byte[32];
103 
104     /**
105      * The current position in the buffer. It contains the index
106      * of the next byte to read from &lt;code&gt;rawData&lt;/code&gt;
107      */
108     private int rawPos;
109 
110     /**
111      * The index one greater than the index of the last valid byte in the
112      * buffer. This value is always in the range &lt;code&gt;0&lt;/code&gt; through
113      * &lt;code&gt;rawData.length&lt;/code&gt;.
114      */
115     private int rawCount;
116 
117     /**
118      * Indicates if an error was encountered when processing the chunked
119      * stream.
120      */
121     private boolean error;
122 
123     /**
124      * Indicates if the chunked stream has been closed using the
125      * &lt;code&gt;close&lt;/code&gt; method.
126      */
127     private boolean closed;
128 
129     /*
130      * Maximum chunk header size of 2KB + 2 bytes for CRLF
131      */
132     private static final int MAX_CHUNK_HEADER_SIZE = 2050;
133 
134     /**
135      * State to indicate that next field should be :-
136      *  chunk-size [ chunk-extension ] CRLF
137      */
138     static final int STATE_AWAITING_CHUNK_HEADER    = 1;
139 
140     /**
141      * State to indicate that we are currently reading the chunk-data.
142      */
143     static final int STATE_READING_CHUNK            = 2;
144 
145     /**
146      * Indicates that a chunk has been completely read and the next
147      * fields to be examine should be CRLF
148      */
149     static final int STATE_AWAITING_CHUNK_EOL       = 3;
150 
151     /**
152      * Indicates that all chunks have been read and the next field
153      * should be optional trailers or an indication that the chunked
154      * stream is complete.
155      */
156     static final int STATE_AWAITING_TRAILERS        = 4;
157 
158     /**
159      * State to indicate that the chunked stream is complete and
160      * no further bytes should be read from the underlying stream.
161      */
162     static final int STATE_DONE                     = 5;
163 
164     /**
165      * Indicates the current state.
166      */
167     private int state;
168 
169 
170     /**
171      * Check to make sure that this stream has not been closed.
172      */
173     private void ensureOpen() throws IOException {
174         if (closed) {
175             throw new IOException(&quot;stream is closed&quot;);
176         }
177     }
178 
179 
180     /**
181      * Ensures there is &lt;code&gt;size&lt;/code&gt; bytes available in
182      * &lt;code&gt;rawData&lt;/code&gt;. This requires that we either
183      * shift the bytes in use to the begining of the buffer
184      * or allocate a large buffer with sufficient space available.
185      */
186     private void ensureRawAvailable(int size) {
187         if (rawCount + size &gt; rawData.length) {
188             int used = rawCount - rawPos;
189             if (used + size &gt; rawData.length) {
190                 byte tmp[] = new byte[used + size];
191                 if (used &gt; 0) {
192                     System.arraycopy(rawData, rawPos, tmp, 0, used);
193                 }
194                 rawData = tmp;
195             } else {
196                 if (used &gt; 0) {
197                     System.arraycopy(rawData, rawPos, rawData, 0, used);
198                 }
199             }
200             rawCount = used;
201             rawPos = 0;
202         }
203     }
204 
205 
206     /**
207      * Close the underlying input stream by either returning it to the
208      * keep alive cache or closing the stream.
209      * &lt;p&gt;
210      * As a chunked stream is inheritly persistent (see HTTP 1.1 RFC) the
211      * underlying stream can be returned to the keep alive cache if the
212      * stream can be completely read without error.
213      */
214     private void closeUnderlying() throws IOException {
215         if (in == null) {
216             return;
217         }
218 
219         if (!error &amp;&amp; state == STATE_DONE) {
220             hc.finished();
221         } else {
222             if (!hurry()) {
223                 hc.closeServer();
224             }
225         }
226 
227         in = null;
228     }
229 
230     /**
231      * Attempt to read the remainder of a chunk directly into the
232      * caller&#39;s buffer.
233      * &lt;p&gt;
234      * Return the number of bytes read.
235      */
236     private int fastRead(byte[] b, int off, int len) throws IOException {
237 
238         // assert state == STATE_READING_CHUNKS;
239 
240         int remaining = chunkSize - chunkRead;
241         int cnt = (remaining &lt; len) ? remaining : len;
242         if (cnt &gt; 0) {
243             int nread;
244             try {
245                 nread = in.read(b, off, cnt);
246             } catch (IOException e) {
247                 error = true;
248                 throw e;
249             }
250             if (nread &gt; 0) {
251                 chunkRead += nread;
252                 if (chunkRead &gt;= chunkSize) {
253                     state = STATE_AWAITING_CHUNK_EOL;
254                 }
255                 return nread;
256             }
257             error = true;
258             throw new IOException(&quot;Premature EOF&quot;);
259         } else {
260             return 0;
261         }
262     }
263 
264     /**
265      * Process any outstanding bytes that have already been read into
266      * &lt;code&gt;rawData&lt;/code&gt;.
267      * &lt;p&gt;
268      * The parsing of the chunked stream is performed as a state machine with
269      * &lt;code&gt;state&lt;/code&gt; representing the current state of the processing.
270      * &lt;p&gt;
271      * Returns when either all the outstanding bytes in rawData have been
272      * processed or there is insufficient bytes available to continue
273      * processing. When the latter occurs &lt;code&gt;rawPos&lt;/code&gt; will not have
274      * been updated and thus the processing can be restarted once further
275      * bytes have been read into &lt;code&gt;rawData&lt;/code&gt;.
276      */
277     private void processRaw() throws IOException {
278         int pos;
279         int i;
280 
281         while (state != STATE_DONE) {
282 
283             switch (state) {
284 
285                 /**
286                  * We are awaiting a line with a chunk header
287                  */
288                 case STATE_AWAITING_CHUNK_HEADER:
289                     /*
290                      * Find \n to indicate end of chunk header. If not found when there is
291                      * insufficient bytes in the raw buffer to parse a chunk header.
292                      */
293                     pos = rawPos;
294                     while (pos &lt; rawCount) {
295                         if (rawData[pos] == &#39;\n&#39;) {
296                             break;
297                         }
298                         pos++;
299                         if ((pos - rawPos) &gt;= MAX_CHUNK_HEADER_SIZE) {
300                             error = true;
301                             throw new IOException(&quot;Chunk header too long&quot;);
302                         }
303                     }
304                     if (pos &gt;= rawCount) {
305                         return;
306                     }
307 
308                     /*
309                      * Extract the chunk size from the header (ignoring extensions).
310                      */
311                     String header = new String(rawData, rawPos, pos-rawPos+1,
312                             US_ASCII.INSTANCE);
313                     for (i=0; i &lt; header.length(); i++) {
314                         if (Character.digit(header.charAt(i), 16) == -1)
315                             break;
316                     }
317                     try {
318                         chunkSize = Integer.parseInt(header, 0, i, 16);
319                     } catch (NumberFormatException e) {
320                         error = true;
321                         throw new IOException(&quot;Bogus chunk size&quot;);
322                     }
323 
324                     /*
325                      * Chunk has been parsed so move rawPos to first byte of chunk
326                      * data.
327                      */
328                     rawPos = pos + 1;
329                     chunkRead = 0;
330 
331                     /*
332                      * A chunk size of 0 means EOF.
333                      */
334                     if (chunkSize &gt; 0) {
335                         state = STATE_READING_CHUNK;
336                     } else {
337                         state = STATE_AWAITING_TRAILERS;
338                     }
339                     break;
340 
341 
342                 /**
343                  * We are awaiting raw entity data (some may have already been
344                  * read). chunkSize is the size of the chunk; chunkRead is the
345                  * total read from the underlying stream to date.
346                  */
347                 case STATE_READING_CHUNK :
348                     /* no data available yet */
349                     if (rawPos &gt;= rawCount) {
350                         return;
351                     }
352 
353                     /*
354                      * Compute the number of bytes of chunk data available in the
355                      * raw buffer.
356                      */
357                     int copyLen = Math.min( chunkSize-chunkRead, rawCount-rawPos );
358 
359                     /*
360                      * Expand or compact chunkData if needed.
361                      */
362                     if (chunkData.length &lt; chunkCount + copyLen) {
363                         int cnt = chunkCount - chunkPos;
364                         if (chunkData.length &lt; cnt + copyLen) {
365                             byte tmp[] = new byte[cnt + copyLen];
366                             System.arraycopy(chunkData, chunkPos, tmp, 0, cnt);
367                             chunkData = tmp;
368                         } else {
369                             System.arraycopy(chunkData, chunkPos, chunkData, 0, cnt);
370                         }
371                         chunkPos = 0;
372                         chunkCount = cnt;
373                     }
374 
375                     /*
376                      * Copy the chunk data into chunkData so that it&#39;s available
377                      * to the read methods.
378                      */
379                     System.arraycopy(rawData, rawPos, chunkData, chunkCount, copyLen);
380                     rawPos += copyLen;
381                     chunkCount += copyLen;
382                     chunkRead += copyLen;
383 
384                     /*
385                      * If all the chunk has been copied into chunkData then the next
386                      * token should be CRLF.
387                      */
388                     if (chunkSize - chunkRead &lt;= 0) {
389                         state = STATE_AWAITING_CHUNK_EOL;
390                     } else {
391                         return;
392                     }
393                     break;
394 
395 
396                 /**
397                  * Awaiting CRLF after the chunk
398                  */
399                 case STATE_AWAITING_CHUNK_EOL:
400                     /* not available yet */
401                     if (rawPos + 1 &gt;= rawCount) {
402                         return;
403                     }
404 
405                     if (rawData[rawPos] != &#39;\r&#39;) {
406                         error = true;
407                         throw new IOException(&quot;missing CR&quot;);
408                     }
409                     if (rawData[rawPos+1] != &#39;\n&#39;) {
410                         error = true;
411                         throw new IOException(&quot;missing LF&quot;);
412                     }
413                     rawPos += 2;
414 
415                     /*
416                      * Move onto the next chunk
417                      */
418                     state = STATE_AWAITING_CHUNK_HEADER;
419                     break;
420 
421 
422                 /**
423                  * Last chunk has been read so not we&#39;re waiting for optional
424                  * trailers.
425                  */
426                 case STATE_AWAITING_TRAILERS:
427 
428                     /*
429                      * Do we have an entire line in the raw buffer?
430                      */
431                     pos = rawPos;
432                     while (pos &lt; rawCount) {
433                         if (rawData[pos] == &#39;\n&#39;) {
434                             break;
435                         }
436                         pos++;
437                     }
438                     if (pos &gt;= rawCount) {
439                         return;
440                     }
441 
442                     if (pos == rawPos) {
443                         error = true;
444                         throw new IOException(&quot;LF should be proceeded by CR&quot;);
445                     }
446                     if (rawData[pos-1] != &#39;\r&#39;) {
447                         error = true;
448                         throw new IOException(&quot;LF should be proceeded by CR&quot;);
449                     }
450 
451                     /*
452                      * Stream done so close underlying stream.
453                      */
454                     if (pos == (rawPos + 1)) {
455 
456                         state = STATE_DONE;
457                         closeUnderlying();
458 
459                         return;
460                     }
461 
462                     /*
463                      * Extract any tailers and append them to the message
464                      * headers.
465                      */
466                     String trailer = new String(rawData, rawPos, pos-rawPos,
467                             US_ASCII.INSTANCE);
468                     i = trailer.indexOf(&#39;:&#39;);
469                     if (i == -1) {
470                         throw new IOException(&quot;Malformed tailer - format should be key:value&quot;);
471                     }
472                     String key = (trailer.substring(0, i)).trim();
473                     String value = (trailer.substring(i+1, trailer.length())).trim();
474 
475                     responses.add(key, value);
476 
477                     /*
478                      * Move onto the next trailer.
479                      */
480                     rawPos = pos+1;
481                     break;
482 
483             } /* switch */
484         }
485     }
486 
487 
488     /**
489      * Reads any available bytes from the underlying stream into
490      * &lt;code&gt;rawData&lt;/code&gt; and returns the number of bytes of
491      * chunk data available in &lt;code&gt;chunkData&lt;/code&gt; that the
492      * application can read.
493      */
494     private int readAheadNonBlocking() throws IOException {
495 
496         /*
497          * If there&#39;s anything available on the underlying stream then we read
498          * it into the raw buffer and process it. Processing ensures that any
499          * available chunk data is made available in chunkData.
500          */
501         int avail = in.available();
502         if (avail &gt; 0) {
503 
504             /* ensure that there is space in rawData to read the available */
505             ensureRawAvailable(avail);
506 
507             int nread;
508             try {
509                 nread = in.read(rawData, rawCount, avail);
510             } catch (IOException e) {
511                 error = true;
512                 throw e;
513             }
514             if (nread &lt; 0) {
515                 error = true;   /* premature EOF ? */
516                 return -1;
517             }
518             rawCount += nread;
519 
520             /*
521              * Process the raw bytes that have been read.
522              */
523             processRaw();
524         }
525 
526         /*
527          * Return the number of chunked bytes available to read
528          */
529         return chunkCount - chunkPos;
530     }
531 
532     /**
533      * Reads from the underlying stream until there is chunk data
534      * available in &lt;code&gt;chunkData&lt;/code&gt; for the application to
535      * read.
536      */
537     private int readAheadBlocking() throws IOException {
538 
539         do {
540             /*
541              * All of chunked response has been read to return EOF.
542              */
543             if (state == STATE_DONE) {
544                 return -1;
545             }
546 
547             /*
548              * We must read into the raw buffer so make sure there is space
549              * available. We use a size of 32 to avoid too much chunk data
550              * being read into the raw buffer.
551              */
552             ensureRawAvailable(32);
553             int nread;
554             try {
555                 nread = in.read(rawData, rawCount, rawData.length-rawCount);
556             } catch (IOException e) {
557                 error = true;
558                 throw e;
559             }
560 
561             /**
562              * If we hit EOF it means there&#39;s a problem as we should never
563              * attempt to read once the last chunk and trailers have been
564              * received.
565              */
566             if (nread &lt; 0) {
567                 error = true;
568                 throw new IOException(&quot;Premature EOF&quot;);
569             }
570 
571             /**
572              * Process the bytes from the underlying stream
573              */
574             rawCount += nread;
575             processRaw();
576 
577         } while (chunkCount &lt;= 0);
578 
579         /*
580          * Return the number of chunked bytes available to read
581          */
582         return chunkCount - chunkPos;
583     }
584 
585     /**
586      * Read ahead in either blocking or non-blocking mode. This method
587      * is typically used when we run out of available bytes in
588      * &lt;code&gt;chunkData&lt;/code&gt; or we need to determine how many bytes
589      * are available on the input stream.
590      */
591     private int readAhead(boolean allowBlocking) throws IOException {
592 
593         /*
594          * Last chunk already received - return EOF
595          */
596         if (state == STATE_DONE) {
597             return -1;
598         }
599 
600         /*
601          * Reset position/count if data in chunkData is exhausted.
602          */
603         if (chunkPos &gt;= chunkCount) {
604             chunkCount = 0;
605             chunkPos = 0;
606         }
607 
608         /*
609          * Read ahead blocking or non-blocking
610          */
611         if (allowBlocking) {
612             return readAheadBlocking();
613         } else {
614             return readAheadNonBlocking();
615         }
616     }
617 
618     /**
619      * Creates a &lt;code&gt;ChunkedInputStream&lt;/code&gt; and saves its  arguments, for
620      * later use.
621      *
622      * @param   in   the underlying input stream.
623      * @param   hc   the HttpClient
624      * @param   responses   the MessageHeader that should be populated with optional
625      *                      trailers.
626      */
627     public ChunkedInputStream(InputStream in, HttpClient hc, MessageHeader responses) throws IOException {
628 
629         /* save arguments */
630         this.in = in;
631         this.responses = responses;
632         this.hc = hc;
633 
634         /*
635          * Set our initial state to indicate that we are first starting to
636          * look for a chunk header.
637          */
638         state = STATE_AWAITING_CHUNK_HEADER;
639     }
640 
641     /**
642      * See
643      * the general contract of the &lt;code&gt;read&lt;/code&gt;
644      * method of &lt;code&gt;InputStream&lt;/code&gt;.
645      *
646      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
647      *             stream is reached.
648      * @exception  IOException  if an I/O error occurs.
649      * @see        java.io.FilterInputStream#in
650      */
651     public synchronized int read() throws IOException {
652         ensureOpen();
653         if (chunkPos &gt;= chunkCount) {
654             if (readAhead(true) &lt;= 0) {
655                 return -1;
656             }
657         }
658         return chunkData[chunkPos++] &amp; 0xff;
659     }
660 
661 
662     /**
663      * Reads bytes from this stream into the specified byte array, starting at
664      * the given offset.
665      *
666      * @param      b     destination buffer.
667      * @param      off   offset at which to start storing bytes.
668      * @param      len   maximum number of bytes to read.
669      * @return     the number of bytes read, or &lt;code&gt;-1&lt;/code&gt; if the end of
670      *             the stream has been reached.
671      * @exception  IOException  if an I/O error occurs.
672      */
673     public synchronized int read(byte b[], int off, int len)
674         throws IOException
675     {
676         ensureOpen();
677         if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||
678             ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
679             throw new IndexOutOfBoundsException();
680         } else if (len == 0) {
681             return 0;
682         }
683 
684         int avail = chunkCount - chunkPos;
685         if (avail &lt;= 0) {
686             /*
687              * Optimization: if we&#39;re in the middle of the chunk read
688              * directly from the underlying stream into the caller&#39;s
689              * buffer
690              */
691             if (state == STATE_READING_CHUNK) {
692                 return fastRead( b, off, len );
693             }
694 
695             /*
696              * We&#39;re not in the middle of a chunk so we must read ahead
697              * until there is some chunk data available.
698              */
699             avail = readAhead(true);
700             if (avail &lt; 0) {
701                 return -1;      /* EOF */
702             }
703         }
704         int cnt = (avail &lt; len) ? avail : len;
705         System.arraycopy(chunkData, chunkPos, b, off, cnt);
706         chunkPos += cnt;
707 
708         return cnt;
709     }
710 
711     /**
712      * Returns the number of bytes that can be read from this input
713      * stream without blocking.
714      *
715      * @return     the number of bytes that can be read from this input
716      *             stream without blocking.
717      * @exception  IOException  if an I/O error occurs.
718      * @see        java.io.FilterInputStream#in
719      */
720     public synchronized int available() throws IOException {
721         ensureOpen();
722 
723         int avail = chunkCount - chunkPos;
724         if(avail &gt; 0) {
725             return avail;
726         }
727 
728         avail = readAhead(false);
729 
730         if (avail &lt; 0) {
731             return 0;
732         } else  {
733             return avail;
734         }
735     }
736 
737     /**
738      * Close the stream by either returning the connection to the
739      * keep alive cache or closing the underlying stream.
740      * &lt;p&gt;
741      * If the chunked response hasn&#39;t been completely read we
742      * try to &quot;hurry&quot; to the end of the response. If this is
743      * possible (without blocking) then the connection can be
744      * returned to the keep alive cache.
745      *
746      * @exception  IOException  if an I/O error occurs.
747      */
748     public synchronized void close() throws IOException {
749         if (closed) {
750             return;
751         }
752         closeUnderlying();
753         closed = true;
754     }
755 
756     /**
757      * Hurry the input stream by reading everything from the underlying
758      * stream. If the last chunk (and optional trailers) can be read without
759      * blocking then the stream is considered hurried.
760      * &lt;p&gt;
761      * Note that if an error has occurred or we can&#39;t get to last chunk
762      * without blocking then this stream can&#39;t be hurried and should be
763      * closed.
764      */
765     public synchronized boolean hurry() {
766         if (in == null || error) {
767             return false;
768         }
769 
770         try {
771             readAhead(false);
772         } catch (Exception e) {
773             return false;
774         }
775 
776         if (error) {
777             return false;
778         }
779 
780         return (state == STATE_DONE);
781     }
782 
783 }
    </pre>
  </body>
</html>
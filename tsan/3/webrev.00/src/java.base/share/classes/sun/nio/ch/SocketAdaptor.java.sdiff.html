<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/SocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocketChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/SocketAdaptor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.net.Socket;
 34 import java.net.SocketAddress;
 35 import java.net.SocketException;
<span class="line-removed"> 36 import java.net.SocketImpl;</span>
 37 import java.net.SocketOption;
<span class="line-removed"> 38 import java.net.SocketTimeoutException;</span>
 39 import java.net.StandardSocketOptions;
<span class="line-removed"> 40 import java.nio.ByteBuffer;</span>
<span class="line-removed"> 41 import java.nio.channels.Channels;</span>
<span class="line-removed"> 42 import java.nio.channels.ClosedChannelException;</span>
<span class="line-removed"> 43 import java.nio.channels.IllegalBlockingModeException;</span>
 44 import java.nio.channels.SocketChannel;
 45 import java.security.AccessController;

 46 import java.security.PrivilegedExceptionAction;
<span class="line-modified"> 47 import static java.util.concurrent.TimeUnit.*;</span>


 48 
 49 // Make a socket channel look like a socket.
 50 //
 51 // The methods in this class are defined in exactly the same order as in
 52 // java.net.Socket so as to simplify tracking future changes to that class.
 53 //
 54 
 55 class SocketAdaptor
 56     extends Socket
 57 {
 58     // The channel being adapted
 59     private final SocketChannelImpl sc;
 60 
 61     // Timeout &quot;option&quot; value for reads
 62     private volatile int timeout;
 63 
 64     private SocketAdaptor(SocketChannelImpl sc) throws SocketException {
<span class="line-modified"> 65         super((SocketImpl) null);</span>
 66         this.sc = sc;
 67     }
 68 
<span class="line-modified"> 69     public static Socket create(SocketChannelImpl sc) {</span>

 70         try {
<span class="line-modified"> 71             return new SocketAdaptor(sc);</span>
<span class="line-modified"> 72         } catch (SocketException e) {</span>
<span class="line-modified"> 73             throw new InternalError(&quot;Should not reach here&quot;);</span>
 74         }
 75     }
 76 
<span class="line-modified"> 77     public SocketChannel getChannel() {</span>
<span class="line-removed"> 78         return sc;</span>
<span class="line-removed"> 79     }</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81     // Override this method just to protect against changes in the superclass</span>
<span class="line-removed"> 82     //</span>
 83     public void connect(SocketAddress remote) throws IOException {
 84         connect(remote, 0);
 85     }
 86 

 87     public void connect(SocketAddress remote, int timeout) throws IOException {
 88         if (remote == null)
 89             throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
 90         if (timeout &lt; 0)
 91             throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
<span class="line-modified"> 92 </span>
<span class="line-modified"> 93         synchronized (sc.blockingLock()) {</span>
<span class="line-modified"> 94             if (!sc.isBlocking())</span>
<span class="line-modified"> 95                 throw new IllegalBlockingModeException();</span>
<span class="line-modified"> 96 </span>
<span class="line-modified"> 97             try {</span>
<span class="line-removed"> 98                 // no timeout</span>
<span class="line-removed"> 99                 if (timeout == 0) {</span>
<span class="line-removed">100                     sc.connect(remote);</span>
<span class="line-removed">101                     return;</span>
<span class="line-removed">102                 }</span>
<span class="line-removed">103 </span>
<span class="line-removed">104                 // timed connect</span>
<span class="line-removed">105                 sc.configureBlocking(false);</span>
<span class="line-removed">106                 try {</span>
<span class="line-removed">107                     if (sc.connect(remote))</span>
<span class="line-removed">108                         return;</span>
<span class="line-removed">109                 } finally {</span>
<span class="line-removed">110                     try {</span>
<span class="line-removed">111                         sc.configureBlocking(true);</span>
<span class="line-removed">112                     } catch (ClosedChannelException e) { }</span>
<span class="line-removed">113                 }</span>
<span class="line-removed">114 </span>
<span class="line-removed">115                 long timeoutNanos = NANOSECONDS.convert(timeout, MILLISECONDS);</span>
<span class="line-removed">116                 long to = timeout;</span>
<span class="line-removed">117                 for (;;) {</span>
<span class="line-removed">118                     long startTime = System.nanoTime();</span>
<span class="line-removed">119                     if (sc.pollConnected(to)) {</span>
<span class="line-removed">120                         boolean connected = sc.finishConnect();</span>
<span class="line-removed">121                         assert connected;</span>
<span class="line-removed">122                         break;</span>
<span class="line-removed">123                     }</span>
<span class="line-removed">124                     timeoutNanos -= System.nanoTime() - startTime;</span>
<span class="line-removed">125                     if (timeoutNanos &lt;= 0) {</span>
<span class="line-removed">126                         try {</span>
<span class="line-removed">127                             sc.close();</span>
<span class="line-removed">128                         } catch (IOException x) { }</span>
<span class="line-removed">129                         throw new SocketTimeoutException();</span>
<span class="line-removed">130                     }</span>
<span class="line-removed">131                     to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span>
<span class="line-removed">132                 }</span>
<span class="line-removed">133 </span>
<span class="line-removed">134             } catch (Exception x) {</span>
<span class="line-removed">135                 Net.translateException(x, true);</span>
136             }


137         }
<span class="line-removed">138 </span>
139     }
140 

141     public void bind(SocketAddress local) throws IOException {
142         try {
143             sc.bind(local);
144         } catch (Exception x) {
145             Net.translateException(x);
146         }
147     }
148 

149     public InetAddress getInetAddress() {
150         InetSocketAddress remote = sc.remoteAddress();
151         if (remote == null) {
152             return null;
153         } else {
154             return remote.getAddress();
155         }
156     }
157 

158     public InetAddress getLocalAddress() {
159         if (sc.isOpen()) {
160             InetSocketAddress local = sc.localAddress();
161             if (local != null) {
162                 return Net.getRevealedLocalAddress(local).getAddress();
163             }
164         }
165         return new InetSocketAddress(0).getAddress();
166     }
167 

168     public int getPort() {
169         InetSocketAddress remote = sc.remoteAddress();
170         if (remote == null) {
171             return 0;
172         } else {
173             return remote.getPort();
174         }
175     }
176 

177     public int getLocalPort() {
178         InetSocketAddress local = sc.localAddress();
179         if (local == null) {
180             return -1;
181         } else {
182             return local.getPort();
183         }
184     }
185 
<span class="line-modified">186     private class SocketInputStream</span>
<span class="line-modified">187         extends ChannelInputStream</span>
<span class="line-modified">188     {</span>
<span class="line-modified">189         private SocketInputStream() {</span>
<span class="line-removed">190             super(sc);</span>
<span class="line-removed">191         }</span>
192 
<span class="line-modified">193         protected int read(ByteBuffer bb)</span>
<span class="line-modified">194             throws IOException</span>
<span class="line-modified">195         {</span>
<span class="line-modified">196             synchronized (sc.blockingLock()) {</span>
<span class="line-modified">197                 if (!sc.isBlocking())</span>
<span class="line-modified">198                     throw new IllegalBlockingModeException();</span>
<span class="line-modified">199 </span>
<span class="line-removed">200                 // no timeout</span>
<span class="line-removed">201                 long to = SocketAdaptor.this.timeout;</span>
<span class="line-removed">202                 if (to == 0)</span>
<span class="line-removed">203                     return sc.read(bb);</span>
<span class="line-removed">204 </span>
<span class="line-removed">205                 // timed read</span>
<span class="line-removed">206                 long timeoutNanos = NANOSECONDS.convert(to, MILLISECONDS);</span>
<span class="line-removed">207                 for (;;) {</span>
<span class="line-removed">208                     long startTime = System.nanoTime();</span>
<span class="line-removed">209                     if (sc.pollRead(to)) {</span>
<span class="line-removed">210                         return sc.read(bb);</span>
<span class="line-removed">211                     }</span>
<span class="line-removed">212                     timeoutNanos -= System.nanoTime() - startTime;</span>
<span class="line-removed">213                     if (timeoutNanos &lt;= 0)</span>
<span class="line-removed">214                         throw new SocketTimeoutException();</span>
<span class="line-removed">215                     to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span>
<span class="line-removed">216                 }</span>
<span class="line-removed">217             }</span>
218         }
219     }
220 
<span class="line-modified">221     private InputStream socketInputStream = null;</span>



222 

223     public InputStream getInputStream() throws IOException {
224         if (!sc.isOpen())
225             throw new SocketException(&quot;Socket is closed&quot;);
226         if (!sc.isConnected())
227             throw new SocketException(&quot;Socket is not connected&quot;);
228         if (!sc.isInputOpen())
229             throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">230         if (socketInputStream == null) {</span>
<span class="line-modified">231             try {</span>
<span class="line-modified">232                 socketInputStream = AccessController.doPrivileged(</span>
<span class="line-modified">233                     new PrivilegedExceptionAction&lt;InputStream&gt;() {</span>
<span class="line-modified">234                         public InputStream run() throws IOException {</span>
<span class="line-modified">235                             return new SocketInputStream();</span>
<span class="line-removed">236                         }</span>
<span class="line-removed">237                     });</span>
<span class="line-removed">238             } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed">239                 throw (IOException)e.getException();</span>
240             }
<span class="line-modified">241         }</span>
<span class="line-modified">242         return socketInputStream;</span>

















243     }
244 

245     public OutputStream getOutputStream() throws IOException {
246         if (!sc.isOpen())
247             throw new SocketException(&quot;Socket is closed&quot;);
248         if (!sc.isConnected())
249             throw new SocketException(&quot;Socket is not connected&quot;);
250         if (!sc.isOutputOpen())
251             throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">252         OutputStream os = null;</span>
<span class="line-modified">253         try {</span>
<span class="line-modified">254             os = AccessController.doPrivileged(</span>
<span class="line-modified">255                 new PrivilegedExceptionAction&lt;OutputStream&gt;() {</span>
<span class="line-modified">256                     public OutputStream run() throws IOException {</span>
<span class="line-modified">257                         return Channels.newOutputStream(sc);</span>
<span class="line-modified">258                     }</span>
<span class="line-modified">259                 });</span>
<span class="line-modified">260         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified">261             throw (IOException)e.getException();</span>
<span class="line-modified">262         }</span>
<span class="line-modified">263         return os;</span>



264     }
265 
266     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
267         throws SocketException
268     {
269         try {
270             sc.setOption(name, value);
271         } catch (IOException x) {
272             Net.translateToSocketException(x);
273         }
274     }
275 
276     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
277         throws SocketException
278     {
279         try {
280             sc.setOption(name, value);
281         } catch (IOException x) {
282             Net.translateToSocketException(x);
283         }
284     }
285 
286     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
287         try {
288             return sc.getOption(name).booleanValue();
289         } catch (IOException x) {
290             Net.translateToSocketException(x);
291             return false;       // keep compiler happy
292         }
293     }
294 
295     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
296         try {
297             return sc.getOption(name).intValue();
298         } catch (IOException x) {
299             Net.translateToSocketException(x);
300             return -1;          // keep compiler happy
301         }
302     }
303 

304     public void setTcpNoDelay(boolean on) throws SocketException {
305         setBooleanOption(StandardSocketOptions.TCP_NODELAY, on);
306     }
307 

308     public boolean getTcpNoDelay() throws SocketException {
309         return getBooleanOption(StandardSocketOptions.TCP_NODELAY);
310     }
311 

312     public void setSoLinger(boolean on, int linger) throws SocketException {
313         if (!on)
314             linger = -1;
315         setIntOption(StandardSocketOptions.SO_LINGER, linger);
316     }
317 

318     public int getSoLinger() throws SocketException {
319         return getIntOption(StandardSocketOptions.SO_LINGER);
320     }
321 

322     public void sendUrgentData(int data) throws IOException {
323         int n = sc.sendOutOfBandData((byte) data);
324         if (n == 0)
325             throw new IOException(&quot;Socket buffer full&quot;);
326     }
327 

328     public void setOOBInline(boolean on) throws SocketException {
329         setBooleanOption(ExtendedSocketOption.SO_OOBINLINE, on);
330     }
331 

332     public boolean getOOBInline() throws SocketException {
333         return getBooleanOption(ExtendedSocketOption.SO_OOBINLINE);
334     }
335 

336     public void setSoTimeout(int timeout) throws SocketException {


337         if (timeout &lt; 0)
<span class="line-modified">338             throw new IllegalArgumentException(&quot;timeout can&#39;t be negative&quot;);</span>
339         this.timeout = timeout;
340     }
341 

342     public int getSoTimeout() throws SocketException {


343         return timeout;
344     }
345 

346     public void setSendBufferSize(int size) throws SocketException {
347         // size 0 valid for SocketChannel, invalid for Socket
348         if (size &lt;= 0)
349             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
350         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
351     }
352 

353     public int getSendBufferSize() throws SocketException {
354         return getIntOption(StandardSocketOptions.SO_SNDBUF);
355     }
356 

357     public void setReceiveBufferSize(int size) throws SocketException {
358         // size 0 valid for SocketChannel, invalid for Socket
359         if (size &lt;= 0)
360             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
361         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
362     }
363 

364     public int getReceiveBufferSize() throws SocketException {
365         return getIntOption(StandardSocketOptions.SO_RCVBUF);
366     }
367 

368     public void setKeepAlive(boolean on) throws SocketException {
369         setBooleanOption(StandardSocketOptions.SO_KEEPALIVE, on);
370     }
371 

372     public boolean getKeepAlive() throws SocketException {
373         return getBooleanOption(StandardSocketOptions.SO_KEEPALIVE);
374     }
375 

376     public void setTrafficClass(int tc) throws SocketException {
377         setIntOption(StandardSocketOptions.IP_TOS, tc);
378     }
379 

380     public int getTrafficClass() throws SocketException {
381         return getIntOption(StandardSocketOptions.IP_TOS);
382     }
383 

384     public void setReuseAddress(boolean on) throws SocketException {
385         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
386     }
387 

388     public boolean getReuseAddress() throws SocketException {
389         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
390     }
391 

392     public void close() throws IOException {
393         sc.close();
394     }
395 

396     public void shutdownInput() throws IOException {
397         try {
398             sc.shutdownInput();
399         } catch (Exception x) {
400             Net.translateException(x);
401         }
402     }
403 

404     public void shutdownOutput() throws IOException {
405         try {
406             sc.shutdownOutput();
407         } catch (Exception x) {
408             Net.translateException(x);
409         }
410     }
411 

412     public String toString() {
413         if (sc.isConnected())
414             return &quot;Socket[addr=&quot; + getInetAddress() +
415                 &quot;,port=&quot; + getPort() +
416                 &quot;,localport=&quot; + getLocalPort() + &quot;]&quot;;
417         return &quot;Socket[unconnected]&quot;;
418     }
419 

420     public boolean isConnected() {
421         return sc.isConnected();
422     }
423 

424     public boolean isBound() {
425         return sc.localAddress() != null;
426     }
427 

428     public boolean isClosed() {
429         return !sc.isOpen();
430     }
431 

432     public boolean isInputShutdown() {
433         return !sc.isInputOpen();
434     }
435 

436     public boolean isOutputShutdown() {
437         return !sc.isOutputOpen();
438     }
















439 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.net.Socket;
 34 import java.net.SocketAddress;
 35 import java.net.SocketException;

 36 import java.net.SocketOption;

 37 import java.net.StandardSocketOptions;




 38 import java.nio.channels.SocketChannel;
 39 import java.security.AccessController;
<span class="line-added"> 40 import java.security.PrivilegedActionException;</span>
 41 import java.security.PrivilegedExceptionAction;
<span class="line-modified"> 42 import java.util.Set;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 import static java.util.concurrent.TimeUnit.MILLISECONDS;</span>
 45 
 46 // Make a socket channel look like a socket.
 47 //
 48 // The methods in this class are defined in exactly the same order as in
 49 // java.net.Socket so as to simplify tracking future changes to that class.
 50 //
 51 
 52 class SocketAdaptor
 53     extends Socket
 54 {
 55     // The channel being adapted
 56     private final SocketChannelImpl sc;
 57 
 58     // Timeout &quot;option&quot; value for reads
 59     private volatile int timeout;
 60 
 61     private SocketAdaptor(SocketChannelImpl sc) throws SocketException {
<span class="line-modified"> 62         super(DummySocketImpl.create());</span>
 63         this.sc = sc;
 64     }
 65 
<span class="line-modified"> 66     static Socket create(SocketChannelImpl sc) {</span>
<span class="line-added"> 67         PrivilegedExceptionAction&lt;Socket&gt; pa = () -&gt; new SocketAdaptor(sc);</span>
 68         try {
<span class="line-modified"> 69             return AccessController.doPrivileged(pa);</span>
<span class="line-modified"> 70         } catch (PrivilegedActionException pae) {</span>
<span class="line-modified"> 71             throw new InternalError(&quot;Should not reach here&quot;, pae);</span>
 72         }
 73     }
 74 
<span class="line-modified"> 75     @Override</span>





 76     public void connect(SocketAddress remote) throws IOException {
 77         connect(remote, 0);
 78     }
 79 
<span class="line-added"> 80     @Override</span>
 81     public void connect(SocketAddress remote, int timeout) throws IOException {
 82         if (remote == null)
 83             throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
 84         if (timeout &lt; 0)
 85             throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
<span class="line-modified"> 86         try {</span>
<span class="line-modified"> 87             if (timeout &gt; 0) {</span>
<span class="line-modified"> 88                 long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-modified"> 89                 sc.blockingConnect(remote, nanos);</span>
<span class="line-modified"> 90             } else {</span>
<span class="line-modified"> 91                 sc.blockingConnect(remote, Long.MAX_VALUE);</span>






































 92             }
<span class="line-added"> 93         } catch (Exception e) {</span>
<span class="line-added"> 94             Net.translateException(e, true);</span>
 95         }

 96     }
 97 
<span class="line-added"> 98     @Override</span>
 99     public void bind(SocketAddress local) throws IOException {
100         try {
101             sc.bind(local);
102         } catch (Exception x) {
103             Net.translateException(x);
104         }
105     }
106 
<span class="line-added">107     @Override</span>
108     public InetAddress getInetAddress() {
109         InetSocketAddress remote = sc.remoteAddress();
110         if (remote == null) {
111             return null;
112         } else {
113             return remote.getAddress();
114         }
115     }
116 
<span class="line-added">117     @Override</span>
118     public InetAddress getLocalAddress() {
119         if (sc.isOpen()) {
120             InetSocketAddress local = sc.localAddress();
121             if (local != null) {
122                 return Net.getRevealedLocalAddress(local).getAddress();
123             }
124         }
125         return new InetSocketAddress(0).getAddress();
126     }
127 
<span class="line-added">128     @Override</span>
129     public int getPort() {
130         InetSocketAddress remote = sc.remoteAddress();
131         if (remote == null) {
132             return 0;
133         } else {
134             return remote.getPort();
135         }
136     }
137 
<span class="line-added">138     @Override</span>
139     public int getLocalPort() {
140         InetSocketAddress local = sc.localAddress();
141         if (local == null) {
142             return -1;
143         } else {
144             return local.getPort();
145         }
146     }
147 
<span class="line-modified">148     @Override</span>
<span class="line-modified">149     public SocketAddress getRemoteSocketAddress() {</span>
<span class="line-modified">150         return sc.remoteAddress();</span>
<span class="line-modified">151     }</span>


152 
<span class="line-modified">153     @Override</span>
<span class="line-modified">154     public SocketAddress getLocalSocketAddress() {</span>
<span class="line-modified">155         InetSocketAddress local = sc.localAddress();</span>
<span class="line-modified">156         if (local != null) {</span>
<span class="line-modified">157             return Net.getRevealedLocalAddress(local);</span>
<span class="line-modified">158         } else {</span>
<span class="line-modified">159             return null;</span>


















160         }
161     }
162 
<span class="line-modified">163     @Override</span>
<span class="line-added">164     public SocketChannel getChannel() {</span>
<span class="line-added">165         return sc;</span>
<span class="line-added">166     }</span>
167 
<span class="line-added">168     @Override</span>
169     public InputStream getInputStream() throws IOException {
170         if (!sc.isOpen())
171             throw new SocketException(&quot;Socket is closed&quot;);
172         if (!sc.isConnected())
173             throw new SocketException(&quot;Socket is not connected&quot;);
174         if (!sc.isInputOpen())
175             throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">176         return new InputStream() {</span>
<span class="line-modified">177             @Override</span>
<span class="line-modified">178             public int read() throws IOException {</span>
<span class="line-modified">179                 byte[] a = new byte[1];</span>
<span class="line-modified">180                 int n = read(a, 0, 1);</span>
<span class="line-modified">181                 return (n &gt; 0) ? (a[0] &amp; 0xff) : -1;</span>




182             }
<span class="line-modified">183             @Override</span>
<span class="line-modified">184             public int read(byte[] b, int off, int len) throws IOException {</span>
<span class="line-added">185                 int timeout = SocketAdaptor.this.timeout;</span>
<span class="line-added">186                 if (timeout &gt; 0) {</span>
<span class="line-added">187                     long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-added">188                     return sc.blockingRead(b, off, len, nanos);</span>
<span class="line-added">189                 } else {</span>
<span class="line-added">190                     return sc.blockingRead(b, off, len, 0);</span>
<span class="line-added">191                 }</span>
<span class="line-added">192             }</span>
<span class="line-added">193             @Override</span>
<span class="line-added">194             public int available() throws IOException {</span>
<span class="line-added">195                 return sc.available();</span>
<span class="line-added">196             }</span>
<span class="line-added">197             @Override</span>
<span class="line-added">198             public void close() throws IOException {</span>
<span class="line-added">199                 sc.close();</span>
<span class="line-added">200             }</span>
<span class="line-added">201         };</span>
202     }
203 
<span class="line-added">204     @Override</span>
205     public OutputStream getOutputStream() throws IOException {
206         if (!sc.isOpen())
207             throw new SocketException(&quot;Socket is closed&quot;);
208         if (!sc.isConnected())
209             throw new SocketException(&quot;Socket is not connected&quot;);
210         if (!sc.isOutputOpen())
211             throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">212         return new OutputStream() {</span>
<span class="line-modified">213             @Override</span>
<span class="line-modified">214             public void write(int b) throws IOException {</span>
<span class="line-modified">215                 byte[] a = new byte[]{(byte) b};</span>
<span class="line-modified">216                 write(a, 0, 1);</span>
<span class="line-modified">217             }</span>
<span class="line-modified">218             @Override</span>
<span class="line-modified">219             public void write(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">220                 sc.blockingWriteFully(b, off, len);</span>
<span class="line-modified">221             }</span>
<span class="line-modified">222             @Override</span>
<span class="line-modified">223             public void close() throws IOException {</span>
<span class="line-added">224                 sc.close();</span>
<span class="line-added">225             }</span>
<span class="line-added">226         };</span>
227     }
228 
229     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
230         throws SocketException
231     {
232         try {
233             sc.setOption(name, value);
234         } catch (IOException x) {
235             Net.translateToSocketException(x);
236         }
237     }
238 
239     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
240         throws SocketException
241     {
242         try {
243             sc.setOption(name, value);
244         } catch (IOException x) {
245             Net.translateToSocketException(x);
246         }
247     }
248 
249     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
250         try {
251             return sc.getOption(name).booleanValue();
252         } catch (IOException x) {
253             Net.translateToSocketException(x);
254             return false;       // keep compiler happy
255         }
256     }
257 
258     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
259         try {
260             return sc.getOption(name).intValue();
261         } catch (IOException x) {
262             Net.translateToSocketException(x);
263             return -1;          // keep compiler happy
264         }
265     }
266 
<span class="line-added">267     @Override</span>
268     public void setTcpNoDelay(boolean on) throws SocketException {
269         setBooleanOption(StandardSocketOptions.TCP_NODELAY, on);
270     }
271 
<span class="line-added">272     @Override</span>
273     public boolean getTcpNoDelay() throws SocketException {
274         return getBooleanOption(StandardSocketOptions.TCP_NODELAY);
275     }
276 
<span class="line-added">277     @Override</span>
278     public void setSoLinger(boolean on, int linger) throws SocketException {
279         if (!on)
280             linger = -1;
281         setIntOption(StandardSocketOptions.SO_LINGER, linger);
282     }
283 
<span class="line-added">284     @Override</span>
285     public int getSoLinger() throws SocketException {
286         return getIntOption(StandardSocketOptions.SO_LINGER);
287     }
288 
<span class="line-added">289     @Override</span>
290     public void sendUrgentData(int data) throws IOException {
291         int n = sc.sendOutOfBandData((byte) data);
292         if (n == 0)
293             throw new IOException(&quot;Socket buffer full&quot;);
294     }
295 
<span class="line-added">296     @Override</span>
297     public void setOOBInline(boolean on) throws SocketException {
298         setBooleanOption(ExtendedSocketOption.SO_OOBINLINE, on);
299     }
300 
<span class="line-added">301     @Override</span>
302     public boolean getOOBInline() throws SocketException {
303         return getBooleanOption(ExtendedSocketOption.SO_OOBINLINE);
304     }
305 
<span class="line-added">306     @Override</span>
307     public void setSoTimeout(int timeout) throws SocketException {
<span class="line-added">308         if (!sc.isOpen())</span>
<span class="line-added">309             throw new SocketException(&quot;Socket is closed&quot;);</span>
310         if (timeout &lt; 0)
<span class="line-modified">311             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
312         this.timeout = timeout;
313     }
314 
<span class="line-added">315     @Override</span>
316     public int getSoTimeout() throws SocketException {
<span class="line-added">317         if (!sc.isOpen())</span>
<span class="line-added">318             throw new SocketException(&quot;Socket is closed&quot;);</span>
319         return timeout;
320     }
321 
<span class="line-added">322     @Override</span>
323     public void setSendBufferSize(int size) throws SocketException {
324         // size 0 valid for SocketChannel, invalid for Socket
325         if (size &lt;= 0)
326             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
327         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
328     }
329 
<span class="line-added">330     @Override</span>
331     public int getSendBufferSize() throws SocketException {
332         return getIntOption(StandardSocketOptions.SO_SNDBUF);
333     }
334 
<span class="line-added">335     @Override</span>
336     public void setReceiveBufferSize(int size) throws SocketException {
337         // size 0 valid for SocketChannel, invalid for Socket
338         if (size &lt;= 0)
339             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
340         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
341     }
342 
<span class="line-added">343     @Override</span>
344     public int getReceiveBufferSize() throws SocketException {
345         return getIntOption(StandardSocketOptions.SO_RCVBUF);
346     }
347 
<span class="line-added">348     @Override</span>
349     public void setKeepAlive(boolean on) throws SocketException {
350         setBooleanOption(StandardSocketOptions.SO_KEEPALIVE, on);
351     }
352 
<span class="line-added">353     @Override</span>
354     public boolean getKeepAlive() throws SocketException {
355         return getBooleanOption(StandardSocketOptions.SO_KEEPALIVE);
356     }
357 
<span class="line-added">358     @Override</span>
359     public void setTrafficClass(int tc) throws SocketException {
360         setIntOption(StandardSocketOptions.IP_TOS, tc);
361     }
362 
<span class="line-added">363     @Override</span>
364     public int getTrafficClass() throws SocketException {
365         return getIntOption(StandardSocketOptions.IP_TOS);
366     }
367 
<span class="line-added">368     @Override</span>
369     public void setReuseAddress(boolean on) throws SocketException {
370         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
371     }
372 
<span class="line-added">373     @Override</span>
374     public boolean getReuseAddress() throws SocketException {
375         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
376     }
377 
<span class="line-added">378     @Override</span>
379     public void close() throws IOException {
380         sc.close();
381     }
382 
<span class="line-added">383     @Override</span>
384     public void shutdownInput() throws IOException {
385         try {
386             sc.shutdownInput();
387         } catch (Exception x) {
388             Net.translateException(x);
389         }
390     }
391 
<span class="line-added">392     @Override</span>
393     public void shutdownOutput() throws IOException {
394         try {
395             sc.shutdownOutput();
396         } catch (Exception x) {
397             Net.translateException(x);
398         }
399     }
400 
<span class="line-added">401     @Override</span>
402     public String toString() {
403         if (sc.isConnected())
404             return &quot;Socket[addr=&quot; + getInetAddress() +
405                 &quot;,port=&quot; + getPort() +
406                 &quot;,localport=&quot; + getLocalPort() + &quot;]&quot;;
407         return &quot;Socket[unconnected]&quot;;
408     }
409 
<span class="line-added">410     @Override</span>
411     public boolean isConnected() {
412         return sc.isConnected();
413     }
414 
<span class="line-added">415     @Override</span>
416     public boolean isBound() {
417         return sc.localAddress() != null;
418     }
419 
<span class="line-added">420     @Override</span>
421     public boolean isClosed() {
422         return !sc.isOpen();
423     }
424 
<span class="line-added">425     @Override</span>
426     public boolean isInputShutdown() {
427         return !sc.isInputOpen();
428     }
429 
<span class="line-added">430     @Override</span>
431     public boolean isOutputShutdown() {
432         return !sc.isOutputOpen();
433     }
<span class="line-added">434 </span>
<span class="line-added">435     @Override</span>
<span class="line-added">436     public &lt;T&gt; Socket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">437         sc.setOption(name, value);</span>
<span class="line-added">438         return this;</span>
<span class="line-added">439     }</span>
<span class="line-added">440 </span>
<span class="line-added">441     @Override</span>
<span class="line-added">442     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">443         return sc.getOption(name);</span>
<span class="line-added">444     }</span>
<span class="line-added">445 </span>
<span class="line-added">446     @Override</span>
<span class="line-added">447     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">448         return sc.supportedOptions();</span>
<span class="line-added">449     }</span>
450 }
</pre>
</td>
</tr>
</table>
<center><a href="ServerSocketChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
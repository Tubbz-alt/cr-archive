<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DTLSOutputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<span class="line-removed"> 30 import java.security.AlgorithmConstraints;</span>
<span class="line-removed"> 31 import java.security.CryptoPrimitive;</span>
 32 import java.security.GeneralSecurityException;
<span class="line-removed"> 33 import java.security.KeyFactory;</span>
<span class="line-removed"> 34 import java.security.PrivateKey;</span>
 35 import java.security.PublicKey;
<span class="line-removed"> 36 import java.security.interfaces.ECPrivateKey;</span>
 37 import java.security.interfaces.ECPublicKey;


 38 import java.security.spec.ECParameterSpec;
<span class="line-modified"> 39 import java.security.spec.ECPoint;</span>
<span class="line-removed"> 40 import java.security.spec.ECPublicKeySpec;</span>
 41 import java.text.MessageFormat;
<span class="line-removed"> 42 import java.util.EnumSet;</span>
 43 import java.util.Locale;
 44 import javax.crypto.SecretKey;
<span class="line-removed"> 45 import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-removed"> 46 import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;</span>
<span class="line-removed"> 47 import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;</span>
 48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-removed"> 49 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
 50 import sun.security.ssl.X509Authentication.X509Credentials;
 51 import sun.security.ssl.X509Authentication.X509Possession;
<span class="line-removed"> 52 import sun.security.util.ECUtil;</span>
 53 import sun.security.util.HexDumpEncoder;
 54 
 55 /**
 56  * Pack of the &quot;ClientKeyExchange&quot; handshake message.





 57  */
 58 final class ECDHClientKeyExchange {
 59     static final SSLConsumer ecdhHandshakeConsumer =
 60             new ECDHClientKeyExchangeConsumer();
 61     static final HandshakeProducer ecdhHandshakeProducer =
 62             new ECDHClientKeyExchangeProducer();
 63 
 64     static final SSLConsumer ecdheHandshakeConsumer =
 65             new ECDHEClientKeyExchangeConsumer();
 66     static final HandshakeProducer ecdheHandshakeProducer =
 67             new ECDHEClientKeyExchangeProducer();
 68 
 69     /**
<span class="line-modified"> 70      * The ECDH/ECDHE ClientKeyExchange handshake message.</span>
 71      */
 72     private static final
 73             class ECDHClientKeyExchangeMessage extends HandshakeMessage {
 74         private final byte[] encodedPoint;
 75 
 76         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
<span class="line-modified"> 77                 ECPublicKey publicKey) {</span>
 78             super(handshakeContext);
 79 
<span class="line-modified"> 80             ECPoint point = publicKey.getW();</span>
<span class="line-removed"> 81             ECParameterSpec params = publicKey.getParams();</span>
<span class="line-removed"> 82             encodedPoint = ECUtil.encodePoint(point, params.getCurve());</span>
 83         }
 84 
 85         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
 86                 ByteBuffer m) throws IOException {
 87             super(handshakeContext);
 88             if (m.remaining() != 0) {       // explicit PublicValueEncoding
 89                 this.encodedPoint = Record.getBytes8(m);
 90             } else {
 91                 this.encodedPoint = new byte[0];
 92             }
 93         }
 94 
<span class="line-removed"> 95         // Check constraints of the specified EC public key.</span>
<span class="line-removed"> 96         static void checkConstraints(AlgorithmConstraints constraints,</span>
<span class="line-removed"> 97                 ECPublicKey publicKey,</span>
<span class="line-removed"> 98                 byte[] encodedPoint) throws SSLHandshakeException {</span>
<span class="line-removed"> 99 </span>
<span class="line-removed">100             try {</span>
<span class="line-removed">101                 ECParameterSpec params = publicKey.getParams();</span>
<span class="line-removed">102                 ECPoint point =</span>
<span class="line-removed">103                         ECUtil.decodePoint(encodedPoint, params.getCurve());</span>
<span class="line-removed">104                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-removed">105 </span>
<span class="line-removed">106                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-removed">107                 ECPublicKey peerPublicKey =</span>
<span class="line-removed">108                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-removed">109 </span>
<span class="line-removed">110                 // check constraints of ECPublicKey</span>
<span class="line-removed">111                 if (!constraints.permits(</span>
<span class="line-removed">112                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">113                         peerPublicKey)) {</span>
<span class="line-removed">114                     throw new SSLHandshakeException(</span>
<span class="line-removed">115                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">116                 }</span>
<span class="line-removed">117             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">118                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">119                         &quot;Could not generate ECPublicKey&quot;).initCause(e);</span>
<span class="line-removed">120             }</span>
<span class="line-removed">121         }</span>
<span class="line-removed">122 </span>
123         @Override
124         public SSLHandshake handshakeType() {
125             return SSLHandshake.CLIENT_KEY_EXCHANGE;
126         }
127 
128         @Override
129         public int messageLength() {
130             if (encodedPoint == null || encodedPoint.length == 0) {
131                 return 0;
132             } else {
133                 return 1 + encodedPoint.length;
134             }
135         }
136 
137         @Override
138         public void send(HandshakeOutStream hos) throws IOException {
139             if (encodedPoint != null &amp;&amp; encodedPoint.length != 0) {
140                 hos.putBytes8(encodedPoint);
141             }
142         }
</pre>
<hr />
<pre>
179         @Override
180         public byte[] produce(ConnectionContext context,
181                 HandshakeMessage message) throws IOException {
182             // The producing happens in client side only.
183             ClientHandshakeContext chc = (ClientHandshakeContext)context;
184 
185             X509Credentials x509Credentials = null;
186             for (SSLCredentials credential : chc.handshakeCredentials) {
187                 if (credential instanceof X509Credentials) {
188                     x509Credentials = (X509Credentials)credential;
189                     break;
190                 }
191             }
192 
193             if (x509Credentials == null) {
194                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
195                     &quot;No server certificate for ECDH client key exchange&quot;);
196             }
197 
198             PublicKey publicKey = x509Credentials.popPublicKey;
<span class="line-modified">199             if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>
















200                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">201                     &quot;Not EC server certificate for ECDH client key exchange&quot;);</span>

202             }
203 
<span class="line-removed">204             ECParameterSpec params = ((ECPublicKey)publicKey).getParams();</span>
<span class="line-removed">205             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
206             if (namedGroup == null) {
207                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">208                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);</span>

209             }
210 
<span class="line-modified">211             ECDHEPossession ecdhePossession = new ECDHEPossession(</span>
<span class="line-modified">212                     namedGroup, chc.sslContext.getSecureRandom());</span>
<span class="line-modified">213             chc.handshakePossessions.add(ecdhePossession);</span>

214             ECDHClientKeyExchangeMessage cke =
215                     new ECDHClientKeyExchangeMessage(
<span class="line-modified">216                             chc, ecdhePossession.publicKey);</span>
217             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
218                 SSLLogger.fine(
219                     &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
220             }
221 
222             // Output the handshake message.
223             cke.write(chc.handshakeOutput);
224             chc.handshakeOutput.flush();
225 
226             // update the states
227             SSLKeyExchange ke = SSLKeyExchange.valueOf(
228                     chc.negotiatedCipherSuite.keyExchange,
229                     chc.negotiatedProtocol);
230             if (ke == null) {
231                 // unlikely
232                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
233                         &quot;Not supported key exchange type&quot;);
234             } else {
235                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
236                 SecretKey masterSecret =
</pre>
<hr />
<pre>
268         @Override
269         public void consume(ConnectionContext context,
270                 ByteBuffer message) throws IOException {
271             // The consuming happens in server side only.
272             ServerHandshakeContext shc = (ServerHandshakeContext)context;
273 
274             X509Possession x509Possession = null;
275             for (SSLPossession possession : shc.handshakePossessions) {
276                 if (possession instanceof X509Possession) {
277                     x509Possession = (X509Possession)possession;
278                     break;
279                 }
280             }
281 
282             if (x509Possession == null) {
283                 // unlikely, have been checked during cipher suite negotiation.
284                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
285                     &quot;No expected EC server cert for ECDH client key exchange&quot;);
286             }
287 
<span class="line-modified">288             PrivateKey privateKey = x509Possession.popPrivateKey;</span>
<span class="line-modified">289             if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>

















290                 // unlikely, have been checked during cipher suite negotiation.
291                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">292                     &quot;Not EC server cert for ECDH client key exchange&quot;);</span>
293             }
294 
<span class="line-modified">295             ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();</span>
<span class="line-removed">296             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
297             if (namedGroup == null) {
<span class="line-removed">298                 // unlikely, have been checked during cipher suite negotiation.</span>
299                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">300                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);</span>

301             }
302 
303             SSLKeyExchange ke = SSLKeyExchange.valueOf(
304                     shc.negotiatedCipherSuite.keyExchange,
305                     shc.negotiatedProtocol);
306             if (ke == null) {
307                 // unlikely
308                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
309                         &quot;Not supported key exchange type&quot;);
310             }
311 
<span class="line-modified">312             // parse the handshake message</span>
313             ECDHClientKeyExchangeMessage cke =
314                     new ECDHClientKeyExchangeMessage(shc, message);
315             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
316                 SSLLogger.fine(
317                     &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
318             }
319 
320             // create the credentials
321             try {
<span class="line-modified">322                 ECPoint point =</span>
<span class="line-modified">323                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());</span>
<span class="line-modified">324                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-modified">325 </span>
<span class="line-modified">326                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">327                 ECPublicKey peerPublicKey =</span>
<span class="line-modified">328                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-modified">329 </span>
<span class="line-modified">330                 // check constraints of peer ECPublicKey</span>
<span class="line-modified">331                 if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">332                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">333                         peerPublicKey)) {</span>
<span class="line-removed">334                     throw new SSLHandshakeException(</span>
<span class="line-removed">335                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">336                 }</span>
<span class="line-removed">337 </span>
<span class="line-removed">338                 shc.handshakeCredentials.add(new ECDHECredentials(</span>
<span class="line-removed">339                         peerPublicKey, namedGroup));</span>
<span class="line-removed">340             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">341                 throw (SSLHandshakeException)(new SSLHandshakeException(</span>
<span class="line-removed">342                         &quot;Could not generate ECPublicKey&quot;).initCause(e));</span>
343             }
344 
345             // update the states
346             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
347             SecretKey masterSecret =
348                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
349             shc.handshakeSession.setMasterSecret(masterSecret);
350 
351             SSLTrafficKeyDerivation kd =
352                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
353             if (kd == null) {
354                 // unlikely
355                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
356                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
357             } else {
358                 shc.handshakeKeyDerivation =
359                     kd.createKeyDerivation(shc, masterSecret);
360             }
361         }
362     }
363 
364     /**
365      * The ECDHE &quot;ClientKeyExchange&quot; handshake message producer.
366      */
367     private static final
368             class ECDHEClientKeyExchangeProducer implements HandshakeProducer {
369         // Prevent instantiation of this class.
370         private ECDHEClientKeyExchangeProducer() {
371             // blank
372         }
373 
374         @Override
375         public byte[] produce(ConnectionContext context,
376                 HandshakeMessage message) throws IOException {
377             // The producing happens in client side only.
378             ClientHandshakeContext chc = (ClientHandshakeContext)context;
379 
<span class="line-modified">380             ECDHECredentials ecdheCredentials = null;</span>





381             for (SSLCredentials cd : chc.handshakeCredentials) {
<span class="line-modified">382                 if (cd instanceof ECDHECredentials) {</span>
<span class="line-modified">383                     ecdheCredentials = (ECDHECredentials)cd;</span>



384                     break;
385                 }
386             }
387 
<span class="line-modified">388             if (ecdheCredentials == null) {</span>
389                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
390                     &quot;No ECDHE credentials negotiated for client key exchange&quot;);
391             }
392 
<span class="line-modified">393             ECDHEPossession ecdhePossession = new ECDHEPossession(</span>
<span class="line-modified">394                     ecdheCredentials, chc.sslContext.getSecureRandom());</span>
<span class="line-modified">395             chc.handshakePossessions.add(ecdhePossession);</span>



396             ECDHClientKeyExchangeMessage cke =
397                     new ECDHClientKeyExchangeMessage(
<span class="line-modified">398                             chc, ecdhePossession.publicKey);</span>

399             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
400                 SSLLogger.fine(
401                     &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
402             }
403 
404             // Output the handshake message.
405             cke.write(chc.handshakeOutput);
406             chc.handshakeOutput.flush();
407 
408             // update the states
409             SSLKeyExchange ke = SSLKeyExchange.valueOf(
410                     chc.negotiatedCipherSuite.keyExchange,
411                     chc.negotiatedProtocol);
412             if (ke == null) {
413                 // unlikely
414                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
415                         &quot;Not supported key exchange type&quot;);
416             } else {
417                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
418                 SecretKey masterSecret =
</pre>
<hr />
<pre>
436             return null;
437         }
438     }
439 
440     /**
441      * The ECDHE &quot;ClientKeyExchange&quot; handshake message consumer.
442      */
443     private static final
444             class ECDHEClientKeyExchangeConsumer implements SSLConsumer {
445         // Prevent instantiation of this class.
446         private ECDHEClientKeyExchangeConsumer() {
447             // blank
448         }
449 
450         @Override
451         public void consume(ConnectionContext context,
452                 ByteBuffer message) throws IOException {
453             // The consuming happens in server side only.
454             ServerHandshakeContext shc = (ServerHandshakeContext)context;
455 
<span class="line-modified">456             ECDHEPossession ecdhePossession = null;</span>




457             for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">458                 if (possession instanceof ECDHEPossession) {</span>
<span class="line-modified">459                     ecdhePossession = (ECDHEPossession)possession;</span>



460                     break;
461                 }
462             }
<span class="line-modified">463             if (ecdhePossession == null) {</span>

464                 // unlikely
465                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
466                     &quot;No expected ECDHE possessions for client key exchange&quot;);
467             }
468 
<span class="line-removed">469             ECParameterSpec params = ecdhePossession.publicKey.getParams();</span>
<span class="line-removed">470             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
471             if (namedGroup == null) {
<span class="line-modified">472                 // unlikely, have been checked during cipher suite negotiation.</span>
473                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
474                     &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
475             }
476 
477             SSLKeyExchange ke = SSLKeyExchange.valueOf(
478                     shc.negotiatedCipherSuite.keyExchange,
479                     shc.negotiatedProtocol);
480             if (ke == null) {
481                 // unlikely
482                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
483                         &quot;Not supported key exchange type&quot;);
484             }
485 
<span class="line-modified">486             // parse the handshake message</span>
487             ECDHClientKeyExchangeMessage cke =
488                     new ECDHClientKeyExchangeMessage(shc, message);
489             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
490                 SSLLogger.fine(
491                     &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
492             }
493 
494             // create the credentials
495             try {
<span class="line-modified">496                 ECPoint point =</span>
<span class="line-modified">497                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());</span>
<span class="line-modified">498                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-modified">499 </span>
<span class="line-modified">500                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">501                 ECPublicKey peerPublicKey =</span>
<span class="line-modified">502                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-modified">503 </span>
<span class="line-modified">504                 // check constraints of peer ECPublicKey</span>
<span class="line-modified">505                 if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">506                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">507                         peerPublicKey)) {</span>
<span class="line-removed">508                     throw new SSLHandshakeException(</span>
<span class="line-removed">509                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">510                 }</span>
<span class="line-removed">511 </span>
<span class="line-removed">512                 shc.handshakeCredentials.add(new ECDHECredentials(</span>
<span class="line-removed">513                         peerPublicKey, namedGroup));</span>
<span class="line-removed">514             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">515                 throw (SSLHandshakeException)(new SSLHandshakeException(</span>
<span class="line-removed">516                         &quot;Could not generate ECPublicKey&quot;).initCause(e));</span>
517             }
518 
519             // update the states
520             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
521             SecretKey masterSecret =
522                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
523             shc.handshakeSession.setMasterSecret(masterSecret);
524 
525             SSLTrafficKeyDerivation kd =
526                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
527             if (kd == null) {
528                 // unlikely
529                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
530                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
531             } else {
532                 shc.handshakeKeyDerivation =
533                     kd.createKeyDerivation(shc, masterSecret);
534             }
535         }
536     }
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;


 30 import java.security.GeneralSecurityException;


 31 import java.security.PublicKey;

 32 import java.security.interfaces.ECPublicKey;
<span class="line-added"> 33 import java.security.interfaces.XECPublicKey;</span>
<span class="line-added"> 34 import java.security.spec.AlgorithmParameterSpec;</span>
 35 import java.security.spec.ECParameterSpec;
<span class="line-modified"> 36 import java.security.spec.NamedParameterSpec;</span>

 37 import java.text.MessageFormat;

 38 import java.util.Locale;
 39 import javax.crypto.SecretKey;



 40 import sun.security.ssl.SSLHandshake.HandshakeMessage;

 41 import sun.security.ssl.X509Authentication.X509Credentials;
 42 import sun.security.ssl.X509Authentication.X509Possession;

 43 import sun.security.util.HexDumpEncoder;
 44 
 45 /**
 46  * Pack of the &quot;ClientKeyExchange&quot; handshake message.
<span class="line-added"> 47  *</span>
<span class="line-added"> 48  * This file is used by both the ECDH/ECDHE/XDH code since much of the</span>
<span class="line-added"> 49  * code is the same between the EC named groups (i.e.</span>
<span class="line-added"> 50  * x25519/x448/secp*r1), even though the APIs are very different (i.e.</span>
<span class="line-added"> 51  * ECPublicKey/XECPublicKey, KeyExchange.getInstance(&quot;EC&quot;/&quot;XDH&quot;), etc.).</span>
 52  */
 53 final class ECDHClientKeyExchange {
 54     static final SSLConsumer ecdhHandshakeConsumer =
 55             new ECDHClientKeyExchangeConsumer();
 56     static final HandshakeProducer ecdhHandshakeProducer =
 57             new ECDHClientKeyExchangeProducer();
 58 
 59     static final SSLConsumer ecdheHandshakeConsumer =
 60             new ECDHEClientKeyExchangeConsumer();
 61     static final HandshakeProducer ecdheHandshakeProducer =
 62             new ECDHEClientKeyExchangeProducer();
 63 
 64     /**
<span class="line-modified"> 65      * The ECDH/ECDHE/XDH ClientKeyExchange handshake message.</span>
 66      */
 67     private static final
 68             class ECDHClientKeyExchangeMessage extends HandshakeMessage {
 69         private final byte[] encodedPoint;
 70 
 71         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
<span class="line-modified"> 72                 byte[] encodedPublicKey) {</span>
 73             super(handshakeContext);
 74 
<span class="line-modified"> 75             this.encodedPoint = encodedPublicKey;</span>


 76         }
 77 
 78         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
 79                 ByteBuffer m) throws IOException {
 80             super(handshakeContext);
 81             if (m.remaining() != 0) {       // explicit PublicValueEncoding
 82                 this.encodedPoint = Record.getBytes8(m);
 83             } else {
 84                 this.encodedPoint = new byte[0];
 85             }
 86         }
 87 




























 88         @Override
 89         public SSLHandshake handshakeType() {
 90             return SSLHandshake.CLIENT_KEY_EXCHANGE;
 91         }
 92 
 93         @Override
 94         public int messageLength() {
 95             if (encodedPoint == null || encodedPoint.length == 0) {
 96                 return 0;
 97             } else {
 98                 return 1 + encodedPoint.length;
 99             }
100         }
101 
102         @Override
103         public void send(HandshakeOutStream hos) throws IOException {
104             if (encodedPoint != null &amp;&amp; encodedPoint.length != 0) {
105                 hos.putBytes8(encodedPoint);
106             }
107         }
</pre>
<hr />
<pre>
144         @Override
145         public byte[] produce(ConnectionContext context,
146                 HandshakeMessage message) throws IOException {
147             // The producing happens in client side only.
148             ClientHandshakeContext chc = (ClientHandshakeContext)context;
149 
150             X509Credentials x509Credentials = null;
151             for (SSLCredentials credential : chc.handshakeCredentials) {
152                 if (credential instanceof X509Credentials) {
153                     x509Credentials = (X509Credentials)credential;
154                     break;
155                 }
156             }
157 
158             if (x509Credentials == null) {
159                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
160                     &quot;No server certificate for ECDH client key exchange&quot;);
161             }
162 
163             PublicKey publicKey = x509Credentials.popPublicKey;
<span class="line-modified">164 </span>
<span class="line-added">165             NamedGroup namedGroup = null;</span>
<span class="line-added">166             String algorithm = publicKey.getAlgorithm();</span>
<span class="line-added">167 </span>
<span class="line-added">168             // Determine which NamedGroup we&#39;ll be using, then use</span>
<span class="line-added">169             // the creator functions.</span>
<span class="line-added">170             if (algorithm.equals(&quot;EC&quot;)) {</span>
<span class="line-added">171                 ECParameterSpec params = ((ECPublicKey)publicKey).getParams();</span>
<span class="line-added">172                 namedGroup = NamedGroup.valueOf(params);</span>
<span class="line-added">173             } else if (algorithm.equals(&quot;XDH&quot;)) {</span>
<span class="line-added">174                 AlgorithmParameterSpec params =</span>
<span class="line-added">175                         ((XECPublicKey)publicKey).getParams();</span>
<span class="line-added">176                 if (params instanceof NamedParameterSpec) {</span>
<span class="line-added">177                     String name = ((NamedParameterSpec)params).getName();</span>
<span class="line-added">178                     namedGroup = NamedGroup.nameOf(name);</span>
<span class="line-added">179                 }</span>
<span class="line-added">180             } else {</span>
181                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">182                     &quot;Not EC/XDH server certificate for &quot; +</span>
<span class="line-added">183                             &quot;ECDH client key exchange&quot;);</span>
184             }
185 


186             if (namedGroup == null) {
187                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">188                     &quot;Unsupported EC/XDH server cert for &quot; +</span>
<span class="line-added">189                         &quot;ECDH client key exchange&quot;);</span>
190             }
191 
<span class="line-modified">192             SSLPossession sslPossession = namedGroup.createPossession(</span>
<span class="line-modified">193                     chc.sslContext.getSecureRandom());</span>
<span class="line-modified">194 </span>
<span class="line-added">195             chc.handshakePossessions.add(sslPossession);</span>
196             ECDHClientKeyExchangeMessage cke =
197                     new ECDHClientKeyExchangeMessage(
<span class="line-modified">198                             chc, sslPossession.encode());</span>
199             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
200                 SSLLogger.fine(
201                     &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
202             }
203 
204             // Output the handshake message.
205             cke.write(chc.handshakeOutput);
206             chc.handshakeOutput.flush();
207 
208             // update the states
209             SSLKeyExchange ke = SSLKeyExchange.valueOf(
210                     chc.negotiatedCipherSuite.keyExchange,
211                     chc.negotiatedProtocol);
212             if (ke == null) {
213                 // unlikely
214                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
215                         &quot;Not supported key exchange type&quot;);
216             } else {
217                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
218                 SecretKey masterSecret =
</pre>
<hr />
<pre>
250         @Override
251         public void consume(ConnectionContext context,
252                 ByteBuffer message) throws IOException {
253             // The consuming happens in server side only.
254             ServerHandshakeContext shc = (ServerHandshakeContext)context;
255 
256             X509Possession x509Possession = null;
257             for (SSLPossession possession : shc.handshakePossessions) {
258                 if (possession instanceof X509Possession) {
259                     x509Possession = (X509Possession)possession;
260                     break;
261                 }
262             }
263 
264             if (x509Possession == null) {
265                 // unlikely, have been checked during cipher suite negotiation.
266                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
267                     &quot;No expected EC server cert for ECDH client key exchange&quot;);
268             }
269 
<span class="line-modified">270             // Determine which NamedGroup we&#39;ll be using, then use</span>
<span class="line-modified">271             // the creator functions.</span>
<span class="line-added">272             NamedGroup namedGroup = null;</span>
<span class="line-added">273 </span>
<span class="line-added">274             // Iteratively determine the X509Possession type&#39;s ParameterSpec.</span>
<span class="line-added">275             ECParameterSpec ecParams = x509Possession.getECParameterSpec();</span>
<span class="line-added">276             NamedParameterSpec namedParams = null;</span>
<span class="line-added">277             if (ecParams != null) {</span>
<span class="line-added">278                 namedGroup = NamedGroup.valueOf(ecParams);</span>
<span class="line-added">279             }</span>
<span class="line-added">280 </span>
<span class="line-added">281             // Wasn&#39;t EC, try XEC.</span>
<span class="line-added">282             if (ecParams == null) {</span>
<span class="line-added">283                 namedParams = x509Possession.getXECParameterSpec();</span>
<span class="line-added">284                 namedGroup = NamedGroup.nameOf(namedParams.getName());</span>
<span class="line-added">285             }</span>
<span class="line-added">286 </span>
<span class="line-added">287             // Can&#39;t figure this out, bail.</span>
<span class="line-added">288             if ((ecParams == null) &amp;&amp; (namedParams == null)) {</span>
289                 // unlikely, have been checked during cipher suite negotiation.
290                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">291                     &quot;Not EC/XDH server cert for ECDH client key exchange&quot;);</span>
292             }
293 
<span class="line-modified">294             // unlikely, have been checked during cipher suite negotiation.</span>

295             if (namedGroup == null) {

296                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">297                     &quot;Unknown named group in server cert for &quot; +</span>
<span class="line-added">298                         &quot;ECDH client key exchange&quot;);</span>
299             }
300 
301             SSLKeyExchange ke = SSLKeyExchange.valueOf(
302                     shc.negotiatedCipherSuite.keyExchange,
303                     shc.negotiatedProtocol);
304             if (ke == null) {
305                 // unlikely
306                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
307                         &quot;Not supported key exchange type&quot;);
308             }
309 
<span class="line-modified">310             // parse either handshake message containing either EC/XEC.</span>
311             ECDHClientKeyExchangeMessage cke =
312                     new ECDHClientKeyExchangeMessage(shc, message);
313             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
314                 SSLLogger.fine(
315                     &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
316             }
317 
318             // create the credentials
319             try {
<span class="line-modified">320                 NamedGroup ng = namedGroup;  // &quot;effectively final&quot; the lambda</span>
<span class="line-modified">321                 // AlgorithmConstraints are checked internally.</span>
<span class="line-modified">322                 SSLCredentials sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">323                         cke.encodedPoint, shc.algorithmConstraints,</span>
<span class="line-modified">324                         s -&gt; shc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">325                         &quot;ClientKeyExchange &quot; + ng + &quot;: &quot; + s));</span>
<span class="line-modified">326 </span>
<span class="line-modified">327                 shc.handshakeCredentials.add(sslCredentials);</span>
<span class="line-modified">328             } catch (GeneralSecurityException e) {</span>
<span class="line-modified">329                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">330                         &quot;Cannot decode ECDH PublicKey: &quot; + namedGroup);</span>










331             }
332 
333             // update the states
334             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
335             SecretKey masterSecret =
336                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
337             shc.handshakeSession.setMasterSecret(masterSecret);
338 
339             SSLTrafficKeyDerivation kd =
340                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
341             if (kd == null) {
342                 // unlikely
343                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
344                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
345             } else {
346                 shc.handshakeKeyDerivation =
347                     kd.createKeyDerivation(shc, masterSecret);
348             }
349         }
350     }
351 
352     /**
353      * The ECDHE &quot;ClientKeyExchange&quot; handshake message producer.
354      */
355     private static final
356             class ECDHEClientKeyExchangeProducer implements HandshakeProducer {
357         // Prevent instantiation of this class.
358         private ECDHEClientKeyExchangeProducer() {
359             // blank
360         }
361 
362         @Override
363         public byte[] produce(ConnectionContext context,
364                 HandshakeMessage message) throws IOException {
365             // The producing happens in client side only.
366             ClientHandshakeContext chc = (ClientHandshakeContext)context;
367 
<span class="line-modified">368             SSLCredentials sslCredentials = null;</span>
<span class="line-added">369             NamedGroup ng = null;</span>
<span class="line-added">370             PublicKey publicKey = null;</span>
<span class="line-added">371 </span>
<span class="line-added">372             // Find a good EC/XEC credential to use, determine the</span>
<span class="line-added">373             // NamedGroup to use for creating Possessions/Credentials/Keys.</span>
374             for (SSLCredentials cd : chc.handshakeCredentials) {
<span class="line-modified">375                 if (cd instanceof NamedGroupCredentials) {</span>
<span class="line-modified">376                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;</span>
<span class="line-added">377                     ng = creds.getNamedGroup();</span>
<span class="line-added">378                     publicKey = creds.getPublicKey();</span>
<span class="line-added">379                     sslCredentials = cd;</span>
380                     break;
381                 }
382             }
383 
<span class="line-modified">384             if (sslCredentials == null) {</span>
385                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
386                     &quot;No ECDHE credentials negotiated for client key exchange&quot;);
387             }
388 
<span class="line-modified">389             SSLPossession sslPossession = ng.createPossession(</span>
<span class="line-modified">390                     chc.sslContext.getSecureRandom());</span>
<span class="line-modified">391 </span>
<span class="line-added">392             chc.handshakePossessions.add(sslPossession);</span>
<span class="line-added">393 </span>
<span class="line-added">394             // Write the EC/XEC message.</span>
395             ECDHClientKeyExchangeMessage cke =
396                     new ECDHClientKeyExchangeMessage(
<span class="line-modified">397                             chc, sslPossession.encode());</span>
<span class="line-added">398 </span>
399             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
400                 SSLLogger.fine(
401                     &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
402             }
403 
404             // Output the handshake message.
405             cke.write(chc.handshakeOutput);
406             chc.handshakeOutput.flush();
407 
408             // update the states
409             SSLKeyExchange ke = SSLKeyExchange.valueOf(
410                     chc.negotiatedCipherSuite.keyExchange,
411                     chc.negotiatedProtocol);
412             if (ke == null) {
413                 // unlikely
414                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
415                         &quot;Not supported key exchange type&quot;);
416             } else {
417                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
418                 SecretKey masterSecret =
</pre>
<hr />
<pre>
436             return null;
437         }
438     }
439 
440     /**
441      * The ECDHE &quot;ClientKeyExchange&quot; handshake message consumer.
442      */
443     private static final
444             class ECDHEClientKeyExchangeConsumer implements SSLConsumer {
445         // Prevent instantiation of this class.
446         private ECDHEClientKeyExchangeConsumer() {
447             // blank
448         }
449 
450         @Override
451         public void consume(ConnectionContext context,
452                 ByteBuffer message) throws IOException {
453             // The consuming happens in server side only.
454             ServerHandshakeContext shc = (ServerHandshakeContext)context;
455 
<span class="line-modified">456             SSLPossession sslPossession = null;</span>
<span class="line-added">457             NamedGroup namedGroup = null;</span>
<span class="line-added">458 </span>
<span class="line-added">459            // Find a good EC/XEC credential to use, determine the</span>
<span class="line-added">460            // NamedGroup to use for creating Possessions/Credentials/Keys.</span>
461             for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">462                 if (possession instanceof NamedGroupPossession) {</span>
<span class="line-modified">463                     NamedGroupPossession poss =</span>
<span class="line-added">464                             (NamedGroupPossession)possession;</span>
<span class="line-added">465                     namedGroup = poss.getNamedGroup();</span>
<span class="line-added">466                     sslPossession = poss;</span>
467                     break;
468                 }
469             }
<span class="line-modified">470 </span>
<span class="line-added">471             if (sslPossession == null) {</span>
472                 // unlikely
473                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
474                     &quot;No expected ECDHE possessions for client key exchange&quot;);
475             }
476 


477             if (namedGroup == null) {
<span class="line-modified">478                 // unlikely, have been checked during cipher suite negotiation</span>
479                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
480                     &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
481             }
482 
483             SSLKeyExchange ke = SSLKeyExchange.valueOf(
484                     shc.negotiatedCipherSuite.keyExchange,
485                     shc.negotiatedProtocol);
486             if (ke == null) {
487                 // unlikely
488                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
489                         &quot;Not supported key exchange type&quot;);
490             }
491 
<span class="line-modified">492             // parse the EC/XEC handshake message</span>
493             ECDHClientKeyExchangeMessage cke =
494                     new ECDHClientKeyExchangeMessage(shc, message);
495             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
496                 SSLLogger.fine(
497                     &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
498             }
499 
500             // create the credentials
501             try {
<span class="line-modified">502                 NamedGroup ng = namedGroup; // &quot;effectively final&quot; the lambda</span>
<span class="line-modified">503                 // AlgorithmConstraints are checked internally.</span>
<span class="line-modified">504                 SSLCredentials sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">505                         cke.encodedPoint, shc.algorithmConstraints,</span>
<span class="line-modified">506                         s -&gt; shc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">507                         &quot;ClientKeyExchange &quot; + ng + &quot;: &quot; + s));</span>
<span class="line-modified">508 </span>
<span class="line-modified">509                 shc.handshakeCredentials.add(sslCredentials);</span>
<span class="line-modified">510             } catch (GeneralSecurityException e) {</span>
<span class="line-modified">511                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">512                         &quot;Cannot decode named group: &quot; + namedGroup);</span>










513             }
514 
515             // update the states
516             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
517             SecretKey masterSecret =
518                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
519             shc.handshakeSession.setMasterSecret(masterSecret);
520 
521             SSLTrafficKeyDerivation kd =
522                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
523             if (kd == null) {
524                 // unlikely
525                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
526                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
527             } else {
528                 shc.handshakeKeyDerivation =
529                     kd.createKeyDerivation(shc, masterSecret);
530             }
531         }
532     }
</pre>
</td>
</tr>
</table>
<center><a href="DTLSOutputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
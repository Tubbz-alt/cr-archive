<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/ECDHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AlgorithmConstraints;
 30 import java.security.CryptoPrimitive;
 31 import java.security.GeneralSecurityException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.PrivateKey;
 36 import java.security.PublicKey;
 37 import java.security.SecureRandom;
<a name="1" id="anc1"></a>
 38 import java.security.interfaces.ECPublicKey;
<a name="2" id="anc2"></a>

 39 import java.security.spec.ECParameterSpec;
 40 import java.security.spec.ECPoint;
 41 import java.security.spec.ECPublicKeySpec;
 42 import java.util.EnumSet;
 43 import javax.crypto.KeyAgreement;
 44 import javax.crypto.SecretKey;
<a name="3" id="anc3"></a>
 45 import javax.net.ssl.SSLHandshakeException;
<a name="4" id="anc4"></a><span class="line-modified"> 46 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>


 47 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 48 import sun.security.ssl.X509Authentication.X509Credentials;
 49 import sun.security.ssl.X509Authentication.X509Possession;
<a name="5" id="anc5"></a><span class="line-added"> 50 import sun.security.ssl.XDHKeyExchange.XDHECredentials;</span>
<span class="line-added"> 51 import sun.security.ssl.XDHKeyExchange.XDHEPossession;</span>
 52 import sun.security.util.ECUtil;
 53 
 54 final class ECDHKeyExchange {
 55     static final SSLPossessionGenerator poGenerator =
 56             new ECDHEPossessionGenerator();
<a name="6" id="anc6"></a>

 57     static final SSLKeyAgreementGenerator ecdhKAGenerator =
 58             new ECDHKAGenerator();
 59 
<a name="7" id="anc7"></a><span class="line-modified"> 60     // TLSv1.3</span>
<span class="line-added"> 61     static final SSLKeyAgreementGenerator ecdheKAGenerator =</span>
<span class="line-added"> 62             new ECDHEKAGenerator();</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64     // TLSv1-1.2, the KA gets more difficult with EC/XEC keys</span>
<span class="line-added"> 65     static final SSLKeyAgreementGenerator ecdheXdhKAGenerator =</span>
<span class="line-added"> 66             new ECDHEXDHKAGenerator();</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     static final class ECDHECredentials implements NamedGroupCredentials {</span>
 69         final ECPublicKey popPublicKey;
 70         final NamedGroup namedGroup;
 71 
 72         ECDHECredentials(ECPublicKey popPublicKey, NamedGroup namedGroup) {
 73             this.popPublicKey = popPublicKey;
 74             this.namedGroup = namedGroup;
 75         }
 76 
<a name="8" id="anc8"></a><span class="line-added"> 77         @Override</span>
<span class="line-added"> 78         public PublicKey getPublicKey() {</span>
<span class="line-added"> 79             return popPublicKey;</span>
<span class="line-added"> 80         }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82         @Override</span>
<span class="line-added"> 83         public NamedGroup getNamedGroup() {</span>
<span class="line-added"> 84             return namedGroup;</span>
<span class="line-added"> 85         }</span>
<span class="line-added"> 86 </span>
 87         static ECDHECredentials valueOf(NamedGroup namedGroup,
 88             byte[] encodedPoint) throws IOException, GeneralSecurityException {
 89 
<a name="9" id="anc9"></a><span class="line-modified"> 90             if (namedGroup.spec != NamedGroupSpec.NAMED_GROUP_ECDHE) {</span>
 91                 throw new RuntimeException(
 92                     &quot;Credentials decoding:  Not ECDHE named group&quot;);
 93             }
 94 
 95             if (encodedPoint == null || encodedPoint.length == 0) {
 96                 return null;
 97             }
 98 
 99             ECParameterSpec parameters =
<a name="10" id="anc10"></a><span class="line-modified">100                     (ECParameterSpec)namedGroup.keAlgParamSpec;</span>




101             ECPoint point = ECUtil.decodePoint(
102                     encodedPoint, parameters.getCurve());
103             KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
104             ECPublicKey publicKey = (ECPublicKey)factory.generatePublic(
105                     new ECPublicKeySpec(point, parameters));
106             return new ECDHECredentials(publicKey, namedGroup);
107         }
108     }
109 
<a name="11" id="anc11"></a><span class="line-modified">110     static final class ECDHEPossession implements NamedGroupPossession {</span>
111         final PrivateKey privateKey;
112         final ECPublicKey publicKey;
113         final NamedGroup namedGroup;
114 
115         ECDHEPossession(NamedGroup namedGroup, SecureRandom random) {
116             try {
117                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
<a name="12" id="anc12"></a><span class="line-modified">118                 kpg.initialize(namedGroup.keAlgParamSpec, random);</span>


119                 KeyPair kp = kpg.generateKeyPair();
120                 privateKey = kp.getPrivate();
121                 publicKey = (ECPublicKey)kp.getPublic();
122             } catch (GeneralSecurityException e) {
123                 throw new RuntimeException(
124                     &quot;Could not generate ECDH keypair&quot;, e);
125             }
126 
127             this.namedGroup = namedGroup;
128         }
129 
130         ECDHEPossession(ECDHECredentials credentials, SecureRandom random) {
131             ECParameterSpec params = credentials.popPublicKey.getParams();
132             try {
133                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
134                 kpg.initialize(params, random);
135                 KeyPair kp = kpg.generateKeyPair();
136                 privateKey = kp.getPrivate();
137                 publicKey = (ECPublicKey)kp.getPublic();
138             } catch (GeneralSecurityException e) {
139                 throw new RuntimeException(
140                     &quot;Could not generate ECDH keypair&quot;, e);
141             }
142 
143             this.namedGroup = credentials.namedGroup;
144         }
145 
146         @Override
147         public byte[] encode() {
148             return ECUtil.encodePoint(
149                     publicKey.getW(), publicKey.getParams().getCurve());
150         }
151 
152         // called by ClientHandshaker with either the server&#39;s static or
153         // ephemeral public key
154         SecretKey getAgreedSecret(
155                 PublicKey peerPublicKey) throws SSLHandshakeException {
156 
157             try {
158                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);
159                 ka.init(privateKey);
160                 ka.doPhase(peerPublicKey, true);
161                 return ka.generateSecret(&quot;TlsPremasterSecret&quot;);
162             } catch (GeneralSecurityException e) {
163                 throw (SSLHandshakeException) new SSLHandshakeException(
164                     &quot;Could not generate secret&quot;).initCause(e);
165             }
166         }
167 
168         // called by ServerHandshaker
169         SecretKey getAgreedSecret(
170                 byte[] encodedPoint) throws SSLHandshakeException {
171             try {
172                 ECParameterSpec params = publicKey.getParams();
173                 ECPoint point =
174                         ECUtil.decodePoint(encodedPoint, params.getCurve());
175                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
176                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
177                 PublicKey peerPublicKey = kf.generatePublic(spec);
178                 return getAgreedSecret(peerPublicKey);
179             } catch (GeneralSecurityException | java.io.IOException e) {
180                 throw (SSLHandshakeException) new SSLHandshakeException(
181                     &quot;Could not generate secret&quot;).initCause(e);
182             }
183         }
184 
185         // Check constraints of the specified EC public key.
186         void checkConstraints(AlgorithmConstraints constraints,
187                 byte[] encodedPoint) throws SSLHandshakeException {
188             try {
189 
190                 ECParameterSpec params = publicKey.getParams();
191                 ECPoint point =
192                         ECUtil.decodePoint(encodedPoint, params.getCurve());
193                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
194 
195                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
196                 ECPublicKey pubKey = (ECPublicKey)kf.generatePublic(spec);
197 
198                 // check constraints of ECPublicKey
199                 if (!constraints.permits(
200                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), pubKey)) {
201                     throw new SSLHandshakeException(
202                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
203                 }
204             } catch (GeneralSecurityException | java.io.IOException e) {
205                 throw (SSLHandshakeException) new SSLHandshakeException(
206                         &quot;Could not generate ECPublicKey&quot;).initCause(e);
207             }
208         }
<a name="13" id="anc13"></a><span class="line-added">209 </span>
<span class="line-added">210         @Override</span>
<span class="line-added">211         public PublicKey getPublicKey() {</span>
<span class="line-added">212             return publicKey;</span>
<span class="line-added">213         }</span>
<span class="line-added">214 </span>
<span class="line-added">215         @Override</span>
<span class="line-added">216         public NamedGroup getNamedGroup() {</span>
<span class="line-added">217             return namedGroup;</span>
<span class="line-added">218         }</span>
<span class="line-added">219 </span>
<span class="line-added">220         @Override</span>
<span class="line-added">221         public PrivateKey getPrivateKey() {</span>
<span class="line-added">222             return privateKey;</span>
<span class="line-added">223         }</span>
224     }
225 
226     private static final
227             class ECDHEPossessionGenerator implements SSLPossessionGenerator {
228         // Prevent instantiation of this class.
229         private ECDHEPossessionGenerator() {
230             // blank
231         }
232 
233         @Override
234         public SSLPossession createPossession(HandshakeContext context) {
<a name="14" id="anc14"></a><span class="line-modified">235 </span>
<span class="line-added">236             NamedGroup preferableNamedGroup;</span>
<span class="line-added">237 </span>
<span class="line-added">238             // Find most preferred EC or XEC groups</span>
239             if ((context.clientRequestedNamedGroups != null) &amp;&amp;
240                     (!context.clientRequestedNamedGroups.isEmpty())) {
241                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
242                         context.negotiatedProtocol,
243                         context.algorithmConstraints,
<a name="15" id="anc15"></a><span class="line-modified">244                         new NamedGroupSpec[] {</span>
<span class="line-added">245                             NamedGroupSpec.NAMED_GROUP_ECDHE,</span>
<span class="line-added">246                             NamedGroupSpec.NAMED_GROUP_XDH },</span>
247                         context.clientRequestedNamedGroups);
248             } else {
249                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
250                         context.negotiatedProtocol,
251                         context.algorithmConstraints,
<a name="16" id="anc16"></a><span class="line-modified">252                         new NamedGroupSpec[] {</span>
<span class="line-added">253                             NamedGroupSpec.NAMED_GROUP_ECDHE,</span>
<span class="line-added">254                             NamedGroupSpec.NAMED_GROUP_XDH });</span>
255             }
256 
257             if (preferableNamedGroup != null) {
<a name="17" id="anc17"></a><span class="line-modified">258                 return preferableNamedGroup.createPossession(</span>
<span class="line-modified">259                     context.sslContext.getSecureRandom());</span>
260             }
261 
262             // no match found, cannot use this cipher suite.
263             //
264             return null;
265         }
266     }
267 
268     private static final
269             class ECDHKAGenerator implements SSLKeyAgreementGenerator {
270         // Prevent instantiation of this class.
271         private ECDHKAGenerator() {
272             // blank
273         }
274 
275         @Override
276         public SSLKeyDerivation createKeyDerivation(
277                 HandshakeContext context) throws IOException {
278             if (context instanceof ServerHandshakeContext) {
279                 return createServerKeyDerivation(
280                         (ServerHandshakeContext)context);
281             } else {
282                 return createClientKeyDerivation(
283                         (ClientHandshakeContext)context);
284             }
285         }
286 
287         private SSLKeyDerivation createServerKeyDerivation(
288                 ServerHandshakeContext shc) throws IOException {
289             X509Possession x509Possession = null;
290             ECDHECredentials ecdheCredentials = null;
291             for (SSLPossession poss : shc.handshakePossessions) {
292                 if (!(poss instanceof X509Possession)) {
293                     continue;
294                 }
295 
<a name="18" id="anc18"></a><span class="line-modified">296                 ECParameterSpec params =</span>
<span class="line-modified">297                         ((X509Possession)poss).getECParameterSpec();</span>
<span class="line-added">298                 if (params == null) {</span>
299                     continue;
300                 }
301 
<a name="19" id="anc19"></a>
302                 NamedGroup ng = NamedGroup.valueOf(params);
303                 if (ng == null) {
<a name="20" id="anc20"></a><span class="line-modified">304                     // unlikely, have been checked during cipher suite</span>
<span class="line-added">305                     // negotiation.</span>
306                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
307                         &quot;Unsupported EC server cert for ECDH key exchange&quot;);
308                 }
309 
310                 for (SSLCredentials cred : shc.handshakeCredentials) {
311                     if (!(cred instanceof ECDHECredentials)) {
312                         continue;
313                     }
314                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
315                         ecdheCredentials = (ECDHECredentials)cred;
316                         break;
317                     }
318                 }
319 
320                 if (ecdheCredentials != null) {
321                     x509Possession = (X509Possession)poss;
322                     break;
323                 }
324             }
325 
326             if (x509Possession == null || ecdheCredentials == null) {
327                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
328                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
329             }
330 
<a name="21" id="anc21"></a><span class="line-modified">331             return new KAKeyDerivation(&quot;ECDH&quot;, shc,</span>
332                 x509Possession.popPrivateKey, ecdheCredentials.popPublicKey);
333         }
334 
335         private SSLKeyDerivation createClientKeyDerivation(
336                 ClientHandshakeContext chc) throws IOException {
337             ECDHEPossession ecdhePossession = null;
338             X509Credentials x509Credentials = null;
339             for (SSLPossession poss : chc.handshakePossessions) {
340                 if (!(poss instanceof ECDHEPossession)) {
341                     continue;
342                 }
343 
344                 NamedGroup ng = ((ECDHEPossession)poss).namedGroup;
345                 for (SSLCredentials cred : chc.handshakeCredentials) {
346                     if (!(cred instanceof X509Credentials)) {
347                         continue;
348                     }
349 
350                     PublicKey publicKey = ((X509Credentials)cred).popPublicKey;
351                     if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {
352                         continue;
353                     }
354                     ECParameterSpec params =
355                             ((ECPublicKey)publicKey).getParams();
356                     NamedGroup namedGroup = NamedGroup.valueOf(params);
357                     if (namedGroup == null) {
358                         // unlikely, should have been checked previously
359                         throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
360                             &quot;Unsupported EC server cert for ECDH key exchange&quot;);
361                     }
362 
363                     if (ng.equals(namedGroup)) {
364                         x509Credentials = (X509Credentials)cred;
365                         break;
366                     }
367                 }
368 
369                 if (x509Credentials != null) {
370                     ecdhePossession = (ECDHEPossession)poss;
371                     break;
372                 }
373             }
374 
375             if (ecdhePossession == null || x509Credentials == null) {
376                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
377                     &quot;No sufficient ECDH key agreement parameters negotiated&quot;);
378             }
379 
<a name="22" id="anc22"></a><span class="line-modified">380             return new KAKeyDerivation(&quot;ECDH&quot;, chc,</span>
381                 ecdhePossession.privateKey, x509Credentials.popPublicKey);
382         }
383     }
384 
385     private static final
386             class ECDHEKAGenerator implements SSLKeyAgreementGenerator {
387         // Prevent instantiation of this class.
388         private ECDHEKAGenerator() {
389             // blank
390         }
391 
392         @Override
393         public SSLKeyDerivation createKeyDerivation(
394                 HandshakeContext context) throws IOException {
395             ECDHEPossession ecdhePossession = null;
396             ECDHECredentials ecdheCredentials = null;
397             for (SSLPossession poss : context.handshakePossessions) {
398                 if (!(poss instanceof ECDHEPossession)) {
399                     continue;
400                 }
401 
402                 NamedGroup ng = ((ECDHEPossession)poss).namedGroup;
403                 for (SSLCredentials cred : context.handshakeCredentials) {
404                     if (!(cred instanceof ECDHECredentials)) {
405                         continue;
406                     }
407                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
408                         ecdheCredentials = (ECDHECredentials)cred;
409                         break;
410                     }
411                 }
412 
413                 if (ecdheCredentials != null) {
414                     ecdhePossession = (ECDHEPossession)poss;
415                     break;
416                 }
417             }
418 
419             if (ecdhePossession == null || ecdheCredentials == null) {
420                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
421                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
422             }
423 
<a name="23" id="anc23"></a><span class="line-modified">424             return new KAKeyDerivation(&quot;ECDH&quot;, context,</span>
425                 ecdhePossession.privateKey, ecdheCredentials.popPublicKey);
426         }
427     }
428 
<a name="24" id="anc24"></a><span class="line-added">429     /*</span>
<span class="line-added">430      * A Generator for TLSv1-1.2 to create a ECDHE or a XDH KeyDerivation</span>
<span class="line-added">431      * object depending on the negotiated group.</span>
<span class="line-added">432      */</span>
433     private static final
<a name="25" id="anc25"></a><span class="line-modified">434             class ECDHEXDHKAGenerator implements SSLKeyAgreementGenerator {</span>
<span class="line-modified">435         // Prevent instantiation of this class.</span>
<span class="line-modified">436         private ECDHEXDHKAGenerator() {</span>
<span class="line-modified">437             // blank</span>







438         }
439 
440         @Override
<a name="26" id="anc26"></a><span class="line-modified">441         public SSLKeyDerivation createKeyDerivation(</span>
<span class="line-modified">442                 HandshakeContext context) throws IOException {</span>






443 
<a name="27" id="anc27"></a><span class="line-modified">444             NamedGroupPossession namedGroupPossession = null;</span>
<span class="line-modified">445             NamedGroupCredentials namedGroupCredentials = null;</span>
<span class="line-modified">446             NamedGroup namedGroup = null;</span>























447 
<a name="28" id="anc28"></a><span class="line-modified">448             // Find a possession/credential combo using the same named group</span>
<span class="line-modified">449             search:</span>
<span class="line-modified">450             for (SSLPossession poss : context.handshakePossessions) {</span>
<span class="line-modified">451                 for (SSLCredentials cred : context.handshakeCredentials) {</span>
<span class="line-modified">452                     if (((poss instanceof ECDHEPossession) &amp;&amp;</span>
<span class="line-modified">453                             (cred instanceof ECDHECredentials)) ||</span>
<span class="line-modified">454                             (((poss instanceof XDHEPossession) &amp;&amp;</span>
<span class="line-modified">455                             (cred instanceof XDHECredentials)))) {</span>
<span class="line-modified">456                         NamedGroupPossession p = (NamedGroupPossession)poss;</span>
<span class="line-modified">457                         NamedGroupCredentials c = (NamedGroupCredentials)cred;</span>
<span class="line-modified">458                         if (p.getNamedGroup() != c.getNamedGroup()) {</span>
<span class="line-modified">459                             continue;</span>
<span class="line-modified">460                         } else {</span>
<span class="line-modified">461                             namedGroup = p.getNamedGroup();</span>
<span class="line-modified">462                         }</span>
<span class="line-modified">463                         namedGroupPossession = p;</span>
<span class="line-modified">464                         namedGroupCredentials = c;</span>
<span class="line-modified">465                         break search;</span>
<span class="line-modified">466                     }</span>


467                 }
<a name="29" id="anc29"></a><span class="line-added">468             }</span>
469 
<a name="30" id="anc30"></a><span class="line-modified">470             if (namedGroupPossession == null || namedGroupCredentials == null) {</span>
<span class="line-modified">471                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added">472                     &quot;No sufficient ECDHE/XDH key agreement &quot; +</span>
<span class="line-added">473                             &quot;parameters negotiated&quot;);</span>
<span class="line-added">474             }</span>
475 
<a name="31" id="anc31"></a><span class="line-modified">476             String alg;</span>
<span class="line-modified">477             switch (namedGroup.spec) {</span>
<span class="line-modified">478                 case NAMED_GROUP_ECDHE:</span>
<span class="line-modified">479                     alg = &quot;ECDH&quot;;</span>
<span class="line-modified">480                     break;</span>
<span class="line-added">481                 case NAMED_GROUP_XDH:</span>
<span class="line-added">482                     alg = &quot;XDH&quot;;</span>
<span class="line-added">483                     break;</span>
<span class="line-added">484                 default:</span>
<span class="line-added">485                     throw new RuntimeException(&quot;Unexpected named group type&quot;);</span>
486             }
<a name="32" id="anc32"></a><span class="line-added">487 </span>
<span class="line-added">488             return new KAKeyDerivation(alg, context,</span>
<span class="line-added">489                     namedGroupPossession.getPrivateKey(),</span>
<span class="line-added">490                     namedGroupCredentials.getPublicKey());</span>
491         }
492     }
493 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
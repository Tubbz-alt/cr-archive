<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/util/locale/provider/LocaleResources.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  * The original version of this source code and documentation
 31  * is copyrighted and owned by Taligent, Inc., a wholly-owned
 32  * subsidiary of IBM. These materials are provided under terms
 33  * of a License Agreement between Taligent and Sun. This technology
 34  * is protected by multiple US and International patents.
 35  *
 36  * This notice and attribution to Taligent may not be removed.
 37  * Taligent is a registered trademark of Taligent, Inc.
 38  *
 39  */
 40 
 41 package sun.util.locale.provider;
 42 
 43 import java.lang.ref.ReferenceQueue;
 44 import java.lang.ref.SoftReference;
 45 import java.text.MessageFormat;
 46 import java.text.NumberFormat;
 47 import java.util.Arrays;
 48 import java.util.Calendar;
 49 import java.util.HashSet;
 50 import java.util.LinkedHashSet;
 51 import java.util.Locale;
 52 import java.util.Map;
 53 import java.util.Objects;
 54 import java.util.ResourceBundle;
 55 import java.util.Set;
 56 import java.util.TimeZone;
 57 import java.util.concurrent.ConcurrentHashMap;
 58 import java.util.concurrent.ConcurrentMap;
 59 import sun.security.action.GetPropertyAction;
 60 import sun.util.resources.LocaleData;
 61 import sun.util.resources.OpenListResourceBundle;
 62 import sun.util.resources.ParallelListResourceBundle;
 63 import sun.util.resources.TimeZoneNamesBundle;
 64 
 65 /**
 66  * Central accessor to locale-dependent resources for JRE/CLDR provider adapters.
 67  *
 68  * @author Masayoshi Okutsu
 69  * @author Naoto Sato
 70  */
 71 public class LocaleResources {
 72 
 73     private final Locale locale;
 74     private final LocaleData localeData;
 75     private final LocaleProviderAdapter.Type type;
 76 
 77     // Resource cache
 78     private final ConcurrentMap&lt;String, ResourceReference&gt; cache = new ConcurrentHashMap&lt;&gt;();
 79     private final ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 80 
 81     // cache key prefixes
 82     private static final String BREAK_ITERATOR_INFO = &quot;BII.&quot;;
 83     private static final String CALENDAR_DATA = &quot;CALD.&quot;;
 84     private static final String COLLATION_DATA_CACHEKEY = &quot;COLD&quot;;
 85     private static final String DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY = &quot;DFSD&quot;;
 86     private static final String CURRENCY_NAMES = &quot;CN.&quot;;
 87     private static final String LOCALE_NAMES = &quot;LN.&quot;;
 88     private static final String TIME_ZONE_NAMES = &quot;TZN.&quot;;
 89     private static final String ZONE_IDS_CACHEKEY = &quot;ZID&quot;;
 90     private static final String CALENDAR_NAMES = &quot;CALN.&quot;;
 91     private static final String NUMBER_PATTERNS_CACHEKEY = &quot;NP&quot;;
 92     private static final String COMPACT_NUMBER_PATTERNS_CACHEKEY = &quot;CNP&quot;;
 93     private static final String DATE_TIME_PATTERN = &quot;DTP.&quot;;
 94 
 95     // TimeZoneNamesBundle exemplar city prefix
 96     private static final String TZNB_EXCITY_PREFIX = &quot;timezone.excity.&quot;;
 97 
 98     // null singleton cache value
 99     private static final Object NULLOBJECT = new Object();
100 
101     LocaleResources(ResourceBundleBasedAdapter adapter, Locale locale) {
102         this.locale = locale;
103         this.localeData = adapter.getLocaleData();
104         type = ((LocaleProviderAdapter)adapter).getAdapterType();
105     }
106 
107     private void removeEmptyReferences() {
108         Object ref;
109         while ((ref = referenceQueue.poll()) != null) {
110             cache.remove(((ResourceReference)ref).getCacheKey());
111         }
112     }
113 
114     Object getBreakIteratorInfo(String key) {
115         Object biInfo;
116         String cacheKey = BREAK_ITERATOR_INFO + key;
117 
118         removeEmptyReferences();
119         ResourceReference data = cache.get(cacheKey);
120         if (data == null || ((biInfo = data.get()) == null)) {
121            biInfo = localeData.getBreakIteratorInfo(locale).getObject(key);
122            cache.put(cacheKey, new ResourceReference(cacheKey, biInfo, referenceQueue));
123         }
124 
125        return biInfo;
126     }
127 
128     @SuppressWarnings(&quot;unchecked&quot;)
129     byte[] getBreakIteratorResources(String key) {
130         return (byte[]) localeData.getBreakIteratorResources(locale).getObject(key);
131     }
132 
133     public String getCalendarData(String key) {
134         String caldata = &quot;&quot;;
135         String cacheKey = CALENDAR_DATA  + key;
136 
137         removeEmptyReferences();
138 
139         ResourceReference data = cache.get(cacheKey);
140         if (data == null || ((caldata = (String) data.get()) == null)) {
141             ResourceBundle rb = localeData.getCalendarData(locale);
142             if (rb.containsKey(key)) {
143                 caldata = rb.getString(key);
144             }
145 
146             cache.put(cacheKey,
147                       new ResourceReference(cacheKey, caldata, referenceQueue));
148         }
149 
150         return caldata;
151     }
152 
153     public String getCollationData() {
154         String key = &quot;Rule&quot;;
155         String coldata = &quot;&quot;;
156 
157         removeEmptyReferences();
158         ResourceReference data = cache.get(COLLATION_DATA_CACHEKEY);
159         if (data == null || ((coldata = (String) data.get()) == null)) {
160             ResourceBundle rb = localeData.getCollationData(locale);
161             if (rb.containsKey(key)) {
162                 coldata = rb.getString(key);
163             }
164             cache.put(COLLATION_DATA_CACHEKEY,
165                       new ResourceReference(COLLATION_DATA_CACHEKEY, (Object) coldata, referenceQueue));
166         }
167 
168         return coldata;
169     }
170 
171     public Object[] getDecimalFormatSymbolsData() {
172         Object[] dfsdata;
173 
174         removeEmptyReferences();
175         ResourceReference data = cache.get(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY);
176         if (data == null || ((dfsdata = (Object[]) data.get()) == null)) {
177             // Note that only dfsdata[0] is prepared here in this method. Other
178             // elements are provided by the caller, yet they are cached here.
179             ResourceBundle rb = localeData.getNumberFormatData(locale);
180             dfsdata = new Object[3];
181             dfsdata[0] = getNumberStrings(rb, &quot;NumberElements&quot;);
182 
183             cache.put(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY,
184                       new ResourceReference(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY, (Object) dfsdata, referenceQueue));
185         }
186 
187         return dfsdata;
188     }
189 
190     private String[] getNumberStrings(ResourceBundle rb, String type) {
191         String[] ret = null;
192         String key;
193         String numSys;
194 
195         // Number strings look up. First, try the Unicode extension
196         numSys = locale.getUnicodeLocaleType(&quot;nu&quot;);
197         if (numSys != null) {
198             key = numSys + &quot;.&quot; + type;
199             if (rb.containsKey(key)) {
200                 ret = rb.getStringArray(key);
201             }
202         }
203 
204         // Next, try DefaultNumberingSystem value
205         if (ret == null &amp;&amp; rb.containsKey(&quot;DefaultNumberingSystem&quot;)) {
206             key = rb.getString(&quot;DefaultNumberingSystem&quot;) + &quot;.&quot; + type;
207             if (rb.containsKey(key)) {
208                 ret = rb.getStringArray(key);
209             }
210         }
211 
212         // Last resort. No need to check the availability.
213         // Just let it throw MissingResourceException when needed.
214         if (ret == null) {
215             ret = rb.getStringArray(type);
216         }
217 
218         return ret;
219     }
220 
221     public String getCurrencyName(String key) {
222         Object currencyName = null;
223         String cacheKey = CURRENCY_NAMES + key;
224 
225         removeEmptyReferences();
226         ResourceReference data = cache.get(cacheKey);
227 
228         if (data != null &amp;&amp; ((currencyName = data.get()) != null)) {
229             if (currencyName.equals(NULLOBJECT)) {
230                 currencyName = null;
231             }
232 
233             return (String) currencyName;
234         }
235 
236         OpenListResourceBundle olrb = localeData.getCurrencyNames(locale);
237 
238         if (olrb.containsKey(key)) {
239             currencyName = olrb.getObject(key);
240             cache.put(cacheKey,
241                       new ResourceReference(cacheKey, currencyName, referenceQueue));
242         }
243 
244         return (String) currencyName;
245     }
246 
247     public String getLocaleName(String key) {
248         Object localeName = null;
249         String cacheKey = LOCALE_NAMES + key;
250 
251         removeEmptyReferences();
252         ResourceReference data = cache.get(cacheKey);
253 
254         if (data != null &amp;&amp; ((localeName = data.get()) != null)) {
255             if (localeName.equals(NULLOBJECT)) {
256                 localeName = null;
257             }
258 
259             return (String) localeName;
260         }
261 
262         OpenListResourceBundle olrb = localeData.getLocaleNames(locale);
263 
264         if (olrb.containsKey(key)) {
265             localeName = olrb.getObject(key);
266             cache.put(cacheKey,
267                       new ResourceReference(cacheKey, localeName, referenceQueue));
268         }
269 
270         return (String) localeName;
271     }
272 
273     public Object getTimeZoneNames(String key) {
274         Object val = null;
275         String cacheKey = TIME_ZONE_NAMES + key;
276 
277         removeEmptyReferences();
278         ResourceReference data = cache.get(cacheKey);
279 
280         if (Objects.isNull(data) || Objects.isNull(val = data.get())) {
281             TimeZoneNamesBundle tznb = localeData.getTimeZoneNames(locale);
282             if (key.startsWith(TZNB_EXCITY_PREFIX)) {
283                 if (tznb.containsKey(key)) {
284                     val = tznb.getString(key);
285                     assert val instanceof String;
286                     trace(&quot;tznb: %s key: %s, val: %s\n&quot;, tznb, key, val);
287                 }
288             } else {
289                 String[] names = null;
290                 if (tznb.containsKey(key)) {
291                     names = tznb.getStringArray(key);
292                 } else {
293                     var tz = TimeZoneNameUtility.canonicalTZID(key).orElse(key);
294                     if (tznb.containsKey(tz)) {
295                         names = tznb.getStringArray(tz);
296                     }
297                 }
298 
299                 if (names != null) {
300                     names[0] = key;
301                     trace(&quot;tznb: %s key: %s, names: %s, %s, %s, %s, %s, %s, %s\n&quot;, tznb, key,
302                         names[0], names[1], names[2], names[3], names[4], names[5], names[6]);
303                     val = names;
304                 }
305             }
306             if (val != null) {
307                 cache.put(cacheKey,
308                           new ResourceReference(cacheKey, val, referenceQueue));
309             }
310         }
311 
312         return val;
313     }
314 
315     @SuppressWarnings(&quot;unchecked&quot;)
316     Set&lt;String&gt; getZoneIDs() {
317         Set&lt;String&gt; zoneIDs = null;
318 
319         removeEmptyReferences();
320         ResourceReference data = cache.get(ZONE_IDS_CACHEKEY);
321         if (data == null || ((zoneIDs = (Set&lt;String&gt;) data.get()) == null)) {
322             TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
323             zoneIDs = rb.keySet();
324             cache.put(ZONE_IDS_CACHEKEY,
325                       new ResourceReference(ZONE_IDS_CACHEKEY, (Object) zoneIDs, referenceQueue));
326         }
327 
328         return zoneIDs;
329     }
330 
331     // zoneStrings are cached separately in TimeZoneNameUtility.
332     String[][] getZoneStrings() {
333         TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
334         Set&lt;String&gt; keyset = getZoneIDs();
335         // Use a LinkedHashSet to preseve the order
336         Set&lt;String[]&gt; value = new LinkedHashSet&lt;&gt;();
337         Set&lt;String&gt; tzIds = new HashSet&lt;&gt;(Arrays.asList(TimeZone.getAvailableIDs()));
338         for (String key : keyset) {
339             if (!key.startsWith(TZNB_EXCITY_PREFIX)) {
340                 value.add(rb.getStringArray(key));
341                 tzIds.remove(key);
342             }
343         }
344 
345         if (type == LocaleProviderAdapter.Type.CLDR) {
346             // Note: TimeZoneNamesBundle creates a String[] on each getStringArray call.
347 
348             // Add timezones which are not present in this keyset,
349             // so that their fallback names will be generated at runtime.
350             tzIds.stream().filter(i -&gt; (!i.startsWith(&quot;Etc/GMT&quot;)
351                     &amp;&amp; !i.startsWith(&quot;GMT&quot;)
352                     &amp;&amp; !i.startsWith(&quot;SystemV&quot;)))
353                     .forEach(tzid -&gt; {
354                         String[] val = new String[7];
355                         if (keyset.contains(tzid)) {
356                             val = rb.getStringArray(tzid);
357                         } else {
358                             var canonID = TimeZoneNameUtility.canonicalTZID(tzid)
359                                             .orElse(tzid);
360                             if (keyset.contains(canonID)) {
361                                 val = rb.getStringArray(canonID);
362                             }
363                         }
364                         val[0] = tzid;
365                         value.add(val);
366                     });
367         }
368         return value.toArray(new String[0][]);
369     }
370 
371     String[] getCalendarNames(String key) {
372         String[] names = null;
373         String cacheKey = CALENDAR_NAMES + key;
374 
375         removeEmptyReferences();
376         ResourceReference data = cache.get(cacheKey);
377 
378         if (data == null || ((names = (String[]) data.get()) == null)) {
379             ResourceBundle rb = localeData.getDateFormatData(locale);
380             if (rb.containsKey(key)) {
381                 names = rb.getStringArray(key);
382                 cache.put(cacheKey,
383                           new ResourceReference(cacheKey, (Object) names, referenceQueue));
384             }
385         }
386 
387         return names;
388     }
389 
390     String[] getJavaTimeNames(String key) {
391         String[] names = null;
392         String cacheKey = CALENDAR_NAMES + key;
393 
394         removeEmptyReferences();
395         ResourceReference data = cache.get(cacheKey);
396 
397         if (data == null || ((names = (String[]) data.get()) == null)) {
398             ResourceBundle rb = getJavaTimeFormatData();
399             if (rb.containsKey(key)) {
400                 names = rb.getStringArray(key);
401                 cache.put(cacheKey,
402                           new ResourceReference(cacheKey, (Object) names, referenceQueue));
403             }
404         }
405 
406         return names;
407     }
408 
409     public String getDateTimePattern(int timeStyle, int dateStyle, Calendar cal) {
410         if (cal == null) {
411             cal = Calendar.getInstance(locale);
412         }
413         return getDateTimePattern(null, timeStyle, dateStyle, cal.getCalendarType());
414     }
415 
416     /**
417      * Returns a date-time format pattern
418      * @param timeStyle style of time; one of FULL, LONG, MEDIUM, SHORT in DateFormat,
419      *                  or -1 if not required
420      * @param dateStyle style of time; one of FULL, LONG, MEDIUM, SHORT in DateFormat,
421      *                  or -1 if not required
422      * @param calType   the calendar type for the pattern
423      * @return the pattern string
424      */
425     public String getJavaTimeDateTimePattern(int timeStyle, int dateStyle, String calType) {
426         calType = CalendarDataUtility.normalizeCalendarType(calType);
427         String pattern;
428         pattern = getDateTimePattern(&quot;java.time.&quot;, timeStyle, dateStyle, calType);
429         if (pattern == null) {
430             pattern = getDateTimePattern(null, timeStyle, dateStyle, calType);
431         }
432         return pattern;
433     }
434 
435     private String getDateTimePattern(String prefix, int timeStyle, int dateStyle, String calType) {
436         String pattern;
437         String timePattern = null;
438         String datePattern = null;
439 
440         if (timeStyle &gt;= 0) {
441             if (prefix != null) {
442                 timePattern = getDateTimePattern(prefix, &quot;TimePatterns&quot;, timeStyle, calType);
443             }
444             if (timePattern == null) {
445                 timePattern = getDateTimePattern(null, &quot;TimePatterns&quot;, timeStyle, calType);
446             }
447         }
448         if (dateStyle &gt;= 0) {
449             if (prefix != null) {
450                 datePattern = getDateTimePattern(prefix, &quot;DatePatterns&quot;, dateStyle, calType);
451             }
452             if (datePattern == null) {
453                 datePattern = getDateTimePattern(null, &quot;DatePatterns&quot;, dateStyle, calType);
454             }
455         }
456         if (timeStyle &gt;= 0) {
457             if (dateStyle &gt;= 0) {
458                 String dateTimePattern = null;
459                 int dateTimeStyle = Math.max(dateStyle, timeStyle);
460                 if (prefix != null) {
461                     dateTimePattern = getDateTimePattern(prefix, &quot;DateTimePatterns&quot;, dateTimeStyle, calType);
462                 }
463                 if (dateTimePattern == null) {
464                     dateTimePattern = getDateTimePattern(null, &quot;DateTimePatterns&quot;, dateTimeStyle, calType);
465                 }
466                 switch (dateTimePattern) {
467                 case &quot;{1} {0}&quot;:
468                     pattern = datePattern + &quot; &quot; + timePattern;
469                     break;
470                 case &quot;{0} {1}&quot;:
471                     pattern = timePattern + &quot; &quot; + datePattern;
472                     break;
473                 default:
474                     pattern = MessageFormat.format(dateTimePattern.replaceAll(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;), timePattern, datePattern);
475                     break;
476                 }
477             } else {
478                 pattern = timePattern;
479             }
480         } else if (dateStyle &gt;= 0) {
481             pattern = datePattern;
482         } else {
483             throw new IllegalArgumentException(&quot;No date or time style specified&quot;);
484         }
485         return pattern;
486     }
487 
488     public String[] getNumberPatterns() {
489         String[] numberPatterns = null;
490 
491         removeEmptyReferences();
492         ResourceReference data = cache.get(NUMBER_PATTERNS_CACHEKEY);
493 
494         if (data == null || ((numberPatterns = (String[]) data.get()) == null)) {
495             ResourceBundle resource = localeData.getNumberFormatData(locale);
496             numberPatterns = getNumberStrings(resource, &quot;NumberPatterns&quot;);
497             cache.put(NUMBER_PATTERNS_CACHEKEY,
498                       new ResourceReference(NUMBER_PATTERNS_CACHEKEY, (Object) numberPatterns, referenceQueue));
499         }
500 
501         return numberPatterns;
502     }
503 
504     /**
505      * Returns the compact number format patterns.
506      * @param formatStyle the style for formatting a number
507      * @return an array of compact number patterns
508      */
509     @SuppressWarnings(&quot;unchecked&quot;)
510     public String[] getCNPatterns(NumberFormat.Style formatStyle) {
511 
512         Objects.requireNonNull(formatStyle);
513         String[] compactNumberPatterns = null;
514         removeEmptyReferences();
515         String width = (formatStyle == NumberFormat.Style.LONG) ? &quot;long&quot; : &quot;short&quot;;
516         String cacheKey = width + &quot;.&quot; + COMPACT_NUMBER_PATTERNS_CACHEKEY;
517         ResourceReference data = cache.get(cacheKey);
518         if (data == null || ((compactNumberPatterns
519                 = (String[]) data.get()) == null)) {
520             ResourceBundle resource = localeData.getNumberFormatData(locale);
521             compactNumberPatterns = (String[]) resource
522                     .getObject(width + &quot;.CompactNumberPatterns&quot;);
523             cache.put(cacheKey, new ResourceReference(cacheKey,
524                     (Object) compactNumberPatterns, referenceQueue));
525         }
526         return compactNumberPatterns;
527     }
528 
529 
530     /**
531      * Returns the FormatData resource bundle of this LocaleResources.
532      * The FormatData should be used only for accessing extra
533      * resources required by JSR 310.
534      */
535     public ResourceBundle getJavaTimeFormatData() {
536         ResourceBundle rb = localeData.getDateFormatData(locale);
537         if (rb instanceof ParallelListResourceBundle) {
538             localeData.setSupplementary((ParallelListResourceBundle) rb);
539         }
540         return rb;
541     }
542 
543     private String getDateTimePattern(String prefix, String key, int styleIndex, String calendarType) {
544         StringBuilder sb = new StringBuilder();
545         if (prefix != null) {
546             sb.append(prefix);
547         }
548         if (!&quot;gregory&quot;.equals(calendarType)) {
549             sb.append(calendarType).append(&#39;.&#39;);
550         }
551         sb.append(key);
552         String resourceKey = sb.toString();
553         String cacheKey = sb.insert(0, DATE_TIME_PATTERN).toString();
554 
555         removeEmptyReferences();
556         ResourceReference data = cache.get(cacheKey);
557         Object value = NULLOBJECT;
558 
559         if (data == null || ((value = data.get()) == null)) {
560             ResourceBundle r = (prefix != null) ? getJavaTimeFormatData() : localeData.getDateFormatData(locale);
561             if (r.containsKey(resourceKey)) {
562                 value = r.getStringArray(resourceKey);
563             } else {
564                 assert !resourceKey.equals(key);
565                 if (r.containsKey(key)) {
566                     value = r.getStringArray(key);
567                 }
568             }
569             cache.put(cacheKey,
570                       new ResourceReference(cacheKey, value, referenceQueue));
571         }
572         if (value == NULLOBJECT) {
573             assert prefix != null;
574             return null;
575         }
576 
577         // for DateTimePatterns. CLDR has multiple styles, while JRE has one.
578         String[] styles = (String[])value;
579         return (styles.length &gt; 1 ? styles[styleIndex] : styles[0]);
580     }
581 
582     private static class ResourceReference extends SoftReference&lt;Object&gt; {
583         private final String cacheKey;
584 
585         ResourceReference(String cacheKey, Object o, ReferenceQueue&lt;Object&gt; q) {
586             super(o, q);
587             this.cacheKey = cacheKey;
588         }
589 
590         String getCacheKey() {
591             return cacheKey;
592         }
593     }
594 
595     private static final boolean TRACE_ON = Boolean.valueOf(
596         GetPropertyAction.privilegedGetProperty(&quot;locale.resources.debug&quot;, &quot;false&quot;));
597 
598     public static void trace(String format, Object... params) {
599         if (TRACE_ON) {
600             System.out.format(format, params);
601         }
602     }
603 }
    </pre>
  </body>
</html>
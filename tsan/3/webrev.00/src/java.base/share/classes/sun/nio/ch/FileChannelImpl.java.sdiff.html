<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="IOStatus.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;

  45 
  46 import jdk.internal.access.JavaIOFileDescriptorAccess;
  47 import jdk.internal.access.JavaNioAccess;
  48 import jdk.internal.access.SharedSecrets;



  49 import jdk.internal.ref.Cleaner;
  50 import jdk.internal.ref.CleanerFactory;
  51 


  52 public class FileChannelImpl
  53     extends FileChannel
  54 {
  55     // Memory allocation size for mapping buffers
  56     private static final long allocationGranularity;
  57 
  58     // Access to FileDescriptor internals
  59     private static final JavaIOFileDescriptorAccess fdAccess =
  60         SharedSecrets.getJavaIOFileDescriptorAccess();
  61 
  62     // Used to make native read and write calls
  63     private final FileDispatcher nd;
  64 
  65     // File descriptor
  66     private final FileDescriptor fd;
  67 
  68     // File access mode (immutable)
  69     private final boolean writable;
  70     private final boolean readable;
  71 
</pre>
<hr />
<pre>
 843         int ti = -1;
 844         try {
 845             beginBlocking();
 846             ti = threads.add();
 847             if (!isOpen())
 848                 return -1;
 849             do {
 850                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
 851             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 852             return IOStatus.normalize(n);
 853         } finally {
 854             threads.remove(ti);
 855             endBlocking(n &gt; 0);
 856             assert IOStatus.check(n);
 857         }
 858     }
 859 
 860 
 861     // -- Memory-mapped buffers --
 862 
<span class="line-modified"> 863     private static class Unmapper</span>
<span class="line-modified"> 864         implements Runnable</span>
 865     {
 866         // may be required to close file
 867         private static final NativeDispatcher nd = new FileDispatcherImpl();
 868 
<span class="line-removed"> 869         // keep track of mapped buffer usage</span>
<span class="line-removed"> 870         static volatile int count;</span>
<span class="line-removed"> 871         static volatile long totalSize;</span>
<span class="line-removed"> 872         static volatile long totalCapacity;</span>
<span class="line-removed"> 873 </span>
 874         private volatile long address;
<span class="line-modified"> 875         private final long size;</span>
<span class="line-modified"> 876         private final int cap;</span>
 877         private final FileDescriptor fd;

 878 
<span class="line-modified"> 879         private Unmapper(long address, long size, int cap,</span>
<span class="line-modified"> 880                          FileDescriptor fd)</span>
 881         {
 882             assert (address != 0);
 883             this.address = address;
 884             this.size = size;
 885             this.cap = cap;
 886             this.fd = fd;


 887 
<span class="line-modified"> 888             synchronized (Unmapper.class) {</span>
<span class="line-modified"> 889                 count++;</span>
<span class="line-modified"> 890                 totalSize += size;</span>
<span class="line-removed"> 891                 totalCapacity += cap;</span>
<span class="line-removed"> 892             }</span>
 893         }
 894 

 895         public void run() {




 896             if (address == 0)
 897                 return;
 898             unmap0(address, size);
 899             address = 0;
 900 
 901             // if this mapping has a valid file descriptor then we close it
 902             if (fd.valid()) {
 903                 try {
 904                     nd.close(fd);
 905                 } catch (IOException ignore) {
 906                     // nothing we can do
 907                 }
 908             }
 909 
<span class="line-modified"> 910             synchronized (Unmapper.class) {</span>
























































 911                 count--;
 912                 totalSize -= size;
 913                 totalCapacity -= cap;
 914             }
 915         }
 916     }
 917 
 918     private static void unmap(MappedByteBuffer bb) {
 919         Cleaner cl = ((DirectBuffer)bb).cleaner();
 920         if (cl != null)
 921             cl.clean();
 922     }
 923 

 924     private static final int MAP_RO = 0;
 925     private static final int MAP_RW = 1;
 926     private static final int MAP_PV = 2;
 927 
<span class="line-modified"> 928     public MappedByteBuffer map(MapMode mode, long position, long size)</span>
































 929         throws IOException
 930     {
 931         ensureOpen();
 932         if (mode == null)
 933             throw new NullPointerException(&quot;Mode is null&quot;);
 934         if (position &lt; 0L)
 935             throw new IllegalArgumentException(&quot;Negative position&quot;);
 936         if (size &lt; 0L)
 937             throw new IllegalArgumentException(&quot;Negative size&quot;);
 938         if (position + size &lt; 0)
 939             throw new IllegalArgumentException(&quot;Position + size overflow&quot;);
<span class="line-removed"> 940         if (size &gt; Integer.MAX_VALUE)</span>
<span class="line-removed"> 941             throw new IllegalArgumentException(&quot;Size exceeds Integer.MAX_VALUE&quot;);</span>
<span class="line-removed"> 942 </span>
<span class="line-removed"> 943         int imode = -1;</span>
<span class="line-removed"> 944         if (mode == MapMode.READ_ONLY)</span>
<span class="line-removed"> 945             imode = MAP_RO;</span>
<span class="line-removed"> 946         else if (mode == MapMode.READ_WRITE)</span>
<span class="line-removed"> 947             imode = MAP_RW;</span>
<span class="line-removed"> 948         else if (mode == MapMode.PRIVATE)</span>
<span class="line-removed"> 949             imode = MAP_PV;</span>
<span class="line-removed"> 950         assert (imode &gt;= 0);</span>
<span class="line-removed"> 951         if ((mode != MapMode.READ_ONLY) &amp;&amp; !writable)</span>
<span class="line-removed"> 952             throw new NonWritableChannelException();</span>
<span class="line-removed"> 953         if (!readable)</span>
<span class="line-removed"> 954             throw new NonReadableChannelException();</span>
 955 

 956         long addr = -1;
 957         int ti = -1;
 958         try {
 959             beginBlocking();
 960             ti = threads.add();
 961             if (!isOpen())
 962                 return null;
 963 
 964             long mapSize;
 965             int pagePosition;
 966             synchronized (positionLock) {
 967                 long filesize;
 968                 do {
 969                     filesize = nd.size(fd);
 970                 } while ((filesize == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 971                 if (!isOpen())
 972                     return null;
 973 
 974                 if (filesize &lt; position + size) { // Extend file size
 975                     if (!writable) {
 976                         throw new IOException(&quot;Channel not open for writing &quot; +
 977                             &quot;- cannot extend file to required size&quot;);
 978                     }
 979                     int rv;
 980                     do {
 981                         rv = nd.truncate(fd, position + size);
 982                     } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 983                     if (!isOpen())
 984                         return null;
 985                 }
 986 
 987                 if (size == 0) {
<span class="line-modified"> 988                     addr = 0;</span>
<span class="line-removed"> 989                     // a valid file descriptor is not required</span>
<span class="line-removed"> 990                     FileDescriptor dummy = new FileDescriptor();</span>
<span class="line-removed"> 991                     if ((!writable) || (imode == MAP_RO))</span>
<span class="line-removed"> 992                         return Util.newMappedByteBufferR(0, 0, dummy, null);</span>
<span class="line-removed"> 993                     else</span>
<span class="line-removed"> 994                         return Util.newMappedByteBuffer(0, 0, dummy, null);</span>
 995                 }
 996 
 997                 pagePosition = (int)(position % allocationGranularity);
 998                 long mapPosition = position - pagePosition;
 999                 mapSize = size + pagePosition;
1000                 try {
1001                     // If map0 did not throw an exception, the address is valid
<span class="line-modified">1002                     addr = map0(imode, mapPosition, mapSize);</span>
1003                 } catch (OutOfMemoryError x) {
1004                     // An OutOfMemoryError may indicate that we&#39;ve exhausted
1005                     // memory so force gc and re-attempt map
1006                     System.gc();
1007                     try {
1008                         Thread.sleep(100);
1009                     } catch (InterruptedException y) {
1010                         Thread.currentThread().interrupt();
1011                     }
1012                     try {
<span class="line-modified">1013                         addr = map0(imode, mapPosition, mapSize);</span>
1014                     } catch (OutOfMemoryError y) {
1015                         // After a second OOME, fail
1016                         throw new IOException(&quot;Map failed&quot;, y);
1017                     }
1018                 }
1019             } // synchronized
1020 
1021             // On Windows, and potentially other platforms, we need an open
1022             // file descriptor for some mapping operations.
1023             FileDescriptor mfd;
1024             try {
1025                 mfd = nd.duplicateForMapping(fd);
1026             } catch (IOException ioe) {
1027                 unmap0(addr, mapSize);
1028                 throw ioe;
1029             }
1030 
1031             assert (IOStatus.checkAll(addr));
1032             assert (addr % allocationGranularity == 0);
<span class="line-modified">1033             int isize = (int)size;</span>
<span class="line-modified">1034             Unmapper um = new Unmapper(addr, mapSize, isize, mfd);</span>
<span class="line-modified">1035             if ((!writable) || (imode == MAP_RO)) {</span>
<span class="line-modified">1036                 return Util.newMappedByteBufferR(isize,</span>
<span class="line-removed">1037                                                  addr + pagePosition,</span>
<span class="line-removed">1038                                                  mfd,</span>
<span class="line-removed">1039                                                  um);</span>
<span class="line-removed">1040             } else {</span>
<span class="line-removed">1041                 return Util.newMappedByteBuffer(isize,</span>
<span class="line-removed">1042                                                 addr + pagePosition,</span>
<span class="line-removed">1043                                                 mfd,</span>
<span class="line-removed">1044                                                 um);</span>
<span class="line-removed">1045             }</span>
1046         } finally {
1047             threads.remove(ti);
1048             endBlocking(IOStatus.checkAll(addr));
1049         }
1050     }
1051 








































1052     /**
1053      * Invoked by sun.management.ManagementFactoryHelper to create the management
1054      * interface for mapped buffers.
1055      */
1056     public static JavaNioAccess.BufferPool getMappedBufferPool() {
1057         return new JavaNioAccess.BufferPool() {
1058             @Override
1059             public String getName() {
1060                 return &quot;mapped&quot;;
1061             }
1062             @Override
1063             public long getCount() {
<span class="line-modified">1064                 return Unmapper.count;</span>

























1065             }
1066             @Override
1067             public long getTotalCapacity() {
<span class="line-modified">1068                 return Unmapper.totalCapacity;</span>
1069             }
1070             @Override
1071             public long getMemoryUsed() {
<span class="line-modified">1072                 return Unmapper.totalSize;</span>
1073             }
1074         };
1075     }
1076 
1077     // -- Locks --
1078 
1079     // keeps track of locks on this file
1080     private volatile FileLockTable fileLockTable;
1081 
1082     private FileLockTable fileLockTable() throws IOException {
1083         if (fileLockTable == null) {
1084             synchronized (this) {
1085                 if (fileLockTable == null) {
1086                     int ti = threads.add();
1087                     try {
1088                         ensureOpen();
1089                         fileLockTable = new FileLockTable(this, fd);
1090                     } finally {
1091                         threads.remove(ti);
1092                     }
</pre>
<hr />
<pre>
1178         } finally {
1179             threads.remove(ti);
1180         }
1181     }
1182 
1183     void release(FileLockImpl fli) throws IOException {
1184         int ti = threads.add();
1185         try {
1186             ensureOpen();
1187             nd.release(fd, fli.position(), fli.size());
1188         } finally {
1189             threads.remove(ti);
1190         }
1191         assert fileLockTable != null;
1192         fileLockTable.remove(fli);
1193     }
1194 
1195     // -- Native methods --
1196 
1197     // Creates a new mapping
<span class="line-modified">1198     private native long map0(int prot, long position, long length)</span>
1199         throws IOException;
1200 
1201     // Removes an existing mapping
1202     private static native int unmap0(long address, long length);
1203 
1204     // Transfers from src to dst, or returns -2 if kernel can&#39;t do that
1205     private native long transferTo0(FileDescriptor src, long position,
1206                                     long count, FileDescriptor dst);
1207 
1208     // Caches fieldIDs
1209     private static native long initIDs();
1210 
1211     static {
1212         IOUtil.load();
1213         allocationGranularity = initIDs();
1214     }
1215 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.ref.Cleaner.Cleanable;
  32 import java.nio.ByteBuffer;
  33 import java.nio.MappedByteBuffer;
  34 import java.nio.channels.AsynchronousCloseException;
  35 import java.nio.channels.ClosedByInterruptException;
  36 import java.nio.channels.ClosedChannelException;
  37 import java.nio.channels.FileChannel;
  38 import java.nio.channels.FileLock;
  39 import java.nio.channels.FileLockInterruptionException;
  40 import java.nio.channels.NonReadableChannelException;
  41 import java.nio.channels.NonWritableChannelException;
  42 import java.nio.channels.ReadableByteChannel;
  43 import java.nio.channels.SelectableChannel;
  44 import java.nio.channels.WritableByteChannel;
<span class="line-added">  45 import java.util.Objects;</span>
  46 
  47 import jdk.internal.access.JavaIOFileDescriptorAccess;
  48 import jdk.internal.access.JavaNioAccess;
  49 import jdk.internal.access.SharedSecrets;
<span class="line-added">  50 import jdk.internal.misc.ExtendedMapMode;</span>
<span class="line-added">  51 import jdk.internal.misc.Unsafe;</span>
<span class="line-added">  52 import jdk.internal.misc.VM;</span>
  53 import jdk.internal.ref.Cleaner;
  54 import jdk.internal.ref.CleanerFactory;
  55 
<span class="line-added">  56 import jdk.internal.access.foreign.UnmapperProxy;</span>
<span class="line-added">  57 </span>
  58 public class FileChannelImpl
  59     extends FileChannel
  60 {
  61     // Memory allocation size for mapping buffers
  62     private static final long allocationGranularity;
  63 
  64     // Access to FileDescriptor internals
  65     private static final JavaIOFileDescriptorAccess fdAccess =
  66         SharedSecrets.getJavaIOFileDescriptorAccess();
  67 
  68     // Used to make native read and write calls
  69     private final FileDispatcher nd;
  70 
  71     // File descriptor
  72     private final FileDescriptor fd;
  73 
  74     // File access mode (immutable)
  75     private final boolean writable;
  76     private final boolean readable;
  77 
</pre>
<hr />
<pre>
 849         int ti = -1;
 850         try {
 851             beginBlocking();
 852             ti = threads.add();
 853             if (!isOpen())
 854                 return -1;
 855             do {
 856                 n = IOUtil.write(fd, src, position, direct, alignment, nd);
 857             } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 858             return IOStatus.normalize(n);
 859         } finally {
 860             threads.remove(ti);
 861             endBlocking(n &gt; 0);
 862             assert IOStatus.check(n);
 863         }
 864     }
 865 
 866 
 867     // -- Memory-mapped buffers --
 868 
<span class="line-modified"> 869     private static abstract class Unmapper</span>
<span class="line-modified"> 870         implements Runnable, UnmapperProxy</span>
 871     {
 872         // may be required to close file
 873         private static final NativeDispatcher nd = new FileDispatcherImpl();
 874 





 875         private volatile long address;
<span class="line-modified"> 876         protected final long size;</span>
<span class="line-modified"> 877         protected final long cap;</span>
 878         private final FileDescriptor fd;
<span class="line-added"> 879         private final int pagePosition;</span>
 880 
<span class="line-modified"> 881         private Unmapper(long address, long size, long cap,</span>
<span class="line-modified"> 882                          FileDescriptor fd, int pagePosition)</span>
 883         {
 884             assert (address != 0);
 885             this.address = address;
 886             this.size = size;
 887             this.cap = cap;
 888             this.fd = fd;
<span class="line-added"> 889             this.pagePosition = pagePosition;</span>
<span class="line-added"> 890         }</span>
 891 
<span class="line-modified"> 892         @Override</span>
<span class="line-modified"> 893         public long address() {</span>
<span class="line-modified"> 894             return address;</span>


 895         }
 896 
<span class="line-added"> 897         @Override</span>
 898         public void run() {
<span class="line-added"> 899             unmap();</span>
<span class="line-added"> 900         }</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902         public void unmap() {</span>
 903             if (address == 0)
 904                 return;
 905             unmap0(address, size);
 906             address = 0;
 907 
 908             // if this mapping has a valid file descriptor then we close it
 909             if (fd.valid()) {
 910                 try {
 911                     nd.close(fd);
 912                 } catch (IOException ignore) {
 913                     // nothing we can do
 914                 }
 915             }
 916 
<span class="line-modified"> 917             decrementStats();</span>
<span class="line-added"> 918         }</span>
<span class="line-added"> 919         protected abstract void incrementStats();</span>
<span class="line-added"> 920         protected abstract void decrementStats();</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     private static class DefaultUnmapper extends Unmapper {</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925         // keep track of non-sync mapped buffer usage</span>
<span class="line-added"> 926         static volatile int count;</span>
<span class="line-added"> 927         static volatile long totalSize;</span>
<span class="line-added"> 928         static volatile long totalCapacity;</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930         public DefaultUnmapper(long address, long size, long cap,</span>
<span class="line-added"> 931                                FileDescriptor fd, int pagePosition) {</span>
<span class="line-added"> 932             super(address, size, cap, fd, pagePosition);</span>
<span class="line-added"> 933             incrementStats();</span>
<span class="line-added"> 934         }</span>
<span class="line-added"> 935 </span>
<span class="line-added"> 936         protected void incrementStats() {</span>
<span class="line-added"> 937             synchronized (DefaultUnmapper.class) {</span>
<span class="line-added"> 938                 count++;</span>
<span class="line-added"> 939                 totalSize += size;</span>
<span class="line-added"> 940                 totalCapacity += cap;</span>
<span class="line-added"> 941             }</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943         protected void decrementStats() {</span>
<span class="line-added"> 944             synchronized (DefaultUnmapper.class) {</span>
<span class="line-added"> 945                 count--;</span>
<span class="line-added"> 946                 totalSize -= size;</span>
<span class="line-added"> 947                 totalCapacity -= cap;</span>
<span class="line-added"> 948             }</span>
<span class="line-added"> 949         }</span>
<span class="line-added"> 950     }</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952     private static class SyncUnmapper extends Unmapper {</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954         // keep track of mapped buffer usage</span>
<span class="line-added"> 955         static volatile int count;</span>
<span class="line-added"> 956         static volatile long totalSize;</span>
<span class="line-added"> 957         static volatile long totalCapacity;</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959         public SyncUnmapper(long address, long size, long cap,</span>
<span class="line-added"> 960                             FileDescriptor fd, int pagePosition) {</span>
<span class="line-added"> 961             super(address, size, cap, fd, pagePosition);</span>
<span class="line-added"> 962             incrementStats();</span>
<span class="line-added"> 963         }</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965         protected void incrementStats() {</span>
<span class="line-added"> 966             synchronized (SyncUnmapper.class) {</span>
<span class="line-added"> 967                 count++;</span>
<span class="line-added"> 968                 totalSize += size;</span>
<span class="line-added"> 969                 totalCapacity += cap;</span>
<span class="line-added"> 970             }</span>
<span class="line-added"> 971         }</span>
<span class="line-added"> 972         protected void decrementStats() {</span>
<span class="line-added"> 973             synchronized (SyncUnmapper.class) {</span>
 974                 count--;
 975                 totalSize -= size;
 976                 totalCapacity -= cap;
 977             }
 978         }
 979     }
 980 
 981     private static void unmap(MappedByteBuffer bb) {
 982         Cleaner cl = ((DirectBuffer)bb).cleaner();
 983         if (cl != null)
 984             cl.clean();
 985     }
 986 
<span class="line-added"> 987     private static final int MAP_INVALID = -1;</span>
 988     private static final int MAP_RO = 0;
 989     private static final int MAP_RW = 1;
 990     private static final int MAP_PV = 2;
 991 
<span class="line-modified"> 992     public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {</span>
<span class="line-added"> 993         if (size &gt; Integer.MAX_VALUE)</span>
<span class="line-added"> 994             throw new IllegalArgumentException(&quot;Size exceeds Integer.MAX_VALUE&quot;);</span>
<span class="line-added"> 995         boolean isSync = isSync(Objects.requireNonNull(mode, &quot;Mode is null&quot;));</span>
<span class="line-added"> 996         int prot = toProt(mode);</span>
<span class="line-added"> 997         Unmapper unmapper = mapInternal(mode, position, size, prot, isSync);</span>
<span class="line-added"> 998         if (unmapper == null) {</span>
<span class="line-added"> 999             // a valid file descriptor is not required</span>
<span class="line-added">1000             FileDescriptor dummy = new FileDescriptor();</span>
<span class="line-added">1001             if ((!writable) || (prot == MAP_RO))</span>
<span class="line-added">1002                 return Util.newMappedByteBufferR(0, 0, dummy, null, isSync);</span>
<span class="line-added">1003             else</span>
<span class="line-added">1004                 return Util.newMappedByteBuffer(0, 0, dummy, null, isSync);</span>
<span class="line-added">1005         } else if ((!writable) || (prot == MAP_RO)) {</span>
<span class="line-added">1006             return Util.newMappedByteBufferR((int)unmapper.cap,</span>
<span class="line-added">1007                     unmapper.address + unmapper.pagePosition,</span>
<span class="line-added">1008                     unmapper.fd,</span>
<span class="line-added">1009                     unmapper, isSync);</span>
<span class="line-added">1010         } else {</span>
<span class="line-added">1011             return Util.newMappedByteBuffer((int)unmapper.cap,</span>
<span class="line-added">1012                     unmapper.address + unmapper.pagePosition,</span>
<span class="line-added">1013                     unmapper.fd,</span>
<span class="line-added">1014                     unmapper, isSync);</span>
<span class="line-added">1015         }</span>
<span class="line-added">1016     }</span>
<span class="line-added">1017 </span>
<span class="line-added">1018     public Unmapper mapInternal(MapMode mode, long position, long size) throws IOException {</span>
<span class="line-added">1019         boolean isSync = isSync(Objects.requireNonNull(mode, &quot;Mode is null&quot;));</span>
<span class="line-added">1020         int prot = toProt(mode);</span>
<span class="line-added">1021         return mapInternal(mode, position, size, prot, isSync);</span>
<span class="line-added">1022     }</span>
<span class="line-added">1023 </span>
<span class="line-added">1024     private Unmapper mapInternal(MapMode mode, long position, long size, int prot, boolean isSync)</span>
1025         throws IOException
1026     {
1027         ensureOpen();
1028         if (mode == null)
1029             throw new NullPointerException(&quot;Mode is null&quot;);
1030         if (position &lt; 0L)
1031             throw new IllegalArgumentException(&quot;Negative position&quot;);
1032         if (size &lt; 0L)
1033             throw new IllegalArgumentException(&quot;Negative size&quot;);
1034         if (position + size &lt; 0)
1035             throw new IllegalArgumentException(&quot;Position + size overflow&quot;);















1036 
<span class="line-added">1037         checkMode(mode, prot, isSync);</span>
1038         long addr = -1;
1039         int ti = -1;
1040         try {
1041             beginBlocking();
1042             ti = threads.add();
1043             if (!isOpen())
1044                 return null;
1045 
1046             long mapSize;
1047             int pagePosition;
1048             synchronized (positionLock) {
1049                 long filesize;
1050                 do {
1051                     filesize = nd.size(fd);
1052                 } while ((filesize == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
1053                 if (!isOpen())
1054                     return null;
1055 
1056                 if (filesize &lt; position + size) { // Extend file size
1057                     if (!writable) {
1058                         throw new IOException(&quot;Channel not open for writing &quot; +
1059                             &quot;- cannot extend file to required size&quot;);
1060                     }
1061                     int rv;
1062                     do {
1063                         rv = nd.truncate(fd, position + size);
1064                     } while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
1065                     if (!isOpen())
1066                         return null;
1067                 }
1068 
1069                 if (size == 0) {
<span class="line-modified">1070                     return null;</span>






1071                 }
1072 
1073                 pagePosition = (int)(position % allocationGranularity);
1074                 long mapPosition = position - pagePosition;
1075                 mapSize = size + pagePosition;
1076                 try {
1077                     // If map0 did not throw an exception, the address is valid
<span class="line-modified">1078                     addr = map0(prot, mapPosition, mapSize, isSync);</span>
1079                 } catch (OutOfMemoryError x) {
1080                     // An OutOfMemoryError may indicate that we&#39;ve exhausted
1081                     // memory so force gc and re-attempt map
1082                     System.gc();
1083                     try {
1084                         Thread.sleep(100);
1085                     } catch (InterruptedException y) {
1086                         Thread.currentThread().interrupt();
1087                     }
1088                     try {
<span class="line-modified">1089                         addr = map0(prot, mapPosition, mapSize, isSync);</span>
1090                     } catch (OutOfMemoryError y) {
1091                         // After a second OOME, fail
1092                         throw new IOException(&quot;Map failed&quot;, y);
1093                     }
1094                 }
1095             } // synchronized
1096 
1097             // On Windows, and potentially other platforms, we need an open
1098             // file descriptor for some mapping operations.
1099             FileDescriptor mfd;
1100             try {
1101                 mfd = nd.duplicateForMapping(fd);
1102             } catch (IOException ioe) {
1103                 unmap0(addr, mapSize);
1104                 throw ioe;
1105             }
1106 
1107             assert (IOStatus.checkAll(addr));
1108             assert (addr % allocationGranularity == 0);
<span class="line-modified">1109             Unmapper um = (isSync</span>
<span class="line-modified">1110                            ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)</span>
<span class="line-modified">1111                            : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));</span>
<span class="line-modified">1112             return um;</span>









1113         } finally {
1114             threads.remove(ti);
1115             endBlocking(IOStatus.checkAll(addr));
1116         }
1117     }
1118 
<span class="line-added">1119     private boolean isSync(MapMode mode) {</span>
<span class="line-added">1120         // Do not want to initialize ExtendedMapMode until</span>
<span class="line-added">1121         // after the module system has been initialized</span>
<span class="line-added">1122         return !VM.isModuleSystemInited() ? false :</span>
<span class="line-added">1123             (mode == ExtendedMapMode.READ_ONLY_SYNC ||</span>
<span class="line-added">1124                 mode == ExtendedMapMode.READ_WRITE_SYNC);</span>
<span class="line-added">1125     }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127     private int toProt(MapMode mode) {</span>
<span class="line-added">1128         int prot;</span>
<span class="line-added">1129         if (mode == MapMode.READ_ONLY) {</span>
<span class="line-added">1130             prot = MAP_RO;</span>
<span class="line-added">1131         } else if (mode == MapMode.READ_WRITE) {</span>
<span class="line-added">1132             prot = MAP_RW;</span>
<span class="line-added">1133         } else if (mode == MapMode.PRIVATE) {</span>
<span class="line-added">1134             prot = MAP_PV;</span>
<span class="line-added">1135         } else if (mode == ExtendedMapMode.READ_ONLY_SYNC) {</span>
<span class="line-added">1136             prot = MAP_RO;</span>
<span class="line-added">1137         } else if (mode == ExtendedMapMode.READ_WRITE_SYNC) {</span>
<span class="line-added">1138             prot = MAP_RW;</span>
<span class="line-added">1139         } else {</span>
<span class="line-added">1140             prot = MAP_INVALID;</span>
<span class="line-added">1141         }</span>
<span class="line-added">1142         return prot;</span>
<span class="line-added">1143     }</span>
<span class="line-added">1144 </span>
<span class="line-added">1145     private void checkMode(MapMode mode, int prot, boolean isSync) {</span>
<span class="line-added">1146         if (prot == MAP_INVALID) {</span>
<span class="line-added">1147             throw new UnsupportedOperationException();</span>
<span class="line-added">1148         }</span>
<span class="line-added">1149         if ((mode != MapMode.READ_ONLY) &amp;&amp; mode != ExtendedMapMode.READ_ONLY_SYNC &amp;&amp; !writable)</span>
<span class="line-added">1150             throw new NonWritableChannelException();</span>
<span class="line-added">1151         if (!readable)</span>
<span class="line-added">1152             throw new NonReadableChannelException();</span>
<span class="line-added">1153         // reject SYNC request if writeback is not enabled for this platform</span>
<span class="line-added">1154         if (isSync &amp;&amp; !Unsafe.isWritebackEnabled()) {</span>
<span class="line-added">1155             throw new UnsupportedOperationException();</span>
<span class="line-added">1156         }</span>
<span class="line-added">1157     }</span>
<span class="line-added">1158 </span>
1159     /**
1160      * Invoked by sun.management.ManagementFactoryHelper to create the management
1161      * interface for mapped buffers.
1162      */
1163     public static JavaNioAccess.BufferPool getMappedBufferPool() {
1164         return new JavaNioAccess.BufferPool() {
1165             @Override
1166             public String getName() {
1167                 return &quot;mapped&quot;;
1168             }
1169             @Override
1170             public long getCount() {
<span class="line-modified">1171                 return DefaultUnmapper.count;</span>
<span class="line-added">1172             }</span>
<span class="line-added">1173             @Override</span>
<span class="line-added">1174             public long getTotalCapacity() {</span>
<span class="line-added">1175                 return DefaultUnmapper.totalCapacity;</span>
<span class="line-added">1176             }</span>
<span class="line-added">1177             @Override</span>
<span class="line-added">1178             public long getMemoryUsed() {</span>
<span class="line-added">1179                 return DefaultUnmapper.totalSize;</span>
<span class="line-added">1180             }</span>
<span class="line-added">1181         };</span>
<span class="line-added">1182     }</span>
<span class="line-added">1183 </span>
<span class="line-added">1184     /**</span>
<span class="line-added">1185      * Invoked by sun.management.ManagementFactoryHelper to create the management</span>
<span class="line-added">1186      * interface for sync mapped buffers.</span>
<span class="line-added">1187      */</span>
<span class="line-added">1188     public static JavaNioAccess.BufferPool getSyncMappedBufferPool() {</span>
<span class="line-added">1189         return new JavaNioAccess.BufferPool() {</span>
<span class="line-added">1190             @Override</span>
<span class="line-added">1191             public String getName() {</span>
<span class="line-added">1192                 return &quot;mapped - &#39;non-volatile memory&#39;&quot;;</span>
<span class="line-added">1193             }</span>
<span class="line-added">1194             @Override</span>
<span class="line-added">1195             public long getCount() {</span>
<span class="line-added">1196                 return SyncUnmapper.count;</span>
1197             }
1198             @Override
1199             public long getTotalCapacity() {
<span class="line-modified">1200                 return SyncUnmapper.totalCapacity;</span>
1201             }
1202             @Override
1203             public long getMemoryUsed() {
<span class="line-modified">1204                 return SyncUnmapper.totalSize;</span>
1205             }
1206         };
1207     }
1208 
1209     // -- Locks --
1210 
1211     // keeps track of locks on this file
1212     private volatile FileLockTable fileLockTable;
1213 
1214     private FileLockTable fileLockTable() throws IOException {
1215         if (fileLockTable == null) {
1216             synchronized (this) {
1217                 if (fileLockTable == null) {
1218                     int ti = threads.add();
1219                     try {
1220                         ensureOpen();
1221                         fileLockTable = new FileLockTable(this, fd);
1222                     } finally {
1223                         threads.remove(ti);
1224                     }
</pre>
<hr />
<pre>
1310         } finally {
1311             threads.remove(ti);
1312         }
1313     }
1314 
1315     void release(FileLockImpl fli) throws IOException {
1316         int ti = threads.add();
1317         try {
1318             ensureOpen();
1319             nd.release(fd, fli.position(), fli.size());
1320         } finally {
1321             threads.remove(ti);
1322         }
1323         assert fileLockTable != null;
1324         fileLockTable.remove(fli);
1325     }
1326 
1327     // -- Native methods --
1328 
1329     // Creates a new mapping
<span class="line-modified">1330     private native long map0(int prot, long position, long length, boolean isSync)</span>
1331         throws IOException;
1332 
1333     // Removes an existing mapping
1334     private static native int unmap0(long address, long length);
1335 
1336     // Transfers from src to dst, or returns -2 if kernel can&#39;t do that
1337     private native long transferTo0(FileDescriptor src, long position,
1338                                     long count, FileDescriptor dst);
1339 
1340     // Caches fieldIDs
1341     private static native long initIDs();
1342 
1343     static {
1344         IOUtil.load();
1345         allocationGranularity = initIDs();
1346     }
1347 }
</pre>
</td>
</tr>
</table>
<center><a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="IOStatus.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
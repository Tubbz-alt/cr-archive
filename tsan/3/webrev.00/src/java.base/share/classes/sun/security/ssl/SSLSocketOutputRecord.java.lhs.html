<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLSocketOutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.ByteArrayInputStream;
 29 import java.io.IOException;
 30 import java.io.OutputStream;
 31 import java.net.SocketException;
 32 import java.nio.ByteBuffer;
 33 import javax.net.ssl.SSLHandshakeException;
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLSocket}.
 37  */
 38 final class SSLSocketOutputRecord extends OutputRecord implements SSLRecord {
 39     private OutputStream deliverStream = null;
 40 
 41     SSLSocketOutputRecord(HandshakeHash handshakeHash) {
 42         this(handshakeHash, null);
 43     }
 44 
 45     SSLSocketOutputRecord(HandshakeHash handshakeHash,
 46             TransportContext tc) {
 47         super(handshakeHash, SSLCipher.SSLWriteCipher.nullTlsWriteCipher());
 48         this.tc = tc;
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
<a name="2" id="anc2"></a><span class="line-modified"> 54     synchronized void encodeAlert(</span>
<span class="line-modified"> 55             byte level, byte description) throws IOException {</span>
<span class="line-modified"> 56         if (isClosed()) {</span>
<span class="line-modified"> 57             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 58                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified"> 59                     &quot;alert message: &quot; + Alert.nameOf(description));</span>



 60             }
<a name="3" id="anc3"></a><span class="line-removed"> 61             return;</span>
<span class="line-removed"> 62         }</span>
 63 
<a name="4" id="anc4"></a><span class="line-modified"> 64         // use the buf of ByteArrayOutputStream</span>
<span class="line-modified"> 65         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified"> 66         count = position;</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68         write(level);</span>
<span class="line-modified"> 69         write(description);</span>
<span class="line-modified"> 70         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified"> 71             SSLLogger.fine(&quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified"> 72                     &quot; &quot; + ContentType.ALERT.name +</span>
<span class="line-modified"> 73                     &quot;(&quot; + Alert.nameOf(description) + &quot;)&quot; +</span>
<span class="line-modified"> 74                     &quot;, length = &quot; + (count - headerSize));</span>
<span class="line-modified"> 75         }</span>
 76 
<a name="5" id="anc5"></a><span class="line-modified"> 77         // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified"> 78         encrypt(writeCipher, ContentType.ALERT.id, headerSize);</span>
 79 
<a name="6" id="anc6"></a><span class="line-modified"> 80         // deliver this message</span>
<span class="line-modified"> 81         deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified"> 82         deliverStream.flush();                 // may throw IOException</span>
 83 
<a name="7" id="anc7"></a><span class="line-modified"> 84         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified"> 85             SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified"> 86                     (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-modified"> 87         }</span>
 88 
<a name="8" id="anc8"></a><span class="line-modified"> 89         // reset the internal buffer</span>
<span class="line-modified"> 90         count = 0;</span>



 91     }
 92 
 93     @Override
<a name="9" id="anc9"></a><span class="line-modified"> 94     synchronized void encodeHandshake(byte[] source,</span>
 95             int offset, int length) throws IOException {
<a name="10" id="anc10"></a><span class="line-modified"> 96         if (isClosed()) {</span>
<span class="line-modified"> 97             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 98                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified"> 99                         &quot;handshake message&quot;,</span>
<span class="line-modified">100                         ByteBuffer.wrap(source, offset, length));</span>




101             }
<a name="11" id="anc11"></a><span class="line-removed">102             return;</span>
<span class="line-removed">103         }</span>
104 
<a name="12" id="anc12"></a><span class="line-modified">105         if (firstMessage) {</span>
<span class="line-modified">106             firstMessage = false;</span>
107 
<a name="13" id="anc13"></a><span class="line-modified">108             if ((helloVersion == ProtocolVersion.SSL20Hello) &amp;&amp;</span>
<span class="line-modified">109                 (source[offset] == SSLHandshake.CLIENT_HELLO.id) &amp;&amp;</span>
110                                             //  5: recode header size
<a name="14" id="anc14"></a><span class="line-modified">111                 (source[offset + 4 + 2 + 32] == 0)) {</span>
112                                             // V3 session ID is empty
113                                             //  4: handshake header size
114                                             //  2: client_version in ClientHello
115                                             // 32: random in ClientHello
116 
<a name="15" id="anc15"></a><span class="line-modified">117                 ByteBuffer v2ClientHello = encodeV2ClientHello(</span>
<span class="line-modified">118                         source, (offset + 4), (length - 4));</span>

















































119 
<a name="16" id="anc16"></a><span class="line-modified">120                 byte[] record = v2ClientHello.array();  // array offset is zero</span>
<span class="line-modified">121                 int limit = v2ClientHello.limit();</span>
<span class="line-modified">122                 handshakeHash.deliver(record, 2, (limit - 2));</span>


123 
124                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
125                     SSLLogger.fine(
<a name="17" id="anc17"></a><span class="line-modified">126                             &quot;WRITE: SSLv2 ClientHello message&quot; +</span>
<span class="line-modified">127                             &quot;, length = &quot; + limit);</span>

128                 }
129 
<a name="18" id="anc18"></a>


130                 // deliver this message
<a name="19" id="anc19"></a><span class="line-modified">131                 //</span>
<span class="line-modified">132                 // Version 2 ClientHello message should be plaintext.</span>
<span class="line-removed">133                 //</span>
<span class="line-removed">134                 // No max fragment length negotiation.</span>
<span class="line-removed">135                 deliverStream.write(record, 0, limit);</span>
<span class="line-removed">136                 deliverStream.flush();</span>
137 
138                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
139                     SSLLogger.fine(&quot;Raw write&quot;,
<a name="20" id="anc20"></a><span class="line-modified">140                             (new ByteArrayInputStream(record, 0, limit)));</span>
141                 }
142 
<a name="21" id="anc21"></a><span class="line-modified">143                 return;</span>




144             }
<a name="22" id="anc22"></a>

145         }
<a name="23" id="anc23"></a>
146 
<a name="24" id="anc24"></a><span class="line-modified">147         byte handshakeType = source[0];</span>
<span class="line-modified">148         if (handshakeHash.isHashable(handshakeType)) {</span>
<span class="line-modified">149             handshakeHash.deliver(source, offset, length);</span>
<span class="line-modified">150         }</span>







151 
<a name="25" id="anc25"></a><span class="line-modified">152         int fragLimit = getFragLimit();</span>
<span class="line-modified">153         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-removed">154         if (count == 0) {</span>
155             count = position;
<a name="26" id="anc26"></a><span class="line-removed">156         }</span>
157 
<a name="27" id="anc27"></a><span class="line-modified">158         if ((count - position) &lt; (fragLimit - length)) {</span>
<span class="line-removed">159             write(source, offset, length);</span>
<span class="line-removed">160             return;</span>
<span class="line-removed">161         }</span>
162 
<a name="28" id="anc28"></a><span class="line-modified">163         for (int limit = (offset + length); offset &lt; limit;) {</span>

164 
<a name="29" id="anc29"></a><span class="line-modified">165             int remains = (limit - offset) + (count - position);</span>
<span class="line-modified">166             int fragLen = Math.min(fragLimit, remains);</span>

167 
<a name="30" id="anc30"></a><span class="line-modified">168             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">169             write(source, offset, fragLen);</span>
<span class="line-modified">170             if (remains &lt; fragLimit) {</span>















171                 return;
172             }
173 
174             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
175                 SSLLogger.fine(
176                         &quot;WRITE: &quot; + protocolVersion +
177                         &quot; &quot; + ContentType.HANDSHAKE.name +
178                         &quot;, length = &quot; + (count - headerSize));
179             }
180 
181             // Encrypt the fragment and wrap up a record.
182             encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);
183 
184             // deliver this message
185             deliverStream.write(buf, 0, count);    // may throw IOException
186             deliverStream.flush();                 // may throw IOException
187 
188             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
189                 SSLLogger.fine(&quot;Raw write&quot;,
190                         (new ByteArrayInputStream(buf, 0, count)));
191             }
192 
<a name="31" id="anc31"></a><span class="line-removed">193             // reset the offset</span>
<span class="line-removed">194             offset += fragLen;</span>
<span class="line-removed">195 </span>
196             // reset the internal buffer
<a name="32" id="anc32"></a><span class="line-modified">197             count = position;</span>


198         }
199     }
200 
201     @Override
<a name="33" id="anc33"></a><span class="line-modified">202     synchronized void encodeChangeCipherSpec() throws IOException {</span>
<span class="line-modified">203         if (isClosed()) {</span>
<span class="line-modified">204             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">205                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified">206                     &quot;change_cipher_spec message&quot;);</span>

207             }
<a name="34" id="anc34"></a><span class="line-removed">208             return;</span>
<span class="line-removed">209         }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211         // use the buf of ByteArrayOutputStream</span>
<span class="line-removed">212         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-removed">213         count = position;</span>
<span class="line-removed">214 </span>
<span class="line-removed">215         write((byte)1);         // byte 1: change_cipher_spec(</span>
<span class="line-removed">216 </span>
<span class="line-removed">217         // Encrypt the fragment and wrap up a record.</span>
<span class="line-removed">218         encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);</span>
<span class="line-removed">219 </span>
<span class="line-removed">220         // deliver this message</span>
<span class="line-removed">221         deliverStream.write(buf, 0, count);        // may throw IOException</span>
<span class="line-removed">222         // deliverStream.flush();                  // flush in Finished</span>
<span class="line-removed">223 </span>
<span class="line-removed">224         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-removed">225             SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-removed">226                     (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-removed">227         }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229         // reset the internal buffer</span>
<span class="line-removed">230         count = 0;</span>
<span class="line-removed">231     }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233     @Override</span>
<span class="line-removed">234     public synchronized void flush() throws IOException {</span>
<span class="line-removed">235         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-removed">236         if (count &lt;= position) {</span>
<span class="line-removed">237             return;</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239 </span>
<span class="line-removed">240         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-removed">241             SSLLogger.fine(</span>
<span class="line-removed">242                     &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-removed">243                     &quot; &quot; + ContentType.HANDSHAKE.name +</span>
<span class="line-removed">244                     &quot;, length = &quot; + (count - headerSize));</span>
<span class="line-removed">245         }</span>
<span class="line-removed">246 </span>
<span class="line-removed">247         // Encrypt the fragment and wrap up a record.</span>
<span class="line-removed">248         encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);</span>
<span class="line-removed">249 </span>
<span class="line-removed">250         // deliver this message</span>
<span class="line-removed">251         deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-removed">252         deliverStream.flush();                 // may throw IOException</span>
<span class="line-removed">253 </span>
<span class="line-removed">254         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-removed">255             SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-removed">256                     (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-removed">257         }</span>
<span class="line-removed">258 </span>
<span class="line-removed">259         // reset the internal buffer</span>
<span class="line-removed">260         count = 0;      // DON&#39;T use position</span>
<span class="line-removed">261     }</span>
262 
<a name="35" id="anc35"></a><span class="line-modified">263     @Override</span>
<span class="line-modified">264     synchronized void deliver(</span>
<span class="line-modified">265             byte[] source, int offset, int length) throws IOException {</span>
<span class="line-modified">266         if (isClosed()) {</span>
<span class="line-modified">267             throw new SocketException(&quot;Connection or outbound has been closed&quot;);</span>
<span class="line-modified">268         }</span>
269 
<a name="36" id="anc36"></a><span class="line-modified">270         if (writeCipher.authenticator.seqNumOverflow()) {</span>
<span class="line-removed">271             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-removed">272                 SSLLogger.fine(</span>
<span class="line-removed">273                     &quot;sequence number extremely close to overflow &quot; +</span>
<span class="line-removed">274                     &quot;(2^64-1 packets). Closing connection.&quot;);</span>
275             }
276 
<a name="37" id="anc37"></a><span class="line-modified">277             throw new SSLHandshakeException(&quot;sequence number overflow&quot;);</span>
<span class="line-modified">278         }</span>










279 
<a name="38" id="anc38"></a><span class="line-modified">280         boolean isFirstRecordOfThePayload = true;</span>
<span class="line-modified">281         for (int limit = (offset + length); offset &lt; limit;) {</span>
<span class="line-removed">282             int fragLen;</span>
<span class="line-removed">283             if (packetSize &gt; 0) {</span>
<span class="line-removed">284                 fragLen = Math.min(maxRecordSize, packetSize);</span>
<span class="line-removed">285                 fragLen =</span>
<span class="line-removed">286                         writeCipher.calculateFragmentSize(fragLen, headerSize);</span>
<span class="line-removed">287 </span>
<span class="line-removed">288                 fragLen = Math.min(fragLen, Record.maxDataSize);</span>
<span class="line-removed">289             } else {</span>
<span class="line-removed">290                 fragLen = Record.maxDataSize;</span>
<span class="line-removed">291             }</span>
292 
<a name="39" id="anc39"></a><span class="line-modified">293             if (fragmentSize &gt; 0) {</span>
<span class="line-modified">294                 fragLen = Math.min(fragLen, fragmentSize);</span>
<span class="line-modified">295             }</span>



296 
<a name="40" id="anc40"></a><span class="line-modified">297             if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {</span>
<span class="line-modified">298                 fragLen = 1;</span>
<span class="line-modified">299                 isFirstRecordOfThePayload = false;</span>
<span class="line-modified">300             } else {</span>
<span class="line-removed">301                 fragLen = Math.min(fragLen, (limit - offset));</span>
<span class="line-removed">302             }</span>
303 
<a name="41" id="anc41"></a><span class="line-modified">304             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">305             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified">306             count = position;</span>
<span class="line-modified">307             write(source, offset, fragLen);</span>


308 
<a name="42" id="anc42"></a><span class="line-modified">309             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified">310                 SSLLogger.fine(</span>
<span class="line-modified">311                         &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-removed">312                         &quot; &quot; + ContentType.APPLICATION_DATA.name +</span>
<span class="line-removed">313                         &quot;, length = &quot; + (count - position));</span>
<span class="line-removed">314             }</span>
315 
<a name="43" id="anc43"></a><span class="line-modified">316             // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified">317             encrypt(writeCipher, ContentType.APPLICATION_DATA.id, headerSize);</span>

318 
<a name="44" id="anc44"></a><span class="line-modified">319             // deliver this message</span>
<span class="line-modified">320             deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified">321             deliverStream.flush();                 // may throw IOException</span>

322 
<a name="45" id="anc45"></a><span class="line-modified">323             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified">324                 SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-removed">325                         (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-removed">326             }</span>
327 
<a name="46" id="anc46"></a><span class="line-modified">328             // reset the internal buffer</span>
<span class="line-modified">329             count = 0;</span>

330 
<a name="47" id="anc47"></a><span class="line-modified">331             if (isFirstAppOutputRecord) {</span>
<span class="line-removed">332                 isFirstAppOutputRecord = false;</span>
333             }
<a name="48" id="anc48"></a><span class="line-modified">334 </span>
<span class="line-modified">335             offset += fragLen;</span>
336         }
337     }
338 
339     @Override
<a name="49" id="anc49"></a><span class="line-modified">340     synchronized void setDeliverStream(OutputStream outputStream) {</span>
<span class="line-modified">341         this.deliverStream = outputStream;</span>





342     }
343 
344     /*
345      * Need to split the payload except the following cases:
346      *
347      * 1. protocol version is TLS 1.1 or later;
348      * 2. bulk cipher does not use CBC mode, including null bulk cipher suites.
349      * 3. the payload is the first application record of a freshly
350      *    negotiated TLS session.
351      * 4. the CBC protection is disabled;
352      *
353      * By default, we counter chosen plaintext issues on CBC mode
354      * ciphersuites in SSLv3/TLS1.0 by sending one byte of application
355      * data in the first record of every payload, and the rest in
356      * subsequent record(s). Note that the issues have been solved in
357      * TLS 1.1 or later.
358      *
359      * It is not necessary to split the very first application record of
360      * a freshly negotiated TLS session, as there is no previous
361      * application data to guess.  To improve compatibility, we will not
362      * split such records.
363      *
364      * This avoids issues in the outbound direction.  For a full fix,
365      * the peer must have similar protections.
366      */
367     private boolean needToSplitPayload() {
368         return (!protocolVersion.useTLS11PlusSpec()) &amp;&amp;
369                 writeCipher.isCBCMode() &amp;&amp; !isFirstAppOutputRecord &amp;&amp;
370                 Record.enableCBCProtection;
371     }
372 
373     private int getFragLimit() {
374         int fragLimit;
375         if (packetSize &gt; 0) {
376             fragLimit = Math.min(maxRecordSize, packetSize);
377             fragLimit =
378                     writeCipher.calculateFragmentSize(fragLimit, headerSize);
379 
380             fragLimit = Math.min(fragLimit, Record.maxDataSize);
381         } else {
382             fragLimit = Record.maxDataSize;
383         }
384 
<a name="50" id="anc50"></a><span class="line-modified">385         if (fragmentSize &gt; 0) {</span>
<span class="line-modified">386             fragLimit = Math.min(fragLimit, fragmentSize);</span>
<span class="line-removed">387         }</span>
388 
389         return fragLimit;
390     }
391 }
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>
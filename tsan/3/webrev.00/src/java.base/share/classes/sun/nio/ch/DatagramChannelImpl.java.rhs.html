<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-added">  30 import java.io.UncheckedIOException;</span>
<span class="line-added">  31 import java.lang.invoke.MethodHandles;</span>
<span class="line-added">  32 import java.lang.invoke.VarHandle;</span>
<span class="line-added">  33 import java.lang.ref.Cleaner.Cleanable;</span>
<span class="line-added">  34 import java.lang.reflect.Method;</span>
  35 import java.net.DatagramSocket;
  36 import java.net.Inet4Address;
  37 import java.net.Inet6Address;
  38 import java.net.InetAddress;
  39 import java.net.InetSocketAddress;
  40 import java.net.NetworkInterface;
  41 import java.net.PortUnreachableException;
  42 import java.net.ProtocolFamily;
  43 import java.net.SocketAddress;
  44 import java.net.SocketOption;
<a name="3" id="anc3"></a><span class="line-added">  45 import java.net.SocketTimeoutException;</span>
  46 import java.net.StandardProtocolFamily;
  47 import java.net.StandardSocketOptions;
  48 import java.nio.ByteBuffer;
  49 import java.nio.channels.AlreadyBoundException;
  50 import java.nio.channels.AlreadyConnectedException;
  51 import java.nio.channels.AsynchronousCloseException;
  52 import java.nio.channels.ClosedChannelException;
  53 import java.nio.channels.DatagramChannel;
<a name="4" id="anc4"></a><span class="line-added">  54 import java.nio.channels.IllegalBlockingModeException;</span>
  55 import java.nio.channels.MembershipKey;
  56 import java.nio.channels.NotYetConnectedException;
  57 import java.nio.channels.SelectionKey;
<a name="5" id="anc5"></a><span class="line-added">  58 import java.nio.channels.spi.AbstractSelectableChannel;</span>
  59 import java.nio.channels.spi.SelectorProvider;
<a name="6" id="anc6"></a><span class="line-added">  60 import java.security.AccessController;</span>
<span class="line-added">  61 import java.security.PrivilegedExceptionAction;</span>
  62 import java.util.Collections;
<a name="7" id="anc7"></a><span class="line-added">  63 import java.util.HashMap;</span>
  64 import java.util.HashSet;
<a name="8" id="anc8"></a><span class="line-added">  65 import java.util.Map;</span>
  66 import java.util.Objects;
  67 import java.util.Set;
  68 import java.util.concurrent.locks.ReentrantLock;
<a name="9" id="anc9"></a><span class="line-added">  69 import java.util.function.Consumer;</span>
  70 
<a name="10" id="anc10"></a><span class="line-added">  71 import jdk.internal.ref.CleanerFactory;</span>
  72 import sun.net.ResourceManager;
  73 import sun.net.ext.ExtendedSocketOptions;
<a name="11" id="anc11"></a><span class="line-added">  74 import sun.net.util.IPAddressUtil;</span>
  75 
  76 /**
  77  * An implementation of DatagramChannels.
  78  */
  79 
  80 class DatagramChannelImpl
  81     extends DatagramChannel
  82     implements SelChImpl
  83 {
  84     // Used to make native read and write calls
<a name="12" id="anc12"></a><span class="line-modified">  85     private static final NativeDispatcher nd = new DatagramDispatcher();</span>
<span class="line-added">  86 </span>
<span class="line-added">  87     // true if interruptible (can be false to emulate legacy DatagramSocket)</span>
<span class="line-added">  88     private final boolean interruptible;</span>
  89 
  90     // The protocol family of the socket
  91     private final ProtocolFamily family;
  92 
  93     // Our file descriptor
  94     private final FileDescriptor fd;
  95     private final int fdVal;
  96 
<a name="13" id="anc13"></a><span class="line-modified">  97     // Native sockaddrs and cached InetSocketAddress for receive, protected by readLock</span>
<span class="line-modified">  98     private NativeSocketAddress sourceSockAddr;</span>
<span class="line-modified">  99     private NativeSocketAddress cachedSockAddr;</span>
<span class="line-modified"> 100     private InetSocketAddress cachedInetSocketAddress;</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102     // Native sockaddr and cached objects for send, protected by writeLock</span>
<span class="line-added"> 103     private final NativeSocketAddress targetSockAddr;</span>
<span class="line-added"> 104     private InetSocketAddress previousTarget;</span>
<span class="line-added"> 105     private int previousSockAddrLength;</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107     // Cleaner to close file descriptor and free native socket address</span>
<span class="line-added"> 108     private final Cleanable cleaner;</span>
 109 
 110     // Lock held by current reading or connecting thread
 111     private final ReentrantLock readLock = new ReentrantLock();
 112 
 113     // Lock held by current writing or connecting thread
 114     private final ReentrantLock writeLock = new ReentrantLock();
 115 
 116     // Lock held by any thread that modifies the state fields declared below
 117     // DO NOT invoke a blocking I/O operation while holding this lock!
 118     private final Object stateLock = new Object();
 119 
 120     // -- The following fields are protected by stateLock
 121 
 122     // State (does not necessarily increase monotonically)
 123     private static final int ST_UNCONNECTED = 0;
 124     private static final int ST_CONNECTED = 1;
 125     private static final int ST_CLOSING = 2;
<a name="14" id="anc14"></a><span class="line-modified"> 126     private static final int ST_CLOSED = 3;</span>

 127     private int state;
 128 
 129     // IDs of native threads doing reads and writes, for signalling
 130     private long readerThread;
 131     private long writerThread;
 132 
<a name="15" id="anc15"></a><span class="line-modified"> 133     // Local and remote (connected) address</span>
 134     private InetSocketAddress localAddress;
 135     private InetSocketAddress remoteAddress;
 136 
<a name="16" id="anc16"></a><span class="line-modified"> 137     // Local address prior to connecting</span>
<span class="line-modified"> 138     private InetSocketAddress initialLocalAddress;</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140     // Socket adaptor, created lazily</span>
<span class="line-added"> 141     private static final VarHandle SOCKET;</span>
<span class="line-added"> 142     static {</span>
<span class="line-added"> 143         try {</span>
<span class="line-added"> 144             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-added"> 145             SOCKET = l.findVarHandle(DatagramChannelImpl.class, &quot;socket&quot;, DatagramSocket.class);</span>
<span class="line-added"> 146         } catch (Exception e) {</span>
<span class="line-added"> 147             throw new InternalError(e);</span>
<span class="line-added"> 148         }</span>
<span class="line-added"> 149     }</span>
<span class="line-added"> 150     private volatile DatagramSocket socket;</span>
 151 
 152     // Multicast support
 153     private MembershipRegistry registry;
 154 
 155     // set true when socket is bound and SO_REUSEADDRESS is emulated
 156     private boolean reuseAddressEmulated;
 157 
 158     // set true/false when socket is already bound and SO_REUSEADDR is emulated
 159     private boolean isReuseAddress;
 160 
 161     // -- End of fields protected by stateLock
 162 
<a name="17" id="anc17"></a><span class="line-modified"> 163 </span>
<span class="line-modified"> 164     DatagramChannelImpl(SelectorProvider sp, boolean interruptible) throws IOException {</span>
<span class="line-modified"> 165         this(sp, (Net.isIPv6Available()</span>
<span class="line-modified"> 166                 ? StandardProtocolFamily.INET6</span>
<span class="line-modified"> 167                 : StandardProtocolFamily.INET),</span>
<span class="line-modified"> 168                 interruptible);</span>









 169     }
 170 
<a name="18" id="anc18"></a><span class="line-modified"> 171     DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family, boolean interruptible)</span>
 172         throws IOException
 173     {
 174         super(sp);
<a name="19" id="anc19"></a><span class="line-added"> 175 </span>
 176         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
 177         if ((family != StandardProtocolFamily.INET) &amp;&amp;
<a name="20" id="anc20"></a><span class="line-modified"> 178                 (family != StandardProtocolFamily.INET6)) {</span>
 179             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
 180         }
<a name="21" id="anc21"></a><span class="line-modified"> 181         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-modified"> 182             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>


 183         }
 184 
<a name="22" id="anc22"></a><span class="line-added"> 185         FileDescriptor fd = null;</span>
<span class="line-added"> 186         NativeSocketAddress[] sockAddrs = null;</span>
<span class="line-added"> 187 </span>
 188         ResourceManager.beforeUdpCreate();
<a name="23" id="anc23"></a><span class="line-added"> 189         boolean initialized = false;</span>
 190         try {
<a name="24" id="anc24"></a><span class="line-added"> 191             this.interruptible = interruptible;</span>
 192             this.family = family;
<a name="25" id="anc25"></a><span class="line-modified"> 193             this.fd = fd = Net.socket(family, false);</span>
 194             this.fdVal = IOUtil.fdVal(fd);
<a name="26" id="anc26"></a><span class="line-modified"> 195 </span>
<span class="line-modified"> 196             sockAddrs = NativeSocketAddress.allocate(3);</span>
<span class="line-modified"> 197             readLock.lock();</span>
<span class="line-added"> 198             try {</span>
<span class="line-added"> 199                 this.sourceSockAddr = sockAddrs[0];</span>
<span class="line-added"> 200                 this.cachedSockAddr = sockAddrs[1];</span>
<span class="line-added"> 201             } finally {</span>
<span class="line-added"> 202                 readLock.unlock();</span>
<span class="line-added"> 203             }</span>
<span class="line-added"> 204             this.targetSockAddr = sockAddrs[2];</span>
<span class="line-added"> 205 </span>
<span class="line-added"> 206             initialized = true;</span>
<span class="line-added"> 207         } finally {</span>
<span class="line-added"> 208             if (!initialized) {</span>
<span class="line-added"> 209                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added"> 210                 if (fd != null) nd.close(fd);</span>
<span class="line-added"> 211                 ResourceManager.afterUdpClose();</span>
<span class="line-added"> 212             }</span>
 213         }
<a name="27" id="anc27"></a><span class="line-added"> 214 </span>
<span class="line-added"> 215         Runnable releaser = releaserFor(fd, sockAddrs);</span>
<span class="line-added"> 216         this.cleaner = CleanerFactory.cleaner().register(this, releaser);</span>
 217     }
 218 
<a name="28" id="anc28"></a><span class="line-modified"> 219     DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)</span>
 220         throws IOException
 221     {
 222         super(sp);
 223 
<a name="29" id="anc29"></a><span class="line-modified"> 224         NativeSocketAddress[] sockAddrs = null;</span>
<span class="line-added"> 225 </span>
 226         ResourceManager.beforeUdpCreate();
<a name="30" id="anc30"></a><span class="line-added"> 227         boolean initialized = false;</span>
<span class="line-added"> 228         try {</span>
<span class="line-added"> 229             this.interruptible = true;</span>
<span class="line-added"> 230             this.family = Net.isIPv6Available()</span>
<span class="line-added"> 231                     ? StandardProtocolFamily.INET6</span>
<span class="line-added"> 232                     : StandardProtocolFamily.INET;</span>
<span class="line-added"> 233             this.fd = fd;</span>
<span class="line-added"> 234             this.fdVal = IOUtil.fdVal(fd);</span>
<span class="line-added"> 235 </span>
<span class="line-added"> 236             sockAddrs = NativeSocketAddress.allocate(3);</span>
<span class="line-added"> 237             readLock.lock();</span>
<span class="line-added"> 238             try {</span>
<span class="line-added"> 239                 this.sourceSockAddr = sockAddrs[0];</span>
<span class="line-added"> 240                 this.cachedSockAddr = sockAddrs[1];</span>
<span class="line-added"> 241             } finally {</span>
<span class="line-added"> 242                 readLock.unlock();</span>
<span class="line-added"> 243             }</span>
<span class="line-added"> 244             this.targetSockAddr = sockAddrs[2];</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246             initialized = true;</span>
<span class="line-added"> 247         } finally {</span>
<span class="line-added"> 248             if (!initialized) {</span>
<span class="line-added"> 249                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added"> 250                 nd.close(fd);</span>
<span class="line-added"> 251                 ResourceManager.afterUdpClose();</span>
<span class="line-added"> 252             }</span>
<span class="line-added"> 253         }</span>
<span class="line-added"> 254 </span>
<span class="line-added"> 255         Runnable releaser = releaserFor(fd, sockAddrs);</span>
<span class="line-added"> 256         this.cleaner = CleanerFactory.cleaner().register(this, releaser);</span>
 257 
<a name="31" id="anc31"></a>




 258         synchronized (stateLock) {
 259             this.localAddress = Net.localAddress(fd);
 260         }
 261     }
 262 
 263     // @throws ClosedChannelException if channel is closed
 264     private void ensureOpen() throws ClosedChannelException {
 265         if (!isOpen())
 266             throw new ClosedChannelException();
 267     }
 268 
 269     @Override
 270     public DatagramSocket socket() {
<a name="32" id="anc32"></a><span class="line-modified"> 271         DatagramSocket socket = this.socket;</span>
<span class="line-modified"> 272         if (socket == null) {</span>
<span class="line-modified"> 273             socket = DatagramSocketAdaptor.create(this);</span>
<span class="line-modified"> 274             if (!SOCKET.compareAndSet(this, null, socket)) {</span>
<span class="line-added"> 275                 socket = this.socket;</span>
<span class="line-added"> 276             }</span>
 277         }
<a name="33" id="anc33"></a><span class="line-added"> 278         return socket;</span>
 279     }
 280 
 281     @Override
 282     public SocketAddress getLocalAddress() throws IOException {
 283         synchronized (stateLock) {
 284             ensureOpen();
 285             // Perform security check before returning address
 286             return Net.getRevealedLocalAddress(localAddress);
 287         }
 288     }
 289 
 290     @Override
 291     public SocketAddress getRemoteAddress() throws IOException {
 292         synchronized (stateLock) {
 293             ensureOpen();
 294             return remoteAddress;
 295         }
 296     }
 297 
<a name="34" id="anc34"></a><span class="line-added"> 298     /**</span>
<span class="line-added"> 299      * Returns the protocol family to specify to set/getSocketOption for the</span>
<span class="line-added"> 300      * given socket option.</span>
<span class="line-added"> 301      */</span>
<span class="line-added"> 302     private ProtocolFamily familyFor(SocketOption&lt;?&gt; name) {</span>
<span class="line-added"> 303         assert Thread.holdsLock(stateLock);</span>
<span class="line-added"> 304 </span>
<span class="line-added"> 305         // unspecified (most options)</span>
<span class="line-added"> 306         if (SocketOptionRegistry.findOption(name, Net.UNSPEC) != null)</span>
<span class="line-added"> 307             return Net.UNSPEC;</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309         // IPv4 socket</span>
<span class="line-added"> 310         if (family == StandardProtocolFamily.INET)</span>
<span class="line-added"> 311             return StandardProtocolFamily.INET;</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313         // IPv6 socket that is unbound</span>
<span class="line-added"> 314         if (localAddress == null)</span>
<span class="line-added"> 315             return StandardProtocolFamily.INET6;</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317         // IPv6 socket bound to wildcard or IPv6 address</span>
<span class="line-added"> 318         InetAddress address = localAddress.getAddress();</span>
<span class="line-added"> 319         if (address.isAnyLocalAddress() || (address instanceof Inet6Address))</span>
<span class="line-added"> 320             return StandardProtocolFamily.INET6;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322         // IPv6 socket bound to IPv4 address</span>
<span class="line-added"> 323         if (Net.canUseIPv6OptionsWithIPv4LocalAddress()) {</span>
<span class="line-added"> 324             // IPV6_XXX options can be used</span>
<span class="line-added"> 325             return StandardProtocolFamily.INET6;</span>
<span class="line-added"> 326         } else {</span>
<span class="line-added"> 327             // IPV6_XXX options cannot be used</span>
<span class="line-added"> 328             return StandardProtocolFamily.INET;</span>
<span class="line-added"> 329         }</span>
<span class="line-added"> 330     }</span>
<span class="line-added"> 331 </span>
 332     @Override
 333     public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
 334         throws IOException
 335     {
 336         Objects.requireNonNull(name);
 337         if (!supportedOptions().contains(name))
 338             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<a name="35" id="anc35"></a><span class="line-added"> 339         if (!name.type().isInstance(value))</span>
<span class="line-added"> 340             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
 341 
 342         synchronized (stateLock) {
 343             ensureOpen();
 344 
<a name="36" id="anc36"></a><span class="line-modified"> 345             ProtocolFamily family = familyFor(name);</span>
<span class="line-modified"> 346 </span>
<span class="line-modified"> 347             // Some platforms require both IPV6_XXX and IP_XXX socket options to</span>
<span class="line-modified"> 348             // be set when the channel&#39;s socket is IPv6 and it is used to send</span>
<span class="line-modified"> 349             // IPv4 multicast datagrams. The IP_XXX socket options are set on a</span>
<span class="line-modified"> 350             // best effort basis.</span>
<span class="line-modified"> 351             boolean needToSetIPv4Option = (family != Net.UNSPEC)</span>
<span class="line-modified"> 352                     &amp;&amp; (this.family == StandardProtocolFamily.INET6)</span>
<span class="line-added"> 353                     &amp;&amp; Net.shouldSetBothIPv4AndIPv6Options();</span>
 354 
<a name="37" id="anc37"></a><span class="line-added"> 355             // outgoing multicast interface</span>
 356             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
<a name="38" id="anc38"></a><span class="line-modified"> 357                 assert family != Net.UNSPEC;</span>
<span class="line-modified"> 358                 NetworkInterface interf = (NetworkInterface) value;</span>

 359                 if (family == StandardProtocolFamily.INET6) {
 360                     int index = interf.getIndex();
 361                     if (index == -1)
 362                         throw new IOException(&quot;Network interface cannot be identified&quot;);
 363                     Net.setInterface6(fd, index);
<a name="39" id="anc39"></a><span class="line-modified"> 364                 }</span>
<span class="line-added"> 365                 if (family == StandardProtocolFamily.INET || needToSetIPv4Option) {</span>
 366                     // need IPv4 address to identify interface
 367                     Inet4Address target = Net.anyInet4Address(interf);
<a name="40" id="anc40"></a><span class="line-modified"> 368                     if (target != null) {</span>
<span class="line-added"> 369                         try {</span>
<span class="line-added"> 370                             Net.setInterface4(fd, Net.inet4AsInt(target));</span>
<span class="line-added"> 371                         } catch (IOException ioe) {</span>
<span class="line-added"> 372                             if (family == StandardProtocolFamily.INET) throw ioe;</span>
<span class="line-added"> 373                         }</span>
<span class="line-added"> 374                     } else if (family == StandardProtocolFamily.INET) {</span>
 375                         throw new IOException(&quot;Network interface not configured for IPv4&quot;);
<a name="41" id="anc41"></a><span class="line-modified"> 376                     }</span>

 377                 }
 378                 return this;
 379             }
<a name="42" id="anc42"></a><span class="line-added"> 380 </span>
<span class="line-added"> 381             // SO_REUSEADDR needs special handling as it may be emulated</span>
 382             if (name == StandardSocketOptions.SO_REUSEADDR
 383                 &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
 384                 reuseAddressEmulated = true;
 385                 this.isReuseAddress = (Boolean)value;
 386             }
 387 
 388             // remaining options don&#39;t need any special handling
<a name="43" id="anc43"></a><span class="line-modified"> 389             Net.setSocketOption(fd, family, name, value);</span>
<span class="line-added"> 390             if (needToSetIPv4Option &amp;&amp; family != StandardProtocolFamily.INET) {</span>
<span class="line-added"> 391                 try {</span>
<span class="line-added"> 392                     Net.setSocketOption(fd, StandardProtocolFamily.INET, name, value);</span>
<span class="line-added"> 393                 } catch (IOException ignore) { }</span>
<span class="line-added"> 394             }</span>
<span class="line-added"> 395 </span>
 396             return this;
 397         }
 398     }
 399 
 400     @Override
 401     @SuppressWarnings(&quot;unchecked&quot;)
 402     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 403         throws IOException
 404     {
 405         Objects.requireNonNull(name);
 406         if (!supportedOptions().contains(name))
 407             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 408 
 409         synchronized (stateLock) {
 410             ensureOpen();
 411 
<a name="44" id="anc44"></a><span class="line-modified"> 412             ProtocolFamily family = familyFor(name);</span>





 413 
 414             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 415                 if (family == StandardProtocolFamily.INET) {
 416                     int address = Net.getInterface4(fd);
 417                     if (address == 0)
 418                         return null;    // default interface
 419 
 420                     InetAddress ia = Net.inet4FromInt(address);
 421                     NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 422                     if (ni == null)
 423                         throw new IOException(&quot;Unable to map address to interface&quot;);
 424                     return (T) ni;
 425                 } else {
 426                     int index = Net.getInterface6(fd);
 427                     if (index == 0)
 428                         return null;    // default interface
 429 
 430                     NetworkInterface ni = NetworkInterface.getByIndex(index);
 431                     if (ni == null)
 432                         throw new IOException(&quot;Unable to map index to interface&quot;);
 433                     return (T) ni;
 434                 }
 435             }
 436 
 437             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
<a name="45" id="anc45"></a><span class="line-modified"> 438                 return (T) Boolean.valueOf(isReuseAddress);</span>
 439             }
 440 
 441             // no special handling
<a name="46" id="anc46"></a><span class="line-modified"> 442             return (T) Net.getSocketOption(fd, family, name);</span>
 443         }
 444     }
 445 
 446     private static class DefaultOptionsHolder {
 447         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 448 
 449         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 450             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 451             set.add(StandardSocketOptions.SO_SNDBUF);
 452             set.add(StandardSocketOptions.SO_RCVBUF);
 453             set.add(StandardSocketOptions.SO_REUSEADDR);
 454             if (Net.isReusePortAvailable()) {
 455                 set.add(StandardSocketOptions.SO_REUSEPORT);
 456             }
 457             set.add(StandardSocketOptions.SO_BROADCAST);
 458             set.add(StandardSocketOptions.IP_TOS);
 459             set.add(StandardSocketOptions.IP_MULTICAST_IF);
 460             set.add(StandardSocketOptions.IP_MULTICAST_TTL);
 461             set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
 462             set.addAll(ExtendedSocketOptions.datagramSocketOptions());
 463             return Collections.unmodifiableSet(set);
 464         }
 465     }
 466 
 467     @Override
 468     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 469         return DefaultOptionsHolder.defaultOptions;
 470     }
 471 
 472     /**
 473      * Marks the beginning of a read operation that might block.
 474      *
 475      * @param blocking true if configured blocking
 476      * @param mustBeConnected true if the socket must be connected
 477      * @return remote address if connected
 478      * @throws ClosedChannelException if the channel is closed
 479      * @throws NotYetConnectedException if mustBeConnected and not connected
 480      * @throws IOException if socket not bound and cannot be bound
 481      */
 482     private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
 483         throws IOException
 484     {
<a name="47" id="anc47"></a><span class="line-modified"> 485         if (blocking &amp;&amp; interruptible) {</span>
 486             // set hook for Thread.interrupt
 487             begin();
 488         }
 489         SocketAddress remote;
 490         synchronized (stateLock) {
 491             ensureOpen();
 492             remote = remoteAddress;
 493             if ((remote == null) &amp;&amp; mustBeConnected)
 494                 throw new NotYetConnectedException();
 495             if (localAddress == null)
 496                 bindInternal(null);
 497             if (blocking)
 498                 readerThread = NativeThread.current();
 499         }
 500         return remote;
 501     }
 502 
 503     /**
 504      * Marks the end of a read operation that may have blocked.
 505      *
 506      * @throws AsynchronousCloseException if the channel was closed asynchronously
 507      */
 508     private void endRead(boolean blocking, boolean completed)
 509         throws AsynchronousCloseException
 510     {
 511         if (blocking) {
 512             synchronized (stateLock) {
 513                 readerThread = 0;
<a name="48" id="anc48"></a>
 514                 if (state == ST_CLOSING) {
<a name="49" id="anc49"></a><span class="line-modified"> 515                     tryFinishClose();</span>
 516                 }
 517             }
<a name="50" id="anc50"></a><span class="line-modified"> 518             if (interruptible) {</span>
<span class="line-modified"> 519                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)</span>
<span class="line-added"> 520                 end(completed);</span>
<span class="line-added"> 521             } else if (!completed &amp;&amp; !isOpen()) {</span>
<span class="line-added"> 522                 throw new AsynchronousCloseException();</span>
<span class="line-added"> 523             }</span>
 524         }
 525     }
 526 
<a name="51" id="anc51"></a>

 527     @Override
 528     public SocketAddress receive(ByteBuffer dst) throws IOException {
 529         if (dst.isReadOnly())
 530             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
<a name="52" id="anc52"></a>
 531         readLock.lock();
 532         try {
 533             boolean blocking = isBlocking();
<a name="53" id="anc53"></a><span class="line-modified"> 534             SocketAddress sender = null;</span>

 535             try {
 536                 SocketAddress remote = beginRead(blocking, false);
 537                 boolean connected = (remote != null);
 538                 SecurityManager sm = System.getSecurityManager();
 539                 if (connected || (sm == null)) {
 540                     // connected or no security manager
<a name="54" id="anc54"></a><span class="line-modified"> 541                     int n = receive(dst, connected);</span>
<span class="line-modified"> 542                     if (blocking) {</span>
<span class="line-modified"> 543                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 544                             park(Net.POLLIN);</span>
<span class="line-modified"> 545                             n = receive(dst, connected);</span>



















 546                         }
<a name="55" id="anc55"></a>


 547                     }
<a name="56" id="anc56"></a><span class="line-added"> 548                     if (n &gt;= 0) {</span>
<span class="line-added"> 549                         // sender address is in socket address buffer</span>
<span class="line-added"> 550                         sender = sourceSocketAddress();</span>
<span class="line-added"> 551                     }</span>
<span class="line-added"> 552                 } else {</span>
<span class="line-added"> 553                     // security manager and unconnected</span>
<span class="line-added"> 554                     sender = untrustedReceive(dst);</span>
 555                 }
<a name="57" id="anc57"></a>
 556                 return sender;
 557             } finally {
<a name="58" id="anc58"></a><span class="line-modified"> 558                 endRead(blocking, (sender != null));</span>
<span class="line-modified"> 559             }</span>
<span class="line-modified"> 560         } finally {</span>
<span class="line-modified"> 561             readLock.unlock();</span>
<span class="line-added"> 562         }</span>
<span class="line-added"> 563     }</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565     /**</span>
<span class="line-added"> 566      * Receives a datagram into an untrusted buffer. When there is a security</span>
<span class="line-added"> 567      * manager set, and the socket is not connected, datagrams have to be received</span>
<span class="line-added"> 568      * into a buffer that is not accessible to the user. The datagram is copied</span>
<span class="line-added"> 569      * into the user&#39;s buffer when the sender address is accepted by the security</span>
<span class="line-added"> 570      * manager.</span>
<span class="line-added"> 571      */</span>
<span class="line-added"> 572     private SocketAddress untrustedReceive(ByteBuffer dst) throws IOException {</span>
<span class="line-added"> 573         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 574         assert readLock.isHeldByCurrentThread()</span>
<span class="line-added"> 575                 &amp;&amp; sm != null &amp;&amp; remoteAddress == null;</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577         ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());</span>
<span class="line-added"> 578         try {</span>
<span class="line-added"> 579             boolean blocking = isBlocking();</span>
<span class="line-added"> 580             for (;;) {</span>
<span class="line-added"> 581                 int n = receive(bb, false);</span>
<span class="line-added"> 582                 if (blocking) {</span>
<span class="line-added"> 583                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 584                         park(Net.POLLIN);</span>
<span class="line-added"> 585                         n = receive(bb, false);</span>
<span class="line-added"> 586                     }</span>
<span class="line-added"> 587                 }</span>
<span class="line-added"> 588                 if (n &gt;= 0) {</span>
<span class="line-added"> 589                     // sender address is in socket address buffer</span>
<span class="line-added"> 590                     InetSocketAddress isa = sourceSocketAddress();</span>
<span class="line-added"> 591                     try {</span>
<span class="line-added"> 592                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added"> 593                         bb.flip();</span>
<span class="line-added"> 594                         dst.put(bb);</span>
<span class="line-added"> 595                         return isa;</span>
<span class="line-added"> 596                     } catch (SecurityException se) {</span>
<span class="line-added"> 597                         // ignore datagram</span>
<span class="line-added"> 598                         bb.clear();</span>
<span class="line-added"> 599                     }</span>
<span class="line-added"> 600                 } else {</span>
<span class="line-added"> 601                     return null;</span>
<span class="line-added"> 602                 }</span>
 603             }
<a name="59" id="anc59"></a><span class="line-added"> 604         } finally {</span>
<span class="line-added"> 605             Util.releaseTemporaryDirectBuffer(bb);</span>
<span class="line-added"> 606         }</span>
<span class="line-added"> 607     }</span>
<span class="line-added"> 608 </span>
<span class="line-added"> 609     /**</span>
<span class="line-added"> 610      * Receives a datagram into the given buffer.</span>
<span class="line-added"> 611      *</span>
<span class="line-added"> 612      * @apiNote This method is for use by the socket adaptor. The buffer is</span>
<span class="line-added"> 613      * assumed to be trusted, meaning it is not accessible to user code.</span>
<span class="line-added"> 614      *</span>
<span class="line-added"> 615      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added"> 616      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added"> 617      */</span>
<span class="line-added"> 618     SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {</span>
<span class="line-added"> 619         readLock.lock();</span>
<span class="line-added"> 620         try {</span>
<span class="line-added"> 621             ensureOpen();</span>
<span class="line-added"> 622             if (!isBlocking())</span>
<span class="line-added"> 623                 throw new IllegalBlockingModeException();</span>
<span class="line-added"> 624             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 625             boolean connected = isConnected();</span>
<span class="line-added"> 626             SocketAddress sender;</span>
<span class="line-added"> 627             do {</span>
<span class="line-added"> 628                 if (nanos &gt; 0) {</span>
<span class="line-added"> 629                     sender = trustedBlockingReceive(dst, nanos);</span>
<span class="line-added"> 630                 } else {</span>
<span class="line-added"> 631                     sender = trustedBlockingReceive(dst);</span>
<span class="line-added"> 632                 }</span>
<span class="line-added"> 633                 // check sender when security manager set and not connected</span>
<span class="line-added"> 634                 if (sm != null &amp;&amp; !connected) {</span>
<span class="line-added"> 635                     InetSocketAddress isa = (InetSocketAddress) sender;</span>
<span class="line-added"> 636                     try {</span>
<span class="line-added"> 637                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added"> 638                     } catch (SecurityException e) {</span>
<span class="line-added"> 639                         sender = null;</span>
<span class="line-added"> 640                     }</span>
<span class="line-added"> 641                 }</span>
<span class="line-added"> 642             } while (sender == null);</span>
<span class="line-added"> 643             return sender;</span>
 644         } finally {
 645             readLock.unlock();
 646         }
 647     }
 648 
<a name="60" id="anc60"></a><span class="line-modified"> 649     /**</span>
<span class="line-added"> 650      * Receives a datagram into given buffer. This method is used to support</span>
<span class="line-added"> 651      * the socket adaptor. The buffer is assumed to be trusted.</span>
<span class="line-added"> 652      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added"> 653      */</span>
<span class="line-added"> 654     private SocketAddress trustedBlockingReceive(ByteBuffer dst)</span>
 655         throws IOException
 656     {
<a name="61" id="anc61"></a><span class="line-added"> 657         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();</span>
<span class="line-added"> 658         SocketAddress sender = null;</span>
<span class="line-added"> 659         try {</span>
<span class="line-added"> 660             SocketAddress remote = beginRead(true, false);</span>
<span class="line-added"> 661             boolean connected = (remote != null);</span>
<span class="line-added"> 662             int n = receive(dst, connected);</span>
<span class="line-added"> 663             while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 664                 park(Net.POLLIN);</span>
<span class="line-added"> 665                 n = receive(dst, connected);</span>
<span class="line-added"> 666             }</span>
<span class="line-added"> 667             if (n &gt;= 0) {</span>
<span class="line-added"> 668                 // sender address is in socket address buffer</span>
<span class="line-added"> 669                 sender = sourceSocketAddress();</span>
<span class="line-added"> 670             }</span>
<span class="line-added"> 671             return sender;</span>
<span class="line-added"> 672         } finally {</span>
<span class="line-added"> 673             endRead(true, (sender != null));</span>
<span class="line-added"> 674         }</span>
<span class="line-added"> 675     }</span>
<span class="line-added"> 676 </span>
<span class="line-added"> 677     /**</span>
<span class="line-added"> 678      * Receives a datagram into given buffer with a timeout. This method is</span>
<span class="line-added"> 679      * used to support the socket adaptor. The buffer is assumed to be trusted.</span>
<span class="line-added"> 680      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added"> 681      */</span>
<span class="line-added"> 682     private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)</span>
<span class="line-added"> 683         throws IOException</span>
<span class="line-added"> 684     {</span>
<span class="line-added"> 685         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();</span>
<span class="line-added"> 686         SocketAddress sender = null;</span>
<span class="line-added"> 687         try {</span>
<span class="line-added"> 688             SocketAddress remote = beginRead(true, false);</span>
<span class="line-added"> 689             boolean connected = (remote != null);</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691             // change socket to non-blocking</span>
<span class="line-added"> 692             lockedConfigureBlocking(false);</span>
<span class="line-added"> 693             try {</span>
<span class="line-added"> 694                 long startNanos = System.nanoTime();</span>
<span class="line-added"> 695                 int n = receive(dst, connected);</span>
<span class="line-added"> 696                 while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-added"> 697                     long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added"> 698                     if (remainingNanos &lt;= 0) {</span>
<span class="line-added"> 699                         throw new SocketTimeoutException(&quot;Receive timed out&quot;);</span>
<span class="line-added"> 700                     }</span>
<span class="line-added"> 701                     park(Net.POLLIN, remainingNanos);</span>
<span class="line-added"> 702                     n = receive(dst, connected);</span>
<span class="line-added"> 703                 }</span>
<span class="line-added"> 704                 if (n &gt;= 0) {</span>
<span class="line-added"> 705                     // sender address is in socket address buffer</span>
<span class="line-added"> 706                     sender = sourceSocketAddress();</span>
<span class="line-added"> 707                 }</span>
<span class="line-added"> 708                 return sender;</span>
<span class="line-added"> 709             } finally {</span>
<span class="line-added"> 710                 // restore socket to blocking mode (if channel is open)</span>
<span class="line-added"> 711                 tryLockedConfigureBlocking(true);</span>
<span class="line-added"> 712             }</span>
<span class="line-added"> 713         } finally {</span>
<span class="line-added"> 714             endRead(true, (sender != null));</span>
<span class="line-added"> 715         }</span>
<span class="line-added"> 716     }</span>
<span class="line-added"> 717 </span>
<span class="line-added"> 718     private int receive(ByteBuffer dst, boolean connected) throws IOException {</span>
 719         int pos = dst.position();
 720         int lim = dst.limit();
 721         assert (pos &lt;= lim);
 722         int rem = (pos &lt;= lim ? lim - pos : 0);
 723         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
<a name="62" id="anc62"></a><span class="line-modified"> 724             return receiveIntoNativeBuffer(dst, rem, pos, connected);</span>
 725 
 726         // Substitute a native buffer. If the supplied buffer is empty
 727         // we must instead use a nonempty buffer, otherwise the call
 728         // will not block waiting for a datagram on some platforms.
 729         int newSize = Math.max(rem, 1);
 730         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 731         try {
<a name="63" id="anc63"></a><span class="line-modified"> 732             int n = receiveIntoNativeBuffer(bb, newSize, 0, connected);</span>
 733             bb.flip();
 734             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 735                 dst.put(bb);
 736             return n;
 737         } finally {
 738             Util.releaseTemporaryDirectBuffer(bb);
 739         }
 740     }
 741 
<a name="64" id="anc64"></a><span class="line-modified"> 742     private int receiveIntoNativeBuffer(ByteBuffer bb, int rem, int pos,</span>
<span class="line-modified"> 743                                         boolean connected)</span>
 744         throws IOException
 745     {
<a name="65" id="anc65"></a><span class="line-modified"> 746         int n = receive0(fd,</span>
<span class="line-added"> 747                          ((DirectBuffer)bb).address() + pos, rem,</span>
<span class="line-added"> 748                          sourceSockAddr.address(),</span>
<span class="line-added"> 749                          connected);</span>
 750         if (n &gt; 0)
 751             bb.position(pos + n);
 752         return n;
 753     }
 754 
<a name="66" id="anc66"></a><span class="line-added"> 755     /**</span>
<span class="line-added"> 756      * Return an InetSocketAddress to represent the source/sender socket address</span>
<span class="line-added"> 757      * in sourceSockAddr. Returns the cached InetSocketAddress if the source</span>
<span class="line-added"> 758      * address is the same as the cached address.</span>
<span class="line-added"> 759      */</span>
<span class="line-added"> 760     private InetSocketAddress sourceSocketAddress() throws IOException {</span>
<span class="line-added"> 761         assert readLock.isHeldByCurrentThread();</span>
<span class="line-added"> 762         if (cachedInetSocketAddress != null &amp;&amp; sourceSockAddr.equals(cachedSockAddr)) {</span>
<span class="line-added"> 763             return cachedInetSocketAddress;</span>
<span class="line-added"> 764         }</span>
<span class="line-added"> 765         InetSocketAddress isa = sourceSockAddr.decode();</span>
<span class="line-added"> 766         // swap sourceSockAddr and cachedSockAddr</span>
<span class="line-added"> 767         NativeSocketAddress tmp = cachedSockAddr;</span>
<span class="line-added"> 768         cachedSockAddr = sourceSockAddr;</span>
<span class="line-added"> 769         sourceSockAddr = tmp;</span>
<span class="line-added"> 770         cachedInetSocketAddress = isa;</span>
<span class="line-added"> 771         return isa;</span>
<span class="line-added"> 772     }</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     @Override</span>
 775     public int send(ByteBuffer src, SocketAddress target)
 776         throws IOException
 777     {
 778         Objects.requireNonNull(src);
 779         InetSocketAddress isa = Net.checkAddress(target, family);
 780 
 781         writeLock.lock();
 782         try {
 783             boolean blocking = isBlocking();
<a name="67" id="anc67"></a><span class="line-modified"> 784             int n;</span>
<span class="line-added"> 785             boolean completed = false;</span>
 786             try {
 787                 SocketAddress remote = beginWrite(blocking, false);
 788                 if (remote != null) {
 789                     // connected
 790                     if (!target.equals(remote)) {
 791                         throw new AlreadyConnectedException();
 792                     }
<a name="68" id="anc68"></a><span class="line-modified"> 793                     n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified"> 794                     if (blocking) {</span>
<span class="line-modified"> 795                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 796                             park(Net.POLLOUT);</span>
<span class="line-added"> 797                             n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-added"> 798                         }</span>
<span class="line-added"> 799                     }</span>
<span class="line-added"> 800                     completed = (n &gt; 0);</span>
 801                 } else {
 802                     // not connected
 803                     SecurityManager sm = System.getSecurityManager();
<a name="69" id="anc69"></a><span class="line-added"> 804                     InetAddress ia = isa.getAddress();</span>
 805                     if (sm != null) {
<a name="70" id="anc70"></a>
 806                         if (ia.isMulticastAddress()) {
 807                             sm.checkMulticast(ia);
 808                         } else {
 809                             sm.checkConnect(ia.getHostAddress(), isa.getPort());
 810                         }
 811                     }
<a name="71" id="anc71"></a><span class="line-modified"> 812                     if (ia.isLinkLocalAddress())</span>
<span class="line-modified"> 813                         isa = IPAddressUtil.toScopedAddress(isa);</span>
<span class="line-modified"> 814                     n = send(fd, src, isa);</span>
<span class="line-added"> 815                     if (blocking) {</span>
<span class="line-added"> 816                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 817                             park(Net.POLLOUT);</span>
<span class="line-added"> 818                             n = send(fd, src, isa);</span>
<span class="line-added"> 819                         }</span>
<span class="line-added"> 820                     }</span>
<span class="line-added"> 821                     completed = (n &gt;= 0);</span>
 822                 }
 823             } finally {
<a name="72" id="anc72"></a><span class="line-modified"> 824                 endWrite(blocking, completed);</span>

 825             }
<a name="73" id="anc73"></a><span class="line-added"> 826             assert n &gt;= 0 || n == IOStatus.UNAVAILABLE;</span>
 827             return IOStatus.normalize(n);
 828         } finally {
 829             writeLock.unlock();
 830         }
 831     }
 832 
<a name="74" id="anc74"></a><span class="line-added"> 833     /**</span>
<span class="line-added"> 834      * Sends a datagram from the bytes in given buffer.</span>
<span class="line-added"> 835      *</span>
<span class="line-added"> 836      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added"> 837      *</span>
<span class="line-added"> 838      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added"> 839      */</span>
<span class="line-added"> 840     void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {</span>
<span class="line-added"> 841         writeLock.lock();</span>
<span class="line-added"> 842         try {</span>
<span class="line-added"> 843             ensureOpen();</span>
<span class="line-added"> 844             if (!isBlocking())</span>
<span class="line-added"> 845                 throw new IllegalBlockingModeException();</span>
<span class="line-added"> 846             send(src, target);</span>
<span class="line-added"> 847         } finally {</span>
<span class="line-added"> 848             writeLock.unlock();</span>
<span class="line-added"> 849         }</span>
<span class="line-added"> 850     }</span>
<span class="line-added"> 851 </span>
 852     private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
 853         throws IOException
 854     {
 855         if (src instanceof DirectBuffer)
 856             return sendFromNativeBuffer(fd, src, target);
 857 
 858         // Substitute a native buffer
 859         int pos = src.position();
 860         int lim = src.limit();
 861         assert (pos &lt;= lim);
 862         int rem = (pos &lt;= lim ? lim - pos : 0);
 863 
 864         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 865         try {
 866             bb.put(src);
 867             bb.flip();
 868             // Do not update src until we see how many bytes were written
 869             src.position(pos);
 870 
 871             int n = sendFromNativeBuffer(fd, bb, target);
 872             if (n &gt; 0) {
 873                 // now update src
 874                 src.position(pos + n);
 875             }
 876             return n;
 877         } finally {
 878             Util.releaseTemporaryDirectBuffer(bb);
 879         }
 880     }
 881 
 882     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 883                                      InetSocketAddress target)
 884         throws IOException
 885     {
 886         int pos = bb.position();
 887         int lim = bb.limit();
 888         assert (pos &lt;= lim);
 889         int rem = (pos &lt;= lim ? lim - pos : 0);
 890 
<a name="75" id="anc75"></a>
 891         int written;
 892         try {
<a name="76" id="anc76"></a><span class="line-modified"> 893             int addressLen = targetSocketAddress(target);</span>
<span class="line-modified"> 894             written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,</span>
<span class="line-added"> 895                             targetSockAddr.address(), addressLen);</span>
 896         } catch (PortUnreachableException pue) {
 897             if (isConnected())
 898                 throw pue;
 899             written = rem;
 900         }
 901         if (written &gt; 0)
 902             bb.position(pos + written);
 903         return written;
 904     }
 905 
<a name="77" id="anc77"></a><span class="line-added"> 906     /**</span>
<span class="line-added"> 907      * Encodes the given InetSocketAddress into targetSockAddr, returning the</span>
<span class="line-added"> 908      * length of the sockaddr structure (sizeof struct sockaddr or sockaddr6).</span>
<span class="line-added"> 909      */</span>
<span class="line-added"> 910     private int targetSocketAddress(InetSocketAddress isa) {</span>
<span class="line-added"> 911         assert writeLock.isHeldByCurrentThread();</span>
<span class="line-added"> 912         // Nothing to do if target address is already in the buffer. Use</span>
<span class="line-added"> 913         // identity rather than equals as Inet6Address.equals ignores scope_id.</span>
<span class="line-added"> 914         if (isa == previousTarget)</span>
<span class="line-added"> 915             return previousSockAddrLength;</span>
<span class="line-added"> 916         previousTarget = null;</span>
<span class="line-added"> 917         int len = targetSockAddr.encode(family, isa);</span>
<span class="line-added"> 918         previousTarget = isa;</span>
<span class="line-added"> 919         previousSockAddrLength = len;</span>
<span class="line-added"> 920         return len;</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922 </span>
 923     @Override
 924     public int read(ByteBuffer buf) throws IOException {
 925         Objects.requireNonNull(buf);
 926 
 927         readLock.lock();
 928         try {
 929             boolean blocking = isBlocking();
 930             int n = 0;
 931             try {
 932                 beginRead(blocking, true);
<a name="78" id="anc78"></a><span class="line-modified"> 933                 n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-modified"> 934                 if (blocking) {</span>
<span class="line-modified"> 935                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 936                         park(Net.POLLIN);</span>
<span class="line-added"> 937                         n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-added"> 938                     }</span>
<span class="line-added"> 939                 }</span>
 940             } finally {
 941                 endRead(blocking, n &gt; 0);
 942                 assert IOStatus.check(n);
 943             }
 944             return IOStatus.normalize(n);
 945         } finally {
 946             readLock.unlock();
 947         }
 948     }
 949 
 950     @Override
 951     public long read(ByteBuffer[] dsts, int offset, int length)
 952         throws IOException
 953     {
 954         Objects.checkFromIndexSize(offset, length, dsts.length);
 955 
 956         readLock.lock();
 957         try {
 958             boolean blocking = isBlocking();
 959             long n = 0;
 960             try {
 961                 beginRead(blocking, true);
<a name="79" id="anc79"></a><span class="line-modified"> 962                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified"> 963                 if (blocking) {</span>
<span class="line-modified"> 964                     while (IOStatus.okayToRetry(n)  &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 965                         park(Net.POLLIN);</span>
<span class="line-added"> 966                         n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-added"> 967                     }</span>
<span class="line-added"> 968                 }</span>
 969             } finally {
 970                 endRead(blocking, n &gt; 0);
 971                 assert IOStatus.check(n);
 972             }
 973             return IOStatus.normalize(n);
 974         } finally {
 975             readLock.unlock();
 976         }
 977     }
 978 
 979     /**
 980      * Marks the beginning of a write operation that might block.
 981      * @param blocking true if configured blocking
 982      * @param mustBeConnected true if the socket must be connected
 983      * @return remote address if connected
 984      * @throws ClosedChannelException if the channel is closed
 985      * @throws NotYetConnectedException if mustBeConnected and not connected
 986      * @throws IOException if socket not bound and cannot be bound
 987      */
 988     private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
 989         throws IOException
 990     {
<a name="80" id="anc80"></a><span class="line-modified"> 991         if (blocking &amp;&amp; interruptible) {</span>
 992             // set hook for Thread.interrupt
 993             begin();
 994         }
 995         SocketAddress remote;
 996         synchronized (stateLock) {
 997             ensureOpen();
 998             remote = remoteAddress;
 999             if ((remote == null) &amp;&amp; mustBeConnected)
1000                 throw new NotYetConnectedException();
1001             if (localAddress == null)
1002                 bindInternal(null);
1003             if (blocking)
1004                 writerThread = NativeThread.current();
1005         }
1006         return remote;
1007     }
1008 
1009     /**
1010      * Marks the end of a write operation that may have blocked.
1011      *
1012      * @throws AsynchronousCloseException if the channel was closed asynchronously
1013      */
1014     private void endWrite(boolean blocking, boolean completed)
1015         throws AsynchronousCloseException
1016     {
1017         if (blocking) {
1018             synchronized (stateLock) {
1019                 writerThread = 0;
<a name="81" id="anc81"></a>
1020                 if (state == ST_CLOSING) {
<a name="82" id="anc82"></a><span class="line-modified">1021                     tryFinishClose();</span>
1022                 }
1023             }
<a name="83" id="anc83"></a><span class="line-modified">1024 </span>
<span class="line-modified">1025             if (interruptible) {</span>
<span class="line-added">1026                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)</span>
<span class="line-added">1027                 end(completed);</span>
<span class="line-added">1028             } else if (!completed &amp;&amp; !isOpen()) {</span>
<span class="line-added">1029                 throw new AsynchronousCloseException();</span>
<span class="line-added">1030             }</span>
1031         }
1032     }
1033 
1034     @Override
1035     public int write(ByteBuffer buf) throws IOException {
1036         Objects.requireNonNull(buf);
1037 
1038         writeLock.lock();
1039         try {
1040             boolean blocking = isBlocking();
1041             int n = 0;
1042             try {
1043                 beginWrite(blocking, true);
<a name="84" id="anc84"></a><span class="line-modified">1044                 n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-modified">1045                 if (blocking) {</span>
<span class="line-modified">1046                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">1047                         park(Net.POLLOUT);</span>
<span class="line-added">1048                         n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-added">1049                     }</span>
<span class="line-added">1050                 }</span>
1051             } finally {
1052                 endWrite(blocking, n &gt; 0);
1053                 assert IOStatus.check(n);
1054             }
1055             return IOStatus.normalize(n);
1056         } finally {
1057             writeLock.unlock();
1058         }
1059     }
1060 
1061     @Override
1062     public long write(ByteBuffer[] srcs, int offset, int length)
1063         throws IOException
1064     {
1065         Objects.checkFromIndexSize(offset, length, srcs.length);
1066 
1067         writeLock.lock();
1068         try {
1069             boolean blocking = isBlocking();
1070             long n = 0;
1071             try {
1072                 beginWrite(blocking, true);
<a name="85" id="anc85"></a><span class="line-modified">1073                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified">1074                 if (blocking) {</span>
<span class="line-modified">1075                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">1076                         park(Net.POLLOUT);</span>
<span class="line-added">1077                         n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-added">1078                     }</span>
<span class="line-added">1079                 }</span>
1080             } finally {
1081                 endWrite(blocking, n &gt; 0);
1082                 assert IOStatus.check(n);
1083             }
1084             return IOStatus.normalize(n);
1085         } finally {
1086             writeLock.unlock();
1087         }
1088     }
1089 
1090     @Override
1091     protected void implConfigureBlocking(boolean block) throws IOException {
1092         readLock.lock();
1093         try {
1094             writeLock.lock();
1095             try {
<a name="86" id="anc86"></a><span class="line-modified">1096                 lockedConfigureBlocking(block);</span>



1097             } finally {
1098                 writeLock.unlock();
1099             }
1100         } finally {
1101             readLock.unlock();
1102         }
1103     }
1104 
<a name="87" id="anc87"></a><span class="line-added">1105     /**</span>
<span class="line-added">1106      * Adjusts the blocking mode. readLock or writeLock must already be held.</span>
<span class="line-added">1107      */</span>
<span class="line-added">1108     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">1109         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">1110         synchronized (stateLock) {</span>
<span class="line-added">1111             ensureOpen();</span>
<span class="line-added">1112             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">1113         }</span>
<span class="line-added">1114     }</span>
<span class="line-added">1115 </span>
<span class="line-added">1116     /**</span>
<span class="line-added">1117      * Adjusts the blocking mode if the channel is open. readLock or writeLock</span>
<span class="line-added">1118      * must already be held.</span>
<span class="line-added">1119      *</span>
<span class="line-added">1120      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-added">1121      *         the blocking mode was not adjusted because the channel is closed</span>
<span class="line-added">1122      */</span>
<span class="line-added">1123     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">1124         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">1125         synchronized (stateLock) {</span>
<span class="line-added">1126             if (isOpen()) {</span>
<span class="line-added">1127                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">1128                 return true;</span>
<span class="line-added">1129             } else {</span>
<span class="line-added">1130                 return false;</span>
<span class="line-added">1131             }</span>
<span class="line-added">1132         }</span>
<span class="line-added">1133     }</span>
<span class="line-added">1134 </span>
1135     InetSocketAddress localAddress() {
1136         synchronized (stateLock) {
1137             return localAddress;
1138         }
1139     }
1140 
1141     InetSocketAddress remoteAddress() {
1142         synchronized (stateLock) {
1143             return remoteAddress;
1144         }
1145     }
1146 
1147     @Override
1148     public DatagramChannel bind(SocketAddress local) throws IOException {
1149         readLock.lock();
1150         try {
1151             writeLock.lock();
1152             try {
1153                 synchronized (stateLock) {
1154                     ensureOpen();
1155                     if (localAddress != null)
1156                         throw new AlreadyBoundException();
1157                     bindInternal(local);
1158                 }
1159             } finally {
1160                 writeLock.unlock();
1161             }
1162         } finally {
1163             readLock.unlock();
1164         }
1165         return this;
1166     }
1167 
1168     private void bindInternal(SocketAddress local) throws IOException {
<a name="88" id="anc88"></a><span class="line-modified">1169         assert Thread.holdsLock(stateLock )&amp;&amp; (localAddress == null);</span>
1170 
1171         InetSocketAddress isa;
1172         if (local == null) {
1173             // only Inet4Address allowed with IPv4 socket
1174             if (family == StandardProtocolFamily.INET) {
1175                 isa = new InetSocketAddress(InetAddress.getByName(&quot;0.0.0.0&quot;), 0);
1176             } else {
1177                 isa = new InetSocketAddress(0);
1178             }
1179         } else {
1180             isa = Net.checkAddress(local, family);
1181         }
1182         SecurityManager sm = System.getSecurityManager();
1183         if (sm != null)
1184             sm.checkListen(isa.getPort());
1185 
1186         Net.bind(family, fd, isa.getAddress(), isa.getPort());
1187         localAddress = Net.localAddress(fd);
1188     }
1189 
1190     @Override
1191     public boolean isConnected() {
1192         synchronized (stateLock) {
1193             return (state == ST_CONNECTED);
1194         }
1195     }
1196 
1197     @Override
1198     public DatagramChannel connect(SocketAddress sa) throws IOException {
<a name="89" id="anc89"></a><span class="line-added">1199         return connect(sa, true);</span>
<span class="line-added">1200     }</span>
<span class="line-added">1201 </span>
<span class="line-added">1202     /**</span>
<span class="line-added">1203      * Connects the channel&#39;s socket.</span>
<span class="line-added">1204      *</span>
<span class="line-added">1205      * @param sa the remote address to which this channel is to be connected</span>
<span class="line-added">1206      * @param check true to check if the channel is already connected.</span>
<span class="line-added">1207      */</span>
<span class="line-added">1208     DatagramChannel connect(SocketAddress sa, boolean check) throws IOException {</span>
1209         InetSocketAddress isa = Net.checkAddress(sa, family);
1210         SecurityManager sm = System.getSecurityManager();
1211         if (sm != null) {
1212             InetAddress ia = isa.getAddress();
1213             if (ia.isMulticastAddress()) {
1214                 sm.checkMulticast(ia);
1215             } else {
1216                 sm.checkConnect(ia.getHostAddress(), isa.getPort());
1217                 sm.checkAccept(ia.getHostAddress(), isa.getPort());
1218             }
1219         }
1220 
1221         readLock.lock();
1222         try {
1223             writeLock.lock();
1224             try {
1225                 synchronized (stateLock) {
1226                     ensureOpen();
<a name="90" id="anc90"></a><span class="line-modified">1227                     if (check &amp;&amp; state == ST_CONNECTED)</span>
1228                         throw new AlreadyConnectedException();
1229 
<a name="91" id="anc91"></a><span class="line-added">1230                     // ensure that the socket is bound</span>
<span class="line-added">1231                     if (localAddress == null) {</span>
<span class="line-added">1232                         bindInternal(null);</span>
<span class="line-added">1233                     }</span>
<span class="line-added">1234 </span>
<span class="line-added">1235                     // capture local address before connect</span>
<span class="line-added">1236                     initialLocalAddress = localAddress;</span>
<span class="line-added">1237 </span>
1238                     int n = Net.connect(family,
1239                                         fd,
1240                                         isa.getAddress(),
1241                                         isa.getPort());
1242                     if (n &lt;= 0)
1243                         throw new Error();      // Can&#39;t happen
1244 
1245                     // connected
1246                     remoteAddress = isa;
1247                     state = ST_CONNECTED;
1248 
1249                     // refresh local address
1250                     localAddress = Net.localAddress(fd);
1251 
1252                     // flush any packets already received.
1253                     boolean blocking = isBlocking();
1254                     if (blocking) {
1255                         IOUtil.configureBlocking(fd, false);
1256                     }
1257                     try {
1258                         ByteBuffer buf = ByteBuffer.allocate(100);
<a name="92" id="anc92"></a><span class="line-modified">1259                         while (receive(buf, false) &gt;= 0) {</span>
1260                             buf.clear();
1261                         }
1262                     } finally {
1263                         if (blocking) {
1264                             IOUtil.configureBlocking(fd, true);
1265                         }
1266                     }
1267                 }
1268             } finally {
1269                 writeLock.unlock();
1270             }
1271         } finally {
1272             readLock.unlock();
1273         }
1274         return this;
1275     }
1276 
1277     @Override
1278     public DatagramChannel disconnect() throws IOException {
1279         readLock.lock();
1280         try {
1281             writeLock.lock();
1282             try {
1283                 synchronized (stateLock) {
1284                     if (!isOpen() || (state != ST_CONNECTED))
1285                         return this;
1286 
1287                     // disconnect socket
1288                     boolean isIPv6 = (family == StandardProtocolFamily.INET6);
1289                     disconnect0(fd, isIPv6);
1290 
1291                     // no longer connected
1292                     remoteAddress = null;
1293                     state = ST_UNCONNECTED;
1294 
<a name="93" id="anc93"></a><span class="line-modified">1295                     // refresh localAddress, should be same as it was prior to connect</span>
1296                     localAddress = Net.localAddress(fd);
<a name="94" id="anc94"></a><span class="line-added">1297                     try {</span>
<span class="line-added">1298                         if (!localAddress.equals(initialLocalAddress)) {</span>
<span class="line-added">1299                             // Workaround connect(2) issues on Linux and macOS</span>
<span class="line-added">1300                             repairSocket(initialLocalAddress);</span>
<span class="line-added">1301                             assert (localAddress != null)</span>
<span class="line-added">1302                                     &amp;&amp; localAddress.equals(Net.localAddress(fd))</span>
<span class="line-added">1303                                     &amp;&amp; localAddress.equals(initialLocalAddress);</span>
<span class="line-added">1304                         }</span>
<span class="line-added">1305                     } finally {</span>
<span class="line-added">1306                         initialLocalAddress = null;</span>
<span class="line-added">1307                     }</span>
1308                 }
1309             } finally {
1310                 writeLock.unlock();
1311             }
1312         } finally {
1313             readLock.unlock();
1314         }
1315         return this;
1316     }
1317 
<a name="95" id="anc95"></a><span class="line-added">1318     /**</span>
<span class="line-added">1319      * &quot;Repair&quot; the channel&#39;s socket after a disconnect that didn&#39;t restore the</span>
<span class="line-added">1320      * local address.</span>
<span class="line-added">1321      *</span>
<span class="line-added">1322      * On Linux, connect(2) dissolves the association but changes the local port</span>
<span class="line-added">1323      * to 0 when it was initially bound to an ephemeral port. The workaround here</span>
<span class="line-added">1324      * is to rebind to the original port.</span>
<span class="line-added">1325      *</span>
<span class="line-added">1326      * On macOS, connect(2) dissolves the association but rebinds the socket to</span>
<span class="line-added">1327      * the wildcard address when it was initially bound to a specific address.</span>
<span class="line-added">1328      * The workaround here is to re-create the socket.</span>
<span class="line-added">1329      */</span>
<span class="line-added">1330     private void repairSocket(InetSocketAddress target)</span>
<span class="line-added">1331         throws IOException</span>
<span class="line-added">1332     {</span>
<span class="line-added">1333         assert Thread.holdsLock(stateLock);</span>
<span class="line-added">1334 </span>
<span class="line-added">1335         // Linux: try to bind the socket to the original address/port</span>
<span class="line-added">1336         if (localAddress.getPort() == 0) {</span>
<span class="line-added">1337             assert localAddress.getAddress().equals(target.getAddress());</span>
<span class="line-added">1338             Net.bind(family, fd, target.getAddress(), target.getPort());</span>
<span class="line-added">1339             localAddress = Net.localAddress(fd);</span>
<span class="line-added">1340             return;</span>
<span class="line-added">1341         }</span>
<span class="line-added">1342 </span>
<span class="line-added">1343         // capture the value of all existing socket options</span>
<span class="line-added">1344         Map&lt;SocketOption&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="line-added">1345         for (SocketOption&lt;?&gt; option : supportedOptions()) {</span>
<span class="line-added">1346             Object value = getOption(option);</span>
<span class="line-added">1347             if (value != null) {</span>
<span class="line-added">1348                 map.put(option, value);</span>
<span class="line-added">1349             }</span>
<span class="line-added">1350         }</span>
<span class="line-added">1351 </span>
<span class="line-added">1352         // macOS: re-create the socket.</span>
<span class="line-added">1353         FileDescriptor newfd = Net.socket(family, false);</span>
<span class="line-added">1354         try {</span>
<span class="line-added">1355             // copy the socket options that are protocol family agnostic</span>
<span class="line-added">1356             for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {</span>
<span class="line-added">1357                 SocketOption&lt;?&gt; option = e.getKey();</span>
<span class="line-added">1358                 if (SocketOptionRegistry.findOption(option, Net.UNSPEC) != null) {</span>
<span class="line-added">1359                     Object value = e.getValue();</span>
<span class="line-added">1360                     try {</span>
<span class="line-added">1361                         Net.setSocketOption(newfd, Net.UNSPEC, option, value);</span>
<span class="line-added">1362                     } catch (IOException ignore) { }</span>
<span class="line-added">1363                 }</span>
<span class="line-added">1364             }</span>
<span class="line-added">1365 </span>
<span class="line-added">1366             // copy the blocking mode</span>
<span class="line-added">1367             if (!isBlocking()) {</span>
<span class="line-added">1368                 IOUtil.configureBlocking(newfd, false);</span>
<span class="line-added">1369             }</span>
<span class="line-added">1370 </span>
<span class="line-added">1371             // dup this channel&#39;s socket to the new socket. If this succeeds then</span>
<span class="line-added">1372             // fd will reference the new socket. If it fails then it will still</span>
<span class="line-added">1373             // reference the old socket.</span>
<span class="line-added">1374             nd.dup(newfd, fd);</span>
<span class="line-added">1375         } finally {</span>
<span class="line-added">1376             // release the file descriptor</span>
<span class="line-added">1377             nd.close(newfd);</span>
<span class="line-added">1378         }</span>
<span class="line-added">1379 </span>
<span class="line-added">1380         // bind to the original local address</span>
<span class="line-added">1381         try {</span>
<span class="line-added">1382             Net.bind(family, fd, target.getAddress(), target.getPort());</span>
<span class="line-added">1383         } catch (IOException ioe) {</span>
<span class="line-added">1384             // bind failed, socket is left unbound</span>
<span class="line-added">1385             localAddress = null;</span>
<span class="line-added">1386             throw ioe;</span>
<span class="line-added">1387         }</span>
<span class="line-added">1388 </span>
<span class="line-added">1389         // restore local address</span>
<span class="line-added">1390         localAddress = Net.localAddress(fd);</span>
<span class="line-added">1391 </span>
<span class="line-added">1392         // restore all socket options (including those set in first pass)</span>
<span class="line-added">1393         for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {</span>
<span class="line-added">1394             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">1395             SocketOption&lt;Object&gt; option = (SocketOption&lt;Object&gt;) e.getKey();</span>
<span class="line-added">1396             Object value = e.getValue();</span>
<span class="line-added">1397             try {</span>
<span class="line-added">1398                 setOption(option, value);</span>
<span class="line-added">1399             } catch (IOException ignore) { }</span>
<span class="line-added">1400         }</span>
<span class="line-added">1401 </span>
<span class="line-added">1402         // restore multicast group membership</span>
<span class="line-added">1403         MembershipRegistry registry = this.registry;</span>
<span class="line-added">1404         if (registry != null) {</span>
<span class="line-added">1405             registry.forEach(k -&gt; {</span>
<span class="line-added">1406                 if (k instanceof MembershipKeyImpl.Type6) {</span>
<span class="line-added">1407                     MembershipKeyImpl.Type6 key6 = (MembershipKeyImpl.Type6) k;</span>
<span class="line-added">1408                     Net.join6(fd, key6.groupAddress(), key6.index(), key6.source());</span>
<span class="line-added">1409                 } else {</span>
<span class="line-added">1410                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4) k;</span>
<span class="line-added">1411                     Net.join4(fd, key4.groupAddress(), key4.interfaceAddress(), key4.source());</span>
<span class="line-added">1412                 }</span>
<span class="line-added">1413             });</span>
<span class="line-added">1414         }</span>
<span class="line-added">1415 </span>
<span class="line-added">1416         // reset registration in all Selectors that this channel is registered with</span>
<span class="line-added">1417         AbstractSelectableChannels.forEach(this, SelectionKeyImpl::reset);</span>
<span class="line-added">1418     }</span>
<span class="line-added">1419 </span>
<span class="line-added">1420     /**</span>
<span class="line-added">1421      * Defines static methods to access AbstractSelectableChannel non-public members.</span>
<span class="line-added">1422      */</span>
<span class="line-added">1423     private static class AbstractSelectableChannels {</span>
<span class="line-added">1424         private static final Method FOREACH;</span>
<span class="line-added">1425         static {</span>
<span class="line-added">1426             try {</span>
<span class="line-added">1427                 PrivilegedExceptionAction&lt;Method&gt; pae = () -&gt; {</span>
<span class="line-added">1428                     Method m = AbstractSelectableChannel.class.getDeclaredMethod(&quot;forEach&quot;, Consumer.class);</span>
<span class="line-added">1429                     m.setAccessible(true);</span>
<span class="line-added">1430                     return m;</span>
<span class="line-added">1431                 };</span>
<span class="line-added">1432                 FOREACH = AccessController.doPrivileged(pae);</span>
<span class="line-added">1433             } catch (Exception e) {</span>
<span class="line-added">1434                 throw new InternalError(e);</span>
<span class="line-added">1435             }</span>
<span class="line-added">1436         }</span>
<span class="line-added">1437         static void forEach(AbstractSelectableChannel ch, Consumer&lt;SelectionKeyImpl&gt; action) {</span>
<span class="line-added">1438             try {</span>
<span class="line-added">1439                 FOREACH.invoke(ch, action);</span>
<span class="line-added">1440             } catch (Exception e) {</span>
<span class="line-added">1441                 throw new InternalError(e);</span>
<span class="line-added">1442             }</span>
<span class="line-added">1443         }</span>
<span class="line-added">1444     }</span>
<span class="line-added">1445 </span>
1446     /**
1447      * Joins channel&#39;s socket to the given group/interface and
1448      * optional source address.
1449      */
1450     private MembershipKey innerJoin(InetAddress group,
1451                                     NetworkInterface interf,
1452                                     InetAddress source)
1453         throws IOException
1454     {
1455         if (!group.isMulticastAddress())
1456             throw new IllegalArgumentException(&quot;Group not a multicast address&quot;);
1457 
1458         // check multicast address is compatible with this socket
1459         if (group instanceof Inet4Address) {
1460             if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.canIPv6SocketJoinIPv4Group())
1461                 throw new IllegalArgumentException(&quot;IPv6 socket cannot join IPv4 multicast group&quot;);
1462         } else if (group instanceof Inet6Address) {
1463             if (family != StandardProtocolFamily.INET6)
1464                 throw new IllegalArgumentException(&quot;Only IPv6 sockets can join IPv6 multicast group&quot;);
1465         } else {
1466             throw new IllegalArgumentException(&quot;Address type not supported&quot;);
1467         }
1468 
1469         // check source address
1470         if (source != null) {
1471             if (source.isAnyLocalAddress())
1472                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1473             if (source.isMulticastAddress())
1474                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1475             if (source.getClass() != group.getClass())
1476                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1477         }
1478 
1479         SecurityManager sm = System.getSecurityManager();
1480         if (sm != null)
1481             sm.checkMulticast(group);
1482 
1483         synchronized (stateLock) {
1484             ensureOpen();
1485 
1486             // check the registry to see if we are already a member of the group
1487             if (registry == null) {
1488                 registry = new MembershipRegistry();
1489             } else {
1490                 // return existing membership key
1491                 MembershipKey key = registry.checkMembership(group, interf, source);
1492                 if (key != null)
1493                     return key;
1494             }
1495 
1496             MembershipKeyImpl key;
1497             if ((family == StandardProtocolFamily.INET6) &amp;&amp;
1498                 ((group instanceof Inet6Address) || Net.canJoin6WithIPv4Group()))
1499             {
1500                 int index = interf.getIndex();
1501                 if (index == -1)
1502                     throw new IOException(&quot;Network interface cannot be identified&quot;);
1503 
1504                 // need multicast and source address as byte arrays
1505                 byte[] groupAddress = Net.inet6AsByteArray(group);
1506                 byte[] sourceAddress = (source == null) ? null :
1507                     Net.inet6AsByteArray(source);
1508 
1509                 // join the group
1510                 int n = Net.join6(fd, groupAddress, index, sourceAddress);
1511                 if (n == IOStatus.UNAVAILABLE)
1512                     throw new UnsupportedOperationException();
1513 
1514                 key = new MembershipKeyImpl.Type6(this, group, interf, source,
1515                                                   groupAddress, index, sourceAddress);
1516 
1517             } else {
1518                 // need IPv4 address to identify interface
1519                 Inet4Address target = Net.anyInet4Address(interf);
1520                 if (target == null)
1521                     throw new IOException(&quot;Network interface not configured for IPv4&quot;);
1522 
1523                 int groupAddress = Net.inet4AsInt(group);
1524                 int targetAddress = Net.inet4AsInt(target);
1525                 int sourceAddress = (source == null) ? 0 : Net.inet4AsInt(source);
1526 
1527                 // join the group
1528                 int n = Net.join4(fd, groupAddress, targetAddress, sourceAddress);
1529                 if (n == IOStatus.UNAVAILABLE)
1530                     throw new UnsupportedOperationException();
1531 
1532                 key = new MembershipKeyImpl.Type4(this, group, interf, source,
1533                                                   groupAddress, targetAddress, sourceAddress);
1534             }
1535 
1536             registry.add(key);
1537             return key;
1538         }
1539     }
1540 
1541     @Override
1542     public MembershipKey join(InetAddress group,
1543                               NetworkInterface interf)
1544         throws IOException
1545     {
1546         return innerJoin(group, interf, null);
1547     }
1548 
1549     @Override
1550     public MembershipKey join(InetAddress group,
1551                               NetworkInterface interf,
1552                               InetAddress source)
1553         throws IOException
1554     {
1555         Objects.requireNonNull(source);
1556         return innerJoin(group, interf, source);
1557     }
1558 
1559     // package-private
1560     void drop(MembershipKeyImpl key) {
1561         assert key.channel() == this;
1562 
1563         synchronized (stateLock) {
1564             if (!key.isValid())
1565                 return;
1566 
1567             try {
1568                 if (key instanceof MembershipKeyImpl.Type6) {
1569                     MembershipKeyImpl.Type6 key6 =
1570                         (MembershipKeyImpl.Type6)key;
1571                     Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
1572                 } else {
1573                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
1574                     Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
1575                         key4.source());
1576                 }
1577             } catch (IOException ioe) {
1578                 // should not happen
1579                 throw new AssertionError(ioe);
1580             }
1581 
1582             key.invalidate();
1583             registry.remove(key);
1584         }
1585     }
1586 
1587     /**
<a name="96" id="anc96"></a><span class="line-modified">1588      * Finds an existing membership of a multicast group. Returns null if this</span>
<span class="line-modified">1589      * channel&#39;s socket is not a member of the group.</span>
<span class="line-added">1590      *</span>
<span class="line-added">1591      * @apiNote This method is for use by the socket adaptor</span>
<span class="line-added">1592      */</span>
<span class="line-added">1593     MembershipKey findMembership(InetAddress group, NetworkInterface interf) {</span>
<span class="line-added">1594         synchronized (stateLock) {</span>
<span class="line-added">1595             if (registry != null) {</span>
<span class="line-added">1596                 return registry.checkMembership(group, interf, null);</span>
<span class="line-added">1597             } else {</span>
<span class="line-added">1598                 return null;</span>
<span class="line-added">1599             }</span>
<span class="line-added">1600         }</span>
<span class="line-added">1601     }</span>
<span class="line-added">1602 </span>
<span class="line-added">1603     /**</span>
<span class="line-added">1604      * Block datagrams from the given source.</span>
1605      */
1606     void block(MembershipKeyImpl key, InetAddress source)
1607         throws IOException
1608     {
1609         assert key.channel() == this;
1610         assert key.sourceAddress() == null;
1611 
1612         synchronized (stateLock) {
1613             if (!key.isValid())
1614                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1615             if (source.isAnyLocalAddress())
1616                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1617             if (source.isMulticastAddress())
1618                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1619             if (source.getClass() != key.group().getClass())
1620                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1621 
1622             int n;
1623             if (key instanceof MembershipKeyImpl.Type6) {
1624                  MembershipKeyImpl.Type6 key6 =
1625                     (MembershipKeyImpl.Type6)key;
1626                 n = Net.block6(fd, key6.groupAddress(), key6.index(),
1627                                Net.inet6AsByteArray(source));
1628             } else {
1629                 MembershipKeyImpl.Type4 key4 =
1630                     (MembershipKeyImpl.Type4)key;
1631                 n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
1632                                Net.inet4AsInt(source));
1633             }
1634             if (n == IOStatus.UNAVAILABLE) {
1635                 // ancient kernel
1636                 throw new UnsupportedOperationException();
1637             }
1638         }
1639     }
1640 
1641     /**
<a name="97" id="anc97"></a><span class="line-modified">1642      * Unblock the given source.</span>
1643      */
1644     void unblock(MembershipKeyImpl key, InetAddress source) {
1645         assert key.channel() == this;
1646         assert key.sourceAddress() == null;
1647 
1648         synchronized (stateLock) {
1649             if (!key.isValid())
1650                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1651 
1652             try {
1653                 if (key instanceof MembershipKeyImpl.Type6) {
1654                     MembershipKeyImpl.Type6 key6 =
1655                         (MembershipKeyImpl.Type6)key;
1656                     Net.unblock6(fd, key6.groupAddress(), key6.index(),
1657                                  Net.inet6AsByteArray(source));
1658                 } else {
1659                     MembershipKeyImpl.Type4 key4 =
1660                         (MembershipKeyImpl.Type4)key;
1661                     Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
1662                                  Net.inet4AsInt(source));
1663                 }
1664             } catch (IOException ioe) {
1665                 // should not happen
1666                 throw new AssertionError(ioe);
1667             }
1668         }
1669     }
1670 
1671     /**
<a name="98" id="anc98"></a><span class="line-modified">1672      * Closes the socket if there are no I/O operations in progress and the</span>
<span class="line-modified">1673      * channel is not registered with a Selector.</span>









1674      */
<a name="99" id="anc99"></a><span class="line-modified">1675     private boolean tryClose() throws IOException {</span>
<span class="line-modified">1676         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-modified">1677         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added">1678             state = ST_CLOSED;</span>
<span class="line-added">1679             try {</span>
<span class="line-added">1680                 // close socket</span>
<span class="line-added">1681                 cleaner.clean();</span>
<span class="line-added">1682             } catch (UncheckedIOException ioe) {</span>
<span class="line-added">1683                 throw ioe.getCause();</span>
<span class="line-added">1684             }</span>
<span class="line-added">1685             return true;</span>
<span class="line-added">1686         } else {</span>
<span class="line-added">1687             return false;</span>
<span class="line-added">1688         }</span>
<span class="line-added">1689     }</span>
1690 
<a name="100" id="anc100"></a><span class="line-modified">1691     /**</span>
<span class="line-modified">1692      * Invokes tryClose to attempt to close the socket.</span>
<span class="line-added">1693      *</span>
<span class="line-added">1694      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">1695      */</span>
<span class="line-added">1696     private void tryFinishClose() {</span>
<span class="line-added">1697         try {</span>
<span class="line-added">1698             tryClose();</span>
<span class="line-added">1699         } catch (IOException ignore) { }</span>
<span class="line-added">1700     }</span>
1701 
<a name="101" id="anc101"></a><span class="line-modified">1702     /**</span>
<span class="line-added">1703      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">1704      *</span>
<span class="line-added">1705      * If there is an I/O operation in progress then the socket is pre-closed</span>
<span class="line-added">1706      * and the I/O threads signalled, in which case the final close is deferred</span>
<span class="line-added">1707      * until all I/O operations complete.</span>
<span class="line-added">1708      */</span>
<span class="line-added">1709     private void implCloseBlockingMode() throws IOException {</span>
1710         synchronized (stateLock) {
1711             assert state &lt; ST_CLOSING;
<a name="102" id="anc102"></a>
1712             state = ST_CLOSING;
1713 
1714             // if member of any multicast groups then invalidate the keys
1715             if (registry != null)
1716                 registry.invalidateAll();
<a name="103" id="anc103"></a>
1717 
<a name="104" id="anc104"></a><span class="line-modified">1718             if (!tryClose()) {</span>



1719                 long reader = readerThread;
1720                 long writer = writerThread;
1721                 if (reader != 0 || writer != 0) {
1722                     nd.preClose(fd);
<a name="105" id="anc105"></a>
1723                     if (reader != 0)
1724                         NativeThread.signal(reader);
1725                     if (writer != 0)
1726                         NativeThread.signal(writer);
<a name="106" id="anc106"></a>








1727                 }
1728             }
<a name="107" id="anc107"></a>








1729         }
<a name="108" id="anc108"></a><span class="line-added">1730     }</span>
1731 
<a name="109" id="anc109"></a><span class="line-modified">1732     /**</span>
<span class="line-added">1733      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">1734      *</span>
<span class="line-added">1735      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">1736      * until the channel is flushed from all Selectors.</span>
<span class="line-added">1737      */</span>
<span class="line-added">1738     private void implCloseNonBlockingMode() throws IOException {</span>
1739         synchronized (stateLock) {
<a name="110" id="anc110"></a><span class="line-modified">1740             assert state &lt; ST_CLOSING;</span>
<span class="line-modified">1741             state = ST_CLOSING;</span>
<span class="line-added">1742 </span>
<span class="line-added">1743             // if member of any multicast groups then invalidate the keys</span>
<span class="line-added">1744             if (registry != null)</span>
<span class="line-added">1745                 registry.invalidateAll();</span>
1746         }
1747 
<a name="111" id="anc111"></a><span class="line-modified">1748         // wait for any read/write operations to complete before trying to close</span>
<span class="line-modified">1749         readLock.lock();</span>
<span class="line-modified">1750         readLock.unlock();</span>
<span class="line-added">1751         writeLock.lock();</span>
<span class="line-added">1752         writeLock.unlock();</span>
<span class="line-added">1753         synchronized (stateLock) {</span>
<span class="line-added">1754             if (state == ST_CLOSING) {</span>
<span class="line-added">1755                 tryClose();</span>
<span class="line-added">1756             }</span>
<span class="line-added">1757         }</span>
<span class="line-added">1758     }</span>
1759 
<a name="112" id="anc112"></a><span class="line-modified">1760     /**</span>
<span class="line-modified">1761      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">1762      */</span>
<span class="line-added">1763     @Override</span>
<span class="line-added">1764     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">1765         assert !isOpen();</span>
<span class="line-added">1766         if (isBlocking()) {</span>
<span class="line-added">1767             implCloseBlockingMode();</span>
<span class="line-added">1768         } else {</span>
<span class="line-added">1769             implCloseNonBlockingMode();</span>
<span class="line-added">1770         }</span>
1771     }
1772 
1773     @Override
<a name="113" id="anc113"></a><span class="line-modified">1774     public void kill() {</span>
1775         synchronized (stateLock) {
<a name="114" id="anc114"></a><span class="line-modified">1776             if (state == ST_CLOSING) {</span>
<span class="line-modified">1777                 tryFinishClose();</span>






1778             }
1779         }
1780     }
1781 
<a name="115" id="anc115"></a>






1782     /**
1783      * Translates native poll revent set into a ready operation set
1784      */
1785     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1786         int intOps = ski.nioInterestOps();
1787         int oldOps = ski.nioReadyOps();
1788         int newOps = initialOps;
1789 
1790         if ((ops &amp; Net.POLLNVAL) != 0) {
1791             // This should only happen if this channel is pre-closed while a
1792             // selection operation is in progress
1793             // ## Throw an error if this channel has not been pre-closed
1794             return false;
1795         }
1796 
1797         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1798             newOps = intOps;
1799             ski.nioReadyOps(newOps);
1800             return (newOps &amp; ~oldOps) != 0;
1801         }
1802 
1803         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1804             ((intOps &amp; SelectionKey.OP_READ) != 0))
1805             newOps |= SelectionKey.OP_READ;
1806 
1807         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1808             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
1809             newOps |= SelectionKey.OP_WRITE;
1810 
1811         ski.nioReadyOps(newOps);
1812         return (newOps &amp; ~oldOps) != 0;
1813     }
1814 
1815     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1816         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1817     }
1818 
1819     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1820         return translateReadyOps(ops, 0, ski);
1821     }
1822 
<a name="116" id="anc116"></a>























1823     /**
1824      * Translates an interest operation set into a native poll event set
1825      */
1826     public int translateInterestOps(int ops) {
1827         int newOps = 0;
1828         if ((ops &amp; SelectionKey.OP_READ) != 0)
1829             newOps |= Net.POLLIN;
1830         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1831             newOps |= Net.POLLOUT;
1832         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1833             newOps |= Net.POLLIN;
1834         return newOps;
1835     }
1836 
1837     public FileDescriptor getFD() {
1838         return fd;
1839     }
1840 
1841     public int getFDVal() {
1842         return fdVal;
1843     }
1844 
<a name="117" id="anc117"></a><span class="line-added">1845     /**</span>
<span class="line-added">1846      * Returns an action to release the given file descriptor and socket addresses.</span>
<span class="line-added">1847      */</span>
<span class="line-added">1848     private static Runnable releaserFor(FileDescriptor fd, NativeSocketAddress... sockAddrs) {</span>
<span class="line-added">1849         return () -&gt; {</span>
<span class="line-added">1850             try {</span>
<span class="line-added">1851                 nd.close(fd);</span>
<span class="line-added">1852             } catch (IOException ioe) {</span>
<span class="line-added">1853                 throw new UncheckedIOException(ioe);</span>
<span class="line-added">1854             } finally {</span>
<span class="line-added">1855                 // decrement socket count and release memory</span>
<span class="line-added">1856                 ResourceManager.afterUdpClose();</span>
<span class="line-added">1857                 NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added">1858             }</span>
<span class="line-added">1859         };</span>
<span class="line-added">1860     }</span>
1861 
1862     // -- Native methods --
1863 
<a name="118" id="anc118"></a>

1864     private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
1865         throws IOException;
1866 
<a name="119" id="anc119"></a><span class="line-modified">1867     private static native int receive0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">1868                                        long senderAddress, boolean connected)</span>
1869         throws IOException;
1870 
<a name="120" id="anc120"></a><span class="line-modified">1871     private static native int send0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">1872                                     long targetAddress, int targetAddressLen)</span>
1873         throws IOException;
1874 
1875     static {
1876         IOUtil.load();
<a name="121" id="anc121"></a>
1877     }
1878 }
<a name="122" id="anc122"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="122" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/ECDHServerKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.CryptoPrimitive;
 31 import java.security.InvalidAlgorithmParameterException;
 32 import java.security.InvalidKeyException;
 33 import java.security.Key;
 34 import java.security.KeyFactory;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.PrivateKey;
 37 import java.security.PublicKey;
 38 import java.security.Signature;
 39 import java.security.SignatureException;
 40 import java.security.interfaces.ECPublicKey;
 41 import java.security.spec.ECParameterSpec;
 42 import java.security.spec.ECPoint;
 43 import java.security.spec.ECPublicKeySpec;
 44 import java.security.spec.InvalidKeySpecException;
 45 import java.text.MessageFormat;
 46 import java.util.EnumSet;
 47 import java.util.Locale;
 48 import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;
 49 import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;
 50 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;
 52 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 53 import sun.security.ssl.X509Authentication.X509Credentials;
 54 import sun.security.ssl.X509Authentication.X509Possession;
 55 import sun.security.util.ECUtil;
 56 import sun.security.util.HexDumpEncoder;
 57 
 58 /**
 59  * Pack of the ServerKeyExchange handshake message.
 60  */
 61 final class ECDHServerKeyExchange {
 62     static final SSLConsumer ecdheHandshakeConsumer =
 63             new ECDHServerKeyExchangeConsumer();
 64     static final HandshakeProducer ecdheHandshakeProducer =
 65             new ECDHServerKeyExchangeProducer();
 66 
 67     /**
 68      * The ECDH ServerKeyExchange handshake message.
 69      */
 70     private static final
 71             class ECDHServerKeyExchangeMessage extends HandshakeMessage {
 72         private static final byte CURVE_NAMED_CURVE = (byte)0x03;
 73 
 74         // id of the named curve
 75         private final NamedGroup namedGroup;
 76 
 77         // encoded public point
 78         private final byte[] publicPoint;
 79 
 80         // signature bytes, or null if anonymous
 81         private final byte[] paramsSignature;
 82 
 83         // public key object encapsulated in this message
 84         private final ECPublicKey publicKey;
 85 
 86         private final boolean useExplicitSigAlgorithm;
 87 
 88         // the signature algorithm used by this ServerKeyExchange message
 89         private final SignatureScheme signatureScheme;
 90 
 91         ECDHServerKeyExchangeMessage(
 92                 HandshakeContext handshakeContext) throws IOException {
 93             super(handshakeContext);
 94 
 95             // This happens in server side only.
 96             ServerHandshakeContext shc =
 97                     (ServerHandshakeContext)handshakeContext;
 98 
 99             ECDHEPossession ecdhePossession = null;
100             X509Possession x509Possession = null;
101             for (SSLPossession possession : shc.handshakePossessions) {
102                 if (possession instanceof ECDHEPossession) {
103                     ecdhePossession = (ECDHEPossession)possession;
104                     if (x509Possession != null) {
105                         break;
106                     }
107                 } else if (possession instanceof X509Possession) {
108                     x509Possession = (X509Possession)possession;
109                     if (ecdhePossession != null) {
110                         break;
111                     }
112                 }
113             }
114 
115             if (ecdhePossession == null) {
116                 // unlikely
117                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
118                     &quot;No ECDHE credentials negotiated for server key exchange&quot;);
119             }
120 
121             publicKey = ecdhePossession.publicKey;
122             ECParameterSpec params = publicKey.getParams();
123             ECPoint point = publicKey.getW();
124             publicPoint = ECUtil.encodePoint(point, params.getCurve());
125 
126             this.namedGroup = NamedGroup.valueOf(params);
127             if ((namedGroup == null) || (namedGroup.oid == null) ) {
128                 // unlikely
129                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
130                     &quot;Unnamed EC parameter spec: &quot; + params);
131             }
132 
133             if (x509Possession == null) {
134                 // anonymous, no authentication, no signature
135                 paramsSignature = null;
136                 signatureScheme = null;
137                 useExplicitSigAlgorithm = false;
138             } else {
139                 useExplicitSigAlgorithm =
140                         shc.negotiatedProtocol.useTLS12PlusSpec();
141                 Signature signer = null;
142                 if (useExplicitSigAlgorithm) {
143                     signatureScheme = SignatureScheme.getPreferableAlgorithm(
144                             shc.peerRequestedSignatureSchemes,
145                             x509Possession.popPrivateKey,
146                             shc.negotiatedProtocol);
147                     if (signatureScheme == null) {
148                         // Unlikely, the credentials generator should have
149                         // selected the preferable signature algorithm properly.
150                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
151                                 &quot;No preferred signature algorithm for &quot; +
152                                 x509Possession.popPrivateKey.getAlgorithm() +
153                                 &quot;  key&quot;);
154                     }
155                     try {
156                         signer = signatureScheme.getSignature(
157                                 x509Possession.popPrivateKey);
158                     } catch (NoSuchAlgorithmException | InvalidKeyException |
159                             InvalidAlgorithmParameterException nsae) {
160                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
161                             &quot;Unsupported signature algorithm: &quot; +
162                             signatureScheme.name, nsae);
163                     }
164                 } else {
165                     signatureScheme = null;
166                     try {
167                         signer = getSignature(
168                                 x509Possession.popPrivateKey.getAlgorithm(),
169                                 x509Possession.popPrivateKey);
170                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
171                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
172                             &quot;Unsupported signature algorithm: &quot; +
173                             x509Possession.popPrivateKey.getAlgorithm(), e);
174                     }
175                 }
176 
177                 byte[] signature = null;
178                 try {
179                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
180                             shc.serverHelloRandom.randomBytes,
181                             namedGroup.id, publicPoint);
182                     signature = signer.sign();
183                 } catch (SignatureException ex) {
184                     throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
185                         &quot;Failed to sign ecdhe parameters: &quot; +
186                         x509Possession.popPrivateKey.getAlgorithm(), ex);
187                 }
188                 paramsSignature = signature;
189             }
190         }
191 
192         ECDHServerKeyExchangeMessage(HandshakeContext handshakeContext,
193                 ByteBuffer m) throws IOException {
194             super(handshakeContext);
195 
196             // This happens in client side only.
197             ClientHandshakeContext chc =
198                     (ClientHandshakeContext)handshakeContext;
199 
200             byte curveType = (byte)Record.getInt8(m);
201             if (curveType != CURVE_NAMED_CURVE) {
202                 // Unlikely as only the named curves should be negotiated.
203                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
204                     &quot;Unsupported ECCurveType: &quot; + curveType);
205             }
206 
207             int namedGroupId = Record.getInt16(m);
208             this.namedGroup = NamedGroup.valueOf(namedGroupId);
209             if (namedGroup == null) {
210                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
211                     &quot;Unknown named group ID: &quot; + namedGroupId);
212             }
213 
214             if (!SupportedGroups.isSupported(namedGroup)) {
215                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
216                     &quot;Unsupported named group: &quot; + namedGroup);
217             }
218 
219             if (namedGroup.oid == null) {
220                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
221                     &quot;Unknown named EC curve: &quot; + namedGroup);
222             }
223 
224             ECParameterSpec parameters =
225                     ECUtil.getECParameterSpec(null, namedGroup.oid);
226             if (parameters == null) {
227                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
228                     &quot;No supported EC parameter: &quot; + namedGroup);
229             }
230 
231             publicPoint = Record.getBytes8(m);
232             if (publicPoint.length == 0) {
233                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
234                     &quot;Insufficient ECPoint data: &quot; + namedGroup);
235             }
236 
237             ECPublicKey ecPublicKey = null;
238             try {
239                 ECPoint point =
240                         ECUtil.decodePoint(publicPoint, parameters.getCurve());
241                 KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
242                 ecPublicKey = (ECPublicKey)factory.generatePublic(
243                     new ECPublicKeySpec(point, parameters));
244             } catch (NoSuchAlgorithmException |
245                     InvalidKeySpecException | IOException ex) {
246                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
247                     &quot;Invalid ECPoint: &quot; + namedGroup, ex);
248             }
249 
250             publicKey = ecPublicKey;
251 
252             X509Credentials x509Credentials = null;
253             for (SSLCredentials cd : chc.handshakeCredentials) {
254                 if (cd instanceof X509Credentials) {
255                     x509Credentials = (X509Credentials)cd;
256                     break;
257                 }
258             }
259 
260             if (x509Credentials == null) {
261                 // anonymous, no authentication, no signature
262                 if (m.hasRemaining()) {
263                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
264                         &quot;Invalid DH ServerKeyExchange: unknown extra data&quot;);
265                 }
266                 this.signatureScheme = null;
267                 this.paramsSignature = null;
268                 this.useExplicitSigAlgorithm = false;
269 
270                 return;
271             }
272 
273             this.useExplicitSigAlgorithm =
274                     chc.negotiatedProtocol.useTLS12PlusSpec();
275             if (useExplicitSigAlgorithm) {
276                 int ssid = Record.getInt16(m);
277                 signatureScheme = SignatureScheme.valueOf(ssid);
278                 if (signatureScheme == null) {
279                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
280                         &quot;Invalid signature algorithm (&quot; + ssid +
281                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
282                 }
283 
284                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
285                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
286                         &quot;Unsupported signature algorithm (&quot; +
287                         signatureScheme.name +
288                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
289                 }
290             } else {
291                 signatureScheme = null;
292             }
293 
294             // read and verify the signature
295             paramsSignature = Record.getBytes16(m);
296             Signature signer;
297             if (useExplicitSigAlgorithm) {
298                 try {
299                     signer = signatureScheme.getSignature(
300                             x509Credentials.popPublicKey);
301                 } catch (NoSuchAlgorithmException | InvalidKeyException |
302                         InvalidAlgorithmParameterException nsae) {
303                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
304                         &quot;Unsupported signature algorithm: &quot; +
305                         signatureScheme.name, nsae);
306                 }
307             } else {
308                 try {
309                     signer = getSignature(
310                             x509Credentials.popPublicKey.getAlgorithm(),
311                             x509Credentials.popPublicKey);
312                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
313                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
314                         &quot;Unsupported signature algorithm: &quot; +
315                         x509Credentials.popPublicKey.getAlgorithm(), e);
316                 }
317             }
318 
319             try {
320                 updateSignature(signer,
321                         chc.clientHelloRandom.randomBytes,
322                         chc.serverHelloRandom.randomBytes,
323                         namedGroup.id, publicPoint);
324 
325                 if (!signer.verify(paramsSignature)) {
326                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
327                         &quot;Invalid ECDH ServerKeyExchange signature&quot;);
328                 }
329             } catch (SignatureException ex) {
330                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
331                         &quot;Cannot verify ECDH ServerKeyExchange signature&quot;, ex);
332             }
333         }
334 
335         @Override
336         public SSLHandshake handshakeType() {
337             return SSLHandshake.SERVER_KEY_EXCHANGE;
338         }
339 
340         @Override
341         public int messageLength() {
342             int sigLen = 0;
343             if (paramsSignature != null) {
344                 sigLen = 2 + paramsSignature.length;
345                 if (useExplicitSigAlgorithm) {
346                     sigLen += SignatureScheme.sizeInRecord();
347                 }
348             }
349 
350             return 4 + publicPoint.length + sigLen;
351         }
352 
353         @Override
354         public void send(HandshakeOutStream hos) throws IOException {
355             hos.putInt8(CURVE_NAMED_CURVE);
356             hos.putInt16(namedGroup.id);
357             hos.putBytes8(publicPoint);
358             if (paramsSignature != null) {
359                 if (useExplicitSigAlgorithm) {
360                     hos.putInt16(signatureScheme.id);
361                 }
362 
363                 hos.putBytes16(paramsSignature);
364             }
365         }
366 
367         @Override
368         public String toString() {
369             if (useExplicitSigAlgorithm) {
370                 MessageFormat messageFormat = new MessageFormat(
371                     &quot;\&quot;ECDH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
372                     &quot;  \&quot;parameters\&quot;: &#39;{&#39;\n&quot; +
373                     &quot;    \&quot;named group\&quot;: \&quot;{0}\&quot;\n&quot; +
374                     &quot;    \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
375                     &quot;{1}\n&quot; +
376                     &quot;    &#39;}&#39;,\n&quot; +
377                     &quot;  &#39;}&#39;,\n&quot; +
378                     &quot;  \&quot;digital signature\&quot;:  &#39;{&#39;\n&quot; +
379                     &quot;    \&quot;signature algorithm\&quot;: \&quot;{2}\&quot;\n&quot; +
380                     &quot;    \&quot;signature\&quot;: &#39;{&#39;\n&quot; +
381                     &quot;{3}\n&quot; +
382                     &quot;    &#39;}&#39;,\n&quot; +
383                     &quot;  &#39;}&#39;\n&quot; +
384                     &quot;&#39;}&#39;&quot;,
385                     Locale.ENGLISH);
386 
387                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
388                 Object[] messageFields = {
389                     namedGroup.name,
390                     Utilities.indent(
391                             hexEncoder.encodeBuffer(publicPoint), &quot;      &quot;),
392                     signatureScheme.name,
393                     Utilities.indent(
394                             hexEncoder.encodeBuffer(paramsSignature), &quot;      &quot;)
395                 };
396                 return messageFormat.format(messageFields);
397             } else if (paramsSignature != null) {
398                 MessageFormat messageFormat = new MessageFormat(
399                     &quot;\&quot;ECDH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
400                     &quot;  \&quot;parameters\&quot;:  &#39;{&#39;\n&quot; +
401                     &quot;    \&quot;named group\&quot;: \&quot;{0}\&quot;\n&quot; +
402                     &quot;    \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
403                     &quot;{1}\n&quot; +
404                     &quot;    &#39;}&#39;,\n&quot; +
405                     &quot;  &#39;}&#39;,\n&quot; +
406                     &quot;  \&quot;signature\&quot;: &#39;{&#39;\n&quot; +
407                     &quot;{2}\n&quot; +
408                     &quot;  &#39;}&#39;\n&quot; +
409                     &quot;&#39;}&#39;&quot;,
410                     Locale.ENGLISH);
411 
412                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
413                 Object[] messageFields = {
414                     namedGroup.name,
415                     Utilities.indent(
416                             hexEncoder.encodeBuffer(publicPoint), &quot;      &quot;),
417                     Utilities.indent(
418                             hexEncoder.encodeBuffer(paramsSignature), &quot;    &quot;)
419                 };
420 
421                 return messageFormat.format(messageFields);
422             } else {    // anonymous
423                 MessageFormat messageFormat = new MessageFormat(
424                     &quot;\&quot;ECDH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
425                     &quot;  \&quot;parameters\&quot;:  &#39;{&#39;\n&quot; +
426                     &quot;    \&quot;named group\&quot;: \&quot;{0}\&quot;\n&quot; +
427                     &quot;    \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
428                     &quot;{1}\n&quot; +
429                     &quot;    &#39;}&#39;,\n&quot; +
430                     &quot;  &#39;}&#39;\n&quot; +
431                     &quot;&#39;}&#39;&quot;,
432                     Locale.ENGLISH);
433 
434                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
435                 Object[] messageFields = {
436                     namedGroup.name,
437                     Utilities.indent(
438                             hexEncoder.encodeBuffer(publicPoint), &quot;      &quot;),
439                 };
440 
441                 return messageFormat.format(messageFields);
442             }
443         }
444 
445         private static Signature getSignature(String keyAlgorithm,
446                 Key key) throws NoSuchAlgorithmException, InvalidKeyException {
447             Signature signer = null;
448             switch (keyAlgorithm) {
449                 case &quot;EC&quot;:
450                     signer = Signature.getInstance(JsseJce.SIGNATURE_ECDSA);
451                     break;
452                 case &quot;RSA&quot;:
453                     signer = RSASignature.getInstance();
454                     break;
455                 default:
456                     throw new NoSuchAlgorithmException(
457                         &quot;neither an RSA or a EC key : &quot; + keyAlgorithm);
458             }
459 
460             if (signer != null) {
461                 if (key instanceof PublicKey) {
462                     signer.initVerify((PublicKey)(key));
463                 } else {
464                     signer.initSign((PrivateKey)key);
465                 }
466             }
467 
468             return signer;
469         }
470 
471         private static void updateSignature(Signature sig,
472                 byte[] clntNonce, byte[] svrNonce, int namedGroupId,
473                 byte[] publicPoint) throws SignatureException {
474             sig.update(clntNonce);
475             sig.update(svrNonce);
476 
477             sig.update(CURVE_NAMED_CURVE);
478             sig.update((byte)((namedGroupId &gt;&gt; 8) &amp; 0xFF));
479             sig.update((byte)(namedGroupId &amp; 0xFF));
480             sig.update((byte)publicPoint.length);
481             sig.update(publicPoint);
482         }
483     }
484 
485     /**
486      * The ECDH &quot;ServerKeyExchange&quot; handshake message producer.
487      */
488     private static final
489             class ECDHServerKeyExchangeProducer implements HandshakeProducer {
490         // Prevent instantiation of this class.
491         private ECDHServerKeyExchangeProducer() {
492             // blank
493         }
494 
495         @Override
496         public byte[] produce(ConnectionContext context,
497                 HandshakeMessage message) throws IOException {
498             // The producing happens in server side only.
499             ServerHandshakeContext shc = (ServerHandshakeContext)context;
500             ECDHServerKeyExchangeMessage skem =
501                     new ECDHServerKeyExchangeMessage(shc);
502             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
503                 SSLLogger.fine(
504                     &quot;Produced ECDH ServerKeyExchange handshake message&quot;, skem);
505             }
506 
507             // Output the handshake message.
508             skem.write(shc.handshakeOutput);
509             shc.handshakeOutput.flush();
510 
511             // The handshake message has been delivered.
512             return null;
513         }
514     }
515 
516     /**
517      * The ECDH &quot;ServerKeyExchange&quot; handshake message consumer.
518      */
519     private static final
520             class ECDHServerKeyExchangeConsumer implements SSLConsumer {
521         // Prevent instantiation of this class.
522         private ECDHServerKeyExchangeConsumer() {
523             // blank
524         }
525 
526         @Override
527         public void consume(ConnectionContext context,
528                 ByteBuffer message) throws IOException {
529             // The consuming happens in client side only.
530             ClientHandshakeContext chc = (ClientHandshakeContext)context;
531 
532             ECDHServerKeyExchangeMessage skem =
533                     new ECDHServerKeyExchangeMessage(chc, message);
534             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
535                 SSLLogger.fine(
536                     &quot;Consuming ECDH ServerKeyExchange handshake message&quot;, skem);
537             }
538 
539             //
540             // validate
541             //
542             // check constraints of EC PublicKey
543             if (!chc.algorithmConstraints.permits(
544                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
545                     skem.publicKey)) {
546                 throw chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,
547                         &quot;ECDH ServerKeyExchange does not comply &quot; +
548                         &quot;to algorithm constraints&quot;);
549             }
550 
551             //
552             // update
553             //
554             chc.handshakeCredentials.add(
555                     new ECDHECredentials(skem.publicKey, skem.namedGroup));
556 
557             //
558             // produce
559             //
560             // Need no new handshake message producers here.
561         }
562     }
563 }
564 
    </pre>
  </body>
</html>
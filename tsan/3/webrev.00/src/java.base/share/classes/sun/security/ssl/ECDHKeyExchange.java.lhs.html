<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/ECDHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AlgorithmConstraints;
 30 import java.security.CryptoPrimitive;
 31 import java.security.GeneralSecurityException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.PrivateKey;
 36 import java.security.PublicKey;
 37 import java.security.SecureRandom;
<a name="1" id="anc1"></a><span class="line-removed"> 38 import java.security.interfaces.ECPrivateKey;</span>
 39 import java.security.interfaces.ECPublicKey;
<a name="2" id="anc2"></a><span class="line-removed"> 40 import java.security.spec.AlgorithmParameterSpec;</span>
<span class="line-removed"> 41 import java.security.spec.ECGenParameterSpec;</span>
 42 import java.security.spec.ECParameterSpec;
 43 import java.security.spec.ECPoint;
 44 import java.security.spec.ECPublicKeySpec;
 45 import java.util.EnumSet;
 46 import javax.crypto.KeyAgreement;
 47 import javax.crypto.SecretKey;
<a name="3" id="anc3"></a><span class="line-removed"> 48 import javax.crypto.spec.SecretKeySpec;</span>
 49 import javax.net.ssl.SSLHandshakeException;
<a name="4" id="anc4"></a><span class="line-modified"> 50 import sun.security.ssl.CipherSuite.HashAlg;</span>
<span class="line-removed"> 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed"> 52 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
 53 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 54 import sun.security.ssl.X509Authentication.X509Credentials;
 55 import sun.security.ssl.X509Authentication.X509Possession;
<a name="5" id="anc5"></a>

 56 import sun.security.util.ECUtil;
 57 
 58 final class ECDHKeyExchange {
 59     static final SSLPossessionGenerator poGenerator =
 60             new ECDHEPossessionGenerator();
<a name="6" id="anc6"></a><span class="line-removed"> 61     static final SSLKeyAgreementGenerator ecdheKAGenerator =</span>
<span class="line-removed"> 62             new ECDHEKAGenerator();</span>
 63     static final SSLKeyAgreementGenerator ecdhKAGenerator =
 64             new ECDHKAGenerator();
 65 
<a name="7" id="anc7"></a><span class="line-modified"> 66     static final class ECDHECredentials implements SSLCredentials {</span>








 67         final ECPublicKey popPublicKey;
 68         final NamedGroup namedGroup;
 69 
 70         ECDHECredentials(ECPublicKey popPublicKey, NamedGroup namedGroup) {
 71             this.popPublicKey = popPublicKey;
 72             this.namedGroup = namedGroup;
 73         }
 74 
<a name="8" id="anc8"></a>









 75         static ECDHECredentials valueOf(NamedGroup namedGroup,
 76             byte[] encodedPoint) throws IOException, GeneralSecurityException {
 77 
<a name="9" id="anc9"></a><span class="line-modified"> 78             if (namedGroup.type != NamedGroupType.NAMED_GROUP_ECDHE) {</span>
 79                 throw new RuntimeException(
 80                     &quot;Credentials decoding:  Not ECDHE named group&quot;);
 81             }
 82 
 83             if (encodedPoint == null || encodedPoint.length == 0) {
 84                 return null;
 85             }
 86 
 87             ECParameterSpec parameters =
<a name="10" id="anc10"></a><span class="line-modified"> 88                     ECUtil.getECParameterSpec(null, namedGroup.oid);</span>
<span class="line-removed"> 89             if (parameters == null) {</span>
<span class="line-removed"> 90                 return null;</span>
<span class="line-removed"> 91             }</span>
<span class="line-removed"> 92 </span>
 93             ECPoint point = ECUtil.decodePoint(
 94                     encodedPoint, parameters.getCurve());
 95             KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
 96             ECPublicKey publicKey = (ECPublicKey)factory.generatePublic(
 97                     new ECPublicKeySpec(point, parameters));
 98             return new ECDHECredentials(publicKey, namedGroup);
 99         }
100     }
101 
<a name="11" id="anc11"></a><span class="line-modified">102     static final class ECDHEPossession implements SSLPossession {</span>
103         final PrivateKey privateKey;
104         final ECPublicKey publicKey;
105         final NamedGroup namedGroup;
106 
107         ECDHEPossession(NamedGroup namedGroup, SecureRandom random) {
108             try {
109                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
<a name="12" id="anc12"></a><span class="line-modified">110                 ECGenParameterSpec params =</span>
<span class="line-removed">111                         (ECGenParameterSpec)namedGroup.getParameterSpec();</span>
<span class="line-removed">112                 kpg.initialize(params, random);</span>
113                 KeyPair kp = kpg.generateKeyPair();
114                 privateKey = kp.getPrivate();
115                 publicKey = (ECPublicKey)kp.getPublic();
116             } catch (GeneralSecurityException e) {
117                 throw new RuntimeException(
118                     &quot;Could not generate ECDH keypair&quot;, e);
119             }
120 
121             this.namedGroup = namedGroup;
122         }
123 
124         ECDHEPossession(ECDHECredentials credentials, SecureRandom random) {
125             ECParameterSpec params = credentials.popPublicKey.getParams();
126             try {
127                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
128                 kpg.initialize(params, random);
129                 KeyPair kp = kpg.generateKeyPair();
130                 privateKey = kp.getPrivate();
131                 publicKey = (ECPublicKey)kp.getPublic();
132             } catch (GeneralSecurityException e) {
133                 throw new RuntimeException(
134                     &quot;Could not generate ECDH keypair&quot;, e);
135             }
136 
137             this.namedGroup = credentials.namedGroup;
138         }
139 
140         @Override
141         public byte[] encode() {
142             return ECUtil.encodePoint(
143                     publicKey.getW(), publicKey.getParams().getCurve());
144         }
145 
146         // called by ClientHandshaker with either the server&#39;s static or
147         // ephemeral public key
148         SecretKey getAgreedSecret(
149                 PublicKey peerPublicKey) throws SSLHandshakeException {
150 
151             try {
152                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);
153                 ka.init(privateKey);
154                 ka.doPhase(peerPublicKey, true);
155                 return ka.generateSecret(&quot;TlsPremasterSecret&quot;);
156             } catch (GeneralSecurityException e) {
157                 throw (SSLHandshakeException) new SSLHandshakeException(
158                     &quot;Could not generate secret&quot;).initCause(e);
159             }
160         }
161 
162         // called by ServerHandshaker
163         SecretKey getAgreedSecret(
164                 byte[] encodedPoint) throws SSLHandshakeException {
165             try {
166                 ECParameterSpec params = publicKey.getParams();
167                 ECPoint point =
168                         ECUtil.decodePoint(encodedPoint, params.getCurve());
169                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
170                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
171                 PublicKey peerPublicKey = kf.generatePublic(spec);
172                 return getAgreedSecret(peerPublicKey);
173             } catch (GeneralSecurityException | java.io.IOException e) {
174                 throw (SSLHandshakeException) new SSLHandshakeException(
175                     &quot;Could not generate secret&quot;).initCause(e);
176             }
177         }
178 
179         // Check constraints of the specified EC public key.
180         void checkConstraints(AlgorithmConstraints constraints,
181                 byte[] encodedPoint) throws SSLHandshakeException {
182             try {
183 
184                 ECParameterSpec params = publicKey.getParams();
185                 ECPoint point =
186                         ECUtil.decodePoint(encodedPoint, params.getCurve());
187                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
188 
189                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
190                 ECPublicKey pubKey = (ECPublicKey)kf.generatePublic(spec);
191 
192                 // check constraints of ECPublicKey
193                 if (!constraints.permits(
194                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), pubKey)) {
195                     throw new SSLHandshakeException(
196                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
197                 }
198             } catch (GeneralSecurityException | java.io.IOException e) {
199                 throw (SSLHandshakeException) new SSLHandshakeException(
200                         &quot;Could not generate ECPublicKey&quot;).initCause(e);
201             }
202         }
<a name="13" id="anc13"></a>














203     }
204 
205     private static final
206             class ECDHEPossessionGenerator implements SSLPossessionGenerator {
207         // Prevent instantiation of this class.
208         private ECDHEPossessionGenerator() {
209             // blank
210         }
211 
212         @Override
213         public SSLPossession createPossession(HandshakeContext context) {
<a name="14" id="anc14"></a><span class="line-modified">214             NamedGroup preferableNamedGroup = null;</span>



215             if ((context.clientRequestedNamedGroups != null) &amp;&amp;
216                     (!context.clientRequestedNamedGroups.isEmpty())) {
217                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
218                         context.negotiatedProtocol,
219                         context.algorithmConstraints,
<a name="15" id="anc15"></a><span class="line-modified">220                         NamedGroupType.NAMED_GROUP_ECDHE,</span>


221                         context.clientRequestedNamedGroups);
222             } else {
223                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
224                         context.negotiatedProtocol,
225                         context.algorithmConstraints,
<a name="16" id="anc16"></a><span class="line-modified">226                         NamedGroupType.NAMED_GROUP_ECDHE);</span>


227             }
228 
229             if (preferableNamedGroup != null) {
<a name="17" id="anc17"></a><span class="line-modified">230                 return new ECDHEPossession(preferableNamedGroup,</span>
<span class="line-modified">231                             context.sslContext.getSecureRandom());</span>
232             }
233 
234             // no match found, cannot use this cipher suite.
235             //
236             return null;
237         }
238     }
239 
240     private static final
241             class ECDHKAGenerator implements SSLKeyAgreementGenerator {
242         // Prevent instantiation of this class.
243         private ECDHKAGenerator() {
244             // blank
245         }
246 
247         @Override
248         public SSLKeyDerivation createKeyDerivation(
249                 HandshakeContext context) throws IOException {
250             if (context instanceof ServerHandshakeContext) {
251                 return createServerKeyDerivation(
252                         (ServerHandshakeContext)context);
253             } else {
254                 return createClientKeyDerivation(
255                         (ClientHandshakeContext)context);
256             }
257         }
258 
259         private SSLKeyDerivation createServerKeyDerivation(
260                 ServerHandshakeContext shc) throws IOException {
261             X509Possession x509Possession = null;
262             ECDHECredentials ecdheCredentials = null;
263             for (SSLPossession poss : shc.handshakePossessions) {
264                 if (!(poss instanceof X509Possession)) {
265                     continue;
266                 }
267 
<a name="18" id="anc18"></a><span class="line-modified">268                 PrivateKey privateKey = ((X509Possession)poss).popPrivateKey;</span>
<span class="line-modified">269                 if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>

270                     continue;
271                 }
272 
<a name="19" id="anc19"></a><span class="line-removed">273                 ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();</span>
274                 NamedGroup ng = NamedGroup.valueOf(params);
275                 if (ng == null) {
<a name="20" id="anc20"></a><span class="line-modified">276                     // unlikely, have been checked during cipher suite negotiation.</span>

277                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
278                         &quot;Unsupported EC server cert for ECDH key exchange&quot;);
279                 }
280 
281                 for (SSLCredentials cred : shc.handshakeCredentials) {
282                     if (!(cred instanceof ECDHECredentials)) {
283                         continue;
284                     }
285                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
286                         ecdheCredentials = (ECDHECredentials)cred;
287                         break;
288                     }
289                 }
290 
291                 if (ecdheCredentials != null) {
292                     x509Possession = (X509Possession)poss;
293                     break;
294                 }
295             }
296 
297             if (x509Possession == null || ecdheCredentials == null) {
298                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
299                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
300             }
301 
<a name="21" id="anc21"></a><span class="line-modified">302             return new ECDHEKAKeyDerivation(shc,</span>
303                 x509Possession.popPrivateKey, ecdheCredentials.popPublicKey);
304         }
305 
306         private SSLKeyDerivation createClientKeyDerivation(
307                 ClientHandshakeContext chc) throws IOException {
308             ECDHEPossession ecdhePossession = null;
309             X509Credentials x509Credentials = null;
310             for (SSLPossession poss : chc.handshakePossessions) {
311                 if (!(poss instanceof ECDHEPossession)) {
312                     continue;
313                 }
314 
315                 NamedGroup ng = ((ECDHEPossession)poss).namedGroup;
316                 for (SSLCredentials cred : chc.handshakeCredentials) {
317                     if (!(cred instanceof X509Credentials)) {
318                         continue;
319                     }
320 
321                     PublicKey publicKey = ((X509Credentials)cred).popPublicKey;
322                     if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {
323                         continue;
324                     }
325                     ECParameterSpec params =
326                             ((ECPublicKey)publicKey).getParams();
327                     NamedGroup namedGroup = NamedGroup.valueOf(params);
328                     if (namedGroup == null) {
329                         // unlikely, should have been checked previously
330                         throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
331                             &quot;Unsupported EC server cert for ECDH key exchange&quot;);
332                     }
333 
334                     if (ng.equals(namedGroup)) {
335                         x509Credentials = (X509Credentials)cred;
336                         break;
337                     }
338                 }
339 
340                 if (x509Credentials != null) {
341                     ecdhePossession = (ECDHEPossession)poss;
342                     break;
343                 }
344             }
345 
346             if (ecdhePossession == null || x509Credentials == null) {
347                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
348                     &quot;No sufficient ECDH key agreement parameters negotiated&quot;);
349             }
350 
<a name="22" id="anc22"></a><span class="line-modified">351             return new ECDHEKAKeyDerivation(chc,</span>
352                 ecdhePossession.privateKey, x509Credentials.popPublicKey);
353         }
354     }
355 
356     private static final
357             class ECDHEKAGenerator implements SSLKeyAgreementGenerator {
358         // Prevent instantiation of this class.
359         private ECDHEKAGenerator() {
360             // blank
361         }
362 
363         @Override
364         public SSLKeyDerivation createKeyDerivation(
365                 HandshakeContext context) throws IOException {
366             ECDHEPossession ecdhePossession = null;
367             ECDHECredentials ecdheCredentials = null;
368             for (SSLPossession poss : context.handshakePossessions) {
369                 if (!(poss instanceof ECDHEPossession)) {
370                     continue;
371                 }
372 
373                 NamedGroup ng = ((ECDHEPossession)poss).namedGroup;
374                 for (SSLCredentials cred : context.handshakeCredentials) {
375                     if (!(cred instanceof ECDHECredentials)) {
376                         continue;
377                     }
378                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
379                         ecdheCredentials = (ECDHECredentials)cred;
380                         break;
381                     }
382                 }
383 
384                 if (ecdheCredentials != null) {
385                     ecdhePossession = (ECDHEPossession)poss;
386                     break;
387                 }
388             }
389 
390             if (ecdhePossession == null || ecdheCredentials == null) {
391                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
392                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
393             }
394 
<a name="23" id="anc23"></a><span class="line-modified">395             return new ECDHEKAKeyDerivation(context,</span>
396                 ecdhePossession.privateKey, ecdheCredentials.popPublicKey);
397         }
398     }
399 
<a name="24" id="anc24"></a>



400     private static final
<a name="25" id="anc25"></a><span class="line-modified">401             class ECDHEKAKeyDerivation implements SSLKeyDerivation {</span>
<span class="line-modified">402         private final HandshakeContext context;</span>
<span class="line-modified">403         private final PrivateKey localPrivateKey;</span>
<span class="line-modified">404         private final PublicKey peerPublicKey;</span>
<span class="line-removed">405 </span>
<span class="line-removed">406         ECDHEKAKeyDerivation(HandshakeContext context,</span>
<span class="line-removed">407                 PrivateKey localPrivateKey,</span>
<span class="line-removed">408                 PublicKey peerPublicKey) {</span>
<span class="line-removed">409             this.context = context;</span>
<span class="line-removed">410             this.localPrivateKey = localPrivateKey;</span>
<span class="line-removed">411             this.peerPublicKey = peerPublicKey;</span>
412         }
413 
414         @Override
<a name="26" id="anc26"></a><span class="line-modified">415         public SecretKey deriveKey(String algorithm,</span>
<span class="line-modified">416                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">417             if (!context.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">418                 return t12DeriveKey(algorithm, params);</span>
<span class="line-removed">419             } else {</span>
<span class="line-removed">420                 return t13DeriveKey(algorithm, params);</span>
<span class="line-removed">421             }</span>
<span class="line-removed">422         }</span>
423 
<a name="27" id="anc27"></a><span class="line-modified">424         private SecretKey t12DeriveKey(String algorithm,</span>
<span class="line-modified">425                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-modified">426             try {</span>
<span class="line-removed">427                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span>
<span class="line-removed">428                 ka.init(localPrivateKey);</span>
<span class="line-removed">429                 ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">430                 SecretKey preMasterSecret =</span>
<span class="line-removed">431                         ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">432 </span>
<span class="line-removed">433                 SSLMasterKeyDerivation mskd =</span>
<span class="line-removed">434                         SSLMasterKeyDerivation.valueOf(</span>
<span class="line-removed">435                                 context.negotiatedProtocol);</span>
<span class="line-removed">436                 if (mskd == null) {</span>
<span class="line-removed">437                     // unlikely</span>
<span class="line-removed">438                     throw new SSLHandshakeException(</span>
<span class="line-removed">439                             &quot;No expected master key derivation for protocol: &quot; +</span>
<span class="line-removed">440                             context.negotiatedProtocol.name);</span>
<span class="line-removed">441                 }</span>
<span class="line-removed">442                 SSLKeyDerivation kd = mskd.createKeyDerivation(</span>
<span class="line-removed">443                         context, preMasterSecret);</span>
<span class="line-removed">444                 return kd.deriveKey(&quot;MasterSecret&quot;, params);</span>
<span class="line-removed">445             } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">446                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">447                     &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">448             }</span>
<span class="line-removed">449         }</span>
450 
<a name="28" id="anc28"></a><span class="line-modified">451         private SecretKey t13DeriveKey(String algorithm,</span>
<span class="line-modified">452                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-modified">453             try {</span>
<span class="line-modified">454                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span>
<span class="line-modified">455                 ka.init(localPrivateKey);</span>
<span class="line-modified">456                 ka.doPhase(peerPublicKey, true);</span>
<span class="line-modified">457                 SecretKey sharedSecret =</span>
<span class="line-modified">458                         ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-modified">459 </span>
<span class="line-modified">460                 HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;</span>
<span class="line-modified">461                 SSLKeyDerivation kd = context.handshakeKeyDerivation;</span>
<span class="line-modified">462                 HKDF hkdf = new HKDF(hashAlg.name);</span>
<span class="line-modified">463                 if (kd == null) {   // No PSK is in use.</span>
<span class="line-modified">464                     // If PSK is not in use Early Secret will still be</span>
<span class="line-modified">465                     // HKDF-Extract(0, 0).</span>
<span class="line-modified">466                     byte[] zeros = new byte[hashAlg.hashLength];</span>
<span class="line-modified">467                     SecretKeySpec ikm =</span>
<span class="line-modified">468                             new SecretKeySpec(zeros, &quot;TlsPreSharedSecret&quot;);</span>
<span class="line-modified">469                     SecretKey earlySecret =</span>
<span class="line-removed">470                             hkdf.extract(zeros, ikm, &quot;TlsEarlySecret&quot;);</span>
<span class="line-removed">471                     kd = new SSLSecretDerivation(context, earlySecret);</span>
472                 }
<a name="29" id="anc29"></a>
473 
<a name="30" id="anc30"></a><span class="line-modified">474                 // derive salt secret</span>
<span class="line-modified">475                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);</span>



476 
<a name="31" id="anc31"></a><span class="line-modified">477                 // derive handshake secret</span>
<span class="line-modified">478                 return hkdf.extract(saltSecret, sharedSecret, algorithm);</span>
<span class="line-modified">479             } catch (GeneralSecurityException gse) {</span>
<span class="line-modified">480                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-modified">481                     &quot;Could not generate secret&quot;).initCause(gse);</span>





482             }
<a name="32" id="anc32"></a>



483         }
484     }
485 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
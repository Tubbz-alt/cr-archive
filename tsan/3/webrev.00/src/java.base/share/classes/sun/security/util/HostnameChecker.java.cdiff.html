<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/util/HostnameChecker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="HexDumpEncoder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="IOUtils.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/HostnameChecker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,32 ***</span>
       * Returns true if name matches against template.&lt;p&gt;
       *
       * The matching is performed as per RFC 2818 rules for TLS and
       * RFC 2830 rules for LDAP.&lt;p&gt;
       *
<span class="line-modified">!      * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.</span>
<span class="line-modified">!      * The &lt;code&gt;template&lt;/code&gt; parameter</span>
<span class="line-removed">-      * may contain the wildcard character *</span>
       */
      private boolean isMatched(String name, String template,
                                boolean chainsToPublicCA) {
  
          // Normalize to Unicode, because PSL is in Unicode.
<span class="line-modified">!         name = IDN.toUnicode(IDN.toASCII(name));</span>
<span class="line-modified">!         template = IDN.toUnicode(IDN.toASCII(template));</span>
  
<span class="line-modified">!         if (hasIllegalWildcard(name, template, chainsToPublicCA)) {</span>
              return false;
          }
  
          // check the validity of the domain name template.
          try {
<span class="line-modified">!             // Replacing wildcard character &#39;*&#39; with &#39;x&#39; so as to check</span>
              // the domain name template validity.
              //
              // Using the checking implemented in SNIHostName
<span class="line-modified">!             new SNIHostName(template.replace(&#39;*&#39;, &#39;x&#39;));</span>
          } catch (IllegalArgumentException iae) {
              // It would be nice to add debug log if not matching.
              return false;
          }
  
<span class="line-new-header">--- 258,39 ---</span>
       * Returns true if name matches against template.&lt;p&gt;
       *
       * The matching is performed as per RFC 2818 rules for TLS and
       * RFC 2830 rules for LDAP.&lt;p&gt;
       *
<span class="line-modified">!      * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.  The</span>
<span class="line-modified">!      * &lt;code&gt;template&lt;/code&gt; parameter may contain the wildcard character &#39;*&#39;.</span>
       */
      private boolean isMatched(String name, String template,
                                boolean chainsToPublicCA) {
  
          // Normalize to Unicode, because PSL is in Unicode.
<span class="line-modified">!         try {</span>
<span class="line-modified">!             name = IDN.toUnicode(IDN.toASCII(name));</span>
<span class="line-added">+             template = IDN.toUnicode(IDN.toASCII(template));</span>
<span class="line-added">+         } catch (RuntimeException re) {</span>
<span class="line-added">+             if (SSLLogger.isOn) {</span>
<span class="line-added">+                 SSLLogger.fine(&quot;Failed to normalize to Unicode: &quot; + re);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (hasIllegalWildcard(template, chainsToPublicCA)) {</span>
              return false;
          }
  
          // check the validity of the domain name template.
          try {
<span class="line-modified">!             // Replacing wildcard character &#39;*&#39; with &#39;z&#39; so as to check</span>
              // the domain name template validity.
              //
              // Using the checking implemented in SNIHostName
<span class="line-modified">!             new SNIHostName(template.replace(&#39;*&#39;, &#39;z&#39;));</span>
          } catch (IllegalArgumentException iae) {
              // It would be nice to add debug log if not matching.
              return false;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,12 ***</span>
      }
  
      /**
       * Returns true if the template contains an illegal wildcard character.
       */
<span class="line-modified">!     private static boolean hasIllegalWildcard(String domain, String template,</span>
<span class="line-modified">!                                               boolean chainsToPublicCA) {</span>
          // not ok if it is a single wildcard character or &quot;*.&quot;
          if (template.equals(&quot;*&quot;) || template.equals(&quot;*.&quot;)) {
              if (SSLLogger.isOn) {
                  SSLLogger.fine(
                      &quot;Certificate domain name has illegal single &quot; +
<span class="line-new-header">--- 304,12 ---</span>
      }
  
      /**
       * Returns true if the template contains an illegal wildcard character.
       */
<span class="line-modified">!     private static boolean hasIllegalWildcard(</span>
<span class="line-modified">!             String template, boolean chainsToPublicCA) {</span>
          // not ok if it is a single wildcard character or &quot;*.&quot;
          if (template.equals(&quot;*&quot;) || template.equals(&quot;*.&quot;)) {
              if (SSLLogger.isOn) {
                  SSLLogger.fine(
                      &quot;Certificate domain name has illegal single &quot; +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,29 ***</span>
                      &quot;no dot after wildcard character: &quot; + template);
              }
              return true;
          }
  
<span class="line-removed">-         // If the wildcarded domain is a top-level domain under which names</span>
<span class="line-removed">-         // can be registered, then a wildcard is not allowed.</span>
<span class="line-removed">- </span>
          if (!chainsToPublicCA) {
              return false; // skip check for non-public certificates
          }
<span class="line-modified">!         Optional&lt;RegisteredDomain&gt; rd = RegisteredDomain.from(domain)</span>
<span class="line-modified">!                 .filter(d -&gt; d.type() == RegisteredDomain.Type.ICANN);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (rd.isPresent()) {</span>
<span class="line-modified">!             String wDomain = afterWildcard.substring(firstDotIndex + 1);</span>
<span class="line-modified">!             if (rd.get().publicSuffix().equalsIgnoreCase(wDomain)) {</span>
<span class="line-modified">!                 if (SSLLogger.isOn) {</span>
<span class="line-modified">!                     SSLLogger.fine(</span>
<span class="line-modified">!                         &quot;Certificate domain name has illegal &quot; +</span>
<span class="line-modified">!                         &quot;wildcard for public suffix: &quot; + template);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 return true;</span>
              }
          }
  
          return false;
      }
  
<span class="line-new-header">--- 336,33 ---</span>
                      &quot;no dot after wildcard character: &quot; + template);
              }
              return true;
          }
  
          if (!chainsToPublicCA) {
              return false; // skip check for non-public certificates
          }
<span class="line-modified">! </span>
<span class="line-modified">!         // If the wildcarded domain is a top-level domain under which names</span>
<span class="line-modified">!         // can be registered, then a wildcard is not allowed.</span>
<span class="line-modified">!         String wildcardedDomain = afterWildcard.substring(firstDotIndex + 1);</span>
<span class="line-modified">!         String templateDomainSuffix =</span>
<span class="line-modified">!                 RegisteredDomain.from(&quot;z.&quot; + wildcardedDomain)</span>
<span class="line-modified">!                     .filter(d -&gt; d.type() == RegisteredDomain.Type.ICANN)</span>
<span class="line-modified">!                     .map(RegisteredDomain::publicSuffix).orElse(null);</span>
<span class="line-modified">!         if (templateDomainSuffix == null) {</span>
<span class="line-modified">!             return false;   // skip check if not known public suffix</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-added">+         // Is it a top-level domain?</span>
<span class="line-added">+         if (wildcardedDomain.equalsIgnoreCase(templateDomainSuffix)) {</span>
<span class="line-added">+             if (SSLLogger.isOn) {</span>
<span class="line-added">+                 SSLLogger.fine(</span>
<span class="line-added">+                     &quot;Certificate domain name has illegal &quot; +</span>
<span class="line-added">+                     &quot;wildcard for top-level public suffix: &quot; + template);</span>
              }
<span class="line-added">+             return true;</span>
          }
  
          return false;
      }
  
</pre>
<center><a href="HexDumpEncoder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="IOUtils.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
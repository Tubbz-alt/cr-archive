<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/DTLSInputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.GeneralSecurityException;
  31 import java.util.Collections;
  32 import java.util.HashMap;
  33 import java.util.Iterator;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Set;
  37 import java.util.TreeSet;
  38 import javax.crypto.BadPaddingException;
  39 import javax.net.ssl.SSLException;
  40 import sun.security.ssl.SSLCipher.SSLReadCipher;
  41 
  42 /**
  43  * DTLS {@code InputRecord} implementation for {@code SSLEngine}.
  44  */
  45 final class DTLSInputRecord extends InputRecord implements DTLSRecord {
  46     private DTLSReassembler reassembler = null;
  47     private int             readEpoch;
  48 
  49     DTLSInputRecord(HandshakeHash handshakeHash) {
  50         super(handshakeHash, SSLReadCipher.nullDTlsReadCipher());
  51         this.readEpoch = 0;
  52     }
  53 
  54     @Override
  55     void changeReadCiphers(SSLReadCipher readCipher) {
  56         this.readCipher = readCipher;
  57         this.readEpoch++;
  58     }
  59 
  60     @Override
  61     public void close() throws IOException {
  62         if (!isClosed) {
  63             super.close();
  64         }
  65     }
  66 
  67     @Override
  68     boolean isEmpty() {
  69         return ((reassembler == null) || reassembler.isEmpty());
  70     }
  71 
  72     @Override
  73     int estimateFragmentSize(int packetSize) {
  74         if (packetSize &gt; 0) {
  75             return readCipher.estimateFragmentSize(packetSize, headerSize);
  76         } else {
  77             return Record.maxDataSize;
  78         }
  79     }
  80 
  81     @Override
  82     void expectingFinishFlight() {
  83         if (reassembler != null) {
  84             reassembler.expectingFinishFlight();
  85         }
  86     }
  87 
  88     @Override
  89     void finishHandshake() {
  90         reassembler = null;
  91     }
  92 
  93     @Override
  94     Plaintext acquirePlaintext() {
  95         if (reassembler != null) {
  96             return reassembler.acquirePlaintext();
  97         }
  98 
  99         return null;
 100     }
 101 
 102      @Override
 103     Plaintext[] decode(ByteBuffer[] srcs, int srcsOffset,
 104             int srcsLength) throws IOException, BadPaddingException {
 105         if (srcs == null || srcs.length == 0 || srcsLength == 0) {
 106             Plaintext pt = acquirePlaintext();
 107             return pt == null ? new Plaintext[0] : new Plaintext[] { pt };
 108         } else if (srcsLength == 1) {
 109             return decode(srcs[srcsOffset]);
 110         } else {
 111             ByteBuffer packet = extract(srcs,
 112                     srcsOffset, srcsLength, DTLSRecord.headerSize);
 113             return decode(packet);
 114         }
 115     }
 116 
 117     Plaintext[] decode(ByteBuffer packet) {
 118         if (isClosed) {
 119             return null;
 120         }
 121 
 122         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
 123             SSLLogger.fine(&quot;Raw read&quot;, packet);
 124         }
 125 
 126         // The caller should have validated the record.
 127         int srcPos = packet.position();
 128         int srcLim = packet.limit();
 129 
 130         byte contentType = packet.get();                   // pos: 0
 131         byte majorVersion = packet.get();                  // pos: 1
 132         byte minorVersion = packet.get();                  // pos: 2
 133         byte[] recordEnS = new byte[8];                    // epoch + seqence
 134         packet.get(recordEnS);
 135         int recordEpoch = ((recordEnS[0] &amp; 0xFF) &lt;&lt; 8) |
 136                            (recordEnS[1] &amp; 0xFF);          // pos: 3, 4
 137         long recordSeq  = ((recordEnS[2] &amp; 0xFFL) &lt;&lt; 40) |
 138                           ((recordEnS[3] &amp; 0xFFL) &lt;&lt; 32) |
 139                           ((recordEnS[4] &amp; 0xFFL) &lt;&lt; 24) |
 140                           ((recordEnS[5] &amp; 0xFFL) &lt;&lt; 16) |
 141                           ((recordEnS[6] &amp; 0xFFL) &lt;&lt;  8) |
 142                            (recordEnS[7] &amp; 0xFFL);         // pos: 5-10
 143 
 144         int contentLen = ((packet.get() &amp; 0xFF) &lt;&lt; 8) |
 145                           (packet.get() &amp; 0xFF);           // pos: 11, 12
 146 
 147         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
 148             SSLLogger.fine(&quot;READ: &quot; +
 149                     ProtocolVersion.nameOf(majorVersion, minorVersion) +
 150                     &quot; &quot; + ContentType.nameOf(contentType) + &quot;, length = &quot; +
 151                     contentLen);
 152         }
 153 
 154         int recLim = Math.addExact(srcPos, DTLSRecord.headerSize + contentLen);
 155 
 156         if (this.readEpoch &gt; recordEpoch) {
 157             // Reset the position of the packet buffer.
 158             packet.position(recLim);
 159             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
 160                 SSLLogger.fine(&quot;READ: discard this old record&quot;, recordEnS);
 161             }
 162             return null;
 163         }
 164 
 165         // Buffer next epoch message if necessary.
 166         if (this.readEpoch &lt; recordEpoch) {
 167             // Discard the record younger than the current epcoh if:
 168             // 1. it is not a handshake message, or
 169             // 3. it is not of next epoch.
 170             if ((contentType != ContentType.HANDSHAKE.id &amp;&amp;
 171                     contentType != ContentType.CHANGE_CIPHER_SPEC.id) ||
 172                 (reassembler == null &amp;&amp;
 173                     contentType != ContentType.HANDSHAKE.id) ||
 174                 (this.readEpoch &lt; (recordEpoch - 1))) {
 175 
 176                 packet.position(recLim);
 177 
 178                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 179                     SSLLogger.fine(&quot;Premature record (epoch), discard it.&quot;);
 180                 }
 181 
 182                 return null;
 183             }
 184 
 185 
 186             // Not ready to decrypt this record, may be an encrypted Finished
 187             // message, need to buffer it.
 188             byte[] fragment = new byte[contentLen];
 189             packet.get(fragment);              // copy the fragment
 190             RecordFragment buffered = new RecordFragment(fragment, contentType,
 191                     majorVersion, minorVersion,
 192                     recordEnS, recordEpoch, recordSeq, true);
 193 
 194             if (reassembler == null) {
 195                 reassembler = new DTLSReassembler(recordEpoch);
 196             }
 197             reassembler.queueUpFragment(buffered);
 198 
 199             // consume the full record in the packet buffer.
 200             packet.position(recLim);
 201 
 202             Plaintext pt = reassembler.acquirePlaintext();
 203             return pt == null ? null : new Plaintext[] { pt };
 204         }
 205 
 206         //
 207         // Now, the message is of this epoch.
 208         //
 209         // decrypt the fragment
 210         packet.limit(recLim);
 211         packet.position(srcPos + DTLSRecord.headerSize);
 212 
 213         ByteBuffer plaintextFragment;
 214         try {
 215             Plaintext plaintext =
 216                     readCipher.decrypt(contentType, packet, recordEnS);
 217             plaintextFragment = plaintext.fragment;
 218             contentType = plaintext.contentType;
 219         } catch (GeneralSecurityException gse) {
 220             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 221                 SSLLogger.fine(&quot;Discard invalid record: &quot; + gse);
 222             }
 223 
 224             // invalid, discard this record [section 4.1.2.7, RFC 6347]
 225             return null;
 226         } finally {
 227             // consume a complete record
 228             packet.limit(srcLim);
 229             packet.position(recLim);
 230         }
 231 
 232         if (contentType != ContentType.CHANGE_CIPHER_SPEC.id &amp;&amp;
 233             contentType != ContentType.HANDSHAKE.id) {   // app data or alert
 234                                                     // no retransmission
 235             // Cleanup the handshake reassembler if necessary.
 236             if ((reassembler != null) &amp;&amp;
 237                     (reassembler.handshakeEpoch &lt; recordEpoch)) {
 238                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 239                     SSLLogger.fine(&quot;Cleanup the handshake reassembler&quot;);
 240                 }
 241 
 242                 reassembler = null;
 243             }
 244 
 245             return new Plaintext[] {
 246                     new Plaintext(contentType, majorVersion, minorVersion,
 247                             recordEpoch, Authenticator.toLong(recordEnS),
 248                             plaintextFragment)};
 249         }
 250 
 251         if (contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
 252             if (reassembler == null) {
 253                 reassembler = new DTLSReassembler(recordEpoch);
 254             }
 255 
 256             reassembler.queueUpChangeCipherSpec(
 257                     new RecordFragment(plaintextFragment, contentType,
 258                             majorVersion, minorVersion,
 259                             recordEnS, recordEpoch, recordSeq, false));
 260         } else {    // handshake record
 261             // One record may contain 1+ more handshake messages.
 262             while (plaintextFragment.remaining() &gt; 0) {
 263 
 264                 HandshakeFragment hsFrag = parseHandshakeMessage(
 265                     contentType, majorVersion, minorVersion,
 266                     recordEnS, recordEpoch, recordSeq, plaintextFragment);
 267 
 268                 if (hsFrag == null) {
 269                     // invalid, discard this record
 270                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 271                         SSLLogger.fine(
 272                                 &quot;Invalid handshake message, discard it.&quot;);
 273                     }
 274 
 275                     return null;
 276                 }
 277 
 278                 if (reassembler == null) {
 279                     reassembler = new DTLSReassembler(recordEpoch);
 280                 }
 281 
 282                 reassembler.queueUpHandshake(hsFrag);
 283             }
 284         }
 285 
 286         // Completed the read of the full record.  Acquire the reassembled
 287         // messages.
 288         if (reassembler != null) {
 289             Plaintext pt = reassembler.acquirePlaintext();
 290             return pt == null ? null : new Plaintext[] { pt };
 291         }
 292 
 293         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 294              SSLLogger.fine(&quot;The reassembler is not initialized yet.&quot;);
 295         }
 296 
 297         return null;
 298     }
 299 
 300     @Override
 301     int bytesInCompletePacket(
 302         ByteBuffer[] srcs, int srcsOffset, int srcsLength) throws IOException {
 303 
 304         return bytesInCompletePacket(srcs[srcsOffset]);
 305     }
 306 
 307     private int bytesInCompletePacket(ByteBuffer packet) throws SSLException {
 308 
 309         // DTLS length field is in bytes 11/12
 310         if (packet.remaining() &lt; headerSize) {
 311             return -1;
 312         }
 313 
 314         // Last sanity check that it&#39;s not a wild record
 315         int pos = packet.position();
 316 
 317         // Check the content type of the record.
 318         byte contentType = packet.get(pos);
 319         if (ContentType.valueOf(contentType) == null) {
 320             throw new SSLException(
 321                     &quot;Unrecognized SSL message, plaintext connection?&quot;);
 322         }
 323 
 324         // Check the protocol version of the record.
 325         byte majorVersion = packet.get(pos + 1);
 326         byte minorVersion = packet.get(pos + 2);
 327         if (!ProtocolVersion.isNegotiable(
 328                 majorVersion, minorVersion, true, false)) {
 329             throw new SSLException(&quot;Unrecognized record version &quot; +
 330                     ProtocolVersion.nameOf(majorVersion, minorVersion) +
 331                     &quot; , plaintext connection?&quot;);
 332         }
 333 
 334         // Get the fragment length of the record.
 335         int fragLen = ((packet.get(pos + 11) &amp; 0xFF) &lt;&lt; 8) +
 336                        (packet.get(pos + 12) &amp; 0xFF) + headerSize;
 337         if (fragLen &gt; Record.maxFragmentSize) {
 338             throw new SSLException(
 339                     &quot;Record overflow, fragment length (&quot; + fragLen +
 340                     &quot;) MUST not exceed &quot; + Record.maxFragmentSize);
 341         }
 342 
 343         return fragLen;
 344     }
 345 
 346     private static HandshakeFragment parseHandshakeMessage(
 347             byte contentType, byte majorVersion, byte minorVersion,
 348             byte[] recordEnS, int recordEpoch, long recordSeq,
 349             ByteBuffer plaintextFragment) {
 350 
 351         int remaining = plaintextFragment.remaining();
 352         if (remaining &lt; handshakeHeaderSize) {
 353             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 354                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 355                         &quot;too small record to hold a handshake fragment&quot;);
 356             }
 357 
 358             // invalid, discard this record [section 4.1.2.7, RFC 6347]
 359             return null;
 360         }
 361 
 362         // Fail fast for unknown handshake message.
 363         byte handshakeType = plaintextFragment.get();       // pos: 0
 364         if (!SSLHandshake.isKnown(handshakeType)) {
 365             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 366                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 367                         &quot;unknown handshake type size, Handshake.msg_type = &quot; +
 368                         (handshakeType &amp; 0xFF));
 369             }
 370 
 371             // invalid, discard this record [section 4.1.2.7, RFC 6347]
 372             return null;
 373         }
 374 
 375         int messageLength =
 376                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 377                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 378                  (plaintextFragment.get() &amp; 0xFF);          // pos: 1-3
 379         int messageSeq =
 380                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 381                  (plaintextFragment.get() &amp; 0xFF);          // pos: 4/5
 382         int fragmentOffset =
 383                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 384                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 385                  (plaintextFragment.get() &amp; 0xFF);          // pos: 6-8
 386         int fragmentLength =
 387                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 388                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 389                  (plaintextFragment.get() &amp; 0xFF);          // pos: 9-11
 390         if ((remaining - handshakeHeaderSize) &lt; fragmentLength) {
 391             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 392                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 393                         &quot;not a complete handshake fragment in the record&quot;);
 394             }
 395 
 396             // invalid, discard this record [section 4.1.2.7, RFC 6347]
 397             return null;
 398         }
 399 
 400         byte[] fragment = new byte[fragmentLength];
 401         plaintextFragment.get(fragment);
 402 
 403         return new HandshakeFragment(fragment, contentType,
 404                 majorVersion, minorVersion,
 405                 recordEnS, recordEpoch, recordSeq,
 406                 handshakeType, messageLength,
 407                 messageSeq, fragmentOffset, fragmentLength);
 408     }
 409 
 410     // buffered record fragment
 411     private static class RecordFragment implements Comparable&lt;RecordFragment&gt; {
 412         boolean         isCiphertext;
 413 
 414         byte            contentType;
 415         byte            majorVersion;
 416         byte            minorVersion;
 417         int             recordEpoch;
 418         long            recordSeq;
 419         byte[]          recordEnS;
 420         byte[]          fragment;
 421 
 422         RecordFragment(ByteBuffer fragBuf, byte contentType,
 423                 byte majorVersion, byte minorVersion, byte[] recordEnS,
 424                 int recordEpoch, long recordSeq, boolean isCiphertext) {
 425             this((byte[])null, contentType, majorVersion, minorVersion,
 426                     recordEnS, recordEpoch, recordSeq, isCiphertext);
 427 
 428             this.fragment = new byte[fragBuf.remaining()];
 429             fragBuf.get(this.fragment);
 430         }
 431 
 432         RecordFragment(byte[] fragment, byte contentType,
 433                 byte majorVersion, byte minorVersion, byte[] recordEnS,
 434                 int recordEpoch, long recordSeq, boolean isCiphertext) {
 435             this.isCiphertext = isCiphertext;
 436 
 437             this.contentType = contentType;
 438             this.majorVersion = majorVersion;
 439             this.minorVersion = minorVersion;
 440             this.recordEpoch = recordEpoch;
 441             this.recordSeq = recordSeq;
 442             this.recordEnS = recordEnS;
 443             this.fragment = fragment;       // The caller should have cloned
 444                                             // the buffer if necessary.
 445         }
 446 
 447         @Override
 448         public int compareTo(RecordFragment o) {
 449             if (this.contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
 450                 if (o.contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
 451                     // Only one incoming ChangeCipherSpec message for an epoch.
 452                     //
 453                     // Ignore duplicated ChangeCipherSpec messages.
 454                     return Integer.compare(this.recordEpoch, o.recordEpoch);
 455                 } else if ((this.recordEpoch == o.recordEpoch) &amp;&amp;
 456                         (o.contentType == ContentType.HANDSHAKE.id)) {
 457                     // ChangeCipherSpec is the latest message of an epoch.
 458                     return 1;
 459                 }
 460             } else if (o.contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
 461                 if ((this.recordEpoch == o.recordEpoch) &amp;&amp;
 462                         (this.contentType == ContentType.HANDSHAKE.id)) {
 463                     // ChangeCipherSpec is the latest message of an epoch.
 464                     return -1;
 465                 } else {
 466                     // different epoch or this is not a handshake message
 467                     return compareToSequence(o.recordEpoch, o.recordSeq);
 468                 }
 469             }
 470 
 471             return compareToSequence(o.recordEpoch, o.recordSeq);
 472         }
 473 
 474         int compareToSequence(int epoch, long seq) {
 475             if (this.recordEpoch &gt; epoch) {
 476                 return 1;
 477             } else if (this.recordEpoch == epoch) {
 478                 return Long.compare(this.recordSeq, seq);
 479             } else {
 480                 return -1;
 481             }
 482         }
 483     }
 484 
 485     // buffered handshake message
 486     private static final class HandshakeFragment extends RecordFragment {
 487 
 488         byte            handshakeType;     // handshake msg_type
 489         int             messageSeq;        // message_seq
 490         int             messageLength;     // Handshake body length
 491         int             fragmentOffset;    // fragment_offset
 492         int             fragmentLength;    // fragment_length
 493 
 494         HandshakeFragment(byte[] fragment, byte contentType,
 495                 byte majorVersion, byte minorVersion, byte[] recordEnS,
 496                 int recordEpoch, long recordSeq,
 497                 byte handshakeType, int messageLength,
 498                 int messageSeq, int fragmentOffset, int fragmentLength) {
 499 
 500             super(fragment, contentType, majorVersion, minorVersion,
 501                     recordEnS, recordEpoch , recordSeq, false);
 502 
 503             this.handshakeType = handshakeType;
 504             this.messageSeq = messageSeq;
 505             this.messageLength = messageLength;
 506             this.fragmentOffset = fragmentOffset;
 507             this.fragmentLength = fragmentLength;
 508         }
 509 
 510         @Override
 511         public int compareTo(RecordFragment o) {
 512             if (o instanceof HandshakeFragment) {
 513                 HandshakeFragment other = (HandshakeFragment)o;
 514                 if (this.messageSeq != other.messageSeq) {
 515                     // keep the insertion order of handshake messages
 516                     return this.messageSeq - other.messageSeq;
 517                 } else if (this.fragmentOffset != other.fragmentOffset) {
 518                     // small fragment offset was transmitted first
 519                     return this.fragmentOffset - other.fragmentOffset;
 520                 } else if (this.fragmentLength == other.fragmentLength) {
 521                     // retransmissions, ignore duplicated messages.
 522                     return 0;
 523                 }
 524 
 525                 // Should be repacked for suitable fragment length.
 526                 //
 527                 // Note that the acquiring processes will reassemble
 528                 // the fragments later.
 529                 return compareToSequence(o.recordEpoch, o.recordSeq);
 530             }
 531 
 532             return super.compareTo(o);
 533         }
 534     }
 535 
 536     private static final class HoleDescriptor {
 537         int offset;             // fragment_offset
 538         int limit;              // fragment_offset + fragment_length
 539 
 540         HoleDescriptor(int offset, int limit) {
 541             this.offset = offset;
 542             this.limit = limit;
 543         }
 544     }
 545 
 546     private static final class HandshakeFlight implements Cloneable {
 547         static final byte HF_UNKNOWN = SSLHandshake.NOT_APPLICABLE.id;
 548 
 549         byte        handshakeType;      // handshake type
 550         int         flightEpoch;        // the epoch of the first message
 551         int         minMessageSeq;      // minimal message sequence
 552 
 553         int         maxMessageSeq;      // maximum message sequence
 554         int         maxRecordEpoch;     // maximum record sequence number
 555         long        maxRecordSeq;       // maximum record sequence number
 556 
 557         HashMap&lt;Byte, List&lt;HoleDescriptor&gt;&gt; holesMap;
 558 
 559         HandshakeFlight() {
 560             this.handshakeType = HF_UNKNOWN;
 561             this.flightEpoch = 0;
 562             this.minMessageSeq = 0;
 563 
 564             this.maxMessageSeq = 0;
 565             this.maxRecordEpoch = 0;
 566             this.maxRecordSeq = -1;
 567 
 568             this.holesMap = new HashMap&lt;&gt;(5);
 569         }
 570 
 571         boolean isRetransmitOf(HandshakeFlight hs) {
 572             return (hs != null) &amp;&amp;
 573                    (this.handshakeType == hs.handshakeType) &amp;&amp;
 574                    (this.minMessageSeq == hs.minMessageSeq);
 575         }
 576 
 577         @Override
 578         public Object clone() {
 579             HandshakeFlight hf = new HandshakeFlight();
 580 
 581             hf.handshakeType = this.handshakeType;
 582             hf.flightEpoch = this.flightEpoch;
 583             hf.minMessageSeq = this.minMessageSeq;
 584 
 585             hf.maxMessageSeq = this.maxMessageSeq;
 586             hf.maxRecordEpoch = this.maxRecordEpoch;
 587             hf.maxRecordSeq = this.maxRecordSeq;
 588 
 589             hf.holesMap = new HashMap&lt;&gt;(this.holesMap);
 590 
 591             return hf;
 592         }
 593     }
 594 
 595     final class DTLSReassembler {
 596         // The handshake epoch.
 597         final int handshakeEpoch;
 598 
 599         // The buffered fragments.
 600         TreeSet&lt;RecordFragment&gt; bufferedFragments = new TreeSet&lt;&gt;();
 601 
 602         // The handshake flight in progress.
 603         HandshakeFlight handshakeFlight = new HandshakeFlight();
 604 
 605         // The preceding handshake flight.
 606         HandshakeFlight precedingFlight = null;
 607 
 608         // Epoch, sequence number and handshake message sequence of the
 609         // next message acquisition of a flight.
 610         int         nextRecordEpoch;        // next record epoch
 611         long        nextRecordSeq = 0;      // next record sequence number
 612 
 613         // Expect ChangeCipherSpec and Finished messages for the final flight.
 614         boolean     expectCCSFlight = false;
 615 
 616         // Ready to process this flight if received all messages of the flight.
 617         boolean     flightIsReady = false;
 618         boolean     needToCheckFlight = false;
 619 
 620         DTLSReassembler(int handshakeEpoch) {
 621             this.handshakeEpoch = handshakeEpoch;
 622             this.nextRecordEpoch = handshakeEpoch;
 623 
 624             this.handshakeFlight.flightEpoch = handshakeEpoch;
 625         }
 626 
 627         void expectingFinishFlight() {
 628             expectCCSFlight = true;
 629         }
 630 
 631         // Queue up a handshake message.
 632         void queueUpHandshake(HandshakeFragment hsf) {
 633             if (!isDesirable(hsf)) {
 634                 // Not a dedired record, discard it.
 635                 return;
 636             }
 637 
 638             // Clean up the retransmission messages if necessary.
 639             cleanUpRetransmit(hsf);
 640 
 641             // Is it the first message of next flight?
 642             //
 643             // Note: the Finished message is handled in the final CCS flight.
 644             boolean isMinimalFlightMessage = false;
 645             if (handshakeFlight.minMessageSeq == hsf.messageSeq) {
 646                 isMinimalFlightMessage = true;
 647             } else if ((precedingFlight != null) &amp;&amp;
 648                     (precedingFlight.minMessageSeq == hsf.messageSeq)) {
 649                 isMinimalFlightMessage = true;
 650             }
 651 
 652             if (isMinimalFlightMessage &amp;&amp; (hsf.fragmentOffset == 0) &amp;&amp;
 653                     (hsf.handshakeType != SSLHandshake.FINISHED.id)) {
 654 
 655                 // reset the handshake flight
 656                 handshakeFlight.handshakeType = hsf.handshakeType;
 657                 handshakeFlight.flightEpoch = hsf.recordEpoch;
 658                 handshakeFlight.minMessageSeq = hsf.messageSeq;
 659             }
 660 
 661             if (hsf.handshakeType == SSLHandshake.FINISHED.id) {
 662                 handshakeFlight.maxMessageSeq = hsf.messageSeq;
 663                 handshakeFlight.maxRecordEpoch = hsf.recordEpoch;
 664                 handshakeFlight.maxRecordSeq = hsf.recordSeq;
 665             } else {
 666                 if (handshakeFlight.maxMessageSeq &lt; hsf.messageSeq) {
 667                     handshakeFlight.maxMessageSeq = hsf.messageSeq;
 668                 }
 669 
 670                 int n = (hsf.recordEpoch - handshakeFlight.maxRecordEpoch);
 671                 if (n &gt; 0) {
 672                     handshakeFlight.maxRecordEpoch = hsf.recordEpoch;
 673                     handshakeFlight.maxRecordSeq = hsf.recordSeq;
 674                 } else if (n == 0) {
 675                     // the same epoch
 676                     if (handshakeFlight.maxRecordSeq &lt; hsf.recordSeq) {
 677                         handshakeFlight.maxRecordSeq = hsf.recordSeq;
 678                     }
 679                 }   // Otherwise, it is unlikely to happen.
 680             }
 681 
 682             boolean fragmented = false;
 683             if ((hsf.fragmentOffset) != 0 ||
 684                 (hsf.fragmentLength != hsf.messageLength)) {
 685 
 686                 fragmented = true;
 687             }
 688 
 689             List&lt;HoleDescriptor&gt; holes =
 690                     handshakeFlight.holesMap.get(hsf.handshakeType);
 691             if (holes == null) {
 692                 if (!fragmented) {
 693                     holes = Collections.emptyList();
 694                 } else {
 695                     holes = new LinkedList&lt;HoleDescriptor&gt;();
 696                     holes.add(new HoleDescriptor(0, hsf.messageLength));
 697                 }
 698                 handshakeFlight.holesMap.put(hsf.handshakeType, holes);
 699             } else if (holes.isEmpty()) {
 700                 // Have got the full handshake message.  This record may be
 701                 // a handshake message retransmission.  Discard this record.
 702                 //
 703                 // It&#39;s OK to discard retransmission as the handshake hash
 704                 // is computed as if each handshake message had been sent
 705                 // as a single fragment.
 706                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 707                     SSLLogger.fine(&quot;Have got the full message, discard it.&quot;);
 708                 }
 709 
 710                 return;
 711             }
 712 
 713             if (fragmented) {
 714                 int fragmentLimit = hsf.fragmentOffset + hsf.fragmentLength;
 715                 for (int i = 0; i &lt; holes.size(); i++) {
 716 
 717                     HoleDescriptor hole = holes.get(i);
 718                     if ((hole.limit &lt;= hsf.fragmentOffset) ||
 719                         (hole.offset &gt;= fragmentLimit)) {
 720                         // Also discard overlapping handshake retransmissions.
 721                         continue;
 722                     }
 723 
 724                     // The ranges SHOULD NOT overlap.
 725                     if (((hole.offset &gt; hsf.fragmentOffset) &amp;&amp;
 726                          (hole.offset &lt; fragmentLimit)) ||
 727                         ((hole.limit &gt; hsf.fragmentOffset) &amp;&amp;
 728                          (hole.limit &lt; fragmentLimit))) {
 729 
 730                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 731                             SSLLogger.fine(&quot;Discard invalid record: &quot; +
 732                                 &quot;handshake fragment ranges are overlapping&quot;);
 733                         }
 734 
 735                         // invalid, discard it [section 4.1.2.7, RFC 6347]
 736                         return;
 737                     }
 738 
 739                     // This record interacts with this hole, fill the hole.
 740                     holes.remove(i);
 741                     // i--;
 742 
 743                     if (hsf.fragmentOffset &gt; hole.offset) {
 744                         holes.add(new HoleDescriptor(
 745                                 hole.offset, hsf.fragmentOffset));
 746                         // i++;
 747                     }
 748 
 749                     if (fragmentLimit &lt; hole.limit) {
 750                         holes.add(new HoleDescriptor(
 751                                 fragmentLimit, hole.limit));
 752                         // i++;
 753                     }
 754 
 755                     // As no ranges overlap, no interact with other holes.
 756                     break;
 757                 }
 758             }
 759 
 760             // buffer this fragment
 761             if (hsf.handshakeType == SSLHandshake.FINISHED.id) {
 762                 // Need no status update.
 763                 bufferedFragments.add(hsf);
 764             } else {
 765                 bufferFragment(hsf);
 766             }
 767         }
 768 
 769         // Queue up a ChangeCipherSpec message
 770         void queueUpChangeCipherSpec(RecordFragment rf) {
 771             if (!isDesirable(rf)) {
 772                 // Not a dedired record, discard it.
 773                 return;
 774             }
 775 
 776             // Clean up the retransmission messages if necessary.
 777             cleanUpRetransmit(rf);
 778 
 779             // Is it the first message of this flight?
 780             //
 781             // Note: the first message of the final flight is ChangeCipherSpec.
 782             if (expectCCSFlight) {
 783                 handshakeFlight.handshakeType = HandshakeFlight.HF_UNKNOWN;
 784                 handshakeFlight.flightEpoch = rf.recordEpoch;
 785             }
 786 
 787             // The epoch should be the same as the first message of the flight.
 788             if (handshakeFlight.maxRecordSeq &lt; rf.recordSeq) {
 789                 handshakeFlight.maxRecordSeq = rf.recordSeq;
 790             }
 791 
 792             // buffer this fragment
 793             bufferFragment(rf);
 794         }
 795 
 796         // Queue up a ciphertext message.
 797         //
 798         // Note: not yet be able to decrypt the message.
 799         void queueUpFragment(RecordFragment rf) {
 800             if (!isDesirable(rf)) {
 801                 // Not a dedired record, discard it.
 802                 return;
 803             }
 804 
 805             // Clean up the retransmission messages if necessary.
 806             cleanUpRetransmit(rf);
 807 
 808             // buffer this fragment
 809             bufferFragment(rf);
 810         }
 811 
 812         private void bufferFragment(RecordFragment rf) {
 813             // append this fragment
 814             bufferedFragments.add(rf);
 815 
 816             if (flightIsReady) {
 817                 flightIsReady = false;
 818             }
 819 
 820             if (!needToCheckFlight) {
 821                 needToCheckFlight = true;
 822             }
 823         }
 824 
 825         private void cleanUpRetransmit(RecordFragment rf) {
 826             // Does the next flight start?
 827             boolean isNewFlight = false;
 828             if (precedingFlight != null) {
 829                 if (precedingFlight.flightEpoch &lt; rf.recordEpoch) {
 830                     isNewFlight = true;
 831                 } else {
 832                     if (rf instanceof HandshakeFragment) {
 833                         HandshakeFragment hsf = (HandshakeFragment)rf;
 834                         if (precedingFlight.maxMessageSeq  &lt; hsf.messageSeq) {
 835                             isNewFlight = true;
 836                         }
 837                     } else if (
 838                         rf.contentType != ContentType.CHANGE_CIPHER_SPEC.id) {
 839 
 840                         // ciphertext
 841                         if (precedingFlight.maxRecordEpoch &lt; rf.recordEpoch) {
 842                             isNewFlight = true;
 843                         }
 844                     }
 845                 }
 846             }
 847 
 848             if (!isNewFlight) {
 849                 // Need no cleanup.
 850                 return;
 851             }
 852 
 853             // clean up the buffer
 854             for (Iterator&lt;RecordFragment&gt; it = bufferedFragments.iterator();
 855                     it.hasNext();) {
 856 
 857                 RecordFragment frag = it.next();
 858                 boolean isOld = false;
 859                 if (frag.recordEpoch &lt; precedingFlight.maxRecordEpoch) {
 860                     isOld = true;
 861                 } else if (frag.recordEpoch == precedingFlight.maxRecordEpoch) {
 862                     if (frag.recordSeq &lt;= precedingFlight.maxRecordSeq) {
 863                         isOld = true;
 864                     }
 865                 }
 866 
 867                 if (!isOld &amp;&amp; (frag instanceof HandshakeFragment)) {
 868                     HandshakeFragment hsf = (HandshakeFragment)frag;
 869                     isOld = (hsf.messageSeq &lt;= precedingFlight.maxMessageSeq);
 870                 }
 871 
 872                 if (isOld) {
 873                     it.remove();
 874                 } else {
 875                     // Safe to break as items in the buffer are ordered.
 876                     break;
 877                 }
 878             }
 879 
 880             // discard retransmissions of the previous flight if any.
 881             precedingFlight = null;
 882         }
 883 
 884         // Is a desired record?
 885         //
 886         // Check for retransmission and lost records.
 887         private boolean isDesirable(RecordFragment rf) {
 888             //
 889             // Discard records old than the previous epoch.
 890             //
 891             int previousEpoch = nextRecordEpoch - 1;
 892             if (rf.recordEpoch &lt; previousEpoch) {
 893                 // Too old to use, discard this record.
 894                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 895                     SSLLogger.fine(
 896                             &quot;Too old epoch to use this record, discard it.&quot;);
 897                 }
 898 
 899                 return false;
 900             }
 901 
 902             //
 903             // Allow retransmission of last flight of the previous epoch
 904             //
 905             // For example, the last server delivered flight for session
 906             // resuming abbreviated handshaking consist three messages:
 907             //      ServerHello
 908             //      [ChangeCipherSpec]
 909             //      Finished
 910             //
 911             // The epoch number is incremented and the sequence number is reset
 912             // if the ChangeCipherSpec is sent.
 913             if (rf.recordEpoch == previousEpoch) {
 914                 boolean isDesired = true;
 915                 if (precedingFlight == null) {
 916                     isDesired = false;
 917                 } else {
 918                     if (rf instanceof HandshakeFragment) {
 919                         HandshakeFragment hsf = (HandshakeFragment)rf;
 920                         if (precedingFlight.minMessageSeq &gt; hsf.messageSeq) {
 921                             isDesired = false;
 922                         }
 923                     } else if (
 924                         rf.contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
 925 
 926                         // ChangeCipherSpec
 927                         if (precedingFlight.flightEpoch != rf.recordEpoch) {
 928                             isDesired = false;
 929                         }
 930                     } else {        // ciphertext
 931                         if ((rf.recordEpoch &lt; precedingFlight.maxRecordEpoch) ||
 932                             (rf.recordEpoch == precedingFlight.maxRecordEpoch &amp;&amp;
 933                                 rf.recordSeq &lt;= precedingFlight.maxRecordSeq)) {
 934                             isDesired = false;
 935                         }
 936                     }
 937                 }
 938 
 939                 if (!isDesired) {
 940                     // Too old to use, discard this retransmitted record
 941                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 942                         SSLLogger.fine(
 943                                 &quot;Too old retransmission to use, discard it.&quot;);
 944                     }
 945 
 946                     return false;
 947                 }
 948             } else if ((rf.recordEpoch == nextRecordEpoch) &amp;&amp;
 949                     (nextRecordSeq &gt; rf.recordSeq)) {
 950 
 951                 // Previously disordered record for the current epoch.
 952                 //
 953                 // Should has been retransmitted. Discard this record.
 954                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 955                     SSLLogger.fine(
 956                             &quot;Lagging behind record (sequence), discard it.&quot;);
 957                 }
 958 
 959                 return false;
 960             }
 961 
 962             return true;
 963         }
 964 
 965         private boolean isEmpty() {
 966             return (bufferedFragments.isEmpty() ||
 967                     (!flightIsReady &amp;&amp; !needToCheckFlight) ||
 968                     (needToCheckFlight &amp;&amp; !flightIsReady()));
 969         }
 970 
 971         Plaintext acquirePlaintext() {
 972             if (bufferedFragments.isEmpty()) {
 973                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 974                     SSLLogger.fine(&quot;No received handshake messages&quot;);
 975                 }
 976                 return null;
 977             }
 978 
 979             if (!flightIsReady &amp;&amp; needToCheckFlight) {
 980                 // check the fligth status
 981                 flightIsReady = flightIsReady();
 982 
 983                 // Reset if this flight is ready.
 984                 if (flightIsReady) {
 985                     // Retransmitted handshake messages are not needed for
 986                     // further handshaking processing.
 987                     if (handshakeFlight.isRetransmitOf(precedingFlight)) {
 988                         // cleanup
 989                         bufferedFragments.clear();
 990 
 991                         // Reset the next handshake flight.
 992                         resetHandshakeFlight(precedingFlight);
 993 
 994                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
 995                             SSLLogger.fine(&quot;Received a retransmission flight.&quot;);
 996                         }
 997 
 998                         return Plaintext.PLAINTEXT_NULL;
 999                     }
1000                 }
1001 
1002                 needToCheckFlight = false;
1003             }
1004 
1005             if (!flightIsReady) {
1006                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1007                     SSLLogger.fine(
1008                             &quot;The handshake flight is not ready to use: &quot; +
1009                             handshakeFlight.handshakeType);
1010                 }
1011                 return null;
1012             }
1013 
1014             RecordFragment rFrag = bufferedFragments.first();
1015             Plaintext plaintext;
1016             if (!rFrag.isCiphertext) {
1017                 // handshake message, or ChangeCipherSpec message
1018                 plaintext = acquireHandshakeMessage();
1019 
1020                 // Reset the handshake flight.
1021                 if (bufferedFragments.isEmpty()) {
1022                     // Need not to backup the holes map.  Clear up it at first.
1023                     handshakeFlight.holesMap.clear();   // cleanup holes map
1024 
1025                     // Update the preceding flight.
1026                     precedingFlight = (HandshakeFlight)handshakeFlight.clone();
1027 
1028                     // Reset the next handshake flight.
1029                     resetHandshakeFlight(precedingFlight);
1030 
1031                     if (expectCCSFlight &amp;&amp;
1032                             (precedingFlight.handshakeType ==
1033                                     HandshakeFlight.HF_UNKNOWN)) {
1034                         expectCCSFlight = false;
1035                     }
1036                 }
1037             } else {
1038                 // a Finished message or other ciphertexts
1039                 plaintext = acquireCachedMessage();
1040             }
1041 
1042             return plaintext;
1043         }
1044 
1045         //
1046         // Reset the handshake flight from a previous one.
1047         //
1048         private void resetHandshakeFlight(HandshakeFlight prev) {
1049             // Reset the next handshake flight.
1050             handshakeFlight.handshakeType = HandshakeFlight.HF_UNKNOWN;
1051             handshakeFlight.flightEpoch = prev.maxRecordEpoch;
1052             if (prev.flightEpoch != prev.maxRecordEpoch) {
1053                 // a new epoch starts
1054                 handshakeFlight.minMessageSeq = 0;
1055             } else {
1056                 // stay at the same epoch
1057                 //
1058                 // The minimal message sequence number will get updated if
1059                 // a flight retransmission happens.
1060                 handshakeFlight.minMessageSeq = prev.maxMessageSeq + 1;
1061             }
1062 
1063             // cleanup the maximum sequence number and epoch number.
1064             //
1065             // Note: actually, we need to do nothing because the reassembler
1066             // of handshake messages will reset them properly even for
1067             // retransmissions.
1068             //
1069             handshakeFlight.maxMessageSeq = 0;
1070             handshakeFlight.maxRecordEpoch = handshakeFlight.flightEpoch;
1071 
1072             // Record sequence number cannot wrap even for retransmissions.
1073             handshakeFlight.maxRecordSeq = prev.maxRecordSeq + 1;
1074 
1075             // cleanup holes map
1076             handshakeFlight.holesMap.clear();
1077 
1078             // Ready to accept new input record.
1079             flightIsReady = false;
1080             needToCheckFlight = false;
1081         }
1082 
1083         private Plaintext acquireCachedMessage() {
1084             RecordFragment rFrag = bufferedFragments.first();
1085             if (readEpoch != rFrag.recordEpoch) {
1086                 if (readEpoch &gt; rFrag.recordEpoch) {
1087                     // discard old records
1088                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1089                         SSLLogger.fine(
1090                                 &quot;Discard old buffered ciphertext fragments.&quot;);
1091                     }
1092                     bufferedFragments.remove(rFrag);    // popup the fragment
1093                 }
1094 
1095                 // reset the flight
1096                 if (flightIsReady) {
1097                     flightIsReady = false;
1098                 }
1099 
1100                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1101                     SSLLogger.fine(
1102                             &quot;Not yet ready to decrypt the cached fragments.&quot;);
1103                 }
1104                 return null;
1105             }
1106 
1107             bufferedFragments.remove(rFrag);    // popup the fragment
1108 
1109             ByteBuffer fragment = ByteBuffer.wrap(rFrag.fragment);
1110             ByteBuffer plaintextFragment = null;
1111             try {
1112                 Plaintext plaintext = readCipher.decrypt(
1113                         rFrag.contentType, fragment, rFrag.recordEnS);
1114                 plaintextFragment = plaintext.fragment;
1115                 rFrag.contentType = plaintext.contentType;
1116             } catch (GeneralSecurityException gse) {
1117                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1118                     SSLLogger.fine(&quot;Discard invalid record: &quot;, gse);
1119                 }
1120 
1121                 // invalid, discard this record [section 4.1.2.7, RFC 6347]
1122                 return null;
1123             }
1124 
1125             // The ciphtext handshake message can only be Finished (the
1126             // end of this flight), ClinetHello or HelloRequest (the
1127             // beginning of the next flight) message.  Need not to check
1128             // any ChangeCipherSpec message.
1129             if (rFrag.contentType == ContentType.HANDSHAKE.id) {
1130                 while (plaintextFragment.remaining() &gt; 0) {
1131                     HandshakeFragment hsFrag = parseHandshakeMessage(
1132                             rFrag.contentType,
1133                             rFrag.majorVersion, rFrag.minorVersion,
1134                             rFrag.recordEnS, rFrag.recordEpoch, rFrag.recordSeq,
1135                             plaintextFragment);
1136 
1137                     if (hsFrag == null) {
1138                         // invalid, discard this record
1139                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1140                             SSLLogger.fine(
1141                                     &quot;Invalid handshake fragment, discard it&quot;,
1142                                     plaintextFragment);
1143                         }
1144                         return null;
1145                     }
1146 
1147                     queueUpHandshake(hsFrag);
1148                     // The flight ready status (flightIsReady) should have
1149                     // been checked and updated for the Finished handshake
1150                     // message before the decryption.  Please don&#39;t update
1151                     // flightIsReady for Finished messages.
1152                     if (hsFrag.handshakeType != SSLHandshake.FINISHED.id) {
1153                         flightIsReady = false;
1154                         needToCheckFlight = true;
1155                     }
1156                 }
1157 
1158                 return acquirePlaintext();
1159             } else {
1160                 return new Plaintext(rFrag.contentType,
1161                         rFrag.majorVersion, rFrag.minorVersion,
1162                         rFrag.recordEpoch,
1163                         Authenticator.toLong(rFrag.recordEnS),
1164                         plaintextFragment);
1165             }
1166         }
1167 
1168         private Plaintext acquireHandshakeMessage() {
1169 
1170             RecordFragment rFrag = bufferedFragments.first();
1171             if (rFrag.contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
1172                 this.nextRecordEpoch = rFrag.recordEpoch + 1;
1173 
1174                 // For retransmissions, the next record sequence number is a
1175                 // positive value.  Don&#39;t worry about it as the acquiring of
1176                 // the immediately followed Finished handshake message will
1177                 // reset the next record sequence number correctly.
1178                 this.nextRecordSeq = 0;
1179 
1180                 // Popup the fragment.
1181                 bufferedFragments.remove(rFrag);
1182                 return new Plaintext(rFrag.contentType,
1183                         rFrag.majorVersion, rFrag.minorVersion,
1184                         rFrag.recordEpoch,
1185                         Authenticator.toLong(rFrag.recordEnS),
1186                         ByteBuffer.wrap(rFrag.fragment));
1187             } else {    // rFrag.contentType == ContentType.HANDSHAKE.id
1188                 HandshakeFragment hsFrag = (HandshakeFragment)rFrag;
1189                 if ((hsFrag.messageLength == hsFrag.fragmentLength) &amp;&amp;
1190                     (hsFrag.fragmentOffset == 0)) {     // no fragmentation
1191 
1192                     bufferedFragments.remove(rFrag);    // popup the fragment
1193 
1194                     // this.nextRecordEpoch = hsFrag.recordEpoch;
1195                     this.nextRecordSeq = hsFrag.recordSeq + 1;
1196 
1197                     // Note: may try to avoid byte array copy in the future.
1198                     byte[] recordFrag = new byte[hsFrag.messageLength + 4];
1199                     Plaintext plaintext = new Plaintext(
1200                             hsFrag.contentType,
1201                             hsFrag.majorVersion, hsFrag.minorVersion,
1202                             hsFrag.recordEpoch,
1203                             Authenticator.toLong(hsFrag.recordEnS),
1204                             ByteBuffer.wrap(recordFrag));
1205 
1206                     // fill the handshake fragment of the record
1207                     recordFrag[0] = hsFrag.handshakeType;
1208                     recordFrag[1] =
1209                             (byte)((hsFrag.messageLength &gt;&gt;&gt; 16) &amp; 0xFF);
1210                     recordFrag[2] =
1211                             (byte)((hsFrag.messageLength &gt;&gt;&gt; 8) &amp; 0xFF);
1212                     recordFrag[3] = (byte)(hsFrag.messageLength &amp; 0xFF);
1213 
1214                     System.arraycopy(hsFrag.fragment, 0,
1215                             recordFrag, 4, hsFrag.fragmentLength);
1216 
1217                     // handshake hashing
1218                     handshakeHashing(hsFrag, plaintext);
1219 
1220                     return plaintext;
1221                 } else {                // fragmented handshake message
1222                     // the first record
1223                     //
1224                     // Note: may try to avoid byte array copy in the future.
1225                     byte[] recordFrag = new byte[hsFrag.messageLength + 4];
1226                     Plaintext plaintext = new Plaintext(
1227                             hsFrag.contentType,
1228                             hsFrag.majorVersion, hsFrag.minorVersion,
1229                             hsFrag.recordEpoch,
1230                             Authenticator.toLong(hsFrag.recordEnS),
1231                             ByteBuffer.wrap(recordFrag));
1232 
1233                     // fill the handshake fragment of the record
1234                     recordFrag[0] = hsFrag.handshakeType;
1235                     recordFrag[1] =
1236                             (byte)((hsFrag.messageLength &gt;&gt;&gt; 16) &amp; 0xFF);
1237                     recordFrag[2] =
1238                             (byte)((hsFrag.messageLength &gt;&gt;&gt; 8) &amp; 0xFF);
1239                     recordFrag[3] = (byte)(hsFrag.messageLength &amp; 0xFF);
1240 
1241                     int msgSeq = hsFrag.messageSeq;
1242                     long maxRecodeSN = hsFrag.recordSeq;
1243                     HandshakeFragment hmFrag = hsFrag;
1244                     do {
1245                         System.arraycopy(hmFrag.fragment, 0,
1246                                 recordFrag, hmFrag.fragmentOffset + 4,
1247                                 hmFrag.fragmentLength);
1248                         // popup the fragment
1249                         bufferedFragments.remove(rFrag);
1250 
1251                         if (maxRecodeSN &lt; hmFrag.recordSeq) {
1252                             maxRecodeSN = hmFrag.recordSeq;
1253                         }
1254 
1255                         // Note: may buffer retransmitted fragments in order to
1256                         // speed up the reassembly in the future.
1257 
1258                         // read the next buffered record
1259                         if (!bufferedFragments.isEmpty()) {
1260                             rFrag = bufferedFragments.first();
1261                             if (rFrag.contentType != ContentType.HANDSHAKE.id) {
1262                                 break;
1263                             } else {
1264                                 hmFrag = (HandshakeFragment)rFrag;
1265                             }
1266                         }
1267                     } while (!bufferedFragments.isEmpty() &amp;&amp;
1268                             (msgSeq == hmFrag.messageSeq));
1269 
1270                     // handshake hashing
1271                     handshakeHashing(hsFrag, plaintext);
1272 
1273                     this.nextRecordSeq = maxRecodeSN + 1;
1274 
1275                     return plaintext;
1276                 }
1277             }
1278         }
1279 
1280         boolean flightIsReady() {
1281 
1282             byte flightType = handshakeFlight.handshakeType;
1283             if (flightType == HandshakeFlight.HF_UNKNOWN) {
1284                 //
1285                 // the ChangeCipherSpec/Finished flight
1286                 //
1287                 if (expectCCSFlight) {
1288                     // Have the ChangeCipherSpec/Finished flight been received?
1289                     boolean isReady = hasFinishedMessage(bufferedFragments);
1290                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1291                         SSLLogger.fine(
1292                             &quot;Has the final flight been received? &quot; + isReady);
1293                     }
1294 
1295                     return isReady;
1296                 }
1297 
1298                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1299                     SSLLogger.fine(&quot;No flight is received yet.&quot;);
1300                 }
1301 
1302                 return false;
1303             }
1304 
1305             if ((flightType == SSLHandshake.CLIENT_HELLO.id) ||
1306                 (flightType == SSLHandshake.HELLO_REQUEST.id) ||
1307                 (flightType == SSLHandshake.HELLO_VERIFY_REQUEST.id)) {
1308 
1309                 // single handshake message flight
1310                 boolean isReady = hasCompleted(flightType);
1311                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1312                     SSLLogger.fine(
1313                             &quot;Is the handshake message completed? &quot; + isReady);
1314                 }
1315 
1316                 return isReady;
1317             }
1318 
1319             //
1320             // the ServerHello flight
1321             //
1322             if (flightType == SSLHandshake.SERVER_HELLO.id) {
1323                 // Firstly, check the first flight handshake message.
1324                 if (!hasCompleted(flightType)) {
1325                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1326                         SSLLogger.fine(
1327                             &quot;The ServerHello message is not completed yet.&quot;);
1328                     }
1329 
1330                     return false;
1331                 }
1332 
1333                 //
1334                 // an abbreviated handshake
1335                 //
1336                 if (hasFinishedMessage(bufferedFragments)) {
1337                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1338                         SSLLogger.fine(&quot;It&#39;s an abbreviated handshake.&quot;);
1339                     }
1340 
1341                     return true;
1342                 }
1343 
1344                 //
1345                 // a full handshake
1346                 //
1347                 List&lt;HoleDescriptor&gt; holes = handshakeFlight.holesMap.get(
1348                         SSLHandshake.SERVER_HELLO_DONE.id);
1349                 if ((holes == null) || !holes.isEmpty()) {
1350                     // Not yet got the final message of the flight.
1351                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1352                         SSLLogger.fine(
1353                                 &quot;Not yet got the ServerHelloDone message&quot;);
1354                     }
1355 
1356                     return false;
1357                 }
1358 
1359                 // Have all handshake message been received?
1360                 boolean isReady = hasCompleted(bufferedFragments,
1361                             handshakeFlight.minMessageSeq,
1362                             handshakeFlight.maxMessageSeq);
1363                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1364                     SSLLogger.fine(
1365                             &quot;Is the ServerHello flight (message &quot; +
1366                             handshakeFlight.minMessageSeq + &quot;-&quot; +
1367                             handshakeFlight.maxMessageSeq +
1368                             &quot;) completed? &quot; + isReady);
1369                 }
1370 
1371                 return isReady;
1372             }
1373 
1374             //
1375             // the ClientKeyExchange flight
1376             //
1377             // Note: need to consider more messages in this flight if
1378             //       ht_supplemental_data and ht_certificate_url are
1379             //       suppported in the future.
1380             //
1381             if ((flightType == SSLHandshake.CERTIFICATE.id) ||
1382                 (flightType == SSLHandshake.CLIENT_KEY_EXCHANGE.id)) {
1383 
1384                 // Firstly, check the first flight handshake message.
1385                 if (!hasCompleted(flightType)) {
1386                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1387                         SSLLogger.fine(
1388                             &quot;The ClientKeyExchange or client Certificate &quot; +
1389                             &quot;message is not completed yet.&quot;);
1390                     }
1391 
1392                     return false;
1393                 }
1394 
1395                 // Is client CertificateVerify a mandatory message?
1396                 if (flightType == SSLHandshake.CERTIFICATE.id) {
1397                     if (needClientVerify(bufferedFragments) &amp;&amp;
1398                         !hasCompleted(SSLHandshake.CERTIFICATE_VERIFY.id)) {
1399 
1400                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1401                             SSLLogger.fine(
1402                                 &quot;Not yet have the CertificateVerify message&quot;);
1403                         }
1404 
1405                         return false;
1406                     }
1407                 }
1408 
1409                 if (!hasFinishedMessage(bufferedFragments)) {
1410                     // not yet have the ChangeCipherSpec/Finished messages
1411                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1412                         SSLLogger.fine(
1413                             &quot;Not yet have the ChangeCipherSpec and &quot; +
1414                             &quot;Finished messages&quot;);
1415                     }
1416 
1417                     return false;
1418                 }
1419 
1420                 // Have all handshake message been received?
1421                 boolean isReady = hasCompleted(bufferedFragments,
1422                             handshakeFlight.minMessageSeq,
1423                             handshakeFlight.maxMessageSeq);
1424                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1425                     SSLLogger.fine(
1426                             &quot;Is the ClientKeyExchange flight (message &quot; +
1427                             handshakeFlight.minMessageSeq + &quot;-&quot; +
1428                             handshakeFlight.maxMessageSeq +
1429                             &quot;) completed? &quot; + isReady);
1430                 }
1431 
1432                 return isReady;
1433             }
1434 
1435             //
1436             // Otherwise, need to receive more handshake messages.
1437             //
1438             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
1439                 SSLLogger.fine(&quot;Need to receive more handshake messages&quot;);
1440             }
1441 
1442             return false;
1443         }
1444 
1445         // Looking for the ChangeCipherSpec and Finished messages.
1446         //
1447         // As the cached Finished message should be a ciphertext, we don&#39;t
1448         // exactly know a ciphertext is a Finished message or not.  According
1449         // to the spec of TLS/DTLS handshaking, a Finished message is always
1450         // sent immediately after a ChangeCipherSpec message.  The first
1451         // ciphertext handshake message should be the expected Finished message.
1452         private boolean hasFinishedMessage(Set&lt;RecordFragment&gt; fragments) {
1453 
1454             boolean hasCCS = false;
1455             boolean hasFin = false;
1456             for (RecordFragment fragment : fragments) {
1457                 if (fragment.contentType == ContentType.CHANGE_CIPHER_SPEC.id) {
1458                     if (hasFin) {
1459                         return true;
1460                     }
1461                     hasCCS = true;
1462                 } else if (fragment.contentType == ContentType.HANDSHAKE.id) {
1463                     // Finished is the first expected message of a new epoch.
1464                     if (fragment.isCiphertext) {
1465                         if (hasCCS) {
1466                             return true;
1467                         }
1468                         hasFin = true;
1469                     }
1470                 }
1471             }
1472 
1473             return hasFin &amp;&amp; hasCCS;
1474         }
1475 
1476         // Is client CertificateVerify a mandatory message?
1477         //
1478         // In the current implementation, client CertificateVerify is a
1479         // mandatory message if the client Certificate is not empty.
1480         private boolean needClientVerify(Set&lt;RecordFragment&gt; fragments) {
1481 
1482             // The caller should have checked the completion of the first
1483             // present handshake message.  Need not to check it again.
1484             for (RecordFragment rFrag : fragments) {
1485                 if ((rFrag.contentType != ContentType.HANDSHAKE.id) ||
1486                         rFrag.isCiphertext) {
1487                     break;
1488                 }
1489 
1490                 HandshakeFragment hsFrag = (HandshakeFragment)rFrag;
1491                 if (hsFrag.handshakeType != SSLHandshake.CERTIFICATE.id) {
1492                     continue;
1493                 }
1494 
1495                 return (rFrag.fragment != null) &amp;&amp;
1496                    (rFrag.fragment.length &gt; DTLSRecord.minCertPlaintextSize);
1497             }
1498 
1499             return false;
1500         }
1501 
1502         private boolean hasCompleted(byte handshakeType) {
1503             List&lt;HoleDescriptor&gt; holes =
1504                     handshakeFlight.holesMap.get(handshakeType);
1505             if (holes == null) {
1506                 // not yet received this kind of handshake message
1507                 return false;
1508             }
1509 
1510             return holes.isEmpty();  // no fragment hole for complete message
1511         }
1512 
1513         private boolean hasCompleted(
1514                 Set&lt;RecordFragment&gt; fragments,
1515                 int presentMsgSeq, int endMsgSeq) {
1516 
1517             // The caller should have checked the completion of the first
1518             // present handshake message.  Need not to check it again.
1519             for (RecordFragment rFrag : fragments) {
1520                 if ((rFrag.contentType != ContentType.HANDSHAKE.id) ||
1521                         rFrag.isCiphertext) {
1522                     break;
1523                 }
1524 
1525                 HandshakeFragment hsFrag = (HandshakeFragment)rFrag;
1526                 if (hsFrag.messageSeq == presentMsgSeq) {
1527                     continue;
1528                 } else if (hsFrag.messageSeq == (presentMsgSeq + 1)) {
1529                     // check the completion of the handshake message
1530                     if (!hasCompleted(hsFrag.handshakeType)) {
1531                         return false;
1532                     }
1533 
1534                     presentMsgSeq = hsFrag.messageSeq;
1535                 } else {
1536                     // not yet got handshake message next to presentMsgSeq
1537                     break;
1538                 }
1539             }
1540 
1541             return (presentMsgSeq &gt;= endMsgSeq);
1542                         // false: if not yet got all messages of the flight.
1543         }
1544 
1545         private void handshakeHashing(
1546                 HandshakeFragment hsFrag, Plaintext plaintext) {
1547             byte hsType = hsFrag.handshakeType;
1548             if (!handshakeHash.isHashable(hsType)) {
1549                 // omitted from handshake hash computation
1550                 return;
1551             }
1552 
1553             // calculate the DTLS header and reserve the handshake message
1554             plaintext.fragment.position(4);     // ignore the TLS header
1555             byte[] temporary = new byte[plaintext.fragment.remaining() + 12];
1556                                                 // 12: handshake header size
1557 
1558             // Handshake.msg_type
1559             temporary[0] = hsFrag.handshakeType;
1560 
1561             // Handshake.length
1562             temporary[1] = (byte)((hsFrag.messageLength &gt;&gt; 16) &amp; 0xFF);
1563             temporary[2] = (byte)((hsFrag.messageLength &gt;&gt; 8) &amp; 0xFF);
1564             temporary[3] = (byte)(hsFrag.messageLength &amp; 0xFF);
1565 
1566             // Handshake.message_seq
1567             temporary[4] = (byte)((hsFrag.messageSeq &gt;&gt; 8) &amp; 0xFF);
1568             temporary[5] = (byte)(hsFrag.messageSeq &amp; 0xFF);
1569 
1570             // Handshake.fragment_offset
1571             temporary[6] = 0;
1572             temporary[7] = 0;
1573             temporary[8] = 0;
1574 
1575             // Handshake.fragment_length
1576             temporary[9] = temporary[1];
1577             temporary[10] = temporary[2];
1578             temporary[11] = temporary[3];
1579 
1580             plaintext.fragment.get(temporary,
1581                     12, plaintext.fragment.remaining());
1582             handshakeHash.receive(temporary);
1583             plaintext.fragment.position(0);     // restore the position
1584         }
1585     }
1586 }
1587 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/util/locale/provider/CalendarNameProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.util.locale.provider;
 26 
 27 import static java.util.Calendar.*;
 28 import java.util.Comparator;
 29 import java.util.Locale;
 30 import java.util.Map;
 31 import java.util.Set;
 32 import java.util.TreeMap;
 33 import java.util.spi.CalendarNameProvider;
 34 import sun.util.calendar.CalendarSystem;
 35 import sun.util.calendar.Era;
 36 
 37 /**
 38  * Concrete implementation of the {@link java.util.spi.CalendarNameProvider
 39  * CalendarNameProvider} class for the JRE LocaleProviderAdapter.
 40  *
 41  * @author Masayoshi Okutsu
 42  * @author Naoto Sato
 43  */
 44 public class CalendarNameProviderImpl extends CalendarNameProvider implements AvailableLanguageTags {
 45     protected final LocaleProviderAdapter.Type type;
 46     protected final Set&lt;String&gt; langtags;
 47 
 48     public CalendarNameProviderImpl(LocaleProviderAdapter.Type type, Set&lt;String&gt; langtags) {
 49         this.type = type;
 50         this.langtags = langtags;
 51     }
 52 
 53     @Override
 54     public String getDisplayName(String calendarType, int field, int value, int style, Locale locale) {
 55         return getDisplayNameImpl(calendarType, field, value, style, locale, false);
 56     }
 57 
 58     public String getJavaTimeDisplayName(String calendarType, int field, int value, int style, Locale locale) {
 59         return getDisplayNameImpl(calendarType, field, value, style, locale, true);
 60     }
 61 
 62     public String getDisplayNameImpl(String calendarType, int field, int value, int style, Locale locale, boolean javatime) {
 63         String name = null;
 64         String key = getResourceKey(calendarType, field, style, javatime);
 65         if (key != null) {
 66             LocaleResources lr = LocaleProviderAdapter.forType(type).getLocaleResources(locale);
 67             String[] strings = javatime ? lr.getJavaTimeNames(key) : lr.getCalendarNames(key);
 68 
 69             // If standalone names are requested and no &quot;standalone.&quot; resources are found,
 70             // try the default ones instead.
 71             if (strings == null &amp;&amp; key.indexOf(&quot;standalone.&quot;) != -1) {
 72                 key = key.replaceFirst(&quot;standalone.&quot;, &quot;&quot;);
 73                 strings = javatime ? lr.getJavaTimeNames(key) : lr.getCalendarNames(key);
 74             }
 75 
 76             if (strings != null &amp;&amp; strings.length &gt; 0) {
 77                 if (field == DAY_OF_WEEK || field == YEAR) {
 78                     --value;
 79                 }
 80                 if (value &lt; 0) {
 81                     return null;
 82                 } else if (value &gt;= strings.length) {
 83                     if (field == ERA &amp;&amp; &quot;japanese&quot;.equals(calendarType)) {
 84                         Era[] jeras = CalendarSystem.forName(&quot;japanese&quot;).getEras();
 85                         if (value &lt;= jeras.length) {
 86                             // Localized era name could not be retrieved from this provider.
<a name="2" id="anc2"></a><span class="line-modified"> 87                             // This can occur either for NewEra or SupEra.</span>
 88                             //
 89                             // If it&#39;s CLDR provider, try COMPAT first, which is guaranteed to have
<a name="3" id="anc3"></a><span class="line-modified"> 90                             // the name for NewEra.</span>
 91                             if (type == LocaleProviderAdapter.Type.CLDR) {
 92                                 lr = LocaleProviderAdapter.forJRE().getLocaleResources(locale);
 93                                 key = getResourceKeyFor(LocaleProviderAdapter.Type.JRE,
 94                                                 calendarType, field, style, javatime);
 95                                 strings =
 96                                     javatime ? lr.getJavaTimeNames(key) : lr.getCalendarNames(key);
 97                             }
 98                             if (strings == null || value &gt;= strings.length) {
 99                                 // Get the default name for SupEra
100                                 Era supEra = jeras[value - 1]; // 0-based index
101                                 if (javatime) {
102                                     return getBaseStyle(style) == NARROW_FORMAT ?
103                                         supEra.getAbbreviation() :
104                                         supEra.getName();
105                                 } else {
106                                     return (style &amp; LONG) != 0 ?
107                                         supEra.getName() :
108                                         supEra.getAbbreviation();
109                                 }
110                             }
111                         } else {
112                             return null;
113                         }
114                     } else {
115                         return null;
116                     }
117                 }
118                 name = strings[value];
119                 // If name is empty in standalone, try its `format&#39; style.
120                 if (name.isEmpty()
121                         &amp;&amp; (style == SHORT_STANDALONE || style == LONG_STANDALONE
122                             || style == NARROW_STANDALONE)) {
123                     name = getDisplayName(calendarType, field, value,
124                                           getBaseStyle(style),
125                                           locale);
126                 }
127             }
128         }
129         return name;
130     }
131 
132     private static int[] REST_OF_STYLES = {
133         SHORT_STANDALONE, LONG_FORMAT, LONG_STANDALONE,
134         NARROW_FORMAT, NARROW_STANDALONE
135     };
136 
137     @Override
138     public Map&lt;String, Integer&gt; getDisplayNames(String calendarType, int field, int style, Locale locale) {
139         Map&lt;String, Integer&gt; names;
140         if (style == ALL_STYLES) {
141             names = getDisplayNamesImpl(calendarType, field, SHORT_FORMAT, locale, false);
142             for (int st : REST_OF_STYLES) {
143                 names.putAll(getDisplayNamesImpl(calendarType, field, st, locale, false));
144             }
145         } else {
146             // specific style
147             names = getDisplayNamesImpl(calendarType, field, style, locale, false);
148         }
149         return names.isEmpty() ? null : names;
150     }
151 
152     // NOTE: This method should be used ONLY BY JSR 310 classes.
153     public Map&lt;String, Integer&gt; getJavaTimeDisplayNames(String calendarType, int field, int style, Locale locale) {
154         Map&lt;String, Integer&gt; names;
155         names = getDisplayNamesImpl(calendarType, field, style, locale, true);
156         return names.isEmpty() ? null : names;
157     }
158 
159     private Map&lt;String, Integer&gt; getDisplayNamesImpl(String calendarType, int field,
160                                                      int style, Locale locale, boolean javatime) {
161         String key = getResourceKey(calendarType, field, style, javatime);
162         Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(LengthBasedComparator.INSTANCE);
163         if (key != null) {
164             LocaleResources lr = LocaleProviderAdapter.forType(type).getLocaleResources(locale);
165             String[] strings = javatime ? lr.getJavaTimeNames(key) : lr.getCalendarNames(key);
166 
167             // If standalone names are requested and no &quot;standalone.&quot; resources are found,
168             // try the default ones instead.
169             if (strings == null &amp;&amp; key.indexOf(&quot;standalone.&quot;) != -1) {
170                 key = key.replaceFirst(&quot;standalone.&quot;, &quot;&quot;);
171                 strings = javatime ? lr.getJavaTimeNames(key) : lr.getCalendarNames(key);
172             }
173 
174             if (strings != null) {
175                 if (!hasDuplicates(strings)) {
176                     if (field == YEAR) {
177                         if (strings.length &gt; 0) {
178                             map.put(strings[0], 1);
179                         }
180                     } else {
181                         int base = (field == DAY_OF_WEEK) ? 1 : 0;
182                         for (int i = 0; i &lt; strings.length; i++) {
183                             String name = strings[i];
184                             // Ignore any empty string (some standalone month names
185                             // are not defined)
186                             if (name.isEmpty()) {
187                                 continue;
188                             }
189                             map.put(name, base + i);
190                         }
191                     }
192                 }
193             }
194         }
195         return map;
196     }
197 
198     private static int getBaseStyle(int style) {
199         return style &amp; ~(SHORT_STANDALONE - SHORT_FORMAT);
200     }
201 
202     /**
203      * Comparator implementation for TreeMap which iterates keys from longest
204      * to shortest.
205      */
206     private static class LengthBasedComparator implements Comparator&lt;String&gt; {
207         private static final LengthBasedComparator INSTANCE = new LengthBasedComparator();
208 
209         private LengthBasedComparator() {
210         }
211 
212         @Override
213         public int compare(String o1, String o2) {
214             int n = o2.length() - o1.length();
215             return (n == 0) ? o1.compareTo(o2) : n;
216         }
217     }
218 
219     @Override
220     public Locale[] getAvailableLocales() {
221         return LocaleProviderAdapter.toLocaleArray(langtags);
222     }
223 
224     @Override
225     public boolean isSupportedLocale(Locale locale) {
226         if (Locale.ROOT.equals(locale)) {
227             return true;
228         }
229         String calendarType = null;
230         if (locale.hasExtensions()) {
231             calendarType = locale.getUnicodeLocaleType(&quot;ca&quot;);
232             locale = locale.stripExtensions();
233         }
234 
235         if (calendarType != null) {
236             switch (calendarType) {
237             case &quot;buddhist&quot;:
238             case &quot;japanese&quot;:
239             case &quot;gregory&quot;:
240             case &quot;islamic&quot;:
241             case &quot;roc&quot;:
242                 break;
243             default:
244                 // Unknown calendar type
245                 return false;
246             }
247         }
248         if (langtags.contains(locale.toLanguageTag())) {
249             return true;
250         }
251         String oldname = locale.toString().replace(&#39;_&#39;, &#39;-&#39;);
252         return langtags.contains(oldname);
253     }
254 
255     @Override
256     public Set&lt;String&gt; getAvailableLanguageTags() {
257         return langtags;
258     }
259 
<a name="4" id="anc4"></a>

260     private boolean hasDuplicates(String[] strings) {
261         int len = strings.length;
262         for (int i = 0; i &lt; len - 1; i++) {
263             String a = strings[i];
<a name="5" id="anc5"></a><span class="line-modified">264             if (a != null) {</span>
265                 for (int j = i + 1; j &lt; len; j++) {
266                     if (a.equals(strings[j]))  {
267                         return true;
268                     }
269                 }
270             }
271         }
272         return false;
273     }
274 
275     private String getResourceKey(String type, int field, int style, boolean javatime) {
276         return getResourceKeyFor(this.type, type, field, style, javatime);
277     }
278 
279     private static String getResourceKeyFor(LocaleProviderAdapter.Type adapterType,
280                             String type, int field, int style, boolean javatime) {
281         int baseStyle = getBaseStyle(style);
282         boolean isStandalone = (style != baseStyle);
283 
284         if (&quot;gregory&quot;.equals(type)) {
285             type = null;
286         }
287         boolean isNarrow = (baseStyle == NARROW_FORMAT);
288         StringBuilder key = new StringBuilder();
289         // If javatime is true, use prefix &quot;java.time.&quot;.
290         if (javatime) {
291             key.append(&quot;java.time.&quot;);
292         }
293         switch (field) {
294         case ERA:
295             if (type != null) {
296                 key.append(type).append(&#39;.&#39;);
297             }
298             if (isNarrow) {
299                 key.append(&quot;narrow.&quot;);
300             } else {
301                 // JRE and CLDR use different resource key conventions
302                 // due to historical reasons. (JRE DateFormatSymbols.getEras returns
303                 // abbreviations while other getShort*() return abbreviations.)
304                 if (adapterType == LocaleProviderAdapter.Type.JRE) {
305                     if (javatime) {
306                         if (baseStyle == LONG) {
307                             key.append(&quot;long.&quot;);
308                         }
309                     }
310                     if (baseStyle == SHORT) {
311                         key.append(&quot;short.&quot;);
312                     }
313                 } else { // this.type == LocaleProviderAdapter.Type.CLDR
314                     if (baseStyle == LONG) {
315                         key.append(&quot;long.&quot;);
316                     }
317                 }
318             }
319             key.append(&quot;Eras&quot;);
320             break;
321 
322         case YEAR:
323             if (!isNarrow) {
324                 key.append(type).append(&quot;.FirstYear&quot;);
325             }
326             break;
327 
328         case MONTH:
329             if (&quot;islamic&quot;.equals(type)) {
330                 key.append(type).append(&#39;.&#39;);
331             }
332             if (isStandalone) {
333                 key.append(&quot;standalone.&quot;);
334             }
335             key.append(&quot;Month&quot;).append(toStyleName(baseStyle));
336             break;
337 
338         case DAY_OF_WEEK:
339             // support standalone day names
340             if (isStandalone) {
341                 key.append(&quot;standalone.&quot;);
342             }
343             key.append(&quot;Day&quot;).append(toStyleName(baseStyle));
344             break;
345 
346         case AM_PM:
347             if (isNarrow) {
348                 key.append(&quot;narrow.&quot;);
349             }
350             key.append(&quot;AmPmMarkers&quot;);
351             break;
352         }
353         return key.length() &gt; 0 ? key.toString() : null;
354     }
355 
356     private static String toStyleName(int baseStyle) {
357         switch (baseStyle) {
358         case SHORT:
359             return &quot;Abbreviations&quot;;
360         case NARROW_FORMAT:
361             return &quot;Narrows&quot;;
362         }
363         return &quot;Names&quot;;
364     }
365 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
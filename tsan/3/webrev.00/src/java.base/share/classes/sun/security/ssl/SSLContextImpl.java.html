<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLContextImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.FileInputStream;
  29 import java.net.Socket;
  30 import java.security.*;
  31 import java.security.cert.*;
  32 import java.util.*;
  33 import java.util.concurrent.locks.ReentrantLock;
  34 import javax.net.ssl.*;
  35 import sun.security.action.GetPropertyAction;
  36 import sun.security.provider.certpath.AlgorithmChecker;
  37 import sun.security.validator.Validator;
  38 
  39 /**
  40  * Implementation of an SSLContext.
  41  *
  42  * Implementation note: Instances of this class and the child classes are
  43  * immutable, except that the context initialization (SSLContext.init()) may
  44  * reset the key, trust managers and source of secure random.
  45  */
  46 
  47 public abstract class SSLContextImpl extends SSLContextSpi {
  48 
  49     private final EphemeralKeyManager ephemeralKeyManager;
  50     private final SSLSessionContextImpl clientCache;
  51     private final SSLSessionContextImpl serverCache;
  52 
  53     private boolean isInitialized;
  54 
  55     private X509ExtendedKeyManager keyManager;
  56     private X509TrustManager trustManager;
  57     private SecureRandom secureRandom;
  58 
  59     // DTLS cookie exchange manager
  60     private volatile HelloCookieManager.Builder helloCookieManagerBuilder;
  61 
  62     private final boolean clientEnableStapling = Utilities.getBooleanProperty(
  63             &quot;jdk.tls.client.enableStatusRequestExtension&quot;, true);
  64     private final boolean serverEnableStapling = Utilities.getBooleanProperty(
  65             &quot;jdk.tls.server.enableStatusRequestExtension&quot;, false);
  66     private static final Collection&lt;CipherSuite&gt; clientCustomizedCipherSuites =
  67             getCustomizedCipherSuites(&quot;jdk.tls.client.cipherSuites&quot;);
  68     private static final Collection&lt;CipherSuite&gt; serverCustomizedCipherSuites =
  69             getCustomizedCipherSuites(&quot;jdk.tls.server.cipherSuites&quot;);
  70 
  71     private volatile StatusResponseManager statusResponseManager;
  72 
  73     private final ReentrantLock contextLock = new ReentrantLock();
  74     final HashMap&lt;Integer,
  75             SessionTicketExtension.StatelessKey&gt; keyHashMap = new HashMap&lt;&gt;();
  76 
  77 
  78     SSLContextImpl() {
  79         ephemeralKeyManager = new EphemeralKeyManager();
  80         clientCache = new SSLSessionContextImpl(false);
  81         serverCache = new SSLSessionContextImpl(true);
  82     }
  83 
  84     @Override
  85     protected void engineInit(KeyManager[] km, TrustManager[] tm,
  86                                 SecureRandom sr) throws KeyManagementException {
  87         isInitialized = false;
  88         keyManager = chooseKeyManager(km);
  89 
  90         if (tm == null) {
  91             try {
  92                 TrustManagerFactory tmf = TrustManagerFactory.getInstance(
  93                         TrustManagerFactory.getDefaultAlgorithm());
  94                 tmf.init((KeyStore)null);
  95                 tm = tmf.getTrustManagers();
  96             } catch (Exception e) {
  97                 // eat
  98             }
  99         }
 100         trustManager = chooseTrustManager(tm);
 101 
 102         if (sr == null) {
 103             secureRandom = new SecureRandom();
 104         } else {
 105             secureRandom = sr;
 106         }
 107 
 108         /*
 109          * The initial delay of seeding the random number generator
 110          * could be long enough to cause the initial handshake on our
 111          * first connection to timeout and fail. Make sure it is
 112          * primed and ready by getting some initial output from it.
 113          */
 114         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 115             SSLLogger.finest(&quot;trigger seeding of SecureRandom&quot;);
 116         }
 117         secureRandom.nextInt();
 118         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 119             SSLLogger.finest(&quot;done seeding of SecureRandom&quot;);
 120         }
 121 
 122         isInitialized = true;
 123     }
 124 
 125     private X509TrustManager chooseTrustManager(TrustManager[] tm)
 126             throws KeyManagementException {
 127         // We only use the first instance of X509TrustManager passed to us.
 128         for (int i = 0; tm != null &amp;&amp; i &lt; tm.length; i++) {
 129             if (tm[i] instanceof X509TrustManager) {
 130                 if (tm[i] instanceof X509ExtendedTrustManager) {
 131                     return (X509TrustManager)tm[i];
 132                 } else {
 133                     return new AbstractTrustManagerWrapper(
 134                                         (X509TrustManager)tm[i]);
 135                 }
 136             }
 137         }
 138 
 139         // nothing found, return a dummy X509TrustManager.
 140         return DummyX509TrustManager.INSTANCE;
 141     }
 142 
 143     private X509ExtendedKeyManager chooseKeyManager(KeyManager[] kms)
 144             throws KeyManagementException {
 145         for (int i = 0; kms != null &amp;&amp; i &lt; kms.length; i++) {
 146             KeyManager km = kms[i];
 147             if (!(km instanceof X509KeyManager)) {
 148                 continue;
 149             }
 150 
 151             if (km instanceof X509ExtendedKeyManager) {
 152                 return (X509ExtendedKeyManager)km;
 153             }
 154 
 155             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 156                 SSLLogger.warning(
 157                     &quot;X509KeyManager passed to SSLContext.init():  need an &quot; +
 158                     &quot;X509ExtendedKeyManager for SSLEngine use&quot;);
 159             }
 160             return new AbstractKeyManagerWrapper((X509KeyManager)km);
 161         }
 162 
 163         // nothing found, return a dummy X509ExtendedKeyManager
 164         return DummyX509KeyManager.INSTANCE;
 165     }
 166 
 167     abstract SSLEngine createSSLEngineImpl();
 168     abstract SSLEngine createSSLEngineImpl(String host, int port);
 169 
 170     @Override
 171     protected SSLEngine engineCreateSSLEngine() {
 172         if (!isInitialized) {
 173             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 174         }
 175         return createSSLEngineImpl();
 176     }
 177 
 178     @Override
 179     protected SSLEngine engineCreateSSLEngine(String host, int port) {
 180         if (!isInitialized) {
 181             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 182         }
 183         return createSSLEngineImpl(host, port);
 184     }
 185 
 186     @Override
 187     protected SSLSocketFactory engineGetSocketFactory() {
 188         if (!isInitialized) {
 189             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 190         }
 191         if (isDTLS()) {
 192             throw new UnsupportedOperationException(
 193                     &quot;DTLS not supported with SSLSocket&quot;);
 194         }
 195        return new SSLSocketFactoryImpl(this);
 196     }
 197 
 198     @Override
 199     protected SSLServerSocketFactory engineGetServerSocketFactory() {
 200         if (!isInitialized) {
 201             throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);
 202         }
 203         if (isDTLS()) {
 204             throw new UnsupportedOperationException(
 205                     &quot;DTLS not supported with SSLServerSocket&quot;);
 206         }
 207         return new SSLServerSocketFactoryImpl(this);
 208     }
 209 
 210     @Override
 211     protected SSLSessionContext engineGetClientSessionContext() {
 212         return clientCache;
 213     }
 214 
 215     @Override
 216     protected SSLSessionContext engineGetServerSessionContext() {
 217         return serverCache;
 218     }
 219 
 220     SecureRandom getSecureRandom() {
 221         return secureRandom;
 222     }
 223 
 224     X509ExtendedKeyManager getX509KeyManager() {
 225         return keyManager;
 226     }
 227 
 228     X509TrustManager getX509TrustManager() {
 229         return trustManager;
 230     }
 231 
 232     EphemeralKeyManager getEphemeralKeyManager() {
 233         return ephemeralKeyManager;
 234     }
 235 
 236     // Used for DTLS in server mode only.
 237     HelloCookieManager getHelloCookieManager(ProtocolVersion protocolVersion) {
 238         if (helloCookieManagerBuilder == null) {
 239             contextLock.lock();
 240             try {
 241                 if (helloCookieManagerBuilder == null) {
 242                     helloCookieManagerBuilder =
 243                             new HelloCookieManager.Builder(secureRandom);
 244                 }
 245             } finally {
 246                 contextLock.unlock();
 247             }
 248         }
 249 
 250         return helloCookieManagerBuilder.valueOf(protocolVersion);
 251     }
 252 
 253     StatusResponseManager getStatusResponseManager() {
 254         if (serverEnableStapling &amp;&amp; statusResponseManager == null) {
 255             contextLock.lock();
 256             try {
 257                 if (statusResponseManager == null) {
 258                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 259                         SSLLogger.finest(
 260                                 &quot;Initializing StatusResponseManager&quot;);
 261                     }
 262                     statusResponseManager = new StatusResponseManager();
 263                 }
 264             } finally {
 265                 contextLock.unlock();
 266             }
 267         }
 268 
 269         return statusResponseManager;
 270     }
 271 
 272     // Get supported protocols.
 273     abstract List&lt;ProtocolVersion&gt; getSupportedProtocolVersions();
 274 
 275     // Get default protocols for server mode.
 276     abstract List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions();
 277 
 278     // Get default protocols for client mode.
 279     abstract List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions();
 280 
 281     // Get supported CipherSuite list.
 282     abstract List&lt;CipherSuite&gt; getSupportedCipherSuites();
 283 
 284     // Get default CipherSuite list for server mode.
 285     abstract List&lt;CipherSuite&gt; getServerDefaultCipherSuites();
 286 
 287     // Get default CipherSuite list for client mode.
 288     abstract List&lt;CipherSuite&gt; getClientDefaultCipherSuites();
 289 
 290     // Is the context for DTLS protocols?
 291     abstract boolean isDTLS();
 292 
 293     // Get default protocols.
 294     List&lt;ProtocolVersion&gt; getDefaultProtocolVersions(boolean roleIsServer) {
 295         return roleIsServer ? getServerDefaultProtocolVersions()
 296                             : getClientDefaultProtocolVersions();
 297     }
 298 
 299     // Get default CipherSuite list.
 300     List&lt;CipherSuite&gt; getDefaultCipherSuites(boolean roleIsServer) {
 301         return roleIsServer ? getServerDefaultCipherSuites()
 302                             : getClientDefaultCipherSuites();
 303     }
 304 
 305     /**
 306      * Return whether a protocol list is the original default enabled
 307      * protocols.  See: SSLSocket/SSLEngine.setEnabledProtocols()
 308      */
 309     boolean isDefaultProtocolVesions(List&lt;ProtocolVersion&gt; protocols) {
 310         return (protocols == getServerDefaultProtocolVersions()) ||
 311                (protocols == getClientDefaultProtocolVersions());
 312     }
 313 
 314     /**
 315      * Return whether a protocol list is the original default enabled
 316      * protocols.  See: SSLSocket/SSLEngine.setEnabledProtocols()
 317      */
 318     boolean isDefaultCipherSuiteList(List&lt;CipherSuite&gt; cipherSuites) {
 319         return (cipherSuites == getServerDefaultCipherSuites()) ||
 320                (cipherSuites == getClientDefaultCipherSuites());
 321     }
 322 
 323     /**
 324      * Return whether client or server side stapling has been enabled
 325      * for this SSLContextImpl
 326      * @param isClient true if the caller is operating in a client side role,
 327      * false if acting as a server.
 328      * @return true if stapling has been enabled for the specified role, false
 329      * otherwise.
 330      */
 331     boolean isStaplingEnabled(boolean isClient) {
 332         return isClient ? clientEnableStapling : serverEnableStapling;
 333     }
 334 
 335     /*
 336      * Return the list of all available CipherSuites that are supported
 337      * using currently installed providers.
 338      */
 339     private static List&lt;CipherSuite&gt; getApplicableSupportedCipherSuites(
 340             List&lt;ProtocolVersion&gt; protocols) {
 341 
 342         return getApplicableCipherSuites(
 343                 CipherSuite.allowedCipherSuites(), protocols);
 344     }
 345 
 346     /*
 347      * Return the list of all available CipherSuites that are default enabled
 348      * in client or server side.
 349      */
 350     private static List&lt;CipherSuite&gt; getApplicableEnabledCipherSuites(
 351             List&lt;ProtocolVersion&gt; protocols, boolean isClient) {
 352 
 353         if (isClient) {
 354             if (!clientCustomizedCipherSuites.isEmpty()) {
 355                 return getApplicableCipherSuites(
 356                         clientCustomizedCipherSuites, protocols);
 357             }
 358         } else {
 359             if (!serverCustomizedCipherSuites.isEmpty()) {
 360                 return getApplicableCipherSuites(
 361                         serverCustomizedCipherSuites, protocols);
 362             }
 363         }
 364 
 365         return getApplicableCipherSuites(
 366                 CipherSuite.defaultCipherSuites(), protocols);
 367     }
 368 
 369     /*
 370      * Return the list of available CipherSuites which are applicable to
 371      * the specified protocols.
 372      */
 373     private static List&lt;CipherSuite&gt; getApplicableCipherSuites(
 374             Collection&lt;CipherSuite&gt; allowedCipherSuites,
 375             List&lt;ProtocolVersion&gt; protocols) {
 376         LinkedHashSet&lt;CipherSuite&gt; suites = new LinkedHashSet&lt;&gt;();
 377         if (protocols != null &amp;&amp; (!protocols.isEmpty())) {
 378             for (CipherSuite suite : allowedCipherSuites) {
 379                 if (!suite.isAvailable()) {
 380                     continue;
 381                 }
 382 
 383                 boolean isSupported = false;
 384                 for (ProtocolVersion protocol : protocols) {
 385                     if (!suite.supports(protocol) ||
 386                             !suite.bulkCipher.isAvailable()) {
 387                         continue;
 388                     }
 389 
 390                     if (SSLAlgorithmConstraints.DEFAULT.permits(
 391                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 392                             suite.name, null)) {
 393                         suites.add(suite);
 394                         isSupported = true;
 395                     } else if (SSLLogger.isOn &amp;&amp;
 396                             SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 397                         SSLLogger.fine(
 398                                 &quot;Ignore disabled cipher suite: &quot; + suite.name);
 399                     }
 400 
 401                     break;
 402                 }
 403 
 404                 if (!isSupported &amp;&amp; SSLLogger.isOn &amp;&amp;
 405                         SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 406                     SSLLogger.finest(
 407                             &quot;Ignore unsupported cipher suite: &quot; + suite);
 408                 }
 409             }
 410         }
 411 
 412         return new ArrayList&lt;&gt;(suites);
 413     }
 414 
 415     /*
 416      * Get the customized cipher suites specified by the given system property.
 417      */
 418     private static Collection&lt;CipherSuite&gt; getCustomizedCipherSuites(
 419             String propertyName) {
 420 
 421         String property = GetPropertyAction.privilegedGetProperty(propertyName);
 422         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 423             SSLLogger.fine(
 424                     &quot;System property &quot; + propertyName + &quot; is set to &#39;&quot; +
 425                     property + &quot;&#39;&quot;);
 426         }
 427         if (property != null &amp;&amp; !property.isEmpty()) {
 428             // remove double quote marks from beginning/end of the property
 429             if (property.length() &gt; 1 &amp;&amp; property.charAt(0) == &#39;&quot;&#39; &amp;&amp;
 430                     property.charAt(property.length() - 1) == &#39;&quot;&#39;) {
 431                 property = property.substring(1, property.length() - 1);
 432             }
 433         }
 434 
 435         if (property != null &amp;&amp; !property.isEmpty()) {
 436             String[] cipherSuiteNames = property.split(&quot;,&quot;);
 437             Collection&lt;CipherSuite&gt; cipherSuites =
 438                         new ArrayList&lt;&gt;(cipherSuiteNames.length);
 439             for (int i = 0; i &lt; cipherSuiteNames.length; i++) {
 440                 cipherSuiteNames[i] = cipherSuiteNames[i].trim();
 441                 if (cipherSuiteNames[i].isEmpty()) {
 442                     continue;
 443                 }
 444 
 445                 CipherSuite suite;
 446                 try {
 447                     suite = CipherSuite.nameOf(cipherSuiteNames[i]);
 448                 } catch (IllegalArgumentException iae) {
 449                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 450                         SSLLogger.fine(
 451                                 &quot;Unknown or unsupported cipher suite name: &quot; +
 452                                 cipherSuiteNames[i]);
 453                     }
 454 
 455                     continue;
 456                 }
 457 
 458                 if (suite != null &amp;&amp; suite.isAvailable()) {
 459                     cipherSuites.add(suite);
 460                 } else {
 461                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 462                         SSLLogger.fine(
 463                                 &quot;The current installed providers do not &quot; +
 464                                 &quot;support cipher suite: &quot; + cipherSuiteNames[i]);
 465                     }
 466                 }
 467             }
 468 
 469             return cipherSuites;
 470         }
 471 
 472         return Collections.emptyList();
 473     }
 474 
 475 
 476     private static List&lt;ProtocolVersion&gt; getAvailableProtocols(
 477             ProtocolVersion[] protocolCandidates) {
 478 
 479         List&lt;ProtocolVersion&gt; availableProtocols =
 480                 Collections.&lt;ProtocolVersion&gt;emptyList();
 481         if (protocolCandidates != null &amp;&amp; protocolCandidates.length != 0) {
 482             availableProtocols = new ArrayList&lt;&gt;(protocolCandidates.length);
 483             for (ProtocolVersion p : protocolCandidates) {
 484                 if (p.isAvailable) {
 485                     availableProtocols.add(p);
 486                 }
 487             }
 488         }
 489 
 490         return availableProtocols;
 491     }
 492 
 493     /*
 494      * The SSLContext implementation for SSL/(D)TLS algorithm
 495      *
 496      * SSL/TLS protocols specify the forward compatibility and version
 497      * roll-back attack protections, however, a number of SSL/TLS server
 498      * vendors did not implement these aspects properly, and some current
 499      * SSL/TLS servers may refuse to talk to a TLS 1.1 or later client.
 500      *
 501      * Considering above interoperability issues, SunJSSE will not set
 502      * TLS 1.1 and TLS 1.2 as the enabled protocols for client by default.
 503      *
 504      * For SSL/TLS servers, there is no such interoperability issues as
 505      * SSL/TLS clients. In SunJSSE, TLS 1.1 or later version will be the
 506      * enabled protocols for server by default.
 507      *
 508      * We may change the behavior when popular TLS/SSL vendors support TLS
 509      * forward compatibility properly.
 510      *
 511      * SSLv2Hello is no longer necessary.  This interoperability option was
 512      * put in place in the late 90&#39;s when SSLv3/TLS1.0 were relatively new
 513      * and there were a fair number of SSLv2-only servers deployed.  Because
 514      * of the security issues in SSLv2, it is rarely (if ever) used, as
 515      * deployments should now be using SSLv3 and TLSv1.
 516      *
 517      * Considering the issues of SSLv2Hello, we should not enable SSLv2Hello
 518      * by default. Applications still can use it by enabling SSLv2Hello with
 519      * the series of setEnabledProtocols APIs.
 520      */
 521 
 522     /*
 523      * The base abstract SSLContext implementation for the Transport Layer
 524      * Security (TLS) protocols.
 525      *
 526      * This abstract class encapsulates supported and the default server
 527      * SSL/TLS parameters.
 528      *
 529      * @see SSLContext
 530      */
 531     private abstract static class AbstractTLSContext extends SSLContextImpl {
 532         private static final List&lt;ProtocolVersion&gt; supportedProtocols;
 533         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
 534 
 535         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
 536         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
 537 
 538         static {
 539             supportedProtocols = Arrays.asList(
 540                 ProtocolVersion.TLS13,
 541                 ProtocolVersion.TLS12,
 542                 ProtocolVersion.TLS11,
 543                 ProtocolVersion.TLS10,
 544                 ProtocolVersion.SSL30,
 545                 ProtocolVersion.SSL20Hello
 546             );
 547 
 548             serverDefaultProtocols = getAvailableProtocols(
 549                     new ProtocolVersion[] {
 550                 ProtocolVersion.TLS13,
 551                 ProtocolVersion.TLS12,
 552                 ProtocolVersion.TLS11,
 553                 ProtocolVersion.TLS10
 554             });
 555 
 556             supportedCipherSuites = getApplicableSupportedCipherSuites(
 557                     supportedProtocols);
 558             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
 559                     serverDefaultProtocols, false);
 560         }
 561 
 562         @Override
 563         List&lt;ProtocolVersion&gt; getSupportedProtocolVersions() {
 564             return supportedProtocols;
 565         }
 566 
 567         @Override
 568         List&lt;CipherSuite&gt; getSupportedCipherSuites() {
 569             return supportedCipherSuites;
 570         }
 571 
 572         @Override
 573         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
 574             return serverDefaultProtocols;
 575         }
 576 
 577         @Override
 578         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 579             return serverDefaultCipherSuites;
 580         }
 581 
 582         @Override
 583         SSLEngine createSSLEngineImpl() {
 584             return new SSLEngineImpl(this);
 585         }
 586 
 587         @Override
 588         SSLEngine createSSLEngineImpl(String host, int port) {
 589             return new SSLEngineImpl(this, host, port);
 590         }
 591 
 592         @Override
 593         boolean isDTLS() {
 594             return false;
 595         }
 596     }
 597 
 598     /*
 599      * The SSLContext implementation for SSLv3 and TLS10 algorithm
 600      *
 601      * @see SSLContext
 602      */
 603     public static final class TLS10Context extends AbstractTLSContext {
 604         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 605         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 606 
 607         static {
 608             clientDefaultProtocols = getAvailableProtocols(
 609                     new ProtocolVersion[] {
 610                 ProtocolVersion.TLS10
 611             });
 612 
 613             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 614                     clientDefaultProtocols, true);
 615         }
 616 
 617         @Override
 618         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 619             return clientDefaultProtocols;
 620         }
 621 
 622         @Override
 623         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 624             return clientDefaultCipherSuites;
 625         }
 626     }
 627 
 628     /*
 629      * The SSLContext implementation for TLS11 algorithm
 630      *
 631      * @see SSLContext
 632      */
 633     public static final class TLS11Context extends AbstractTLSContext {
 634         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 635         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 636 
 637         static {
 638             clientDefaultProtocols = getAvailableProtocols(
 639                     new ProtocolVersion[] {
 640                 ProtocolVersion.TLS11,
 641                 ProtocolVersion.TLS10
 642             });
 643 
 644             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 645                     clientDefaultProtocols, true);
 646 
 647         }
 648 
 649         @Override
 650         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 651             return clientDefaultProtocols;
 652         }
 653 
 654         @Override
 655         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 656             return clientDefaultCipherSuites;
 657         }
 658     }
 659 
 660     /*
 661      * The SSLContext implementation for TLS12 algorithm
 662      *
 663      * @see SSLContext
 664      */
 665     public static final class TLS12Context extends AbstractTLSContext {
 666         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 667         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 668 
 669         static {
 670             clientDefaultProtocols = getAvailableProtocols(
 671                     new ProtocolVersion[] {
 672                 ProtocolVersion.TLS12,
 673                 ProtocolVersion.TLS11,
 674                 ProtocolVersion.TLS10
 675             });
 676 
 677             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 678                     clientDefaultProtocols, true);
 679         }
 680 
 681         @Override
 682         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 683             return clientDefaultProtocols;
 684         }
 685 
 686         @Override
 687         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 688             return clientDefaultCipherSuites;
 689         }
 690     }
 691 
 692     /*
 693      * The SSLContext implementation for TLS1.3 algorithm
 694      *
 695      * @see SSLContext
 696      */
 697     public static final class TLS13Context extends AbstractTLSContext {
 698         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 699         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 700 
 701         static {
 702             clientDefaultProtocols = getAvailableProtocols(
 703                     new ProtocolVersion[] {
 704                 ProtocolVersion.TLS13,
 705                 ProtocolVersion.TLS12,
 706                 ProtocolVersion.TLS11,
 707                 ProtocolVersion.TLS10
 708             });
 709 
 710             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 711                     clientDefaultProtocols, true);
 712         }
 713 
 714         @Override
 715         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 716             return clientDefaultProtocols;
 717         }
 718 
 719         @Override
 720         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 721             return clientDefaultCipherSuites;
 722         }
 723     }
 724 
 725     /*
 726      * The interface for the customized SSL/(D)TLS SSLContext.
 727      *
 728      * @see SSLContext
 729      */
 730     private static class CustomizedSSLProtocols {
 731         private static final String JDK_TLS_CLIENT_PROTOCOLS =
 732                 &quot;jdk.tls.client.protocols&quot;;
 733         private static final String JDK_TLS_SERVER_PROTOCOLS =
 734                 &quot;jdk.tls.server.protocols&quot;;
 735         static IllegalArgumentException reservedException = null;
 736         static final ArrayList&lt;ProtocolVersion&gt; customizedClientProtocols =
 737                 new ArrayList&lt;&gt;();
 738         static final ArrayList&lt;ProtocolVersion&gt; customizedServerProtocols =
 739                 new ArrayList&lt;&gt;();
 740 
 741         // Don&#39;t want a java.lang.LinkageError for illegal system property.
 742         //
 743         // Please don&#39;t throw exception in this static block.  Otherwise,
 744         // java.lang.LinkageError may be thrown during the instantiation of
 745         // the provider service. Instead, please handle the initialization
 746         // exception in the caller&#39;s constructor.
 747         static {
 748             populate(JDK_TLS_CLIENT_PROTOCOLS, customizedClientProtocols);
 749             populate(JDK_TLS_SERVER_PROTOCOLS, customizedServerProtocols);
 750         }
 751 
 752         private static void populate(String propname,
 753                 ArrayList&lt;ProtocolVersion&gt; arrayList) {
 754             String property = GetPropertyAction.privilegedGetProperty(propname);
 755             if (property == null) {
 756                 return;
 757             }
 758 
 759             if (!property.isEmpty()) {
 760                 // remove double quote marks from beginning/end of the property
 761                 if (property.length() &gt; 1 &amp;&amp; property.charAt(0) == &#39;&quot;&#39; &amp;&amp;
 762                         property.charAt(property.length() - 1) == &#39;&quot;&#39;) {
 763                     property = property.substring(1, property.length() - 1);
 764                 }
 765             }
 766 
 767             if (!property.isEmpty()) {
 768                 String[] protocols = property.split(&quot;,&quot;);
 769                 for (int i = 0; i &lt; protocols.length; i++) {
 770                     protocols[i] = protocols[i].trim();
 771                     // Is it a supported protocol name?
 772                     ProtocolVersion pv =
 773                             ProtocolVersion.nameOf(protocols[i]);
 774                     if (pv == null) {
 775                         reservedException = new IllegalArgumentException(
 776                             propname + &quot;: &quot; + protocols[i] +
 777                             &quot; is not a supported SSL protocol name&quot;);
 778                     }
 779 
 780                     // ignore duplicated protocols
 781                     if (!arrayList.contains(pv)) {
 782                         arrayList.add(pv);
 783                     }
 784                 }
 785             }
 786         }
 787     }
 788 
 789     /*
 790      * The SSLContext implementation for customized TLS protocols
 791      *
 792      * @see SSLContext
 793      */
 794     private static class CustomizedTLSContext extends AbstractTLSContext {
 795 
 796         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 797         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
 798         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 799         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
 800         private static final IllegalArgumentException reservedException;
 801 
 802         // Don&#39;t want a java.lang.LinkageError for illegal system property.
 803         //
 804         // Please don&#39;t throw exception in this static block.  Otherwise,
 805         // java.lang.LinkageError may be thrown during the instantiation of
 806         // the provider service. Instead, let&#39;s handle the initialization
 807         // exception in constructor.
 808         static {
 809             reservedException = CustomizedSSLProtocols.reservedException;
 810             if (reservedException == null) {
 811                 clientDefaultProtocols = customizedProtocols(true,
 812                         CustomizedSSLProtocols.customizedClientProtocols);
 813                 serverDefaultProtocols = customizedProtocols(false,
 814                         CustomizedSSLProtocols.customizedServerProtocols);
 815 
 816                 clientDefaultCipherSuites =
 817                         getApplicableEnabledCipherSuites(
 818                                 clientDefaultProtocols, true);
 819                 serverDefaultCipherSuites =
 820                         getApplicableEnabledCipherSuites(
 821                                 serverDefaultProtocols, false);
 822 
 823             } else {
 824                 // unlikely to be used
 825                 clientDefaultProtocols = null;
 826                 serverDefaultProtocols = null;
 827                 clientDefaultCipherSuites = null;
 828                 serverDefaultCipherSuites = null;
 829             }
 830         }
 831 
 832         private static List&lt;ProtocolVersion&gt; customizedProtocols(
 833                 boolean client, List&lt;ProtocolVersion&gt; customized) {
 834             List&lt;ProtocolVersion&gt; refactored = new ArrayList&lt;&gt;();
 835             for (ProtocolVersion pv : customized) {
 836                 if (!pv.isDTLS) {
 837                     refactored.add(pv);
 838                 }
 839             }
 840 
 841             // Use the default enabled protocols if no customization
 842             ProtocolVersion[] candidates;
 843             if (refactored.isEmpty()) {
 844                 // Client and server use the same default protocols.
 845                 candidates = new ProtocolVersion[] {
 846                         ProtocolVersion.TLS13,
 847                         ProtocolVersion.TLS12,
 848                         ProtocolVersion.TLS11,
 849                         ProtocolVersion.TLS10
 850                     };
 851             } else {
 852                 // Use the customized TLS protocols.
 853                 candidates =
 854                     refactored.toArray(new ProtocolVersion[refactored.size()]);
 855             }
 856 
 857             return getAvailableProtocols(candidates);
 858         }
 859 
 860         protected CustomizedTLSContext() {
 861             if (reservedException != null) {
 862                 throw reservedException;
 863             }
 864         }
 865 
 866         @Override
 867         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 868             return clientDefaultProtocols;
 869         }
 870 
 871         @Override
 872         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
 873             return serverDefaultProtocols;
 874         }
 875 
 876         @Override
 877         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 878             return clientDefaultCipherSuites;
 879         }
 880 
 881         @Override
 882         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 883             return serverDefaultCipherSuites;
 884         }
 885     }
 886 
 887     /*
 888      * The SSLContext implementation for default &quot;TLS&quot; algorithm
 889      *
 890      * @see SSLContext
 891      */
 892     public static final class TLSContext extends CustomizedTLSContext {
 893         // use the default constructor and methods
 894     }
 895 
 896     // lazy initialization holder class idiom for static default parameters
 897     //
 898     // See Effective Java Second Edition: Item 71.
 899     private static final class DefaultManagersHolder {
 900         private static final String NONE = &quot;NONE&quot;;
 901         private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 902 
 903         private static final TrustManager[] trustManagers;
 904         private static final KeyManager[] keyManagers;
 905 
 906         private static final Exception reservedException;
 907 
 908         static {
 909             Exception reserved = null;
 910             TrustManager[] tmMediator = null;
 911             try {
 912                 tmMediator = getTrustManagers();
 913             } catch (Exception e) {
 914                 reserved = e;
 915                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
 916                     SSLLogger.warning(
 917                             &quot;Failed to load default trust managers&quot;, e);
 918                 }
 919             }
 920 
 921             KeyManager[] kmMediator = null;
 922             if (reserved == null) {
 923                 try {
 924                     kmMediator = getKeyManagers();
 925                 } catch (Exception e) {
 926                     reserved = e;
 927                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
 928                         SSLLogger.warning(
 929                                 &quot;Failed to load default key managers&quot;, e);
 930                     }
 931                 }
 932             }
 933 
 934             if (reserved != null) {
 935                 trustManagers = new TrustManager[0];
 936                 keyManagers = new KeyManager[0];
 937 
 938                 // Important note: please don&#39;t reserve the original exception
 939                 // object, which may be not garbage collection friendly as
 940                 // &#39;reservedException&#39; is a static filed.
 941                 reservedException =
 942                         new KeyManagementException(reserved.getMessage());
 943             } else {
 944                 trustManagers = tmMediator;
 945                 keyManagers = kmMediator;
 946 
 947                 reservedException = null;
 948             }
 949         }
 950 
 951         private static TrustManager[] getTrustManagers() throws Exception {
 952             TrustManagerFactory tmf = TrustManagerFactory.getInstance(
 953                     TrustManagerFactory.getDefaultAlgorithm());
 954             if (&quot;SunJSSE&quot;.equals(tmf.getProvider().getName())) {
 955                 // The implementation will load the default KeyStore
 956                 // automatically.  Cached trust materials may be used
 957                 // for performance improvement.
 958                 tmf.init((KeyStore)null);
 959             } else {
 960                 // Use the explicitly specified KeyStore for third party&#39;s
 961                 // TrustManagerFactory implementation.
 962                 KeyStore ks = TrustStoreManager.getTrustedKeyStore();
 963                 tmf.init(ks);
 964             }
 965 
 966             return tmf.getTrustManagers();
 967         }
 968 
 969         private static KeyManager[] getKeyManagers() throws Exception {
 970 
 971             final Map&lt;String,String&gt; props = new HashMap&lt;&gt;();
 972             AccessController.doPrivileged(
 973                         new PrivilegedExceptionAction&lt;Object&gt;() {
 974                 @Override
 975                 public Object run() throws Exception {
 976                     props.put(&quot;keyStore&quot;,  System.getProperty(
 977                                 &quot;javax.net.ssl.keyStore&quot;, &quot;&quot;));
 978                     props.put(&quot;keyStoreType&quot;, System.getProperty(
 979                                 &quot;javax.net.ssl.keyStoreType&quot;,
 980                                 KeyStore.getDefaultType()));
 981                     props.put(&quot;keyStoreProvider&quot;, System.getProperty(
 982                                 &quot;javax.net.ssl.keyStoreProvider&quot;, &quot;&quot;));
 983                     props.put(&quot;keyStorePasswd&quot;, System.getProperty(
 984                                 &quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;));
 985                     return null;
 986                 }
 987             });
 988 
 989             final String defaultKeyStore = props.get(&quot;keyStore&quot;);
 990             String defaultKeyStoreType = props.get(&quot;keyStoreType&quot;);
 991             String defaultKeyStoreProvider = props.get(&quot;keyStoreProvider&quot;);
 992             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
 993                 SSLLogger.fine(&quot;keyStore is : &quot; + defaultKeyStore);
 994                 SSLLogger.fine(&quot;keyStore type is : &quot; +
 995                                         defaultKeyStoreType);
 996                 SSLLogger.fine(&quot;keyStore provider is : &quot; +
 997                                         defaultKeyStoreProvider);
 998             }
 999 
1000             if (P11KEYSTORE.equals(defaultKeyStoreType) &amp;&amp;
1001                     !NONE.equals(defaultKeyStore)) {
1002                 throw new IllegalArgumentException(&quot;if keyStoreType is &quot;
1003                     + P11KEYSTORE + &quot;, then keyStore must be &quot; + NONE);
1004             }
1005 
1006             FileInputStream fs = null;
1007             KeyStore ks = null;
1008             char[] passwd = null;
1009             try {
1010                 if (!defaultKeyStore.isEmpty() &amp;&amp;
1011                         !NONE.equals(defaultKeyStore)) {
1012                     fs = AccessController.doPrivileged(
1013                             new PrivilegedExceptionAction&lt;FileInputStream&gt;() {
1014                         @Override
1015                         public FileInputStream run() throws Exception {
1016                             return new FileInputStream(defaultKeyStore);
1017                         }
1018                     });
1019                 }
1020 
1021                 String defaultKeyStorePassword = props.get(&quot;keyStorePasswd&quot;);
1022                 if (!defaultKeyStorePassword.isEmpty()) {
1023                     passwd = defaultKeyStorePassword.toCharArray();
1024                 }
1025 
1026                 /**
1027                  * Try to initialize key store.
1028                  */
1029                 if ((defaultKeyStoreType.length()) != 0) {
1030                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1031                         SSLLogger.finest(&quot;init keystore&quot;);
1032                     }
1033                     if (defaultKeyStoreProvider.isEmpty()) {
1034                         ks = KeyStore.getInstance(defaultKeyStoreType);
1035                     } else {
1036                         ks = KeyStore.getInstance(defaultKeyStoreType,
1037                                             defaultKeyStoreProvider);
1038                     }
1039 
1040                     // if defaultKeyStore is NONE, fs will be null
1041                     ks.load(fs, passwd);
1042                 }
1043             } finally {
1044                 if (fs != null) {
1045                     fs.close();
1046                     fs = null;
1047                 }
1048             }
1049 
1050             /*
1051              * Try to initialize key manager.
1052              */
1053             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1054                 SSLLogger.fine(&quot;init keymanager of type &quot; +
1055                     KeyManagerFactory.getDefaultAlgorithm());
1056             }
1057             KeyManagerFactory kmf = KeyManagerFactory.getInstance(
1058                 KeyManagerFactory.getDefaultAlgorithm());
1059 
1060             if (P11KEYSTORE.equals(defaultKeyStoreType)) {
1061                 kmf.init(ks, null); // do not pass key passwd if using token
1062             } else {
1063                 kmf.init(ks, passwd);
1064             }
1065 
1066             return kmf.getKeyManagers();
1067         }
1068     }
1069 
1070     // lazy initialization holder class idiom for static default parameters
1071     //
1072     // See Effective Java Second Edition: Item 71.
1073     private static final class DefaultSSLContextHolder {
1074 
1075         private static final SSLContextImpl sslContext;
1076         private static final Exception reservedException;
1077 
1078         static {
1079             Exception reserved = null;
1080             SSLContextImpl mediator = null;
1081             if (DefaultManagersHolder.reservedException != null) {
1082                 reserved = DefaultManagersHolder.reservedException;
1083             } else {
1084                 try {
1085                     mediator = new DefaultSSLContext();
1086                 } catch (Exception e) {
1087                     // Important note: please don&#39;t reserve the original
1088                     // exception object, which may be not garbage collection
1089                     // friendly as &#39;reservedException&#39; is a static filed.
1090                     reserved = new KeyManagementException(e.getMessage());
1091                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1092                         SSLLogger.warning(
1093                                 &quot;Failed to load default SSLContext&quot;, e);
1094                     }
1095                 }
1096             }
1097 
1098             sslContext = mediator;
1099             reservedException = reserved;
1100         }
1101     }
1102 
1103     /*
1104      * The SSLContext implementation for default &quot;Default&quot; algorithm
1105      *
1106      * @see SSLContext
1107      */
1108     public static final class DefaultSSLContext extends CustomizedTLSContext {
1109 
1110         // public constructor for SSLContext.getInstance(&quot;Default&quot;)
1111         public DefaultSSLContext() throws Exception {
1112             if (DefaultManagersHolder.reservedException != null) {
1113                 throw DefaultManagersHolder.reservedException;
1114             }
1115 
1116             try {
1117                 super.engineInit(DefaultManagersHolder.keyManagers,
1118                         DefaultManagersHolder.trustManagers, null);
1119             } catch (Exception e) {
1120                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,defaultctx&quot;)) {
1121                     SSLLogger.fine(&quot;default context init failed: &quot;, e);
1122                 }
1123                 throw e;
1124             }
1125         }
1126 
1127         @Override
1128         protected void engineInit(KeyManager[] km, TrustManager[] tm,
1129             SecureRandom sr) throws KeyManagementException {
1130             throw new KeyManagementException
1131                 (&quot;Default SSLContext is initialized automatically&quot;);
1132         }
1133 
1134         static SSLContextImpl getDefaultImpl() throws Exception {
1135             if (DefaultSSLContextHolder.reservedException != null) {
1136                 throw DefaultSSLContextHolder.reservedException;
1137             }
1138 
1139             return DefaultSSLContextHolder.sslContext;
1140         }
1141     }
1142 
1143     /*
1144      * The base abstract SSLContext implementation for the Datagram Transport
1145      * Layer Security (DTLS) protocols.
1146      *
1147      * This abstract class encapsulates supported and the default server DTLS
1148      * parameters.
1149      *
1150      * @see SSLContext
1151      */
1152     private abstract static class AbstractDTLSContext extends SSLContextImpl {
1153         private static final List&lt;ProtocolVersion&gt; supportedProtocols;
1154         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
1155 
1156         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
1157         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
1158 
1159         static {
1160             supportedProtocols = Arrays.asList(
1161                 ProtocolVersion.DTLS12,
1162                 ProtocolVersion.DTLS10
1163             );
1164 
1165             // available protocols for server mode
1166             serverDefaultProtocols = getAvailableProtocols(
1167                     new ProtocolVersion[] {
1168                 ProtocolVersion.DTLS12,
1169                 ProtocolVersion.DTLS10
1170             });
1171 
1172             supportedCipherSuites = getApplicableSupportedCipherSuites(
1173                     supportedProtocols);
1174             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
1175                     serverDefaultProtocols, false);
1176         }
1177 
1178         @Override
1179         protected SSLParameters engineGetDefaultSSLParameters() {
1180             SSLEngine engine = createSSLEngineImpl();
1181             return engine.getSSLParameters();
1182         }
1183 
1184         @Override
1185         protected SSLParameters engineGetSupportedSSLParameters() {
1186             SSLEngine engine = createSSLEngineImpl();
1187             SSLParameters params = new SSLParameters();
1188             params.setCipherSuites(engine.getSupportedCipherSuites());
1189             params.setProtocols(engine.getSupportedProtocols());
1190             return params;
1191         }
1192 
1193         @Override
1194         List&lt;ProtocolVersion&gt; getSupportedProtocolVersions() {
1195             return supportedProtocols;
1196         }
1197 
1198         @Override
1199         List&lt;CipherSuite&gt; getSupportedCipherSuites() {
1200             return supportedCipherSuites;
1201         }
1202 
1203         @Override
1204         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
1205             return serverDefaultProtocols;
1206         }
1207 
1208         @Override
1209         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
1210             return serverDefaultCipherSuites;
1211         }
1212 
1213         @Override
1214         SSLEngine createSSLEngineImpl() {
1215             return new SSLEngineImpl(this);
1216         }
1217 
1218         @Override
1219         SSLEngine createSSLEngineImpl(String host, int port) {
1220             return new SSLEngineImpl(this, host, port);
1221         }
1222 
1223         @Override
1224         boolean isDTLS() {
1225             return true;
1226         }
1227     }
1228 
1229     /*
1230      * The SSLContext implementation for DTLSv1.0 algorithm.
1231      *
1232      * @see SSLContext
1233      */
1234     public static final class DTLS10Context extends AbstractDTLSContext {
1235         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
1236         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
1237 
1238         static {
1239             // available protocols for client mode
1240             clientDefaultProtocols = getAvailableProtocols(
1241                     new ProtocolVersion[] {
1242                 ProtocolVersion.DTLS10
1243             });
1244 
1245             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
1246                     clientDefaultProtocols, true);
1247         }
1248 
1249         @Override
1250         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
1251             return clientDefaultProtocols;
1252         }
1253 
1254         @Override
1255         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
1256             return clientDefaultCipherSuites;
1257         }
1258     }
1259 
1260     /*
1261      * The SSLContext implementation for DTLSv1.2 algorithm.
1262      *
1263      * @see SSLContext
1264      */
1265     public static final class DTLS12Context extends AbstractDTLSContext {
1266         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
1267         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
1268 
1269         static {
1270             // available protocols for client mode
1271             clientDefaultProtocols = getAvailableProtocols(
1272                     new ProtocolVersion[] {
1273                 ProtocolVersion.DTLS12,
1274                 ProtocolVersion.DTLS10
1275             });
1276 
1277             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
1278                     clientDefaultProtocols, true);
1279         }
1280 
1281         @Override
1282         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
1283             return clientDefaultProtocols;
1284         }
1285 
1286         @Override
1287         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
1288             return clientDefaultCipherSuites;
1289         }
1290     }
1291 
1292     /*
1293      * The SSLContext implementation for customized TLS protocols
1294      *
1295      * @see SSLContext
1296      */
1297     private static class CustomizedDTLSContext extends AbstractDTLSContext {
1298         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
1299         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
1300         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
1301         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
1302 
1303         private static IllegalArgumentException reservedException = null;
1304 
1305         // Don&#39;t want a java.lang.LinkageError for illegal system property.
1306         //
1307         // Please don&#39;t throw exception in this static block.  Otherwise,
1308         // java.lang.LinkageError may be thrown during the instantiation of
1309         // the provider service. Instead, let&#39;s handle the initialization
1310         // exception in constructor.
1311         static {
1312             reservedException = CustomizedSSLProtocols.reservedException;
1313             if (reservedException == null) {
1314                 clientDefaultProtocols = customizedProtocols(true,
1315                         CustomizedSSLProtocols.customizedClientProtocols);
1316                 serverDefaultProtocols = customizedProtocols(false,
1317                         CustomizedSSLProtocols.customizedServerProtocols);
1318 
1319                 clientDefaultCipherSuites =
1320                         getApplicableEnabledCipherSuites(
1321                                 clientDefaultProtocols, true);
1322                 serverDefaultCipherSuites =
1323                         getApplicableEnabledCipherSuites(
1324                                 serverDefaultProtocols, false);
1325 
1326             } else {
1327                 // unlikely to be used
1328                 clientDefaultProtocols = null;
1329                 serverDefaultProtocols = null;
1330                 clientDefaultCipherSuites = null;
1331                 serverDefaultCipherSuites = null;
1332             }
1333         }
1334 
1335         private static List&lt;ProtocolVersion&gt; customizedProtocols(boolean client,
1336                 List&lt;ProtocolVersion&gt; customized) {
1337             List&lt;ProtocolVersion&gt; refactored = new ArrayList&lt;&gt;();
1338             for (ProtocolVersion pv : customized) {
1339                 if (pv.isDTLS) {
1340                     refactored.add(pv);
1341                 }
1342             }
1343 
1344             ProtocolVersion[] candidates;
1345             // Use the default enabled protocols if no customization
1346             if (refactored.isEmpty()) {
1347                 candidates = new ProtocolVersion[]{
1348                         ProtocolVersion.DTLS12,
1349                         ProtocolVersion.DTLS10
1350                 };
1351                 if (!client)
1352                     return Arrays.asList(candidates);
1353             } else {
1354                 // Use the customized TLS protocols.
1355                 candidates =
1356                         new ProtocolVersion[customized.size()];
1357                 candidates = customized.toArray(candidates);
1358             }
1359 
1360             return getAvailableProtocols(candidates);
1361         }
1362 
1363         protected CustomizedDTLSContext() {
1364             if (reservedException != null) {
1365                 throw reservedException;
1366             }
1367         }
1368 
1369         @Override
1370         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
1371             return clientDefaultProtocols;
1372         }
1373 
1374         @Override
1375         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
1376             return serverDefaultProtocols;
1377         }
1378 
1379         @Override
1380         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
1381             return clientDefaultCipherSuites;
1382         }
1383 
1384         @Override
1385         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
1386             return serverDefaultCipherSuites;
1387         }
1388     }
1389 
1390     /*
1391      * The SSLContext implementation for default &quot;DTLS&quot; algorithm
1392      *
1393      * @see SSLContext
1394      */
1395     public static final class DTLSContext extends CustomizedDTLSContext {
1396         // use the default constructor and methods
1397     }
1398 
1399 }
1400 
1401 final class AbstractTrustManagerWrapper extends X509ExtendedTrustManager
1402             implements X509TrustManager {
1403 
1404     // the delegated trust manager
1405     private final X509TrustManager tm;
1406 
1407     AbstractTrustManagerWrapper(X509TrustManager tm) {
1408         this.tm = tm;
1409     }
1410 
1411     @Override
1412     public void checkClientTrusted(X509Certificate[] chain, String authType)
1413         throws CertificateException {
1414         tm.checkClientTrusted(chain, authType);
1415     }
1416 
1417     @Override
1418     public void checkServerTrusted(X509Certificate[] chain, String authType)
1419         throws CertificateException {
1420         tm.checkServerTrusted(chain, authType);
1421     }
1422 
1423     @Override
1424     public X509Certificate[] getAcceptedIssuers() {
1425         return tm.getAcceptedIssuers();
1426     }
1427 
1428     @Override
1429     public void checkClientTrusted(X509Certificate[] chain, String authType,
1430                 Socket socket) throws CertificateException {
1431         tm.checkClientTrusted(chain, authType);
1432         checkAdditionalTrust(chain, authType, socket, true);
1433     }
1434 
1435     @Override
1436     public void checkServerTrusted(X509Certificate[] chain, String authType,
1437             Socket socket) throws CertificateException {
1438         tm.checkServerTrusted(chain, authType);
1439         checkAdditionalTrust(chain, authType, socket, false);
1440     }
1441 
1442     @Override
1443     public void checkClientTrusted(X509Certificate[] chain, String authType,
1444             SSLEngine engine) throws CertificateException {
1445         tm.checkClientTrusted(chain, authType);
1446         checkAdditionalTrust(chain, authType, engine, true);
1447     }
1448 
1449     @Override
1450     public void checkServerTrusted(X509Certificate[] chain, String authType,
1451             SSLEngine engine) throws CertificateException {
1452         tm.checkServerTrusted(chain, authType);
1453         checkAdditionalTrust(chain, authType, engine, false);
1454     }
1455 
1456     private void checkAdditionalTrust(X509Certificate[] chain,
1457             String authType, Socket socket,
1458             boolean checkClientTrusted) throws CertificateException {
1459         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
1460                                     socket instanceof SSLSocket) {
1461 
1462             SSLSocket sslSocket = (SSLSocket)socket;
1463             SSLSession session = sslSocket.getHandshakeSession();
1464             if (session == null) {
1465                 throw new CertificateException(&quot;No handshake session&quot;);
1466             }
1467 
1468             // check endpoint identity
1469             String identityAlg = sslSocket.getSSLParameters().
1470                                         getEndpointIdentificationAlgorithm();
1471             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
1472                 X509TrustManagerImpl.checkIdentity(session, chain,
1473                                     identityAlg, checkClientTrusted);
1474             }
1475 
1476             // try the best to check the algorithm constraints
1477             AlgorithmConstraints constraints;
1478             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1479                 if (session instanceof ExtendedSSLSession) {
1480                     ExtendedSSLSession extSession =
1481                                     (ExtendedSSLSession)session;
1482                     String[] peerSupportedSignAlgs =
1483                             extSession.getLocalSupportedSignatureAlgorithms();
1484 
1485                     constraints = new SSLAlgorithmConstraints(
1486                                     sslSocket, peerSupportedSignAlgs, true);
1487                 } else {
1488                     constraints =
1489                             new SSLAlgorithmConstraints(sslSocket, true);
1490                 }
1491             } else {
1492                 constraints = new SSLAlgorithmConstraints(sslSocket, true);
1493             }
1494 
1495             checkAlgorithmConstraints(chain, constraints, checkClientTrusted);
1496         }
1497     }
1498 
1499     private void checkAdditionalTrust(X509Certificate[] chain,
1500             String authType, SSLEngine engine,
1501             boolean checkClientTrusted) throws CertificateException {
1502         if (engine != null) {
1503             SSLSession session = engine.getHandshakeSession();
1504             if (session == null) {
1505                 throw new CertificateException(&quot;No handshake session&quot;);
1506             }
1507 
1508             // check endpoint identity
1509             String identityAlg = engine.getSSLParameters().
1510                                         getEndpointIdentificationAlgorithm();
1511             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
1512                 X509TrustManagerImpl.checkIdentity(session, chain,
1513                                     identityAlg, checkClientTrusted);
1514             }
1515 
1516             // try the best to check the algorithm constraints
1517             AlgorithmConstraints constraints;
1518             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1519                 if (session instanceof ExtendedSSLSession) {
1520                     ExtendedSSLSession extSession =
1521                                     (ExtendedSSLSession)session;
1522                     String[] peerSupportedSignAlgs =
1523                             extSession.getLocalSupportedSignatureAlgorithms();
1524 
1525                     constraints = new SSLAlgorithmConstraints(
1526                                     engine, peerSupportedSignAlgs, true);
1527                 } else {
1528                     constraints =
1529                             new SSLAlgorithmConstraints(engine, true);
1530                 }
1531             } else {
1532                 constraints = new SSLAlgorithmConstraints(engine, true);
1533             }
1534 
1535             checkAlgorithmConstraints(chain, constraints, checkClientTrusted);
1536         }
1537     }
1538 
1539     private void checkAlgorithmConstraints(X509Certificate[] chain,
1540             AlgorithmConstraints constraints,
1541             boolean checkClientTrusted) throws CertificateException {
1542         try {
1543             // Does the certificate chain end with a trusted certificate?
1544             int checkedLength = chain.length - 1;
1545 
1546             Collection&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
1547             X509Certificate[] certs = tm.getAcceptedIssuers();
1548             if ((certs != null) &amp;&amp; (certs.length &gt; 0)){
1549                 Collections.addAll(trustedCerts, certs);
1550             }
1551 
1552             if (trustedCerts.contains(chain[checkedLength])) {
1553                     checkedLength--;
1554             }
1555 
1556             // A forward checker, need to check from trust to target
1557             if (checkedLength &gt;= 0) {
1558                 AlgorithmChecker checker =
1559                     new AlgorithmChecker(constraints, null,
1560                             (checkClientTrusted ? Validator.VAR_TLS_CLIENT :
1561                                         Validator.VAR_TLS_SERVER));
1562                 checker.init(false);
1563                 for (int i = checkedLength; i &gt;= 0; i--) {
1564                     X509Certificate cert = chain[i];
1565                     // We don&#39;t care about the unresolved critical extensions.
1566                     checker.check(cert, Collections.&lt;String&gt;emptySet());
1567                 }
1568             }
1569         } catch (CertPathValidatorException cpve) {
1570             throw new CertificateException(
1571                 &quot;Certificates do not conform to algorithm constraints&quot;, cpve);
1572         }
1573     }
1574 }
1575 
1576 // Dummy X509TrustManager implementation, rejects all peer certificates.
1577 // Used if the application did not specify a proper X509TrustManager.
1578 final class DummyX509TrustManager extends X509ExtendedTrustManager
1579             implements X509TrustManager {
1580 
1581     static final X509TrustManager INSTANCE = new DummyX509TrustManager();
1582 
1583     private DummyX509TrustManager() {
1584         // empty
1585     }
1586 
1587     /*
1588      * Given the partial or complete certificate chain
1589      * provided by the peer, build a certificate path
1590      * to a trusted root and return if it can be
1591      * validated and is trusted for client SSL authentication.
1592      * If not, it throws an exception.
1593      */
1594     @Override
1595     public void checkClientTrusted(X509Certificate[] chain, String authType)
1596         throws CertificateException {
1597         throw new CertificateException(
1598             &quot;No X509TrustManager implementation avaiable&quot;);
1599     }
1600 
1601     /*
1602      * Given the partial or complete certificate chain
1603      * provided by the peer, build a certificate path
1604      * to a trusted root and return if it can be
1605      * validated and is trusted for server SSL authentication.
1606      * If not, it throws an exception.
1607      */
1608     @Override
1609     public void checkServerTrusted(X509Certificate[] chain, String authType)
1610         throws CertificateException {
1611         throw new CertificateException(
1612             &quot;No X509TrustManager implementation available&quot;);
1613     }
1614 
1615     /*
1616      * Return an array of issuer certificates which are trusted
1617      * for authenticating peers.
1618      */
1619     @Override
1620     public X509Certificate[] getAcceptedIssuers() {
1621         return new X509Certificate[0];
1622     }
1623 
1624     @Override
1625     public void checkClientTrusted(X509Certificate[] chain, String authType,
1626                 Socket socket) throws CertificateException {
1627         throw new CertificateException(
1628             &quot;No X509TrustManager implementation available&quot;);
1629     }
1630 
1631     @Override
1632     public void checkServerTrusted(X509Certificate[] chain, String authType,
1633             Socket socket) throws CertificateException {
1634         throw new CertificateException(
1635             &quot;No X509TrustManager implementation available&quot;);
1636     }
1637 
1638     @Override
1639     public void checkClientTrusted(X509Certificate[] chain, String authType,
1640             SSLEngine engine) throws CertificateException {
1641         throw new CertificateException(
1642             &quot;No X509TrustManager implementation available&quot;);
1643     }
1644 
1645     @Override
1646     public void checkServerTrusted(X509Certificate[] chain, String authType,
1647             SSLEngine engine) throws CertificateException {
1648         throw new CertificateException(
1649             &quot;No X509TrustManager implementation available&quot;);
1650     }
1651 }
1652 
1653 /*
1654  * A wrapper class to turn a X509KeyManager into an X509ExtendedKeyManager
1655  */
1656 final class AbstractKeyManagerWrapper extends X509ExtendedKeyManager {
1657 
1658     private final X509KeyManager km;
1659 
1660     AbstractKeyManagerWrapper(X509KeyManager km) {
1661         this.km = km;
1662     }
1663 
1664     @Override
1665     public String[] getClientAliases(String keyType, Principal[] issuers) {
1666         return km.getClientAliases(keyType, issuers);
1667     }
1668 
1669     @Override
1670     public String chooseClientAlias(String[] keyType, Principal[] issuers,
1671             Socket socket) {
1672         return km.chooseClientAlias(keyType, issuers, socket);
1673     }
1674 
1675     @Override
1676     public String[] getServerAliases(String keyType, Principal[] issuers) {
1677         return km.getServerAliases(keyType, issuers);
1678     }
1679 
1680     @Override
1681     public String chooseServerAlias(String keyType, Principal[] issuers,
1682             Socket socket) {
1683         return km.chooseServerAlias(keyType, issuers, socket);
1684     }
1685 
1686     @Override
1687     public X509Certificate[] getCertificateChain(String alias) {
1688         return km.getCertificateChain(alias);
1689     }
1690 
1691     @Override
1692     public PrivateKey getPrivateKey(String alias) {
1693         return km.getPrivateKey(alias);
1694     }
1695 
1696     // Inherit chooseEngineClientAlias() and chooseEngineServerAlias() from
1697     // X509ExtendedKeymanager. It defines them to return null;
1698 }
1699 
1700 
1701 // Dummy X509KeyManager implementation, never returns any certificates/keys.
1702 // Used if the application did not specify a proper X509TrustManager.
1703 final class DummyX509KeyManager extends X509ExtendedKeyManager {
1704 
1705     static final X509ExtendedKeyManager INSTANCE = new DummyX509KeyManager();
1706 
1707     private DummyX509KeyManager() {
1708         // empty
1709     }
1710 
1711     /*
1712      * Get the matching aliases for authenticating the client side of a secure
1713      * socket given the public key type and the list of
1714      * certificate issuer authorities recognized by the peer (if any).
1715      */
1716     @Override
1717     public String[] getClientAliases(String keyType, Principal[] issuers) {
1718         return null;
1719     }
1720 
1721     /*
1722      * Choose an alias to authenticate the client side of a secure
1723      * socket given the public key type and the list of
1724      * certificate issuer authorities recognized by the peer (if any).
1725      */
1726     @Override
1727     public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
1728             Socket socket) {
1729         return null;
1730     }
1731 
1732     /*
1733      * Choose an alias to authenticate the client side of an
1734      * engine given the public key type and the list of
1735      * certificate issuer authorities recognized by the peer (if any).
1736      */
1737     @Override
1738     public String chooseEngineClientAlias(
1739             String[] keyTypes, Principal[] issuers, SSLEngine engine) {
1740         return null;
1741     }
1742 
1743     /*
1744      * Get the matching aliases for authenticating the server side of a secure
1745      * socket given the public key type and the list of
1746      * certificate issuer authorities recognized by the peer (if any).
1747      */
1748     @Override
1749     public String[] getServerAliases(String keyType, Principal[] issuers) {
1750         return null;
1751     }
1752 
1753     /*
1754      * Choose an alias to authenticate the server side of a secure
1755      * socket given the public key type and the list of
1756      * certificate issuer authorities recognized by the peer (if any).
1757      */
1758     @Override
1759     public String chooseServerAlias(String keyType, Principal[] issuers,
1760             Socket socket) {
1761         return null;
1762     }
1763 
1764     /*
1765      * Choose an alias to authenticate the server side of an engine
1766      * given the public key type and the list of
1767      * certificate issuer authorities recognized by the peer (if any).
1768      */
1769     @Override
1770     public String chooseEngineServerAlias(
1771             String keyType, Principal[] issuers, SSLEngine engine) {
1772         return null;
1773     }
1774 
1775     /**
1776      * Returns the certificate chain associated with the given alias.
1777      *
1778      * @param alias the alias name
1779      *
1780      * @return the certificate chain (ordered with the user&#39;s certificate first
1781      * and the root certificate authority last)
1782      */
1783     @Override
1784     public X509Certificate[] getCertificateChain(String alias) {
1785         return null;
1786     }
1787 
1788     /*
1789      * Returns the key associated with the given alias, using the given
1790      * password to recover it.
1791      *
1792      * @param alias the alias name
1793      *
1794      * @return the requested key
1795      */
1796     @Override
1797     public PrivateKey getPrivateKey(String alias) {
1798         return null;
1799     }
1800 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/ServerHello.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLTransport.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ServerHelloDone.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ServerHello.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,18 +26,19 @@</span>
  package sun.security.ssl;
  
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.security.AlgorithmConstraints;
<span class="udiff-line-added">+ import java.security.CryptoPrimitive;</span>
  import java.security.GeneralSecurityException;
  import java.text.MessageFormat;
  import java.util.Arrays;
<span class="udiff-line-added">+ import java.util.EnumSet;</span>
  import java.util.LinkedList;
  import java.util.List;
  import java.util.Locale;
  import java.util.Map;
<span class="udiff-line-removed">- import java.util.Optional;</span>
  import javax.crypto.SecretKey;
  import javax.crypto.spec.IvParameterSpec;
  import javax.net.ssl.SSLException;
  import javax.net.ssl.SSLHandshakeException;
  import javax.net.ssl.SSLProtocolException;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46,10 +47,12 @@</span>
  import sun.security.ssl.SSLCipher.SSLReadCipher;
  import sun.security.ssl.SSLCipher.SSLWriteCipher;
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
  import sun.security.ssl.SupportedVersionsExtension.SHSupportedVersionsSpec;
  
<span class="udiff-line-added">+ import static sun.security.ssl.SSLExtension.SH_SESSION_TICKET;</span>
<span class="udiff-line-added">+ </span>
  /**
   * Pack of the ServerHello/HelloRetryRequest handshake message.
   */
  final class ServerHello {
      static final SSLConsumer handshakeConsumer =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,10 +339,19 @@</span>
                      }
                  }
                  shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO_DONE.id,
                          SSLHandshake.SERVER_HELLO_DONE);
              } else {
<span class="udiff-line-added">+                 // stateless and use the client session id (RFC 5077 3.4)</span>
<span class="udiff-line-added">+                 if (shc.statelessResumption) {</span>
<span class="udiff-line-added">+                     shc.resumingSession = new SSLSessionImpl(shc.resumingSession,</span>
<span class="udiff-line-added">+                             (clientHello.sessionId.length() == 0) ?</span>
<span class="udiff-line-added">+                                     new SessionId(true,</span>
<span class="udiff-line-added">+                                             shc.sslContext.getSecureRandom()) :</span>
<span class="udiff-line-added">+                                     new SessionId(clientHello.sessionId.getId())</span>
<span class="udiff-line-added">+                     );</span>
<span class="udiff-line-added">+                 }</span>
                  shc.handshakeSession = shc.resumingSession;
                  shc.negotiatedProtocol =
                          shc.resumingSession.getProtocolVersion();
                  shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
                  shc.handshakeHash.determine(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -422,11 +434,11 @@</span>
                          cs.keyExchange, shc.negotiatedProtocol);
                  if (ke == null) {
                      continue;
                  }
                  if (!ServerHandshakeContext.legacyAlgorithmConstraints.permits(
<span class="udiff-line-modified-removed">-                         null, cs.name, null)) {</span>
<span class="udiff-line-modified-added">+                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), cs.name, null)) {</span>
                      legacySuites.add(cs);
                      continue;
                  }
  
                  SSLPossession[] hcds = ke.createPossessions(shc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -490,10 +502,13 @@</span>
                  HandshakeMessage message) throws IOException {
              // The producing happens in server side only.
              ServerHandshakeContext shc = (ServerHandshakeContext)context;
              ClientHelloMessage clientHello = (ClientHelloMessage)message;
  
<span class="udiff-line-added">+             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="udiff-line-added">+                     shc.sslContext.engineGetServerSessionContext();</span>
<span class="udiff-line-added">+ </span>
              // If client hasn&#39;t specified a session we can resume, start a
              // new one and choose its cipher suite and compression options,
              // unless new session creation is disabled for this connection!
              if (!shc.isResumption || shc.resumingSession == null) {
                  if (!shc.sslConfig.enableSessionCreation) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -542,15 +557,13 @@</span>
                  shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
                  shc.handshakeHash.determine(
                          shc.negotiatedProtocol, shc.negotiatedCipherSuite);
  
                  setUpPskKD(shc,
<span class="udiff-line-modified-removed">-                         shc.resumingSession.consumePreSharedKey().get());</span>
<span class="udiff-line-modified-added">+                         shc.resumingSession.consumePreSharedKey());</span>
  
                  // The session can&#39;t be resumed again---remove it from cache
<span class="udiff-line-removed">-                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="udiff-line-removed">-                     shc.sslContext.engineGetServerSessionContext();</span>
                  sessionCache.remove(shc.resumingSession.getSessionId());
              }
  
              // update the responders
              shc.handshakeProducers.put(SSLHandshake.ENCRYPTED_EXTENSIONS.id,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -678,10 +691,15 @@</span>
                      writeCipher, (clientHello.sessionId.length() != 0));
  
              // Update the context for master key derivation.
              shc.handshakeKeyDerivation = kd;
  
<span class="udiff-line-added">+             // Check if the server supports stateless resumption</span>
<span class="udiff-line-added">+             if (sessionCache.statelessEnabled()) {</span>
<span class="udiff-line-added">+                 shc.statelessResumption = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              // The handshake message has been delivered.
              return null;
          }
  
          private static CipherSuite chooseCipherSuite(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -705,11 +723,13 @@</span>
                          proposed, shc.negotiatedProtocol, cs)) {
                      continue;
                  }
  
                  if ((legacySuite == null) &amp;&amp;
<span class="udiff-line-modified-removed">-                         !legacyConstraints.permits(null, cs.name, null)) {</span>
<span class="udiff-line-modified-added">+                         !legacyConstraints.permits(</span>
<span class="udiff-line-added">+                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="udiff-line-added">+                                 cs.name, null)) {</span>
                      legacySuite = cs;
                      continue;
                  }
  
                  // The cipher suite has been negotiated.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1097,13 +1117,27 @@</span>
  
                  if (!chc.sslConfig.enableSessionCreation) {
                      throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
                          &quot;New session creation is disabled&quot;);
                  }
<span class="udiff-line-modified-removed">-                 chc.handshakeSession = new SSLSessionImpl(chc,</span>
<span class="udiff-line-modified-removed">-                         chc.negotiatedCipherSuite,</span>
<span class="udiff-line-modified-removed">-                         serverHello.sessionId);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 if (serverHello.sessionId.length() == 0 &amp;&amp;</span>
<span class="udiff-line-modified-added">+                         chc.statelessResumption) {</span>
<span class="udiff-line-added">+                     SessionId newId = new SessionId(true,</span>
<span class="udiff-line-added">+                             chc.sslContext.getSecureRandom());</span>
<span class="udiff-line-added">+                     chc.handshakeSession = new SSLSessionImpl(chc,</span>
<span class="udiff-line-added">+                             chc.negotiatedCipherSuite, newId);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                         SSLLogger.fine(&quot;Locally assigned Session Id: &quot; +</span>
<span class="udiff-line-added">+                                 newId.toString());</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     chc.handshakeSession = new SSLSessionImpl(chc,</span>
<span class="udiff-line-added">+                             chc.negotiatedCipherSuite,</span>
<span class="udiff-line-added">+                             serverHello.sessionId);</span>
<span class="udiff-line-added">+                 }</span>
                  chc.handshakeSession.setMaximumPacketSize(
                          chc.sslConfig.maximumPacketSize);
              }
  
              //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1123,10 +1157,15 @@</span>
                  } else {
                      chc.handshakeKeyDerivation = kdg.createKeyDerivation(
                              chc, chc.resumingSession.getMasterSecret());
                  }
  
<span class="udiff-line-added">+                 if (chc.statelessResumption) {</span>
<span class="udiff-line-added">+                     chc.handshakeConsumers.putIfAbsent(</span>
<span class="udiff-line-added">+                             SSLHandshake.NEW_SESSION_TICKET.id,</span>
<span class="udiff-line-added">+                             SSLHandshake.NEW_SESSION_TICKET);</span>
<span class="udiff-line-added">+                 }</span>
                  chc.conContext.consumers.putIfAbsent(
                          ContentType.CHANGE_CIPHER_SPEC.id,
                          ChangeCipherSpec.t10Consumer);
                  chc.handshakeConsumers.put(
                          SSLHandshake.FINISHED.id,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1221,20 +1260,20 @@</span>
                          serverHello.sessionId);
                  chc.handshakeSession.setMaximumPacketSize(
                          chc.sslConfig.maximumPacketSize);
              } else {
                  // The PSK is consumed to allow it to be deleted
<span class="udiff-line-modified-removed">-                 Optional&lt;SecretKey&gt; psk =</span>
<span class="udiff-line-modified-added">+                 SecretKey psk =</span>
                          chc.resumingSession.consumePreSharedKey();
<span class="udiff-line-modified-removed">-                 if(!psk.isPresent()) {</span>
<span class="udiff-line-modified-added">+                 if(psk == null) {</span>
                      throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No PSK available. Unable to resume.&quot;);
                  }
  
                  chc.handshakeSession = chc.resumingSession;
  
<span class="udiff-line-modified-removed">-                 setUpPskKD(chc, psk.get());</span>
<span class="udiff-line-modified-added">+                 setUpPskKD(chc, psk);</span>
              }
  
              //
              // update
              //
</pre>
<center><a href="SSLTransport.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ServerHelloDone.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
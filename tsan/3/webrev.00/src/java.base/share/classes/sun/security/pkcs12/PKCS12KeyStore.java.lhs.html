<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs12;
  27 
  28 import java.io.*;
  29 import java.security.AccessController;
  30 import java.security.MessageDigest;
  31 import java.security.NoSuchAlgorithmException;
  32 import java.security.Key;
  33 import java.security.KeyFactory;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreSpi;
  36 import java.security.KeyStoreException;
  37 import java.security.PKCS12Attribute;
  38 import java.security.PrivateKey;
  39 import java.security.PrivilegedAction;
  40 import java.security.UnrecoverableEntryException;
  41 import java.security.UnrecoverableKeyException;
  42 import java.security.SecureRandom;
  43 import java.security.Security;
  44 import java.security.cert.Certificate;
  45 import java.security.cert.CertificateFactory;
  46 import java.security.cert.X509Certificate;
  47 import java.security.cert.CertificateException;
  48 import java.security.spec.AlgorithmParameterSpec;
  49 import java.security.spec.InvalidParameterSpecException;
  50 import java.security.spec.KeySpec;
  51 import java.security.spec.PKCS8EncodedKeySpec;
  52 import java.util.*;
  53 
<a name="2" id="anc2"></a>

  54 import java.security.AlgorithmParameters;
  55 import java.security.InvalidAlgorithmParameterException;
  56 import javax.crypto.spec.PBEParameterSpec;
  57 import javax.crypto.spec.PBEKeySpec;
  58 import javax.crypto.spec.SecretKeySpec;
  59 import javax.crypto.SecretKeyFactory;
  60 import javax.crypto.SecretKey;
  61 import javax.crypto.Cipher;
  62 import javax.crypto.Mac;
  63 import javax.security.auth.DestroyFailedException;
  64 import javax.security.auth.x500.X500Principal;
  65 
  66 import sun.security.tools.KeyStoreUtil;
  67 import sun.security.util.Debug;
  68 import sun.security.util.DerInputStream;
  69 import sun.security.util.DerOutputStream;
  70 import sun.security.util.DerValue;
  71 import sun.security.util.ObjectIdentifier;
  72 import sun.security.pkcs.ContentInfo;
  73 import sun.security.util.SecurityProperties;
  74 import sun.security.x509.AlgorithmId;
  75 import sun.security.pkcs.EncryptedPrivateKeyInfo;
  76 import sun.security.provider.JavaKeyStore.JKS;
  77 import sun.security.util.KeyStoreDelegator;
  78 import sun.security.x509.AuthorityKeyIdentifierExtension;
  79 
  80 
  81 /**
  82  * This class provides the keystore implementation referred to as &quot;PKCS12&quot;.
  83  * Implements the PKCS#12 PFX protected using the Password privacy mode.
  84  * The contents are protected using Password integrity mode.
  85  *
  86  * Currently these PBE algorithms are used by default:
  87  *  - PBEWithSHA1AndDESede to encrypt private keys, iteration count 50000.
  88  *  - PBEWithSHA1AndRC2_40 to encrypt certificates, iteration count 50000.
  89  *
  90  * The default Mac algorithm is  HmacPBESHA1, iteration count 100000.
  91  *
  92  * Supported encryption of various implementations :
  93  *
  94  * Software and mode.     Certificate encryption  Private key encryption
  95  * ---------------------------------------------------------------------
  96  * MSIE4 (domestic            40 bit RC2.            40 bit RC2
  97  * and xport versions)
  98  * PKCS#12 export.
  99  *
 100  * MSIE4, 5 (domestic         40 bit RC2,            40 bit RC2,
 101  * and export versions)       3 key triple DES       3 key triple DES
 102  * PKCS#12 import.
 103  *
 104  * MSIE5                      40 bit RC2             3 key triple DES,
 105  * PKCS#12 export.                                   with SHA1 (168 bits)
 106  *
 107  * Netscape Communicator      40 bit RC2             3 key triple DES,
 108  * (domestic and export                              with SHA1 (168 bits)
 109  * versions) PKCS#12 export
 110  *
 111  * Netscape Communicator      40 bit ciphers only    All.
 112  * (export version)
 113  * PKCS#12 import.
 114  *
 115  * Netscape Communicator      All.                   All.
 116  * (domestic or fortified
 117  * version) PKCS#12 import.
 118  *
 119  * OpenSSL PKCS#12 code.      All.                   All.
 120  * ---------------------------------------------------------------------
 121  *
 122  * NOTE: PKCS12 KeyStore supports PrivateKeyEntry and TrustedCertficateEntry.
 123  * PKCS#12 is mainly used to deliver private keys with their associated
 124  * certificate chain and aliases. In a PKCS12 keystore, entries are
 125  * identified by the alias, and a localKeyId is required to match the
 126  * private key with the certificate. Trusted certificate entries are identified
 127  * by the presence of an trustedKeyUsage attribute.
 128  *
 129  * @author Seema Malkani
 130  * @author Jeff Nisewanger
 131  * @author Jan Luehe
 132  *
 133  * @see java.security.KeyStoreSpi
 134  */
 135 public final class PKCS12KeyStore extends KeyStoreSpi {
 136 
 137     // special PKCS12 keystore that supports PKCS12 and JKS file formats
 138     public static final class DualFormatPKCS12 extends KeyStoreDelegator {
 139         public DualFormatPKCS12() {
 140             super(&quot;PKCS12&quot;, PKCS12KeyStore.class, &quot;JKS&quot;, JKS.class);
 141         }
 142     }
 143 
 144     public static final int VERSION_3 = 3;
 145 
 146     private static final int MAX_ITERATION_COUNT = 5000000;
 147     private static final int SALT_LEN = 20;
 148 
 149     // friendlyName, localKeyId, trustedKeyUsage
 150     private static final String[] CORE_ATTRIBUTES = {
 151         &quot;1.2.840.113549.1.9.20&quot;,
 152         &quot;1.2.840.113549.1.9.21&quot;,
 153         &quot;2.16.840.1.113894.746875.1.1&quot;
 154     };
 155 
 156     private static final Debug debug = Debug.getInstance(&quot;pkcs12&quot;);
 157 
<a name="3" id="anc3"></a><span class="line-modified"> 158     private static final int[] keyBag  = {1, 2, 840, 113549, 1, 12, 10, 1, 2};</span>
<span class="line-modified"> 159     private static final int[] certBag = {1, 2, 840, 113549, 1, 12, 10, 1, 3};</span>
<span class="line-modified"> 160     private static final int[] secretBag = {1, 2, 840, 113549, 1, 12, 10, 1, 5};</span>
<span class="line-modified"> 161 </span>
<span class="line-modified"> 162     private static final int[] pkcs9Name  = {1, 2, 840, 113549, 1, 9, 20};</span>
<span class="line-modified"> 163     private static final int[] pkcs9KeyId = {1, 2, 840, 113549, 1, 9, 21};</span>








 164 
<a name="4" id="anc4"></a><span class="line-removed"> 165     private static final int[] pkcs9certType = {1, 2, 840, 113549, 1, 9, 22, 1};</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167     private static final int[] pbes2 = {1, 2, 840, 113549, 1, 5, 13};</span>
<span class="line-removed"> 168     // TODO: temporary Oracle OID</span>
 169     /*
<a name="5" id="anc5"></a><span class="line-modified"> 170      * { joint-iso-itu-t(2) country(16) us(840) organization(1) oracle(113894)</span>
<span class="line-modified"> 171      *   jdk(746875) crypto(1) id-at-trustedKeyUsage(1) }</span>


 172      */
<a name="6" id="anc6"></a><span class="line-modified"> 173     private static final int[] TrustedKeyUsage =</span>
<span class="line-modified"> 174                                         {2, 16, 840, 1, 113894, 746875, 1, 1};</span>
<span class="line-modified"> 175     private static final int[] AnyExtendedKeyUsage = {2, 5, 29, 37, 0};</span>
<span class="line-modified"> 176 </span>
<span class="line-modified"> 177     private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID;</span>
<span class="line-modified"> 178     private static final ObjectIdentifier CertBag_OID;</span>
<span class="line-modified"> 179     private static final ObjectIdentifier SecretBag_OID;</span>
<span class="line-removed"> 180     private static final ObjectIdentifier PKCS9FriendlyName_OID;</span>
<span class="line-removed"> 181     private static final ObjectIdentifier PKCS9LocalKeyId_OID;</span>
<span class="line-removed"> 182     private static final ObjectIdentifier PKCS9CertType_OID;</span>
<span class="line-removed"> 183     private static final ObjectIdentifier pbes2_OID;</span>
<span class="line-removed"> 184     private static final ObjectIdentifier TrustedKeyUsage_OID;</span>
<span class="line-removed"> 185     private static final ObjectIdentifier[] AnyUsage;</span>
 186 
 187     private int counter = 0;
 188 
 189     // private key count
 190     // Note: This is a workaround to allow null localKeyID attribute
 191     // in pkcs12 with one private key entry and associated cert-chain
 192     private int privateKeyCount = 0;
 193 
 194     // secret key count
 195     private int secretKeyCount = 0;
 196 
 197     // certificate count
 198     private int certificateCount = 0;
 199 
 200     // Alg/params used for *this* keystore. Initialized as -1 for ic and
 201     // null for algorithm names. When an existing file is read, they will be
 202     // assigned inside engineLoad() so storing an existing keystore uses the
 203     // old alg/params. This makes sure if a keystore is created password-less
 204     // it will be password-less forever. Otherwise, engineStore() will read
 205     // the default values. These fields are always reset when load() is called.
 206     private String certProtectionAlgorithm = null;
 207     private int certPbeIterationCount = -1;
 208     private String macAlgorithm = null;
 209     private int macIterationCount = -1;
 210 
 211     // the source of randomness
 212     private SecureRandom random;
 213 
<a name="7" id="anc7"></a><span class="line-removed"> 214     static {</span>
<span class="line-removed"> 215         try {</span>
<span class="line-removed"> 216             PKCS8ShroudedKeyBag_OID = new ObjectIdentifier(keyBag);</span>
<span class="line-removed"> 217             CertBag_OID = new ObjectIdentifier(certBag);</span>
<span class="line-removed"> 218             SecretBag_OID = new ObjectIdentifier(secretBag);</span>
<span class="line-removed"> 219             PKCS9FriendlyName_OID = new ObjectIdentifier(pkcs9Name);</span>
<span class="line-removed"> 220             PKCS9LocalKeyId_OID = new ObjectIdentifier(pkcs9KeyId);</span>
<span class="line-removed"> 221             PKCS9CertType_OID = new ObjectIdentifier(pkcs9certType);</span>
<span class="line-removed"> 222             pbes2_OID = new ObjectIdentifier(pbes2);</span>
<span class="line-removed"> 223             TrustedKeyUsage_OID = new ObjectIdentifier(TrustedKeyUsage);</span>
<span class="line-removed"> 224             AnyUsage = new ObjectIdentifier[]{</span>
<span class="line-removed"> 225                 new ObjectIdentifier(AnyExtendedKeyUsage)};</span>
<span class="line-removed"> 226         } catch (IOException ioe) {</span>
<span class="line-removed"> 227             throw new AssertionError(&quot;OID not initialized&quot;, ioe);</span>
<span class="line-removed"> 228         }</span>
<span class="line-removed"> 229     }</span>
<span class="line-removed"> 230 </span>
 231     // A keystore entry and associated attributes
 232     private static class Entry {
 233         Date date; // the creation date of this entry
 234         String alias;
 235         byte[] keyId;
 236         Set&lt;KeyStore.Entry.Attribute&gt; attributes;
 237     }
 238 
 239     // A key entry
 240     private static class KeyEntry extends Entry {
 241     }
 242 
 243     // A private key entry and its supporting certificate chain
 244     private static class PrivateKeyEntry extends KeyEntry {
 245         byte[] protectedPrivKey;
 246         Certificate[] chain;
 247     };
 248 
 249     // A secret key
 250     private static class SecretKeyEntry extends KeyEntry {
 251         byte[] protectedSecretKey;
 252     };
 253 
 254     // A certificate entry
 255     private static class CertEntry extends Entry {
 256         final X509Certificate cert;
 257         ObjectIdentifier[] trustedKeyUsage;
 258 
 259         CertEntry(X509Certificate cert, byte[] keyId, String alias) {
 260             this(cert, keyId, alias, null, null);
 261         }
 262 
 263         CertEntry(X509Certificate cert, byte[] keyId, String alias,
 264                 ObjectIdentifier[] trustedKeyUsage,
 265                 Set&lt;? extends KeyStore.Entry.Attribute&gt; attributes) {
 266             this.date = new Date();
 267             this.cert = cert;
 268             this.keyId = keyId;
 269             this.alias = alias;
 270             this.trustedKeyUsage = trustedKeyUsage;
 271             this.attributes = new HashSet&lt;&gt;();
 272             if (attributes != null) {
 273                 this.attributes.addAll(attributes);
 274             }
 275         }
 276     }
 277 
 278     /**
 279      * Retries an action with password &quot;\0&quot; if &quot;&quot; fails.
 280      * @param &lt;T&gt; the return type
 281      */
 282     @FunctionalInterface
 283     private interface RetryWithZero&lt;T&gt; {
 284 
 285         T tryOnce(char[] password) throws Exception;
 286 
 287         static &lt;S&gt; S run(RetryWithZero&lt;S&gt; f, char[] password) throws Exception {
 288             try {
 289                 return f.tryOnce(password);
 290             } catch (Exception e) {
 291                 if (password.length == 0) {
 292                     // Retry using an empty password with a NUL terminator.
 293                     if (debug != null) {
 294                         debug.println(&quot;Retry with a NUL password&quot;);
 295                     }
 296                     return f.tryOnce(new char[1]);
 297                 }
 298                 throw e;
 299             }
 300         }
 301     }
 302 
 303     /**
 304      * Private keys and certificates are stored in a map.
 305      * Map entries are keyed by alias names.
 306      */
 307     private Map&lt;String, Entry&gt; entries =
 308         Collections.synchronizedMap(new LinkedHashMap&lt;String, Entry&gt;());
 309 
 310     private ArrayList&lt;KeyEntry&gt; keyList = new ArrayList&lt;KeyEntry&gt;();
 311     private List&lt;X509Certificate&gt; allCerts = new ArrayList&lt;&gt;();
 312     private ArrayList&lt;CertEntry&gt; certEntries = new ArrayList&lt;CertEntry&gt;();
 313 
 314     /**
 315      * Returns the key associated with the given alias, using the given
 316      * password to recover it.
 317      *
 318      * @param alias the alias name
 319      * @param password the password for recovering the key
 320      *
 321      * @return the requested key, or null if the given alias does not exist
 322      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
 323      *
 324      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 325      * key cannot be found
 326      * @exception UnrecoverableKeyException if the key cannot be recovered
 327      * (e.g., the given password is wrong).
 328      */
 329     public Key engineGetKey(String alias, char[] password)
 330         throws NoSuchAlgorithmException, UnrecoverableKeyException
 331     {
 332         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 333         Key key = null;
 334 
 335         if (entry == null || (!(entry instanceof KeyEntry))) {
 336             return null;
 337         }
 338 
 339         // get the encoded private key or secret key
 340         byte[] encrBytes = null;
 341         if (entry instanceof PrivateKeyEntry) {
 342             encrBytes = ((PrivateKeyEntry) entry).protectedPrivKey;
 343         } else if (entry instanceof SecretKeyEntry) {
 344             encrBytes = ((SecretKeyEntry) entry).protectedSecretKey;
 345         } else {
 346             throw new UnrecoverableKeyException(&quot;Error locating key&quot;);
 347         }
 348 
 349         byte[] encryptedKey;
 350         AlgorithmParameters algParams;
 351         ObjectIdentifier algOid;
 352 
 353         try {
 354             // get the encrypted private key
 355             EncryptedPrivateKeyInfo encrInfo =
 356                         new EncryptedPrivateKeyInfo(encrBytes);
 357             encryptedKey = encrInfo.getEncryptedData();
 358 
 359             // parse Algorithm parameters
 360             DerValue val = new DerValue(encrInfo.getAlgorithm().encode());
 361             DerInputStream in = val.toDerInputStream();
 362             algOid = in.getOID();
 363             algParams = parseAlgParameters(algOid, in);
 364 
 365         } catch (IOException ioe) {
 366             UnrecoverableKeyException uke =
 367                 new UnrecoverableKeyException(&quot;Private key not stored as &quot;
 368                                  + &quot;PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe);
 369             uke.initCause(ioe);
 370             throw uke;
 371         }
 372 
 373        try {
 374             PBEParameterSpec pbeSpec;
 375             int ic;
 376 
 377             if (algParams != null) {
 378                 try {
 379                     pbeSpec =
 380                         algParams.getParameterSpec(PBEParameterSpec.class);
 381                 } catch (InvalidParameterSpecException ipse) {
 382                     throw new IOException(&quot;Invalid PBE algorithm parameters&quot;);
 383                 }
 384                 ic = pbeSpec.getIterationCount();
 385 
 386                 if (ic &gt; MAX_ITERATION_COUNT) {
 387                     throw new IOException(&quot;key PBE iteration count too large&quot;);
 388                 }
 389             } else {
 390                 ic = 0;
 391             }
 392 
 393             key = RetryWithZero.run(pass -&gt; {
 394                 // Use JCE
 395                 SecretKey skey = getPBEKey(pass);
 396                 Cipher cipher = Cipher.getInstance(
 397                         mapPBEParamsToAlgorithm(algOid, algParams));
 398                 cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
 399                 byte[] keyInfo = cipher.doFinal(encryptedKey);
 400                 /*
 401                  * Parse the key algorithm and then use a JCA key factory
 402                  * to re-create the key.
 403                  */
 404                 DerValue val = new DerValue(keyInfo);
 405                 DerInputStream in = val.toDerInputStream();
 406                 int i = in.getInteger();
 407                 DerValue[] value = in.getSequence(2);
 408                 AlgorithmId algId = new AlgorithmId(value[0].getOID());
 409                 String keyAlgo = algId.getName();
 410 
 411                 // decode private key
 412                 if (entry instanceof PrivateKeyEntry) {
 413                     KeyFactory kfac = KeyFactory.getInstance(keyAlgo);
 414                     PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(keyInfo);
 415                     Key tmp = kfac.generatePrivate(kspec);
 416 
 417                     if (debug != null) {
 418                         debug.println(&quot;Retrieved a protected private key at alias&quot; +
 419                                 &quot; &#39;&quot; + alias + &quot;&#39; (&quot; +
 420                                 mapPBEParamsToAlgorithm(algOid, algParams) +
 421                                 &quot; iterations: &quot; + ic + &quot;)&quot;);
 422                     }
 423                     return tmp;
 424                     // decode secret key
 425                 } else {
 426                     byte[] keyBytes = in.getOctetString();
 427                     SecretKeySpec secretKeySpec =
 428                             new SecretKeySpec(keyBytes, keyAlgo);
 429 
 430                     // Special handling required for PBE: needs a PBEKeySpec
 431                     Key tmp;
 432                     if (keyAlgo.startsWith(&quot;PBE&quot;)) {
 433                         SecretKeyFactory sKeyFactory =
 434                                 SecretKeyFactory.getInstance(keyAlgo);
 435                         KeySpec pbeKeySpec =
 436                                 sKeyFactory.getKeySpec(secretKeySpec, PBEKeySpec.class);
 437                         tmp = sKeyFactory.generateSecret(pbeKeySpec);
 438                     } else {
 439                         tmp = secretKeySpec;
 440                     }
 441 
 442                     if (debug != null) {
 443                         debug.println(&quot;Retrieved a protected secret key at alias &quot; +
 444                                 &quot;&#39;&quot; + alias + &quot;&#39; (&quot; +
 445                                 mapPBEParamsToAlgorithm(algOid, algParams) +
 446                                 &quot; iterations: &quot; + ic + &quot;)&quot;);
 447                     }
 448                     return tmp;
 449                 }
 450             }, password);
 451 
 452         } catch (Exception e) {
 453             UnrecoverableKeyException uke =
 454                 new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
 455                                         e.getMessage());
 456             uke.initCause(e);
 457             throw uke;
 458         }
 459         return key;
 460     }
 461 
 462     /**
 463      * Returns the certificate chain associated with the given alias.
 464      *
 465      * @param alias the alias name
 466      *
 467      * @return the certificate chain (ordered with the user&#39;s certificate first
 468      * and the root certificate authority last), or null if the given alias
 469      * does not exist or does not contain a certificate chain (i.e., the given
 470      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
 471      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
 472      */
 473     public Certificate[] engineGetCertificateChain(String alias) {
 474         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 475         if (entry != null &amp;&amp; entry instanceof PrivateKeyEntry) {
 476             if (((PrivateKeyEntry) entry).chain == null) {
 477                 return null;
 478             } else {
 479 
 480                 if (debug != null) {
 481                     debug.println(&quot;Retrieved a &quot; +
 482                         ((PrivateKeyEntry) entry).chain.length +
 483                         &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 484                 }
 485 
 486                 return ((PrivateKeyEntry) entry).chain.clone();
 487             }
 488         } else {
 489             return null;
 490         }
 491     }
 492 
 493     /**
 494      * Returns the certificate associated with the given alias.
 495      *
 496      * &lt;p&gt;If the given alias name identifies a
 497      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
 498      * entry is returned. If the given alias name identifies a
 499      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
 500      * entry is returned, or null if that entry does not have a certificate
 501      * chain.
 502      *
 503      * @param alias the alias name
 504      *
 505      * @return the certificate, or null if the given alias does not exist or
 506      * does not contain a certificate.
 507      */
 508     public Certificate engineGetCertificate(String alias) {
 509         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 510         if (entry == null) {
 511             return null;
 512         }
 513         if (entry instanceof CertEntry &amp;&amp;
 514             ((CertEntry) entry).trustedKeyUsage != null) {
 515 
 516             if (debug != null) {
 517                 if (Arrays.equals(AnyUsage,
 518                     ((CertEntry) entry).trustedKeyUsage)) {
 519                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 520                         &quot;&#39; (trusted for any purpose)&quot;);
 521                 } else {
 522                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 523                         &quot;&#39; (trusted for limited purposes)&quot;);
 524                 }
 525             }
 526 
 527             return ((CertEntry) entry).cert;
 528 
 529         } else if (entry instanceof PrivateKeyEntry) {
 530             if (((PrivateKeyEntry) entry).chain == null) {
 531                 return null;
 532             } else {
 533 
 534                 if (debug != null) {
 535                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 536                         &quot;&#39;&quot;);
 537                 }
 538 
 539                 return ((PrivateKeyEntry) entry).chain[0];
 540             }
 541 
 542         } else {
 543             return null;
 544         }
 545     }
 546 
 547     /**
 548      * Returns the creation date of the entry identified by the given alias.
 549      *
 550      * @param alias the alias name
 551      *
 552      * @return the creation date of this entry, or null if the given alias does
 553      * not exist
 554      */
 555     public Date engineGetCreationDate(String alias) {
 556         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 557         if (entry != null) {
 558             return new Date(entry.date.getTime());
 559         } else {
 560             return null;
 561         }
 562     }
 563 
 564     /**
 565      * Assigns the given key to the given alias, protecting it with the given
 566      * password.
 567      *
 568      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 569      * it must be accompanied by a certificate chain certifying the
 570      * corresponding public key.
 571      *
 572      * &lt;p&gt;If the given alias already exists, the keystore information
 573      * associated with it is overridden by the given key (and possibly
 574      * certificate chain).
 575      *
 576      * @param alias the alias name
 577      * @param key the key to be associated with the alias
 578      * @param password the password to protect the key
 579      * @param chain the certificate chain for the corresponding public
 580      * key (only required if the given key is of type
 581      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 582      *
 583      * @exception KeyStoreException if the given key cannot be protected, or
 584      * this operation fails for some other reason
 585      */
 586     public synchronized void engineSetKeyEntry(String alias, Key key,
 587                         char[] password, Certificate[] chain)
 588         throws KeyStoreException
 589     {
 590         KeyStore.PasswordProtection passwordProtection =
 591             new KeyStore.PasswordProtection(password);
 592 
 593         try {
 594             setKeyEntry(alias, key, passwordProtection, chain, null);
 595 
 596         } finally {
 597             try {
 598                 passwordProtection.destroy();
 599             } catch (DestroyFailedException dfe) {
 600                 // ignore
 601             }
 602         }
 603     }
 604 
 605     /*
 606      * Sets a key entry (with attributes, when present)
 607      */
 608     private void setKeyEntry(String alias, Key key,
 609         KeyStore.PasswordProtection passwordProtection, Certificate[] chain,
 610         Set&lt;KeyStore.Entry.Attribute&gt; attributes)
 611             throws KeyStoreException
 612     {
 613         try {
 614             Entry entry;
 615 
 616             if (key instanceof PrivateKey) {
 617                 // Check that all the certs are X.509 certs
 618                 checkX509Certs(chain);
 619 
 620                 PrivateKeyEntry keyEntry = new PrivateKeyEntry();
 621                 keyEntry.date = new Date();
 622 
 623                 if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||
 624                     (key.getFormat().equals(&quot;PKCS8&quot;))) {
 625 
 626                     if (debug != null) {
 627                         debug.println(
 628                             &quot;Setting a protected private key at alias &#39;&quot; +
 629                             alias + &quot;&#39;&quot;);
 630                         }
 631 
 632                     // Encrypt the private key
 633                     keyEntry.protectedPrivKey =
 634                         encryptPrivateKey(key.getEncoded(), passwordProtection);
 635                 } else {
 636                     throw new KeyStoreException(&quot;Private key is not encoded&quot; +
 637                                 &quot;as PKCS#8&quot;);
 638                 }
 639 
 640                 // clone the chain
 641                 if (chain != null) {
 642                     // validate cert-chain
 643                     if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain)))
 644                        throw new KeyStoreException(&quot;Certificate chain is &quot; +
 645                                                 &quot;not valid&quot;);
 646                     keyEntry.chain = chain.clone();
 647                     certificateCount += chain.length;
 648 
 649                     if (debug != null) {
 650                         debug.println(&quot;Setting a &quot; + chain.length +
 651                             &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 652                     }
 653                 }
 654                 privateKeyCount++;
 655                 entry = keyEntry;
 656 
 657             } else if (key instanceof SecretKey) {
 658                 SecretKeyEntry keyEntry = new SecretKeyEntry();
 659                 keyEntry.date = new Date();
 660 
 661                 // Encode secret key in a PKCS#8
 662                 DerOutputStream pkcs8 = new DerOutputStream();
 663                 DerOutputStream secretKeyInfo = new DerOutputStream();
 664                 secretKeyInfo.putInteger(0);
 665                 AlgorithmId algId = AlgorithmId.get(key.getAlgorithm());
 666                 algId.encode(secretKeyInfo);
 667                 secretKeyInfo.putOctetString(key.getEncoded());
 668                 pkcs8.write(DerValue.tag_Sequence, secretKeyInfo);
 669 
 670                 // Encrypt the secret key (using same PBE as for private keys)
 671                 keyEntry.protectedSecretKey =
 672                     encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);
 673 
 674                 if (debug != null) {
 675                     debug.println(&quot;Setting a protected secret key at alias &#39;&quot; +
 676                         alias + &quot;&#39;&quot;);
 677                 }
 678                 secretKeyCount++;
 679                 entry = keyEntry;
 680 
 681             } else {
 682                 throw new KeyStoreException(&quot;Unsupported Key type&quot;);
 683             }
 684 
 685             entry.attributes = new HashSet&lt;&gt;();
 686             if (attributes != null) {
 687                 entry.attributes.addAll(attributes);
 688             }
 689             // set the keyId to current date
<a name="8" id="anc8"></a><span class="line-modified"> 690             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(&quot;UTF8&quot;);</span>
 691             // set the alias
 692             entry.alias = alias.toLowerCase(Locale.ENGLISH);
 693             // add the entry
 694             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 695 
<a name="9" id="anc9"></a>

 696         } catch (Exception nsae) {
 697             throw new KeyStoreException(&quot;Key protection&quot; +
 698                        &quot; algorithm not found: &quot; + nsae, nsae);
 699         }
 700     }
 701 
 702     /**
 703      * Assigns the given key (that has already been protected) to the given
 704      * alias.
 705      *
 706      * &lt;p&gt;If the protected key is of type
 707      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 708      * certificate chain certifying the corresponding public key. If the
 709      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 710      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 711      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 712      *
 713      * &lt;p&gt;If the given alias already exists, the keystore information
 714      * associated with it is overridden by the given key (and possibly
 715      * certificate chain).
 716      *
 717      * @param alias the alias name
 718      * @param key the key (in protected format) to be associated with the alias
 719      * @param chain the certificate chain for the corresponding public
 720      * key (only useful if the protected key is of type
 721      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 722      *
 723      * @exception KeyStoreException if this operation fails.
 724      */
 725     public synchronized void engineSetKeyEntry(String alias, byte[] key,
 726                                   Certificate[] chain)
 727         throws KeyStoreException
 728     {
 729         // Check that all the certs are X.509 certs
 730         checkX509Certs(chain);
 731 
 732         // Private key must be encoded as EncryptedPrivateKeyInfo
 733         // as defined in PKCS#8
 734         try {
 735             new EncryptedPrivateKeyInfo(key);
 736         } catch (IOException ioe) {
 737             throw new KeyStoreException(&quot;Private key is not stored&quot;
 738                     + &quot; as PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe, ioe);
 739         }
 740 
 741         PrivateKeyEntry entry = new PrivateKeyEntry();
 742         entry.date = new Date();
 743 
 744         if (debug != null) {
 745             debug.println(&quot;Setting a protected private key at alias &#39;&quot; +
 746                 alias + &quot;&#39;&quot;);
 747         }
 748 
<a name="10" id="anc10"></a><span class="line-modified"> 749         try {</span>
<span class="line-modified"> 750             // set the keyId to current date</span>
<span class="line-removed"> 751             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(&quot;UTF8&quot;);</span>
<span class="line-removed"> 752         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed"> 753             // Won&#39;t happen</span>
<span class="line-removed"> 754         }</span>
 755         // set the alias
 756         entry.alias = alias.toLowerCase(Locale.ENGLISH);
 757 
 758         entry.protectedPrivKey = key.clone();
 759         if (chain != null) {
 760             // validate cert-chain
 761             if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain))) {
 762                 throw new KeyStoreException(&quot;Certificate chain is &quot;
 763                         + &quot;not valid&quot;);
 764             }
 765             entry.chain = chain.clone();
 766             certificateCount += chain.length;
 767 
 768             if (debug != null) {
 769                 debug.println(&quot;Setting a &quot; + entry.chain.length +
 770                     &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 771             }
 772         }
 773 
 774         // add the entry
 775         privateKeyCount++;
 776         entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 777     }
 778 
 779 
 780     /*
 781      * Generate random salt
 782      */
 783     private byte[] getSalt()
 784     {
 785         // Generate a random salt.
 786         byte[] salt = new byte[SALT_LEN];
 787         if (random == null) {
 788            random = new SecureRandom();
 789         }
 790         random.nextBytes(salt);
 791         return salt;
 792     }
 793 
 794     /*
 795      * Generate PBE Algorithm Parameters
 796      */
 797     private AlgorithmParameters getPBEAlgorithmParameters(
 798             String algorithm, int iterationCount) throws IOException {
 799         AlgorithmParameters algParams = null;
 800 
 801         // create PBE parameters from salt and iteration count
 802         PBEParameterSpec paramSpec =
 803                 new PBEParameterSpec(getSalt(), iterationCount);
 804         try {
 805            algParams = AlgorithmParameters.getInstance(algorithm);
 806            algParams.init(paramSpec);
 807         } catch (Exception e) {
 808            throw new IOException(&quot;getPBEAlgorithmParameters failed: &quot; +
 809                                  e.getMessage(), e);
 810         }
 811         return algParams;
 812     }
 813 
 814     /*
 815      * parse Algorithm Parameters
 816      */
 817     private AlgorithmParameters parseAlgParameters(ObjectIdentifier algorithm,
 818         DerInputStream in) throws IOException
 819     {
 820         AlgorithmParameters algParams = null;
 821         try {
 822             DerValue params;
 823             if (in.available() == 0) {
 824                 params = null;
 825             } else {
 826                 params = in.getDerValue();
 827                 if (params.tag == DerValue.tag_Null) {
 828                    params = null;
 829                 }
 830             }
 831             if (params != null) {
 832                 if (algorithm.equals(pbes2_OID)) {
 833                     algParams = AlgorithmParameters.getInstance(&quot;PBES2&quot;);
 834                 } else {
 835                     algParams = AlgorithmParameters.getInstance(&quot;PBE&quot;);
 836                 }
 837                 algParams.init(params.toByteArray());
 838             }
 839         } catch (Exception e) {
 840            throw new IOException(&quot;parseAlgParameters failed: &quot; +
 841                                  e.getMessage(), e);
 842         }
 843         return algParams;
 844     }
 845 
 846     /*
 847      * Generate PBE key
 848      */
 849     private SecretKey getPBEKey(char[] password) throws IOException
 850     {
 851         SecretKey skey = null;
 852 
 853         try {
 854             PBEKeySpec keySpec = new PBEKeySpec(password);
 855             SecretKeyFactory skFac = SecretKeyFactory.getInstance(&quot;PBE&quot;);
 856             skey = skFac.generateSecret(keySpec);
 857             keySpec.clearPassword();
 858         } catch (Exception e) {
 859            throw new IOException(&quot;getSecretKey failed: &quot; +
 860                                  e.getMessage(), e);
 861         }
 862         return skey;
 863     }
 864 
 865     /*
 866      * Encrypt private key or secret key using Password-based encryption (PBE)
 867      * as defined in PKCS#5.
 868      *
 869      * NOTE: By default, pbeWithSHAAnd3-KeyTripleDES-CBC algorithmID is
 870      *       used to derive the key and IV.
 871      *
 872      * @return encrypted private key or secret key encoded as
 873      *         EncryptedPrivateKeyInfo
 874      */
 875     private byte[] encryptPrivateKey(byte[] data,
 876         KeyStore.PasswordProtection passwordProtection)
 877         throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException
 878     {
 879         byte[] key = null;
 880 
 881         try {
 882             String algorithm;
 883             AlgorithmParameters algParams;
 884             AlgorithmId algid;
 885 
 886             // Initialize PBE algorithm and parameters
 887             algorithm = passwordProtection.getProtectionAlgorithm();
 888             if (algorithm != null) {
 889                 AlgorithmParameterSpec algParamSpec =
 890                     passwordProtection.getProtectionParameters();
 891                 if (algParamSpec != null) {
 892                     algParams = AlgorithmParameters.getInstance(algorithm);
 893                     algParams.init(algParamSpec);
 894                 } else {
 895                     algParams = getPBEAlgorithmParameters(algorithm,
 896                             defaultKeyPbeIterationCount());
 897                 }
 898             } else {
 899                 // Check default key protection algorithm for PKCS12 keystores
 900                 algorithm = defaultKeyProtectionAlgorithm();
 901                 algParams = getPBEAlgorithmParameters(algorithm,
 902                         defaultKeyPbeIterationCount());
 903             }
 904 
 905             ObjectIdentifier pbeOID = mapPBEAlgorithmToOID(algorithm);
 906             if (pbeOID == null) {
 907                     throw new IOException(&quot;PBE algorithm &#39;&quot; + algorithm +
 908                         &quot; &#39;is not supported for key entry protection&quot;);
 909             }
 910 
 911             // Use JCE
 912             SecretKey skey = getPBEKey(passwordProtection.getPassword());
 913             Cipher cipher = Cipher.getInstance(algorithm);
 914             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
 915             byte[] encryptedKey = cipher.doFinal(data);
 916             algid = new AlgorithmId(pbeOID, cipher.getParameters());
 917 
 918             if (debug != null) {
 919                 debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +
 920                     &quot;)&quot;);
 921             }
 922 
 923             // wrap encrypted private key in EncryptedPrivateKeyInfo
 924             // as defined in PKCS#8
 925             EncryptedPrivateKeyInfo encrInfo =
 926                 new EncryptedPrivateKeyInfo(algid, encryptedKey);
 927             key = encrInfo.getEncoded();
 928         } catch (Exception e) {
 929             UnrecoverableKeyException uke =
 930                 new UnrecoverableKeyException(&quot;Encrypt Private Key failed: &quot;
 931                                                 + e.getMessage());
 932             uke.initCause(e);
 933             throw uke;
 934         }
 935 
 936         return key;
 937     }
 938 
 939     /*
 940      * Map a PBE algorithm name onto its object identifier
 941      */
 942     private static ObjectIdentifier mapPBEAlgorithmToOID(String algorithm)
 943         throws NoSuchAlgorithmException {
 944         // Check for PBES2 algorithms
 945         if (algorithm.toLowerCase(Locale.ENGLISH).startsWith(&quot;pbewithhmacsha&quot;)) {
 946             return pbes2_OID;
 947         }
 948         return AlgorithmId.get(algorithm).getOID();
 949     }
 950 
 951     /*
 952      * Map a PBE algorithm parameters onto its algorithm name
 953      */
 954     private static String mapPBEParamsToAlgorithm(ObjectIdentifier algorithm,
 955         AlgorithmParameters algParams) throws NoSuchAlgorithmException {
 956         // Check for PBES2 algorithms
 957         if (algorithm.equals(pbes2_OID) &amp;&amp; algParams != null) {
 958             return algParams.toString();
 959         }
 960         return new AlgorithmId(algorithm).getName();
 961     }
 962 
 963     /**
 964      * Assigns the given certificate to the given alias.
 965      *
 966      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
 967      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
 968      * overridden by the given certificate.
 969      *
 970      * @param alias the alias name
 971      * @param cert the certificate
 972      *
 973      * @exception KeyStoreException if the given alias already exists and does
 974      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation fails
 975      * for some other reason.
 976      */
 977     public synchronized void engineSetCertificateEntry(String alias,
 978         Certificate cert) throws KeyStoreException
 979     {
 980         setCertEntry(alias, cert, null);
 981     }
 982 
 983     /*
 984      * Sets a trusted cert entry (with attributes, when present)
 985      */
 986     private void setCertEntry(String alias, Certificate cert,
 987         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws KeyStoreException {
 988 
 989         // Check that the cert is an X.509 cert
 990         if (cert != null &amp;&amp; (!(cert instanceof X509Certificate))) {
 991             throw new KeyStoreException(
 992                 &quot;Only X.509 certificates are supported - rejecting class: &quot; +
 993                 cert.getClass().getName());
 994         }
 995 
 996         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 997         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
 998             throw new KeyStoreException(&quot;Cannot overwrite own certificate&quot;);
 999         }
1000 
1001         CertEntry certEntry =
1002             new CertEntry((X509Certificate) cert, null, alias, AnyUsage,
1003                 attributes);
1004         certificateCount++;
1005         entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
1006 
1007         if (debug != null) {
1008             debug.println(&quot;Setting a trusted certificate at alias &#39;&quot; + alias +
1009                 &quot;&#39;&quot;);
1010         }
1011     }
1012 
1013     /**
1014      * Deletes the entry identified by the given alias from this keystore.
1015      *
1016      * @param alias the alias name
1017      *
1018      * @exception KeyStoreException if the entry cannot be removed.
1019      */
1020     public synchronized void engineDeleteEntry(String alias)
1021         throws KeyStoreException
1022     {
1023         if (debug != null) {
1024             debug.println(&quot;Removing entry at alias &#39;&quot; + alias + &quot;&#39;&quot;);
1025         }
1026 
1027         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1028         if (entry instanceof PrivateKeyEntry) {
1029             PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;
1030             if (keyEntry.chain != null) {
1031                 certificateCount -= keyEntry.chain.length;
1032             }
1033             privateKeyCount--;
1034         } else if (entry instanceof CertEntry) {
1035             certificateCount--;
1036         } else if (entry instanceof SecretKeyEntry) {
1037             secretKeyCount--;
1038         }
1039         entries.remove(alias.toLowerCase(Locale.ENGLISH));
1040     }
1041 
1042     /**
1043      * Lists all the alias names of this keystore.
1044      *
1045      * @return enumeration of the alias names
1046      */
1047     public Enumeration&lt;String&gt; engineAliases() {
1048         return Collections.enumeration(entries.keySet());
1049     }
1050 
1051     /**
1052      * Checks if the given alias exists in this keystore.
1053      *
1054      * @param alias the alias name
1055      *
1056      * @return true if the alias exists, false otherwise
1057      */
1058     public boolean engineContainsAlias(String alias) {
1059         return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));
1060     }
1061 
1062     /**
1063      * Retrieves the number of entries in this keystore.
1064      *
1065      * @return the number of entries in this keystore
1066      */
1067     public int engineSize() {
1068         return entries.size();
1069     }
1070 
1071     /**
1072      * Returns true if the entry identified by the given alias is a
1073      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
1074      *
1075      * @return true if the entry identified by the given alias is a
1076      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
1077      */
1078     public boolean engineIsKeyEntry(String alias) {
1079         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1080         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
1081             return true;
1082         } else {
1083             return false;
1084         }
1085     }
1086 
1087     /**
1088      * Returns true if the entry identified by the given alias is a
1089      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
1090      *
1091      * @return true if the entry identified by the given alias is a
1092      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
1093      */
1094     public boolean engineIsCertificateEntry(String alias) {
1095         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1096         if (entry != null &amp;&amp; entry instanceof CertEntry &amp;&amp;
1097             ((CertEntry) entry).trustedKeyUsage != null) {
1098             return true;
1099         } else {
1100             return false;
1101         }
1102     }
1103 
1104     /**
1105      * Determines if the keystore {@code Entry} for the specified
1106      * {@code alias} is an instance or subclass of the specified
1107      * {@code entryClass}.
1108      *
1109      * @param alias the alias name
1110      * @param entryClass the entry class
1111      *
1112      * @return true if the keystore {@code Entry} for the specified
1113      *          {@code alias} is an instance or subclass of the
1114      *          specified {@code entryClass}, false otherwise
1115      *
1116      * @since 1.5
1117      */
1118     @Override
1119     public boolean
1120         engineEntryInstanceOf(String alias,
1121                               Class&lt;? extends KeyStore.Entry&gt; entryClass)
1122     {
1123         if (entryClass == KeyStore.TrustedCertificateEntry.class) {
1124             return engineIsCertificateEntry(alias);
1125         }
1126 
1127         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1128         if (entryClass == KeyStore.PrivateKeyEntry.class) {
1129             return (entry != null &amp;&amp; entry instanceof PrivateKeyEntry);
1130         }
1131         if (entryClass == KeyStore.SecretKeyEntry.class) {
1132             return (entry != null &amp;&amp; entry instanceof SecretKeyEntry);
1133         }
1134         return false;
1135     }
1136 
1137     /**
1138      * Returns the (alias) name of the first keystore entry whose certificate
1139      * matches the given certificate.
1140      *
1141      * &lt;p&gt;This method attempts to match the given certificate with each
1142      * keystore entry. If the entry being considered
1143      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
1144      * compared to that entry&#39;s certificate. If the entry being considered is
1145      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
1146      * element of that entry&#39;s certificate chain (if a chain exists).
1147      *
1148      * @param cert the certificate to match with.
1149      *
1150      * @return the (alias) name of the first entry with matching certificate,
1151      * or null if no such entry exists in this keystore.
1152      */
1153     public String engineGetCertificateAlias(Certificate cert) {
1154         Certificate certElem = null;
1155 
1156         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1157             String alias = e.nextElement();
1158             Entry entry = entries.get(alias);
1159             if (entry instanceof PrivateKeyEntry) {
1160                 if (((PrivateKeyEntry) entry).chain != null) {
1161                     certElem = ((PrivateKeyEntry) entry).chain[0];
1162                 }
1163             } else if (entry instanceof CertEntry &amp;&amp;
1164                     ((CertEntry) entry).trustedKeyUsage != null) {
1165                 certElem = ((CertEntry) entry).cert;
1166             } else {
1167                 continue;
1168             }
1169             if (certElem != null &amp;&amp; certElem.equals(cert)) {
1170                 return alias;
1171             }
1172         }
1173         return null;
1174     }
1175 
1176     /**
1177      * Stores this keystore to the given output stream, and protects its
1178      * integrity with the given password.
1179      *
1180      * @param stream the output stream to which this keystore is written.
1181      * @param password the password to generate the keystore integrity check
1182      *
1183      * @exception IOException if there was an I/O problem with data
1184      * @exception NoSuchAlgorithmException if the appropriate data integrity
1185      * algorithm could not be found
1186      * @exception CertificateException if any of the certificates included in
1187      * the keystore data could not be stored
1188      */
1189     public synchronized void engineStore(OutputStream stream, char[] password)
1190         throws IOException, NoSuchAlgorithmException, CertificateException
1191     {
1192 
1193         // -- Create PFX
1194         DerOutputStream pfx = new DerOutputStream();
1195 
1196         // PFX version (always write the latest version)
1197         DerOutputStream version = new DerOutputStream();
1198         version.putInteger(VERSION_3);
1199         byte[] pfxVersion = version.toByteArray();
1200         pfx.write(pfxVersion);
1201 
1202         // -- Create AuthSafe
1203         DerOutputStream authSafe = new DerOutputStream();
1204 
1205         // -- Create ContentInfos
1206         DerOutputStream authSafeContentInfo = new DerOutputStream();
1207 
1208         // -- create safeContent Data ContentInfo
1209         if (privateKeyCount &gt; 0 || secretKeyCount &gt; 0) {
1210 
1211             if (debug != null) {
1212                 debug.println(&quot;Storing &quot; + (privateKeyCount + secretKeyCount) +
1213                     &quot; protected key(s) in a PKCS#7 data&quot;);
1214             }
1215 
1216             byte[] safeContentData = createSafeContent();
1217             ContentInfo dataContentInfo = new ContentInfo(safeContentData);
1218             dataContentInfo.encode(authSafeContentInfo);
1219         }
1220 
1221         // -- create EncryptedContentInfo
1222         if (certificateCount &gt; 0) {
1223 
1224             if (certProtectionAlgorithm == null) {
1225                 certProtectionAlgorithm = defaultCertProtectionAlgorithm();
1226             }
1227             if (certPbeIterationCount &lt; 0) {
1228                 certPbeIterationCount = defaultCertPbeIterationCount();
1229             }
1230 
1231             if (debug != null) {
1232                 debug.println(&quot;Storing &quot; + certificateCount +
1233                     &quot; certificate(s) in a PKCS#7 encryptedData&quot;);
1234             }
1235 
1236             byte[] encrData = createEncryptedData(password);
1237             if (!certProtectionAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1238                 ContentInfo encrContentInfo =
1239                         new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,
1240                                 new DerValue(encrData));
1241                 encrContentInfo.encode(authSafeContentInfo);
1242             } else {
1243                 ContentInfo dataContentInfo = new ContentInfo(encrData);
1244                 dataContentInfo.encode(authSafeContentInfo);
1245             }
1246         }
1247 
1248         // wrap as SequenceOf ContentInfos
1249         DerOutputStream cInfo = new DerOutputStream();
1250         cInfo.write(DerValue.tag_SequenceOf, authSafeContentInfo);
1251         byte[] authenticatedSafe = cInfo.toByteArray();
1252 
1253         // Create Encapsulated ContentInfo
1254         ContentInfo contentInfo = new ContentInfo(authenticatedSafe);
1255         contentInfo.encode(authSafe);
1256         byte[] authSafeData = authSafe.toByteArray();
1257         pfx.write(authSafeData);
1258 
1259         // -- MAC
1260         if (macAlgorithm == null) {
1261             macAlgorithm = defaultMacAlgorithm();
1262         }
1263         if (macIterationCount &lt; 0) {
1264             macIterationCount = defaultMacIterationCount();
1265         }
1266         if (!macAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1267             byte[] macData = calculateMac(password, authenticatedSafe);
1268             pfx.write(macData);
1269         }
1270         // write PFX to output stream
1271         DerOutputStream pfxout = new DerOutputStream();
1272         pfxout.write(DerValue.tag_Sequence, pfx);
1273         byte[] pfxData = pfxout.toByteArray();
1274         stream.write(pfxData);
1275         stream.flush();
1276     }
1277 
1278     /**
1279      * Gets a &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias
1280      * with the specified protection parameter.
1281      *
1282      * @param alias get the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for this alias
1283      * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
1284      *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
1285      *          which may be &lt;code&gt;null&lt;/code&gt;
1286      *
1287      * @return the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias,
1288      *          or &lt;code&gt;null&lt;/code&gt; if there is no such entry
1289      *
1290      * @exception KeyStoreException if the operation failed
1291      * @exception NoSuchAlgorithmException if the algorithm for recovering the
1292      *          entry cannot be found
1293      * @exception UnrecoverableEntryException if the specified
1294      *          &lt;code&gt;protParam&lt;/code&gt; were insufficient or invalid
1295      * @exception UnrecoverableKeyException if the entry is a
1296      *          &lt;code&gt;PrivateKeyEntry&lt;/code&gt; or &lt;code&gt;SecretKeyEntry&lt;/code&gt;
1297      *          and the specified &lt;code&gt;protParam&lt;/code&gt; does not contain
1298      *          the information needed to recover the key (e.g. wrong password)
1299      *
1300      * @since 1.5
1301      */
1302     @Override
1303     public KeyStore.Entry engineGetEntry(String alias,
1304                         KeyStore.ProtectionParameter protParam)
1305                 throws KeyStoreException, NoSuchAlgorithmException,
1306                 UnrecoverableEntryException {
1307 
1308         if (!engineContainsAlias(alias)) {
1309             return null;
1310         }
1311 
1312         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1313         if (protParam == null) {
1314             if (engineIsCertificateEntry(alias)) {
1315                 if (entry instanceof CertEntry &amp;&amp;
1316                     ((CertEntry) entry).trustedKeyUsage != null) {
1317 
1318                     if (debug != null) {
1319                         debug.println(&quot;Retrieved a trusted certificate at &quot; +
1320                             &quot;alias &#39;&quot; + alias + &quot;&#39;&quot;);
1321                     }
1322 
1323                     return new KeyStore.TrustedCertificateEntry(
1324                         ((CertEntry)entry).cert, getAttributes(entry));
1325                 }
1326             } else {
1327                 throw new UnrecoverableKeyException
1328                         (&quot;requested entry requires a password&quot;);
1329             }
1330         }
1331 
1332         if (protParam instanceof KeyStore.PasswordProtection) {
1333             if (engineIsCertificateEntry(alias)) {
1334                 throw new UnsupportedOperationException
1335                     (&quot;trusted certificate entries are not password-protected&quot;);
1336             } else if (engineIsKeyEntry(alias)) {
1337                 KeyStore.PasswordProtection pp =
1338                         (KeyStore.PasswordProtection)protParam;
1339                 char[] password = pp.getPassword();
1340 
1341                 Key key = engineGetKey(alias, password);
1342                 if (key instanceof PrivateKey) {
1343                     Certificate[] chain = engineGetCertificateChain(alias);
1344 
1345                     return new KeyStore.PrivateKeyEntry((PrivateKey)key, chain,
1346                         getAttributes(entry));
1347 
1348                 } else if (key instanceof SecretKey) {
1349 
1350                     return new KeyStore.SecretKeyEntry((SecretKey)key,
1351                         getAttributes(entry));
1352                 }
1353             } else if (!engineIsKeyEntry(alias)) {
1354                 throw new UnsupportedOperationException
1355                     (&quot;untrusted certificate entries are not &quot; +
1356                         &quot;password-protected&quot;);
1357             }
1358         }
1359 
1360         throw new UnsupportedOperationException();
1361     }
1362 
1363     /**
1364      * Saves a &lt;code&gt;KeyStore.Entry&lt;/code&gt; under the specified alias.
1365      * The specified protection parameter is used to protect the
1366      * &lt;code&gt;Entry&lt;/code&gt;.
1367      *
1368      * &lt;p&gt; If an entry already exists for the specified alias,
1369      * it is overridden.
1370      *
1371      * @param alias save the &lt;code&gt;KeyStore.Entry&lt;/code&gt; under this alias
1372      * @param entry the &lt;code&gt;Entry&lt;/code&gt; to save
1373      * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
1374      *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
1375      *          which may be &lt;code&gt;null&lt;/code&gt;
1376      *
1377      * @exception KeyStoreException if this operation fails
1378      *
1379      * @since 1.5
1380      */
1381     @Override
1382     public synchronized void engineSetEntry(String alias, KeyStore.Entry entry,
1383         KeyStore.ProtectionParameter protParam) throws KeyStoreException {
1384 
1385         // get password
1386         if (protParam != null &amp;&amp;
1387             !(protParam instanceof KeyStore.PasswordProtection)) {
1388             throw new KeyStoreException(&quot;unsupported protection parameter&quot;);
1389         }
1390         KeyStore.PasswordProtection pProtect = null;
1391         if (protParam != null) {
1392             pProtect = (KeyStore.PasswordProtection)protParam;
1393         }
1394 
1395         // set entry
1396         if (entry instanceof KeyStore.TrustedCertificateEntry) {
1397             if (protParam != null &amp;&amp; pProtect.getPassword() != null) {
1398                 // pre-1.5 style setCertificateEntry did not allow password
1399                 throw new KeyStoreException
1400                     (&quot;trusted certificate entries are not password-protected&quot;);
1401             } else {
1402                 KeyStore.TrustedCertificateEntry tce =
1403                         (KeyStore.TrustedCertificateEntry)entry;
1404                 setCertEntry(alias, tce.getTrustedCertificate(),
1405                     tce.getAttributes());
1406 
1407                 return;
1408             }
1409         } else if (entry instanceof KeyStore.PrivateKeyEntry) {
1410             if (pProtect == null || pProtect.getPassword() == null) {
1411                 // pre-1.5 style setKeyEntry required password
1412                 throw new KeyStoreException
1413                     (&quot;non-null password required to create PrivateKeyEntry&quot;);
1414             } else {
1415                 KeyStore.PrivateKeyEntry pke = (KeyStore.PrivateKeyEntry)entry;
1416                 setKeyEntry(alias, pke.getPrivateKey(), pProtect,
1417                     pke.getCertificateChain(), pke.getAttributes());
1418 
1419                 return;
1420             }
1421         } else if (entry instanceof KeyStore.SecretKeyEntry) {
1422             if (pProtect == null || pProtect.getPassword() == null) {
1423                 // pre-1.5 style setKeyEntry required password
1424                 throw new KeyStoreException
1425                     (&quot;non-null password required to create SecretKeyEntry&quot;);
1426             } else {
1427                 KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;
1428                 setKeyEntry(alias, ske.getSecretKey(), pProtect,
1429                     (Certificate[])null, ske.getAttributes());
1430 
1431                 return;
1432             }
1433         }
1434 
1435         throw new KeyStoreException
1436                 (&quot;unsupported entry type: &quot; + entry.getClass().getName());
1437     }
1438 
1439     /*
1440      * Assemble the entry attributes
1441      */
1442     private Set&lt;KeyStore.Entry.Attribute&gt; getAttributes(Entry entry) {
1443 
1444         if (entry.attributes == null) {
1445             entry.attributes = new HashSet&lt;&gt;();
1446         }
1447 
1448         // friendlyName
1449         entry.attributes.add(new PKCS12Attribute(
1450             PKCS9FriendlyName_OID.toString(), entry.alias));
1451 
1452         // localKeyID
1453         byte[] keyIdValue = entry.keyId;
1454         if (keyIdValue != null) {
1455             entry.attributes.add(new PKCS12Attribute(
1456                 PKCS9LocalKeyId_OID.toString(), Debug.toString(keyIdValue)));
1457         }
1458 
1459         // trustedKeyUsage
1460         if (entry instanceof CertEntry) {
1461             ObjectIdentifier[] trustedKeyUsageValue =
1462                 ((CertEntry) entry).trustedKeyUsage;
1463             if (trustedKeyUsageValue != null) {
1464                 if (trustedKeyUsageValue.length == 1) { // omit brackets
1465                     entry.attributes.add(new PKCS12Attribute(
1466                         TrustedKeyUsage_OID.toString(),
1467                         trustedKeyUsageValue[0].toString()));
1468                 } else { // multi-valued
1469                     entry.attributes.add(new PKCS12Attribute(
1470                         TrustedKeyUsage_OID.toString(),
1471                         Arrays.toString(trustedKeyUsageValue)));
1472                 }
1473             }
1474         }
1475 
1476         return entry.attributes;
1477     }
1478 
1479     /*
1480      * Calculate MAC using HMAC algorithm (required for password integrity)
1481      *
1482      * Hash-based MAC algorithm combines secret key with message digest to
1483      * create a message authentication code (MAC)
1484      */
1485     private byte[] calculateMac(char[] passwd, byte[] data)
1486         throws IOException
1487     {
1488         byte[] mData = null;
1489         String algName = macAlgorithm.substring(7);
1490 
1491         try {
1492             // Generate a random salt.
1493             byte[] salt = getSalt();
1494 
1495             // generate MAC (MAC key is generated within JCE)
1496             Mac m = Mac.getInstance(macAlgorithm);
1497             PBEParameterSpec params =
1498                         new PBEParameterSpec(salt, macIterationCount);
1499             SecretKey key = getPBEKey(passwd);
1500             m.init(key, params);
1501             m.update(data);
1502             byte[] macResult = m.doFinal();
1503 
1504             // encode as MacData
1505             MacData macData = new MacData(algName, macResult, salt,
1506                     macIterationCount);
1507             DerOutputStream bytes = new DerOutputStream();
1508             bytes.write(macData.getEncoded());
1509             mData = bytes.toByteArray();
1510         } catch (Exception e) {
1511             throw new IOException(&quot;calculateMac failed: &quot; + e, e);
1512         }
1513         return mData;
1514     }
1515 
1516 
1517     /*
1518      * Validate Certificate Chain
1519      */
1520     private boolean validateChain(Certificate[] certChain)
1521     {
1522         for (int i = 0; i &lt; certChain.length-1; i++) {
1523             X500Principal issuerDN =
1524                 ((X509Certificate)certChain[i]).getIssuerX500Principal();
1525             X500Principal subjectDN =
1526                 ((X509Certificate)certChain[i+1]).getSubjectX500Principal();
1527             if (!(issuerDN.equals(subjectDN)))
1528                 return false;
1529         }
1530 
1531         // Check for loops in the chain. If there are repeated certs,
1532         // the Set of certs in the chain will contain fewer certs than
1533         // the chain
1534         Set&lt;Certificate&gt; set = new HashSet&lt;&gt;(Arrays.asList(certChain));
1535         return set.size() == certChain.length;
1536     }
1537 
1538     /*
1539      * Check that all the certificates are X.509 certificates
1540      */
1541     private static void checkX509Certs(Certificate[] certs)
1542             throws KeyStoreException {
1543         if (certs != null) {
1544             for (Certificate cert : certs) {
1545                 if (!(cert instanceof X509Certificate)) {
1546                     throw new KeyStoreException(
1547                         &quot;Only X.509 certificates are supported - &quot; +
1548                         &quot;rejecting class: &quot; + cert.getClass().getName());
1549                 }
1550             }
1551         }
1552     }
1553 
1554     /*
1555      * Create PKCS#12 Attributes, friendlyName, localKeyId and trustedKeyUsage.
1556      *
1557      * Although attributes are optional, they could be required.
1558      * For e.g. localKeyId attribute is required to match the
1559      * private key with the associated end-entity certificate.
1560      * The trustedKeyUsage attribute is used to denote a trusted certificate.
1561      *
1562      * PKCS8ShroudedKeyBags include unique localKeyID and friendlyName.
1563      * CertBags may or may not include attributes depending on the type
1564      * of Certificate. In end-entity certificates, localKeyID should be
1565      * unique, and the corresponding private key should have the same
1566      * localKeyID. For trusted CA certs in the cert-chain, localKeyID
1567      * attribute is not required, hence most vendors don&#39;t include it.
1568      * NSS/Netscape require it to be unique or null, where as IE/OpenSSL
1569      * ignore it.
1570      *
1571      * Here is a list of pkcs12 attribute values in CertBags.
1572      *
1573      * PKCS12 Attribute       NSS/Netscape    IE     OpenSSL    J2SE
1574      * --------------------------------------------------------------
1575      * LocalKeyId
1576      * (In EE cert only,
1577      *  NULL in CA certs)      true          true     true      true
1578      *
1579      * friendlyName            unique        same/    same/     unique
1580      *                                       unique   unique/
1581      *                                                null
1582      * trustedKeyUsage         -             -        -         true
1583      *
1584      * Note: OpenSSL adds friendlyName for end-entity cert only, and
1585      * removes the localKeyID and friendlyName for CA certs.
1586      * If the CertBag did not have a friendlyName, most vendors will
1587      * add it, and assign it to the DN of the cert.
1588      */
1589     private byte[] getBagAttributes(String alias, byte[] keyId,
1590         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
1591         return getBagAttributes(alias, keyId, null, attributes);
1592     }
1593 
1594     private byte[] getBagAttributes(String alias, byte[] keyId,
1595         ObjectIdentifier[] trustedUsage,
1596         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
1597 
1598         byte[] localKeyID = null;
1599         byte[] friendlyName = null;
1600         byte[] trustedKeyUsage = null;
1601 
1602         // return null if all three attributes are null
1603         if ((alias == null) &amp;&amp; (keyId == null) &amp;&amp; (trustedKeyUsage == null)) {
1604             return null;
1605         }
1606 
1607         // SafeBag Attributes
1608         DerOutputStream bagAttrs = new DerOutputStream();
1609 
1610         // Encode the friendlyname oid.
1611         if (alias != null) {
1612             DerOutputStream bagAttr1 = new DerOutputStream();
1613             bagAttr1.putOID(PKCS9FriendlyName_OID);
1614             DerOutputStream bagAttrContent1 = new DerOutputStream();
1615             DerOutputStream bagAttrValue1 = new DerOutputStream();
1616             bagAttrContent1.putBMPString(alias);
1617             bagAttr1.write(DerValue.tag_Set, bagAttrContent1);
1618             bagAttrValue1.write(DerValue.tag_Sequence, bagAttr1);
1619             friendlyName = bagAttrValue1.toByteArray();
1620         }
1621 
1622         // Encode the localkeyId oid.
1623         if (keyId != null) {
1624             DerOutputStream bagAttr2 = new DerOutputStream();
1625             bagAttr2.putOID(PKCS9LocalKeyId_OID);
1626             DerOutputStream bagAttrContent2 = new DerOutputStream();
1627             DerOutputStream bagAttrValue2 = new DerOutputStream();
1628             bagAttrContent2.putOctetString(keyId);
1629             bagAttr2.write(DerValue.tag_Set, bagAttrContent2);
1630             bagAttrValue2.write(DerValue.tag_Sequence, bagAttr2);
1631             localKeyID = bagAttrValue2.toByteArray();
1632         }
1633 
1634         // Encode the trustedKeyUsage oid.
1635         if (trustedUsage != null) {
1636             DerOutputStream bagAttr3 = new DerOutputStream();
1637             bagAttr3.putOID(TrustedKeyUsage_OID);
1638             DerOutputStream bagAttrContent3 = new DerOutputStream();
1639             DerOutputStream bagAttrValue3 = new DerOutputStream();
1640             for (ObjectIdentifier usage : trustedUsage) {
1641                 bagAttrContent3.putOID(usage);
1642             }
1643             bagAttr3.write(DerValue.tag_Set, bagAttrContent3);
1644             bagAttrValue3.write(DerValue.tag_Sequence, bagAttr3);
1645             trustedKeyUsage = bagAttrValue3.toByteArray();
1646         }
1647 
1648         DerOutputStream attrs = new DerOutputStream();
1649         if (friendlyName != null) {
1650             attrs.write(friendlyName);
1651         }
1652         if (localKeyID != null) {
1653             attrs.write(localKeyID);
1654         }
1655         if (trustedKeyUsage != null) {
1656             attrs.write(trustedKeyUsage);
1657         }
1658 
1659         if (attributes != null) {
1660             for (KeyStore.Entry.Attribute attribute : attributes) {
1661                 String attributeName = attribute.getName();
1662                 // skip friendlyName, localKeyId and trustedKeyUsage
1663                 if (CORE_ATTRIBUTES[0].equals(attributeName) ||
1664                     CORE_ATTRIBUTES[1].equals(attributeName) ||
1665                     CORE_ATTRIBUTES[2].equals(attributeName)) {
1666                     continue;
1667                 }
1668                 attrs.write(((PKCS12Attribute) attribute).getEncoded());
1669             }
1670         }
1671 
1672         bagAttrs.write(DerValue.tag_Set, attrs);
1673         return bagAttrs.toByteArray();
1674     }
1675 
1676     /*
1677      * Create EncryptedData content type, that contains EncryptedContentInfo.
1678      * Includes certificates in individual SafeBags of type CertBag.
1679      * Each CertBag may include pkcs12 attributes
1680      * (see comments in getBagAttributes)
1681      */
1682     private byte[] createEncryptedData(char[] password)
1683         throws CertificateException, IOException
1684     {
1685         DerOutputStream out = new DerOutputStream();
1686         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1687 
1688             String alias = e.nextElement();
1689             Entry entry = entries.get(alias);
1690 
1691             // certificate chain
1692             Certificate[] certs;
1693 
1694             if (entry instanceof PrivateKeyEntry) {
1695                 PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;
1696                 if (keyEntry.chain != null) {
1697                     certs = keyEntry.chain;
1698                 } else {
1699                     certs = new Certificate[0];
1700                 }
1701             } else if (entry instanceof CertEntry) {
1702                 certs = new Certificate[]{((CertEntry) entry).cert};
1703             } else {
1704                 certs = new Certificate[0];
1705             }
1706 
1707             for (int i = 0; i &lt; certs.length; i++) {
1708                 // create SafeBag of Type CertBag
1709                 DerOutputStream safeBag = new DerOutputStream();
1710                 safeBag.putOID(CertBag_OID);
1711 
1712                 // create a CertBag
1713                 DerOutputStream certBag = new DerOutputStream();
1714                 certBag.putOID(PKCS9CertType_OID);
1715 
1716                 // write encoded certs in a context-specific tag
1717                 DerOutputStream certValue = new DerOutputStream();
1718                 X509Certificate cert = (X509Certificate) certs[i];
1719                 certValue.putOctetString(cert.getEncoded());
1720                 certBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1721                                         true, (byte) 0), certValue);
1722 
1723                 // wrap CertBag in a Sequence
1724                 DerOutputStream certout = new DerOutputStream();
1725                 certout.write(DerValue.tag_Sequence, certBag);
1726                 byte[] certBagValue = certout.toByteArray();
1727 
1728                 // Wrap the CertBag encoding in a context-specific tag.
1729                 DerOutputStream bagValue = new DerOutputStream();
1730                 bagValue.write(certBagValue);
1731                 // write SafeBag Value
1732                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1733                                 true, (byte) 0), bagValue);
1734 
1735                 // write SafeBag Attributes
1736                 // All Certs should have a unique friendlyName.
1737                 // This change is made to meet NSS requirements.
1738                 byte[] bagAttrs = null;
1739                 if (i == 0) {
1740                     // Only End-Entity Cert should have a localKeyId.
1741                     if (entry instanceof KeyEntry) {
1742                         KeyEntry keyEntry = (KeyEntry) entry;
1743                         bagAttrs =
1744                             getBagAttributes(keyEntry.alias, keyEntry.keyId,
1745                                 keyEntry.attributes);
1746                     } else {
1747                         CertEntry certEntry = (CertEntry) entry;
1748                         bagAttrs =
1749                             getBagAttributes(certEntry.alias, certEntry.keyId,
1750                                 certEntry.trustedKeyUsage,
1751                                 certEntry.attributes);
1752                     }
1753                 } else {
1754                     // Trusted root CA certs and Intermediate CA certs do not
1755                     // need to have a localKeyId, and hence localKeyId is null
1756                     // This change is made to meet NSS/Netscape requirements.
1757                     // NSS pkcs12 library requires trusted CA certs in the
1758                     // certificate chain to have unique or null localKeyID.
1759                     // However, IE/OpenSSL do not impose this restriction.
1760                     bagAttrs = getBagAttributes(
1761                             cert.getSubjectX500Principal().getName(), null,
1762                             entry.attributes);
1763                 }
1764                 if (bagAttrs != null) {
1765                     safeBag.write(bagAttrs);
1766                 }
1767 
1768                 // wrap as Sequence
1769                 out.write(DerValue.tag_Sequence, safeBag);
1770             } // for cert-chain
1771         }
1772 
1773         // wrap as SequenceOf SafeBag
1774         DerOutputStream safeBagValue = new DerOutputStream();
1775         safeBagValue.write(DerValue.tag_SequenceOf, out);
1776         byte[] safeBagData = safeBagValue.toByteArray();
1777 
1778         // encrypt the content (EncryptedContentInfo)
1779         if (!certProtectionAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1780             byte[] encrContentInfo = encryptContent(safeBagData, password);
1781 
1782             // -- SEQUENCE of EncryptedData
1783             DerOutputStream encrData = new DerOutputStream();
1784             DerOutputStream encrDataContent = new DerOutputStream();
1785             encrData.putInteger(0);
1786             encrData.write(encrContentInfo);
1787             encrDataContent.write(DerValue.tag_Sequence, encrData);
1788             return encrDataContent.toByteArray();
1789         } else {
1790             return safeBagData;
1791         }
1792     }
1793 
1794     /*
1795      * Create SafeContent Data content type.
1796      * Includes encrypted secret key in a SafeBag of type SecretBag.
1797      * Includes encrypted private key in a SafeBag of type PKCS8ShroudedKeyBag.
1798      * Each PKCS8ShroudedKeyBag includes pkcs12 attributes
1799      * (see comments in getBagAttributes)
1800      */
1801     private byte[] createSafeContent()
1802         throws CertificateException, IOException {
1803 
1804         DerOutputStream out = new DerOutputStream();
1805         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1806 
1807             String alias = e.nextElement();
1808             Entry entry = entries.get(alias);
1809             if (entry == null || (!(entry instanceof KeyEntry))) {
1810                 continue;
1811             }
1812             DerOutputStream safeBag = new DerOutputStream();
1813             KeyEntry keyEntry = (KeyEntry) entry;
1814 
1815             // DER encode the private key
1816             if (keyEntry instanceof PrivateKeyEntry) {
1817                 // Create SafeBag of type pkcs8ShroudedKeyBag
1818                 safeBag.putOID(PKCS8ShroudedKeyBag_OID);
1819 
1820                 // get the encrypted private key
1821                 byte[] encrBytes = ((PrivateKeyEntry)keyEntry).protectedPrivKey;
1822                 EncryptedPrivateKeyInfo encrInfo = null;
1823                 try {
1824                     encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
1825 
1826                 } catch (IOException ioe) {
1827                     throw new IOException(&quot;Private key not stored as &quot;
1828                             + &quot;PKCS#8 EncryptedPrivateKeyInfo&quot;
1829                             + ioe.getMessage());
1830                 }
1831 
1832                 // Wrap the EncryptedPrivateKeyInfo in a context-specific tag.
1833                 DerOutputStream bagValue = new DerOutputStream();
1834                 bagValue.write(encrInfo.getEncoded());
1835                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1836                                 true, (byte) 0), bagValue);
1837 
1838             // DER encode the secret key
1839             } else if (keyEntry instanceof SecretKeyEntry) {
1840                 // Create SafeBag of type SecretBag
1841                 safeBag.putOID(SecretBag_OID);
1842 
1843                 // Create a SecretBag
1844                 DerOutputStream secretBag = new DerOutputStream();
1845                 secretBag.putOID(PKCS8ShroudedKeyBag_OID);
1846 
1847                 // Write secret key in a context-specific tag
1848                 DerOutputStream secretKeyValue = new DerOutputStream();
1849                 secretKeyValue.putOctetString(
1850                     ((SecretKeyEntry) keyEntry).protectedSecretKey);
1851                 secretBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1852                                         true, (byte) 0), secretKeyValue);
1853 
1854                 // Wrap SecretBag in a Sequence
1855                 DerOutputStream secretBagSeq = new DerOutputStream();
1856                 secretBagSeq.write(DerValue.tag_Sequence, secretBag);
1857                 byte[] secretBagValue = secretBagSeq.toByteArray();
1858 
1859                 // Wrap the secret bag in a context-specific tag.
1860                 DerOutputStream bagValue = new DerOutputStream();
1861                 bagValue.write(secretBagValue);
1862 
1863                 // Write SafeBag value
1864                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1865                                     true, (byte) 0), bagValue);
1866             } else {
1867                 continue; // skip this entry
1868             }
1869 
1870             // write SafeBag Attributes
1871             byte[] bagAttrs =
1872                 getBagAttributes(alias, entry.keyId, entry.attributes);
1873             safeBag.write(bagAttrs);
1874 
1875             // wrap as Sequence
1876             out.write(DerValue.tag_Sequence, safeBag);
1877         }
1878 
1879         // wrap as Sequence
1880         DerOutputStream safeBagValue = new DerOutputStream();
1881         safeBagValue.write(DerValue.tag_Sequence, out);
1882         return safeBagValue.toByteArray();
1883     }
1884 
1885 
1886     /*
1887      * Encrypt the contents using Password-based (PBE) encryption
1888      * as defined in PKCS #5.
1889      *
1890      * NOTE: Currently pbeWithSHAAnd40BiteRC2-CBC algorithmID is used
1891      *       to derive the key and IV.
1892      *
1893      * @return encrypted contents encoded as EncryptedContentInfo
1894      */
1895     private byte[] encryptContent(byte[] data, char[] password)
1896         throws IOException {
1897 
1898         byte[] encryptedData = null;
1899 
1900 
1901         try {
1902             // create AlgorithmParameters
1903             AlgorithmParameters algParams = getPBEAlgorithmParameters(
1904                     certProtectionAlgorithm, certPbeIterationCount);
1905             DerOutputStream bytes = new DerOutputStream();
1906 
1907             // Use JCE
1908             SecretKey skey = getPBEKey(password);
1909             Cipher cipher = Cipher.getInstance(certProtectionAlgorithm);
1910             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
1911             encryptedData = cipher.doFinal(data);
1912 
1913             AlgorithmId algId = new AlgorithmId(
1914                     mapPBEAlgorithmToOID(certProtectionAlgorithm),
1915                     cipher.getParameters());
1916                     // cipher.getParameters() now has IV
1917             algId.encode(bytes);
1918             byte[] encodedAlgId = bytes.toByteArray();
1919 
1920             if (debug != null) {
1921                 debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +
1922                         &quot;)&quot;);
1923             }
1924 
1925             // create EncryptedContentInfo
1926             DerOutputStream bytes2 = new DerOutputStream();
1927             bytes2.putOID(ContentInfo.DATA_OID);
1928             bytes2.write(encodedAlgId);
1929 
1930             // Wrap encrypted data in a context-specific tag.
1931             DerOutputStream tmpout2 = new DerOutputStream();
1932             tmpout2.putOctetString(encryptedData);
1933             bytes2.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
1934                     false, (byte) 0), tmpout2);
1935 
1936             // wrap EncryptedContentInfo in a Sequence
1937             DerOutputStream out = new DerOutputStream();
1938             out.write(DerValue.tag_Sequence, bytes2);
1939             return out.toByteArray();
1940         } catch (IOException ioe) {
1941             throw ioe;
1942         } catch (Exception e) {
1943             throw new IOException(&quot;Failed to encrypt&quot; +
1944                     &quot; safe contents entry: &quot; + e, e);
1945         }
1946     }
1947 
1948     /**
1949      * Loads the keystore from the given input stream.
1950      *
1951      * &lt;p&gt;If a password is given, it is used to check the integrity of the
1952      * keystore data. Otherwise, the integrity of the keystore is not checked.
1953      *
1954      * @param stream the input stream from which the keystore is loaded
1955      * @param password the (optional) password used to check the integrity of
1956      * the keystore.
1957      *
1958      * @exception IOException if there is an I/O or format problem with the
1959      * keystore data
1960      * @exception NoSuchAlgorithmException if the algorithm used to check
1961      * the integrity of the keystore cannot be found
1962      * @exception CertificateException if any of the certificates in the
1963      * keystore could not be loaded
1964      */
1965     public synchronized void engineLoad(InputStream stream, char[] password)
1966         throws IOException, NoSuchAlgorithmException, CertificateException
1967     {
1968 
1969         // Reset config when loading a different keystore.
1970         certProtectionAlgorithm = null;
1971         certPbeIterationCount = -1;
1972         macAlgorithm = null;
1973         macIterationCount = -1;
1974 
1975         if (stream == null)
1976            return;
1977 
1978         // reset the counter
1979         counter = 0;
1980 
1981         DerValue val = new DerValue(stream);
1982         DerInputStream s = val.toDerInputStream();
1983         int version = s.getInteger();
1984 
1985         if (version != VERSION_3) {
1986            throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);
1987         }
1988 
1989         entries.clear();
1990 
1991         /*
1992          * Read the authSafe.
1993          */
1994         byte[] authSafeData;
1995         ContentInfo authSafe = new ContentInfo(s);
1996         ObjectIdentifier contentType = authSafe.getContentType();
1997 
1998         if (contentType.equals(ContentInfo.DATA_OID)) {
1999            authSafeData = authSafe.getData();
2000         } else /* signed data */ {
2001            throw new IOException(&quot;public key protected PKCS12 not supported&quot;);
2002         }
2003 
2004         DerInputStream as = new DerInputStream(authSafeData);
2005         DerValue[] safeContentsArray = as.getSequence(2);
2006         int count = safeContentsArray.length;
2007 
2008         // reset the counters at the start
2009         privateKeyCount = 0;
2010         secretKeyCount = 0;
2011         certificateCount = 0;
2012 
2013         boolean seeEncBag = false;
2014 
2015         /*
2016          * Spin over the ContentInfos.
2017          */
2018         for (int i = 0; i &lt; count; i++) {
2019             ContentInfo safeContents;
2020             DerInputStream sci;
2021             byte[] eAlgId = null;
2022 
2023             sci = new DerInputStream(safeContentsArray[i].toByteArray());
2024             safeContents = new ContentInfo(sci);
2025             contentType = safeContents.getContentType();
2026             if (contentType.equals(ContentInfo.DATA_OID)) {
2027 
2028                 if (debug != null) {
2029                     debug.println(&quot;Loading PKCS#7 data&quot;);
2030                 }
2031 
2032                 loadSafeContents(new DerInputStream(safeContents.getData()));
2033             } else if (contentType.equals(ContentInfo.ENCRYPTED_DATA_OID)) {
2034                 if (password == null) {
2035 
2036                     if (debug != null) {
2037                         debug.println(&quot;Warning: skipping PKCS#7 encryptedData&quot; +
2038                             &quot; - no password was supplied&quot;);
2039                     }
2040                     // No password to decrypt ENCRYPTED_DATA_OID. *Skip it*.
2041                     // This means user will see a PrivateKeyEntry without
2042                     // certificates and a whole TrustedCertificateEntry will
2043                     // be lost. This is not a perfect solution but alternative
2044                     // solutions are more disruptive:
2045                     //
2046                     // We cannot just fail, since KeyStore.load(is, null)
2047                     // has been known to never fail because of a null password.
2048                     //
2049                     // We cannot just throw away the whole PrivateKeyEntry,
2050                     // this is too silent and no one will notice anything.
2051                     //
2052                     // We also cannot fail when getCertificate() on such a
2053                     // PrivateKeyEntry is called, since the method has not
2054                     // specified this behavior.
2055                     continue;
2056                 }
2057 
2058                 DerInputStream edi =
2059                                 safeContents.getContent().toDerInputStream();
2060                 int edVersion = edi.getInteger();
2061                 DerValue[] seq = edi.getSequence(2);
2062                 ObjectIdentifier edContentType = seq[0].getOID();
2063                 eAlgId = seq[1].toByteArray();
2064                 if (!seq[2].isContextSpecific((byte)0)) {
2065                    throw new IOException(&quot;encrypted content not present!&quot;);
2066                 }
2067                 byte newTag = DerValue.tag_OctetString;
2068                 if (seq[2].isConstructed())
2069                    newTag |= 0x20;
2070                 seq[2].resetTag(newTag);
2071                 byte[] rawData = seq[2].getOctetString();
2072 
2073                 // parse Algorithm parameters
2074                 DerInputStream in = seq[1].toDerInputStream();
2075                 ObjectIdentifier algOid = in.getOID();
2076                 AlgorithmParameters algParams = parseAlgParameters(algOid, in);
2077 
2078                 PBEParameterSpec pbeSpec;
2079                 int ic = 0;
2080 
2081                 if (algParams != null) {
2082                     try {
2083                         pbeSpec =
2084                             algParams.getParameterSpec(PBEParameterSpec.class);
2085                     } catch (InvalidParameterSpecException ipse) {
2086                         throw new IOException(
2087                             &quot;Invalid PBE algorithm parameters&quot;);
2088                     }
2089                     ic = pbeSpec.getIterationCount();
2090 
2091                     if (ic &gt; MAX_ITERATION_COUNT) {
2092                         throw new IOException(&quot;cert PBE iteration count too large&quot;);
2093                     }
2094 
2095                     certProtectionAlgorithm
2096                             = mapPBEParamsToAlgorithm(algOid, algParams);
2097                     certPbeIterationCount = ic;
2098                     seeEncBag = true;
2099                 }
2100 
2101                 if (debug != null) {
2102                     debug.println(&quot;Loading PKCS#7 encryptedData &quot; +
2103                         &quot;(&quot; + mapPBEParamsToAlgorithm(algOid, algParams) +
2104                         &quot; iterations: &quot; + ic + &quot;)&quot;);
2105                 }
2106 
2107                 try {
2108                     RetryWithZero.run(pass -&gt; {
2109                         // Use JCE
2110                         SecretKey skey = getPBEKey(pass);
2111                         Cipher cipher = Cipher.getInstance(
2112                                 mapPBEParamsToAlgorithm(algOid, algParams));
2113                         cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
2114                         loadSafeContents(new DerInputStream(cipher.doFinal(rawData)));
2115                         return null;
2116                     }, password);
2117                 } catch (Exception e) {
2118                     throw new IOException(&quot;keystore password was incorrect&quot;,
2119                             new UnrecoverableKeyException(
2120                                     &quot;failed to decrypt safe contents entry: &quot; + e));
2121                 }
2122             } else {
2123                 throw new IOException(&quot;public key protected PKCS12&quot; +
2124                                         &quot; not supported&quot;);
2125             }
2126         }
2127 
2128         // No ENCRYPTED_DATA_OID but see certificate. Must be passwordless.
2129         if (!seeEncBag &amp;&amp; certificateCount &gt; 0) {
2130             certProtectionAlgorithm = &quot;NONE&quot;;
2131         }
2132 
2133         // The MacData is optional.
2134         if (s.available() &gt; 0) {
2135             // If there is no password, we cannot fail. KeyStore.load(is, null)
2136             // has been known to never fail because of a null password.
2137             if (password != null) {
2138                 MacData macData = new MacData(s);
2139                 int ic = macData.getIterations();
2140 
2141                 try {
2142                     if (ic &gt; MAX_ITERATION_COUNT) {
2143                         throw new InvalidAlgorithmParameterException(
2144                                 &quot;MAC iteration count too large: &quot; + ic);
2145                     }
2146 
2147                     String algName =
2148                             macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);
2149 
2150                     // Change SHA-1 to SHA1
2151                     algName = algName.replace(&quot;-&quot;, &quot;&quot;);
2152 
2153                     macAlgorithm = &quot;HmacPBE&quot; + algName;
2154                     macIterationCount = ic;
2155 
2156                     // generate MAC (MAC key is created within JCE)
2157                     Mac m = Mac.getInstance(macAlgorithm);
2158                     PBEParameterSpec params =
2159                             new PBEParameterSpec(macData.getSalt(), ic);
2160 
2161                     RetryWithZero.run(pass -&gt; {
2162                         SecretKey key = getPBEKey(pass);
2163                         m.init(key, params);
2164                         m.update(authSafeData);
2165                         byte[] macResult = m.doFinal();
2166 
2167                         if (debug != null) {
2168                             debug.println(&quot;Checking keystore integrity &quot; +
2169                                     &quot;(&quot; + m.getAlgorithm() + &quot; iterations: &quot; + ic + &quot;)&quot;);
2170                         }
2171 
2172                         if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {
2173                             throw new UnrecoverableKeyException(&quot;Failed PKCS12&quot; +
2174                                     &quot; integrity checking&quot;);
2175                         }
2176                         return (Void) null;
2177                     }, password);
2178                 } catch (Exception e) {
2179                     throw new IOException(&quot;Integrity check failed: &quot; + e, e);
2180                 }
2181             }
2182         } else {
2183             macAlgorithm = &quot;NONE&quot;;
2184         }
2185 
2186         /*
2187          * Match up private keys with certificate chains.
2188          */
2189         PrivateKeyEntry[] list =
2190             keyList.toArray(new PrivateKeyEntry[keyList.size()]);
2191         for (int m = 0; m &lt; list.length; m++) {
2192             PrivateKeyEntry entry = list[m];
2193             if (entry.keyId != null) {
2194                 ArrayList&lt;X509Certificate&gt; chain =
2195                                 new ArrayList&lt;X509Certificate&gt;();
2196                 X509Certificate cert = findMatchedCertificate(entry);
2197 
2198                 mainloop:
2199                 while (cert != null) {
2200                     // Check for loops in the certificate chain
2201                     if (!chain.isEmpty()) {
2202                         for (X509Certificate chainCert : chain) {
2203                             if (cert.equals(chainCert)) {
2204                                 if (debug != null) {
2205                                     debug.println(&quot;Loop detected in &quot; +
2206                                         &quot;certificate chain. Skip adding &quot; +
2207                                         &quot;repeated cert to chain. Subject: &quot; +
2208                                         cert.getSubjectX500Principal()
2209                                             .toString());
2210                                 }
2211                                 break mainloop;
2212                             }
2213                         }
2214                     }
2215                     chain.add(cert);
2216                     if (KeyStoreUtil.isSelfSigned(cert)) {
2217                         break;
2218                     }
2219                     cert = findIssuer(cert);
2220                 }
2221                 /* Update existing KeyEntry in entries table */
2222                 if (chain.size() &gt; 0) {
2223                     entry.chain = chain.toArray(new Certificate[chain.size()]);
2224                 } else {
2225                     // Remove private key entries where there is no associated
2226                     // certs. Most likely the keystore is loaded with a null
2227                     // password.
2228                     entries.remove(entry);
2229                 }
2230             }
2231         }
2232 
2233         if (debug != null) {
2234             debug.println(&quot;PKCS12KeyStore load: private key count: &quot; +
2235                     privateKeyCount + &quot;. secret key count: &quot; + secretKeyCount +
2236                     &quot;. certificate count: &quot; + certificateCount);
2237         }
2238 
2239         certEntries.clear();
2240         allCerts.clear();
2241         keyList.clear();
2242     }
2243 
2244     /**
2245      * Find the issuer of input in allCerts. If the input has an
2246      * AuthorityKeyIdentifier extension and the keyId inside matches
2247      * the keyId of the SubjectKeyIdentifier of a cert. This cert is
2248      * returned. Otherwise, a cert whose subjectDN is the same as the
2249      * input&#39;s issuerDN is returned.
2250      *
2251      * @param input the input certificate
2252      * @return the isssuer, or null if none matches
2253      */
2254     private X509Certificate findIssuer(X509Certificate input) {
2255 
2256         X509Certificate fallback = null; // the DN match
2257         X500Principal issuerPrinc = input.getIssuerX500Principal();
2258 
2259         // AuthorityKeyIdentifier value encoded as an OCTET STRING
2260         byte[] issuerIdExtension = input.getExtensionValue(&quot;2.5.29.35&quot;);
2261         byte[] issuerId = null;
2262 
2263         if (issuerIdExtension != null) {
2264             try {
2265                 issuerId = new AuthorityKeyIdentifierExtension(
2266                             false,
2267                             new DerValue(issuerIdExtension).getOctetString())
2268                         .getEncodedKeyIdentifier();
2269             } catch (IOException e) {
2270                 // ignored. issuerId is still null
2271             }
2272         }
2273 
2274         for (X509Certificate cert : allCerts) {
2275             if (cert.getSubjectX500Principal().equals(issuerPrinc)) {
2276                 if (issuerId != null) {
2277                     // SubjectKeyIdentifier value encoded as an OCTET STRING
2278                     byte[] subjectIdExtension = cert.getExtensionValue(&quot;2.5.29.14&quot;);
2279                     byte[] subjectId = null;
2280                     if (subjectIdExtension != null) {
2281                         try {
2282                             subjectId = new DerValue(subjectIdExtension)
2283                                     .getOctetString();
2284                         } catch (IOException e) {
2285                             // ignored. issuerId is still null
2286                         }
2287                     }
2288                     if (subjectId != null) {
2289                         if (Arrays.equals(issuerId, subjectId)) {
2290                             // keyId exact match!
2291                             return cert;
2292                         } else {
2293                             // Different keyId. Not a fallback.
2294                             continue;
2295                         }
2296                     } else {
2297                         // A DN match with no subjectId
2298                         fallback = cert;
2299                     }
2300                 } else { // if there is no issuerId, return the 1st DN match
2301                     return cert;
2302                 }
2303             }
2304         }
2305         return fallback;
2306     }
2307 
2308     /**
2309      * Returns if a pkcs12 file is password-less. This means no cert is
2310      * encrypted and there is no Mac. Please note that the private key
2311      * can be encrypted.
2312      *
2313      * This is a simplified version of {@link #engineLoad} that only looks
2314      * at the ContentInfo types.
2315      *
2316      * @param f the pkcs12 file
2317      * @return if it&#39;s password-less
2318      * @throws IOException
2319      */
2320     public static boolean isPasswordless(File f) throws IOException {
2321 
2322         try (FileInputStream stream = new FileInputStream(f)) {
2323             DerValue val = new DerValue(stream);
2324             DerInputStream s = val.toDerInputStream();
2325 
2326             s.getInteger(); // skip version
2327 
2328             ContentInfo authSafe = new ContentInfo(s);
2329             DerInputStream as = new DerInputStream(authSafe.getData());
2330             for (DerValue seq : as.getSequence(2)) {
2331                 DerInputStream sci = new DerInputStream(seq.toByteArray());
2332                 ContentInfo safeContents = new ContentInfo(sci);
2333                 if (safeContents.getContentType()
2334                         .equals(ContentInfo.ENCRYPTED_DATA_OID)) {
2335                     // Certificate encrypted
2336                     return false;
2337                 }
2338             }
2339 
2340             if (s.available() &gt; 0) {
2341                 // The MacData exists.
2342                 return false;
2343             }
2344         }
2345         return true;
2346     }
2347 
2348     /**
2349      * Locates a matched CertEntry from certEntries, and returns its cert.
2350      * @param entry the KeyEntry to match
2351      * @return a certificate, null if not found
2352      */
2353     private X509Certificate findMatchedCertificate(PrivateKeyEntry entry) {
2354         CertEntry keyIdMatch = null;
2355         CertEntry aliasMatch = null;
2356         for (CertEntry ce: certEntries) {
2357             if (Arrays.equals(entry.keyId, ce.keyId)) {
2358                 keyIdMatch = ce;
2359                 if (entry.alias.equalsIgnoreCase(ce.alias)) {
2360                     // Full match!
2361                     return ce.cert;
2362                 }
2363             } else if (entry.alias.equalsIgnoreCase(ce.alias)) {
2364                 aliasMatch = ce;
2365             }
2366         }
2367         // keyId match first, for compatibility
2368         if (keyIdMatch != null) return keyIdMatch.cert;
2369         else if (aliasMatch != null) return aliasMatch.cert;
2370         else return null;
2371     }
2372 
2373     private void loadSafeContents(DerInputStream stream)
2374         throws IOException, NoSuchAlgorithmException, CertificateException
2375     {
2376         DerValue[] safeBags = stream.getSequence(2);
2377         int count = safeBags.length;
2378 
2379         /*
2380          * Spin over the SafeBags.
2381          */
2382         for (int i = 0; i &lt; count; i++) {
2383             ObjectIdentifier bagId;
2384             DerInputStream sbi;
2385             DerValue bagValue;
2386             Object bagItem = null;
2387 
2388             sbi = safeBags[i].toDerInputStream();
2389             bagId = sbi.getOID();
2390             bagValue = sbi.getDerValue();
2391             if (!bagValue.isContextSpecific((byte)0)) {
2392                 throw new IOException(&quot;unsupported PKCS12 bag value type &quot;
2393                                         + bagValue.tag);
2394             }
2395             bagValue = bagValue.data.getDerValue();
2396             if (bagId.equals(PKCS8ShroudedKeyBag_OID)) {
2397                 PrivateKeyEntry kEntry = new PrivateKeyEntry();
2398                 kEntry.protectedPrivKey = bagValue.toByteArray();
2399                 bagItem = kEntry;
2400                 privateKeyCount++;
2401             } else if (bagId.equals(CertBag_OID)) {
2402                 DerInputStream cs = new DerInputStream(bagValue.toByteArray());
2403                 DerValue[] certValues = cs.getSequence(2);
2404                 ObjectIdentifier certId = certValues[0].getOID();
2405                 if (!certValues[1].isContextSpecific((byte)0)) {
2406                     throw new IOException(&quot;unsupported PKCS12 cert value type &quot;
2407                                         + certValues[1].tag);
2408                 }
2409                 DerValue certValue = certValues[1].data.getDerValue();
2410                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X509&quot;);
2411                 X509Certificate cert;
2412                 cert = (X509Certificate)cf.generateCertificate
2413                         (new ByteArrayInputStream(certValue.getOctetString()));
2414                 bagItem = cert;
2415                 certificateCount++;
2416             } else if (bagId.equals(SecretBag_OID)) {
2417                 DerInputStream ss = new DerInputStream(bagValue.toByteArray());
2418                 DerValue[] secretValues = ss.getSequence(2);
2419                 ObjectIdentifier secretId = secretValues[0].getOID();
2420                 if (!secretValues[1].isContextSpecific((byte)0)) {
2421                     throw new IOException(
2422                         &quot;unsupported PKCS12 secret value type &quot;
2423                                         + secretValues[1].tag);
2424                 }
2425                 DerValue secretValue = secretValues[1].data.getDerValue();
2426                 SecretKeyEntry kEntry = new SecretKeyEntry();
2427                 kEntry.protectedSecretKey = secretValue.getOctetString();
2428                 bagItem = kEntry;
2429                 secretKeyCount++;
2430             } else {
2431 
2432                 if (debug != null) {
2433                     debug.println(&quot;Unsupported PKCS12 bag type: &quot; + bagId);
2434                 }
2435             }
2436 
2437             DerValue[] attrSet;
2438             try {
2439                 attrSet = sbi.getSet(3);
2440             } catch (IOException e) {
2441                 // entry does not have attributes
2442                 // Note: CA certs can have no attributes
2443                 // OpenSSL generates pkcs12 with no attr for CA certs.
2444                 attrSet = null;
2445             }
2446 
2447             String alias = null;
2448             byte[] keyId = null;
2449             ObjectIdentifier[] trustedKeyUsage = null;
2450             Set&lt;PKCS12Attribute&gt; attributes = new HashSet&lt;&gt;();
2451 
2452             if (attrSet != null) {
2453                 for (int j = 0; j &lt; attrSet.length; j++) {
2454                     byte[] encoded = attrSet[j].toByteArray();
2455                     DerInputStream as = new DerInputStream(encoded);
2456                     DerValue[] attrSeq = as.getSequence(2);
2457                     ObjectIdentifier attrId = attrSeq[0].getOID();
2458                     DerInputStream vs =
2459                         new DerInputStream(attrSeq[1].toByteArray());
2460                     DerValue[] valSet;
2461                     try {
2462                         valSet = vs.getSet(1);
2463                     } catch (IOException e) {
2464                         throw new IOException(&quot;Attribute &quot; + attrId +
2465                                 &quot; should have a value &quot; + e.getMessage());
2466                     }
2467                     if (attrId.equals(PKCS9FriendlyName_OID)) {
2468                         alias = valSet[0].getBMPString();
2469                     } else if (attrId.equals(PKCS9LocalKeyId_OID)) {
2470                         keyId = valSet[0].getOctetString();
2471                     } else if
2472                         (attrId.equals(TrustedKeyUsage_OID)) {
2473                         trustedKeyUsage = new ObjectIdentifier[valSet.length];
2474                         for (int k = 0; k &lt; valSet.length; k++) {
2475                             trustedKeyUsage[k] = valSet[k].getOID();
2476                         }
2477                     } else {
2478                         attributes.add(new PKCS12Attribute(encoded));
2479                     }
2480                 }
2481             }
2482 
2483             /*
2484              * As per PKCS12 v1.0 friendlyname (alias) and localKeyId (keyId)
2485              * are optional PKCS12 bagAttributes. But entries in the keyStore
2486              * are identified by their alias. Hence we need to have an
2487              * Unfriendlyname in the alias, if alias is null. The keyId
2488              * attribute is required to match the private key with the
2489              * certificate. If we get a bagItem of type KeyEntry with a
2490              * null keyId, we should skip it entirely.
2491              */
2492             if (bagItem instanceof KeyEntry) {
2493                 KeyEntry entry = (KeyEntry)bagItem;
2494 
2495                 if (keyId == null) {
2496                     if (bagItem instanceof PrivateKeyEntry) {
2497                        // Insert a localKeyID for the privateKey
2498                        // Note: This is a workaround to allow null localKeyID
2499                        // attribute in pkcs12 with one private key entry and
2500                        // associated cert-chain
2501                        if (privateKeyCount == 1) {
<a name="11" id="anc11"></a><span class="line-modified">2502                             keyId = &quot;01&quot;.getBytes(&quot;UTF8&quot;);</span>
2503                        } else {
2504                             continue;
2505                        }
2506                     } else {
2507                         // keyId in a SecretKeyEntry is not significant
<a name="12" id="anc12"></a><span class="line-modified">2508                         keyId = &quot;00&quot;.getBytes(&quot;UTF8&quot;);</span>
2509                     }
2510                 }
2511                 entry.keyId = keyId;
2512                 // restore date if it exists
<a name="13" id="anc13"></a><span class="line-modified">2513                 String keyIdStr = new String(keyId, &quot;UTF8&quot;);</span>
2514                 Date date = null;
2515                 if (keyIdStr.startsWith(&quot;Time &quot;)) {
2516                     try {
2517                         date = new Date(
2518                                 Long.parseLong(keyIdStr.substring(5)));
2519                     } catch (Exception e) {
2520                         date = null;
2521                     }
2522                 }
2523                 if (date == null) {
2524                     date = new Date();
2525                 }
2526                 entry.date = date;
2527 
2528                 if (bagItem instanceof PrivateKeyEntry) {
2529                     keyList.add((PrivateKeyEntry) entry);
2530                 }
2531                 if (entry.attributes == null) {
2532                     entry.attributes = new HashSet&lt;&gt;();
2533                 }
2534                 entry.attributes.addAll(attributes);
2535                 if (alias == null) {
2536                    alias = getUnfriendlyName();
2537                 }
2538                 entry.alias = alias;
2539                 entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
2540 
2541             } else if (bagItem instanceof X509Certificate) {
2542                 X509Certificate cert = (X509Certificate)bagItem;
2543                 // Insert a localKeyID for the corresponding cert
2544                 // Note: This is a workaround to allow null localKeyID
2545                 // attribute in pkcs12 with one private key entry and
2546                 // associated cert-chain
2547                 if ((keyId == null) &amp;&amp; (privateKeyCount == 1)) {
2548                     // insert localKeyID only for EE cert or self-signed cert
2549                     if (i == 0) {
<a name="14" id="anc14"></a><span class="line-modified">2550                         keyId = &quot;01&quot;.getBytes(&quot;UTF8&quot;);</span>
2551                     }
2552                 }
2553                 // Trusted certificate
2554                 if (trustedKeyUsage != null) {
2555                     if (alias == null) {
2556                         alias = getUnfriendlyName();
2557                     }
2558                     CertEntry certEntry =
2559                         new CertEntry(cert, keyId, alias, trustedKeyUsage,
2560                             attributes);
2561                     entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
2562                 } else {
2563                     certEntries.add(new CertEntry(cert, keyId, alias));
2564                 }
2565                 allCerts.add(cert);
2566             }
2567         }
2568     }
2569 
2570     private String getUnfriendlyName() {
2571         counter++;
2572         return (String.valueOf(counter));
2573     }
2574 
2575     /*
2576      * PKCS12 permitted first 24 bytes:
2577      *
2578      * 30 80 02 01 03 30 80 06 09 2A 86 48 86 F7 0D 01 07 01 A0 80 24 80 04 --
2579      * 30 82 -- -- 02 01 03 30 82 -- -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 8-
2580      * 30 -- 02 01 03 30 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 -- 04 -- -- --
2581      * 30 81 -- 02 01 03 30 81 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 81 -- 04
2582      * 30 82 -- -- 02 01 03 30 81 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 81 --
2583      * 30 83 -- -- -- 02 01 03 30 82 -- -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0
2584      * 30 83 -- -- -- 02 01 03 30 83 -- -- -- 06 09 2A 86 48 86 F7 0D 01 07 01
2585      * 30 84 -- -- -- -- 02 01 03 30 83 -- -- -- 06 09 2A 86 48 86 F7 0D 01 07
2586      * 30 84 -- -- -- -- 02 01 03 30 84 -- -- -- -- 06 09 2A 86 48 86 F7 0D 01
2587      */
2588 
2589     private static final long[][] PKCS12_HEADER_PATTERNS = {
2590         { 0x3080020103308006L, 0x092A864886F70D01L, 0x0701A08024800400L },
2591         { 0x3082000002010330L, 0x82000006092A8648L, 0x86F70D010701A080L },
2592         { 0x3000020103300006L, 0x092A864886F70D01L, 0x0701A00004000000L },
2593         { 0x3081000201033081L, 0x0006092A864886F7L, 0x0D010701A0810004L },
2594         { 0x3082000002010330L, 0x810006092A864886L, 0xF70D010701A08100L },
2595         { 0x3083000000020103L, 0x3082000006092A86L, 0x4886F70D010701A0L },
2596         { 0x3083000000020103L, 0x308300000006092AL, 0x864886F70D010701L },
2597         { 0x3084000000000201L, 0x0330830000000609L, 0x2A864886F70D0107L },
2598         { 0x3084000000000201L, 0x0330840000000006L, 0x092A864886F70D01L }
2599     };
2600 
2601     private static final long[][] PKCS12_HEADER_MASKS = {
2602         { 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFF00L },
2603         { 0xFFFF0000FFFFFFFFL, 0xFF0000FFFFFFFFFFL, 0xFFFFFFFFFFFFFFF0L },
2604         { 0xFF00FFFFFFFF00FFL, 0xFFFFFFFFFFFFFFFFL, 0xFFFFFF00FF000000L },
2605         { 0xFFFF00FFFFFFFFFFL, 0x00FFFFFFFFFFFFFFL, 0xFFFFFFFFFFFF00FFL },
2606         { 0xFFFF0000FFFFFFFFL, 0xFF00FFFFFFFFFFFFL, 0xFFFFFFFFFFFFFF00L },
2607         { 0xFFFF000000FFFFFFL, 0xFFFF0000FFFFFFFFL, 0xFFFFFFFFFFFFFFFFL },
2608         { 0xFFFF000000FFFFFFL, 0xFFFF000000FFFFFFL, 0xFFFFFFFFFFFFFFFFL },
2609         { 0xFFFF00000000FFFFL, 0xFFFFFF000000FFFFL, 0xFFFFFFFFFFFFFFFFL },
2610         { 0xFFFF00000000FFFFL, 0xFFFFFF00000000FFL, 0xFFFFFFFFFFFFFFFFL }
2611     };
2612 
2613     /**
2614      * Probe the first few bytes of the keystore data stream for a valid
2615      * PKCS12 keystore encoding.
2616      */
2617     @Override
2618     public boolean engineProbe(InputStream stream) throws IOException {
2619 
2620         DataInputStream dataStream;
2621         if (stream instanceof DataInputStream) {
2622             dataStream = (DataInputStream)stream;
2623         } else {
2624             dataStream = new DataInputStream(stream);
2625         }
2626 
2627         long firstPeek = dataStream.readLong();
2628         long nextPeek = dataStream.readLong();
2629         long finalPeek = dataStream.readLong();
2630         boolean result = false;
2631 
2632         for (int i = 0; i &lt; PKCS12_HEADER_PATTERNS.length; i++) {
2633             if (PKCS12_HEADER_PATTERNS[i][0] ==
2634                     (firstPeek &amp; PKCS12_HEADER_MASKS[i][0]) &amp;&amp;
2635                 (PKCS12_HEADER_PATTERNS[i][1] ==
2636                     (nextPeek &amp; PKCS12_HEADER_MASKS[i][1])) &amp;&amp;
2637                 (PKCS12_HEADER_PATTERNS[i][2] ==
2638                     (finalPeek &amp; PKCS12_HEADER_MASKS[i][2]))) {
2639                 result = true;
2640                 break;
2641             }
2642         }
2643 
2644         return result;
2645     }
2646 
2647     // 8076190: Customizing the generation of a PKCS12 keystore
2648 
2649     private static String defaultCertProtectionAlgorithm() {
2650         String result = SecurityProperties.privilegedGetOverridable(
2651                 &quot;keystore.pkcs12.certProtectionAlgorithm&quot;);
2652         return (result != null &amp;&amp; !result.isEmpty())
2653                 ? result : &quot;PBEWithSHA1AndRC2_40&quot;;
2654     }
2655 
2656     private static int defaultCertPbeIterationCount() {
2657         String result = SecurityProperties.privilegedGetOverridable(
2658                 &quot;keystore.pkcs12.certPbeIterationCount&quot;);
2659         return (result != null &amp;&amp; !result.isEmpty())
2660                 ? string2IC(&quot;certPbeIterationCount&quot;, result) : 50000;
2661     }
2662 
2663     // Read both &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
2664     // &quot;keystore.PKCS12.keyProtectionAlgorithm&quot; for compatibility.
2665     private static String defaultKeyProtectionAlgorithm() {
2666         String result = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
2667             public String run() {
2668                 String result;
2669                 String name1 = &quot;keystore.pkcs12.keyProtectionAlgorithm&quot;;
2670                 String name2 = &quot;keystore.PKCS12.keyProtectionAlgorithm&quot;;
2671                 result = System.getProperty(name1);
2672                 if (result != null) {
2673                     return result;
2674                 }
2675                 result = System.getProperty(name2);
2676                 if (result != null) {
2677                     return result;
2678                 }
2679                 result = Security.getProperty(name1);
2680                 if (result != null) {
2681                     return result;
2682                 }
2683                 return Security.getProperty(name2);
2684             }
2685         });
2686         return (result != null &amp;&amp; !result.isEmpty())
2687                 ? result : &quot;PBEWithSHA1AndDESede&quot;;
2688     }
2689 
2690     private static int defaultKeyPbeIterationCount() {
2691         String result = SecurityProperties.privilegedGetOverridable(
2692                 &quot;keystore.pkcs12.keyPbeIterationCount&quot;);
2693         return (result != null &amp;&amp; !result.isEmpty())
2694                 ? string2IC(&quot;keyPbeIterationCount&quot;, result) : 50000;
2695     }
2696 
2697     private static String defaultMacAlgorithm() {
2698         String result = SecurityProperties.privilegedGetOverridable(
2699                 &quot;keystore.pkcs12.macAlgorithm&quot;);
2700         return (result != null &amp;&amp; !result.isEmpty())
2701                 ? result : &quot;HmacPBESHA1&quot;;
2702     }
2703 
2704     private static int defaultMacIterationCount() {
2705         String result = SecurityProperties.privilegedGetOverridable(
2706                 &quot;keystore.pkcs12.macIterationCount&quot;);
2707         return (result != null &amp;&amp; !result.isEmpty())
2708                 ? string2IC(&quot;macIterationCount&quot;, result) : 100000;
2709     }
2710 
2711     private static int string2IC(String type, String value) {
2712         int number;
2713         try {
2714             number = Integer.parseInt(value);
2715         } catch (NumberFormatException e) {
2716             throw new IllegalArgumentException(&quot;keystore.pkcs12.&quot; + type
2717                     + &quot; is not a number: &quot; + value);
2718         }
2719         if (number &lt;= 0 || number &gt; MAX_ITERATION_COUNT) {
2720             throw new IllegalArgumentException(&quot;Invalid keystore.pkcs12.&quot;
2721                     + type + &quot;: &quot; + value);
2722         }
2723         return number;
2724     }
2725 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
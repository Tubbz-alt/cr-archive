<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
<a name="1" id="anc1"></a><span class="line-added">  27 import sun.security.x509.X509CertImpl;</span>
<span class="line-added">  28 </span>
<span class="line-added">  29 import java.io.IOException;</span>
<span class="line-added">  30 import java.lang.reflect.Array;</span>
  31 import java.math.BigInteger;
  32 import java.net.InetAddress;
<a name="2" id="anc2"></a><span class="line-added">  33 import java.nio.ByteBuffer;</span>
  34 import java.security.Principal;
  35 import java.security.PrivateKey;
  36 import java.security.cert.CertificateEncodingException;
  37 import java.security.cert.X509Certificate;
  38 import java.util.ArrayList;
<a name="3" id="anc3"></a><span class="line-added">  39 import java.util.Arrays;</span>
  40 import java.util.Queue;
  41 import java.util.Collection;
  42 import java.util.Collections;
  43 import java.util.Enumeration;
  44 import java.util.List;
<a name="4" id="anc4"></a>
  45 import java.util.concurrent.ConcurrentHashMap;
  46 import java.util.concurrent.ConcurrentLinkedQueue;
<a name="5" id="anc5"></a><span class="line-added">  47 import java.util.concurrent.locks.ReentrantLock;</span>
  48 import javax.crypto.SecretKey;
<a name="6" id="anc6"></a><span class="line-added">  49 import javax.crypto.spec.SecretKeySpec;</span>
  50 import javax.net.ssl.ExtendedSSLSession;
<a name="7" id="anc7"></a><span class="line-added">  51 import javax.net.ssl.SNIHostName;</span>
  52 import javax.net.ssl.SNIServerName;
<a name="8" id="anc8"></a><span class="line-added">  53 import javax.net.ssl.SSLException;</span>
  54 import javax.net.ssl.SSLPeerUnverifiedException;
  55 import javax.net.ssl.SSLPermission;
  56 import javax.net.ssl.SSLSessionBindingEvent;
  57 import javax.net.ssl.SSLSessionBindingListener;
  58 import javax.net.ssl.SSLSessionContext;
  59 
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
  74  * is associated with any given authentication context. &lt;/em&gt;
  75  *
  76  * @author David Brownell
  77  */
  78 final class SSLSessionImpl extends ExtendedSSLSession {
  79 
  80     /*
  81      * we only really need a single null session
  82      */
  83     static final SSLSessionImpl         nullSession = new SSLSessionImpl();
  84 
  85     /*
  86      * The state of a single session, as described in section 7.1
  87      * of the SSLv3 spec.
  88      */
  89     private final ProtocolVersion       protocolVersion;
  90     private final SessionId             sessionId;
  91     private X509Certificate[]   peerCerts;
  92     private CipherSuite         cipherSuite;
  93     private SecretKey           masterSecret;
  94     final boolean               useExtendedMasterSecret;
  95 
  96     /*
  97      * Information not part of the SSLv3 protocol spec, but used
  98      * to support session management policies.
  99      */
 100     private final long          creationTime;
 101     private long                lastUsedTime = 0;
 102     private final String        host;
 103     private final int           port;
 104     private SSLSessionContextImpl       context;
 105     private boolean             invalidated;
 106     private X509Certificate[]   localCerts;
 107     private PrivateKey          localPrivateKey;
 108     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
<a name="9" id="anc9"></a><span class="line-modified"> 109     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate</span>
 110     private boolean             useDefaultPeerSignAlgs = false;
 111     private List&lt;byte[]&gt;        statusResponses;
 112     private SecretKey           resumptionMasterSecret;
 113     private SecretKey           preSharedKey;
 114     private byte[]              pskIdentity;
 115     private final long          ticketCreationTime = System.currentTimeMillis();
 116     private int                 ticketAgeAdd;
 117 
 118     private int                 negotiatedMaxFragLen = -1;
 119     private int                 maximumPacketSize;
 120 
 121     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 122                                         new ConcurrentLinkedQueue&lt;&gt;();
 123 
 124     /*
 125      * Is the session currently re-established with a session-resumption
 126      * abbreviated initial handshake?
 127      *
 128      * Note that currently we only set this variable in client side.
 129      */
 130     private boolean isSessionResumption = false;
 131 
 132     /*
 133      * Use of session caches is globally enabled/disabled.
 134      */
 135     private static boolean      defaultRejoinable = true;
 136 
 137     // server name indication
 138     final SNIServerName         serverNameIndication;
 139     private final List&lt;SNIServerName&gt;    requestedServerNames;
 140 
 141     // Counter used to create unique nonces in NewSessionTicket
 142     private BigInteger ticketNonceCounter = BigInteger.ONE;
 143 
 144     // The endpoint identification algorithm used to check certificates
 145     // in this session.
<a name="10" id="anc10"></a><span class="line-modified"> 146     private final String        identificationProtocol;</span>
<span class="line-added"> 147 </span>
<span class="line-added"> 148     private final ReentrantLock sessionLock = new ReentrantLock();</span>
 149 
 150     /*
 151      * Create a new non-rejoinable session, using the default (null)
 152      * cipher spec.  This constructor returns a session which could
 153      * be used either by a client or by a server, as a connection is
 154      * first opened and before handshaking begins.
 155      */
 156     private SSLSessionImpl() {
 157         this.protocolVersion = ProtocolVersion.NONE;
 158         this.cipherSuite = CipherSuite.C_NULL;
 159         this.sessionId = new SessionId(false, null);
 160         this.host = null;
 161         this.port = -1;
 162         this.localSupportedSignAlgs = Collections.emptySet();
 163         this.serverNameIndication = null;
 164         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 165         this.useExtendedMasterSecret = false;
 166         this.creationTime = System.currentTimeMillis();
 167         this.identificationProtocol = null;
 168         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 169     }
 170 
 171     /*
 172      * Create a new session, using a given cipher spec.  This will
 173      * be rejoinable if session caching is enabled; the constructor
 174      * is intended mostly for use by serves.
 175      */
 176     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
 177         this(hc, cipherSuite,
 178             new SessionId(defaultRejoinable, hc.sslContext.getSecureRandom()));
 179     }
 180 
 181     /*
 182      * Record a new session, using a given cipher spec and session ID.
 183      */
 184     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite, SessionId id) {
 185         this(hc, cipherSuite, id, System.currentTimeMillis());
 186     }
 187 
 188     /*
 189      * Record a new session, using a given cipher spec, session ID,
 190      * and creation time.
 191      * Note: For the unmodifiable collections and lists we are creating new
 192      * collections as inputs to avoid potential deep nesting of
 193      * unmodifiable collections that can cause StackOverflowErrors
 194      * (see JDK-6323374).
 195      */
 196     SSLSessionImpl(HandshakeContext hc,
 197             CipherSuite cipherSuite, SessionId id, long creationTime) {
 198         this.protocolVersion = hc.negotiatedProtocol;
 199         this.cipherSuite = cipherSuite;
 200         this.sessionId = id;
 201         this.host = hc.conContext.transport.getPeerHost();
 202         this.port = hc.conContext.transport.getPeerPort();
 203         this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?
 204                 Collections.emptySet() :
 205                 Collections.unmodifiableCollection(
 206                         new ArrayList&lt;&gt;(hc.localSupportedSignAlgs));
 207         this.serverNameIndication = hc.negotiatedServerName;
 208         this.requestedServerNames = Collections.unmodifiableList(
 209                 new ArrayList&lt;&gt;(hc.getRequestedServerNames()));
 210         if (hc.sslConfig.isClientMode) {
 211             this.useExtendedMasterSecret =
 212                 (hc.handshakeExtensions.get(
 213                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 214                 (hc.handshakeExtensions.get(
 215                         SSLExtension.SH_EXTENDED_MASTER_SECRET) != null);
 216         } else {
 217             this.useExtendedMasterSecret =
 218                 (hc.handshakeExtensions.get(
 219                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 220                 (!hc.negotiatedProtocol.useTLS13PlusSpec());
 221         }
 222         this.creationTime = creationTime;
 223         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 224         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 225 
 226         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 227              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 228         }
 229     }
 230 
 231     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 232         this.protocolVersion = baseSession.getProtocolVersion();
 233         this.cipherSuite = baseSession.cipherSuite;
 234         this.sessionId = newId;
 235         this.host = baseSession.getPeerHost();
 236         this.port = baseSession.getPeerPort();
 237         this.localSupportedSignAlgs =
 238                 baseSession.localSupportedSignAlgs == null ?
 239                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 240         this.peerSupportedSignAlgs =
<a name="11" id="anc11"></a><span class="line-modified"> 241                 baseSession.peerSupportedSignAlgs == null ?</span>
<span class="line-added"> 242                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;</span>
 243         this.serverNameIndication = baseSession.serverNameIndication;
 244         this.requestedServerNames = baseSession.getRequestedServerNames();
 245         this.masterSecret = baseSession.getMasterSecret();
 246         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 247         this.creationTime = baseSession.getCreationTime();
 248         this.lastUsedTime = System.currentTimeMillis();
 249         this.identificationProtocol = baseSession.getIdentificationProtocol();
 250         this.localCerts = baseSession.localCerts;
 251         this.peerCerts = baseSession.peerCerts;
 252         this.statusResponses = baseSession.statusResponses;
 253         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 254         this.context = baseSession.context;
 255         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 256         this.maximumPacketSize = baseSession.maximumPacketSize;
 257         this.boundValues = baseSession.boundValues;
 258 
 259         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 260              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 261         }
 262     }
 263 
<a name="12" id="anc12"></a><span class="line-added"> 264     /**</span>
<span class="line-added"> 265      * &lt; 2 bytes &gt; protocolVersion</span>
<span class="line-added"> 266      * &lt; 2 bytes &gt; cipherSuite</span>
<span class="line-added"> 267      * &lt; 1 byte &gt; localSupportedSignAlgs entries</span>
<span class="line-added"> 268      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs</span>
<span class="line-added"> 269      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries</span>
<span class="line-added"> 270      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs</span>
<span class="line-added"> 271      * &lt; 2 bytes &gt; preSharedKey length</span>
<span class="line-added"> 272      * &lt; length in bytes &gt; preSharedKey</span>
<span class="line-added"> 273      * &lt; 1 byte &gt; pskIdentity length</span>
<span class="line-added"> 274      * &lt; length in bytes &gt; pskIdentity</span>
<span class="line-added"> 275      * &lt; 1 byte &gt; masterSecret length</span>
<span class="line-added"> 276      *   &lt; 1 byte &gt; masterSecret algorithm length</span>
<span class="line-added"> 277      *   &lt; length in bytes &gt; masterSecret algorithm</span>
<span class="line-added"> 278      *   &lt; 2 bytes &gt; masterSecretKey length</span>
<span class="line-added"> 279      *   &lt; length in bytes&gt; masterSecretKey</span>
<span class="line-added"> 280      * &lt; 1 byte &gt; useExtendedMasterSecret</span>
<span class="line-added"> 281      * &lt; 1 byte &gt; identificationProtocol length</span>
<span class="line-added"> 282      * &lt; length in bytes &gt; identificationProtocol</span>
<span class="line-added"> 283      * &lt; 1 byte &gt; serverNameIndication length</span>
<span class="line-added"> 284      * &lt; length in bytes &gt; serverNameIndication</span>
<span class="line-added"> 285      * &lt; 1 byte &gt; Number of requestedServerNames entries</span>
<span class="line-added"> 286      *   &lt; 1 byte &gt; ServerName length</span>
<span class="line-added"> 287      *   &lt; length in bytes &gt; ServerName</span>
<span class="line-added"> 288      * &lt; 4 bytes &gt; creationTime</span>
<span class="line-added"> 289      * &lt; 2 byte &gt; status response length</span>
<span class="line-added"> 290      *   &lt; 2 byte &gt; status response entry length</span>
<span class="line-added"> 291      *   &lt; length in byte &gt; status response entry</span>
<span class="line-added"> 292      * &lt; 1 byte &gt; Length of peer host</span>
<span class="line-added"> 293      *   &lt; length in bytes &gt; peer host</span>
<span class="line-added"> 294      * &lt; 2 bytes&gt; peer port</span>
<span class="line-added"> 295      * &lt; 1 byte &gt; Number of peerCerts entries</span>
<span class="line-added"> 296      *   &lt; 4 byte &gt; peerCert length</span>
<span class="line-added"> 297      *   &lt; length in bytes &gt; peerCert</span>
<span class="line-added"> 298      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)</span>
<span class="line-added"> 299      *   Certificate</span>
<span class="line-added"> 300      *     &lt; 1 byte &gt; Number of Certificate entries</span>
<span class="line-added"> 301      *       &lt; 4 byte&gt; Certificate length</span>
<span class="line-added"> 302      *       &lt; length in bytes&gt; Certificate</span>
<span class="line-added"> 303      *   PSK</span>
<span class="line-added"> 304      *     &lt; 1 byte &gt; Number of PSK entries</span>
<span class="line-added"> 305      *       &lt; 1 bytes &gt; PSK algorithm length</span>
<span class="line-added"> 306      *       &lt; length in bytes &gt; PSK algorithm string</span>
<span class="line-added"> 307      *       &lt; 4 bytes &gt; PSK key length</span>
<span class="line-added"> 308      *       &lt; length in bytes&gt; PSK key</span>
<span class="line-added"> 309      *       &lt; 4 bytes &gt; PSK identity length</span>
<span class="line-added"> 310      *       &lt; length in bytes&gt; PSK identity</span>
<span class="line-added"> 311      *   Anonymous</span>
<span class="line-added"> 312      *     &lt; 1 byte &gt;</span>
<span class="line-added"> 313      * &lt; 4 bytes &gt; maximumPacketSize</span>
<span class="line-added"> 314      * &lt; 4 bytes &gt; negotiatedMaxFragSize</span>
<span class="line-added"> 315     */</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {</span>
<span class="line-added"> 318         int i = 0;</span>
<span class="line-added"> 319         byte[] b;</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321         boundValues = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-added"> 322         this.protocolVersion =</span>
<span class="line-added"> 323                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added"> 326             this.sessionId = new SessionId(false, null);</span>
<span class="line-added"> 327         } else {</span>
<span class="line-added"> 328             // The CH session id may reset this if it&#39;s provided</span>
<span class="line-added"> 329             this.sessionId = new SessionId(true,</span>
<span class="line-added"> 330                     hc.sslContext.getSecureRandom());</span>
<span class="line-added"> 331         }</span>
<span class="line-added"> 332 </span>
<span class="line-added"> 333         this.cipherSuite =</span>
<span class="line-added"> 334                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336         // Local Supported signature algorithms</span>
<span class="line-added"> 337         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 338         i = Byte.toUnsignedInt(buf.get());</span>
<span class="line-added"> 339         while (i-- &gt; 0) {</span>
<span class="line-added"> 340             list.add(SignatureScheme.valueOf(</span>
<span class="line-added"> 341                     Short.toUnsignedInt(buf.getShort())));</span>
<span class="line-added"> 342         }</span>
<span class="line-added"> 343         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345         // Peer Supported signature algorithms</span>
<span class="line-added"> 346         i = Byte.toUnsignedInt(buf.get());</span>
<span class="line-added"> 347         list.clear();</span>
<span class="line-added"> 348         while (i-- &gt; 0) {</span>
<span class="line-added"> 349             list.add(SignatureScheme.valueOf(</span>
<span class="line-added"> 350                     Short.toUnsignedInt(buf.getShort())));</span>
<span class="line-added"> 351         }</span>
<span class="line-added"> 352         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);</span>
<span class="line-added"> 353 </span>
<span class="line-added"> 354         // PSK</span>
<span class="line-added"> 355         i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 356         if (i &gt; 0) {</span>
<span class="line-added"> 357             b = new byte[i];</span>
<span class="line-added"> 358             // Get algorithm string</span>
<span class="line-added"> 359             buf.get(b, 0, i);</span>
<span class="line-added"> 360             // Encoded length</span>
<span class="line-added"> 361             i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 362             // Encoded SecretKey</span>
<span class="line-added"> 363             b = new byte[i];</span>
<span class="line-added"> 364             buf.get(b);</span>
<span class="line-added"> 365             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);</span>
<span class="line-added"> 366         } else {</span>
<span class="line-added"> 367             this.preSharedKey = null;</span>
<span class="line-added"> 368         }</span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370         // PSK identity</span>
<span class="line-added"> 371         i = buf.get();</span>
<span class="line-added"> 372         if (i &gt; 0) {</span>
<span class="line-added"> 373             b = new byte[i];</span>
<span class="line-added"> 374             buf.get(b);</span>
<span class="line-added"> 375             this.pskIdentity = b;</span>
<span class="line-added"> 376         } else {</span>
<span class="line-added"> 377             this.pskIdentity = null;</span>
<span class="line-added"> 378         }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380         // Master secret length of secret key algorithm  (one byte)</span>
<span class="line-added"> 381         i = buf.get();</span>
<span class="line-added"> 382         if (i &gt; 0) {</span>
<span class="line-added"> 383             b = new byte[i];</span>
<span class="line-added"> 384             // Get algorithm string</span>
<span class="line-added"> 385             buf.get(b, 0, i);</span>
<span class="line-added"> 386             // Encoded length</span>
<span class="line-added"> 387             i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 388             // Encoded SecretKey</span>
<span class="line-added"> 389             b = new byte[i];</span>
<span class="line-added"> 390             buf.get(b);</span>
<span class="line-added"> 391             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);</span>
<span class="line-added"> 392         } else {</span>
<span class="line-added"> 393             this.masterSecret = null;</span>
<span class="line-added"> 394         }</span>
<span class="line-added"> 395         // Use extended master secret</span>
<span class="line-added"> 396         this.useExtendedMasterSecret = (buf.get() != 0);</span>
<span class="line-added"> 397 </span>
<span class="line-added"> 398         // Identification Protocol</span>
<span class="line-added"> 399         i = buf.get();</span>
<span class="line-added"> 400         if (i == 0) {</span>
<span class="line-added"> 401             identificationProtocol = null;</span>
<span class="line-added"> 402         } else {</span>
<span class="line-added"> 403             b = new byte[i];</span>
<span class="line-added"> 404             identificationProtocol =</span>
<span class="line-added"> 405                     buf.get(b, 0, i).asCharBuffer().toString();</span>
<span class="line-added"> 406         }</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408         // SNI</span>
<span class="line-added"> 409         i = buf.get();  // length</span>
<span class="line-added"> 410         if (i == 0) {</span>
<span class="line-added"> 411             serverNameIndication = null;</span>
<span class="line-added"> 412         } else {</span>
<span class="line-added"> 413             b = new byte[i];</span>
<span class="line-added"> 414             buf.get(b, 0, b.length);</span>
<span class="line-added"> 415             serverNameIndication = new SNIHostName(b);</span>
<span class="line-added"> 416         }</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418         // List of SNIServerName</span>
<span class="line-added"> 419         int len = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 420         if (len == 0) {</span>
<span class="line-added"> 421             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();</span>
<span class="line-added"> 422         } else {</span>
<span class="line-added"> 423             requestedServerNames = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 424             while (len &gt; 0) {</span>
<span class="line-added"> 425                 int l = buf.get();</span>
<span class="line-added"> 426                 b = new byte[l];</span>
<span class="line-added"> 427                 buf.get(b, 0, l);</span>
<span class="line-added"> 428                 requestedServerNames.add(new SNIHostName(new String(b)));</span>
<span class="line-added"> 429                 len--;</span>
<span class="line-added"> 430             }</span>
<span class="line-added"> 431         }</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433         maximumPacketSize = buf.getInt();</span>
<span class="line-added"> 434         negotiatedMaxFragLen = buf.getInt();</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436         // Get creation time</span>
<span class="line-added"> 437         this.creationTime = buf.getLong();</span>
<span class="line-added"> 438 </span>
<span class="line-added"> 439         // Get Buffer sizes</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441         // Status Response</span>
<span class="line-added"> 442         len = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 443         if (len == 0) {</span>
<span class="line-added"> 444             statusResponses = Collections.emptyList();</span>
<span class="line-added"> 445         } else {</span>
<span class="line-added"> 446             statusResponses = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 447         }</span>
<span class="line-added"> 448         while (len-- &gt; 0) {</span>
<span class="line-added"> 449             b = new byte[Short.toUnsignedInt(buf.getShort())];</span>
<span class="line-added"> 450             buf.get(b);</span>
<span class="line-added"> 451             statusResponses.add(b);</span>
<span class="line-added"> 452         }</span>
<span class="line-added"> 453 </span>
<span class="line-added"> 454         // Get Peer host &amp; port</span>
<span class="line-added"> 455         i = Byte.toUnsignedInt(buf.get());</span>
<span class="line-added"> 456         if (i == 0) {</span>
<span class="line-added"> 457             this.host = new String();</span>
<span class="line-added"> 458         } else {</span>
<span class="line-added"> 459             b = new byte[i];</span>
<span class="line-added"> 460             this.host = buf.get(b).toString();</span>
<span class="line-added"> 461         }</span>
<span class="line-added"> 462         this.port = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 463 </span>
<span class="line-added"> 464         // Peer certs</span>
<span class="line-added"> 465         i = buf.get();</span>
<span class="line-added"> 466         if (i == 0) {</span>
<span class="line-added"> 467             this.peerCerts = null;</span>
<span class="line-added"> 468         } else {</span>
<span class="line-added"> 469             this.peerCerts = new X509Certificate[i];</span>
<span class="line-added"> 470             int j = 0;</span>
<span class="line-added"> 471             while (i &gt; j) {</span>
<span class="line-added"> 472                 b = new byte[buf.getInt()];</span>
<span class="line-added"> 473                 buf.get(b);</span>
<span class="line-added"> 474                 try {</span>
<span class="line-added"> 475                     this.peerCerts[j] = new X509CertImpl(b);</span>
<span class="line-added"> 476                 } catch (Exception e) {</span>
<span class="line-added"> 477                     throw new IOException(e);</span>
<span class="line-added"> 478                 }</span>
<span class="line-added"> 479                 j++;</span>
<span class="line-added"> 480             }</span>
<span class="line-added"> 481         }</span>
<span class="line-added"> 482 </span>
<span class="line-added"> 483         // Get local certs of PSK</span>
<span class="line-added"> 484         switch (buf.get()) {</span>
<span class="line-added"> 485             case 0:</span>
<span class="line-added"> 486                 break;</span>
<span class="line-added"> 487             case 1:</span>
<span class="line-added"> 488                 // number of certs</span>
<span class="line-added"> 489                 len = buf.get();</span>
<span class="line-added"> 490                 this.localCerts = new X509Certificate[len];</span>
<span class="line-added"> 491                 i = 0;</span>
<span class="line-added"> 492                 while (len &gt; i) {</span>
<span class="line-added"> 493                     b = new byte[buf.getInt()];</span>
<span class="line-added"> 494                     buf.get(b);</span>
<span class="line-added"> 495                     try {</span>
<span class="line-added"> 496                         this.localCerts[i] = new X509CertImpl(b);</span>
<span class="line-added"> 497                     } catch (Exception e) {</span>
<span class="line-added"> 498                         throw new IOException(e);</span>
<span class="line-added"> 499                     }</span>
<span class="line-added"> 500                     i++;</span>
<span class="line-added"> 501                 }</span>
<span class="line-added"> 502                 break;</span>
<span class="line-added"> 503             case 2:</span>
<span class="line-added"> 504                 // pre-shared key</span>
<span class="line-added"> 505                 // Length of pre-shared key algorithm  (one byte)</span>
<span class="line-added"> 506                 i = buf.get();</span>
<span class="line-added"> 507                 b = new byte[i];</span>
<span class="line-added"> 508                 String alg = buf.get(b, 0, i).asCharBuffer().toString();</span>
<span class="line-added"> 509                 // Get length of encoding</span>
<span class="line-added"> 510                 i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 511                 // Get encoding</span>
<span class="line-added"> 512                 b = new byte[i];</span>
<span class="line-added"> 513                 buf.get(b);</span>
<span class="line-added"> 514                 this.preSharedKey = new SecretKeySpec(b, alg);</span>
<span class="line-added"> 515                 // Get identity len</span>
<span class="line-added"> 516                 this.pskIdentity = new byte[buf.get()];</span>
<span class="line-added"> 517                 buf.get(pskIdentity);</span>
<span class="line-added"> 518                 break;</span>
<span class="line-added"> 519             default:</span>
<span class="line-added"> 520                 throw new SSLException(&quot;Failed local certs of session.&quot;);</span>
<span class="line-added"> 521         }</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523         context = (SSLSessionContextImpl)</span>
<span class="line-added"> 524                 hc.sslContext.engineGetServerSessionContext();</span>
<span class="line-added"> 525         this.lastUsedTime = System.currentTimeMillis();</span>
<span class="line-added"> 526     }</span>
<span class="line-added"> 527 </span>
<span class="line-added"> 528     // Some situations we cannot provide a stateless ticket, but after it</span>
<span class="line-added"> 529     // has been negotiated</span>
<span class="line-added"> 530     boolean isStatelessable(HandshakeContext hc) {</span>
<span class="line-added"> 531         if (!hc.statelessResumption) {</span>
<span class="line-added"> 532             return false;</span>
<span class="line-added"> 533         }</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535         // If there is no getMasterSecret with TLS1.2 or under, do not resume.</span>
<span class="line-added"> 536         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added"> 537                 getMasterSecret().getEncoded() == null) {</span>
<span class="line-added"> 538             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added"> 539                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +</span>
<span class="line-added"> 540                         &quot; ticket&quot;);</span>
<span class="line-added"> 541             }</span>
<span class="line-added"> 542             return false;</span>
<span class="line-added"> 543         }</span>
<span class="line-added"> 544         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {</span>
<span class="line-added"> 545             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added"> 546                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +</span>
<span class="line-added"> 547                         &quot; stateless ticket&quot;);</span>
<span class="line-added"> 548             }</span>
<span class="line-added"> 549             return false;</span>
<span class="line-added"> 550         }</span>
<span class="line-added"> 551         return true;</span>
<span class="line-added"> 552     }</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554     /**</span>
<span class="line-added"> 555      * Write out a SSLSessionImpl in a byte array for a stateless session ticket</span>
<span class="line-added"> 556      */</span>
<span class="line-added"> 557     byte[] write() throws Exception {</span>
<span class="line-added"> 558         byte[] b;</span>
<span class="line-added"> 559         HandshakeOutStream hos = new HandshakeOutStream(null);</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561         hos.putInt16(protocolVersion.id);</span>
<span class="line-added"> 562         hos.putInt16(cipherSuite.id);</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564         // Local Supported signature algorithms</span>
<span class="line-added"> 565         hos.putInt8(localSupportedSignAlgs.size());</span>
<span class="line-added"> 566         for (SignatureScheme s : localSupportedSignAlgs) {</span>
<span class="line-added"> 567             hos.putInt16(s.id);</span>
<span class="line-added"> 568         }</span>
<span class="line-added"> 569 </span>
<span class="line-added"> 570         // Peer Supported signature algorithms</span>
<span class="line-added"> 571         hos.putInt8(peerSupportedSignAlgs.size());</span>
<span class="line-added"> 572         for (SignatureScheme s : peerSupportedSignAlgs) {</span>
<span class="line-added"> 573             hos.putInt16(s.id);</span>
<span class="line-added"> 574         }</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576         // PSK</span>
<span class="line-added"> 577         if (preSharedKey == null ||</span>
<span class="line-added"> 578                 preSharedKey.getAlgorithm() == null) {</span>
<span class="line-added"> 579             hos.putInt16(0);</span>
<span class="line-added"> 580         } else {</span>
<span class="line-added"> 581             hos.putInt16(preSharedKey.getAlgorithm().length());</span>
<span class="line-added"> 582             if (preSharedKey.getAlgorithm().length() != 0) {</span>
<span class="line-added"> 583                 hos.write(preSharedKey.getAlgorithm().getBytes());</span>
<span class="line-added"> 584             }</span>
<span class="line-added"> 585             b = preSharedKey.getEncoded();</span>
<span class="line-added"> 586             hos.putInt16(b.length);</span>
<span class="line-added"> 587             hos.write(b, 0, b.length);</span>
<span class="line-added"> 588         }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590         // PSK Identity</span>
<span class="line-added"> 591         if (pskIdentity == null) {</span>
<span class="line-added"> 592             hos.putInt8(0);</span>
<span class="line-added"> 593         } else {</span>
<span class="line-added"> 594             hos.putInt8(pskIdentity.length);</span>
<span class="line-added"> 595             hos.write(pskIdentity, 0, pskIdentity.length);</span>
<span class="line-added"> 596         }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598         // Master Secret</span>
<span class="line-added"> 599         if (getMasterSecret() == null ||</span>
<span class="line-added"> 600                 getMasterSecret().getAlgorithm() == null) {</span>
<span class="line-added"> 601             hos.putInt8(0);</span>
<span class="line-added"> 602         } else {</span>
<span class="line-added"> 603             hos.putInt8(getMasterSecret().getAlgorithm().length());</span>
<span class="line-added"> 604             if (getMasterSecret().getAlgorithm().length() != 0) {</span>
<span class="line-added"> 605                 hos.write(getMasterSecret().getAlgorithm().getBytes());</span>
<span class="line-added"> 606             }</span>
<span class="line-added"> 607             b = getMasterSecret().getEncoded();</span>
<span class="line-added"> 608             hos.putInt16(b.length);</span>
<span class="line-added"> 609             hos.write(b, 0, b.length);</span>
<span class="line-added"> 610         }</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612         hos.putInt8(useExtendedMasterSecret ? 1 : 0);</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614         // Identification Protocol</span>
<span class="line-added"> 615         if (identificationProtocol == null) {</span>
<span class="line-added"> 616             hos.putInt8(0);</span>
<span class="line-added"> 617         } else {</span>
<span class="line-added"> 618             hos.putInt8(identificationProtocol.length());</span>
<span class="line-added"> 619             hos.write(identificationProtocol.getBytes(), 0,</span>
<span class="line-added"> 620                     identificationProtocol.length());</span>
<span class="line-added"> 621         }</span>
<span class="line-added"> 622 </span>
<span class="line-added"> 623         // SNI</span>
<span class="line-added"> 624         if (serverNameIndication == null) {</span>
<span class="line-added"> 625             hos.putInt8(0);</span>
<span class="line-added"> 626         } else {</span>
<span class="line-added"> 627             b = serverNameIndication.getEncoded();</span>
<span class="line-added"> 628             hos.putInt8(b.length);</span>
<span class="line-added"> 629             hos.write(b, 0, b.length);</span>
<span class="line-added"> 630         }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632         // List of SNIServerName</span>
<span class="line-added"> 633         hos.putInt16(requestedServerNames.size());</span>
<span class="line-added"> 634         if (requestedServerNames.size() &gt; 0) {</span>
<span class="line-added"> 635             for (SNIServerName host : requestedServerNames) {</span>
<span class="line-added"> 636                 b = host.getEncoded();</span>
<span class="line-added"> 637                 hos.putInt8(b.length);</span>
<span class="line-added"> 638                 hos.write(b, 0, b.length);</span>
<span class="line-added"> 639             }</span>
<span class="line-added"> 640         }</span>
<span class="line-added"> 641 </span>
<span class="line-added"> 642         // Buffer sizes</span>
<span class="line-added"> 643         hos.putInt32(maximumPacketSize);</span>
<span class="line-added"> 644         hos.putInt32(negotiatedMaxFragLen);</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646         // creation time</span>
<span class="line-added"> 647         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);</span>
<span class="line-added"> 648         hos.writeBytes(buffer.putLong(creationTime).array());</span>
<span class="line-added"> 649 </span>
<span class="line-added"> 650         // Status Responses</span>
<span class="line-added"> 651         List&lt;byte[]&gt; list = getStatusResponses();</span>
<span class="line-added"> 652         int l = list.size();</span>
<span class="line-added"> 653         hos.putInt16(l);</span>
<span class="line-added"> 654         for (byte[] e : list) {</span>
<span class="line-added"> 655             hos.putInt16(e.length);</span>
<span class="line-added"> 656             hos.write(e);</span>
<span class="line-added"> 657         }</span>
<span class="line-added"> 658 </span>
<span class="line-added"> 659         // peer Host &amp; Port</span>
<span class="line-added"> 660         if (host == null || host.length() == 0) {</span>
<span class="line-added"> 661             hos.putInt8(0);</span>
<span class="line-added"> 662         } else {</span>
<span class="line-added"> 663             hos.putInt8(host.length());</span>
<span class="line-added"> 664             hos.writeBytes(host.getBytes());</span>
<span class="line-added"> 665         }</span>
<span class="line-added"> 666         hos.putInt16(port);</span>
<span class="line-added"> 667 </span>
<span class="line-added"> 668         // Peer cert</span>
<span class="line-added"> 669         if (peerCerts == null || peerCerts.length == 0) {</span>
<span class="line-added"> 670             hos.putInt8(0);</span>
<span class="line-added"> 671         } else {</span>
<span class="line-added"> 672             hos.putInt8(peerCerts.length);</span>
<span class="line-added"> 673             for (X509Certificate c : peerCerts) {</span>
<span class="line-added"> 674                 b = c.getEncoded();</span>
<span class="line-added"> 675                 hos.putInt32(b.length);</span>
<span class="line-added"> 676                 hos.writeBytes(b);</span>
<span class="line-added"> 677             }</span>
<span class="line-added"> 678         }</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680         // Client identity</span>
<span class="line-added"> 681         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {</span>
<span class="line-added"> 682             // certificate based</span>
<span class="line-added"> 683             hos.putInt8(1);</span>
<span class="line-added"> 684             hos.putInt8(localCerts.length);</span>
<span class="line-added"> 685             for (X509Certificate c : localCerts) {</span>
<span class="line-added"> 686                 b = c.getEncoded();</span>
<span class="line-added"> 687                 hos.putInt32(b.length);</span>
<span class="line-added"> 688                 hos.writeBytes(b);</span>
<span class="line-added"> 689             }</span>
<span class="line-added"> 690         } else if (preSharedKey != null) {</span>
<span class="line-added"> 691             // pre-shared key</span>
<span class="line-added"> 692             hos.putInt8(2);</span>
<span class="line-added"> 693             hos.putInt8(preSharedKey.getAlgorithm().length());</span>
<span class="line-added"> 694             hos.write(preSharedKey.getAlgorithm().getBytes());</span>
<span class="line-added"> 695             b = preSharedKey.getEncoded();</span>
<span class="line-added"> 696             hos.putInt32(b.length);</span>
<span class="line-added"> 697             hos.writeBytes(b);</span>
<span class="line-added"> 698             hos.putInt32(pskIdentity.length);</span>
<span class="line-added"> 699             hos.writeBytes(pskIdentity);</span>
<span class="line-added"> 700         } else {</span>
<span class="line-added"> 701             // anonymous</span>
<span class="line-added"> 702             hos.putInt8(0);</span>
<span class="line-added"> 703         }</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705         return hos.toByteArray();</span>
<span class="line-added"> 706     }</span>
<span class="line-added"> 707 </span>
 708     void setMasterSecret(SecretKey secret) {
 709         masterSecret = secret;
 710     }
 711 
 712     void setResumptionMasterSecret(SecretKey secret) {
 713         resumptionMasterSecret = secret;
 714     }
 715 
 716     void setPreSharedKey(SecretKey key) {
 717         preSharedKey = key;
 718     }
 719 
 720     void addChild(SSLSessionImpl session) {
 721         childSessions.add(session);
 722     }
 723 
 724     void setTicketAgeAdd(int ticketAgeAdd) {
 725         this.ticketAgeAdd = ticketAgeAdd;
 726     }
 727 
 728     void setPskIdentity(byte[] pskIdentity) {
 729         this.pskIdentity = pskIdentity;
 730     }
 731 
 732     BigInteger incrTicketNonceCounter() {
 733         BigInteger result = ticketNonceCounter;
<a name="13" id="anc13"></a><span class="line-modified"> 734         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);</span>
 735         return result;
 736     }
 737 
<a name="14" id="anc14"></a><span class="line-added"> 738     boolean isPSKable() {</span>
<span class="line-added"> 739         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);</span>
<span class="line-added"> 740     }</span>
<span class="line-added"> 741 </span>
 742     /**
 743      * Returns the master secret ... treat with extreme caution!
 744      */
 745     SecretKey getMasterSecret() {
 746         return masterSecret;
 747     }
 748 
<a name="15" id="anc15"></a><span class="line-modified"> 749     SecretKey getResumptionMasterSecret() {</span>
<span class="line-modified"> 750         return resumptionMasterSecret;</span>
 751     }
 752 
<a name="16" id="anc16"></a><span class="line-modified"> 753     SecretKey getPreSharedKey() {</span>
<span class="line-modified"> 754         sessionLock.lock();</span>
<span class="line-added"> 755         try {</span>
<span class="line-added"> 756             return preSharedKey;</span>
<span class="line-added"> 757         } finally {</span>
<span class="line-added"> 758             sessionLock.unlock();</span>
<span class="line-added"> 759         }</span>
 760     }
 761 
<a name="17" id="anc17"></a><span class="line-modified"> 762     SecretKey consumePreSharedKey() {</span>
<span class="line-modified"> 763         sessionLock.lock();</span>
<span class="line-modified"> 764         try {</span>
<span class="line-modified"> 765             return preSharedKey;</span>
<span class="line-added"> 766         } finally {</span>
<span class="line-added"> 767             preSharedKey = null;</span>
<span class="line-added"> 768             sessionLock.unlock();</span>
<span class="line-added"> 769         }</span>
 770     }
 771 
 772     int getTicketAgeAdd() {
 773         return ticketAgeAdd;
 774     }
 775 
 776     String getIdentificationProtocol() {
 777         return this.identificationProtocol;
 778     }
 779 
 780     /* PSK identities created from new_session_ticket messages should only
 781      * be used once. This method will return the identity and then clear it
 782      * so it cannot be used again.
 783      */
<a name="18" id="anc18"></a><span class="line-modified"> 784     byte[] consumePskIdentity() {</span>
<span class="line-modified"> 785         sessionLock.lock();</span>
<span class="line-modified"> 786         try {</span>
<span class="line-modified"> 787             return pskIdentity;</span>
<span class="line-added"> 788         } finally {</span>
<span class="line-added"> 789             pskIdentity = null;</span>
<span class="line-added"> 790             sessionLock.unlock();</span>
<span class="line-added"> 791         }</span>
<span class="line-added"> 792     }</span>
<span class="line-added"> 793 </span>
<span class="line-added"> 794     byte[] getPskIdentity() {</span>
<span class="line-added"> 795         return pskIdentity;</span>
 796     }
 797 
 798     void setPeerCertificates(X509Certificate[] peer) {
 799         if (peerCerts == null) {
 800             peerCerts = peer;
 801         }
 802     }
 803 
 804     void setLocalCertificates(X509Certificate[] local) {
 805         localCerts = local;
 806     }
 807 
 808     void setLocalPrivateKey(PrivateKey privateKey) {
 809         localPrivateKey = privateKey;
 810     }
 811 
 812     void setPeerSupportedSignatureAlgorithms(
 813             Collection&lt;SignatureScheme&gt; signatureSchemes) {
<a name="19" id="anc19"></a><span class="line-modified"> 814         peerSupportedSignAlgs = signatureSchemes;</span>

 815     }
 816 
 817     // TLS 1.2 only
 818     //
 819     // Per RFC 5246, If the client supports only the default hash
 820     // and signature algorithms, it MAY omit the
 821     // signature_algorithms extension.  If the client does not
 822     // support the default algorithms, or supports other hash
 823     // and signature algorithms (and it is willing to use them
 824     // for verifying messages sent by the server, i.e., server
 825     // certificates and server key exchange), it MUST send the
 826     // signature_algorithms extension, listing the algorithms it
 827     // is willing to accept.
<a name="20" id="anc20"></a><span class="line-added"> 828     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =</span>
<span class="line-added"> 829             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,</span>
<span class="line-added"> 830                     SignatureScheme.DSA_SHA1,</span>
<span class="line-added"> 831                     SignatureScheme.ECDSA_SHA1));</span>
<span class="line-added"> 832 </span>
 833     void setUseDefaultPeerSignAlgs() {
 834         useDefaultPeerSignAlgs = true;
<a name="21" id="anc21"></a><span class="line-modified"> 835         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;</span>

 836     }
 837 
 838     // Returns the connection session.
 839     SSLSessionImpl finish() {
 840         if (useDefaultPeerSignAlgs) {
<a name="22" id="anc22"></a><span class="line-modified"> 841             peerSupportedSignAlgs = Collections.emptySet();</span>
 842         }
 843 
 844         return this;
 845     }
 846 
 847     /**
 848      * Provide status response data obtained during the SSL handshake.
 849      *
 850      * @param responses a {@link List} of responses in binary form.
 851      */
 852     void setStatusResponses(List&lt;byte[]&gt; responses) {
 853         if (responses != null &amp;&amp; !responses.isEmpty()) {
 854             statusResponses = responses;
 855         } else {
 856             statusResponses = Collections.emptyList();
 857         }
 858     }
 859 
 860     /**
 861      * Returns true iff this session may be resumed ... sessions are
 862      * usually resumable.  Security policies may suggest otherwise,
 863      * for example sessions that haven&#39;t been used for a while (say,
 864      * a working day) won&#39;t be resumable, and sessions might have a
 865      * maximum lifetime in any case.
 866      */
 867     boolean isRejoinable() {
<a name="23" id="anc23"></a><span class="line-added"> 868         // TLS 1.3 can have no session id</span>
<span class="line-added"> 869         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added"> 870             return (!invalidated &amp;&amp; isLocalAuthenticationValid());</span>
<span class="line-added"> 871         }</span>
 872         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
<a name="24" id="anc24"></a><span class="line-modified"> 873                 !invalidated &amp;&amp; isLocalAuthenticationValid();</span>
 874     }
 875 
 876     @Override
<a name="25" id="anc25"></a><span class="line-modified"> 877     public boolean isValid() {</span>
<span class="line-modified"> 878         sessionLock.lock();</span>
<span class="line-added"> 879         try {</span>
<span class="line-added"> 880             return isRejoinable();</span>
<span class="line-added"> 881         } finally {</span>
<span class="line-added"> 882             sessionLock.unlock();</span>
<span class="line-added"> 883         }</span>
 884     }
 885 
 886     /**
 887      * Check if the authentication used when establishing this session
 888      * is still valid. Returns true if no authentication was used
 889      */
 890     private boolean isLocalAuthenticationValid() {
 891         if (localPrivateKey != null) {
 892             try {
 893                 // if the private key is no longer valid, getAlgorithm()
 894                 // should throw an exception
 895                 // (e.g. Smartcard has been removed from the reader)
 896                 localPrivateKey.getAlgorithm();
 897             } catch (Exception e) {
 898                 invalidate();
 899                 return false;
 900             }
 901         }
 902 
 903         return true;
 904     }
 905 
 906     /**
 907      * Returns the ID for this session.  The ID is fixed for the
 908      * duration of the session; neither it, nor its value, changes.
 909      */
 910     @Override
 911     public byte[] getId() {
 912         return sessionId.getId();
 913     }
 914 
 915     /**
 916      * For server sessions, this returns the set of sessions which
 917      * are currently valid in this process.  For client sessions,
 918      * this returns null.
 919      */
 920     @Override
 921     public SSLSessionContext getSessionContext() {
 922         /*
 923          * An interim security policy until we can do something
 924          * more specific in 1.2. Only allow trusted code (code which
 925          * can set system properties) to get an
 926          * SSLSessionContext. This is to limit the ability of code to
 927          * look up specific sessions or enumerate over them. Otherwise,
 928          * code can only get session objects from successful SSL
 929          * connections which implies that they must have had permission
 930          * to make the network connection in the first place.
 931          */
 932         SecurityManager sm;
 933         if ((sm = System.getSecurityManager()) != null) {
 934             sm.checkPermission(new SSLPermission(&quot;getSSLSessionContext&quot;));
 935         }
 936 
 937         return context;
 938     }
 939 
 940 
 941     SessionId getSessionId() {
 942         return sessionId;
 943     }
 944 
 945 
 946     /**
 947      * Returns the cipher spec in use on this session
 948      */
 949     CipherSuite getSuite() {
 950         return cipherSuite;
 951     }
 952 
 953     /**
 954      * Resets the cipher spec in use on this session
 955      */
 956     void setSuite(CipherSuite suite) {
 957        cipherSuite = suite;
 958 
 959         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 960              SSLLogger.finest(&quot;Negotiating session:  &quot; + this);
 961        }
 962     }
 963 
 964     /**
 965      * Return true if the session is currently re-established with a
 966      * session-resumption abbreviated initial handshake.
 967      */
 968     boolean isSessionResumption() {
 969         return isSessionResumption;
 970     }
 971 
 972     /**
 973      * Resets whether the session is re-established with a session-resumption
 974      * abbreviated initial handshake.
 975      */
 976     void setAsSessionResumption(boolean flag) {
 977         isSessionResumption = flag;
 978     }
 979 
 980     /**
 981      * Returns the name of the cipher suite in use on this session
 982      */
 983     @Override
 984     public String getCipherSuite() {
 985         return getSuite().name;
 986     }
 987 
 988     ProtocolVersion getProtocolVersion() {
 989         return protocolVersion;
 990     }
 991 
 992     /**
 993      * Returns the standard name of the protocol in use on this session
 994      */
 995     @Override
 996     public String getProtocol() {
 997         return getProtocolVersion().name;
 998     }
 999 
1000     /**
1001      * Returns the hashcode for this session
1002      */
1003     @Override
1004     public int hashCode() {
1005         return sessionId.hashCode();
1006     }
1007 
1008     /**
1009      * Returns true if sessions have same ids, false otherwise.
1010      */
1011     @Override
1012     public boolean equals(Object obj) {
1013 
1014         if (obj == this) {
1015             return true;
1016         }
1017 
1018         if (obj instanceof SSLSessionImpl) {
1019             SSLSessionImpl sess = (SSLSessionImpl) obj;
1020             return (sessionId != null) &amp;&amp; (sessionId.equals(
1021                         sess.getSessionId()));
1022         }
1023 
1024         return false;
1025     }
1026 
1027 
1028     /**
1029      * Return the cert chain presented by the peer in the
1030      * java.security.cert format.
1031      * Note: This method can be used only when using certificate-based
1032      * cipher suites; using it with non-certificate-based cipher suites
1033      * will throw an SSLPeerUnverifiedException.
1034      *
1035      * @return array of peer X.509 certs, with the peer&#39;s own cert
1036      *  first in the chain, and with the &quot;root&quot; CA last.
1037      */
1038     @Override
1039     public java.security.cert.Certificate[] getPeerCertificates()
1040             throws SSLPeerUnverifiedException {
1041         //
1042         // clone to preserve integrity of session ... caller can&#39;t
1043         // change record of peer identity even by accident, much
1044         // less do it intentionally.
1045         //
1046         if (peerCerts == null) {
1047             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1048         }
1049         // Certs are immutable objects, therefore we don&#39;t clone them.
1050         // But do need to clone the array, so that nothing is inserted
1051         // into peerCerts.
1052         return (java.security.cert.Certificate[])peerCerts.clone();
1053     }
1054 
1055     /**
1056      * Return the cert chain presented to the peer in the
1057      * java.security.cert format.
1058      * Note: This method is useful only when using certificate-based
1059      * cipher suites.
1060      *
1061      * @return array of peer X.509 certs, with the peer&#39;s own cert
1062      *  first in the chain, and with the &quot;root&quot; CA last.
1063      */
1064     @Override
1065     public java.security.cert.Certificate[] getLocalCertificates() {
1066         //
1067         // clone to preserve integrity of session ... caller can&#39;t
1068         // change record of peer identity even by accident, much
1069         // less do it intentionally.
1070         return (localCerts == null ? null :
1071             (java.security.cert.Certificate[])localCerts.clone());
1072     }
1073 
1074     /**
1075      * Return the cert chain presented by the peer in the
1076      * javax.security.cert format.
1077      * Note: This method can be used only when using certificate-based
1078      * cipher suites; using it with non-certificate-based cipher suites
1079      * will throw an SSLPeerUnverifiedException.
1080      *
1081      * @return array of peer X.509 certs, with the peer&#39;s own cert
1082      *  first in the chain, and with the &quot;root&quot; CA last.
1083      *
1084      * @deprecated This method returns the deprecated
1085      *  {@code javax.security.cert.X509Certificate} type.
1086      *  Use {@code getPeerCertificates()} instead.
1087      */
1088     @Override
1089     @SuppressWarnings(&quot;removal&quot;)
1090     @Deprecated(since=&quot;9&quot;, forRemoval=true)
1091     public javax.security.cert.X509Certificate[] getPeerCertificateChain()
1092             throws SSLPeerUnverifiedException {
1093         //
1094         // clone to preserve integrity of session ... caller can&#39;t
1095         // change record of peer identity even by accident, much
1096         // less do it intentionally.
1097         //
1098         if (peerCerts == null) {
1099             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1100         }
1101         javax.security.cert.X509Certificate[] certs;
1102         certs = new javax.security.cert.X509Certificate[peerCerts.length];
1103         for (int i = 0; i &lt; peerCerts.length; i++) {
1104             byte[] der = null;
1105             try {
1106                 der = peerCerts[i].getEncoded();
1107                 certs[i] = javax.security.cert.X509Certificate.getInstance(der);
1108             } catch (CertificateEncodingException e) {
1109                 throw new SSLPeerUnverifiedException(e.getMessage());
1110             } catch (javax.security.cert.CertificateException e) {
1111                 throw new SSLPeerUnverifiedException(e.getMessage());
1112             }
1113         }
1114 
1115         return certs;
1116     }
1117 
1118     /**
1119      * Return the cert chain presented by the peer.
1120      * Note: This method can be used only when using certificate-based
1121      * cipher suites; using it with non-certificate-based cipher suites
1122      * will throw an SSLPeerUnverifiedException.
1123      *
1124      * @return array of peer X.509 certs, with the peer&#39;s own cert
1125      *  first in the chain, and with the &quot;root&quot; CA last.
1126      */
1127     public X509Certificate[] getCertificateChain()
1128             throws SSLPeerUnverifiedException {
1129         /*
1130          * clone to preserve integrity of session ... caller can&#39;t
1131          * change record of peer identity even by accident, much
1132          * less do it intentionally.
1133          */
1134         if (peerCerts != null) {
1135             return peerCerts.clone();
1136         } else {
1137             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1138         }
1139     }
1140 
1141     /**
1142      * Return a List of status responses presented by the peer.
1143      * Note: This method can be used only when using certificate-based
1144      * server authentication; otherwise an empty {@code List} will be returned.
1145      *
1146      * @return an unmodifiable {@code List} of byte arrays, each consisting
1147      * of a DER-encoded OCSP response (see RFC 6960).  If no responses have
1148      * been presented by the server or non-certificate based server
1149      * authentication is used then an empty {@code List} is returned.
1150      */
1151     @Override
1152     public List&lt;byte[]&gt; getStatusResponses() {
1153         if (statusResponses == null || statusResponses.isEmpty()) {
1154             return Collections.emptyList();
1155         } else {
1156             // Clone both the list and the contents
1157             List&lt;byte[]&gt; responses = new ArrayList&lt;&gt;(statusResponses.size());
1158             for (byte[] respBytes : statusResponses) {
1159                 responses.add(respBytes.clone());
1160             }
1161             return Collections.unmodifiableList(responses);
1162         }
1163     }
1164 
1165     /**
1166      * Returns the identity of the peer which was established as part of
1167      * defining the session.
1168      *
1169      * @return the peer&#39;s principal. Returns an X500Principal of the
1170      * end-entity certificate for X509-based cipher suites.
1171      *
1172      * @throws SSLPeerUnverifiedException if the peer&#39;s identity has not
1173      *          been verified
1174      */
1175     @Override
1176     public Principal getPeerPrincipal()
1177                 throws SSLPeerUnverifiedException
1178     {
1179         if (peerCerts == null) {
1180             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1181         }
1182         return peerCerts[0].getSubjectX500Principal();
1183     }
1184 
1185     /**
1186      * Returns the principal that was sent to the peer during handshaking.
1187      *
1188      * @return the principal sent to the peer. Returns an X500Principal
1189      * of the end-entity certificate for X509-based cipher suites.
1190      * If no principal was sent, then null is returned.
1191      */
1192     @Override
1193     public Principal getLocalPrincipal() {
1194         return ((localCerts == null || localCerts.length == 0) ? null :
1195                 localCerts[0].getSubjectX500Principal());
1196     }
1197 
1198     /*
1199      * Return the time the ticket for this session was created.
1200      */
1201     public long getTicketCreationTime() {
1202         return ticketCreationTime;
1203     }
1204 
1205     /**
1206      * Returns the time this session was created.
1207      */
1208     @Override
1209     public long getCreationTime() {
1210         return creationTime;
1211     }
1212 
1213     /**
1214      * Returns the last time this session was used to initialize
1215      * a connection.
1216      */
1217     @Override
1218     public long getLastAccessedTime() {
1219         return (lastUsedTime != 0) ? lastUsedTime : creationTime;
1220     }
1221 
1222     void setLastAccessedTime(long time) {
1223         lastUsedTime = time;
1224     }
1225 
1226 
1227     /**
1228      * Returns the network address of the session&#39;s peer.  This
1229      * implementation does not insist that connections between
1230      * different ports on the same host must necessarily belong
1231      * to different sessions, though that is of course allowed.
1232      */
1233     public InetAddress getPeerAddress() {
1234         try {
1235             return InetAddress.getByName(host);
1236         } catch (java.net.UnknownHostException e) {
1237             return null;
1238         }
1239     }
1240 
1241     @Override
1242     public String getPeerHost() {
1243         return host;
1244     }
1245 
1246     /**
1247      * Need to provide the port info for caching sessions based on
1248      * host and port. Accessed by SSLSessionContextImpl
1249      */
1250     @Override
1251     public int getPeerPort() {
1252         return port;
1253     }
1254 
1255     void setContext(SSLSessionContextImpl ctx) {
1256         if (context == null) {
1257             context = ctx;
1258         }
1259     }
1260 
1261     /**
1262      * Invalidate a session.  Active connections may still exist, but
1263      * no connections will be able to rejoin this session.
1264      */
1265     @Override
<a name="26" id="anc26"></a><span class="line-modified">1266     public void invalidate() {</span>
<span class="line-modified">1267         sessionLock.lock();</span>
<span class="line-modified">1268         try {</span>
<span class="line-modified">1269             //</span>
<span class="line-modified">1270             // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="line-modified">1271             // attempted when we get a handshaking error on a brand</span>
<span class="line-modified">1272             // new connection, with no &quot;real&quot; session yet.</span>
<span class="line-modified">1273             //</span>
<span class="line-modified">1274             if (this == nullSession) {</span>
<span class="line-added">1275                 return;</span>
<span class="line-added">1276             }</span>
1277 
<a name="27" id="anc27"></a><span class="line-modified">1278             if (context != null) {</span>
<span class="line-modified">1279                 context.remove(sessionId);</span>
<span class="line-modified">1280                 context = null;</span>
<span class="line-modified">1281             }</span>
<span class="line-modified">1282 </span>
<span class="line-modified">1283             if (invalidated) {</span>
<span class="line-modified">1284                 return;</span>
<span class="line-modified">1285             }</span>
<span class="line-modified">1286             invalidated = true;</span>
<span class="line-modified">1287             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {</span>
<span class="line-modified">1288                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);</span>
<span class="line-modified">1289             }</span>
<span class="line-modified">1290             for (SSLSessionImpl child : childSessions) {</span>
<span class="line-added">1291                 child.invalidate();</span>
<span class="line-added">1292             }</span>
<span class="line-added">1293         } finally {</span>
<span class="line-added">1294             sessionLock.unlock();</span>
1295         }
1296     }
1297 
1298     /*
1299      * Table of application-specific session data indexed by an application
1300      * key and the calling security context. This is important since
1301      * sessions can be shared across different protection domains.
1302      */
1303     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
<a name="28" id="anc28"></a><span class="line-added">1304     boolean updateNST;</span>
1305 
1306     /**
1307      * Assigns a session value.  Session change events are given if
1308      * appropriate, to any original value as well as the new value.
1309      */
1310     @Override
1311     public void putValue(String key, Object value) {
1312         if ((key == null) || (value == null)) {
1313             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
1314         }
1315 
1316         SecureKey secureKey = new SecureKey(key);
1317         Object oldValue = boundValues.put(secureKey, value);
1318 
1319         if (oldValue instanceof SSLSessionBindingListener) {
1320             SSLSessionBindingEvent e;
1321 
1322             e = new SSLSessionBindingEvent(this, key);
1323             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
1324         }
1325         if (value instanceof SSLSessionBindingListener) {
1326             SSLSessionBindingEvent e;
1327 
1328             e = new SSLSessionBindingEvent(this, key);
1329             ((SSLSessionBindingListener)value).valueBound(e);
1330         }
<a name="29" id="anc29"></a><span class="line-added">1331         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added">1332             updateNST = true;</span>
<span class="line-added">1333         }</span>
1334     }
1335 
1336     /**
1337      * Returns the specified session value.
1338      */
1339     @Override
1340     public Object getValue(String key) {
1341         if (key == null) {
1342             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1343         }
1344 
1345         SecureKey secureKey = new SecureKey(key);
1346         return boundValues.get(secureKey);
1347     }
1348 
1349 
1350     /**
1351      * Removes the specified session value, delivering a session changed
1352      * event as appropriate.
1353      */
1354     @Override
1355     public void removeValue(String key) {
1356         if (key == null) {
1357             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1358         }
1359 
1360         SecureKey secureKey = new SecureKey(key);
1361         Object value = boundValues.remove(secureKey);
1362 
1363         if (value instanceof SSLSessionBindingListener) {
1364             SSLSessionBindingEvent e;
1365 
1366             e = new SSLSessionBindingEvent(this, key);
1367             ((SSLSessionBindingListener)value).valueUnbound(e);
1368         }
<a name="30" id="anc30"></a><span class="line-added">1369         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added">1370             updateNST = true;</span>
<span class="line-added">1371         }</span>
1372     }
1373 
1374 
1375     /**
1376      * Lists the names of the session values.
1377      */
1378     @Override
1379     public String[] getValueNames() {
1380         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
1381         Object securityCtx = SecureKey.getCurrentSecurityContext();
1382         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
1383                 e.hasMoreElements(); ) {
1384             SecureKey key = e.nextElement();
1385             if (securityCtx.equals(key.getSecurityContext())) {
1386                 v.add(key.getAppKey());
1387             }
1388         }
1389 
1390         return v.toArray(new String[0]);
1391     }
1392 
1393     /**
1394      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
1395      * until changed.
1396      *
1397      * In the TLS specification (section 6.2.1, RFC2246), it is not
1398      * recommended that the plaintext has more than 2^14 bytes.
1399      * However, some TLS implementations violate the specification.
1400      * This is a workaround for interoperability with these stacks.
1401      *
1402      * Application could accept large fragments up to 2^15 bytes by
1403      * setting the system property jsse.SSLEngine.acceptLargeFragments
1404      * to &quot;true&quot;.
1405      */
1406     private boolean acceptLargeFragments =
1407             Utilities.getBooleanProperty(
1408                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
1409 
1410     /**
1411      * Expand the buffer size of both SSL/TLS network packet and
1412      * application data.
1413      */
<a name="31" id="anc31"></a><span class="line-modified">1414     protected void expandBufferSizes() {</span>
<span class="line-modified">1415         sessionLock.lock();</span>
<span class="line-added">1416         try {</span>
<span class="line-added">1417             acceptLargeFragments = true;</span>
<span class="line-added">1418         } finally {</span>
<span class="line-added">1419             sessionLock.unlock();</span>
<span class="line-added">1420         }</span>
1421     }
1422 
1423     /**
1424      * Gets the current size of the largest SSL/TLS packet that is expected
1425      * when using this session.
1426      */
1427     @Override
<a name="32" id="anc32"></a><span class="line-modified">1428     public int getPacketBufferSize() {</span>
<span class="line-modified">1429         sessionLock.lock();</span>
<span class="line-modified">1430         try {</span>
<span class="line-modified">1431             // Use the bigger packet size calculated from maximumPacketSize</span>
<span class="line-modified">1432             // and negotiatedMaxFragLen.</span>
<span class="line-modified">1433             int packetSize = 0;</span>
<span class="line-modified">1434             if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified">1435                 packetSize = cipherSuite.calculatePacketSize(</span>
<span class="line-modified">1436                         negotiatedMaxFragLen, protocolVersion,</span>
<span class="line-added">1437                         protocolVersion.isDTLS);</span>
<span class="line-added">1438             }</span>
1439 
<a name="33" id="anc33"></a><span class="line-modified">1440             if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified">1441                 return (maximumPacketSize &gt; packetSize) ?</span>
<span class="line-modified">1442                         maximumPacketSize : packetSize;</span>
<span class="line-modified">1443             }</span>
1444 
<a name="34" id="anc34"></a><span class="line-modified">1445             if (packetSize != 0) {</span>
<span class="line-modified">1446                return packetSize;</span>
<span class="line-modified">1447             }</span>
1448 
<a name="35" id="anc35"></a><span class="line-modified">1449             if (protocolVersion.isDTLS) {</span>
<span class="line-modified">1450                 return DTLSRecord.maxRecordSize;</span>
<span class="line-modified">1451             } else {</span>
<span class="line-modified">1452                 return acceptLargeFragments ?</span>
<span class="line-modified">1453                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="line-added">1454             }</span>
<span class="line-added">1455         } finally {</span>
<span class="line-added">1456             sessionLock.unlock();</span>
1457         }
1458     }
1459 
1460     /**
1461      * Gets the current size of the largest application data that is
1462      * expected when using this session.
1463      */
1464     @Override
<a name="36" id="anc36"></a><span class="line-modified">1465     public int getApplicationBufferSize() {</span>
<span class="line-modified">1466         sessionLock.lock();</span>
<span class="line-modified">1467         try {</span>
<span class="line-modified">1468             // Use the bigger fragment size calculated from maximumPacketSize</span>
<span class="line-modified">1469             // and negotiatedMaxFragLen.</span>
<span class="line-modified">1470             int fragmentSize = 0;</span>
<span class="line-modified">1471             if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified">1472                 fragmentSize = cipherSuite.calculateFragSize(</span>
<span class="line-modified">1473                         maximumPacketSize, protocolVersion,</span>
<span class="line-added">1474                         protocolVersion.isDTLS);</span>
<span class="line-added">1475             }</span>
1476 
<a name="37" id="anc37"></a><span class="line-modified">1477             if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified">1478                 return (negotiatedMaxFragLen &gt; fragmentSize) ?</span>
<span class="line-modified">1479                         negotiatedMaxFragLen : fragmentSize;</span>
<span class="line-modified">1480             }</span>
1481 
<a name="38" id="anc38"></a><span class="line-modified">1482             if (fragmentSize != 0) {</span>
<span class="line-modified">1483                 return fragmentSize;</span>
<span class="line-modified">1484             }</span>
1485 
<a name="39" id="anc39"></a><span class="line-modified">1486             if (protocolVersion.isDTLS) {</span>
<span class="line-modified">1487                 return Record.maxDataSize;</span>
<span class="line-modified">1488             } else {</span>
<span class="line-modified">1489                 int maxPacketSize = acceptLargeFragments ?</span>
<span class="line-modified">1490                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="line-modified">1491                 return (maxPacketSize - SSLRecord.headerSize);</span>
<span class="line-added">1492             }</span>
<span class="line-added">1493         } finally {</span>
<span class="line-added">1494             sessionLock.unlock();</span>
1495         }
1496     }
1497 
1498     /**
1499      * Sets the negotiated maximum fragment length, as specified by the
1500      * max_fragment_length ClientHello extension in RFC 6066.
1501      *
1502      * @param  negotiatedMaxFragLen
1503      *         the negotiated maximum fragment length, or {@code -1} if
1504      *         no such length has been negotiated.
1505      */
<a name="40" id="anc40"></a><span class="line-modified">1506     void setNegotiatedMaxFragSize(</span>
1507             int negotiatedMaxFragLen) {
<a name="41" id="anc41"></a><span class="line-modified">1508         sessionLock.lock();</span>
<span class="line-modified">1509         try {</span>
<span class="line-added">1510             this.negotiatedMaxFragLen = negotiatedMaxFragLen;</span>
<span class="line-added">1511         } finally {</span>
<span class="line-added">1512             sessionLock.unlock();</span>
<span class="line-added">1513         }</span>
1514     }
1515 
1516     /**
1517      * Get the negotiated maximum fragment length, as specified by the
1518      * max_fragment_length ClientHello extension in RFC 6066.
1519      *
1520      * @return the negotiated maximum fragment length, or {@code -1} if
1521      *         no such length has been negotiated.
1522      */
<a name="42" id="anc42"></a><span class="line-modified">1523     int getNegotiatedMaxFragSize() {</span>
<span class="line-modified">1524         sessionLock.lock();</span>
<span class="line-added">1525         try {</span>
<span class="line-added">1526             return negotiatedMaxFragLen;</span>
<span class="line-added">1527         } finally {</span>
<span class="line-added">1528             sessionLock.unlock();</span>
<span class="line-added">1529         }</span>
1530     }
1531 
<a name="43" id="anc43"></a><span class="line-modified">1532     void setMaximumPacketSize(int maximumPacketSize) {</span>
<span class="line-modified">1533         sessionLock.lock();</span>
<span class="line-added">1534         try {</span>
<span class="line-added">1535             this.maximumPacketSize = maximumPacketSize;</span>
<span class="line-added">1536         } finally {</span>
<span class="line-added">1537             sessionLock.unlock();</span>
<span class="line-added">1538         }</span>
1539     }
1540 
<a name="44" id="anc44"></a><span class="line-modified">1541     int getMaximumPacketSize() {</span>
<span class="line-modified">1542         sessionLock.lock();</span>
<span class="line-added">1543         try {</span>
<span class="line-added">1544             return maximumPacketSize;</span>
<span class="line-added">1545         } finally {</span>
<span class="line-added">1546             sessionLock.unlock();</span>
<span class="line-added">1547         }</span>
1548     }
1549 
1550     /**
1551      * Gets an array of supported signature algorithm names that the local
1552      * side is willing to verify.
1553      */
1554     @Override
1555     public String[] getLocalSupportedSignatureAlgorithms() {
1556         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1557     }
1558 
1559     /**
1560      * Gets an array of supported signature schemes that the local side is
1561      * willing to verify.
1562      */
1563     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1564         return localSupportedSignAlgs;
1565     }
1566 
1567     /**
1568      * Gets an array of supported signature algorithms that the peer is
1569      * able to verify.
1570      */
1571     @Override
1572     public String[] getPeerSupportedSignatureAlgorithms() {
<a name="45" id="anc45"></a><span class="line-modified">1573         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);</span>




1574     }
1575 
1576     /**
1577      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1578      * of the requested Server Name Indication (SNI) extension.
1579      */
1580     @Override
1581     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1582         return requestedServerNames;
1583     }
1584 
1585     /** Returns a string representation of this SSL session */
1586     @Override
1587     public String toString() {
1588         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1589     }
1590 }
1591 
1592 /**
1593  * This &quot;struct&quot; class serves as a Hash Key that combines an
1594  * application-specific key and a security context.
1595  */
1596 class SecureKey {
1597     private static final Object     nullObject = new Object();
1598     private final Object            appKey;
1599     private final Object            securityCtx;
1600 
1601     static Object getCurrentSecurityContext() {
1602         SecurityManager sm = System.getSecurityManager();
1603         Object context = null;
1604 
1605         if (sm != null)
1606             context = sm.getSecurityContext();
1607         if (context == null)
1608             context = nullObject;
1609         return context;
1610     }
1611 
1612     SecureKey(Object key) {
1613         this.appKey = key;
1614         this.securityCtx = getCurrentSecurityContext();
1615     }
1616 
1617     Object getAppKey() {
1618         return appKey;
1619     }
1620 
1621     Object getSecurityContext() {
1622         return securityCtx;
1623     }
1624 
1625     @Override
1626     public int hashCode() {
1627         return appKey.hashCode() ^ securityCtx.hashCode();
1628     }
1629 
1630     @Override
1631     public boolean equals(Object o) {
1632         return o instanceof SecureKey &amp;&amp; ((SecureKey)o).appKey.equals(appKey)
1633                         &amp;&amp; ((SecureKey)o).securityCtx.equals(securityCtx);
1634     }
1635 }
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
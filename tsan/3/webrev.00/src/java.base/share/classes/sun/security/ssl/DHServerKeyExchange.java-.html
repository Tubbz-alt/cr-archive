<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/DHServerKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.nio.ByteBuffer;
 31 import java.security.CryptoPrimitive;
 32 import java.security.GeneralSecurityException;
 33 import java.security.InvalidAlgorithmParameterException;
 34 import java.security.InvalidKeyException;
 35 import java.security.Key;
 36 import java.security.KeyFactory;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.PrivateKey;
 39 import java.security.PublicKey;
 40 import java.security.Signature;
 41 import java.security.SignatureException;
 42 import java.text.MessageFormat;
 43 import java.util.EnumSet;
 44 import java.util.Locale;
 45 import javax.crypto.interfaces.DHPublicKey;
 46 import javax.crypto.spec.DHParameterSpec;
 47 import javax.crypto.spec.DHPublicKeySpec;
 48 import sun.security.ssl.DHKeyExchange.DHECredentials;
 49 import sun.security.ssl.DHKeyExchange.DHEPossession;
 50 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;
 52 import sun.security.ssl.X509Authentication.X509Credentials;
 53 import sun.security.ssl.X509Authentication.X509Possession;
 54 import sun.security.util.HexDumpEncoder;
 55 import sun.security.util.KeyUtil;
 56 
 57 /**
 58  * Pack of the ServerKeyExchange handshake message.
 59  */
 60 final class DHServerKeyExchange {
 61     static final SSLConsumer dhHandshakeConsumer =
 62             new DHServerKeyExchangeConsumer();
 63     static final HandshakeProducer dhHandshakeProducer =
 64             new DHServerKeyExchangeProducer();
 65 
 66     /**
 67      * The DiffieHellman ServerKeyExchange handshake message.
 68      */
 69     private static final
 70             class DHServerKeyExchangeMessage extends HandshakeMessage {
 71         // public key encapsulated in this message
 72         private final byte[] p;        // 1 to 2^16 - 1 bytes
 73         private final byte[] g;        // 1 to 2^16 - 1 bytes
 74         private final byte[] y;        // 1 to 2^16 - 1 bytes
 75 
 76         // the signature algorithm used by this ServerKeyExchange message
 77         private final boolean useExplicitSigAlgorithm;
 78         private final SignatureScheme signatureScheme;
 79 
 80         // signature bytes, or null if anonymous
 81         private final byte[] paramsSignature;
 82 
 83         DHServerKeyExchangeMessage(
 84                 HandshakeContext handshakeContext) throws IOException {
 85             super(handshakeContext);
 86 
 87             // This happens in server side only.
 88             ServerHandshakeContext shc =
 89                     (ServerHandshakeContext)handshakeContext;
 90 
 91             DHEPossession dhePossession = null;
 92             X509Possession x509Possession = null;
 93             for (SSLPossession possession : shc.handshakePossessions) {
 94                 if (possession instanceof DHEPossession) {
 95                     dhePossession = (DHEPossession)possession;
 96                     if (x509Possession != null) {
 97                         break;
 98                     }
 99                 } else if (possession instanceof X509Possession) {
100                     x509Possession = (X509Possession)possession;
101                     if (dhePossession != null) {
102                         break;
103                     }
104                 }
105             }
106 
107             if (dhePossession == null) {
108                 // unlikely
109                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
110                     &quot;No DHE credentials negotiated for server key exchange&quot;);
111             }
112             DHPublicKey publicKey = dhePossession.publicKey;
113             DHParameterSpec params = publicKey.getParams();
114             this.p = Utilities.toByteArray(params.getP());
115             this.g = Utilities.toByteArray(params.getG());
116             this.y = Utilities.toByteArray(publicKey.getY());
117 
118             if (x509Possession == null) {
119                 // anonymous, no authentication, no signature
120                 paramsSignature = null;
121                 signatureScheme = null;
122                 useExplicitSigAlgorithm = false;
123             } else {
124                 useExplicitSigAlgorithm =
125                         shc.negotiatedProtocol.useTLS12PlusSpec();
126                 Signature signer = null;
127                 if (useExplicitSigAlgorithm) {
128                     signatureScheme = SignatureScheme.getPreferableAlgorithm(
129                             shc.peerRequestedSignatureSchemes,
130                             x509Possession.popPrivateKey,
131                             shc.negotiatedProtocol);
132                     if (signatureScheme == null) {
133                         // Unlikely, the credentials generator should have
134                         // selected the preferable signature algorithm properly.
135                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
136                             &quot;No preferred signature algorithm&quot;);
137                     }
138                     try {
139                         signer = signatureScheme.getSignature(
140                                 x509Possession.popPrivateKey);
141                     } catch (NoSuchAlgorithmException | InvalidKeyException |
142                             InvalidAlgorithmParameterException nsae) {
143                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
144                             &quot;Unsupported signature algorithm: &quot; +
145                             signatureScheme.name, nsae);
146                     }
147                 } else {
148                     signatureScheme = null;
149                     try {
150                         signer = getSignature(
151                                 x509Possession.popPrivateKey.getAlgorithm(),
152                                 x509Possession.popPrivateKey);
153                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
154                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
155                             &quot;Unsupported signature algorithm: &quot; +
156                             x509Possession.popPrivateKey.getAlgorithm(), e);
157                     }
158                 }
159 
160                 byte[] signature = null;
161                 try {
162                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
163                             shc.serverHelloRandom.randomBytes);
164                     signature = signer.sign();
165                 } catch (SignatureException ex) {
166                     throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
167                         &quot;Failed to sign dhe parameters: &quot; +
168                         x509Possession.popPrivateKey.getAlgorithm(), ex);
169                 }
170                 paramsSignature = signature;
171             }
172         }
173 
174         DHServerKeyExchangeMessage(HandshakeContext handshakeContext,
175                 ByteBuffer m) throws IOException {
176             super(handshakeContext);
177 
178             // This happens in client side only.
179             ClientHandshakeContext chc =
180                     (ClientHandshakeContext)handshakeContext;
181 
182             this.p = Record.getBytes16(m);
183             this.g = Record.getBytes16(m);
184             this.y = Record.getBytes16(m);
185 
186             try {
187                 KeyUtil.validate(new DHPublicKeySpec(
188                         new BigInteger(1, y),
189                         new BigInteger(1, p),
190                         new BigInteger(1, p)));
191             } catch (InvalidKeyException ike) {
192                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
193                     &quot;Invalid DH ServerKeyExchange: invalid parameters&quot;, ike);
194             }
195 
196             X509Credentials x509Credentials = null;
197             for (SSLCredentials cd : chc.handshakeCredentials) {
198                 if (cd instanceof X509Credentials) {
199                     x509Credentials = (X509Credentials)cd;
200                     break;
201                 }
202             }
203 
204             if (x509Credentials == null) {
205                 // anonymous, no authentication, no signature
206                 if (m.hasRemaining()) {
207                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
208                         &quot;Invalid DH ServerKeyExchange: unknown extra data&quot;);
209                 }
210 
211                 this.signatureScheme = null;
212                 this.paramsSignature = null;
213                 this.useExplicitSigAlgorithm = false;
214 
215                 return;
216             }
217 
218             this.useExplicitSigAlgorithm =
219                     chc.negotiatedProtocol.useTLS12PlusSpec();
220             if (useExplicitSigAlgorithm) {
221                 int ssid = Record.getInt16(m);
222                 signatureScheme = SignatureScheme.valueOf(ssid);
223                 if (signatureScheme == null) {
224                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
225                             &quot;Invalid signature algorithm (&quot; + ssid +
226                             &quot;) used in DH ServerKeyExchange handshake message&quot;);
227                 }
228 
229                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
230                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
231                             &quot;Unsupported signature algorithm (&quot; +
232                             signatureScheme.name +
233                             &quot;) used in DH ServerKeyExchange handshake message&quot;);
234                 }
235             } else {
236                 this.signatureScheme = null;
237             }
238 
239             // read and verify the signature
240             this.paramsSignature = Record.getBytes16(m);
241             Signature signer;
242             if (useExplicitSigAlgorithm) {
243                 try {
244                     signer = signatureScheme.getSignature(
245                             x509Credentials.popPublicKey);
246                 } catch (NoSuchAlgorithmException | InvalidKeyException |
247                         InvalidAlgorithmParameterException nsae) {
248                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
249                             &quot;Unsupported signature algorithm: &quot; +
250                             signatureScheme.name, nsae);
251                 }
252             } else {
253                 try {
254                     signer = getSignature(
255                             x509Credentials.popPublicKey.getAlgorithm(),
256                             x509Credentials.popPublicKey);
257                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
258                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
259                             &quot;Unsupported signature algorithm: &quot; +
260                             x509Credentials.popPublicKey.getAlgorithm(), e);
261                 }
262             }
263 
264             try {
265                 updateSignature(signer,
266                         chc.clientHelloRandom.randomBytes,
267                         chc.serverHelloRandom.randomBytes);
268 
269                 if (!signer.verify(paramsSignature)) {
270                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
271                         &quot;Invalid signature on DH ServerKeyExchange message&quot;);
272                 }
273             } catch (SignatureException ex) {
274                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
275                         &quot;Cannot verify DH ServerKeyExchange signature&quot;, ex);
276             }
277         }
278 
279         @Override
280         public SSLHandshake handshakeType() {
281             return SSLHandshake.SERVER_KEY_EXCHANGE;
282         }
283 
284         @Override
285         public int messageLength() {
286             int sigLen = 0;
287             if (paramsSignature != null) {
288                 sigLen = 2 + paramsSignature.length;
289                 if (useExplicitSigAlgorithm) {
290                     sigLen += SignatureScheme.sizeInRecord();
291                 }
292             }
293 
294             return 6 + p.length + g.length + y.length + sigLen;
295                     // 6: overhead for p, g, y values
296         }
297 
298         @Override
299         public void send(HandshakeOutStream hos) throws IOException {
300             hos.putBytes16(p);
301             hos.putBytes16(g);
302             hos.putBytes16(y);
303 
304             if (paramsSignature != null) {
305                 if (useExplicitSigAlgorithm) {
306                     hos.putInt16(signatureScheme.id);
307                 }
308 
309                 hos.putBytes16(paramsSignature);
310             }
311         }
312 
313         @Override
314         public String toString() {
315             if (paramsSignature == null) {    // anonymous
316                 MessageFormat messageFormat = new MessageFormat(
317                     &quot;\&quot;DH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
318                     &quot;  \&quot;parameters\&quot;: &#39;{&#39;\n&quot; +
319                     &quot;    \&quot;dh_p\&quot;: &#39;{&#39;\n&quot; +
320                     &quot;{0}\n&quot; +
321                     &quot;    &#39;}&#39;,\n&quot; +
322                     &quot;    \&quot;dh_g\&quot;: &#39;{&#39;\n&quot; +
323                     &quot;{1}\n&quot; +
324                     &quot;    &#39;}&#39;,\n&quot; +
325                     &quot;    \&quot;dh_Ys\&quot;: &#39;{&#39;\n&quot; +
326                     &quot;{2}\n&quot; +
327                     &quot;    &#39;}&#39;,\n&quot; +
328                     &quot;  &#39;}&#39;\n&quot; +
329                     &quot;&#39;}&#39;&quot;,
330                     Locale.ENGLISH);
331 
332                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
333                 Object[] messageFields = {
334                     Utilities.indent(
335                             hexEncoder.encodeBuffer(p), &quot;      &quot;),
336                     Utilities.indent(
337                             hexEncoder.encodeBuffer(g), &quot;      &quot;),
338                     Utilities.indent(
339                             hexEncoder.encodeBuffer(y), &quot;      &quot;),
340                 };
341 
342                 return messageFormat.format(messageFields);
343             }
344 
345             if (useExplicitSigAlgorithm) {
346                 MessageFormat messageFormat = new MessageFormat(
347                     &quot;\&quot;DH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
348                     &quot;  \&quot;parameters\&quot;: &#39;{&#39;\n&quot; +
349                     &quot;    \&quot;dh_p\&quot;: &#39;{&#39;\n&quot; +
350                     &quot;{0}\n&quot; +
351                     &quot;    &#39;}&#39;,\n&quot; +
352                     &quot;    \&quot;dh_g\&quot;: &#39;{&#39;\n&quot; +
353                     &quot;{1}\n&quot; +
354                     &quot;    &#39;}&#39;,\n&quot; +
355                     &quot;    \&quot;dh_Ys\&quot;: &#39;{&#39;\n&quot; +
356                     &quot;{2}\n&quot; +
357                     &quot;    &#39;}&#39;,\n&quot; +
358                     &quot;  &#39;}&#39;,\n&quot; +
359                     &quot;  \&quot;digital signature\&quot;:  &#39;{&#39;\n&quot; +
360                     &quot;    \&quot;signature algorithm\&quot;: \&quot;{3}\&quot;\n&quot; +
361                     &quot;    \&quot;signature\&quot;: &#39;{&#39;\n&quot; +
362                     &quot;{4}\n&quot; +
363                     &quot;    &#39;}&#39;,\n&quot; +
364                     &quot;  &#39;}&#39;\n&quot; +
365                     &quot;&#39;}&#39;&quot;,
366                     Locale.ENGLISH);
367 
368                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
369                 Object[] messageFields = {
370                     Utilities.indent(
371                             hexEncoder.encodeBuffer(p), &quot;      &quot;),
372                     Utilities.indent(
373                             hexEncoder.encodeBuffer(g), &quot;      &quot;),
374                     Utilities.indent(
375                             hexEncoder.encodeBuffer(y), &quot;      &quot;),
376                     signatureScheme.name,
377                     Utilities.indent(
378                             hexEncoder.encodeBuffer(paramsSignature), &quot;      &quot;)
379                 };
380 
381                 return messageFormat.format(messageFields);
382             } else {
383                 MessageFormat messageFormat = new MessageFormat(
384                     &quot;\&quot;DH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
385                     &quot;  \&quot;parameters\&quot;: &#39;{&#39;\n&quot; +
386                     &quot;    \&quot;dh_p\&quot;: &#39;{&#39;\n&quot; +
387                     &quot;{0}\n&quot; +
388                     &quot;    &#39;}&#39;,\n&quot; +
389                     &quot;    \&quot;dh_g\&quot;: &#39;{&#39;\n&quot; +
390                     &quot;{1}\n&quot; +
391                     &quot;    &#39;}&#39;,\n&quot; +
392                     &quot;    \&quot;dh_Ys\&quot;: &#39;{&#39;\n&quot; +
393                     &quot;{2}\n&quot; +
394                     &quot;    &#39;}&#39;,\n&quot; +
395                     &quot;  &#39;}&#39;,\n&quot; +
396                     &quot;  \&quot;signature\&quot;: &#39;{&#39;\n&quot; +
397                     &quot;{3}\n&quot; +
398                     &quot;  &#39;}&#39;\n&quot; +
399                     &quot;&#39;}&#39;&quot;,
400                     Locale.ENGLISH);
401 
402                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
403                 Object[] messageFields = {
404                     Utilities.indent(
405                             hexEncoder.encodeBuffer(p), &quot;      &quot;),
406                     Utilities.indent(
407                             hexEncoder.encodeBuffer(g), &quot;      &quot;),
408                     Utilities.indent(
409                             hexEncoder.encodeBuffer(y), &quot;      &quot;),
410                     Utilities.indent(
411                             hexEncoder.encodeBuffer(paramsSignature), &quot;    &quot;)
412                 };
413 
414                 return messageFormat.format(messageFields);
415             }
416         }
417 
418         private static Signature getSignature(String keyAlgorithm,
419                 Key key) throws NoSuchAlgorithmException, InvalidKeyException {
420             Signature signer = null;
421             switch (keyAlgorithm) {
422                 case &quot;DSA&quot;:
423                     signer = Signature.getInstance(JsseJce.SIGNATURE_DSA);
424                     break;
425                 case &quot;RSA&quot;:
426                     signer = RSASignature.getInstance();
427                     break;
428                 default:
429                     throw new NoSuchAlgorithmException(
430                         &quot;neither an RSA or a DSA key : &quot; + keyAlgorithm);
431             }
432 
433             if (signer != null) {
434                 if (key instanceof PublicKey) {
435                     signer.initVerify((PublicKey)(key));
436                 } else {
437                     signer.initSign((PrivateKey)key);
438                 }
439             }
440 
441             return signer;
442         }
443 
444         /*
445          * Update sig with nonces and Diffie-Hellman public key.
446          */
447         private void updateSignature(Signature sig, byte[] clntNonce,
448                 byte[] svrNonce) throws SignatureException {
449             int tmp;
450 
451             sig.update(clntNonce);
452             sig.update(svrNonce);
453 
454             sig.update((byte)(p.length &gt;&gt; 8));
455             sig.update((byte)(p.length &amp; 0x0ff));
456             sig.update(p);
457 
458             sig.update((byte)(g.length &gt;&gt; 8));
459             sig.update((byte)(g.length &amp; 0x0ff));
460             sig.update(g);
461 
462             sig.update((byte)(y.length &gt;&gt; 8));
463             sig.update((byte)(y.length &amp; 0x0ff));
464             sig.update(y);
465         }
466     }
467 
468     /**
469      * The DiffieHellman &quot;ServerKeyExchange&quot; handshake message producer.
470      */
471     static final class DHServerKeyExchangeProducer
472             implements HandshakeProducer {
473         // Prevent instantiation of this class.
474         private DHServerKeyExchangeProducer() {
475             // blank
476         }
477 
478         @Override
479         public byte[] produce(ConnectionContext context,
480                 HandshakeMessage message) throws IOException {
481             // The producing happens in server side only.
482             ServerHandshakeContext shc = (ServerHandshakeContext)context;
483             DHServerKeyExchangeMessage skem =
484                     new DHServerKeyExchangeMessage(shc);
485             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
486                 SSLLogger.fine(
487                     &quot;Produced DH ServerKeyExchange handshake message&quot;, skem);
488             }
489 
490             // Output the handshake message.
491             skem.write(shc.handshakeOutput);
492             shc.handshakeOutput.flush();
493 
494             // The handshake message has been delivered.
495             return null;
496         }
497     }
498 
499     /**
500      * The DiffieHellman &quot;ServerKeyExchange&quot; handshake message consumer.
501      */
502     static final class DHServerKeyExchangeConsumer implements SSLConsumer {
503         // Prevent instantiation of this class.
504         private DHServerKeyExchangeConsumer() {
505             // blank
506         }
507 
508         @Override
509         public void consume(ConnectionContext context,
510                 ByteBuffer message) throws IOException {
511             // The consuming happens in client side only.
512             ClientHandshakeContext chc = (ClientHandshakeContext)context;
513 
514             DHServerKeyExchangeMessage skem =
515                     new DHServerKeyExchangeMessage(chc, message);
516             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
517                 SSLLogger.fine(
518                     &quot;Consuming DH ServerKeyExchange handshake message&quot;, skem);
519             }
520 
521             //
522             // validate
523             //
524             // check constraints of EC PublicKey
525             DHPublicKey publicKey;
526             try {
527                 KeyFactory kf = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
528                 DHPublicKeySpec spec = new DHPublicKeySpec(
529                         new BigInteger(1, skem.y),
530                         new BigInteger(1, skem.p),
531                         new BigInteger(1, skem.g));
532                 publicKey = (DHPublicKey)kf.generatePublic(spec);
533             } catch (GeneralSecurityException gse) {
534                 throw chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,
535                     &quot;Could not generate DHPublicKey&quot;, gse);
536             }
537 
538             if (!chc.algorithmConstraints.permits(
539                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), publicKey)) {
540                 throw chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,
541                         &quot;DH ServerKeyExchange does not comply to &quot; +
542                         &quot;algorithm constraints&quot;);
543             }
544 
545             //
546             // update
547             //
548             NamedGroup namedGroup = NamedGroup.valueOf(publicKey.getParams());
549             chc.handshakeCredentials.add(
550                     new DHECredentials(publicKey, namedGroup));
551 
552             //
553             // produce
554             //
555             // Need no new handshake message producers here.
556         }
557     }
558 }
559 
    </pre>
  </body>
</html>
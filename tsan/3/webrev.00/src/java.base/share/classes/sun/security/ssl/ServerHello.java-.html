<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/ServerHello.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.AlgorithmConstraints;
  31 import java.security.GeneralSecurityException;
  32 import java.text.MessageFormat;
  33 import java.util.Arrays;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Locale;
  37 import java.util.Map;
  38 import java.util.Optional;
  39 import javax.crypto.SecretKey;
  40 import javax.crypto.spec.IvParameterSpec;
  41 import javax.net.ssl.SSLException;
  42 import javax.net.ssl.SSLHandshakeException;
  43 import javax.net.ssl.SSLProtocolException;
  44 import sun.security.ssl.CipherSuite.KeyExchange;
  45 import sun.security.ssl.ClientHello.ClientHelloMessage;
  46 import sun.security.ssl.SSLCipher.SSLReadCipher;
  47 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  49 import sun.security.ssl.SupportedVersionsExtension.SHSupportedVersionsSpec;
  50 
  51 /**
  52  * Pack of the ServerHello/HelloRetryRequest handshake message.
  53  */
  54 final class ServerHello {
  55     static final SSLConsumer handshakeConsumer =
  56         new ServerHelloConsumer();
  57     static final HandshakeProducer t12HandshakeProducer =
  58         new T12ServerHelloProducer();
  59     static final HandshakeProducer t13HandshakeProducer =
  60         new T13ServerHelloProducer();
  61     static final HandshakeProducer hrrHandshakeProducer =
  62         new T13HelloRetryRequestProducer();
  63 
  64     static final HandshakeProducer hrrReproducer =
  65         new T13HelloRetryRequestReproducer();
  66 
  67     private static final HandshakeConsumer t12HandshakeConsumer =
  68         new T12ServerHelloConsumer();
  69     private static final HandshakeConsumer t13HandshakeConsumer =
  70         new T13ServerHelloConsumer();
  71 
  72     private static final HandshakeConsumer d12HandshakeConsumer =
  73         new T12ServerHelloConsumer();
  74     private static final HandshakeConsumer d13HandshakeConsumer =
  75         new T13ServerHelloConsumer();
  76 
  77     private static final HandshakeConsumer t13HrrHandshakeConsumer =
  78         new T13HelloRetryRequestConsumer();
  79     private static final HandshakeConsumer d13HrrHandshakeConsumer =
  80         new T13HelloRetryRequestConsumer();
  81 
  82     /**
  83      * The ServerHello handshake message.
  84      */
  85     static final class ServerHelloMessage extends HandshakeMessage {
  86         final ProtocolVersion           serverVersion;      // TLS 1.3 legacy
  87         final RandomCookie              serverRandom;
  88         final SessionId                 sessionId;          // TLS 1.3 legacy
  89         final CipherSuite               cipherSuite;
  90         final byte                      compressionMethod;  // TLS 1.3 legacy
  91         final SSLExtensions             extensions;
  92 
  93         // The HelloRetryRequest producer needs to use the ClientHello message
  94         // for cookie generation.  Please don&#39;t use this field for other
  95         // purpose unless it is really necessary.
  96         final ClientHelloMessage        clientHello;
  97 
  98         // Reserved for HelloRetryRequest consumer.  Please don&#39;t use this
  99         // field for other purpose unless it is really necessary.
 100         final ByteBuffer                handshakeRecord;
 101 
 102         ServerHelloMessage(HandshakeContext context,
 103                 ProtocolVersion serverVersion, SessionId sessionId,
 104                 CipherSuite cipherSuite, RandomCookie serverRandom,
 105                 ClientHelloMessage clientHello) {
 106             super(context);
 107 
 108             this.serverVersion = serverVersion;
 109             this.serverRandom = serverRandom;
 110             this.sessionId = sessionId;
 111             this.cipherSuite = cipherSuite;
 112             this.compressionMethod = 0x00;      // Don&#39;t support compression.
 113             this.extensions = new SSLExtensions(this);
 114 
 115             // Reserve the ClientHello message for cookie generation.
 116             this.clientHello = clientHello;
 117 
 118             // The handshakeRecord field is used for HelloRetryRequest consumer
 119             // only.  It&#39;s fine to set it to null for generating side of the
 120             // ServerHello/HelloRetryRequest message.
 121             this.handshakeRecord = null;
 122         }
 123 
 124         ServerHelloMessage(HandshakeContext context,
 125                 ByteBuffer m) throws IOException {
 126             super(context);
 127 
 128             // Reserve for HelloRetryRequest consumer if needed.
 129             this.handshakeRecord = m.duplicate();
 130 
 131             byte major = m.get();
 132             byte minor = m.get();
 133             this.serverVersion = ProtocolVersion.valueOf(major, minor);
 134             if (this.serverVersion == null) {
 135                 // The client should only request for known protocol versions.
 136                 throw context.conContext.fatal(Alert.PROTOCOL_VERSION,
 137                     &quot;Unsupported protocol version: &quot; +
 138                     ProtocolVersion.nameOf(major, minor));
 139             }
 140 
 141             this.serverRandom = new RandomCookie(m);
 142             this.sessionId = new SessionId(Record.getBytes8(m));
 143             try {
 144                 sessionId.checkLength(serverVersion.id);
 145             } catch (SSLProtocolException ex) {
 146                 throw handshakeContext.conContext.fatal(
 147                         Alert.ILLEGAL_PARAMETER, ex);
 148             }
 149 
 150             int cipherSuiteId = Record.getInt16(m);
 151             this.cipherSuite = CipherSuite.valueOf(cipherSuiteId);
 152             if (cipherSuite == null || !context.isNegotiable(cipherSuite)) {
 153                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 154                     &quot;Server selected improper ciphersuite &quot; +
 155                     CipherSuite.nameOf(cipherSuiteId));
 156             }
 157 
 158             this.compressionMethod = m.get();
 159             if (compressionMethod != 0) {
 160                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 161                     &quot;compression type not supported, &quot; + compressionMethod);
 162             }
 163 
 164             SSLExtension[] supportedExtensions;
 165             if (serverRandom.isHelloRetryRequest()) {
 166                 supportedExtensions = context.sslConfig.getEnabledExtensions(
 167                             SSLHandshake.HELLO_RETRY_REQUEST);
 168             } else {
 169                 supportedExtensions = context.sslConfig.getEnabledExtensions(
 170                             SSLHandshake.SERVER_HELLO);
 171             }
 172 
 173             if (m.hasRemaining()) {
 174                 this.extensions =
 175                     new SSLExtensions(this, m, supportedExtensions);
 176             } else {
 177                 this.extensions = new SSLExtensions(this);
 178             }
 179 
 180             // The clientHello field is used for HelloRetryRequest producer
 181             // only.  It&#39;s fine to set it to null for receiving side of
 182             // ServerHello/HelloRetryRequest message.
 183             this.clientHello = null;        // not used, let it be null;
 184         }
 185 
 186         @Override
 187         public SSLHandshake handshakeType() {
 188             return serverRandom.isHelloRetryRequest() ?
 189                 SSLHandshake.HELLO_RETRY_REQUEST : SSLHandshake.SERVER_HELLO;
 190         }
 191 
 192         @Override
 193         public int messageLength() {
 194             // almost fixed header size, except session ID and extensions:
 195             //      major + minor = 2
 196             //      random = 32
 197             //      session ID len field = 1
 198             //      cipher suite = 2
 199             //      compression = 1
 200             //      extensions: if present, 2 + length of extensions
 201             // In TLS 1.3, use of certain extensions is mandatory.
 202             return 38 + sessionId.length() + extensions.length();
 203         }
 204 
 205         @Override
 206         public void send(HandshakeOutStream hos) throws IOException {
 207             hos.putInt8(serverVersion.major);
 208             hos.putInt8(serverVersion.minor);
 209             hos.write(serverRandom.randomBytes);
 210             hos.putBytes8(sessionId.getId());
 211             hos.putInt8((cipherSuite.id &gt;&gt; 8) &amp; 0xFF);
 212             hos.putInt8(cipherSuite.id &amp; 0xff);
 213             hos.putInt8(compressionMethod);
 214 
 215             extensions.send(hos);           // In TLS 1.3, use of certain
 216                                             // extensions is mandatory.
 217         }
 218 
 219         @Override
 220         public String toString() {
 221             MessageFormat messageFormat = new MessageFormat(
 222                 &quot;\&quot;{0}\&quot;: &#39;{&#39;\n&quot; +
 223                 &quot;  \&quot;server version\&quot;      : \&quot;{1}\&quot;,\n&quot; +
 224                 &quot;  \&quot;random\&quot;              : \&quot;{2}\&quot;,\n&quot; +
 225                 &quot;  \&quot;session id\&quot;          : \&quot;{3}\&quot;,\n&quot; +
 226                 &quot;  \&quot;cipher suite\&quot;        : \&quot;{4}\&quot;,\n&quot; +
 227                 &quot;  \&quot;compression methods\&quot; : \&quot;{5}\&quot;,\n&quot; +
 228                 &quot;  \&quot;extensions\&quot;          : [\n&quot; +
 229                 &quot;{6}\n&quot; +
 230                 &quot;  ]\n&quot; +
 231                 &quot;&#39;}&#39;&quot;,
 232                 Locale.ENGLISH);
 233             Object[] messageFields = {
 234                 serverRandom.isHelloRetryRequest() ?
 235                     &quot;HelloRetryRequest&quot; : &quot;ServerHello&quot;,
 236                 serverVersion.name,
 237                 Utilities.toHexString(serverRandom.randomBytes),
 238                 sessionId.toString(),
 239                 cipherSuite.name + &quot;(&quot; +
 240                         Utilities.byte16HexString(cipherSuite.id) + &quot;)&quot;,
 241                 Utilities.toHexString(compressionMethod),
 242                 Utilities.indent(extensions.toString(), &quot;    &quot;)
 243             };
 244 
 245             return messageFormat.format(messageFields);
 246         }
 247     }
 248 
 249     /**
 250      * The &quot;ServerHello&quot; handshake message producer.
 251      */
 252     private static final class T12ServerHelloProducer
 253             implements HandshakeProducer {
 254 
 255         // Prevent instantiation of this class.
 256         private T12ServerHelloProducer() {
 257             // blank
 258         }
 259 
 260         @Override
 261         public byte[] produce(ConnectionContext context,
 262                 HandshakeMessage message) throws IOException {
 263             // The producing happens in server side only.
 264             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 265             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 266 
 267             // If client hasn&#39;t specified a session we can resume, start a
 268             // new one and choose its cipher suite and compression options,
 269             // unless new session creation is disabled for this connection!
 270             if (!shc.isResumption || shc.resumingSession == null) {
 271                 if (!shc.sslConfig.enableSessionCreation) {
 272                     throw new SSLException(
 273                         &quot;Not resumption, and no new session is allowed&quot;);
 274                 }
 275 
 276                 if (shc.localSupportedSignAlgs == null) {
 277                     shc.localSupportedSignAlgs =
 278                         SignatureScheme.getSupportedAlgorithms(
 279                                 shc.algorithmConstraints, shc.activeProtocols);
 280                 }
 281 
 282                 SSLSessionImpl session =
 283                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 284                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 285                 shc.handshakeSession = session;
 286 
 287                 // consider the handshake extension impact
 288                 SSLExtension[] enabledExtensions =
 289                         shc.sslConfig.getEnabledExtensions(
 290                             SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 291                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 292 
 293                 // negotiate the cipher suite.
 294                 KeyExchangeProperties credentials =
 295                         chooseCipherSuite(shc, clientHello);
 296                 if (credentials == null) {
 297                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 298                             &quot;no cipher suites in common&quot;);
 299                 }
 300                 shc.negotiatedCipherSuite = credentials.cipherSuite;
 301                 shc.handshakeKeyExchange = credentials.keyExchange;
 302                 shc.handshakeSession.setSuite(credentials.cipherSuite);
 303                 shc.handshakePossessions.addAll(
 304                         Arrays.asList(credentials.possessions));
 305                 shc.handshakeHash.determine(
 306                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 307 
 308                 // Check the incoming OCSP stapling extensions and attempt
 309                 // to get responses.  If the resulting stapleParams is non
 310                 // null, it implies that stapling is enabled on the server side.
 311                 shc.stapleParams = StatusResponseManager.processStapling(shc);
 312                 shc.staplingActive = (shc.stapleParams != null);
 313 
 314                 // update the responders
 315                 SSLKeyExchange ke = credentials.keyExchange;
 316                 if (ke != null) {
 317                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
 318                             ke.getHandshakeProducers(shc)) {
 319                         shc.handshakeProducers.put(
 320                                 me.getKey(), me.getValue());
 321                     }
 322                 }
 323 
 324                 if ((ke != null) &amp;&amp;
 325                         (shc.sslConfig.clientAuthType !=
 326                                 ClientAuthType.CLIENT_AUTH_NONE) &amp;&amp;
 327                         !shc.negotiatedCipherSuite.isAnonymous()) {
 328                     for (SSLHandshake hs :
 329                             ke.getRelatedHandshakers(shc)) {
 330                         if (hs == SSLHandshake.CERTIFICATE) {
 331                             shc.handshakeProducers.put(
 332                                     SSLHandshake.CERTIFICATE_REQUEST.id,
 333                                     SSLHandshake.CERTIFICATE_REQUEST);
 334                             break;
 335                         }
 336                     }
 337                 }
 338                 shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO_DONE.id,
 339                         SSLHandshake.SERVER_HELLO_DONE);
 340             } else {
 341                 shc.handshakeSession = shc.resumingSession;
 342                 shc.negotiatedProtocol =
 343                         shc.resumingSession.getProtocolVersion();
 344                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 345                 shc.handshakeHash.determine(
 346                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 347             }
 348 
 349             // Generate the ServerHello handshake message.
 350             ServerHelloMessage shm = new ServerHelloMessage(shc,
 351                     shc.negotiatedProtocol,
 352                     shc.handshakeSession.getSessionId(),
 353                     shc.negotiatedCipherSuite,
 354                     new RandomCookie(shc),
 355                     clientHello);
 356             shc.serverHelloRandom = shm.serverRandom;
 357 
 358             // Produce extensions for ServerHello handshake message.
 359             SSLExtension[] serverHelloExtensions =
 360                 shc.sslConfig.getEnabledExtensions(
 361                         SSLHandshake.SERVER_HELLO, shc.negotiatedProtocol);
 362             shm.extensions.produce(shc, serverHelloExtensions);
 363             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 364                 SSLLogger.fine(&quot;Produced ServerHello handshake message&quot;, shm);
 365             }
 366 
 367             // Output the handshake message.
 368             shm.write(shc.handshakeOutput);
 369             shc.handshakeOutput.flush();
 370 
 371             if (shc.isResumption &amp;&amp; shc.resumingSession != null) {
 372                 SSLTrafficKeyDerivation kdg =
 373                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 374                 if (kdg == null) {
 375                     // unlikely
 376                     throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 377                             &quot;Not supported key derivation: &quot; +
 378                             shc.negotiatedProtocol);
 379                 } else {
 380                     shc.handshakeKeyDerivation = kdg.createKeyDerivation(
 381                             shc, shc.resumingSession.getMasterSecret());
 382                 }
 383 
 384                 // update the responders
 385                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 386                         SSLHandshake.FINISHED);
 387             }
 388 
 389             // The handshake message has been delivered.
 390             return null;
 391         }
 392 
 393         private static KeyExchangeProperties chooseCipherSuite(
 394                 ServerHandshakeContext shc,
 395                 ClientHelloMessage clientHello) throws IOException {
 396             List&lt;CipherSuite&gt; preferred;
 397             List&lt;CipherSuite&gt; proposed;
 398             if (shc.sslConfig.preferLocalCipherSuites) {
 399                 preferred = shc.activeCipherSuites;
 400                 proposed = clientHello.cipherSuites;
 401             } else {
 402                 preferred = clientHello.cipherSuites;
 403                 proposed = shc.activeCipherSuites;
 404             }
 405 
 406             List&lt;CipherSuite&gt; legacySuites = new LinkedList&lt;&gt;();
 407             for (CipherSuite cs : preferred) {
 408                 if (!HandshakeContext.isNegotiable(
 409                         proposed, shc.negotiatedProtocol, cs)) {
 410                     continue;
 411                 }
 412 
 413                 if (shc.sslConfig.clientAuthType ==
 414                         ClientAuthType.CLIENT_AUTH_REQUIRED) {
 415                     if ((cs.keyExchange == KeyExchange.K_DH_ANON) ||
 416                         (cs.keyExchange == KeyExchange.K_ECDH_ANON)) {
 417                         continue;
 418                     }
 419                 }
 420 
 421                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 422                         cs.keyExchange, shc.negotiatedProtocol);
 423                 if (ke == null) {
 424                     continue;
 425                 }
 426                 if (!ServerHandshakeContext.legacyAlgorithmConstraints.permits(
 427                         null, cs.name, null)) {
 428                     legacySuites.add(cs);
 429                     continue;
 430                 }
 431 
 432                 SSLPossession[] hcds = ke.createPossessions(shc);
 433                 if ((hcds == null) || (hcds.length == 0)) {
 434                     continue;
 435                 }
 436 
 437                 // The cipher suite has been negotiated.
 438                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 439                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 440                 }
 441 
 442                 return new KeyExchangeProperties(cs, ke, hcds);
 443             }
 444 
 445             for (CipherSuite cs : legacySuites) {
 446                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 447                         cs.keyExchange,  shc.negotiatedProtocol);
 448                 if (ke != null) {
 449                     SSLPossession[] hcds = ke.createPossessions(shc);
 450                     if ((hcds != null) &amp;&amp; (hcds.length != 0)) {
 451                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 452                             SSLLogger.warning(
 453                                 &quot;use legacy cipher suite &quot; + cs.name);
 454                         }
 455                         return new KeyExchangeProperties(cs, ke, hcds);
 456                     }
 457                 }
 458             }
 459 
 460             throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 461                     &quot;no cipher suites in common&quot;);
 462         }
 463 
 464         private static final class KeyExchangeProperties {
 465             final CipherSuite cipherSuite;
 466             final SSLKeyExchange keyExchange;
 467             final SSLPossession[] possessions;
 468 
 469             private KeyExchangeProperties(CipherSuite cipherSuite,
 470                     SSLKeyExchange keyExchange, SSLPossession[] possessions) {
 471                 this.cipherSuite = cipherSuite;
 472                 this.keyExchange = keyExchange;
 473                 this.possessions = possessions;
 474             }
 475         }
 476     }
 477 
 478     /**
 479      * The &quot;ServerHello&quot; handshake message producer.
 480      */
 481     private static final
 482             class T13ServerHelloProducer implements HandshakeProducer {
 483         // Prevent instantiation of this class.
 484         private T13ServerHelloProducer() {
 485             // blank
 486         }
 487 
 488         @Override
 489         public byte[] produce(ConnectionContext context,
 490                 HandshakeMessage message) throws IOException {
 491             // The producing happens in server side only.
 492             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 493             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 494 
 495             // If client hasn&#39;t specified a session we can resume, start a
 496             // new one and choose its cipher suite and compression options,
 497             // unless new session creation is disabled for this connection!
 498             if (!shc.isResumption || shc.resumingSession == null) {
 499                 if (!shc.sslConfig.enableSessionCreation) {
 500                     throw new SSLException(
 501                         &quot;Not resumption, and no new session is allowed&quot;);
 502                 }
 503 
 504                 if (shc.localSupportedSignAlgs == null) {
 505                     shc.localSupportedSignAlgs =
 506                         SignatureScheme.getSupportedAlgorithms(
 507                                 shc.algorithmConstraints, shc.activeProtocols);
 508                 }
 509 
 510                 SSLSessionImpl session =
 511                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 512                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 513                 shc.handshakeSession = session;
 514 
 515                 // consider the handshake extension impact
 516                 SSLExtension[] enabledExtensions =
 517                         shc.sslConfig.getEnabledExtensions(
 518                             SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 519                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 520 
 521                 // negotiate the cipher suite.
 522                 CipherSuite cipherSuite = chooseCipherSuite(shc, clientHello);
 523                 if (cipherSuite == null) {
 524                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 525                             &quot;no cipher suites in common&quot;);
 526                 }
 527                 shc.negotiatedCipherSuite = cipherSuite;
 528                 shc.handshakeSession.setSuite(cipherSuite);
 529                 shc.handshakeHash.determine(
 530                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 531             } else {
 532                 shc.handshakeSession = shc.resumingSession;
 533 
 534                 // consider the handshake extension impact
 535                 SSLExtension[] enabledExtensions =
 536                 shc.sslConfig.getEnabledExtensions(
 537                 SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 538                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 539 
 540                 shc.negotiatedProtocol =
 541                         shc.resumingSession.getProtocolVersion();
 542                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 543                 shc.handshakeHash.determine(
 544                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 545 
 546                 setUpPskKD(shc,
 547                         shc.resumingSession.consumePreSharedKey().get());
 548 
 549                 // The session can&#39;t be resumed again---remove it from cache
 550                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
 551                     shc.sslContext.engineGetServerSessionContext();
 552                 sessionCache.remove(shc.resumingSession.getSessionId());
 553             }
 554 
 555             // update the responders
 556             shc.handshakeProducers.put(SSLHandshake.ENCRYPTED_EXTENSIONS.id,
 557                     SSLHandshake.ENCRYPTED_EXTENSIONS);
 558             shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 559                     SSLHandshake.FINISHED);
 560 
 561             // Generate the ServerHello handshake message.
 562             ServerHelloMessage shm = new ServerHelloMessage(shc,
 563                     ProtocolVersion.TLS12,      // use legacy version
 564                     clientHello.sessionId,      // echo back
 565                     shc.negotiatedCipherSuite,
 566                     new RandomCookie(shc),
 567                     clientHello);
 568             shc.serverHelloRandom = shm.serverRandom;
 569 
 570             // Produce extensions for ServerHello handshake message.
 571             SSLExtension[] serverHelloExtensions =
 572                     shc.sslConfig.getEnabledExtensions(
 573                         SSLHandshake.SERVER_HELLO, shc.negotiatedProtocol);
 574             shm.extensions.produce(shc, serverHelloExtensions);
 575             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 576                 SSLLogger.fine(&quot;Produced ServerHello handshake message&quot;, shm);
 577             }
 578 
 579             // Output the handshake message.
 580             shm.write(shc.handshakeOutput);
 581             shc.handshakeOutput.flush();
 582 
 583             // Change client/server handshake traffic secrets.
 584             // Refresh handshake hash
 585             shc.handshakeHash.update();
 586 
 587             // Change client/server handshake traffic secrets.
 588             SSLKeyExchange ke = shc.handshakeKeyExchange;
 589             if (ke == null) {
 590                 // unlikely
 591                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 592                         &quot;Not negotiated key shares&quot;);
 593             }
 594 
 595             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);
 596             SecretKey handshakeSecret = handshakeKD.deriveKey(
 597                     &quot;TlsHandshakeSecret&quot;, null);
 598 
 599             SSLTrafficKeyDerivation kdg =
 600                 SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 601             if (kdg == null) {
 602                 // unlikely
 603                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 604                         &quot;Not supported key derivation: &quot; +
 605                         shc.negotiatedProtocol);
 606             }
 607 
 608             SSLKeyDerivation kd =
 609                     new SSLSecretDerivation(shc, handshakeSecret);
 610 
 611             // update the handshake traffic read keys.
 612             SecretKey readSecret = kd.deriveKey(
 613                     &quot;TlsClientHandshakeTrafficSecret&quot;, null);
 614             SSLKeyDerivation readKD =
 615                     kdg.createKeyDerivation(shc, readSecret);
 616             SecretKey readKey = readKD.deriveKey(
 617                     &quot;TlsKey&quot;, null);
 618             SecretKey readIvSecret = readKD.deriveKey(
 619                     &quot;TlsIv&quot;, null);
 620             IvParameterSpec readIv =
 621                     new IvParameterSpec(readIvSecret.getEncoded());
 622             SSLReadCipher readCipher;
 623             try {
 624                 readCipher =
 625                     shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
 626                         Authenticator.valueOf(shc.negotiatedProtocol),
 627                         shc.negotiatedProtocol, readKey, readIv,
 628                         shc.sslContext.getSecureRandom());
 629             } catch (GeneralSecurityException gse) {
 630                 // unlikely
 631                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 632                         &quot;Missing cipher algorithm&quot;, gse);
 633             }
 634 
 635             if (readCipher == null) {
 636                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 637                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 638                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 639                     &quot;)&quot;);
 640             }
 641 
 642             shc.baseReadSecret = readSecret;
 643             shc.conContext.inputRecord.changeReadCiphers(readCipher);
 644 
 645             // update the handshake traffic write secret.
 646             SecretKey writeSecret = kd.deriveKey(
 647                     &quot;TlsServerHandshakeTrafficSecret&quot;, null);
 648             SSLKeyDerivation writeKD =
 649                     kdg.createKeyDerivation(shc, writeSecret);
 650             SecretKey writeKey = writeKD.deriveKey(
 651                     &quot;TlsKey&quot;, null);
 652             SecretKey writeIvSecret = writeKD.deriveKey(
 653                     &quot;TlsIv&quot;, null);
 654             IvParameterSpec writeIv =
 655                     new IvParameterSpec(writeIvSecret.getEncoded());
 656             SSLWriteCipher writeCipher;
 657             try {
 658                 writeCipher =
 659                     shc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 660                         Authenticator.valueOf(shc.negotiatedProtocol),
 661                         shc.negotiatedProtocol, writeKey, writeIv,
 662                         shc.sslContext.getSecureRandom());
 663             } catch (GeneralSecurityException gse) {
 664                 // unlikely
 665                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 666                         &quot;Missing cipher algorithm&quot;, gse);
 667             }
 668 
 669             if (writeCipher == null) {
 670                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 671                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 672                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 673                     &quot;)&quot;);
 674             }
 675 
 676             shc.baseWriteSecret = writeSecret;
 677             shc.conContext.outputRecord.changeWriteCiphers(
 678                     writeCipher, (clientHello.sessionId.length() != 0));
 679 
 680             // Update the context for master key derivation.
 681             shc.handshakeKeyDerivation = kd;
 682 
 683             // The handshake message has been delivered.
 684             return null;
 685         }
 686 
 687         private static CipherSuite chooseCipherSuite(
 688                 ServerHandshakeContext shc,
 689                 ClientHelloMessage clientHello) throws IOException {
 690             List&lt;CipherSuite&gt; preferred;
 691             List&lt;CipherSuite&gt; proposed;
 692             if (shc.sslConfig.preferLocalCipherSuites) {
 693                 preferred = shc.activeCipherSuites;
 694                 proposed = clientHello.cipherSuites;
 695             } else {
 696                 preferred = clientHello.cipherSuites;
 697                 proposed = shc.activeCipherSuites;
 698             }
 699 
 700             CipherSuite legacySuite = null;
 701             AlgorithmConstraints legacyConstraints =
 702                     ServerHandshakeContext.legacyAlgorithmConstraints;
 703             for (CipherSuite cs : preferred) {
 704                 if (!HandshakeContext.isNegotiable(
 705                         proposed, shc.negotiatedProtocol, cs)) {
 706                     continue;
 707                 }
 708 
 709                 if ((legacySuite == null) &amp;&amp;
 710                         !legacyConstraints.permits(null, cs.name, null)) {
 711                     legacySuite = cs;
 712                     continue;
 713                 }
 714 
 715                 // The cipher suite has been negotiated.
 716                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 717                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 718                 }
 719                 return cs;
 720             }
 721 
 722             if (legacySuite != null) {
 723                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 724                     SSLLogger.warning(
 725                             &quot;use legacy cipher suite &quot; + legacySuite.name);
 726                 }
 727                 return legacySuite;
 728             }
 729 
 730             // no cipher suites in common
 731             return null;
 732         }
 733     }
 734 
 735     /**
 736      * The &quot;HelloRetryRequest&quot; handshake message producer.
 737      */
 738     private static final
 739             class T13HelloRetryRequestProducer implements HandshakeProducer {
 740         // Prevent instantiation of this class.
 741         private T13HelloRetryRequestProducer() {
 742             // blank
 743         }
 744 
 745         @Override
 746         public byte[] produce(ConnectionContext context,
 747                 HandshakeMessage message) throws IOException {
 748             ServerHandshakeContext shc = (ServerHandshakeContext) context;
 749             ClientHelloMessage clientHello = (ClientHelloMessage) message;
 750 
 751             // negotiate the cipher suite.
 752             CipherSuite cipherSuite =
 753                     T13ServerHelloProducer.chooseCipherSuite(shc, clientHello);
 754             if (cipherSuite == null) {
 755                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 756                         &quot;no cipher suites in common for hello retry request&quot;);
 757             }
 758 
 759             ServerHelloMessage hhrm = new ServerHelloMessage(shc,
 760                     ProtocolVersion.TLS12,      // use legacy version
 761                     clientHello.sessionId,      //  echo back
 762                     cipherSuite,
 763                     RandomCookie.hrrRandom,
 764                     clientHello
 765             );
 766 
 767             shc.negotiatedCipherSuite = cipherSuite;
 768             shc.handshakeHash.determine(
 769                     shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 770 
 771             // Produce extensions for HelloRetryRequest handshake message.
 772             SSLExtension[] serverHelloExtensions =
 773                 shc.sslConfig.getEnabledExtensions(
 774                     SSLHandshake.HELLO_RETRY_REQUEST, shc.negotiatedProtocol);
 775             hhrm.extensions.produce(shc, serverHelloExtensions);
 776             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 777                 SSLLogger.fine(
 778                         &quot;Produced HelloRetryRequest handshake message&quot;, hhrm);
 779             }
 780 
 781             // Output the handshake message.
 782             hhrm.write(shc.handshakeOutput);
 783             shc.handshakeOutput.flush();
 784 
 785             // Stateless, shall we clean up the handshake context as well?
 786             shc.handshakeHash.finish();     // forgot about the handshake hash
 787             shc.handshakeExtensions.clear();
 788 
 789             // What&#39;s the expected response?
 790             shc.handshakeConsumers.put(
 791                     SSLHandshake.CLIENT_HELLO.id, SSLHandshake.CLIENT_HELLO);
 792 
 793             // The handshake message has been delivered.
 794             return null;
 795         }
 796     }
 797 
 798     /**
 799      * The &quot;HelloRetryRequest&quot; handshake message reproducer.
 800      */
 801     private static final
 802             class T13HelloRetryRequestReproducer implements HandshakeProducer {
 803         // Prevent instantiation of this class.
 804         private T13HelloRetryRequestReproducer() {
 805             // blank
 806         }
 807 
 808         @Override
 809         public byte[] produce(ConnectionContext context,
 810                 HandshakeMessage message) throws IOException {
 811             ServerHandshakeContext shc = (ServerHandshakeContext) context;
 812             ClientHelloMessage clientHello = (ClientHelloMessage) message;
 813 
 814             // negotiate the cipher suite.
 815             CipherSuite cipherSuite = shc.negotiatedCipherSuite;
 816             ServerHelloMessage hhrm = new ServerHelloMessage(shc,
 817                     ProtocolVersion.TLS12,      // use legacy version
 818                     clientHello.sessionId,      //  echo back
 819                     cipherSuite,
 820                     RandomCookie.hrrRandom,
 821                     clientHello
 822             );
 823 
 824             // Produce extensions for HelloRetryRequest handshake message.
 825             SSLExtension[] serverHelloExtensions =
 826                 shc.sslConfig.getEnabledExtensions(
 827                     SSLHandshake.MESSAGE_HASH, shc.negotiatedProtocol);
 828             hhrm.extensions.produce(shc, serverHelloExtensions);
 829             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 830                 SSLLogger.fine(
 831                         &quot;Reproduced HelloRetryRequest handshake message&quot;, hhrm);
 832             }
 833 
 834             HandshakeOutStream hos = new HandshakeOutStream(null);
 835             hhrm.write(hos);
 836 
 837             return hos.toByteArray();
 838         }
 839     }
 840 
 841     /**
 842      * The &quot;ServerHello&quot; handshake message consumer.
 843      */
 844     private static final
 845             class ServerHelloConsumer implements SSLConsumer {
 846         // Prevent instantiation of this class.
 847         private ServerHelloConsumer() {
 848             // blank
 849         }
 850 
 851         @Override
 852         public void consume(ConnectionContext context,
 853                 ByteBuffer message) throws IOException {
 854             // The consuming happens in client side only.
 855             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 856 
 857             // clean up this consumer
 858             chc.handshakeConsumers.remove(SSLHandshake.SERVER_HELLO.id);
 859             if (!chc.handshakeConsumers.isEmpty()) {
 860                 // DTLS 1.0/1.2
 861                 chc.handshakeConsumers.remove(
 862                         SSLHandshake.HELLO_VERIFY_REQUEST.id);
 863             }
 864             if (!chc.handshakeConsumers.isEmpty()) {
 865                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 866                     &quot;No more message expected before ServerHello is processed&quot;);
 867             }
 868 
 869             ServerHelloMessage shm = new ServerHelloMessage(chc, message);
 870             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 871                 SSLLogger.fine(&quot;Consuming ServerHello handshake message&quot;, shm);
 872             }
 873 
 874             if (shm.serverRandom.isHelloRetryRequest()) {
 875                 onHelloRetryRequest(chc, shm);
 876             } else {
 877                 onServerHello(chc, shm);
 878             }
 879         }
 880 
 881         private void onHelloRetryRequest(ClientHandshakeContext chc,
 882                 ServerHelloMessage helloRetryRequest) throws IOException {
 883             // Negotiate protocol version.
 884             //
 885             // Check and launch SupportedVersions.
 886             SSLExtension[] extTypes = new SSLExtension[] {
 887                     SSLExtension.HRR_SUPPORTED_VERSIONS
 888                 };
 889             helloRetryRequest.extensions.consumeOnLoad(chc, extTypes);
 890 
 891             ProtocolVersion serverVersion;
 892             SHSupportedVersionsSpec svs =
 893                     (SHSupportedVersionsSpec)chc.handshakeExtensions.get(
 894                             SSLExtension.HRR_SUPPORTED_VERSIONS);
 895             if (svs != null) {
 896                 serverVersion =            // could be null
 897                         ProtocolVersion.valueOf(svs.selectedVersion);
 898             } else {
 899                 serverVersion = helloRetryRequest.serverVersion;
 900             }
 901 
 902             if (!chc.activeProtocols.contains(serverVersion)) {
 903                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 904                     &quot;The server selected protocol version &quot; + serverVersion +
 905                     &quot; is not accepted by client preferences &quot; +
 906                     chc.activeProtocols);
 907             }
 908 
 909             if (!serverVersion.useTLS13PlusSpec()) {
 910                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 911                     &quot;Unexpected HelloRetryRequest for &quot; + serverVersion.name);
 912             }
 913 
 914             chc.negotiatedProtocol = serverVersion;
 915             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 916                 SSLLogger.fine(
 917                     &quot;Negotiated protocol version: &quot; + serverVersion.name);
 918             }
 919 
 920             // TLS 1.3 key share extension may have produced client
 921             // possessions for TLS 1.3 key exchanges.
 922             //
 923             // Clean up before producing new client key share possessions.
 924             chc.handshakePossessions.clear();
 925 
 926             if (serverVersion.isDTLS) {
 927                 d13HrrHandshakeConsumer.consume(chc, helloRetryRequest);
 928             } else {
 929                 t13HrrHandshakeConsumer.consume(chc, helloRetryRequest);
 930             }
 931         }
 932 
 933         private void onServerHello(ClientHandshakeContext chc,
 934                 ServerHelloMessage serverHello) throws IOException {
 935             // Negotiate protocol version.
 936             //
 937             // Check and launch SupportedVersions.
 938             SSLExtension[] extTypes = new SSLExtension[] {
 939                     SSLExtension.SH_SUPPORTED_VERSIONS
 940                 };
 941             serverHello.extensions.consumeOnLoad(chc, extTypes);
 942 
 943             ProtocolVersion serverVersion;
 944             SHSupportedVersionsSpec svs =
 945                     (SHSupportedVersionsSpec)chc.handshakeExtensions.get(
 946                             SSLExtension.SH_SUPPORTED_VERSIONS);
 947             if (svs != null) {
 948                 serverVersion =            // could be null
 949                         ProtocolVersion.valueOf(svs.selectedVersion);
 950             } else {
 951                 serverVersion = serverHello.serverVersion;
 952             }
 953 
 954             if (!chc.activeProtocols.contains(serverVersion)) {
 955                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 956                     &quot;The server selected protocol version &quot; + serverVersion +
 957                     &quot; is not accepted by client preferences &quot; +
 958                     chc.activeProtocols);
 959             }
 960 
 961             chc.negotiatedProtocol = serverVersion;
 962             if (!chc.conContext.isNegotiated) {
 963                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 964                 chc.conContext.outputRecord.setVersion(chc.negotiatedProtocol);
 965             }
 966             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 967                 SSLLogger.fine(
 968                     &quot;Negotiated protocol version: &quot; + serverVersion.name);
 969             }
 970 
 971             if (serverHello.serverRandom.isVersionDowngrade(chc)) {
 972                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 973                     &quot;A potential protocol version downgrade attack&quot;);
 974             }
 975 
 976             // Consume the handshake message for the specific protocol version.
 977             if (serverVersion.isDTLS) {
 978                 if (serverVersion.useTLS13PlusSpec()) {
 979                     d13HandshakeConsumer.consume(chc, serverHello);
 980                 } else {
 981                     // TLS 1.3 key share extension may have produced client
 982                     // possessions for TLS 1.3 key exchanges.
 983                     chc.handshakePossessions.clear();
 984 
 985                     d12HandshakeConsumer.consume(chc, serverHello);
 986                 }
 987             } else {
 988                 if (serverVersion.useTLS13PlusSpec()) {
 989                     t13HandshakeConsumer.consume(chc, serverHello);
 990                 } else {
 991                     // TLS 1.3 key share extension may have produced client
 992                     // possessions for TLS 1.3 key exchanges.
 993                     chc.handshakePossessions.clear();
 994 
 995                     t12HandshakeConsumer.consume(chc, serverHello);
 996                 }
 997             }
 998         }
 999     }
1000 
1001     private static final
1002             class T12ServerHelloConsumer implements HandshakeConsumer {
1003         // Prevent instantiation of this class.
1004         private T12ServerHelloConsumer() {
1005             // blank
1006         }
1007 
1008         @Override
1009         public void consume(ConnectionContext context,
1010                 HandshakeMessage message) throws IOException {
1011             // The consuming happens in client side only.
1012             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1013             ServerHelloMessage serverHello = (ServerHelloMessage)message;
1014             if (!chc.isNegotiable(serverHello.serverVersion)) {
1015                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1016                     &quot;Server chose &quot; + serverHello.serverVersion +
1017                     &quot;, but that protocol version is not enabled or &quot; +
1018                     &quot;not supported by the client.&quot;);
1019             }
1020 
1021             // chc.negotiatedProtocol = serverHello.serverVersion;
1022             chc.negotiatedCipherSuite = serverHello.cipherSuite;
1023             chc.handshakeHash.determine(
1024                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1025             chc.serverHelloRandom = serverHello.serverRandom;
1026             if (chc.negotiatedCipherSuite.keyExchange == null) {
1027                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1028                     &quot;TLS 1.2 or prior version does not support the &quot; +
1029                     &quot;server cipher suite: &quot; + chc.negotiatedCipherSuite.name);
1030             }
1031 
1032             //
1033             // validate
1034             //
1035 
1036             // Check and launch the &quot;renegotiation_info&quot; extension.
1037             SSLExtension[] extTypes = new SSLExtension[] {
1038                     SSLExtension.SH_RENEGOTIATION_INFO
1039                 };
1040             serverHello.extensions.consumeOnLoad(chc, extTypes);
1041 
1042             // Is it session resuming?
1043             if (chc.resumingSession != null) {
1044                 // we tried to resume, let&#39;s see what the server decided
1045                 if (serverHello.sessionId.equals(
1046                         chc.resumingSession.getSessionId())) {
1047                     // server resumed the session, let&#39;s make sure everything
1048                     // checks out
1049 
1050                     // Verify that the session ciphers are unchanged.
1051                     CipherSuite sessionSuite = chc.resumingSession.getSuite();
1052                     if (chc.negotiatedCipherSuite != sessionSuite) {
1053                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1054                             &quot;Server returned wrong cipher suite for session&quot;);
1055                     }
1056 
1057                     // verify protocol version match
1058                     ProtocolVersion sessionVersion =
1059                             chc.resumingSession.getProtocolVersion();
1060                     if (chc.negotiatedProtocol != sessionVersion) {
1061                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1062                             &quot;Server resumed with wrong protocol version&quot;);
1063                     }
1064 
1065                     // looks fine;  resume it.
1066                     chc.isResumption = true;
1067                     chc.resumingSession.setAsSessionResumption(true);
1068                     chc.handshakeSession = chc.resumingSession;
1069                 } else {
1070                     // we wanted to resume, but the server refused
1071                     //
1072                     // Invalidate the session for initial handshake in case
1073                     // of reusing next time.
1074                     if (chc.resumingSession != null) {
1075                         chc.resumingSession.invalidate();
1076                         chc.resumingSession = null;
1077                     }
1078                     chc.isResumption = false;
1079                     if (!chc.sslConfig.enableSessionCreation) {
1080                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1081                             &quot;New session creation is disabled&quot;);
1082                     }
1083                 }
1084             }
1085 
1086             // Check and launch ClientHello extensions.
1087             extTypes = chc.sslConfig.getEnabledExtensions(
1088                     SSLHandshake.SERVER_HELLO);
1089             serverHello.extensions.consumeOnLoad(chc, extTypes);
1090 
1091             if (!chc.isResumption) {
1092                 if (chc.resumingSession != null) {
1093                     // in case the resumption happens next time.
1094                     chc.resumingSession.invalidate();
1095                     chc.resumingSession = null;
1096                 }
1097 
1098                 if (!chc.sslConfig.enableSessionCreation) {
1099                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1100                         &quot;New session creation is disabled&quot;);
1101                 }
1102                 chc.handshakeSession = new SSLSessionImpl(chc,
1103                         chc.negotiatedCipherSuite,
1104                         serverHello.sessionId);
1105                 chc.handshakeSession.setMaximumPacketSize(
1106                         chc.sslConfig.maximumPacketSize);
1107             }
1108 
1109             //
1110             // update
1111             //
1112             serverHello.extensions.consumeOnTrade(chc, extTypes);
1113 
1114             // update the consumers and producers
1115             if (chc.isResumption) {
1116                 SSLTrafficKeyDerivation kdg =
1117                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1118                 if (kdg == null) {
1119                     // unlikely
1120                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1121                             &quot;Not supported key derivation: &quot; +
1122                             chc.negotiatedProtocol);
1123                 } else {
1124                     chc.handshakeKeyDerivation = kdg.createKeyDerivation(
1125                             chc, chc.resumingSession.getMasterSecret());
1126                 }
1127 
1128                 chc.conContext.consumers.putIfAbsent(
1129                         ContentType.CHANGE_CIPHER_SPEC.id,
1130                         ChangeCipherSpec.t10Consumer);
1131                 chc.handshakeConsumers.put(
1132                         SSLHandshake.FINISHED.id,
1133                         SSLHandshake.FINISHED);
1134             } else {
1135                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
1136                         chc.negotiatedCipherSuite.keyExchange,
1137                         chc.negotiatedProtocol);
1138                 chc.handshakeKeyExchange = ke;
1139                 if (ke != null) {
1140                     for (SSLHandshake handshake :
1141                             ke.getRelatedHandshakers(chc)) {
1142                         chc.handshakeConsumers.put(handshake.id, handshake);
1143                     }
1144                 }
1145 
1146                 chc.handshakeConsumers.put(SSLHandshake.SERVER_HELLO_DONE.id,
1147                         SSLHandshake.SERVER_HELLO_DONE);
1148             }
1149 
1150             //
1151             // produce
1152             //
1153             // Need no new handshake message producers here.
1154         }
1155     }
1156 
1157     private static void setUpPskKD(HandshakeContext hc,
1158             SecretKey psk) throws SSLHandshakeException {
1159 
1160         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1161             SSLLogger.fine(&quot;Using PSK to derive early secret&quot;);
1162         }
1163 
1164         try {
1165             CipherSuite.HashAlg hashAlg = hc.negotiatedCipherSuite.hashAlg;
1166             HKDF hkdf = new HKDF(hashAlg.name);
1167             byte[] zeros = new byte[hashAlg.hashLength];
1168             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
1169             hc.handshakeKeyDerivation =
1170                     new SSLSecretDerivation(hc, earlySecret);
1171         } catch  (GeneralSecurityException gse) {
1172             throw (SSLHandshakeException) new SSLHandshakeException(
1173                 &quot;Could not generate secret&quot;).initCause(gse);
1174         }
1175     }
1176 
1177     private static final
1178             class T13ServerHelloConsumer implements HandshakeConsumer {
1179         // Prevent instantiation of this class.
1180         private T13ServerHelloConsumer() {
1181             // blank
1182         }
1183 
1184         @Override
1185         public void consume(ConnectionContext context,
1186                 HandshakeMessage message) throws IOException {
1187             // The consuming happens in client side only.
1188             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1189             ServerHelloMessage serverHello = (ServerHelloMessage)message;
1190             if (serverHello.serverVersion != ProtocolVersion.TLS12) {
1191                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1192                     &quot;The ServerHello.legacy_version field is not TLS 1.2&quot;);
1193             }
1194 
1195             chc.negotiatedCipherSuite = serverHello.cipherSuite;
1196             chc.handshakeHash.determine(
1197                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1198             chc.serverHelloRandom = serverHello.serverRandom;
1199 
1200             //
1201             // validate
1202             //
1203 
1204             // Check and launch ServerHello extensions.
1205             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
1206                     SSLHandshake.SERVER_HELLO);
1207             serverHello.extensions.consumeOnLoad(chc, extTypes);
1208             if (!chc.isResumption) {
1209                 if (chc.resumingSession != null) {
1210                     // in case the resumption happens next time.
1211                     chc.resumingSession.invalidate();
1212                     chc.resumingSession = null;
1213                 }
1214 
1215                 if (!chc.sslConfig.enableSessionCreation) {
1216                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1217                         &quot;New session creation is disabled&quot;);
1218                 }
1219                 chc.handshakeSession = new SSLSessionImpl(chc,
1220                         chc.negotiatedCipherSuite,
1221                         serverHello.sessionId);
1222                 chc.handshakeSession.setMaximumPacketSize(
1223                         chc.sslConfig.maximumPacketSize);
1224             } else {
1225                 // The PSK is consumed to allow it to be deleted
1226                 Optional&lt;SecretKey&gt; psk =
1227                         chc.resumingSession.consumePreSharedKey();
1228                 if(!psk.isPresent()) {
1229                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1230                     &quot;No PSK available. Unable to resume.&quot;);
1231                 }
1232 
1233                 chc.handshakeSession = chc.resumingSession;
1234 
1235                 setUpPskKD(chc, psk.get());
1236             }
1237 
1238             //
1239             // update
1240             //
1241             serverHello.extensions.consumeOnTrade(chc, extTypes);
1242 
1243             // Change client/server handshake traffic secrets.
1244             // Refresh handshake hash
1245             chc.handshakeHash.update();
1246 
1247             SSLKeyExchange ke = chc.handshakeKeyExchange;
1248             if (ke == null) {
1249                 // unlikely
1250                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1251                         &quot;Not negotiated key shares&quot;);
1252             }
1253 
1254             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(chc);
1255             SecretKey handshakeSecret = handshakeKD.deriveKey(
1256                     &quot;TlsHandshakeSecret&quot;, null);
1257             SSLTrafficKeyDerivation kdg =
1258                 SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1259             if (kdg == null) {
1260                 // unlikely
1261                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1262                         &quot;Not supported key derivation: &quot; +
1263                         chc.negotiatedProtocol);
1264             }
1265 
1266             SSLKeyDerivation secretKD =
1267                     new SSLSecretDerivation(chc, handshakeSecret);
1268 
1269             // update the handshake traffic read keys.
1270             SecretKey readSecret = secretKD.deriveKey(
1271                     &quot;TlsServerHandshakeTrafficSecret&quot;, null);
1272 
1273             SSLKeyDerivation readKD =
1274                     kdg.createKeyDerivation(chc, readSecret);
1275             SecretKey readKey = readKD.deriveKey(
1276                     &quot;TlsKey&quot;, null);
1277             SecretKey readIvSecret = readKD.deriveKey(
1278                     &quot;TlsIv&quot;, null);
1279             IvParameterSpec readIv =
1280                     new IvParameterSpec(readIvSecret.getEncoded());
1281             SSLReadCipher readCipher;
1282             try {
1283                 readCipher =
1284                     chc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1285                         Authenticator.valueOf(chc.negotiatedProtocol),
1286                         chc.negotiatedProtocol, readKey, readIv,
1287                         chc.sslContext.getSecureRandom());
1288             } catch (GeneralSecurityException gse) {
1289                 // unlikely
1290                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1291                         &quot;Missing cipher algorithm&quot;, gse);
1292             }
1293 
1294             if (readCipher == null) {
1295                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1296                     &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1297                     &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1298                     &quot;)&quot;);
1299             }
1300 
1301             chc.baseReadSecret = readSecret;
1302             chc.conContext.inputRecord.changeReadCiphers(readCipher);
1303 
1304             // update the handshake traffic write keys.
1305             SecretKey writeSecret = secretKD.deriveKey(
1306                     &quot;TlsClientHandshakeTrafficSecret&quot;, null);
1307             SSLKeyDerivation writeKD =
1308                     kdg.createKeyDerivation(chc, writeSecret);
1309             SecretKey writeKey = writeKD.deriveKey(
1310                     &quot;TlsKey&quot;, null);
1311             SecretKey writeIvSecret = writeKD.deriveKey(
1312                     &quot;TlsIv&quot;, null);
1313             IvParameterSpec writeIv =
1314                     new IvParameterSpec(writeIvSecret.getEncoded());
1315             SSLWriteCipher writeCipher;
1316             try {
1317                 writeCipher =
1318                     chc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
1319                         Authenticator.valueOf(chc.negotiatedProtocol),
1320                         chc.negotiatedProtocol, writeKey, writeIv,
1321                         chc.sslContext.getSecureRandom());
1322             } catch (GeneralSecurityException gse) {
1323                 // unlikely
1324                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1325                         &quot;Missing cipher algorithm&quot;, gse);
1326             }
1327 
1328             if (writeCipher == null) {
1329                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1330                     &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1331                     &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1332                     &quot;)&quot;);
1333             }
1334 
1335             chc.baseWriteSecret = writeSecret;
1336             chc.conContext.outputRecord.changeWriteCiphers(
1337                     writeCipher, (serverHello.sessionId.length() != 0));
1338 
1339             // Should use resumption_master_secret for TLS 1.3.
1340             // chc.handshakeSession.setMasterSecret(masterSecret);
1341 
1342             // Update the context for master key derivation.
1343             chc.handshakeKeyDerivation = secretKD;
1344 
1345             // update the consumers and producers
1346             //
1347             // The server sends a dummy change_cipher_spec record immediately
1348             // after its first handshake message.  This may either be after a
1349             // ServerHello or a HelloRetryRequest.
1350             chc.conContext.consumers.putIfAbsent(
1351                     ContentType.CHANGE_CIPHER_SPEC.id,
1352                     ChangeCipherSpec.t13Consumer);
1353 
1354             chc.handshakeConsumers.put(
1355                     SSLHandshake.ENCRYPTED_EXTENSIONS.id,
1356                     SSLHandshake.ENCRYPTED_EXTENSIONS);
1357 
1358             // Support cert authentication only, when not PSK.
1359             chc.handshakeConsumers.put(
1360                     SSLHandshake.CERTIFICATE_REQUEST.id,
1361                     SSLHandshake.CERTIFICATE_REQUEST);
1362             chc.handshakeConsumers.put(
1363                     SSLHandshake.CERTIFICATE.id,
1364                     SSLHandshake.CERTIFICATE);
1365             chc.handshakeConsumers.put(
1366                     SSLHandshake.CERTIFICATE_VERIFY.id,
1367                     SSLHandshake.CERTIFICATE_VERIFY);
1368 
1369             chc.handshakeConsumers.put(
1370                     SSLHandshake.FINISHED.id,
1371                     SSLHandshake.FINISHED);
1372 
1373             //
1374             // produce
1375             //
1376             // Need no new handshake message producers here.
1377         }
1378     }
1379 
1380     private static final
1381             class T13HelloRetryRequestConsumer implements HandshakeConsumer {
1382         // Prevent instantiation of this class.
1383         private T13HelloRetryRequestConsumer() {
1384             // blank
1385         }
1386 
1387         @Override
1388         public void consume(ConnectionContext context,
1389                 HandshakeMessage message) throws IOException {
1390             // The consuming happens in client side only.
1391             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1392             ServerHelloMessage helloRetryRequest = (ServerHelloMessage)message;
1393             if (helloRetryRequest.serverVersion != ProtocolVersion.TLS12) {
1394                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1395                     &quot;The HelloRetryRequest.legacy_version is not TLS 1.2&quot;);
1396             }
1397 
1398             chc.negotiatedCipherSuite = helloRetryRequest.cipherSuite;
1399 
1400             //
1401             // validate
1402             //
1403 
1404             // Check and launch ClientHello extensions.
1405             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
1406                     SSLHandshake.HELLO_RETRY_REQUEST);
1407             helloRetryRequest.extensions.consumeOnLoad(chc, extTypes);
1408 
1409             //
1410             // update
1411             //
1412             helloRetryRequest.extensions.consumeOnTrade(chc, extTypes);
1413 
1414             // Change client/server handshake traffic secrets.
1415             // Refresh handshake hash
1416             chc.handshakeHash.finish();     // reset the handshake hash
1417 
1418             // calculate the transcript hash of the 1st ClientHello message
1419             HandshakeOutStream hos = new HandshakeOutStream(null);
1420             try {
1421                 chc.initialClientHelloMsg.write(hos);
1422             } catch (IOException ioe) {
1423                 // unlikely
1424                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1425                     &quot;Failed to construct message hash&quot;, ioe);
1426             }
1427             chc.handshakeHash.deliver(hos.toByteArray());
1428             chc.handshakeHash.determine(
1429                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1430             byte[] clientHelloHash = chc.handshakeHash.digest();
1431 
1432             // calculate the message_hash
1433             //
1434             // Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
1435             //   Hash(message_hash ||    /* Handshake type */
1436             //     00 00 Hash.length ||  /* Handshake message length (bytes) */
1437             //     Hash(ClientHello1) || /* Hash of ClientHello1 */
1438             //     HelloRetryRequest || ... || Mn)
1439             int hashLen = chc.negotiatedCipherSuite.hashAlg.hashLength;
1440             byte[] hashedClientHello = new byte[4 + hashLen];
1441             hashedClientHello[0] = SSLHandshake.MESSAGE_HASH.id;
1442             hashedClientHello[1] = (byte)0x00;
1443             hashedClientHello[2] = (byte)0x00;
1444             hashedClientHello[3] = (byte)(hashLen &amp; 0xFF);
1445             System.arraycopy(clientHelloHash, 0,
1446                     hashedClientHello, 4, hashLen);
1447 
1448             chc.handshakeHash.finish();     // reset the handshake hash
1449             chc.handshakeHash.deliver(hashedClientHello);
1450 
1451             int hrrBodyLen = helloRetryRequest.handshakeRecord.remaining();
1452             byte[] hrrMessage = new byte[4 + hrrBodyLen];
1453             hrrMessage[0] = SSLHandshake.HELLO_RETRY_REQUEST.id;
1454             hrrMessage[1] = (byte)((hrrBodyLen &gt;&gt; 16) &amp; 0xFF);
1455             hrrMessage[2] = (byte)((hrrBodyLen &gt;&gt; 8) &amp; 0xFF);
1456             hrrMessage[3] = (byte)(hrrBodyLen &amp; 0xFF);
1457 
1458             ByteBuffer hrrBody = helloRetryRequest.handshakeRecord.duplicate();
1459             hrrBody.get(hrrMessage, 4, hrrBodyLen);
1460 
1461             chc.handshakeHash.receive(hrrMessage);
1462 
1463             // Update the initial ClientHello handshake message.
1464             chc.initialClientHelloMsg.extensions.reproduce(chc,
1465                     new SSLExtension[] {
1466                         SSLExtension.CH_COOKIE,
1467                         SSLExtension.CH_KEY_SHARE,
1468                         SSLExtension.CH_PRE_SHARED_KEY
1469                     });
1470 
1471             //
1472             // produce response handshake message
1473             //
1474             SSLHandshake.CLIENT_HELLO.produce(context, helloRetryRequest);
1475         }
1476     }
1477 }
    </pre>
  </body>
</html>
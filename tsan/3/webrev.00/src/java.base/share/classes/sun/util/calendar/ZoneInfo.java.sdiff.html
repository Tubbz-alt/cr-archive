<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/util/calendar/ZoneInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LocalGregorianCalendar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZoneInfoFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/util/calendar/ZoneInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
146      * java.util.SimpleTimeZone#SimpleTimeZone(int, String, int, int,
147      * int , int , int , int , int , int , int, int, int) the
148      * 13-argument SimpleTimeZone constructor} parameters.
149      * @serial
150      */
151     private int[] simpleTimeZoneParams;
152 
153     /**
154      * True if the raw GMT offset value would change after the time
155      * zone data has been generated; false, otherwise. The default
156      * value is false.
157      * @serial
158      */
159     private boolean willGMTOffsetChange = false;
160 
161     /**
162      * True if the object has been modified after its instantiation.
163      */
164     private transient boolean dirty = false;
165 

166     private static final long serialVersionUID = 2653134537216586139L;
167 
168     /**
169      * A constructor.
170      */
171     public ZoneInfo() {
172     }
173 
174     /**
175      * A Constructor for CustomID.
176      */
177     public ZoneInfo(String ID, int rawOffset) {
178         this(ID, rawOffset, 0, 0, null, null, null, false);
179     }
180 
181     /**
182      * Constructs a ZoneInfo instance.
183      *
184      * @param ID time zone name
185      * @param rawOffset GMT offset in milliseconds
</pre>
<hr />
<pre>
256             if (offsets != null) {
257                 offsets[0] = offset;
258                 offsets[1] = 0;
259             }
260             return offset;
261         }
262 
263         if (index &lt; transitions.length) {
264             long val = transitions[index];
265             int offset = this.offsets[(int)(val &amp; OFFSET_MASK)] + rawOffsetDiff;
266             if (offsets != null) {
267                 int dst = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);
268                 int save = (dst == 0) ? 0 : this.offsets[dst];
269                 offsets[0] = offset - save;
270                 offsets[1] = save;
271             }
272             return offset;
273         }
274 
275         // beyond the transitions, delegate to SimpleTimeZone if there
<span class="line-modified">276         // is a rule; otherwise, return rawOffset.</span>
277         SimpleTimeZone tz = getLastRule();
278         if (tz != null) {
279             int rawoffset = tz.getRawOffset();
280             long msec = date;
281             if (type != UTC_TIME) {
282                 msec -= rawOffset;
283             }
284             int dstoffset = tz.getOffset(msec) - rawOffset;
285 
286             // Check if it&#39;s in a standard-to-daylight transition.
287             if (dstoffset &gt; 0 &amp;&amp; tz.getOffset(msec - dstoffset) == rawoffset) {
288                 dstoffset = 0;
289             }
290 
291             if (offsets != null) {
292                 offsets[0] = rawoffset;
293                 offsets[1] = dstoffset;
294             }
295             return rawoffset + dstoffset;











296         }
<span class="line-removed">297         int offset = getLastRawOffset();</span>
<span class="line-removed">298         if (offsets != null) {</span>
<span class="line-removed">299             offsets[0] = offset;</span>
<span class="line-removed">300             offsets[1] = 0;</span>
<span class="line-removed">301         }</span>
<span class="line-removed">302         return offset;</span>
303     }
304 
305     private int getTransitionIndex(long date, int type) {
306         int low = 0;
307         int high = transitions.length - 1;
308 
309         while (low &lt;= high) {
310             int mid = (low + high) / 2;
311             long val = transitions[mid];
312             long midVal = val &gt;&gt; TRANSITION_NSHIFT; // sign extended
313             if (type != UTC_TIME) {
314                 midVal += offsets[(int)(val &amp; OFFSET_MASK)]; // wall time
315             }
316             if (type == STANDARD_TIME) {
317                 int dstIndex = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);
318                 if (dstIndex != 0) {
319                     midVal -= offsets[dstIndex]; // make it standard time
320                 }
321             }
322 
</pre>
<hr />
<pre>
485             return false;
486         }
487 
488         long utc = date.getTime() - rawOffsetDiff;
489         int index = getTransitionIndex(utc, UTC_TIME);
490 
491         // before transitions in the transition table
492         if (index &lt; 0) {
493             return false;
494         }
495 
496         // the time is in the table range.
497         if (index &lt; transitions.length) {
498             return (transitions[index] &amp; DST_MASK) != 0;
499         }
500 
501         // beyond the transition table
502         SimpleTimeZone tz = getLastRule();
503         if (tz != null) {
504             return tz.inDaylightTime(date);
<span class="line-modified">505        }</span>
<span class="line-modified">506         return false;</span>


507     }
508 
509     /**
510      * Returns the amount of time in milliseconds that the clock is advanced
511      * during daylight saving time is in effect in its last daylight saving time rule.
512      *
513      * @return the number of milliseconds the time is advanced with respect to
514      * standard time when daylight saving time is in effect.
515      */
516     public int getDSTSavings() {
517         return dstSavings;
518     }
519 
520 //    /**
521 //     * @return the last year in the transition table or -1 if this
522 //     * time zone doesn&#39;t observe any daylight saving time.
523 //     */
524 //    public int getMaxTransitionYear() {
525 //      if (transitions == null) {
526 //          return -1;
</pre>
<hr />
<pre>
702             return false;
703         }
704         if (getLastRawOffset() != ((ZoneInfo)other).getLastRawOffset()) {
705             return false;
706         }
707         return (checksum == ((ZoneInfo)other).checksum);
708     }
709 
710     /**
711      * Returns a Map from alias time zone IDs to their standard
712      * time zone IDs.
713      *
714      * @return the Map that holds the mappings from alias time zone IDs
715      *    to their standard time zone IDs, or null if
716      *    &lt;code&gt;ZoneInfoMappings&lt;/code&gt; file is not available.
717      */
718     public static Map&lt;String, String&gt; getAliasTable() {
719          return ZoneInfoFile.getAliasMap();
720     }
721 

722     private void readObject(ObjectInputStream stream)
723             throws IOException, ClassNotFoundException {
724         stream.defaultReadObject();
725         // We don&#39;t know how this object from 1.4.x or earlier has
726         // been mutated. So it should always be marked as `dirty&#39;.
727         dirty = true;
728     }
729 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
146      * java.util.SimpleTimeZone#SimpleTimeZone(int, String, int, int,
147      * int , int , int , int , int , int , int, int, int) the
148      * 13-argument SimpleTimeZone constructor} parameters.
149      * @serial
150      */
151     private int[] simpleTimeZoneParams;
152 
153     /**
154      * True if the raw GMT offset value would change after the time
155      * zone data has been generated; false, otherwise. The default
156      * value is false.
157      * @serial
158      */
159     private boolean willGMTOffsetChange = false;
160 
161     /**
162      * True if the object has been modified after its instantiation.
163      */
164     private transient boolean dirty = false;
165 
<span class="line-added">166     @java.io.Serial</span>
167     private static final long serialVersionUID = 2653134537216586139L;
168 
169     /**
170      * A constructor.
171      */
172     public ZoneInfo() {
173     }
174 
175     /**
176      * A Constructor for CustomID.
177      */
178     public ZoneInfo(String ID, int rawOffset) {
179         this(ID, rawOffset, 0, 0, null, null, null, false);
180     }
181 
182     /**
183      * Constructs a ZoneInfo instance.
184      *
185      * @param ID time zone name
186      * @param rawOffset GMT offset in milliseconds
</pre>
<hr />
<pre>
257             if (offsets != null) {
258                 offsets[0] = offset;
259                 offsets[1] = 0;
260             }
261             return offset;
262         }
263 
264         if (index &lt; transitions.length) {
265             long val = transitions[index];
266             int offset = this.offsets[(int)(val &amp; OFFSET_MASK)] + rawOffsetDiff;
267             if (offsets != null) {
268                 int dst = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);
269                 int save = (dst == 0) ? 0 : this.offsets[dst];
270                 offsets[0] = offset - save;
271                 offsets[1] = save;
272             }
273             return offset;
274         }
275 
276         // beyond the transitions, delegate to SimpleTimeZone if there
<span class="line-modified">277         // is a rule; otherwise, return the offset of the last transition.</span>
278         SimpleTimeZone tz = getLastRule();
279         if (tz != null) {
280             int rawoffset = tz.getRawOffset();
281             long msec = date;
282             if (type != UTC_TIME) {
283                 msec -= rawOffset;
284             }
285             int dstoffset = tz.getOffset(msec) - rawOffset;
286 
287             // Check if it&#39;s in a standard-to-daylight transition.
288             if (dstoffset &gt; 0 &amp;&amp; tz.getOffset(msec - dstoffset) == rawoffset) {
289                 dstoffset = 0;
290             }
291 
292             if (offsets != null) {
293                 offsets[0] = rawoffset;
294                 offsets[1] = dstoffset;
295             }
296             return rawoffset + dstoffset;
<span class="line-added">297         } else {</span>
<span class="line-added">298             // use the last transition</span>
<span class="line-added">299             long val = transitions[transitions.length - 1];</span>
<span class="line-added">300             int offset = this.offsets[(int)(val &amp; OFFSET_MASK)] + rawOffsetDiff;</span>
<span class="line-added">301             if (offsets != null) {</span>
<span class="line-added">302                 int dst = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);</span>
<span class="line-added">303                 int save = (dst == 0) ? 0 : this.offsets[dst];</span>
<span class="line-added">304                 offsets[0] = offset - save;</span>
<span class="line-added">305                 offsets[1] = save;</span>
<span class="line-added">306             }</span>
<span class="line-added">307             return offset;</span>
308         }






309     }
310 
311     private int getTransitionIndex(long date, int type) {
312         int low = 0;
313         int high = transitions.length - 1;
314 
315         while (low &lt;= high) {
316             int mid = (low + high) / 2;
317             long val = transitions[mid];
318             long midVal = val &gt;&gt; TRANSITION_NSHIFT; // sign extended
319             if (type != UTC_TIME) {
320                 midVal += offsets[(int)(val &amp; OFFSET_MASK)]; // wall time
321             }
322             if (type == STANDARD_TIME) {
323                 int dstIndex = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);
324                 if (dstIndex != 0) {
325                     midVal -= offsets[dstIndex]; // make it standard time
326                 }
327             }
328 
</pre>
<hr />
<pre>
491             return false;
492         }
493 
494         long utc = date.getTime() - rawOffsetDiff;
495         int index = getTransitionIndex(utc, UTC_TIME);
496 
497         // before transitions in the transition table
498         if (index &lt; 0) {
499             return false;
500         }
501 
502         // the time is in the table range.
503         if (index &lt; transitions.length) {
504             return (transitions[index] &amp; DST_MASK) != 0;
505         }
506 
507         // beyond the transition table
508         SimpleTimeZone tz = getLastRule();
509         if (tz != null) {
510             return tz.inDaylightTime(date);
<span class="line-modified">511         } else {</span>
<span class="line-modified">512             // use the last transition</span>
<span class="line-added">513             return (transitions[transitions.length - 1] &amp; DST_MASK) != 0;</span>
<span class="line-added">514         }</span>
515     }
516 
517     /**
518      * Returns the amount of time in milliseconds that the clock is advanced
519      * during daylight saving time is in effect in its last daylight saving time rule.
520      *
521      * @return the number of milliseconds the time is advanced with respect to
522      * standard time when daylight saving time is in effect.
523      */
524     public int getDSTSavings() {
525         return dstSavings;
526     }
527 
528 //    /**
529 //     * @return the last year in the transition table or -1 if this
530 //     * time zone doesn&#39;t observe any daylight saving time.
531 //     */
532 //    public int getMaxTransitionYear() {
533 //      if (transitions == null) {
534 //          return -1;
</pre>
<hr />
<pre>
710             return false;
711         }
712         if (getLastRawOffset() != ((ZoneInfo)other).getLastRawOffset()) {
713             return false;
714         }
715         return (checksum == ((ZoneInfo)other).checksum);
716     }
717 
718     /**
719      * Returns a Map from alias time zone IDs to their standard
720      * time zone IDs.
721      *
722      * @return the Map that holds the mappings from alias time zone IDs
723      *    to their standard time zone IDs, or null if
724      *    &lt;code&gt;ZoneInfoMappings&lt;/code&gt; file is not available.
725      */
726     public static Map&lt;String, String&gt; getAliasTable() {
727          return ZoneInfoFile.getAliasMap();
728     }
729 
<span class="line-added">730     @java.io.Serial</span>
731     private void readObject(ObjectInputStream stream)
732             throws IOException, ClassNotFoundException {
733         stream.defaultReadObject();
734         // We don&#39;t know how this object from 1.4.x or earlier has
735         // been mutated. So it should always be marked as `dirty&#39;.
736         dirty = true;
737     }
738 }
</pre>
</td>
</tr>
</table>
<center><a href="LocalGregorianCalendar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZoneInfoFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
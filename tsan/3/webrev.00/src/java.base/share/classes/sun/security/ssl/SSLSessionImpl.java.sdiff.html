<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSessionContextImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 




  27 import java.math.BigInteger;
  28 import java.net.InetAddress;

  29 import java.security.Principal;
  30 import java.security.PrivateKey;
  31 import java.security.cert.CertificateEncodingException;
  32 import java.security.cert.X509Certificate;
  33 import java.util.ArrayList;

  34 import java.util.Queue;
  35 import java.util.Collection;
  36 import java.util.Collections;
  37 import java.util.Enumeration;
  38 import java.util.List;
<span class="line-removed">  39 import java.util.Optional;</span>
  40 import java.util.concurrent.ConcurrentHashMap;
  41 import java.util.concurrent.ConcurrentLinkedQueue;

  42 import javax.crypto.SecretKey;

  43 import javax.net.ssl.ExtendedSSLSession;

  44 import javax.net.ssl.SNIServerName;

  45 import javax.net.ssl.SSLPeerUnverifiedException;
  46 import javax.net.ssl.SSLPermission;
  47 import javax.net.ssl.SSLSessionBindingEvent;
  48 import javax.net.ssl.SSLSessionBindingListener;
  49 import javax.net.ssl.SSLSessionContext;
  50 
  51 /**
  52  * Implements the SSL session interface, and exposes the session context
  53  * which is maintained by SSL servers.
  54  *
  55  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  56  * their authentication context(s).  They can do this by enumerating the
  57  * IDs of the sessions which are cached, examining those sessions, and then
  58  * perhaps invalidating a given session so that it can&#39;t be used again.
  59  * If servers do not explicitly manage the cache, sessions will linger
  60  * until memory is low enough that the runtime environment purges cache
  61  * entries automatically to reclaim space.
  62  *
  63  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  64  * there&#39;s no other public way to get at the server session context which
</pre>
<hr />
<pre>
  80     private final ProtocolVersion       protocolVersion;
  81     private final SessionId             sessionId;
  82     private X509Certificate[]   peerCerts;
  83     private CipherSuite         cipherSuite;
  84     private SecretKey           masterSecret;
  85     final boolean               useExtendedMasterSecret;
  86 
  87     /*
  88      * Information not part of the SSLv3 protocol spec, but used
  89      * to support session management policies.
  90      */
  91     private final long          creationTime;
  92     private long                lastUsedTime = 0;
  93     private final String        host;
  94     private final int           port;
  95     private SSLSessionContextImpl       context;
  96     private boolean             invalidated;
  97     private X509Certificate[]   localCerts;
  98     private PrivateKey          localPrivateKey;
  99     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
<span class="line-modified"> 100     private String[]            peerSupportedSignAlgs;      // for certificate</span>
 101     private boolean             useDefaultPeerSignAlgs = false;
 102     private List&lt;byte[]&gt;        statusResponses;
 103     private SecretKey           resumptionMasterSecret;
 104     private SecretKey           preSharedKey;
 105     private byte[]              pskIdentity;
 106     private final long          ticketCreationTime = System.currentTimeMillis();
 107     private int                 ticketAgeAdd;
 108 
 109     private int                 negotiatedMaxFragLen = -1;
 110     private int                 maximumPacketSize;
 111 
 112     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 113                                         new ConcurrentLinkedQueue&lt;&gt;();
 114 
 115     /*
 116      * Is the session currently re-established with a session-resumption
 117      * abbreviated initial handshake?
 118      *
 119      * Note that currently we only set this variable in client side.
 120      */
 121     private boolean isSessionResumption = false;
 122 
 123     /*
 124      * Use of session caches is globally enabled/disabled.
 125      */
 126     private static boolean      defaultRejoinable = true;
 127 
 128     // server name indication
 129     final SNIServerName         serverNameIndication;
 130     private final List&lt;SNIServerName&gt;    requestedServerNames;
 131 
 132     // Counter used to create unique nonces in NewSessionTicket
 133     private BigInteger ticketNonceCounter = BigInteger.ONE;
 134 
 135     // The endpoint identification algorithm used to check certificates
 136     // in this session.
<span class="line-modified"> 137     private final String              identificationProtocol;</span>


 138 
 139     /*
 140      * Create a new non-rejoinable session, using the default (null)
 141      * cipher spec.  This constructor returns a session which could
 142      * be used either by a client or by a server, as a connection is
 143      * first opened and before handshaking begins.
 144      */
 145     private SSLSessionImpl() {
 146         this.protocolVersion = ProtocolVersion.NONE;
 147         this.cipherSuite = CipherSuite.C_NULL;
 148         this.sessionId = new SessionId(false, null);
 149         this.host = null;
 150         this.port = -1;
 151         this.localSupportedSignAlgs = Collections.emptySet();
 152         this.serverNameIndication = null;
 153         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 154         this.useExtendedMasterSecret = false;
 155         this.creationTime = System.currentTimeMillis();
 156         this.identificationProtocol = null;
 157         this.boundValues = new ConcurrentHashMap&lt;&gt;();
</pre>
<hr />
<pre>
 210         }
 211         this.creationTime = creationTime;
 212         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 213         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 214 
 215         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 216              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 217         }
 218     }
 219 
 220     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 221         this.protocolVersion = baseSession.getProtocolVersion();
 222         this.cipherSuite = baseSession.cipherSuite;
 223         this.sessionId = newId;
 224         this.host = baseSession.getPeerHost();
 225         this.port = baseSession.getPeerPort();
 226         this.localSupportedSignAlgs =
 227                 baseSession.localSupportedSignAlgs == null ?
 228                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 229         this.peerSupportedSignAlgs =
<span class="line-modified"> 230                 baseSession.getPeerSupportedSignatureAlgorithms();</span>

 231         this.serverNameIndication = baseSession.serverNameIndication;
 232         this.requestedServerNames = baseSession.getRequestedServerNames();
 233         this.masterSecret = baseSession.getMasterSecret();
 234         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 235         this.creationTime = baseSession.getCreationTime();
 236         this.lastUsedTime = System.currentTimeMillis();
 237         this.identificationProtocol = baseSession.getIdentificationProtocol();
 238         this.localCerts = baseSession.localCerts;
 239         this.peerCerts = baseSession.peerCerts;
 240         this.statusResponses = baseSession.statusResponses;
 241         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 242         this.context = baseSession.context;
 243         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 244         this.maximumPacketSize = baseSession.maximumPacketSize;
 245         this.boundValues = baseSession.boundValues;
 246 
 247         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 248              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 249         }
 250     }
 251 




























































































































































































































































































































































































































































 252     void setMasterSecret(SecretKey secret) {
 253         masterSecret = secret;
 254     }
 255 
 256     void setResumptionMasterSecret(SecretKey secret) {
 257         resumptionMasterSecret = secret;
 258     }
 259 
 260     void setPreSharedKey(SecretKey key) {
 261         preSharedKey = key;
 262     }
 263 
 264     void addChild(SSLSessionImpl session) {
 265         childSessions.add(session);
 266     }
 267 
 268     void setTicketAgeAdd(int ticketAgeAdd) {
 269         this.ticketAgeAdd = ticketAgeAdd;
 270     }
 271 
 272     void setPskIdentity(byte[] pskIdentity) {
 273         this.pskIdentity = pskIdentity;
 274     }
 275 
 276     BigInteger incrTicketNonceCounter() {
 277         BigInteger result = ticketNonceCounter;
<span class="line-modified"> 278         ticketNonceCounter = ticketNonceCounter.add(BigInteger.valueOf(1));</span>
 279         return result;
 280     }
 281 




 282     /**
 283      * Returns the master secret ... treat with extreme caution!
 284      */
 285     SecretKey getMasterSecret() {
 286         return masterSecret;
 287     }
 288 
<span class="line-modified"> 289     Optional&lt;SecretKey&gt; getResumptionMasterSecret() {</span>
<span class="line-modified"> 290         return Optional.ofNullable(resumptionMasterSecret);</span>
 291     }
 292 
<span class="line-modified"> 293     synchronized Optional&lt;SecretKey&gt; getPreSharedKey() {</span>
<span class="line-modified"> 294         return Optional.ofNullable(preSharedKey);</span>





 295     }
 296 
<span class="line-modified"> 297     synchronized Optional&lt;SecretKey&gt; consumePreSharedKey() {</span>
<span class="line-modified"> 298         Optional&lt;SecretKey&gt; result = Optional.ofNullable(preSharedKey);</span>
<span class="line-modified"> 299         preSharedKey = null;</span>
<span class="line-modified"> 300         return result;</span>




 301     }
 302 
 303     int getTicketAgeAdd() {
 304         return ticketAgeAdd;
 305     }
 306 
 307     String getIdentificationProtocol() {
 308         return this.identificationProtocol;
 309     }
 310 
 311     /* PSK identities created from new_session_ticket messages should only
 312      * be used once. This method will return the identity and then clear it
 313      * so it cannot be used again.
 314      */
<span class="line-modified"> 315     synchronized Optional&lt;byte[]&gt; consumePskIdentity() {</span>
<span class="line-modified"> 316         Optional&lt;byte[]&gt; result = Optional.ofNullable(pskIdentity);</span>
<span class="line-modified"> 317         pskIdentity = null;</span>
<span class="line-modified"> 318         return result;</span>








 319     }
 320 
 321     void setPeerCertificates(X509Certificate[] peer) {
 322         if (peerCerts == null) {
 323             peerCerts = peer;
 324         }
 325     }
 326 
 327     void setLocalCertificates(X509Certificate[] local) {
 328         localCerts = local;
 329     }
 330 
 331     void setLocalPrivateKey(PrivateKey privateKey) {
 332         localPrivateKey = privateKey;
 333     }
 334 
 335     void setPeerSupportedSignatureAlgorithms(
 336             Collection&lt;SignatureScheme&gt; signatureSchemes) {
<span class="line-modified"> 337         peerSupportedSignAlgs =</span>
<span class="line-removed"> 338             SignatureScheme.getAlgorithmNames(signatureSchemes);</span>
 339     }
 340 
 341     // TLS 1.2 only
 342     //
 343     // Per RFC 5246, If the client supports only the default hash
 344     // and signature algorithms, it MAY omit the
 345     // signature_algorithms extension.  If the client does not
 346     // support the default algorithms, or supports other hash
 347     // and signature algorithms (and it is willing to use them
 348     // for verifying messages sent by the server, i.e., server
 349     // certificates and server key exchange), it MUST send the
 350     // signature_algorithms extension, listing the algorithms it
 351     // is willing to accept.





 352     void setUseDefaultPeerSignAlgs() {
 353         useDefaultPeerSignAlgs = true;
<span class="line-modified"> 354         peerSupportedSignAlgs = new String[] {</span>
<span class="line-removed"> 355             &quot;SHA1withRSA&quot;, &quot;SHA1withDSA&quot;, &quot;SHA1withECDSA&quot;};</span>
 356     }
 357 
 358     // Returns the connection session.
 359     SSLSessionImpl finish() {
 360         if (useDefaultPeerSignAlgs) {
<span class="line-modified"> 361             this.peerSupportedSignAlgs = new String[0];</span>
 362         }
 363 
 364         return this;
 365     }
 366 
 367     /**
 368      * Provide status response data obtained during the SSL handshake.
 369      *
 370      * @param responses a {@link List} of responses in binary form.
 371      */
 372     void setStatusResponses(List&lt;byte[]&gt; responses) {
 373         if (responses != null &amp;&amp; !responses.isEmpty()) {
 374             statusResponses = responses;
 375         } else {
 376             statusResponses = Collections.emptyList();
 377         }
 378     }
 379 
 380     /**
 381      * Returns true iff this session may be resumed ... sessions are
 382      * usually resumable.  Security policies may suggest otherwise,
 383      * for example sessions that haven&#39;t been used for a while (say,
 384      * a working day) won&#39;t be resumable, and sessions might have a
 385      * maximum lifetime in any case.
 386      */
 387     boolean isRejoinable() {




 388         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
<span class="line-modified"> 389             !invalidated &amp;&amp; isLocalAuthenticationValid();</span>
 390     }
 391 
 392     @Override
<span class="line-modified"> 393     public synchronized boolean isValid() {</span>
<span class="line-modified"> 394         return isRejoinable();</span>





 395     }
 396 
 397     /**
 398      * Check if the authentication used when establishing this session
 399      * is still valid. Returns true if no authentication was used
 400      */
 401     private boolean isLocalAuthenticationValid() {
 402         if (localPrivateKey != null) {
 403             try {
 404                 // if the private key is no longer valid, getAlgorithm()
 405                 // should throw an exception
 406                 // (e.g. Smartcard has been removed from the reader)
 407                 localPrivateKey.getAlgorithm();
 408             } catch (Exception e) {
 409                 invalidate();
 410                 return false;
 411             }
 412         }
 413 
 414         return true;
</pre>
<hr />
<pre>
 757     /**
 758      * Need to provide the port info for caching sessions based on
 759      * host and port. Accessed by SSLSessionContextImpl
 760      */
 761     @Override
 762     public int getPeerPort() {
 763         return port;
 764     }
 765 
 766     void setContext(SSLSessionContextImpl ctx) {
 767         if (context == null) {
 768             context = ctx;
 769         }
 770     }
 771 
 772     /**
 773      * Invalidate a session.  Active connections may still exist, but
 774      * no connections will be able to rejoin this session.
 775      */
 776     @Override
<span class="line-modified"> 777     public synchronized void invalidate() {</span>
<span class="line-modified"> 778         //</span>
<span class="line-modified"> 779         // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="line-modified"> 780         // attempted when we get a handshaking error on a brand</span>
<span class="line-modified"> 781         // new connection, with no &quot;real&quot; session yet.</span>
<span class="line-modified"> 782         //</span>
<span class="line-modified"> 783         if (this == nullSession) {</span>
<span class="line-modified"> 784             return;</span>
<span class="line-modified"> 785         }</span>


 786 
<span class="line-modified"> 787         if (context != null) {</span>
<span class="line-modified"> 788             context.remove(sessionId);</span>
<span class="line-modified"> 789             context = null;</span>
<span class="line-modified"> 790         }</span>
<span class="line-modified"> 791         if (invalidated) {</span>
<span class="line-modified"> 792             return;</span>
<span class="line-modified"> 793         }</span>
<span class="line-modified"> 794         invalidated = true;</span>
<span class="line-modified"> 795         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {</span>
<span class="line-modified"> 796              SSLLogger.finest(&quot;Invalidated session:  &quot; + this);</span>
<span class="line-modified"> 797         }</span>
<span class="line-modified"> 798         for (SSLSessionImpl child : childSessions) {</span>
<span class="line-modified"> 799             child.invalidate();</span>




 800         }
 801     }
 802 
 803     /*
 804      * Table of application-specific session data indexed by an application
 805      * key and the calling security context. This is important since
 806      * sessions can be shared across different protection domains.
 807      */
 808     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;

 809 
 810     /**
 811      * Assigns a session value.  Session change events are given if
 812      * appropriate, to any original value as well as the new value.
 813      */
 814     @Override
 815     public void putValue(String key, Object value) {
 816         if ((key == null) || (value == null)) {
 817             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
 818         }
 819 
 820         SecureKey secureKey = new SecureKey(key);
 821         Object oldValue = boundValues.put(secureKey, value);
 822 
 823         if (oldValue instanceof SSLSessionBindingListener) {
 824             SSLSessionBindingEvent e;
 825 
 826             e = new SSLSessionBindingEvent(this, key);
 827             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
 828         }
 829         if (value instanceof SSLSessionBindingListener) {
 830             SSLSessionBindingEvent e;
 831 
 832             e = new SSLSessionBindingEvent(this, key);
 833             ((SSLSessionBindingListener)value).valueBound(e);
 834         }



 835     }
 836 
 837     /**
 838      * Returns the specified session value.
 839      */
 840     @Override
 841     public Object getValue(String key) {
 842         if (key == null) {
 843             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
 844         }
 845 
 846         SecureKey secureKey = new SecureKey(key);
 847         return boundValues.get(secureKey);
 848     }
 849 
 850 
 851     /**
 852      * Removes the specified session value, delivering a session changed
 853      * event as appropriate.
 854      */
 855     @Override
 856     public void removeValue(String key) {
 857         if (key == null) {
 858             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
 859         }
 860 
 861         SecureKey secureKey = new SecureKey(key);
 862         Object value = boundValues.remove(secureKey);
 863 
 864         if (value instanceof SSLSessionBindingListener) {
 865             SSLSessionBindingEvent e;
 866 
 867             e = new SSLSessionBindingEvent(this, key);
 868             ((SSLSessionBindingListener)value).valueUnbound(e);
 869         }



 870     }
 871 
 872 
 873     /**
 874      * Lists the names of the session values.
 875      */
 876     @Override
 877     public String[] getValueNames() {
 878         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
 879         Object securityCtx = SecureKey.getCurrentSecurityContext();
 880         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
 881                 e.hasMoreElements(); ) {
 882             SecureKey key = e.nextElement();
 883             if (securityCtx.equals(key.getSecurityContext())) {
 884                 v.add(key.getAppKey());
 885             }
 886         }
 887 
 888         return v.toArray(new String[0]);
 889     }
</pre>
<hr />
<pre>
 892      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
 893      * until changed.
 894      *
 895      * In the TLS specification (section 6.2.1, RFC2246), it is not
 896      * recommended that the plaintext has more than 2^14 bytes.
 897      * However, some TLS implementations violate the specification.
 898      * This is a workaround for interoperability with these stacks.
 899      *
 900      * Application could accept large fragments up to 2^15 bytes by
 901      * setting the system property jsse.SSLEngine.acceptLargeFragments
 902      * to &quot;true&quot;.
 903      */
 904     private boolean acceptLargeFragments =
 905             Utilities.getBooleanProperty(
 906                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
 907 
 908     /**
 909      * Expand the buffer size of both SSL/TLS network packet and
 910      * application data.
 911      */
<span class="line-modified"> 912     protected synchronized void expandBufferSizes() {</span>
<span class="line-modified"> 913         acceptLargeFragments = true;</span>





 914     }
 915 
 916     /**
 917      * Gets the current size of the largest SSL/TLS packet that is expected
 918      * when using this session.
 919      */
 920     @Override
<span class="line-modified"> 921     public synchronized int getPacketBufferSize() {</span>
<span class="line-modified"> 922         // Use the bigger packet size calculated from maximumPacketSize</span>
<span class="line-modified"> 923         // and negotiatedMaxFragLen.</span>
<span class="line-modified"> 924         int packetSize = 0;</span>
<span class="line-modified"> 925         if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified"> 926             packetSize = cipherSuite.calculatePacketSize(</span>
<span class="line-modified"> 927                     negotiatedMaxFragLen, protocolVersion,</span>
<span class="line-modified"> 928                     protocolVersion.isDTLS);</span>
<span class="line-modified"> 929         }</span>


 930 
<span class="line-modified"> 931         if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified"> 932             return (maximumPacketSize &gt; packetSize) ?</span>
<span class="line-modified"> 933                     maximumPacketSize : packetSize;</span>
<span class="line-modified"> 934         }</span>
 935 
<span class="line-modified"> 936         if (packetSize != 0) {</span>
<span class="line-modified"> 937            return packetSize;</span>
<span class="line-modified"> 938         }</span>
 939 
<span class="line-modified"> 940         if (protocolVersion.isDTLS) {</span>
<span class="line-modified"> 941             return DTLSRecord.maxRecordSize;</span>
<span class="line-modified"> 942         } else {</span>
<span class="line-modified"> 943             return acceptLargeFragments ?</span>
<span class="line-modified"> 944                     SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>



 945         }
 946     }
 947 
 948     /**
 949      * Gets the current size of the largest application data that is
 950      * expected when using this session.
 951      */
 952     @Override
<span class="line-modified"> 953     public synchronized int getApplicationBufferSize() {</span>
<span class="line-modified"> 954         // Use the bigger fragment size calculated from maximumPacketSize</span>
<span class="line-modified"> 955         // and negotiatedMaxFragLen.</span>
<span class="line-modified"> 956         int fragmentSize = 0;</span>
<span class="line-modified"> 957         if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified"> 958             fragmentSize = cipherSuite.calculateFragSize(</span>
<span class="line-modified"> 959                     maximumPacketSize, protocolVersion,</span>
<span class="line-modified"> 960                     protocolVersion.isDTLS);</span>
<span class="line-modified"> 961         }</span>


 962 
<span class="line-modified"> 963         if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified"> 964             return (negotiatedMaxFragLen &gt; fragmentSize) ?</span>
<span class="line-modified"> 965                     negotiatedMaxFragLen : fragmentSize;</span>
<span class="line-modified"> 966         }</span>
 967 
<span class="line-modified"> 968         if (fragmentSize != 0) {</span>
<span class="line-modified"> 969             return fragmentSize;</span>
<span class="line-modified"> 970         }</span>
 971 
<span class="line-modified"> 972         if (protocolVersion.isDTLS) {</span>
<span class="line-modified"> 973             return Record.maxDataSize;</span>
<span class="line-modified"> 974         } else {</span>
<span class="line-modified"> 975             int maxPacketSize = acceptLargeFragments ?</span>
<span class="line-modified"> 976                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="line-modified"> 977             return (maxPacketSize - SSLRecord.headerSize);</span>



 978         }
 979     }
 980 
 981     /**
 982      * Sets the negotiated maximum fragment length, as specified by the
 983      * max_fragment_length ClientHello extension in RFC 6066.
 984      *
 985      * @param  negotiatedMaxFragLen
 986      *         the negotiated maximum fragment length, or {@code -1} if
 987      *         no such length has been negotiated.
 988      */
<span class="line-modified"> 989     synchronized void setNegotiatedMaxFragSize(</span>
 990             int negotiatedMaxFragLen) {
<span class="line-modified"> 991 </span>
<span class="line-modified"> 992         this.negotiatedMaxFragLen = negotiatedMaxFragLen;</span>




 993     }
 994 
 995     /**
 996      * Get the negotiated maximum fragment length, as specified by the
 997      * max_fragment_length ClientHello extension in RFC 6066.
 998      *
 999      * @return the negotiated maximum fragment length, or {@code -1} if
1000      *         no such length has been negotiated.
1001      */
<span class="line-modified">1002     synchronized int getNegotiatedMaxFragSize() {</span>
<span class="line-modified">1003         return negotiatedMaxFragLen;</span>





1004     }
1005 
<span class="line-modified">1006     synchronized void setMaximumPacketSize(int maximumPacketSize) {</span>
<span class="line-modified">1007         this.maximumPacketSize = maximumPacketSize;</span>





1008     }
1009 
<span class="line-modified">1010     synchronized int getMaximumPacketSize() {</span>
<span class="line-modified">1011         return maximumPacketSize;</span>





1012     }
1013 
1014     /**
1015      * Gets an array of supported signature algorithm names that the local
1016      * side is willing to verify.
1017      */
1018     @Override
1019     public String[] getLocalSupportedSignatureAlgorithms() {
1020         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1021     }
1022 
1023     /**
1024      * Gets an array of supported signature schemes that the local side is
1025      * willing to verify.
1026      */
1027     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1028         return localSupportedSignAlgs;
1029     }
1030 
1031     /**
1032      * Gets an array of supported signature algorithms that the peer is
1033      * able to verify.
1034      */
1035     @Override
1036     public String[] getPeerSupportedSignatureAlgorithms() {
<span class="line-modified">1037         if (peerSupportedSignAlgs != null) {</span>
<span class="line-removed">1038             return peerSupportedSignAlgs.clone();</span>
<span class="line-removed">1039         }</span>
<span class="line-removed">1040 </span>
<span class="line-removed">1041         return new String[0];</span>
1042     }
1043 
1044     /**
1045      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1046      * of the requested Server Name Indication (SNI) extension.
1047      */
1048     @Override
1049     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1050         return requestedServerNames;
1051     }
1052 
1053     /** Returns a string representation of this SSL session */
1054     @Override
1055     public String toString() {
1056         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1057     }
1058 }
1059 
1060 /**
1061  * This &quot;struct&quot; class serves as a Hash Key that combines an
</pre>
</td>
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
<span class="line-added">  27 import sun.security.x509.X509CertImpl;</span>
<span class="line-added">  28 </span>
<span class="line-added">  29 import java.io.IOException;</span>
<span class="line-added">  30 import java.lang.reflect.Array;</span>
  31 import java.math.BigInteger;
  32 import java.net.InetAddress;
<span class="line-added">  33 import java.nio.ByteBuffer;</span>
  34 import java.security.Principal;
  35 import java.security.PrivateKey;
  36 import java.security.cert.CertificateEncodingException;
  37 import java.security.cert.X509Certificate;
  38 import java.util.ArrayList;
<span class="line-added">  39 import java.util.Arrays;</span>
  40 import java.util.Queue;
  41 import java.util.Collection;
  42 import java.util.Collections;
  43 import java.util.Enumeration;
  44 import java.util.List;

  45 import java.util.concurrent.ConcurrentHashMap;
  46 import java.util.concurrent.ConcurrentLinkedQueue;
<span class="line-added">  47 import java.util.concurrent.locks.ReentrantLock;</span>
  48 import javax.crypto.SecretKey;
<span class="line-added">  49 import javax.crypto.spec.SecretKeySpec;</span>
  50 import javax.net.ssl.ExtendedSSLSession;
<span class="line-added">  51 import javax.net.ssl.SNIHostName;</span>
  52 import javax.net.ssl.SNIServerName;
<span class="line-added">  53 import javax.net.ssl.SSLException;</span>
  54 import javax.net.ssl.SSLPeerUnverifiedException;
  55 import javax.net.ssl.SSLPermission;
  56 import javax.net.ssl.SSLSessionBindingEvent;
  57 import javax.net.ssl.SSLSessionBindingListener;
  58 import javax.net.ssl.SSLSessionContext;
  59 
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
</pre>
<hr />
<pre>
  89     private final ProtocolVersion       protocolVersion;
  90     private final SessionId             sessionId;
  91     private X509Certificate[]   peerCerts;
  92     private CipherSuite         cipherSuite;
  93     private SecretKey           masterSecret;
  94     final boolean               useExtendedMasterSecret;
  95 
  96     /*
  97      * Information not part of the SSLv3 protocol spec, but used
  98      * to support session management policies.
  99      */
 100     private final long          creationTime;
 101     private long                lastUsedTime = 0;
 102     private final String        host;
 103     private final int           port;
 104     private SSLSessionContextImpl       context;
 105     private boolean             invalidated;
 106     private X509Certificate[]   localCerts;
 107     private PrivateKey          localPrivateKey;
 108     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
<span class="line-modified"> 109     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate</span>
 110     private boolean             useDefaultPeerSignAlgs = false;
 111     private List&lt;byte[]&gt;        statusResponses;
 112     private SecretKey           resumptionMasterSecret;
 113     private SecretKey           preSharedKey;
 114     private byte[]              pskIdentity;
 115     private final long          ticketCreationTime = System.currentTimeMillis();
 116     private int                 ticketAgeAdd;
 117 
 118     private int                 negotiatedMaxFragLen = -1;
 119     private int                 maximumPacketSize;
 120 
 121     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 122                                         new ConcurrentLinkedQueue&lt;&gt;();
 123 
 124     /*
 125      * Is the session currently re-established with a session-resumption
 126      * abbreviated initial handshake?
 127      *
 128      * Note that currently we only set this variable in client side.
 129      */
 130     private boolean isSessionResumption = false;
 131 
 132     /*
 133      * Use of session caches is globally enabled/disabled.
 134      */
 135     private static boolean      defaultRejoinable = true;
 136 
 137     // server name indication
 138     final SNIServerName         serverNameIndication;
 139     private final List&lt;SNIServerName&gt;    requestedServerNames;
 140 
 141     // Counter used to create unique nonces in NewSessionTicket
 142     private BigInteger ticketNonceCounter = BigInteger.ONE;
 143 
 144     // The endpoint identification algorithm used to check certificates
 145     // in this session.
<span class="line-modified"> 146     private final String        identificationProtocol;</span>
<span class="line-added"> 147 </span>
<span class="line-added"> 148     private final ReentrantLock sessionLock = new ReentrantLock();</span>
 149 
 150     /*
 151      * Create a new non-rejoinable session, using the default (null)
 152      * cipher spec.  This constructor returns a session which could
 153      * be used either by a client or by a server, as a connection is
 154      * first opened and before handshaking begins.
 155      */
 156     private SSLSessionImpl() {
 157         this.protocolVersion = ProtocolVersion.NONE;
 158         this.cipherSuite = CipherSuite.C_NULL;
 159         this.sessionId = new SessionId(false, null);
 160         this.host = null;
 161         this.port = -1;
 162         this.localSupportedSignAlgs = Collections.emptySet();
 163         this.serverNameIndication = null;
 164         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 165         this.useExtendedMasterSecret = false;
 166         this.creationTime = System.currentTimeMillis();
 167         this.identificationProtocol = null;
 168         this.boundValues = new ConcurrentHashMap&lt;&gt;();
</pre>
<hr />
<pre>
 221         }
 222         this.creationTime = creationTime;
 223         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 224         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 225 
 226         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 227              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 228         }
 229     }
 230 
 231     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 232         this.protocolVersion = baseSession.getProtocolVersion();
 233         this.cipherSuite = baseSession.cipherSuite;
 234         this.sessionId = newId;
 235         this.host = baseSession.getPeerHost();
 236         this.port = baseSession.getPeerPort();
 237         this.localSupportedSignAlgs =
 238                 baseSession.localSupportedSignAlgs == null ?
 239                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 240         this.peerSupportedSignAlgs =
<span class="line-modified"> 241                 baseSession.peerSupportedSignAlgs == null ?</span>
<span class="line-added"> 242                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;</span>
 243         this.serverNameIndication = baseSession.serverNameIndication;
 244         this.requestedServerNames = baseSession.getRequestedServerNames();
 245         this.masterSecret = baseSession.getMasterSecret();
 246         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 247         this.creationTime = baseSession.getCreationTime();
 248         this.lastUsedTime = System.currentTimeMillis();
 249         this.identificationProtocol = baseSession.getIdentificationProtocol();
 250         this.localCerts = baseSession.localCerts;
 251         this.peerCerts = baseSession.peerCerts;
 252         this.statusResponses = baseSession.statusResponses;
 253         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 254         this.context = baseSession.context;
 255         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 256         this.maximumPacketSize = baseSession.maximumPacketSize;
 257         this.boundValues = baseSession.boundValues;
 258 
 259         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 260              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 261         }
 262     }
 263 
<span class="line-added"> 264     /**</span>
<span class="line-added"> 265      * &lt; 2 bytes &gt; protocolVersion</span>
<span class="line-added"> 266      * &lt; 2 bytes &gt; cipherSuite</span>
<span class="line-added"> 267      * &lt; 1 byte &gt; localSupportedSignAlgs entries</span>
<span class="line-added"> 268      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs</span>
<span class="line-added"> 269      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries</span>
<span class="line-added"> 270      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs</span>
<span class="line-added"> 271      * &lt; 2 bytes &gt; preSharedKey length</span>
<span class="line-added"> 272      * &lt; length in bytes &gt; preSharedKey</span>
<span class="line-added"> 273      * &lt; 1 byte &gt; pskIdentity length</span>
<span class="line-added"> 274      * &lt; length in bytes &gt; pskIdentity</span>
<span class="line-added"> 275      * &lt; 1 byte &gt; masterSecret length</span>
<span class="line-added"> 276      *   &lt; 1 byte &gt; masterSecret algorithm length</span>
<span class="line-added"> 277      *   &lt; length in bytes &gt; masterSecret algorithm</span>
<span class="line-added"> 278      *   &lt; 2 bytes &gt; masterSecretKey length</span>
<span class="line-added"> 279      *   &lt; length in bytes&gt; masterSecretKey</span>
<span class="line-added"> 280      * &lt; 1 byte &gt; useExtendedMasterSecret</span>
<span class="line-added"> 281      * &lt; 1 byte &gt; identificationProtocol length</span>
<span class="line-added"> 282      * &lt; length in bytes &gt; identificationProtocol</span>
<span class="line-added"> 283      * &lt; 1 byte &gt; serverNameIndication length</span>
<span class="line-added"> 284      * &lt; length in bytes &gt; serverNameIndication</span>
<span class="line-added"> 285      * &lt; 1 byte &gt; Number of requestedServerNames entries</span>
<span class="line-added"> 286      *   &lt; 1 byte &gt; ServerName length</span>
<span class="line-added"> 287      *   &lt; length in bytes &gt; ServerName</span>
<span class="line-added"> 288      * &lt; 4 bytes &gt; creationTime</span>
<span class="line-added"> 289      * &lt; 2 byte &gt; status response length</span>
<span class="line-added"> 290      *   &lt; 2 byte &gt; status response entry length</span>
<span class="line-added"> 291      *   &lt; length in byte &gt; status response entry</span>
<span class="line-added"> 292      * &lt; 1 byte &gt; Length of peer host</span>
<span class="line-added"> 293      *   &lt; length in bytes &gt; peer host</span>
<span class="line-added"> 294      * &lt; 2 bytes&gt; peer port</span>
<span class="line-added"> 295      * &lt; 1 byte &gt; Number of peerCerts entries</span>
<span class="line-added"> 296      *   &lt; 4 byte &gt; peerCert length</span>
<span class="line-added"> 297      *   &lt; length in bytes &gt; peerCert</span>
<span class="line-added"> 298      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)</span>
<span class="line-added"> 299      *   Certificate</span>
<span class="line-added"> 300      *     &lt; 1 byte &gt; Number of Certificate entries</span>
<span class="line-added"> 301      *       &lt; 4 byte&gt; Certificate length</span>
<span class="line-added"> 302      *       &lt; length in bytes&gt; Certificate</span>
<span class="line-added"> 303      *   PSK</span>
<span class="line-added"> 304      *     &lt; 1 byte &gt; Number of PSK entries</span>
<span class="line-added"> 305      *       &lt; 1 bytes &gt; PSK algorithm length</span>
<span class="line-added"> 306      *       &lt; length in bytes &gt; PSK algorithm string</span>
<span class="line-added"> 307      *       &lt; 4 bytes &gt; PSK key length</span>
<span class="line-added"> 308      *       &lt; length in bytes&gt; PSK key</span>
<span class="line-added"> 309      *       &lt; 4 bytes &gt; PSK identity length</span>
<span class="line-added"> 310      *       &lt; length in bytes&gt; PSK identity</span>
<span class="line-added"> 311      *   Anonymous</span>
<span class="line-added"> 312      *     &lt; 1 byte &gt;</span>
<span class="line-added"> 313      * &lt; 4 bytes &gt; maximumPacketSize</span>
<span class="line-added"> 314      * &lt; 4 bytes &gt; negotiatedMaxFragSize</span>
<span class="line-added"> 315     */</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {</span>
<span class="line-added"> 318         int i = 0;</span>
<span class="line-added"> 319         byte[] b;</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321         boundValues = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-added"> 322         this.protocolVersion =</span>
<span class="line-added"> 323                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added"> 326             this.sessionId = new SessionId(false, null);</span>
<span class="line-added"> 327         } else {</span>
<span class="line-added"> 328             // The CH session id may reset this if it&#39;s provided</span>
<span class="line-added"> 329             this.sessionId = new SessionId(true,</span>
<span class="line-added"> 330                     hc.sslContext.getSecureRandom());</span>
<span class="line-added"> 331         }</span>
<span class="line-added"> 332 </span>
<span class="line-added"> 333         this.cipherSuite =</span>
<span class="line-added"> 334                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336         // Local Supported signature algorithms</span>
<span class="line-added"> 337         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 338         i = Byte.toUnsignedInt(buf.get());</span>
<span class="line-added"> 339         while (i-- &gt; 0) {</span>
<span class="line-added"> 340             list.add(SignatureScheme.valueOf(</span>
<span class="line-added"> 341                     Short.toUnsignedInt(buf.getShort())));</span>
<span class="line-added"> 342         }</span>
<span class="line-added"> 343         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345         // Peer Supported signature algorithms</span>
<span class="line-added"> 346         i = Byte.toUnsignedInt(buf.get());</span>
<span class="line-added"> 347         list.clear();</span>
<span class="line-added"> 348         while (i-- &gt; 0) {</span>
<span class="line-added"> 349             list.add(SignatureScheme.valueOf(</span>
<span class="line-added"> 350                     Short.toUnsignedInt(buf.getShort())));</span>
<span class="line-added"> 351         }</span>
<span class="line-added"> 352         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);</span>
<span class="line-added"> 353 </span>
<span class="line-added"> 354         // PSK</span>
<span class="line-added"> 355         i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 356         if (i &gt; 0) {</span>
<span class="line-added"> 357             b = new byte[i];</span>
<span class="line-added"> 358             // Get algorithm string</span>
<span class="line-added"> 359             buf.get(b, 0, i);</span>
<span class="line-added"> 360             // Encoded length</span>
<span class="line-added"> 361             i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 362             // Encoded SecretKey</span>
<span class="line-added"> 363             b = new byte[i];</span>
<span class="line-added"> 364             buf.get(b);</span>
<span class="line-added"> 365             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);</span>
<span class="line-added"> 366         } else {</span>
<span class="line-added"> 367             this.preSharedKey = null;</span>
<span class="line-added"> 368         }</span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370         // PSK identity</span>
<span class="line-added"> 371         i = buf.get();</span>
<span class="line-added"> 372         if (i &gt; 0) {</span>
<span class="line-added"> 373             b = new byte[i];</span>
<span class="line-added"> 374             buf.get(b);</span>
<span class="line-added"> 375             this.pskIdentity = b;</span>
<span class="line-added"> 376         } else {</span>
<span class="line-added"> 377             this.pskIdentity = null;</span>
<span class="line-added"> 378         }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380         // Master secret length of secret key algorithm  (one byte)</span>
<span class="line-added"> 381         i = buf.get();</span>
<span class="line-added"> 382         if (i &gt; 0) {</span>
<span class="line-added"> 383             b = new byte[i];</span>
<span class="line-added"> 384             // Get algorithm string</span>
<span class="line-added"> 385             buf.get(b, 0, i);</span>
<span class="line-added"> 386             // Encoded length</span>
<span class="line-added"> 387             i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 388             // Encoded SecretKey</span>
<span class="line-added"> 389             b = new byte[i];</span>
<span class="line-added"> 390             buf.get(b);</span>
<span class="line-added"> 391             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);</span>
<span class="line-added"> 392         } else {</span>
<span class="line-added"> 393             this.masterSecret = null;</span>
<span class="line-added"> 394         }</span>
<span class="line-added"> 395         // Use extended master secret</span>
<span class="line-added"> 396         this.useExtendedMasterSecret = (buf.get() != 0);</span>
<span class="line-added"> 397 </span>
<span class="line-added"> 398         // Identification Protocol</span>
<span class="line-added"> 399         i = buf.get();</span>
<span class="line-added"> 400         if (i == 0) {</span>
<span class="line-added"> 401             identificationProtocol = null;</span>
<span class="line-added"> 402         } else {</span>
<span class="line-added"> 403             b = new byte[i];</span>
<span class="line-added"> 404             identificationProtocol =</span>
<span class="line-added"> 405                     buf.get(b, 0, i).asCharBuffer().toString();</span>
<span class="line-added"> 406         }</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408         // SNI</span>
<span class="line-added"> 409         i = buf.get();  // length</span>
<span class="line-added"> 410         if (i == 0) {</span>
<span class="line-added"> 411             serverNameIndication = null;</span>
<span class="line-added"> 412         } else {</span>
<span class="line-added"> 413             b = new byte[i];</span>
<span class="line-added"> 414             buf.get(b, 0, b.length);</span>
<span class="line-added"> 415             serverNameIndication = new SNIHostName(b);</span>
<span class="line-added"> 416         }</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418         // List of SNIServerName</span>
<span class="line-added"> 419         int len = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 420         if (len == 0) {</span>
<span class="line-added"> 421             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();</span>
<span class="line-added"> 422         } else {</span>
<span class="line-added"> 423             requestedServerNames = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 424             while (len &gt; 0) {</span>
<span class="line-added"> 425                 int l = buf.get();</span>
<span class="line-added"> 426                 b = new byte[l];</span>
<span class="line-added"> 427                 buf.get(b, 0, l);</span>
<span class="line-added"> 428                 requestedServerNames.add(new SNIHostName(new String(b)));</span>
<span class="line-added"> 429                 len--;</span>
<span class="line-added"> 430             }</span>
<span class="line-added"> 431         }</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433         maximumPacketSize = buf.getInt();</span>
<span class="line-added"> 434         negotiatedMaxFragLen = buf.getInt();</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436         // Get creation time</span>
<span class="line-added"> 437         this.creationTime = buf.getLong();</span>
<span class="line-added"> 438 </span>
<span class="line-added"> 439         // Get Buffer sizes</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441         // Status Response</span>
<span class="line-added"> 442         len = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 443         if (len == 0) {</span>
<span class="line-added"> 444             statusResponses = Collections.emptyList();</span>
<span class="line-added"> 445         } else {</span>
<span class="line-added"> 446             statusResponses = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 447         }</span>
<span class="line-added"> 448         while (len-- &gt; 0) {</span>
<span class="line-added"> 449             b = new byte[Short.toUnsignedInt(buf.getShort())];</span>
<span class="line-added"> 450             buf.get(b);</span>
<span class="line-added"> 451             statusResponses.add(b);</span>
<span class="line-added"> 452         }</span>
<span class="line-added"> 453 </span>
<span class="line-added"> 454         // Get Peer host &amp; port</span>
<span class="line-added"> 455         i = Byte.toUnsignedInt(buf.get());</span>
<span class="line-added"> 456         if (i == 0) {</span>
<span class="line-added"> 457             this.host = new String();</span>
<span class="line-added"> 458         } else {</span>
<span class="line-added"> 459             b = new byte[i];</span>
<span class="line-added"> 460             this.host = buf.get(b).toString();</span>
<span class="line-added"> 461         }</span>
<span class="line-added"> 462         this.port = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 463 </span>
<span class="line-added"> 464         // Peer certs</span>
<span class="line-added"> 465         i = buf.get();</span>
<span class="line-added"> 466         if (i == 0) {</span>
<span class="line-added"> 467             this.peerCerts = null;</span>
<span class="line-added"> 468         } else {</span>
<span class="line-added"> 469             this.peerCerts = new X509Certificate[i];</span>
<span class="line-added"> 470             int j = 0;</span>
<span class="line-added"> 471             while (i &gt; j) {</span>
<span class="line-added"> 472                 b = new byte[buf.getInt()];</span>
<span class="line-added"> 473                 buf.get(b);</span>
<span class="line-added"> 474                 try {</span>
<span class="line-added"> 475                     this.peerCerts[j] = new X509CertImpl(b);</span>
<span class="line-added"> 476                 } catch (Exception e) {</span>
<span class="line-added"> 477                     throw new IOException(e);</span>
<span class="line-added"> 478                 }</span>
<span class="line-added"> 479                 j++;</span>
<span class="line-added"> 480             }</span>
<span class="line-added"> 481         }</span>
<span class="line-added"> 482 </span>
<span class="line-added"> 483         // Get local certs of PSK</span>
<span class="line-added"> 484         switch (buf.get()) {</span>
<span class="line-added"> 485             case 0:</span>
<span class="line-added"> 486                 break;</span>
<span class="line-added"> 487             case 1:</span>
<span class="line-added"> 488                 // number of certs</span>
<span class="line-added"> 489                 len = buf.get();</span>
<span class="line-added"> 490                 this.localCerts = new X509Certificate[len];</span>
<span class="line-added"> 491                 i = 0;</span>
<span class="line-added"> 492                 while (len &gt; i) {</span>
<span class="line-added"> 493                     b = new byte[buf.getInt()];</span>
<span class="line-added"> 494                     buf.get(b);</span>
<span class="line-added"> 495                     try {</span>
<span class="line-added"> 496                         this.localCerts[i] = new X509CertImpl(b);</span>
<span class="line-added"> 497                     } catch (Exception e) {</span>
<span class="line-added"> 498                         throw new IOException(e);</span>
<span class="line-added"> 499                     }</span>
<span class="line-added"> 500                     i++;</span>
<span class="line-added"> 501                 }</span>
<span class="line-added"> 502                 break;</span>
<span class="line-added"> 503             case 2:</span>
<span class="line-added"> 504                 // pre-shared key</span>
<span class="line-added"> 505                 // Length of pre-shared key algorithm  (one byte)</span>
<span class="line-added"> 506                 i = buf.get();</span>
<span class="line-added"> 507                 b = new byte[i];</span>
<span class="line-added"> 508                 String alg = buf.get(b, 0, i).asCharBuffer().toString();</span>
<span class="line-added"> 509                 // Get length of encoding</span>
<span class="line-added"> 510                 i = Short.toUnsignedInt(buf.getShort());</span>
<span class="line-added"> 511                 // Get encoding</span>
<span class="line-added"> 512                 b = new byte[i];</span>
<span class="line-added"> 513                 buf.get(b);</span>
<span class="line-added"> 514                 this.preSharedKey = new SecretKeySpec(b, alg);</span>
<span class="line-added"> 515                 // Get identity len</span>
<span class="line-added"> 516                 this.pskIdentity = new byte[buf.get()];</span>
<span class="line-added"> 517                 buf.get(pskIdentity);</span>
<span class="line-added"> 518                 break;</span>
<span class="line-added"> 519             default:</span>
<span class="line-added"> 520                 throw new SSLException(&quot;Failed local certs of session.&quot;);</span>
<span class="line-added"> 521         }</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523         context = (SSLSessionContextImpl)</span>
<span class="line-added"> 524                 hc.sslContext.engineGetServerSessionContext();</span>
<span class="line-added"> 525         this.lastUsedTime = System.currentTimeMillis();</span>
<span class="line-added"> 526     }</span>
<span class="line-added"> 527 </span>
<span class="line-added"> 528     // Some situations we cannot provide a stateless ticket, but after it</span>
<span class="line-added"> 529     // has been negotiated</span>
<span class="line-added"> 530     boolean isStatelessable(HandshakeContext hc) {</span>
<span class="line-added"> 531         if (!hc.statelessResumption) {</span>
<span class="line-added"> 532             return false;</span>
<span class="line-added"> 533         }</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535         // If there is no getMasterSecret with TLS1.2 or under, do not resume.</span>
<span class="line-added"> 536         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added"> 537                 getMasterSecret().getEncoded() == null) {</span>
<span class="line-added"> 538             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added"> 539                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +</span>
<span class="line-added"> 540                         &quot; ticket&quot;);</span>
<span class="line-added"> 541             }</span>
<span class="line-added"> 542             return false;</span>
<span class="line-added"> 543         }</span>
<span class="line-added"> 544         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {</span>
<span class="line-added"> 545             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added"> 546                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +</span>
<span class="line-added"> 547                         &quot; stateless ticket&quot;);</span>
<span class="line-added"> 548             }</span>
<span class="line-added"> 549             return false;</span>
<span class="line-added"> 550         }</span>
<span class="line-added"> 551         return true;</span>
<span class="line-added"> 552     }</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554     /**</span>
<span class="line-added"> 555      * Write out a SSLSessionImpl in a byte array for a stateless session ticket</span>
<span class="line-added"> 556      */</span>
<span class="line-added"> 557     byte[] write() throws Exception {</span>
<span class="line-added"> 558         byte[] b;</span>
<span class="line-added"> 559         HandshakeOutStream hos = new HandshakeOutStream(null);</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561         hos.putInt16(protocolVersion.id);</span>
<span class="line-added"> 562         hos.putInt16(cipherSuite.id);</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564         // Local Supported signature algorithms</span>
<span class="line-added"> 565         hos.putInt8(localSupportedSignAlgs.size());</span>
<span class="line-added"> 566         for (SignatureScheme s : localSupportedSignAlgs) {</span>
<span class="line-added"> 567             hos.putInt16(s.id);</span>
<span class="line-added"> 568         }</span>
<span class="line-added"> 569 </span>
<span class="line-added"> 570         // Peer Supported signature algorithms</span>
<span class="line-added"> 571         hos.putInt8(peerSupportedSignAlgs.size());</span>
<span class="line-added"> 572         for (SignatureScheme s : peerSupportedSignAlgs) {</span>
<span class="line-added"> 573             hos.putInt16(s.id);</span>
<span class="line-added"> 574         }</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576         // PSK</span>
<span class="line-added"> 577         if (preSharedKey == null ||</span>
<span class="line-added"> 578                 preSharedKey.getAlgorithm() == null) {</span>
<span class="line-added"> 579             hos.putInt16(0);</span>
<span class="line-added"> 580         } else {</span>
<span class="line-added"> 581             hos.putInt16(preSharedKey.getAlgorithm().length());</span>
<span class="line-added"> 582             if (preSharedKey.getAlgorithm().length() != 0) {</span>
<span class="line-added"> 583                 hos.write(preSharedKey.getAlgorithm().getBytes());</span>
<span class="line-added"> 584             }</span>
<span class="line-added"> 585             b = preSharedKey.getEncoded();</span>
<span class="line-added"> 586             hos.putInt16(b.length);</span>
<span class="line-added"> 587             hos.write(b, 0, b.length);</span>
<span class="line-added"> 588         }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590         // PSK Identity</span>
<span class="line-added"> 591         if (pskIdentity == null) {</span>
<span class="line-added"> 592             hos.putInt8(0);</span>
<span class="line-added"> 593         } else {</span>
<span class="line-added"> 594             hos.putInt8(pskIdentity.length);</span>
<span class="line-added"> 595             hos.write(pskIdentity, 0, pskIdentity.length);</span>
<span class="line-added"> 596         }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598         // Master Secret</span>
<span class="line-added"> 599         if (getMasterSecret() == null ||</span>
<span class="line-added"> 600                 getMasterSecret().getAlgorithm() == null) {</span>
<span class="line-added"> 601             hos.putInt8(0);</span>
<span class="line-added"> 602         } else {</span>
<span class="line-added"> 603             hos.putInt8(getMasterSecret().getAlgorithm().length());</span>
<span class="line-added"> 604             if (getMasterSecret().getAlgorithm().length() != 0) {</span>
<span class="line-added"> 605                 hos.write(getMasterSecret().getAlgorithm().getBytes());</span>
<span class="line-added"> 606             }</span>
<span class="line-added"> 607             b = getMasterSecret().getEncoded();</span>
<span class="line-added"> 608             hos.putInt16(b.length);</span>
<span class="line-added"> 609             hos.write(b, 0, b.length);</span>
<span class="line-added"> 610         }</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612         hos.putInt8(useExtendedMasterSecret ? 1 : 0);</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614         // Identification Protocol</span>
<span class="line-added"> 615         if (identificationProtocol == null) {</span>
<span class="line-added"> 616             hos.putInt8(0);</span>
<span class="line-added"> 617         } else {</span>
<span class="line-added"> 618             hos.putInt8(identificationProtocol.length());</span>
<span class="line-added"> 619             hos.write(identificationProtocol.getBytes(), 0,</span>
<span class="line-added"> 620                     identificationProtocol.length());</span>
<span class="line-added"> 621         }</span>
<span class="line-added"> 622 </span>
<span class="line-added"> 623         // SNI</span>
<span class="line-added"> 624         if (serverNameIndication == null) {</span>
<span class="line-added"> 625             hos.putInt8(0);</span>
<span class="line-added"> 626         } else {</span>
<span class="line-added"> 627             b = serverNameIndication.getEncoded();</span>
<span class="line-added"> 628             hos.putInt8(b.length);</span>
<span class="line-added"> 629             hos.write(b, 0, b.length);</span>
<span class="line-added"> 630         }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632         // List of SNIServerName</span>
<span class="line-added"> 633         hos.putInt16(requestedServerNames.size());</span>
<span class="line-added"> 634         if (requestedServerNames.size() &gt; 0) {</span>
<span class="line-added"> 635             for (SNIServerName host : requestedServerNames) {</span>
<span class="line-added"> 636                 b = host.getEncoded();</span>
<span class="line-added"> 637                 hos.putInt8(b.length);</span>
<span class="line-added"> 638                 hos.write(b, 0, b.length);</span>
<span class="line-added"> 639             }</span>
<span class="line-added"> 640         }</span>
<span class="line-added"> 641 </span>
<span class="line-added"> 642         // Buffer sizes</span>
<span class="line-added"> 643         hos.putInt32(maximumPacketSize);</span>
<span class="line-added"> 644         hos.putInt32(negotiatedMaxFragLen);</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646         // creation time</span>
<span class="line-added"> 647         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);</span>
<span class="line-added"> 648         hos.writeBytes(buffer.putLong(creationTime).array());</span>
<span class="line-added"> 649 </span>
<span class="line-added"> 650         // Status Responses</span>
<span class="line-added"> 651         List&lt;byte[]&gt; list = getStatusResponses();</span>
<span class="line-added"> 652         int l = list.size();</span>
<span class="line-added"> 653         hos.putInt16(l);</span>
<span class="line-added"> 654         for (byte[] e : list) {</span>
<span class="line-added"> 655             hos.putInt16(e.length);</span>
<span class="line-added"> 656             hos.write(e);</span>
<span class="line-added"> 657         }</span>
<span class="line-added"> 658 </span>
<span class="line-added"> 659         // peer Host &amp; Port</span>
<span class="line-added"> 660         if (host == null || host.length() == 0) {</span>
<span class="line-added"> 661             hos.putInt8(0);</span>
<span class="line-added"> 662         } else {</span>
<span class="line-added"> 663             hos.putInt8(host.length());</span>
<span class="line-added"> 664             hos.writeBytes(host.getBytes());</span>
<span class="line-added"> 665         }</span>
<span class="line-added"> 666         hos.putInt16(port);</span>
<span class="line-added"> 667 </span>
<span class="line-added"> 668         // Peer cert</span>
<span class="line-added"> 669         if (peerCerts == null || peerCerts.length == 0) {</span>
<span class="line-added"> 670             hos.putInt8(0);</span>
<span class="line-added"> 671         } else {</span>
<span class="line-added"> 672             hos.putInt8(peerCerts.length);</span>
<span class="line-added"> 673             for (X509Certificate c : peerCerts) {</span>
<span class="line-added"> 674                 b = c.getEncoded();</span>
<span class="line-added"> 675                 hos.putInt32(b.length);</span>
<span class="line-added"> 676                 hos.writeBytes(b);</span>
<span class="line-added"> 677             }</span>
<span class="line-added"> 678         }</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680         // Client identity</span>
<span class="line-added"> 681         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {</span>
<span class="line-added"> 682             // certificate based</span>
<span class="line-added"> 683             hos.putInt8(1);</span>
<span class="line-added"> 684             hos.putInt8(localCerts.length);</span>
<span class="line-added"> 685             for (X509Certificate c : localCerts) {</span>
<span class="line-added"> 686                 b = c.getEncoded();</span>
<span class="line-added"> 687                 hos.putInt32(b.length);</span>
<span class="line-added"> 688                 hos.writeBytes(b);</span>
<span class="line-added"> 689             }</span>
<span class="line-added"> 690         } else if (preSharedKey != null) {</span>
<span class="line-added"> 691             // pre-shared key</span>
<span class="line-added"> 692             hos.putInt8(2);</span>
<span class="line-added"> 693             hos.putInt8(preSharedKey.getAlgorithm().length());</span>
<span class="line-added"> 694             hos.write(preSharedKey.getAlgorithm().getBytes());</span>
<span class="line-added"> 695             b = preSharedKey.getEncoded();</span>
<span class="line-added"> 696             hos.putInt32(b.length);</span>
<span class="line-added"> 697             hos.writeBytes(b);</span>
<span class="line-added"> 698             hos.putInt32(pskIdentity.length);</span>
<span class="line-added"> 699             hos.writeBytes(pskIdentity);</span>
<span class="line-added"> 700         } else {</span>
<span class="line-added"> 701             // anonymous</span>
<span class="line-added"> 702             hos.putInt8(0);</span>
<span class="line-added"> 703         }</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705         return hos.toByteArray();</span>
<span class="line-added"> 706     }</span>
<span class="line-added"> 707 </span>
 708     void setMasterSecret(SecretKey secret) {
 709         masterSecret = secret;
 710     }
 711 
 712     void setResumptionMasterSecret(SecretKey secret) {
 713         resumptionMasterSecret = secret;
 714     }
 715 
 716     void setPreSharedKey(SecretKey key) {
 717         preSharedKey = key;
 718     }
 719 
 720     void addChild(SSLSessionImpl session) {
 721         childSessions.add(session);
 722     }
 723 
 724     void setTicketAgeAdd(int ticketAgeAdd) {
 725         this.ticketAgeAdd = ticketAgeAdd;
 726     }
 727 
 728     void setPskIdentity(byte[] pskIdentity) {
 729         this.pskIdentity = pskIdentity;
 730     }
 731 
 732     BigInteger incrTicketNonceCounter() {
 733         BigInteger result = ticketNonceCounter;
<span class="line-modified"> 734         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);</span>
 735         return result;
 736     }
 737 
<span class="line-added"> 738     boolean isPSKable() {</span>
<span class="line-added"> 739         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);</span>
<span class="line-added"> 740     }</span>
<span class="line-added"> 741 </span>
 742     /**
 743      * Returns the master secret ... treat with extreme caution!
 744      */
 745     SecretKey getMasterSecret() {
 746         return masterSecret;
 747     }
 748 
<span class="line-modified"> 749     SecretKey getResumptionMasterSecret() {</span>
<span class="line-modified"> 750         return resumptionMasterSecret;</span>
 751     }
 752 
<span class="line-modified"> 753     SecretKey getPreSharedKey() {</span>
<span class="line-modified"> 754         sessionLock.lock();</span>
<span class="line-added"> 755         try {</span>
<span class="line-added"> 756             return preSharedKey;</span>
<span class="line-added"> 757         } finally {</span>
<span class="line-added"> 758             sessionLock.unlock();</span>
<span class="line-added"> 759         }</span>
 760     }
 761 
<span class="line-modified"> 762     SecretKey consumePreSharedKey() {</span>
<span class="line-modified"> 763         sessionLock.lock();</span>
<span class="line-modified"> 764         try {</span>
<span class="line-modified"> 765             return preSharedKey;</span>
<span class="line-added"> 766         } finally {</span>
<span class="line-added"> 767             preSharedKey = null;</span>
<span class="line-added"> 768             sessionLock.unlock();</span>
<span class="line-added"> 769         }</span>
 770     }
 771 
 772     int getTicketAgeAdd() {
 773         return ticketAgeAdd;
 774     }
 775 
 776     String getIdentificationProtocol() {
 777         return this.identificationProtocol;
 778     }
 779 
 780     /* PSK identities created from new_session_ticket messages should only
 781      * be used once. This method will return the identity and then clear it
 782      * so it cannot be used again.
 783      */
<span class="line-modified"> 784     byte[] consumePskIdentity() {</span>
<span class="line-modified"> 785         sessionLock.lock();</span>
<span class="line-modified"> 786         try {</span>
<span class="line-modified"> 787             return pskIdentity;</span>
<span class="line-added"> 788         } finally {</span>
<span class="line-added"> 789             pskIdentity = null;</span>
<span class="line-added"> 790             sessionLock.unlock();</span>
<span class="line-added"> 791         }</span>
<span class="line-added"> 792     }</span>
<span class="line-added"> 793 </span>
<span class="line-added"> 794     byte[] getPskIdentity() {</span>
<span class="line-added"> 795         return pskIdentity;</span>
 796     }
 797 
 798     void setPeerCertificates(X509Certificate[] peer) {
 799         if (peerCerts == null) {
 800             peerCerts = peer;
 801         }
 802     }
 803 
 804     void setLocalCertificates(X509Certificate[] local) {
 805         localCerts = local;
 806     }
 807 
 808     void setLocalPrivateKey(PrivateKey privateKey) {
 809         localPrivateKey = privateKey;
 810     }
 811 
 812     void setPeerSupportedSignatureAlgorithms(
 813             Collection&lt;SignatureScheme&gt; signatureSchemes) {
<span class="line-modified"> 814         peerSupportedSignAlgs = signatureSchemes;</span>

 815     }
 816 
 817     // TLS 1.2 only
 818     //
 819     // Per RFC 5246, If the client supports only the default hash
 820     // and signature algorithms, it MAY omit the
 821     // signature_algorithms extension.  If the client does not
 822     // support the default algorithms, or supports other hash
 823     // and signature algorithms (and it is willing to use them
 824     // for verifying messages sent by the server, i.e., server
 825     // certificates and server key exchange), it MUST send the
 826     // signature_algorithms extension, listing the algorithms it
 827     // is willing to accept.
<span class="line-added"> 828     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =</span>
<span class="line-added"> 829             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,</span>
<span class="line-added"> 830                     SignatureScheme.DSA_SHA1,</span>
<span class="line-added"> 831                     SignatureScheme.ECDSA_SHA1));</span>
<span class="line-added"> 832 </span>
 833     void setUseDefaultPeerSignAlgs() {
 834         useDefaultPeerSignAlgs = true;
<span class="line-modified"> 835         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;</span>

 836     }
 837 
 838     // Returns the connection session.
 839     SSLSessionImpl finish() {
 840         if (useDefaultPeerSignAlgs) {
<span class="line-modified"> 841             peerSupportedSignAlgs = Collections.emptySet();</span>
 842         }
 843 
 844         return this;
 845     }
 846 
 847     /**
 848      * Provide status response data obtained during the SSL handshake.
 849      *
 850      * @param responses a {@link List} of responses in binary form.
 851      */
 852     void setStatusResponses(List&lt;byte[]&gt; responses) {
 853         if (responses != null &amp;&amp; !responses.isEmpty()) {
 854             statusResponses = responses;
 855         } else {
 856             statusResponses = Collections.emptyList();
 857         }
 858     }
 859 
 860     /**
 861      * Returns true iff this session may be resumed ... sessions are
 862      * usually resumable.  Security policies may suggest otherwise,
 863      * for example sessions that haven&#39;t been used for a while (say,
 864      * a working day) won&#39;t be resumable, and sessions might have a
 865      * maximum lifetime in any case.
 866      */
 867     boolean isRejoinable() {
<span class="line-added"> 868         // TLS 1.3 can have no session id</span>
<span class="line-added"> 869         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added"> 870             return (!invalidated &amp;&amp; isLocalAuthenticationValid());</span>
<span class="line-added"> 871         }</span>
 872         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
<span class="line-modified"> 873                 !invalidated &amp;&amp; isLocalAuthenticationValid();</span>
 874     }
 875 
 876     @Override
<span class="line-modified"> 877     public boolean isValid() {</span>
<span class="line-modified"> 878         sessionLock.lock();</span>
<span class="line-added"> 879         try {</span>
<span class="line-added"> 880             return isRejoinable();</span>
<span class="line-added"> 881         } finally {</span>
<span class="line-added"> 882             sessionLock.unlock();</span>
<span class="line-added"> 883         }</span>
 884     }
 885 
 886     /**
 887      * Check if the authentication used when establishing this session
 888      * is still valid. Returns true if no authentication was used
 889      */
 890     private boolean isLocalAuthenticationValid() {
 891         if (localPrivateKey != null) {
 892             try {
 893                 // if the private key is no longer valid, getAlgorithm()
 894                 // should throw an exception
 895                 // (e.g. Smartcard has been removed from the reader)
 896                 localPrivateKey.getAlgorithm();
 897             } catch (Exception e) {
 898                 invalidate();
 899                 return false;
 900             }
 901         }
 902 
 903         return true;
</pre>
<hr />
<pre>
1246     /**
1247      * Need to provide the port info for caching sessions based on
1248      * host and port. Accessed by SSLSessionContextImpl
1249      */
1250     @Override
1251     public int getPeerPort() {
1252         return port;
1253     }
1254 
1255     void setContext(SSLSessionContextImpl ctx) {
1256         if (context == null) {
1257             context = ctx;
1258         }
1259     }
1260 
1261     /**
1262      * Invalidate a session.  Active connections may still exist, but
1263      * no connections will be able to rejoin this session.
1264      */
1265     @Override
<span class="line-modified">1266     public void invalidate() {</span>
<span class="line-modified">1267         sessionLock.lock();</span>
<span class="line-modified">1268         try {</span>
<span class="line-modified">1269             //</span>
<span class="line-modified">1270             // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="line-modified">1271             // attempted when we get a handshaking error on a brand</span>
<span class="line-modified">1272             // new connection, with no &quot;real&quot; session yet.</span>
<span class="line-modified">1273             //</span>
<span class="line-modified">1274             if (this == nullSession) {</span>
<span class="line-added">1275                 return;</span>
<span class="line-added">1276             }</span>
1277 
<span class="line-modified">1278             if (context != null) {</span>
<span class="line-modified">1279                 context.remove(sessionId);</span>
<span class="line-modified">1280                 context = null;</span>
<span class="line-modified">1281             }</span>
<span class="line-modified">1282 </span>
<span class="line-modified">1283             if (invalidated) {</span>
<span class="line-modified">1284                 return;</span>
<span class="line-modified">1285             }</span>
<span class="line-modified">1286             invalidated = true;</span>
<span class="line-modified">1287             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {</span>
<span class="line-modified">1288                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);</span>
<span class="line-modified">1289             }</span>
<span class="line-modified">1290             for (SSLSessionImpl child : childSessions) {</span>
<span class="line-added">1291                 child.invalidate();</span>
<span class="line-added">1292             }</span>
<span class="line-added">1293         } finally {</span>
<span class="line-added">1294             sessionLock.unlock();</span>
1295         }
1296     }
1297 
1298     /*
1299      * Table of application-specific session data indexed by an application
1300      * key and the calling security context. This is important since
1301      * sessions can be shared across different protection domains.
1302      */
1303     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
<span class="line-added">1304     boolean updateNST;</span>
1305 
1306     /**
1307      * Assigns a session value.  Session change events are given if
1308      * appropriate, to any original value as well as the new value.
1309      */
1310     @Override
1311     public void putValue(String key, Object value) {
1312         if ((key == null) || (value == null)) {
1313             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
1314         }
1315 
1316         SecureKey secureKey = new SecureKey(key);
1317         Object oldValue = boundValues.put(secureKey, value);
1318 
1319         if (oldValue instanceof SSLSessionBindingListener) {
1320             SSLSessionBindingEvent e;
1321 
1322             e = new SSLSessionBindingEvent(this, key);
1323             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
1324         }
1325         if (value instanceof SSLSessionBindingListener) {
1326             SSLSessionBindingEvent e;
1327 
1328             e = new SSLSessionBindingEvent(this, key);
1329             ((SSLSessionBindingListener)value).valueBound(e);
1330         }
<span class="line-added">1331         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added">1332             updateNST = true;</span>
<span class="line-added">1333         }</span>
1334     }
1335 
1336     /**
1337      * Returns the specified session value.
1338      */
1339     @Override
1340     public Object getValue(String key) {
1341         if (key == null) {
1342             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1343         }
1344 
1345         SecureKey secureKey = new SecureKey(key);
1346         return boundValues.get(secureKey);
1347     }
1348 
1349 
1350     /**
1351      * Removes the specified session value, delivering a session changed
1352      * event as appropriate.
1353      */
1354     @Override
1355     public void removeValue(String key) {
1356         if (key == null) {
1357             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1358         }
1359 
1360         SecureKey secureKey = new SecureKey(key);
1361         Object value = boundValues.remove(secureKey);
1362 
1363         if (value instanceof SSLSessionBindingListener) {
1364             SSLSessionBindingEvent e;
1365 
1366             e = new SSLSessionBindingEvent(this, key);
1367             ((SSLSessionBindingListener)value).valueUnbound(e);
1368         }
<span class="line-added">1369         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added">1370             updateNST = true;</span>
<span class="line-added">1371         }</span>
1372     }
1373 
1374 
1375     /**
1376      * Lists the names of the session values.
1377      */
1378     @Override
1379     public String[] getValueNames() {
1380         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
1381         Object securityCtx = SecureKey.getCurrentSecurityContext();
1382         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
1383                 e.hasMoreElements(); ) {
1384             SecureKey key = e.nextElement();
1385             if (securityCtx.equals(key.getSecurityContext())) {
1386                 v.add(key.getAppKey());
1387             }
1388         }
1389 
1390         return v.toArray(new String[0]);
1391     }
</pre>
<hr />
<pre>
1394      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
1395      * until changed.
1396      *
1397      * In the TLS specification (section 6.2.1, RFC2246), it is not
1398      * recommended that the plaintext has more than 2^14 bytes.
1399      * However, some TLS implementations violate the specification.
1400      * This is a workaround for interoperability with these stacks.
1401      *
1402      * Application could accept large fragments up to 2^15 bytes by
1403      * setting the system property jsse.SSLEngine.acceptLargeFragments
1404      * to &quot;true&quot;.
1405      */
1406     private boolean acceptLargeFragments =
1407             Utilities.getBooleanProperty(
1408                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
1409 
1410     /**
1411      * Expand the buffer size of both SSL/TLS network packet and
1412      * application data.
1413      */
<span class="line-modified">1414     protected void expandBufferSizes() {</span>
<span class="line-modified">1415         sessionLock.lock();</span>
<span class="line-added">1416         try {</span>
<span class="line-added">1417             acceptLargeFragments = true;</span>
<span class="line-added">1418         } finally {</span>
<span class="line-added">1419             sessionLock.unlock();</span>
<span class="line-added">1420         }</span>
1421     }
1422 
1423     /**
1424      * Gets the current size of the largest SSL/TLS packet that is expected
1425      * when using this session.
1426      */
1427     @Override
<span class="line-modified">1428     public int getPacketBufferSize() {</span>
<span class="line-modified">1429         sessionLock.lock();</span>
<span class="line-modified">1430         try {</span>
<span class="line-modified">1431             // Use the bigger packet size calculated from maximumPacketSize</span>
<span class="line-modified">1432             // and negotiatedMaxFragLen.</span>
<span class="line-modified">1433             int packetSize = 0;</span>
<span class="line-modified">1434             if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified">1435                 packetSize = cipherSuite.calculatePacketSize(</span>
<span class="line-modified">1436                         negotiatedMaxFragLen, protocolVersion,</span>
<span class="line-added">1437                         protocolVersion.isDTLS);</span>
<span class="line-added">1438             }</span>
1439 
<span class="line-modified">1440             if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified">1441                 return (maximumPacketSize &gt; packetSize) ?</span>
<span class="line-modified">1442                         maximumPacketSize : packetSize;</span>
<span class="line-modified">1443             }</span>
1444 
<span class="line-modified">1445             if (packetSize != 0) {</span>
<span class="line-modified">1446                return packetSize;</span>
<span class="line-modified">1447             }</span>
1448 
<span class="line-modified">1449             if (protocolVersion.isDTLS) {</span>
<span class="line-modified">1450                 return DTLSRecord.maxRecordSize;</span>
<span class="line-modified">1451             } else {</span>
<span class="line-modified">1452                 return acceptLargeFragments ?</span>
<span class="line-modified">1453                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="line-added">1454             }</span>
<span class="line-added">1455         } finally {</span>
<span class="line-added">1456             sessionLock.unlock();</span>
1457         }
1458     }
1459 
1460     /**
1461      * Gets the current size of the largest application data that is
1462      * expected when using this session.
1463      */
1464     @Override
<span class="line-modified">1465     public int getApplicationBufferSize() {</span>
<span class="line-modified">1466         sessionLock.lock();</span>
<span class="line-modified">1467         try {</span>
<span class="line-modified">1468             // Use the bigger fragment size calculated from maximumPacketSize</span>
<span class="line-modified">1469             // and negotiatedMaxFragLen.</span>
<span class="line-modified">1470             int fragmentSize = 0;</span>
<span class="line-modified">1471             if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified">1472                 fragmentSize = cipherSuite.calculateFragSize(</span>
<span class="line-modified">1473                         maximumPacketSize, protocolVersion,</span>
<span class="line-added">1474                         protocolVersion.isDTLS);</span>
<span class="line-added">1475             }</span>
1476 
<span class="line-modified">1477             if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified">1478                 return (negotiatedMaxFragLen &gt; fragmentSize) ?</span>
<span class="line-modified">1479                         negotiatedMaxFragLen : fragmentSize;</span>
<span class="line-modified">1480             }</span>
1481 
<span class="line-modified">1482             if (fragmentSize != 0) {</span>
<span class="line-modified">1483                 return fragmentSize;</span>
<span class="line-modified">1484             }</span>
1485 
<span class="line-modified">1486             if (protocolVersion.isDTLS) {</span>
<span class="line-modified">1487                 return Record.maxDataSize;</span>
<span class="line-modified">1488             } else {</span>
<span class="line-modified">1489                 int maxPacketSize = acceptLargeFragments ?</span>
<span class="line-modified">1490                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="line-modified">1491                 return (maxPacketSize - SSLRecord.headerSize);</span>
<span class="line-added">1492             }</span>
<span class="line-added">1493         } finally {</span>
<span class="line-added">1494             sessionLock.unlock();</span>
1495         }
1496     }
1497 
1498     /**
1499      * Sets the negotiated maximum fragment length, as specified by the
1500      * max_fragment_length ClientHello extension in RFC 6066.
1501      *
1502      * @param  negotiatedMaxFragLen
1503      *         the negotiated maximum fragment length, or {@code -1} if
1504      *         no such length has been negotiated.
1505      */
<span class="line-modified">1506     void setNegotiatedMaxFragSize(</span>
1507             int negotiatedMaxFragLen) {
<span class="line-modified">1508         sessionLock.lock();</span>
<span class="line-modified">1509         try {</span>
<span class="line-added">1510             this.negotiatedMaxFragLen = negotiatedMaxFragLen;</span>
<span class="line-added">1511         } finally {</span>
<span class="line-added">1512             sessionLock.unlock();</span>
<span class="line-added">1513         }</span>
1514     }
1515 
1516     /**
1517      * Get the negotiated maximum fragment length, as specified by the
1518      * max_fragment_length ClientHello extension in RFC 6066.
1519      *
1520      * @return the negotiated maximum fragment length, or {@code -1} if
1521      *         no such length has been negotiated.
1522      */
<span class="line-modified">1523     int getNegotiatedMaxFragSize() {</span>
<span class="line-modified">1524         sessionLock.lock();</span>
<span class="line-added">1525         try {</span>
<span class="line-added">1526             return negotiatedMaxFragLen;</span>
<span class="line-added">1527         } finally {</span>
<span class="line-added">1528             sessionLock.unlock();</span>
<span class="line-added">1529         }</span>
1530     }
1531 
<span class="line-modified">1532     void setMaximumPacketSize(int maximumPacketSize) {</span>
<span class="line-modified">1533         sessionLock.lock();</span>
<span class="line-added">1534         try {</span>
<span class="line-added">1535             this.maximumPacketSize = maximumPacketSize;</span>
<span class="line-added">1536         } finally {</span>
<span class="line-added">1537             sessionLock.unlock();</span>
<span class="line-added">1538         }</span>
1539     }
1540 
<span class="line-modified">1541     int getMaximumPacketSize() {</span>
<span class="line-modified">1542         sessionLock.lock();</span>
<span class="line-added">1543         try {</span>
<span class="line-added">1544             return maximumPacketSize;</span>
<span class="line-added">1545         } finally {</span>
<span class="line-added">1546             sessionLock.unlock();</span>
<span class="line-added">1547         }</span>
1548     }
1549 
1550     /**
1551      * Gets an array of supported signature algorithm names that the local
1552      * side is willing to verify.
1553      */
1554     @Override
1555     public String[] getLocalSupportedSignatureAlgorithms() {
1556         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1557     }
1558 
1559     /**
1560      * Gets an array of supported signature schemes that the local side is
1561      * willing to verify.
1562      */
1563     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1564         return localSupportedSignAlgs;
1565     }
1566 
1567     /**
1568      * Gets an array of supported signature algorithms that the peer is
1569      * able to verify.
1570      */
1571     @Override
1572     public String[] getPeerSupportedSignatureAlgorithms() {
<span class="line-modified">1573         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);</span>




1574     }
1575 
1576     /**
1577      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1578      * of the requested Server Name Indication (SNI) extension.
1579      */
1580     @Override
1581     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1582         return requestedServerNames;
1583     }
1584 
1585     /** Returns a string representation of this SSL session */
1586     @Override
1587     public String toString() {
1588         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1589     }
1590 }
1591 
1592 /**
1593  * This &quot;struct&quot; class serves as a Hash Key that combines an
</pre>
</td>
</tr>
</table>
<center><a href="SSLSessionContextImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
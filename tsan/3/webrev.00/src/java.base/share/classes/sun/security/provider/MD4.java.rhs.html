<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/provider/MD4.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.security.*;
 29 import java.util.Arrays;
 30 
 31 import static sun.security.provider.ByteArrayAccess.*;
 32 import static sun.security.util.SecurityConstants.PROVIDER_VER;
 33 
 34 /**
 35  * The MD4 class is used to compute an MD4 message digest over a given
 36  * buffer of bytes. It is an implementation of the RSA Data Security Inc
 37  * MD4 algorithim as described in internet RFC 1320.
 38  *
 39  * &lt;p&gt;The MD4 algorithm is very weak and should not be used unless it is
 40  * unavoidable. Therefore, it is not registered in our standard providers. To
 41  * obtain an implementation, call the static getInstance() method in this
 42  * class.
 43  *
 44  * @author      Andreas Sterbenz
 45  */
 46 public final class MD4 extends DigestBase {
 47 
 48     // state of this object
 49     private int[] state;
 50     // temporary buffer, used by implCompress()
 51     private int[] x;
 52 
 53     // rotation constants
 54     private static final int S11 = 3;
 55     private static final int S12 = 7;
 56     private static final int S13 = 11;
 57     private static final int S14 = 19;
 58     private static final int S21 = 3;
 59     private static final int S22 = 5;
 60     private static final int S23 = 9;
 61     private static final int S24 = 13;
 62     private static final int S31 = 3;
 63     private static final int S32 = 9;
 64     private static final int S33 = 11;
 65     private static final int S34 = 15;
 66 
 67     private static final Provider md4Provider;
 68 
 69     static {
 70         md4Provider = new Provider(&quot;MD4Provider&quot;, PROVIDER_VER,
 71             &quot;MD4 MessageDigest&quot;) {
<a name="2" id="anc2"></a><span class="line-added"> 72             @java.io.Serial</span>
 73             private static final long serialVersionUID = -8850464997518327965L;
 74         };
 75         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 76             public Void run() {
 77                 md4Provider.put(&quot;MessageDigest.MD4&quot;, &quot;sun.security.provider.MD4&quot;);
 78                 return null;
 79             }
 80         });
 81     }
 82 
 83     public static MessageDigest getInstance() {
 84         try {
 85             return MessageDigest.getInstance(&quot;MD4&quot;, md4Provider);
 86         } catch (NoSuchAlgorithmException e) {
 87             // should never occur
 88             throw new ProviderException(e);
 89         }
 90     }
 91 
 92     // Standard constructor, creates a new MD4 instance.
 93     public MD4() {
 94         super(&quot;MD4&quot;, 16, 64);
 95         state = new int[4];
 96         x = new int[16];
 97         resetHashes();
 98     }
 99 
100     // clone this object
101     public Object clone() throws CloneNotSupportedException {
102         MD4 copy = (MD4) super.clone();
103         copy.state = copy.state.clone();
104         copy.x = new int[16];
105         return copy;
106     }
107 
108     /**
109      * Reset the state of this object.
110      */
111     void implReset() {
112         // Load magic initialization constants.
113         resetHashes();
114         // clear out old data
115         Arrays.fill(x, 0);
116     }
117 
118     private void resetHashes() {
119         state[0] = 0x67452301;
120         state[1] = 0xefcdab89;
121         state[2] = 0x98badcfe;
122         state[3] = 0x10325476;
123     }
124 
125     /**
126      * Perform the final computations, any buffered bytes are added
127      * to the digest, the count is added to the digest, and the resulting
128      * digest is stored.
129      */
130     void implDigest(byte[] out, int ofs) {
131         long bitsProcessed = bytesProcessed &lt;&lt; 3;
132 
133         int index = (int)bytesProcessed &amp; 0x3f;
134         int padLen = (index &lt; 56) ? (56 - index) : (120 - index);
135         engineUpdate(padding, 0, padLen);
136 
137         i2bLittle4((int)bitsProcessed, buffer, 56);
138         i2bLittle4((int)(bitsProcessed &gt;&gt;&gt; 32), buffer, 60);
139         implCompress(buffer, 0);
140 
141         i2bLittle(state, 0, out, ofs, 16);
142     }
143 
144     private static int FF(int a, int b, int c, int d, int x, int s) {
145         a += ((b &amp; c) | ((~b) &amp; d)) + x;
146         return ((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)));
147     }
148 
149     private static int GG(int a, int b, int c, int d, int x, int s) {
150         a += ((b &amp; c) | (b &amp; d) | (c &amp; d)) + x + 0x5a827999;
151         return ((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)));
152     }
153 
154     private static int HH(int a, int b, int c, int d, int x, int s) {
155         a += ((b ^ c) ^ d) + x + 0x6ed9eba1;
156         return ((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)));
157     }
158 
159     /**
160      * This is where the functions come together as the generic MD4
161      * transformation operation. It consumes sixteen
162      * bytes from the buffer, beginning at the specified offset.
163      */
164     void implCompress(byte[] buf, int ofs) {
165         b2iLittle64(buf, ofs, x);
166 
167         int a = state[0];
168         int b = state[1];
169         int c = state[2];
170         int d = state[3];
171 
172         /* Round 1 */
173         a = FF (a, b, c, d, x[ 0], S11); /* 1 */
174         d = FF (d, a, b, c, x[ 1], S12); /* 2 */
175         c = FF (c, d, a, b, x[ 2], S13); /* 3 */
176         b = FF (b, c, d, a, x[ 3], S14); /* 4 */
177         a = FF (a, b, c, d, x[ 4], S11); /* 5 */
178         d = FF (d, a, b, c, x[ 5], S12); /* 6 */
179         c = FF (c, d, a, b, x[ 6], S13); /* 7 */
180         b = FF (b, c, d, a, x[ 7], S14); /* 8 */
181         a = FF (a, b, c, d, x[ 8], S11); /* 9 */
182         d = FF (d, a, b, c, x[ 9], S12); /* 10 */
183         c = FF (c, d, a, b, x[10], S13); /* 11 */
184         b = FF (b, c, d, a, x[11], S14); /* 12 */
185         a = FF (a, b, c, d, x[12], S11); /* 13 */
186         d = FF (d, a, b, c, x[13], S12); /* 14 */
187         c = FF (c, d, a, b, x[14], S13); /* 15 */
188         b = FF (b, c, d, a, x[15], S14); /* 16 */
189 
190         /* Round 2 */
191         a = GG (a, b, c, d, x[ 0], S21); /* 17 */
192         d = GG (d, a, b, c, x[ 4], S22); /* 18 */
193         c = GG (c, d, a, b, x[ 8], S23); /* 19 */
194         b = GG (b, c, d, a, x[12], S24); /* 20 */
195         a = GG (a, b, c, d, x[ 1], S21); /* 21 */
196         d = GG (d, a, b, c, x[ 5], S22); /* 22 */
197         c = GG (c, d, a, b, x[ 9], S23); /* 23 */
198         b = GG (b, c, d, a, x[13], S24); /* 24 */
199         a = GG (a, b, c, d, x[ 2], S21); /* 25 */
200         d = GG (d, a, b, c, x[ 6], S22); /* 26 */
201         c = GG (c, d, a, b, x[10], S23); /* 27 */
202         b = GG (b, c, d, a, x[14], S24); /* 28 */
203         a = GG (a, b, c, d, x[ 3], S21); /* 29 */
204         d = GG (d, a, b, c, x[ 7], S22); /* 30 */
205         c = GG (c, d, a, b, x[11], S23); /* 31 */
206         b = GG (b, c, d, a, x[15], S24); /* 32 */
207 
208         /* Round 3 */
209         a = HH (a, b, c, d, x[ 0], S31); /* 33 */
210         d = HH (d, a, b, c, x[ 8], S32); /* 34 */
211         c = HH (c, d, a, b, x[ 4], S33); /* 35 */
212         b = HH (b, c, d, a, x[12], S34); /* 36 */
213         a = HH (a, b, c, d, x[ 2], S31); /* 37 */
214         d = HH (d, a, b, c, x[10], S32); /* 38 */
215         c = HH (c, d, a, b, x[ 6], S33); /* 39 */
216         b = HH (b, c, d, a, x[14], S34); /* 40 */
217         a = HH (a, b, c, d, x[ 1], S31); /* 41 */
218         d = HH (d, a, b, c, x[ 9], S32); /* 42 */
219         c = HH (c, d, a, b, x[ 5], S33); /* 43 */
220         b = HH (b, c, d, a, x[13], S34); /* 44 */
221         a = HH (a, b, c, d, x[ 3], S31); /* 45 */
222         d = HH (d, a, b, c, x[11], S32); /* 46 */
223         c = HH (c, d, a, b, x[ 7], S33); /* 47 */
224         b = HH (b, c, d, a, x[15], S34); /* 48 */
225 
226         state[0] += a;
227         state[1] += b;
228         state[2] += c;
229         state[3] += d;
230     }
231 
232 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/DHServerKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DHKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DTLSInputRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/DHServerKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.nio.ByteBuffer;
 31 import java.security.CryptoPrimitive;
 32 import java.security.GeneralSecurityException;
 33 import java.security.InvalidAlgorithmParameterException;
 34 import java.security.InvalidKeyException;
 35 import java.security.Key;
 36 import java.security.KeyFactory;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.PrivateKey;
 39 import java.security.PublicKey;
 40 import java.security.Signature;
 41 import java.security.SignatureException;
 42 import java.text.MessageFormat;
 43 import java.util.EnumSet;
 44 import java.util.Locale;

 45 import javax.crypto.interfaces.DHPublicKey;
 46 import javax.crypto.spec.DHParameterSpec;
 47 import javax.crypto.spec.DHPublicKeySpec;
 48 import sun.security.ssl.DHKeyExchange.DHECredentials;
 49 import sun.security.ssl.DHKeyExchange.DHEPossession;
 50 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-removed"> 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
 52 import sun.security.ssl.X509Authentication.X509Credentials;
 53 import sun.security.ssl.X509Authentication.X509Possession;
 54 import sun.security.util.HexDumpEncoder;
 55 import sun.security.util.KeyUtil;
 56 
 57 /**
 58  * Pack of the ServerKeyExchange handshake message.
 59  */
 60 final class DHServerKeyExchange {
 61     static final SSLConsumer dhHandshakeConsumer =
 62             new DHServerKeyExchangeConsumer();
 63     static final HandshakeProducer dhHandshakeProducer =
 64             new DHServerKeyExchangeProducer();
 65 
 66     /**
 67      * The DiffieHellman ServerKeyExchange handshake message.
 68      */
 69     private static final
 70             class DHServerKeyExchangeMessage extends HandshakeMessage {
 71         // public key encapsulated in this message
</pre>
<hr />
<pre>
108                 // unlikely
109                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
110                     &quot;No DHE credentials negotiated for server key exchange&quot;);
111             }
112             DHPublicKey publicKey = dhePossession.publicKey;
113             DHParameterSpec params = publicKey.getParams();
114             this.p = Utilities.toByteArray(params.getP());
115             this.g = Utilities.toByteArray(params.getG());
116             this.y = Utilities.toByteArray(publicKey.getY());
117 
118             if (x509Possession == null) {
119                 // anonymous, no authentication, no signature
120                 paramsSignature = null;
121                 signatureScheme = null;
122                 useExplicitSigAlgorithm = false;
123             } else {
124                 useExplicitSigAlgorithm =
125                         shc.negotiatedProtocol.useTLS12PlusSpec();
126                 Signature signer = null;
127                 if (useExplicitSigAlgorithm) {
<span class="line-modified">128                     signatureScheme = SignatureScheme.getPreferableAlgorithm(</span>
<span class="line-modified">129                             shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">130                             x509Possession.popPrivateKey,</span>
<span class="line-modified">131                             shc.negotiatedProtocol);</span>
<span class="line-modified">132                     if (signatureScheme == null) {</span>


133                         // Unlikely, the credentials generator should have
134                         // selected the preferable signature algorithm properly.
135                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified">136                             &quot;No preferred signature algorithm&quot;);</span>
<span class="line-modified">137                     }</span>
<span class="line-modified">138                     try {</span>
<span class="line-modified">139                         signer = signatureScheme.getSignature(</span>
<span class="line-modified">140                                 x509Possession.popPrivateKey);</span>
<span class="line-modified">141                     } catch (NoSuchAlgorithmException | InvalidKeyException |</span>
<span class="line-removed">142                             InvalidAlgorithmParameterException nsae) {</span>
<span class="line-removed">143                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-removed">144                             &quot;Unsupported signature algorithm: &quot; +</span>
<span class="line-removed">145                             signatureScheme.name, nsae);</span>
146                     }
147                 } else {
148                     signatureScheme = null;
149                     try {
150                         signer = getSignature(
151                                 x509Possession.popPrivateKey.getAlgorithm(),
152                                 x509Possession.popPrivateKey);
153                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
154                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
155                             &quot;Unsupported signature algorithm: &quot; +
156                             x509Possession.popPrivateKey.getAlgorithm(), e);
157                     }
158                 }
159 
160                 byte[] signature = null;
161                 try {
162                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
163                             shc.serverHelloRandom.randomBytes);
164                     signature = signer.sign();
165                 } catch (SignatureException ex) {
</pre>
<hr />
<pre>
224                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
225                             &quot;Invalid signature algorithm (&quot; + ssid +
226                             &quot;) used in DH ServerKeyExchange handshake message&quot;);
227                 }
228 
229                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
230                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
231                             &quot;Unsupported signature algorithm (&quot; +
232                             signatureScheme.name +
233                             &quot;) used in DH ServerKeyExchange handshake message&quot;);
234                 }
235             } else {
236                 this.signatureScheme = null;
237             }
238 
239             // read and verify the signature
240             this.paramsSignature = Record.getBytes16(m);
241             Signature signer;
242             if (useExplicitSigAlgorithm) {
243                 try {
<span class="line-modified">244                     signer = signatureScheme.getSignature(</span>
245                             x509Credentials.popPublicKey);
246                 } catch (NoSuchAlgorithmException | InvalidKeyException |
247                         InvalidAlgorithmParameterException nsae) {
248                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
249                             &quot;Unsupported signature algorithm: &quot; +
250                             signatureScheme.name, nsae);
251                 }
252             } else {
253                 try {
254                     signer = getSignature(
255                             x509Credentials.popPublicKey.getAlgorithm(),
256                             x509Credentials.popPublicKey);
257                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
258                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
259                             &quot;Unsupported signature algorithm: &quot; +
260                             x509Credentials.popPublicKey.getAlgorithm(), e);
261                 }
262             }
263 
264             try {
</pre>
</td>
<td>
<hr />
<pre>
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.nio.ByteBuffer;
 31 import java.security.CryptoPrimitive;
 32 import java.security.GeneralSecurityException;
 33 import java.security.InvalidAlgorithmParameterException;
 34 import java.security.InvalidKeyException;
 35 import java.security.Key;
 36 import java.security.KeyFactory;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.PrivateKey;
 39 import java.security.PublicKey;
 40 import java.security.Signature;
 41 import java.security.SignatureException;
 42 import java.text.MessageFormat;
 43 import java.util.EnumSet;
 44 import java.util.Locale;
<span class="line-added"> 45 import java.util.Map;</span>
 46 import javax.crypto.interfaces.DHPublicKey;
 47 import javax.crypto.spec.DHParameterSpec;
 48 import javax.crypto.spec.DHPublicKeySpec;
 49 import sun.security.ssl.DHKeyExchange.DHECredentials;
 50 import sun.security.ssl.DHKeyExchange.DHEPossession;
 51 import sun.security.ssl.SSLHandshake.HandshakeMessage;

 52 import sun.security.ssl.X509Authentication.X509Credentials;
 53 import sun.security.ssl.X509Authentication.X509Possession;
 54 import sun.security.util.HexDumpEncoder;
 55 import sun.security.util.KeyUtil;
 56 
 57 /**
 58  * Pack of the ServerKeyExchange handshake message.
 59  */
 60 final class DHServerKeyExchange {
 61     static final SSLConsumer dhHandshakeConsumer =
 62             new DHServerKeyExchangeConsumer();
 63     static final HandshakeProducer dhHandshakeProducer =
 64             new DHServerKeyExchangeProducer();
 65 
 66     /**
 67      * The DiffieHellman ServerKeyExchange handshake message.
 68      */
 69     private static final
 70             class DHServerKeyExchangeMessage extends HandshakeMessage {
 71         // public key encapsulated in this message
</pre>
<hr />
<pre>
108                 // unlikely
109                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
110                     &quot;No DHE credentials negotiated for server key exchange&quot;);
111             }
112             DHPublicKey publicKey = dhePossession.publicKey;
113             DHParameterSpec params = publicKey.getParams();
114             this.p = Utilities.toByteArray(params.getP());
115             this.g = Utilities.toByteArray(params.getG());
116             this.y = Utilities.toByteArray(publicKey.getY());
117 
118             if (x509Possession == null) {
119                 // anonymous, no authentication, no signature
120                 paramsSignature = null;
121                 signatureScheme = null;
122                 useExplicitSigAlgorithm = false;
123             } else {
124                 useExplicitSigAlgorithm =
125                         shc.negotiatedProtocol.useTLS12PlusSpec();
126                 Signature signer = null;
127                 if (useExplicitSigAlgorithm) {
<span class="line-modified">128                     Map.Entry&lt;SignatureScheme, Signature&gt; schemeAndSigner =</span>
<span class="line-modified">129                             SignatureScheme.getSignerOfPreferableAlgorithm(</span>
<span class="line-modified">130                                     shc.algorithmConstraints,</span>
<span class="line-modified">131                                     shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">132                                     x509Possession,</span>
<span class="line-added">133                                     shc.negotiatedProtocol);</span>
<span class="line-added">134                     if (schemeAndSigner == null) {</span>
135                         // Unlikely, the credentials generator should have
136                         // selected the preferable signature algorithm properly.
137                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified">138                                 &quot;No supported signature algorithm for &quot; +</span>
<span class="line-modified">139                                 x509Possession.popPrivateKey.getAlgorithm() +</span>
<span class="line-modified">140                                 &quot;  key&quot;);</span>
<span class="line-modified">141                     } else {</span>
<span class="line-modified">142                         signatureScheme = schemeAndSigner.getKey();</span>
<span class="line-modified">143                         signer = schemeAndSigner.getValue();</span>




144                     }
145                 } else {
146                     signatureScheme = null;
147                     try {
148                         signer = getSignature(
149                                 x509Possession.popPrivateKey.getAlgorithm(),
150                                 x509Possession.popPrivateKey);
151                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
152                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
153                             &quot;Unsupported signature algorithm: &quot; +
154                             x509Possession.popPrivateKey.getAlgorithm(), e);
155                     }
156                 }
157 
158                 byte[] signature = null;
159                 try {
160                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
161                             shc.serverHelloRandom.randomBytes);
162                     signature = signer.sign();
163                 } catch (SignatureException ex) {
</pre>
<hr />
<pre>
222                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
223                             &quot;Invalid signature algorithm (&quot; + ssid +
224                             &quot;) used in DH ServerKeyExchange handshake message&quot;);
225                 }
226 
227                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
228                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
229                             &quot;Unsupported signature algorithm (&quot; +
230                             signatureScheme.name +
231                             &quot;) used in DH ServerKeyExchange handshake message&quot;);
232                 }
233             } else {
234                 this.signatureScheme = null;
235             }
236 
237             // read and verify the signature
238             this.paramsSignature = Record.getBytes16(m);
239             Signature signer;
240             if (useExplicitSigAlgorithm) {
241                 try {
<span class="line-modified">242                     signer = signatureScheme.getVerifier(</span>
243                             x509Credentials.popPublicKey);
244                 } catch (NoSuchAlgorithmException | InvalidKeyException |
245                         InvalidAlgorithmParameterException nsae) {
246                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
247                             &quot;Unsupported signature algorithm: &quot; +
248                             signatureScheme.name, nsae);
249                 }
250             } else {
251                 try {
252                     signer = getSignature(
253                             x509Credentials.popPublicKey.getAlgorithm(),
254                             x509Credentials.popPublicKey);
255                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
256                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
257                             &quot;Unsupported signature algorithm: &quot; +
258                             x509Credentials.popPublicKey.getAlgorithm(), e);
259                 }
260             }
261 
262             try {
</pre>
</td>
</tr>
</table>
<center><a href="DHKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DTLSInputRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
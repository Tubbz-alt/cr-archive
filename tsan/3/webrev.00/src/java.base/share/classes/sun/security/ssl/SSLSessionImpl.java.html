<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
  27 import sun.security.x509.X509CertImpl;
  28 
  29 import java.io.IOException;
  30 import java.lang.reflect.Array;
  31 import java.math.BigInteger;
  32 import java.net.InetAddress;
  33 import java.nio.ByteBuffer;
  34 import java.security.Principal;
  35 import java.security.PrivateKey;
  36 import java.security.cert.CertificateEncodingException;
  37 import java.security.cert.X509Certificate;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Queue;
  41 import java.util.Collection;
  42 import java.util.Collections;
  43 import java.util.Enumeration;
  44 import java.util.List;
  45 import java.util.concurrent.ConcurrentHashMap;
  46 import java.util.concurrent.ConcurrentLinkedQueue;
  47 import java.util.concurrent.locks.ReentrantLock;
  48 import javax.crypto.SecretKey;
  49 import javax.crypto.spec.SecretKeySpec;
  50 import javax.net.ssl.ExtendedSSLSession;
  51 import javax.net.ssl.SNIHostName;
  52 import javax.net.ssl.SNIServerName;
  53 import javax.net.ssl.SSLException;
  54 import javax.net.ssl.SSLPeerUnverifiedException;
  55 import javax.net.ssl.SSLPermission;
  56 import javax.net.ssl.SSLSessionBindingEvent;
  57 import javax.net.ssl.SSLSessionBindingListener;
  58 import javax.net.ssl.SSLSessionContext;
  59 
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
  74  * is associated with any given authentication context. &lt;/em&gt;
  75  *
  76  * @author David Brownell
  77  */
  78 final class SSLSessionImpl extends ExtendedSSLSession {
  79 
  80     /*
  81      * we only really need a single null session
  82      */
  83     static final SSLSessionImpl         nullSession = new SSLSessionImpl();
  84 
  85     /*
  86      * The state of a single session, as described in section 7.1
  87      * of the SSLv3 spec.
  88      */
  89     private final ProtocolVersion       protocolVersion;
  90     private final SessionId             sessionId;
  91     private X509Certificate[]   peerCerts;
  92     private CipherSuite         cipherSuite;
  93     private SecretKey           masterSecret;
  94     final boolean               useExtendedMasterSecret;
  95 
  96     /*
  97      * Information not part of the SSLv3 protocol spec, but used
  98      * to support session management policies.
  99      */
 100     private final long          creationTime;
 101     private long                lastUsedTime = 0;
 102     private final String        host;
 103     private final int           port;
 104     private SSLSessionContextImpl       context;
 105     private boolean             invalidated;
 106     private X509Certificate[]   localCerts;
 107     private PrivateKey          localPrivateKey;
 108     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
 109     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate
 110     private boolean             useDefaultPeerSignAlgs = false;
 111     private List&lt;byte[]&gt;        statusResponses;
 112     private SecretKey           resumptionMasterSecret;
 113     private SecretKey           preSharedKey;
 114     private byte[]              pskIdentity;
 115     private final long          ticketCreationTime = System.currentTimeMillis();
 116     private int                 ticketAgeAdd;
 117 
 118     private int                 negotiatedMaxFragLen = -1;
 119     private int                 maximumPacketSize;
 120 
 121     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 122                                         new ConcurrentLinkedQueue&lt;&gt;();
 123 
 124     /*
 125      * Is the session currently re-established with a session-resumption
 126      * abbreviated initial handshake?
 127      *
 128      * Note that currently we only set this variable in client side.
 129      */
 130     private boolean isSessionResumption = false;
 131 
 132     /*
 133      * Use of session caches is globally enabled/disabled.
 134      */
 135     private static boolean      defaultRejoinable = true;
 136 
 137     // server name indication
 138     final SNIServerName         serverNameIndication;
 139     private final List&lt;SNIServerName&gt;    requestedServerNames;
 140 
 141     // Counter used to create unique nonces in NewSessionTicket
 142     private BigInteger ticketNonceCounter = BigInteger.ONE;
 143 
 144     // The endpoint identification algorithm used to check certificates
 145     // in this session.
 146     private final String        identificationProtocol;
 147 
 148     private final ReentrantLock sessionLock = new ReentrantLock();
 149 
 150     /*
 151      * Create a new non-rejoinable session, using the default (null)
 152      * cipher spec.  This constructor returns a session which could
 153      * be used either by a client or by a server, as a connection is
 154      * first opened and before handshaking begins.
 155      */
 156     private SSLSessionImpl() {
 157         this.protocolVersion = ProtocolVersion.NONE;
 158         this.cipherSuite = CipherSuite.C_NULL;
 159         this.sessionId = new SessionId(false, null);
 160         this.host = null;
 161         this.port = -1;
 162         this.localSupportedSignAlgs = Collections.emptySet();
 163         this.serverNameIndication = null;
 164         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 165         this.useExtendedMasterSecret = false;
 166         this.creationTime = System.currentTimeMillis();
 167         this.identificationProtocol = null;
 168         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 169     }
 170 
 171     /*
 172      * Create a new session, using a given cipher spec.  This will
 173      * be rejoinable if session caching is enabled; the constructor
 174      * is intended mostly for use by serves.
 175      */
 176     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
 177         this(hc, cipherSuite,
 178             new SessionId(defaultRejoinable, hc.sslContext.getSecureRandom()));
 179     }
 180 
 181     /*
 182      * Record a new session, using a given cipher spec and session ID.
 183      */
 184     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite, SessionId id) {
 185         this(hc, cipherSuite, id, System.currentTimeMillis());
 186     }
 187 
 188     /*
 189      * Record a new session, using a given cipher spec, session ID,
 190      * and creation time.
 191      * Note: For the unmodifiable collections and lists we are creating new
 192      * collections as inputs to avoid potential deep nesting of
 193      * unmodifiable collections that can cause StackOverflowErrors
 194      * (see JDK-6323374).
 195      */
 196     SSLSessionImpl(HandshakeContext hc,
 197             CipherSuite cipherSuite, SessionId id, long creationTime) {
 198         this.protocolVersion = hc.negotiatedProtocol;
 199         this.cipherSuite = cipherSuite;
 200         this.sessionId = id;
 201         this.host = hc.conContext.transport.getPeerHost();
 202         this.port = hc.conContext.transport.getPeerPort();
 203         this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?
 204                 Collections.emptySet() :
 205                 Collections.unmodifiableCollection(
 206                         new ArrayList&lt;&gt;(hc.localSupportedSignAlgs));
 207         this.serverNameIndication = hc.negotiatedServerName;
 208         this.requestedServerNames = Collections.unmodifiableList(
 209                 new ArrayList&lt;&gt;(hc.getRequestedServerNames()));
 210         if (hc.sslConfig.isClientMode) {
 211             this.useExtendedMasterSecret =
 212                 (hc.handshakeExtensions.get(
 213                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 214                 (hc.handshakeExtensions.get(
 215                         SSLExtension.SH_EXTENDED_MASTER_SECRET) != null);
 216         } else {
 217             this.useExtendedMasterSecret =
 218                 (hc.handshakeExtensions.get(
 219                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 220                 (!hc.negotiatedProtocol.useTLS13PlusSpec());
 221         }
 222         this.creationTime = creationTime;
 223         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 224         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 225 
 226         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 227              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 228         }
 229     }
 230 
 231     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 232         this.protocolVersion = baseSession.getProtocolVersion();
 233         this.cipherSuite = baseSession.cipherSuite;
 234         this.sessionId = newId;
 235         this.host = baseSession.getPeerHost();
 236         this.port = baseSession.getPeerPort();
 237         this.localSupportedSignAlgs =
 238                 baseSession.localSupportedSignAlgs == null ?
 239                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 240         this.peerSupportedSignAlgs =
 241                 baseSession.peerSupportedSignAlgs == null ?
 242                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;
 243         this.serverNameIndication = baseSession.serverNameIndication;
 244         this.requestedServerNames = baseSession.getRequestedServerNames();
 245         this.masterSecret = baseSession.getMasterSecret();
 246         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 247         this.creationTime = baseSession.getCreationTime();
 248         this.lastUsedTime = System.currentTimeMillis();
 249         this.identificationProtocol = baseSession.getIdentificationProtocol();
 250         this.localCerts = baseSession.localCerts;
 251         this.peerCerts = baseSession.peerCerts;
 252         this.statusResponses = baseSession.statusResponses;
 253         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 254         this.context = baseSession.context;
 255         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 256         this.maximumPacketSize = baseSession.maximumPacketSize;
 257         this.boundValues = baseSession.boundValues;
 258 
 259         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 260              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 261         }
 262     }
 263 
 264     /**
 265      * &lt; 2 bytes &gt; protocolVersion
 266      * &lt; 2 bytes &gt; cipherSuite
 267      * &lt; 1 byte &gt; localSupportedSignAlgs entries
 268      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs
 269      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries
 270      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs
 271      * &lt; 2 bytes &gt; preSharedKey length
 272      * &lt; length in bytes &gt; preSharedKey
 273      * &lt; 1 byte &gt; pskIdentity length
 274      * &lt; length in bytes &gt; pskIdentity
 275      * &lt; 1 byte &gt; masterSecret length
 276      *   &lt; 1 byte &gt; masterSecret algorithm length
 277      *   &lt; length in bytes &gt; masterSecret algorithm
 278      *   &lt; 2 bytes &gt; masterSecretKey length
 279      *   &lt; length in bytes&gt; masterSecretKey
 280      * &lt; 1 byte &gt; useExtendedMasterSecret
 281      * &lt; 1 byte &gt; identificationProtocol length
 282      * &lt; length in bytes &gt; identificationProtocol
 283      * &lt; 1 byte &gt; serverNameIndication length
 284      * &lt; length in bytes &gt; serverNameIndication
 285      * &lt; 1 byte &gt; Number of requestedServerNames entries
 286      *   &lt; 1 byte &gt; ServerName length
 287      *   &lt; length in bytes &gt; ServerName
 288      * &lt; 4 bytes &gt; creationTime
 289      * &lt; 2 byte &gt; status response length
 290      *   &lt; 2 byte &gt; status response entry length
 291      *   &lt; length in byte &gt; status response entry
 292      * &lt; 1 byte &gt; Length of peer host
 293      *   &lt; length in bytes &gt; peer host
 294      * &lt; 2 bytes&gt; peer port
 295      * &lt; 1 byte &gt; Number of peerCerts entries
 296      *   &lt; 4 byte &gt; peerCert length
 297      *   &lt; length in bytes &gt; peerCert
 298      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)
 299      *   Certificate
 300      *     &lt; 1 byte &gt; Number of Certificate entries
 301      *       &lt; 4 byte&gt; Certificate length
 302      *       &lt; length in bytes&gt; Certificate
 303      *   PSK
 304      *     &lt; 1 byte &gt; Number of PSK entries
 305      *       &lt; 1 bytes &gt; PSK algorithm length
 306      *       &lt; length in bytes &gt; PSK algorithm string
 307      *       &lt; 4 bytes &gt; PSK key length
 308      *       &lt; length in bytes&gt; PSK key
 309      *       &lt; 4 bytes &gt; PSK identity length
 310      *       &lt; length in bytes&gt; PSK identity
 311      *   Anonymous
 312      *     &lt; 1 byte &gt;
 313      * &lt; 4 bytes &gt; maximumPacketSize
 314      * &lt; 4 bytes &gt; negotiatedMaxFragSize
 315     */
 316 
 317     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {
 318         int i = 0;
 319         byte[] b;
 320 
 321         boundValues = new ConcurrentHashMap&lt;&gt;();
 322         this.protocolVersion =
 323                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 324 
 325         if (protocolVersion.useTLS13PlusSpec()) {
 326             this.sessionId = new SessionId(false, null);
 327         } else {
 328             // The CH session id may reset this if it&#39;s provided
 329             this.sessionId = new SessionId(true,
 330                     hc.sslContext.getSecureRandom());
 331         }
 332 
 333         this.cipherSuite =
 334                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 335 
 336         // Local Supported signature algorithms
 337         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();
 338         i = Byte.toUnsignedInt(buf.get());
 339         while (i-- &gt; 0) {
 340             list.add(SignatureScheme.valueOf(
 341                     Short.toUnsignedInt(buf.getShort())));
 342         }
 343         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);
 344 
 345         // Peer Supported signature algorithms
 346         i = Byte.toUnsignedInt(buf.get());
 347         list.clear();
 348         while (i-- &gt; 0) {
 349             list.add(SignatureScheme.valueOf(
 350                     Short.toUnsignedInt(buf.getShort())));
 351         }
 352         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);
 353 
 354         // PSK
 355         i = Short.toUnsignedInt(buf.getShort());
 356         if (i &gt; 0) {
 357             b = new byte[i];
 358             // Get algorithm string
 359             buf.get(b, 0, i);
 360             // Encoded length
 361             i = Short.toUnsignedInt(buf.getShort());
 362             // Encoded SecretKey
 363             b = new byte[i];
 364             buf.get(b);
 365             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 366         } else {
 367             this.preSharedKey = null;
 368         }
 369 
 370         // PSK identity
 371         i = buf.get();
 372         if (i &gt; 0) {
 373             b = new byte[i];
 374             buf.get(b);
 375             this.pskIdentity = b;
 376         } else {
 377             this.pskIdentity = null;
 378         }
 379 
 380         // Master secret length of secret key algorithm  (one byte)
 381         i = buf.get();
 382         if (i &gt; 0) {
 383             b = new byte[i];
 384             // Get algorithm string
 385             buf.get(b, 0, i);
 386             // Encoded length
 387             i = Short.toUnsignedInt(buf.getShort());
 388             // Encoded SecretKey
 389             b = new byte[i];
 390             buf.get(b);
 391             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 392         } else {
 393             this.masterSecret = null;
 394         }
 395         // Use extended master secret
 396         this.useExtendedMasterSecret = (buf.get() != 0);
 397 
 398         // Identification Protocol
 399         i = buf.get();
 400         if (i == 0) {
 401             identificationProtocol = null;
 402         } else {
 403             b = new byte[i];
 404             identificationProtocol =
 405                     buf.get(b, 0, i).asCharBuffer().toString();
 406         }
 407 
 408         // SNI
 409         i = buf.get();  // length
 410         if (i == 0) {
 411             serverNameIndication = null;
 412         } else {
 413             b = new byte[i];
 414             buf.get(b, 0, b.length);
 415             serverNameIndication = new SNIHostName(b);
 416         }
 417 
 418         // List of SNIServerName
 419         int len = Short.toUnsignedInt(buf.getShort());
 420         if (len == 0) {
 421             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 422         } else {
 423             requestedServerNames = new ArrayList&lt;&gt;();
 424             while (len &gt; 0) {
 425                 int l = buf.get();
 426                 b = new byte[l];
 427                 buf.get(b, 0, l);
 428                 requestedServerNames.add(new SNIHostName(new String(b)));
 429                 len--;
 430             }
 431         }
 432 
 433         maximumPacketSize = buf.getInt();
 434         negotiatedMaxFragLen = buf.getInt();
 435 
 436         // Get creation time
 437         this.creationTime = buf.getLong();
 438 
 439         // Get Buffer sizes
 440 
 441         // Status Response
 442         len = Short.toUnsignedInt(buf.getShort());
 443         if (len == 0) {
 444             statusResponses = Collections.emptyList();
 445         } else {
 446             statusResponses = new ArrayList&lt;&gt;();
 447         }
 448         while (len-- &gt; 0) {
 449             b = new byte[Short.toUnsignedInt(buf.getShort())];
 450             buf.get(b);
 451             statusResponses.add(b);
 452         }
 453 
 454         // Get Peer host &amp; port
 455         i = Byte.toUnsignedInt(buf.get());
 456         if (i == 0) {
 457             this.host = new String();
 458         } else {
 459             b = new byte[i];
 460             this.host = buf.get(b).toString();
 461         }
 462         this.port = Short.toUnsignedInt(buf.getShort());
 463 
 464         // Peer certs
 465         i = buf.get();
 466         if (i == 0) {
 467             this.peerCerts = null;
 468         } else {
 469             this.peerCerts = new X509Certificate[i];
 470             int j = 0;
 471             while (i &gt; j) {
 472                 b = new byte[buf.getInt()];
 473                 buf.get(b);
 474                 try {
 475                     this.peerCerts[j] = new X509CertImpl(b);
 476                 } catch (Exception e) {
 477                     throw new IOException(e);
 478                 }
 479                 j++;
 480             }
 481         }
 482 
 483         // Get local certs of PSK
 484         switch (buf.get()) {
 485             case 0:
 486                 break;
 487             case 1:
 488                 // number of certs
 489                 len = buf.get();
 490                 this.localCerts = new X509Certificate[len];
 491                 i = 0;
 492                 while (len &gt; i) {
 493                     b = new byte[buf.getInt()];
 494                     buf.get(b);
 495                     try {
 496                         this.localCerts[i] = new X509CertImpl(b);
 497                     } catch (Exception e) {
 498                         throw new IOException(e);
 499                     }
 500                     i++;
 501                 }
 502                 break;
 503             case 2:
 504                 // pre-shared key
 505                 // Length of pre-shared key algorithm  (one byte)
 506                 i = buf.get();
 507                 b = new byte[i];
 508                 String alg = buf.get(b, 0, i).asCharBuffer().toString();
 509                 // Get length of encoding
 510                 i = Short.toUnsignedInt(buf.getShort());
 511                 // Get encoding
 512                 b = new byte[i];
 513                 buf.get(b);
 514                 this.preSharedKey = new SecretKeySpec(b, alg);
 515                 // Get identity len
 516                 this.pskIdentity = new byte[buf.get()];
 517                 buf.get(pskIdentity);
 518                 break;
 519             default:
 520                 throw new SSLException(&quot;Failed local certs of session.&quot;);
 521         }
 522 
 523         context = (SSLSessionContextImpl)
 524                 hc.sslContext.engineGetServerSessionContext();
 525         this.lastUsedTime = System.currentTimeMillis();
 526     }
 527 
 528     // Some situations we cannot provide a stateless ticket, but after it
 529     // has been negotiated
 530     boolean isStatelessable(HandshakeContext hc) {
 531         if (!hc.statelessResumption) {
 532             return false;
 533         }
 534 
 535         // If there is no getMasterSecret with TLS1.2 or under, do not resume.
 536         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;
 537                 getMasterSecret().getEncoded() == null) {
 538             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 539                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +
 540                         &quot; ticket&quot;);
 541             }
 542             return false;
 543         }
 544         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {
 545             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 546                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +
 547                         &quot; stateless ticket&quot;);
 548             }
 549             return false;
 550         }
 551         return true;
 552     }
 553 
 554     /**
 555      * Write out a SSLSessionImpl in a byte array for a stateless session ticket
 556      */
 557     byte[] write() throws Exception {
 558         byte[] b;
 559         HandshakeOutStream hos = new HandshakeOutStream(null);
 560 
 561         hos.putInt16(protocolVersion.id);
 562         hos.putInt16(cipherSuite.id);
 563 
 564         // Local Supported signature algorithms
 565         hos.putInt8(localSupportedSignAlgs.size());
 566         for (SignatureScheme s : localSupportedSignAlgs) {
 567             hos.putInt16(s.id);
 568         }
 569 
 570         // Peer Supported signature algorithms
 571         hos.putInt8(peerSupportedSignAlgs.size());
 572         for (SignatureScheme s : peerSupportedSignAlgs) {
 573             hos.putInt16(s.id);
 574         }
 575 
 576         // PSK
 577         if (preSharedKey == null ||
 578                 preSharedKey.getAlgorithm() == null) {
 579             hos.putInt16(0);
 580         } else {
 581             hos.putInt16(preSharedKey.getAlgorithm().length());
 582             if (preSharedKey.getAlgorithm().length() != 0) {
 583                 hos.write(preSharedKey.getAlgorithm().getBytes());
 584             }
 585             b = preSharedKey.getEncoded();
 586             hos.putInt16(b.length);
 587             hos.write(b, 0, b.length);
 588         }
 589 
 590         // PSK Identity
 591         if (pskIdentity == null) {
 592             hos.putInt8(0);
 593         } else {
 594             hos.putInt8(pskIdentity.length);
 595             hos.write(pskIdentity, 0, pskIdentity.length);
 596         }
 597 
 598         // Master Secret
 599         if (getMasterSecret() == null ||
 600                 getMasterSecret().getAlgorithm() == null) {
 601             hos.putInt8(0);
 602         } else {
 603             hos.putInt8(getMasterSecret().getAlgorithm().length());
 604             if (getMasterSecret().getAlgorithm().length() != 0) {
 605                 hos.write(getMasterSecret().getAlgorithm().getBytes());
 606             }
 607             b = getMasterSecret().getEncoded();
 608             hos.putInt16(b.length);
 609             hos.write(b, 0, b.length);
 610         }
 611 
 612         hos.putInt8(useExtendedMasterSecret ? 1 : 0);
 613 
 614         // Identification Protocol
 615         if (identificationProtocol == null) {
 616             hos.putInt8(0);
 617         } else {
 618             hos.putInt8(identificationProtocol.length());
 619             hos.write(identificationProtocol.getBytes(), 0,
 620                     identificationProtocol.length());
 621         }
 622 
 623         // SNI
 624         if (serverNameIndication == null) {
 625             hos.putInt8(0);
 626         } else {
 627             b = serverNameIndication.getEncoded();
 628             hos.putInt8(b.length);
 629             hos.write(b, 0, b.length);
 630         }
 631 
 632         // List of SNIServerName
 633         hos.putInt16(requestedServerNames.size());
 634         if (requestedServerNames.size() &gt; 0) {
 635             for (SNIServerName host : requestedServerNames) {
 636                 b = host.getEncoded();
 637                 hos.putInt8(b.length);
 638                 hos.write(b, 0, b.length);
 639             }
 640         }
 641 
 642         // Buffer sizes
 643         hos.putInt32(maximumPacketSize);
 644         hos.putInt32(negotiatedMaxFragLen);
 645 
 646         // creation time
 647         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
 648         hos.writeBytes(buffer.putLong(creationTime).array());
 649 
 650         // Status Responses
 651         List&lt;byte[]&gt; list = getStatusResponses();
 652         int l = list.size();
 653         hos.putInt16(l);
 654         for (byte[] e : list) {
 655             hos.putInt16(e.length);
 656             hos.write(e);
 657         }
 658 
 659         // peer Host &amp; Port
 660         if (host == null || host.length() == 0) {
 661             hos.putInt8(0);
 662         } else {
 663             hos.putInt8(host.length());
 664             hos.writeBytes(host.getBytes());
 665         }
 666         hos.putInt16(port);
 667 
 668         // Peer cert
 669         if (peerCerts == null || peerCerts.length == 0) {
 670             hos.putInt8(0);
 671         } else {
 672             hos.putInt8(peerCerts.length);
 673             for (X509Certificate c : peerCerts) {
 674                 b = c.getEncoded();
 675                 hos.putInt32(b.length);
 676                 hos.writeBytes(b);
 677             }
 678         }
 679 
 680         // Client identity
 681         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {
 682             // certificate based
 683             hos.putInt8(1);
 684             hos.putInt8(localCerts.length);
 685             for (X509Certificate c : localCerts) {
 686                 b = c.getEncoded();
 687                 hos.putInt32(b.length);
 688                 hos.writeBytes(b);
 689             }
 690         } else if (preSharedKey != null) {
 691             // pre-shared key
 692             hos.putInt8(2);
 693             hos.putInt8(preSharedKey.getAlgorithm().length());
 694             hos.write(preSharedKey.getAlgorithm().getBytes());
 695             b = preSharedKey.getEncoded();
 696             hos.putInt32(b.length);
 697             hos.writeBytes(b);
 698             hos.putInt32(pskIdentity.length);
 699             hos.writeBytes(pskIdentity);
 700         } else {
 701             // anonymous
 702             hos.putInt8(0);
 703         }
 704 
 705         return hos.toByteArray();
 706     }
 707 
 708     void setMasterSecret(SecretKey secret) {
 709         masterSecret = secret;
 710     }
 711 
 712     void setResumptionMasterSecret(SecretKey secret) {
 713         resumptionMasterSecret = secret;
 714     }
 715 
 716     void setPreSharedKey(SecretKey key) {
 717         preSharedKey = key;
 718     }
 719 
 720     void addChild(SSLSessionImpl session) {
 721         childSessions.add(session);
 722     }
 723 
 724     void setTicketAgeAdd(int ticketAgeAdd) {
 725         this.ticketAgeAdd = ticketAgeAdd;
 726     }
 727 
 728     void setPskIdentity(byte[] pskIdentity) {
 729         this.pskIdentity = pskIdentity;
 730     }
 731 
 732     BigInteger incrTicketNonceCounter() {
 733         BigInteger result = ticketNonceCounter;
 734         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);
 735         return result;
 736     }
 737 
 738     boolean isPSKable() {
 739         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);
 740     }
 741 
 742     /**
 743      * Returns the master secret ... treat with extreme caution!
 744      */
 745     SecretKey getMasterSecret() {
 746         return masterSecret;
 747     }
 748 
 749     SecretKey getResumptionMasterSecret() {
 750         return resumptionMasterSecret;
 751     }
 752 
 753     SecretKey getPreSharedKey() {
 754         sessionLock.lock();
 755         try {
 756             return preSharedKey;
 757         } finally {
 758             sessionLock.unlock();
 759         }
 760     }
 761 
 762     SecretKey consumePreSharedKey() {
 763         sessionLock.lock();
 764         try {
 765             return preSharedKey;
 766         } finally {
 767             preSharedKey = null;
 768             sessionLock.unlock();
 769         }
 770     }
 771 
 772     int getTicketAgeAdd() {
 773         return ticketAgeAdd;
 774     }
 775 
 776     String getIdentificationProtocol() {
 777         return this.identificationProtocol;
 778     }
 779 
 780     /* PSK identities created from new_session_ticket messages should only
 781      * be used once. This method will return the identity and then clear it
 782      * so it cannot be used again.
 783      */
 784     byte[] consumePskIdentity() {
 785         sessionLock.lock();
 786         try {
 787             return pskIdentity;
 788         } finally {
 789             pskIdentity = null;
 790             sessionLock.unlock();
 791         }
 792     }
 793 
 794     byte[] getPskIdentity() {
 795         return pskIdentity;
 796     }
 797 
 798     void setPeerCertificates(X509Certificate[] peer) {
 799         if (peerCerts == null) {
 800             peerCerts = peer;
 801         }
 802     }
 803 
 804     void setLocalCertificates(X509Certificate[] local) {
 805         localCerts = local;
 806     }
 807 
 808     void setLocalPrivateKey(PrivateKey privateKey) {
 809         localPrivateKey = privateKey;
 810     }
 811 
 812     void setPeerSupportedSignatureAlgorithms(
 813             Collection&lt;SignatureScheme&gt; signatureSchemes) {
 814         peerSupportedSignAlgs = signatureSchemes;
 815     }
 816 
 817     // TLS 1.2 only
 818     //
 819     // Per RFC 5246, If the client supports only the default hash
 820     // and signature algorithms, it MAY omit the
 821     // signature_algorithms extension.  If the client does not
 822     // support the default algorithms, or supports other hash
 823     // and signature algorithms (and it is willing to use them
 824     // for verifying messages sent by the server, i.e., server
 825     // certificates and server key exchange), it MUST send the
 826     // signature_algorithms extension, listing the algorithms it
 827     // is willing to accept.
 828     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =
 829             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,
 830                     SignatureScheme.DSA_SHA1,
 831                     SignatureScheme.ECDSA_SHA1));
 832 
 833     void setUseDefaultPeerSignAlgs() {
 834         useDefaultPeerSignAlgs = true;
 835         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;
 836     }
 837 
 838     // Returns the connection session.
 839     SSLSessionImpl finish() {
 840         if (useDefaultPeerSignAlgs) {
 841             peerSupportedSignAlgs = Collections.emptySet();
 842         }
 843 
 844         return this;
 845     }
 846 
 847     /**
 848      * Provide status response data obtained during the SSL handshake.
 849      *
 850      * @param responses a {@link List} of responses in binary form.
 851      */
 852     void setStatusResponses(List&lt;byte[]&gt; responses) {
 853         if (responses != null &amp;&amp; !responses.isEmpty()) {
 854             statusResponses = responses;
 855         } else {
 856             statusResponses = Collections.emptyList();
 857         }
 858     }
 859 
 860     /**
 861      * Returns true iff this session may be resumed ... sessions are
 862      * usually resumable.  Security policies may suggest otherwise,
 863      * for example sessions that haven&#39;t been used for a while (say,
 864      * a working day) won&#39;t be resumable, and sessions might have a
 865      * maximum lifetime in any case.
 866      */
 867     boolean isRejoinable() {
 868         // TLS 1.3 can have no session id
 869         if (protocolVersion.useTLS13PlusSpec()) {
 870             return (!invalidated &amp;&amp; isLocalAuthenticationValid());
 871         }
 872         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
 873                 !invalidated &amp;&amp; isLocalAuthenticationValid();
 874     }
 875 
 876     @Override
 877     public boolean isValid() {
 878         sessionLock.lock();
 879         try {
 880             return isRejoinable();
 881         } finally {
 882             sessionLock.unlock();
 883         }
 884     }
 885 
 886     /**
 887      * Check if the authentication used when establishing this session
 888      * is still valid. Returns true if no authentication was used
 889      */
 890     private boolean isLocalAuthenticationValid() {
 891         if (localPrivateKey != null) {
 892             try {
 893                 // if the private key is no longer valid, getAlgorithm()
 894                 // should throw an exception
 895                 // (e.g. Smartcard has been removed from the reader)
 896                 localPrivateKey.getAlgorithm();
 897             } catch (Exception e) {
 898                 invalidate();
 899                 return false;
 900             }
 901         }
 902 
 903         return true;
 904     }
 905 
 906     /**
 907      * Returns the ID for this session.  The ID is fixed for the
 908      * duration of the session; neither it, nor its value, changes.
 909      */
 910     @Override
 911     public byte[] getId() {
 912         return sessionId.getId();
 913     }
 914 
 915     /**
 916      * For server sessions, this returns the set of sessions which
 917      * are currently valid in this process.  For client sessions,
 918      * this returns null.
 919      */
 920     @Override
 921     public SSLSessionContext getSessionContext() {
 922         /*
 923          * An interim security policy until we can do something
 924          * more specific in 1.2. Only allow trusted code (code which
 925          * can set system properties) to get an
 926          * SSLSessionContext. This is to limit the ability of code to
 927          * look up specific sessions or enumerate over them. Otherwise,
 928          * code can only get session objects from successful SSL
 929          * connections which implies that they must have had permission
 930          * to make the network connection in the first place.
 931          */
 932         SecurityManager sm;
 933         if ((sm = System.getSecurityManager()) != null) {
 934             sm.checkPermission(new SSLPermission(&quot;getSSLSessionContext&quot;));
 935         }
 936 
 937         return context;
 938     }
 939 
 940 
 941     SessionId getSessionId() {
 942         return sessionId;
 943     }
 944 
 945 
 946     /**
 947      * Returns the cipher spec in use on this session
 948      */
 949     CipherSuite getSuite() {
 950         return cipherSuite;
 951     }
 952 
 953     /**
 954      * Resets the cipher spec in use on this session
 955      */
 956     void setSuite(CipherSuite suite) {
 957        cipherSuite = suite;
 958 
 959         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 960              SSLLogger.finest(&quot;Negotiating session:  &quot; + this);
 961        }
 962     }
 963 
 964     /**
 965      * Return true if the session is currently re-established with a
 966      * session-resumption abbreviated initial handshake.
 967      */
 968     boolean isSessionResumption() {
 969         return isSessionResumption;
 970     }
 971 
 972     /**
 973      * Resets whether the session is re-established with a session-resumption
 974      * abbreviated initial handshake.
 975      */
 976     void setAsSessionResumption(boolean flag) {
 977         isSessionResumption = flag;
 978     }
 979 
 980     /**
 981      * Returns the name of the cipher suite in use on this session
 982      */
 983     @Override
 984     public String getCipherSuite() {
 985         return getSuite().name;
 986     }
 987 
 988     ProtocolVersion getProtocolVersion() {
 989         return protocolVersion;
 990     }
 991 
 992     /**
 993      * Returns the standard name of the protocol in use on this session
 994      */
 995     @Override
 996     public String getProtocol() {
 997         return getProtocolVersion().name;
 998     }
 999 
1000     /**
1001      * Returns the hashcode for this session
1002      */
1003     @Override
1004     public int hashCode() {
1005         return sessionId.hashCode();
1006     }
1007 
1008     /**
1009      * Returns true if sessions have same ids, false otherwise.
1010      */
1011     @Override
1012     public boolean equals(Object obj) {
1013 
1014         if (obj == this) {
1015             return true;
1016         }
1017 
1018         if (obj instanceof SSLSessionImpl) {
1019             SSLSessionImpl sess = (SSLSessionImpl) obj;
1020             return (sessionId != null) &amp;&amp; (sessionId.equals(
1021                         sess.getSessionId()));
1022         }
1023 
1024         return false;
1025     }
1026 
1027 
1028     /**
1029      * Return the cert chain presented by the peer in the
1030      * java.security.cert format.
1031      * Note: This method can be used only when using certificate-based
1032      * cipher suites; using it with non-certificate-based cipher suites
1033      * will throw an SSLPeerUnverifiedException.
1034      *
1035      * @return array of peer X.509 certs, with the peer&#39;s own cert
1036      *  first in the chain, and with the &quot;root&quot; CA last.
1037      */
1038     @Override
1039     public java.security.cert.Certificate[] getPeerCertificates()
1040             throws SSLPeerUnverifiedException {
1041         //
1042         // clone to preserve integrity of session ... caller can&#39;t
1043         // change record of peer identity even by accident, much
1044         // less do it intentionally.
1045         //
1046         if (peerCerts == null) {
1047             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1048         }
1049         // Certs are immutable objects, therefore we don&#39;t clone them.
1050         // But do need to clone the array, so that nothing is inserted
1051         // into peerCerts.
1052         return (java.security.cert.Certificate[])peerCerts.clone();
1053     }
1054 
1055     /**
1056      * Return the cert chain presented to the peer in the
1057      * java.security.cert format.
1058      * Note: This method is useful only when using certificate-based
1059      * cipher suites.
1060      *
1061      * @return array of peer X.509 certs, with the peer&#39;s own cert
1062      *  first in the chain, and with the &quot;root&quot; CA last.
1063      */
1064     @Override
1065     public java.security.cert.Certificate[] getLocalCertificates() {
1066         //
1067         // clone to preserve integrity of session ... caller can&#39;t
1068         // change record of peer identity even by accident, much
1069         // less do it intentionally.
1070         return (localCerts == null ? null :
1071             (java.security.cert.Certificate[])localCerts.clone());
1072     }
1073 
1074     /**
1075      * Return the cert chain presented by the peer in the
1076      * javax.security.cert format.
1077      * Note: This method can be used only when using certificate-based
1078      * cipher suites; using it with non-certificate-based cipher suites
1079      * will throw an SSLPeerUnverifiedException.
1080      *
1081      * @return array of peer X.509 certs, with the peer&#39;s own cert
1082      *  first in the chain, and with the &quot;root&quot; CA last.
1083      *
1084      * @deprecated This method returns the deprecated
1085      *  {@code javax.security.cert.X509Certificate} type.
1086      *  Use {@code getPeerCertificates()} instead.
1087      */
1088     @Override
1089     @SuppressWarnings(&quot;removal&quot;)
1090     @Deprecated(since=&quot;9&quot;, forRemoval=true)
1091     public javax.security.cert.X509Certificate[] getPeerCertificateChain()
1092             throws SSLPeerUnverifiedException {
1093         //
1094         // clone to preserve integrity of session ... caller can&#39;t
1095         // change record of peer identity even by accident, much
1096         // less do it intentionally.
1097         //
1098         if (peerCerts == null) {
1099             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1100         }
1101         javax.security.cert.X509Certificate[] certs;
1102         certs = new javax.security.cert.X509Certificate[peerCerts.length];
1103         for (int i = 0; i &lt; peerCerts.length; i++) {
1104             byte[] der = null;
1105             try {
1106                 der = peerCerts[i].getEncoded();
1107                 certs[i] = javax.security.cert.X509Certificate.getInstance(der);
1108             } catch (CertificateEncodingException e) {
1109                 throw new SSLPeerUnverifiedException(e.getMessage());
1110             } catch (javax.security.cert.CertificateException e) {
1111                 throw new SSLPeerUnverifiedException(e.getMessage());
1112             }
1113         }
1114 
1115         return certs;
1116     }
1117 
1118     /**
1119      * Return the cert chain presented by the peer.
1120      * Note: This method can be used only when using certificate-based
1121      * cipher suites; using it with non-certificate-based cipher suites
1122      * will throw an SSLPeerUnverifiedException.
1123      *
1124      * @return array of peer X.509 certs, with the peer&#39;s own cert
1125      *  first in the chain, and with the &quot;root&quot; CA last.
1126      */
1127     public X509Certificate[] getCertificateChain()
1128             throws SSLPeerUnverifiedException {
1129         /*
1130          * clone to preserve integrity of session ... caller can&#39;t
1131          * change record of peer identity even by accident, much
1132          * less do it intentionally.
1133          */
1134         if (peerCerts != null) {
1135             return peerCerts.clone();
1136         } else {
1137             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1138         }
1139     }
1140 
1141     /**
1142      * Return a List of status responses presented by the peer.
1143      * Note: This method can be used only when using certificate-based
1144      * server authentication; otherwise an empty {@code List} will be returned.
1145      *
1146      * @return an unmodifiable {@code List} of byte arrays, each consisting
1147      * of a DER-encoded OCSP response (see RFC 6960).  If no responses have
1148      * been presented by the server or non-certificate based server
1149      * authentication is used then an empty {@code List} is returned.
1150      */
1151     @Override
1152     public List&lt;byte[]&gt; getStatusResponses() {
1153         if (statusResponses == null || statusResponses.isEmpty()) {
1154             return Collections.emptyList();
1155         } else {
1156             // Clone both the list and the contents
1157             List&lt;byte[]&gt; responses = new ArrayList&lt;&gt;(statusResponses.size());
1158             for (byte[] respBytes : statusResponses) {
1159                 responses.add(respBytes.clone());
1160             }
1161             return Collections.unmodifiableList(responses);
1162         }
1163     }
1164 
1165     /**
1166      * Returns the identity of the peer which was established as part of
1167      * defining the session.
1168      *
1169      * @return the peer&#39;s principal. Returns an X500Principal of the
1170      * end-entity certificate for X509-based cipher suites.
1171      *
1172      * @throws SSLPeerUnverifiedException if the peer&#39;s identity has not
1173      *          been verified
1174      */
1175     @Override
1176     public Principal getPeerPrincipal()
1177                 throws SSLPeerUnverifiedException
1178     {
1179         if (peerCerts == null) {
1180             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1181         }
1182         return peerCerts[0].getSubjectX500Principal();
1183     }
1184 
1185     /**
1186      * Returns the principal that was sent to the peer during handshaking.
1187      *
1188      * @return the principal sent to the peer. Returns an X500Principal
1189      * of the end-entity certificate for X509-based cipher suites.
1190      * If no principal was sent, then null is returned.
1191      */
1192     @Override
1193     public Principal getLocalPrincipal() {
1194         return ((localCerts == null || localCerts.length == 0) ? null :
1195                 localCerts[0].getSubjectX500Principal());
1196     }
1197 
1198     /*
1199      * Return the time the ticket for this session was created.
1200      */
1201     public long getTicketCreationTime() {
1202         return ticketCreationTime;
1203     }
1204 
1205     /**
1206      * Returns the time this session was created.
1207      */
1208     @Override
1209     public long getCreationTime() {
1210         return creationTime;
1211     }
1212 
1213     /**
1214      * Returns the last time this session was used to initialize
1215      * a connection.
1216      */
1217     @Override
1218     public long getLastAccessedTime() {
1219         return (lastUsedTime != 0) ? lastUsedTime : creationTime;
1220     }
1221 
1222     void setLastAccessedTime(long time) {
1223         lastUsedTime = time;
1224     }
1225 
1226 
1227     /**
1228      * Returns the network address of the session&#39;s peer.  This
1229      * implementation does not insist that connections between
1230      * different ports on the same host must necessarily belong
1231      * to different sessions, though that is of course allowed.
1232      */
1233     public InetAddress getPeerAddress() {
1234         try {
1235             return InetAddress.getByName(host);
1236         } catch (java.net.UnknownHostException e) {
1237             return null;
1238         }
1239     }
1240 
1241     @Override
1242     public String getPeerHost() {
1243         return host;
1244     }
1245 
1246     /**
1247      * Need to provide the port info for caching sessions based on
1248      * host and port. Accessed by SSLSessionContextImpl
1249      */
1250     @Override
1251     public int getPeerPort() {
1252         return port;
1253     }
1254 
1255     void setContext(SSLSessionContextImpl ctx) {
1256         if (context == null) {
1257             context = ctx;
1258         }
1259     }
1260 
1261     /**
1262      * Invalidate a session.  Active connections may still exist, but
1263      * no connections will be able to rejoin this session.
1264      */
1265     @Override
1266     public void invalidate() {
1267         sessionLock.lock();
1268         try {
1269             //
1270             // Can&#39;t invalidate the NULL session -- this would be
1271             // attempted when we get a handshaking error on a brand
1272             // new connection, with no &quot;real&quot; session yet.
1273             //
1274             if (this == nullSession) {
1275                 return;
1276             }
1277 
1278             if (context != null) {
1279                 context.remove(sessionId);
1280                 context = null;
1281             }
1282 
1283             if (invalidated) {
1284                 return;
1285             }
1286             invalidated = true;
1287             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
1288                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);
1289             }
1290             for (SSLSessionImpl child : childSessions) {
1291                 child.invalidate();
1292             }
1293         } finally {
1294             sessionLock.unlock();
1295         }
1296     }
1297 
1298     /*
1299      * Table of application-specific session data indexed by an application
1300      * key and the calling security context. This is important since
1301      * sessions can be shared across different protection domains.
1302      */
1303     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
1304     boolean updateNST;
1305 
1306     /**
1307      * Assigns a session value.  Session change events are given if
1308      * appropriate, to any original value as well as the new value.
1309      */
1310     @Override
1311     public void putValue(String key, Object value) {
1312         if ((key == null) || (value == null)) {
1313             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
1314         }
1315 
1316         SecureKey secureKey = new SecureKey(key);
1317         Object oldValue = boundValues.put(secureKey, value);
1318 
1319         if (oldValue instanceof SSLSessionBindingListener) {
1320             SSLSessionBindingEvent e;
1321 
1322             e = new SSLSessionBindingEvent(this, key);
1323             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
1324         }
1325         if (value instanceof SSLSessionBindingListener) {
1326             SSLSessionBindingEvent e;
1327 
1328             e = new SSLSessionBindingEvent(this, key);
1329             ((SSLSessionBindingListener)value).valueBound(e);
1330         }
1331         if (protocolVersion.useTLS13PlusSpec()) {
1332             updateNST = true;
1333         }
1334     }
1335 
1336     /**
1337      * Returns the specified session value.
1338      */
1339     @Override
1340     public Object getValue(String key) {
1341         if (key == null) {
1342             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1343         }
1344 
1345         SecureKey secureKey = new SecureKey(key);
1346         return boundValues.get(secureKey);
1347     }
1348 
1349 
1350     /**
1351      * Removes the specified session value, delivering a session changed
1352      * event as appropriate.
1353      */
1354     @Override
1355     public void removeValue(String key) {
1356         if (key == null) {
1357             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1358         }
1359 
1360         SecureKey secureKey = new SecureKey(key);
1361         Object value = boundValues.remove(secureKey);
1362 
1363         if (value instanceof SSLSessionBindingListener) {
1364             SSLSessionBindingEvent e;
1365 
1366             e = new SSLSessionBindingEvent(this, key);
1367             ((SSLSessionBindingListener)value).valueUnbound(e);
1368         }
1369         if (protocolVersion.useTLS13PlusSpec()) {
1370             updateNST = true;
1371         }
1372     }
1373 
1374 
1375     /**
1376      * Lists the names of the session values.
1377      */
1378     @Override
1379     public String[] getValueNames() {
1380         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
1381         Object securityCtx = SecureKey.getCurrentSecurityContext();
1382         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
1383                 e.hasMoreElements(); ) {
1384             SecureKey key = e.nextElement();
1385             if (securityCtx.equals(key.getSecurityContext())) {
1386                 v.add(key.getAppKey());
1387             }
1388         }
1389 
1390         return v.toArray(new String[0]);
1391     }
1392 
1393     /**
1394      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
1395      * until changed.
1396      *
1397      * In the TLS specification (section 6.2.1, RFC2246), it is not
1398      * recommended that the plaintext has more than 2^14 bytes.
1399      * However, some TLS implementations violate the specification.
1400      * This is a workaround for interoperability with these stacks.
1401      *
1402      * Application could accept large fragments up to 2^15 bytes by
1403      * setting the system property jsse.SSLEngine.acceptLargeFragments
1404      * to &quot;true&quot;.
1405      */
1406     private boolean acceptLargeFragments =
1407             Utilities.getBooleanProperty(
1408                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
1409 
1410     /**
1411      * Expand the buffer size of both SSL/TLS network packet and
1412      * application data.
1413      */
1414     protected void expandBufferSizes() {
1415         sessionLock.lock();
1416         try {
1417             acceptLargeFragments = true;
1418         } finally {
1419             sessionLock.unlock();
1420         }
1421     }
1422 
1423     /**
1424      * Gets the current size of the largest SSL/TLS packet that is expected
1425      * when using this session.
1426      */
1427     @Override
1428     public int getPacketBufferSize() {
1429         sessionLock.lock();
1430         try {
1431             // Use the bigger packet size calculated from maximumPacketSize
1432             // and negotiatedMaxFragLen.
1433             int packetSize = 0;
1434             if (negotiatedMaxFragLen &gt; 0) {
1435                 packetSize = cipherSuite.calculatePacketSize(
1436                         negotiatedMaxFragLen, protocolVersion,
1437                         protocolVersion.isDTLS);
1438             }
1439 
1440             if (maximumPacketSize &gt; 0) {
1441                 return (maximumPacketSize &gt; packetSize) ?
1442                         maximumPacketSize : packetSize;
1443             }
1444 
1445             if (packetSize != 0) {
1446                return packetSize;
1447             }
1448 
1449             if (protocolVersion.isDTLS) {
1450                 return DTLSRecord.maxRecordSize;
1451             } else {
1452                 return acceptLargeFragments ?
1453                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1454             }
1455         } finally {
1456             sessionLock.unlock();
1457         }
1458     }
1459 
1460     /**
1461      * Gets the current size of the largest application data that is
1462      * expected when using this session.
1463      */
1464     @Override
1465     public int getApplicationBufferSize() {
1466         sessionLock.lock();
1467         try {
1468             // Use the bigger fragment size calculated from maximumPacketSize
1469             // and negotiatedMaxFragLen.
1470             int fragmentSize = 0;
1471             if (maximumPacketSize &gt; 0) {
1472                 fragmentSize = cipherSuite.calculateFragSize(
1473                         maximumPacketSize, protocolVersion,
1474                         protocolVersion.isDTLS);
1475             }
1476 
1477             if (negotiatedMaxFragLen &gt; 0) {
1478                 return (negotiatedMaxFragLen &gt; fragmentSize) ?
1479                         negotiatedMaxFragLen : fragmentSize;
1480             }
1481 
1482             if (fragmentSize != 0) {
1483                 return fragmentSize;
1484             }
1485 
1486             if (protocolVersion.isDTLS) {
1487                 return Record.maxDataSize;
1488             } else {
1489                 int maxPacketSize = acceptLargeFragments ?
1490                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1491                 return (maxPacketSize - SSLRecord.headerSize);
1492             }
1493         } finally {
1494             sessionLock.unlock();
1495         }
1496     }
1497 
1498     /**
1499      * Sets the negotiated maximum fragment length, as specified by the
1500      * max_fragment_length ClientHello extension in RFC 6066.
1501      *
1502      * @param  negotiatedMaxFragLen
1503      *         the negotiated maximum fragment length, or {@code -1} if
1504      *         no such length has been negotiated.
1505      */
1506     void setNegotiatedMaxFragSize(
1507             int negotiatedMaxFragLen) {
1508         sessionLock.lock();
1509         try {
1510             this.negotiatedMaxFragLen = negotiatedMaxFragLen;
1511         } finally {
1512             sessionLock.unlock();
1513         }
1514     }
1515 
1516     /**
1517      * Get the negotiated maximum fragment length, as specified by the
1518      * max_fragment_length ClientHello extension in RFC 6066.
1519      *
1520      * @return the negotiated maximum fragment length, or {@code -1} if
1521      *         no such length has been negotiated.
1522      */
1523     int getNegotiatedMaxFragSize() {
1524         sessionLock.lock();
1525         try {
1526             return negotiatedMaxFragLen;
1527         } finally {
1528             sessionLock.unlock();
1529         }
1530     }
1531 
1532     void setMaximumPacketSize(int maximumPacketSize) {
1533         sessionLock.lock();
1534         try {
1535             this.maximumPacketSize = maximumPacketSize;
1536         } finally {
1537             sessionLock.unlock();
1538         }
1539     }
1540 
1541     int getMaximumPacketSize() {
1542         sessionLock.lock();
1543         try {
1544             return maximumPacketSize;
1545         } finally {
1546             sessionLock.unlock();
1547         }
1548     }
1549 
1550     /**
1551      * Gets an array of supported signature algorithm names that the local
1552      * side is willing to verify.
1553      */
1554     @Override
1555     public String[] getLocalSupportedSignatureAlgorithms() {
1556         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1557     }
1558 
1559     /**
1560      * Gets an array of supported signature schemes that the local side is
1561      * willing to verify.
1562      */
1563     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1564         return localSupportedSignAlgs;
1565     }
1566 
1567     /**
1568      * Gets an array of supported signature algorithms that the peer is
1569      * able to verify.
1570      */
1571     @Override
1572     public String[] getPeerSupportedSignatureAlgorithms() {
1573         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);
1574     }
1575 
1576     /**
1577      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1578      * of the requested Server Name Indication (SNI) extension.
1579      */
1580     @Override
1581     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1582         return requestedServerNames;
1583     }
1584 
1585     /** Returns a string representation of this SSL session */
1586     @Override
1587     public String toString() {
1588         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1589     }
1590 }
1591 
1592 /**
1593  * This &quot;struct&quot; class serves as a Hash Key that combines an
1594  * application-specific key and a security context.
1595  */
1596 class SecureKey {
1597     private static final Object     nullObject = new Object();
1598     private final Object            appKey;
1599     private final Object            securityCtx;
1600 
1601     static Object getCurrentSecurityContext() {
1602         SecurityManager sm = System.getSecurityManager();
1603         Object context = null;
1604 
1605         if (sm != null)
1606             context = sm.getSecurityContext();
1607         if (context == null)
1608             context = nullObject;
1609         return context;
1610     }
1611 
1612     SecureKey(Object key) {
1613         this.appKey = key;
1614         this.securityCtx = getCurrentSecurityContext();
1615     }
1616 
1617     Object getAppKey() {
1618         return appKey;
1619     }
1620 
1621     Object getSecurityContext() {
1622         return securityCtx;
1623     }
1624 
1625     @Override
1626     public int hashCode() {
1627         return appKey.hashCode() ^ securityCtx.hashCode();
1628     }
1629 
1630     @Override
1631     public boolean equals(Object o) {
1632         return o instanceof SecureKey &amp;&amp; ((SecureKey)o).appKey.equals(appKey)
1633                         &amp;&amp; ((SecureKey)o).securityCtx.equals(securityCtx);
1634     }
1635 }
    </pre>
  </body>
</html>
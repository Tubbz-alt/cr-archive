diff a/src/java.base/share/classes/sun/util/calendar/ZoneInfo.java b/src/java.base/share/classes/sun/util/calendar/ZoneInfo.java
--- a/src/java.base/share/classes/sun/util/calendar/ZoneInfo.java
+++ b/src/java.base/share/classes/sun/util/calendar/ZoneInfo.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -161,10 +161,11 @@
     /**
      * True if the object has been modified after its instantiation.
      */
     private transient boolean dirty = false;
 
+    @java.io.Serial
     private static final long serialVersionUID = 2653134537216586139L;
 
     /**
      * A constructor.
      */
@@ -271,11 +272,11 @@
             }
             return offset;
         }
 
         // beyond the transitions, delegate to SimpleTimeZone if there
-        // is a rule; otherwise, return rawOffset.
+        // is a rule; otherwise, return the offset of the last transition.
         SimpleTimeZone tz = getLastRule();
         if (tz != null) {
             int rawoffset = tz.getRawOffset();
             long msec = date;
             if (type != UTC_TIME) {
@@ -291,17 +292,22 @@
             if (offsets != null) {
                 offsets[0] = rawoffset;
                 offsets[1] = dstoffset;
             }
             return rawoffset + dstoffset;
+        } else {
+            // use the last transition
+            long val = transitions[transitions.length - 1];
+            int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;
+            if (offsets != null) {
+                int dst = (int)((val >>> DST_NSHIFT) & 0xfL);
+                int save = (dst == 0) ? 0 : this.offsets[dst];
+                offsets[0] = offset - save;
+                offsets[1] = save;
+            }
+            return offset;
         }
-        int offset = getLastRawOffset();
-        if (offsets != null) {
-            offsets[0] = offset;
-            offsets[1] = 0;
-        }
-        return offset;
     }
 
     private int getTransitionIndex(long date, int type) {
         int low = 0;
         int high = transitions.length - 1;
@@ -500,12 +506,14 @@
 
         // beyond the transition table
         SimpleTimeZone tz = getLastRule();
         if (tz != null) {
             return tz.inDaylightTime(date);
-       }
-        return false;
+        } else {
+            // use the last transition
+            return (transitions[transitions.length - 1] & DST_MASK) != 0;
+        }
     }
 
     /**
      * Returns the amount of time in milliseconds that the clock is advanced
      * during daylight saving time is in effect in its last daylight saving time rule.
@@ -717,10 +725,11 @@
      */
     public static Map<String, String> getAliasTable() {
          return ZoneInfoFile.getAliasMap();
     }
 
+    @java.io.Serial
     private void readObject(ObjectInputStream stream)
             throws IOException, ClassNotFoundException {
         stream.defaultReadObject();
         // We don't know how this object from 1.4.x or earlier has
         // been mutated. So it should always be marked as `dirty'.

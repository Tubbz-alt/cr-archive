<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/DHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.security.GeneralSecurityException;
 31 import java.security.InvalidKeyException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.PrivateKey;
 37 import java.security.PublicKey;
 38 import java.security.SecureRandom;
<a name="1" id="anc1"></a><span class="line-removed"> 39 import java.security.spec.AlgorithmParameterSpec;</span>
 40 import java.security.spec.InvalidKeySpecException;
<a name="2" id="anc2"></a><span class="line-removed"> 41 import javax.crypto.KeyAgreement;</span>
<span class="line-removed"> 42 import javax.crypto.SecretKey;</span>
 43 import javax.crypto.interfaces.DHPublicKey;
 44 import javax.crypto.spec.DHParameterSpec;
 45 import javax.crypto.spec.DHPublicKeySpec;
<a name="3" id="anc3"></a><span class="line-removed"> 46 import javax.crypto.spec.SecretKeySpec;</span>
<span class="line-removed"> 47 import javax.net.ssl.SSLHandshakeException;</span>
 48 import sun.security.action.GetPropertyAction;
<a name="4" id="anc4"></a><span class="line-modified"> 49 import sun.security.ssl.CipherSuite.HashAlg;</span>
<span class="line-removed"> 50 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed"> 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
 52 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 53 import sun.security.ssl.X509Authentication.X509Possession;
 54 import sun.security.util.KeyUtil;
 55 
 56 final class DHKeyExchange {
 57     static final SSLPossessionGenerator poGenerator =
 58             new DHEPossessionGenerator(false);
 59     static final SSLPossessionGenerator poExportableGenerator =
 60             new DHEPossessionGenerator(true);
 61     static final SSLKeyAgreementGenerator kaGenerator =
 62             new DHEKAGenerator();
 63 
<a name="5" id="anc5"></a><span class="line-modified"> 64     static final class DHECredentials implements SSLCredentials {</span>
 65         final DHPublicKey popPublicKey;
 66         final NamedGroup namedGroup;
 67 
 68         DHECredentials(DHPublicKey popPublicKey, NamedGroup namedGroup) {
 69             this.popPublicKey = popPublicKey;
 70             this.namedGroup = namedGroup;
 71         }
 72 
<a name="6" id="anc6"></a>









 73         static DHECredentials valueOf(NamedGroup ng,
 74             byte[] encodedPublic) throws IOException, GeneralSecurityException {
 75 
<a name="7" id="anc7"></a><span class="line-modified"> 76             if (ng.type != NamedGroupType.NAMED_GROUP_FFDHE) {</span>
 77                 throw new RuntimeException(
 78                         &quot;Credentials decoding:  Not FFDHE named group&quot;);
 79             }
 80 
 81             if (encodedPublic == null || encodedPublic.length == 0) {
 82                 return null;
 83             }
 84 
<a name="8" id="anc8"></a><span class="line-modified"> 85             DHParameterSpec params = (DHParameterSpec)ng.getParameterSpec();</span>
<span class="line-removed"> 86             if (params == null) {</span>
<span class="line-removed"> 87                 return null;</span>
<span class="line-removed"> 88             }</span>
<span class="line-removed"> 89 </span>
 90             KeyFactory kf = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
 91             DHPublicKeySpec spec = new DHPublicKeySpec(
 92                     new BigInteger(1, encodedPublic),
 93                     params.getP(), params.getG());
 94             DHPublicKey publicKey =
 95                     (DHPublicKey)kf.generatePublic(spec);
 96 
 97             return new DHECredentials(publicKey, ng);
 98         }
 99     }
100 
<a name="9" id="anc9"></a><span class="line-modified">101     static final class DHEPossession implements SSLPossession {</span>
102         final PrivateKey privateKey;
103         final DHPublicKey publicKey;
104         final NamedGroup namedGroup;
105 
106         DHEPossession(NamedGroup namedGroup, SecureRandom random) {
107             try {
108                 KeyPairGenerator kpg =
109                         KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
<a name="10" id="anc10"></a><span class="line-modified">110                 DHParameterSpec params =</span>
<span class="line-removed">111                         (DHParameterSpec)namedGroup.getParameterSpec();</span>
<span class="line-removed">112                 kpg.initialize(params, random);</span>
113                 KeyPair kp = generateDHKeyPair(kpg);
114                 if (kp == null) {
115                     throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
116                 }
117                 privateKey = kp.getPrivate();
118                 publicKey = (DHPublicKey)kp.getPublic();
119             } catch (GeneralSecurityException gse) {
120                 throw new RuntimeException(
121                         &quot;Could not generate DH keypair&quot;, gse);
122             }
123 
124             this.namedGroup = namedGroup;
125         }
126 
127         DHEPossession(int keyLength, SecureRandom random) {
128             DHParameterSpec params =
129                     PredefinedDHParameterSpecs.definedParams.get(keyLength);
130             try {
131                 KeyPairGenerator kpg =
132                     KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
133                 if (params != null) {
134                     kpg.initialize(params, random);
135                 } else {
136                     kpg.initialize(keyLength, random);
137                 }
138 
139                 KeyPair kp = generateDHKeyPair(kpg);
140                 if (kp == null) {
141                     throw new RuntimeException(
142                             &quot;Could not generate DH keypair of &quot; +
143                             keyLength + &quot; bits&quot;);
144                 }
145                 privateKey = kp.getPrivate();
146                 publicKey = (DHPublicKey)kp.getPublic();
147             } catch (GeneralSecurityException gse) {
148                 throw new RuntimeException(
149                         &quot;Could not generate DH keypair&quot;, gse);
150             }
151 
152             this.namedGroup = NamedGroup.valueOf(publicKey.getParams());
153         }
154 
155         DHEPossession(DHECredentials credentials, SecureRandom random) {
156             try {
157                 KeyPairGenerator kpg =
158                         KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
159                 kpg.initialize(credentials.popPublicKey.getParams(), random);
160                 KeyPair kp = generateDHKeyPair(kpg);
161                 if (kp == null) {
162                     throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
163                 }
164                 privateKey = kp.getPrivate();
165                 publicKey = (DHPublicKey)kp.getPublic();
166             } catch (GeneralSecurityException gse) {
167                 throw new RuntimeException(
168                         &quot;Could not generate DH keypair&quot;, gse);
169             }
170 
171             this.namedGroup = credentials.namedGroup;
172         }
173 
174         // Generate and validate DHPublicKeySpec
175         private KeyPair generateDHKeyPair(
176                 KeyPairGenerator kpg) throws GeneralSecurityException {
<a name="11" id="anc11"></a><span class="line-modified">177             boolean doExtraValiadtion =</span>
178                     (!KeyUtil.isOracleJCEProvider(kpg.getProvider().getName()));
179             boolean isRecovering = false;
180             for (int i = 0; i &lt;= 2; i++) {      // Try to recover from failure.
181                 KeyPair kp = kpg.generateKeyPair();
182                 // validate the Diffie-Hellman public key
<a name="12" id="anc12"></a><span class="line-modified">183                 if (doExtraValiadtion) {</span>
184                     DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
185                     try {
186                         KeyUtil.validate(spec);
187                     } catch (InvalidKeyException ivke) {
188                         if (isRecovering) {
189                             throw ivke;
190                         }
191                         // otherwise, ignore the exception and try again
192                         isRecovering = true;
193                         continue;
194                     }
195                 }
196 
197                 return kp;
198             }
199 
200             return null;
201         }
202 
203         private static DHPublicKeySpec getDHPublicKeySpec(PublicKey key) {
204             if (key instanceof DHPublicKey) {
205                 DHPublicKey dhKey = (DHPublicKey)key;
206                 DHParameterSpec params = dhKey.getParams();
207                 return new DHPublicKeySpec(dhKey.getY(),
208                                         params.getP(), params.getG());
209             }
210             try {
211                 KeyFactory factory = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
212                 return factory.getKeySpec(key, DHPublicKeySpec.class);
213             } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
214                 // unlikely
215                 throw new RuntimeException(&quot;Unable to get DHPublicKeySpec&quot;, e);
216             }
217         }
218 
219         @Override
220         public byte[] encode() {
221             // Note: the DH public value is encoded as a big-endian integer
222             // and padded to the left with zeros to the size of p in bytes.
223             byte[] encoded = Utilities.toByteArray(publicKey.getY());
224             int pSize = (KeyUtil.getKeySize(publicKey) + 7) &gt;&gt;&gt; 3;
225             if (pSize &gt; 0 &amp;&amp; encoded.length &lt; pSize) {
226                 byte[] buffer = new byte[pSize];
227                 System.arraycopy(encoded, 0,
228                         buffer, pSize - encoded.length, encoded.length);
229                 encoded = buffer;
230             }
231 
232             return encoded;
233         }
<a name="13" id="anc13"></a>














234     }
235 
236     private static final class
237             DHEPossessionGenerator implements SSLPossessionGenerator {
238         // Flag to use smart ephemeral DH key which size matches the
239         // corresponding authentication key
240         private static final boolean useSmartEphemeralDHKeys;
241 
242         // Flag to use legacy ephemeral DH key which size is 512 bits for
243         // exportable cipher suites, and 768 bits for others
244         private static final boolean useLegacyEphemeralDHKeys;
245 
246         // The customized ephemeral DH key size for non-exportable
247         // cipher suites.
248         private static final int customizedDHKeySize;
249 
250         // Is it for exportable cipher suite?
251         private final boolean exportable;
252 
253         static {
254             String property = GetPropertyAction.privilegedGetProperty(
255                     &quot;jdk.tls.ephemeralDHKeySize&quot;);
256             if (property == null || property.isEmpty()) {
257                 useLegacyEphemeralDHKeys = false;
258                 useSmartEphemeralDHKeys = false;
259                 customizedDHKeySize = -1;
260             } else if (&quot;matched&quot;.equals(property)) {
261                 useLegacyEphemeralDHKeys = false;
262                 useSmartEphemeralDHKeys = true;
263                 customizedDHKeySize = -1;
264             } else if (&quot;legacy&quot;.equals(property)) {
265                 useLegacyEphemeralDHKeys = true;
266                 useSmartEphemeralDHKeys = false;
267                 customizedDHKeySize = -1;
268             } else {
269                 useLegacyEphemeralDHKeys = false;
270                 useSmartEphemeralDHKeys = false;
271 
272                 try {
273                     // DH parameter generation can be extremely slow, best to
274                     // use one of the supported pre-computed DH parameters
275                     // (see DHCrypt class).
276                     customizedDHKeySize = Integer.parseUnsignedInt(property);
277                     if (customizedDHKeySize &lt; 1024 ||
278                             customizedDHKeySize &gt; 8192 ||
279                             (customizedDHKeySize &amp; 0x3f) != 0) {
280                         throw new IllegalArgumentException(
281                             &quot;Unsupported customized DH key size: &quot; +
282                             customizedDHKeySize + &quot;. &quot; +
283                             &quot;The key size must be multiple of 64, &quot; +
284                             &quot;and range from 1024 to 8192 (inclusive)&quot;);
285                     }
286                 } catch (NumberFormatException nfe) {
287                     throw new IllegalArgumentException(
288                         &quot;Invalid system property jdk.tls.ephemeralDHKeySize&quot;);
289                 }
290             }
291         }
292 
293         // Prevent instantiation of this class.
294         private DHEPossessionGenerator(boolean exportable) {
295             this.exportable = exportable;
296         }
297 
298         // Used for ServerKeyExchange, TLS 1.2 and prior versions.
299         @Override
300         public SSLPossession createPossession(HandshakeContext context) {
<a name="14" id="anc14"></a><span class="line-modified">301             NamedGroup preferableNamedGroup = null;</span>
302             if (!useLegacyEphemeralDHKeys &amp;&amp;
303                     (context.clientRequestedNamedGroups != null) &amp;&amp;
304                     (!context.clientRequestedNamedGroups.isEmpty())) {
305                 preferableNamedGroup =
<a name="15" id="anc15"></a><span class="line-modified">306                         SupportedGroups.getPreferredGroup(</span>
<span class="line-removed">307                                 context.negotiatedProtocol,</span>
308                                 context.algorithmConstraints,
<a name="16" id="anc16"></a><span class="line-modified">309                                 NamedGroupType.NAMED_GROUP_FFDHE,</span>

310                                 context.clientRequestedNamedGroups);
311                 if (preferableNamedGroup != null) {
312                     return new DHEPossession(preferableNamedGroup,
313                                 context.sslContext.getSecureRandom());
314                 }
315             }
316 
317             /*
318              * 768 bits ephemeral DH private keys were used to be used in
319              * ServerKeyExchange except that exportable ciphers max out at 512
320              * bits modulus values. We still adhere to this behavior in legacy
321              * mode (system property &quot;jdk.tls.ephemeralDHKeySize&quot; is defined
322              * as &quot;legacy&quot;).
323              *
324              * Old JDK (JDK 7 and previous) releases don&#39;t support DH keys
325              * bigger than 1024 bits. We have to consider the compatibility
326              * requirement. 1024 bits DH key is always used for non-exportable
327              * cipher suites in default mode (system property
328              * &quot;jdk.tls.ephemeralDHKeySize&quot; is not defined).
329              *
330              * However, if applications want more stronger strength, setting
331              * system property &quot;jdk.tls.ephemeralDHKeySize&quot; to &quot;matched&quot;
332              * is a workaround to use ephemeral DH key which size matches the
333              * corresponding authentication key. For example, if the public key
334              * size of an authentication certificate is 2048 bits, then the
335              * ephemeral DH key size should be 2048 bits accordingly unless
336              * the cipher suite is exportable.  This key sizing scheme keeps
337              * the cryptographic strength consistent between authentication
338              * keys and key-exchange keys.
339              *
340              * Applications may also want to customize the ephemeral DH key
341              * size to a fixed length for non-exportable cipher suites. This
342              * can be approached by setting system property
343              * &quot;jdk.tls.ephemeralDHKeySize&quot; to a valid positive integer between
344              * 1024 and 8192 bits, inclusive.
345              *
346              * Note that the minimum acceptable key size is 1024 bits except
347              * exportable cipher suites or legacy mode.
348              *
349              * Note that per RFC 2246, the key size limit of DH is 512 bits for
350              * exportable cipher suites.  Because of the weakness, exportable
351              * cipher suites are deprecated since TLS v1.1 and they are not
352              * enabled by default in Oracle provider. The legacy behavior is
353              * reserved and 512 bits DH key is always used for exportable
354              * cipher suites.
355              */
356             int keySize = exportable ? 512 : 1024;           // default mode
357             if (!exportable) {
358                 if (useLegacyEphemeralDHKeys) {          // legacy mode
359                     keySize = 768;
360                 } else if (useSmartEphemeralDHKeys) {    // matched mode
361                     PrivateKey key = null;
362                     ServerHandshakeContext shc =
363                             (ServerHandshakeContext)context;
364                     if (shc.interimAuthn instanceof X509Possession) {
365                         key = ((X509Possession)shc.interimAuthn).popPrivateKey;
366                     }
367 
368                     if (key != null) {
369                         int ks = KeyUtil.getKeySize(key);
370 
371                         // DH parameter generation can be extremely slow, make
372                         // sure to use one of the supported pre-computed DH
373                         // parameters.
374                         //
375                         // Old deployed applications may not be ready to
376                         // support DH key sizes bigger than 2048 bits.  Please
377                         // DON&#39;T use value other than 1024 and 2048 at present.
378                         // May improve the underlying providers and key size
379                         // limit in the future when the compatibility and
380                         // interoperability impact is limited.
381                         keySize = ks &lt;= 1024 ? 1024 : 2048;
382                     } // Otherwise, anonymous cipher suites, 1024-bit is used.
383                 } else if (customizedDHKeySize &gt; 0) {    // customized mode
384                     keySize = customizedDHKeySize;
385                 }
386             }
387 
388             return new DHEPossession(
389                     keySize, context.sslContext.getSecureRandom());
390         }
391     }
392 
393     private static final
394             class DHEKAGenerator implements SSLKeyAgreementGenerator {
<a name="17" id="anc17"></a><span class="line-modified">395         static private DHEKAGenerator instance = new DHEKAGenerator();</span>
396 
397         // Prevent instantiation of this class.
398         private DHEKAGenerator() {
399             // blank
400         }
401 
402         @Override
403         public SSLKeyDerivation createKeyDerivation(
404                 HandshakeContext context) throws IOException {
405             DHEPossession dhePossession = null;
406             DHECredentials dheCredentials = null;
407             for (SSLPossession poss : context.handshakePossessions) {
408                 if (!(poss instanceof DHEPossession)) {
409                     continue;
410                 }
411 
412                 DHEPossession dhep = (DHEPossession)poss;
413                 for (SSLCredentials cred : context.handshakeCredentials) {
414                     if (!(cred instanceof DHECredentials)) {
415                         continue;
416                     }
417                     DHECredentials dhec = (DHECredentials)cred;
418                     if (dhep.namedGroup != null &amp;&amp; dhec.namedGroup != null) {
419                         if (dhep.namedGroup.equals(dhec.namedGroup)) {
420                             dheCredentials = (DHECredentials)cred;
421                             break;
422                         }
423                     } else {
424                         DHParameterSpec pps = dhep.publicKey.getParams();
425                         DHParameterSpec cps = dhec.popPublicKey.getParams();
426                         if (pps.getP().equals(cps.getP()) &amp;&amp;
427                                 pps.getG().equals(cps.getG())) {
428                             dheCredentials = (DHECredentials)cred;
429                             break;
430                         }
431                     }
432                 }
433 
434                 if (dheCredentials != null) {
435                     dhePossession = (DHEPossession)poss;
436                     break;
437                 }
438             }
439 
440             if (dhePossession == null || dheCredentials == null) {
441                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
442                     &quot;No sufficient DHE key agreement parameters negotiated&quot;);
443             }
444 
<a name="18" id="anc18"></a><span class="line-modified">445             return new DHEKAKeyDerivation(context,</span>
446                     dhePossession.privateKey, dheCredentials.popPublicKey);
447         }
<a name="19" id="anc19"></a><span class="line-removed">448 </span>
<span class="line-removed">449         private static final</span>
<span class="line-removed">450                 class DHEKAKeyDerivation implements SSLKeyDerivation {</span>
<span class="line-removed">451             private final HandshakeContext context;</span>
<span class="line-removed">452             private final PrivateKey localPrivateKey;</span>
<span class="line-removed">453             private final PublicKey peerPublicKey;</span>
<span class="line-removed">454 </span>
<span class="line-removed">455             DHEKAKeyDerivation(HandshakeContext context,</span>
<span class="line-removed">456                     PrivateKey localPrivateKey,</span>
<span class="line-removed">457                     PublicKey peerPublicKey) {</span>
<span class="line-removed">458                 this.context = context;</span>
<span class="line-removed">459                 this.localPrivateKey = localPrivateKey;</span>
<span class="line-removed">460                 this.peerPublicKey = peerPublicKey;</span>
<span class="line-removed">461             }</span>
<span class="line-removed">462 </span>
<span class="line-removed">463             @Override</span>
<span class="line-removed">464             public SecretKey deriveKey(String algorithm,</span>
<span class="line-removed">465                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">466                 if (!context.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">467                     return t12DeriveKey(algorithm, params);</span>
<span class="line-removed">468                 } else {</span>
<span class="line-removed">469                     return t13DeriveKey(algorithm, params);</span>
<span class="line-removed">470                 }</span>
<span class="line-removed">471             }</span>
<span class="line-removed">472 </span>
<span class="line-removed">473             private SecretKey t12DeriveKey(String algorithm,</span>
<span class="line-removed">474                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">475                 try {</span>
<span class="line-removed">476                     KeyAgreement ka = KeyAgreement.getInstance(&quot;DiffieHellman&quot;);</span>
<span class="line-removed">477                     ka.init(localPrivateKey);</span>
<span class="line-removed">478                     ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">479                     SecretKey preMasterSecret =</span>
<span class="line-removed">480                             ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">481                     SSLMasterKeyDerivation mskd =</span>
<span class="line-removed">482                             SSLMasterKeyDerivation.valueOf(</span>
<span class="line-removed">483                                     context.negotiatedProtocol);</span>
<span class="line-removed">484                     if (mskd == null) {</span>
<span class="line-removed">485                         // unlikely</span>
<span class="line-removed">486                         throw new SSLHandshakeException(</span>
<span class="line-removed">487                             &quot;No expected master key derivation for protocol: &quot; +</span>
<span class="line-removed">488                             context.negotiatedProtocol.name);</span>
<span class="line-removed">489                     }</span>
<span class="line-removed">490                     SSLKeyDerivation kd = mskd.createKeyDerivation(</span>
<span class="line-removed">491                             context, preMasterSecret);</span>
<span class="line-removed">492                     return kd.deriveKey(&quot;MasterSecret&quot;, params);</span>
<span class="line-removed">493                 } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">494                     throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">495                         &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">496                 }</span>
<span class="line-removed">497             }</span>
<span class="line-removed">498 </span>
<span class="line-removed">499             private SecretKey t13DeriveKey(String algorithm,</span>
<span class="line-removed">500                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">501                 try {</span>
<span class="line-removed">502                     KeyAgreement ka = KeyAgreement.getInstance(&quot;DiffieHellman&quot;);</span>
<span class="line-removed">503                     ka.init(localPrivateKey);</span>
<span class="line-removed">504                     ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">505                     SecretKey sharedSecret =</span>
<span class="line-removed">506                             ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">507 </span>
<span class="line-removed">508                     HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;</span>
<span class="line-removed">509                     SSLKeyDerivation kd = context.handshakeKeyDerivation;</span>
<span class="line-removed">510                     HKDF hkdf = new HKDF(hashAlg.name);</span>
<span class="line-removed">511                     if (kd == null) {   // No PSK is in use.</span>
<span class="line-removed">512                         // If PSK is not in use Early Secret will still be</span>
<span class="line-removed">513                         // HKDF-Extract(0, 0).</span>
<span class="line-removed">514                         byte[] zeros = new byte[hashAlg.hashLength];</span>
<span class="line-removed">515                         SecretKeySpec ikm =</span>
<span class="line-removed">516                                 new SecretKeySpec(zeros, &quot;TlsPreSharedSecret&quot;);</span>
<span class="line-removed">517                         SecretKey earlySecret =</span>
<span class="line-removed">518                                 hkdf.extract(zeros, ikm, &quot;TlsEarlySecret&quot;);</span>
<span class="line-removed">519                         kd = new SSLSecretDerivation(context, earlySecret);</span>
<span class="line-removed">520                     }</span>
<span class="line-removed">521 </span>
<span class="line-removed">522                     // derive salt secret</span>
<span class="line-removed">523                     SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);</span>
<span class="line-removed">524 </span>
<span class="line-removed">525                     // derive handshake secret</span>
<span class="line-removed">526                     return hkdf.extract(saltSecret, sharedSecret, algorithm);</span>
<span class="line-removed">527                 } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">528                     throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">529                         &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">530                 }</span>
<span class="line-removed">531             }</span>
<span class="line-removed">532         }</span>
533     }
534 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
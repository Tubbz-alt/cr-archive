<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;
 34 import java.net.SocketTimeoutException;
 35 import java.net.StandardSocketOptions;
 36 import java.nio.channels.AlreadyBoundException;
 37 import java.nio.channels.AsynchronousCloseException;
 38 import java.nio.channels.ClosedChannelException;
 39 import java.nio.channels.IllegalBlockingModeException;
 40 import java.nio.channels.NotYetBoundException;
 41 import java.nio.channels.SelectionKey;
 42 import java.nio.channels.ServerSocketChannel;
 43 import java.nio.channels.SocketChannel;
 44 import java.nio.channels.spi.SelectorProvider;
 45 import java.util.Collections;
 46 import java.util.HashSet;
 47 import java.util.Objects;
 48 import java.util.Set;
 49 import java.util.concurrent.locks.ReentrantLock;
 50 
 51 import sun.net.NetHooks;
 52 import sun.net.ext.ExtendedSocketOptions;
 53 
 54 /**
 55  * An implementation of ServerSocketChannels
 56  */
 57 
 58 class ServerSocketChannelImpl
 59     extends ServerSocketChannel
 60     implements SelChImpl
 61 {
 62     // Used to make native close and configure calls
 63     private static final NativeDispatcher nd = new SocketDispatcher();
 64 
 65     // Our file descriptor
 66     private final FileDescriptor fd;
 67     private final int fdVal;
 68 
 69     // Lock held by thread currently blocked on this channel
 70     private final ReentrantLock acceptLock = new ReentrantLock();
 71 
 72     // Lock held by any thread that modifies the state fields declared below
 73     // DO NOT invoke a blocking I/O operation while holding this lock!
 74     private final Object stateLock = new Object();
 75 
 76     // -- The following fields are protected by stateLock
 77 
 78     // Channel state, increases monotonically
 79     private static final int ST_INUSE = 0;
 80     private static final int ST_CLOSING = 1;
 81     private static final int ST_CLOSED = 2;
 82     private int state;
 83 
 84     // ID of native thread currently blocked in this channel, for signalling
 85     private long thread;
 86 
 87     // Binding
 88     private InetSocketAddress localAddress; // null =&gt; unbound
 89 
 90     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 91     private boolean isReuseAddress;
 92 
 93     // Our socket adaptor, if any
 94     private ServerSocket socket;
 95 
 96     // -- End of fields protected by stateLock
 97 
 98 
 99     ServerSocketChannelImpl(SelectorProvider sp) {
100         super(sp);
101         this.fd = Net.serverSocket(true);
102         this.fdVal = IOUtil.fdVal(fd);
103     }
104 
105     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
106         throws IOException
107     {
108         super(sp);
109         this.fd =  fd;
110         this.fdVal = IOUtil.fdVal(fd);
111         if (bound) {
112             synchronized (stateLock) {
113                 localAddress = Net.localAddress(fd);
114             }
115         }
116     }
117 
118     // @throws ClosedChannelException if channel is closed
119     private void ensureOpen() throws ClosedChannelException {
120         if (!isOpen())
121             throw new ClosedChannelException();
122     }
123 
124     @Override
125     public ServerSocket socket() {
126         synchronized (stateLock) {
127             if (socket == null)
128                 socket = ServerSocketAdaptor.create(this);
129             return socket;
130         }
131     }
132 
133     @Override
134     public SocketAddress getLocalAddress() throws IOException {
135         synchronized (stateLock) {
136             ensureOpen();
137             return (localAddress == null)
138                     ? null
139                     : Net.getRevealedLocalAddress(localAddress);
140         }
141     }
142 
143     @Override
144     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
145         throws IOException
146     {
147         Objects.requireNonNull(name);
148         if (!supportedOptions().contains(name))
149             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
150         if (!name.type().isInstance(value))
151             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
152 
153         synchronized (stateLock) {
154             ensureOpen();
155 
156             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
157                 // SO_REUSEADDR emulated when using exclusive bind
158                 isReuseAddress = (Boolean)value;
159             } else {
160                 // no options that require special handling
161                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
162             }
163             return this;
164         }
165     }
166 
167     @Override
168     @SuppressWarnings(&quot;unchecked&quot;)
169     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
170         throws IOException
171     {
172         Objects.requireNonNull(name);
173         if (!supportedOptions().contains(name))
174             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
175 
176         synchronized (stateLock) {
177             ensureOpen();
178             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
179                 // SO_REUSEADDR emulated when using exclusive bind
180                 return (T)Boolean.valueOf(isReuseAddress);
181             }
182             // no options that require special handling
183             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
184         }
185     }
186 
187     private static class DefaultOptionsHolder {
188         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
189 
190         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
191             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
192             set.add(StandardSocketOptions.SO_RCVBUF);
193             set.add(StandardSocketOptions.SO_REUSEADDR);
194             if (Net.isReusePortAvailable()) {
195                 set.add(StandardSocketOptions.SO_REUSEPORT);
196             }
197             set.addAll(ExtendedSocketOptions.serverSocketOptions());
198             return Collections.unmodifiableSet(set);
199         }
200     }
201 
202     @Override
203     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
204         return DefaultOptionsHolder.defaultOptions;
205     }
206 
207     @Override
208     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
209         synchronized (stateLock) {
210             ensureOpen();
211             if (localAddress != null)
212                 throw new AlreadyBoundException();
213             InetSocketAddress isa = (local == null)
214                                     ? new InetSocketAddress(0)
215                                     : Net.checkAddress(local);
216             SecurityManager sm = System.getSecurityManager();
217             if (sm != null)
218                 sm.checkListen(isa.getPort());
219             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
220             Net.bind(fd, isa.getAddress(), isa.getPort());
221             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
222             localAddress = Net.localAddress(fd);
223         }
224         return this;
225     }
226 
227     /**
228      * Marks the beginning of an I/O operation that might block.
229      *
230      * @throws ClosedChannelException if the channel is closed
231      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
232      */
233     private void begin(boolean blocking) throws ClosedChannelException {
234         if (blocking)
235             begin();  // set blocker to close channel if interrupted
236         synchronized (stateLock) {
237             ensureOpen();
238             if (localAddress == null)
239                 throw new NotYetBoundException();
240             if (blocking)
241                 thread = NativeThread.current();
242         }
243     }
244 
245     /**
246      * Marks the end of an I/O operation that may have blocked.
247      *
248      * @throws AsynchronousCloseException if the channel was closed due to this
249      * thread being interrupted on a blocking I/O operation.
250      */
251     private void end(boolean blocking, boolean completed)
252         throws AsynchronousCloseException
253     {
254         if (blocking) {
255             synchronized (stateLock) {
256                 thread = 0;
257                 if (state == ST_CLOSING) {
258                     tryFinishClose();
259                 }
260             }
261             end(completed);
262         }
263     }
264 
265     @Override
266     public SocketChannel accept() throws IOException {
267         int n = 0;
268         FileDescriptor newfd = new FileDescriptor();
269         InetSocketAddress[] isaa = new InetSocketAddress[1];
270 
271         acceptLock.lock();
272         try {
273             boolean blocking = isBlocking();
274             try {
275                 begin(blocking);
276                 n = Net.accept(this.fd, newfd, isaa);
277                 if (blocking) {
278                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
279                         park(Net.POLLIN);
280                         n = Net.accept(this.fd, newfd, isaa);
281                     }
282                 }
283             } finally {
284                 end(blocking, n &gt; 0);
285                 assert IOStatus.check(n);
286             }
287         } finally {
288             acceptLock.unlock();
289         }
290 
291         if (n &gt; 0) {
292             return finishAccept(newfd, isaa[0]);
293         } else {
294             return null;
295         }
296     }
297 
298     /**
299      * Accepts a new connection with a given timeout. This method requires the
300      * channel to be configured in blocking mode.
301      *
302      * @apiNote This method is for use by the socket adaptor.
303      *
304      * @param nanos the timeout, in nanoseconds
305      * @throws IllegalBlockingModeException if the channel is configured non-blocking
306      * @throws SocketTimeoutException if the timeout expires
307      */
308     SocketChannel blockingAccept(long nanos) throws IOException {
309         int n = 0;
310         FileDescriptor newfd = new FileDescriptor();
311         InetSocketAddress[] isaa = new InetSocketAddress[1];
312 
313         acceptLock.lock();
314         try {
315             // check that channel is configured blocking
316             if (!isBlocking())
317                 throw new IllegalBlockingModeException();
318 
319             try {
320                 begin(true);
321                 // change socket to non-blocking
322                 lockedConfigureBlocking(false);
323                 try {
324                     long startNanos = System.nanoTime();
325                     n = Net.accept(fd, newfd, isaa);
326                     while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {
327                         long remainingNanos = nanos - (System.nanoTime() - startNanos);
328                         if (remainingNanos &lt;= 0) {
329                             throw new SocketTimeoutException(&quot;Accept timed out&quot;);
330                         }
331                         park(Net.POLLIN, remainingNanos);
332                         n = Net.accept(fd, newfd, isaa);
333                     }
334                 } finally {
335                     // restore socket to blocking mode (if channel is open)
336                     tryLockedConfigureBlocking(true);
337                 }
338             } finally {
339                 end(true, n &gt; 0);
340             }
341         } finally {
342             acceptLock.unlock();
343         }
344 
345         assert n &gt; 0;
346         return finishAccept(newfd, isaa[0]);
347     }
348 
349     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)
350         throws IOException
351     {
352         try {
353             // newly accepted socket is initially in blocking mode
354             IOUtil.configureBlocking(newfd, true);
355 
356             // check permitted to accept connections from the remote address
357             SecurityManager sm = System.getSecurityManager();
358             if (sm != null) {
359                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
360             }
361             return new SocketChannelImpl(provider(), newfd, isa);
362         } catch (Exception e) {
363             nd.close(newfd);
364             throw e;
365         }
366     }
367 
368     @Override
369     protected void implConfigureBlocking(boolean block) throws IOException {
370         acceptLock.lock();
371         try {
372             lockedConfigureBlocking(block);
373         } finally {
374             acceptLock.unlock();
375         }
376     }
377 
378     /**
379      * Adjust the blocking. acceptLock must already be held.
380      */
381     private void lockedConfigureBlocking(boolean block) throws IOException {
382         assert acceptLock.isHeldByCurrentThread();
383         synchronized (stateLock) {
384             ensureOpen();
385             IOUtil.configureBlocking(fd, block);
386         }
387     }
388 
389     /**
390      * Adjusts the blocking mode if the channel is open. acceptLock must already
391      * be held.
392      *
393      * @return {@code true} if the blocking mode was adjusted, {@code false} if
394      *         the blocking mode was not adjusted because the channel is closed
395      */
396     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {
397         assert acceptLock.isHeldByCurrentThread();
398         synchronized (stateLock) {
399             if (isOpen()) {
400                 IOUtil.configureBlocking(fd, block);
401                 return true;
402             } else {
403                 return false;
404             }
405         }
406     }
407 
408     /**
409      * Closes the socket if there are no accept in progress and the channel is
410      * not registered with a Selector.
411      */
412     private boolean tryClose() throws IOException {
413         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;
414         if ((thread == 0) &amp;&amp; !isRegistered()) {
415             state = ST_CLOSED;
416             nd.close(fd);
417             return true;
418         } else {
419             return false;
420         }
421     }
422 
423     /**
424      * Invokes tryClose to attempt to close the socket.
425      *
426      * This method is used for deferred closing by I/O and Selector operations.
427      */
428     private void tryFinishClose() {
429         try {
430             tryClose();
431         } catch (IOException ignore) { }
432     }
433 
434     /**
435      * Closes this channel when configured in blocking mode.
436      *
437      * If there is an accept in progress then the socket is pre-closed and the
438      * accept thread is signalled, in which case the final close is deferred
439      * until the accept aborts.
440      */
441     private void implCloseBlockingMode() throws IOException {
442         synchronized (stateLock) {
443             assert state &lt; ST_CLOSING;
444             state = ST_CLOSING;
445             if (!tryClose()) {
446                 long th = thread;
447                 if (th != 0) {
448                     nd.preClose(fd);
449                     NativeThread.signal(th);
450                 }
451             }
452         }
453     }
454 
455     /**
456      * Closes this channel when configured in non-blocking mode.
457      *
458      * If the channel is registered with a Selector then the close is deferred
459      * until the channel is flushed from all Selectors.
460      */
461     private void implCloseNonBlockingMode() throws IOException {
462         synchronized (stateLock) {
463             assert state &lt; ST_CLOSING;
464             state = ST_CLOSING;
465         }
466         // wait for any accept to complete before trying to close
467         acceptLock.lock();
468         acceptLock.unlock();
469         synchronized (stateLock) {
470             if (state == ST_CLOSING) {
471                 tryClose();
472             }
473         }
474     }
475 
476     /**
477      * Invoked by implCloseChannel to close the channel.
478      */
479     @Override
480     protected void implCloseSelectableChannel() throws IOException {
481         assert !isOpen();
482         if (isBlocking()) {
483             implCloseBlockingMode();
484         } else {
485             implCloseNonBlockingMode();
486         }
487     }
488 
489     @Override
490     public void kill() {
491         synchronized (stateLock) {
492             if (state == ST_CLOSING) {
493                 tryFinishClose();
494             }
495         }
496     }
497 
498     /**
499      * Returns true if channel&#39;s socket is bound
500      */
501     boolean isBound() {
502         synchronized (stateLock) {
503             return localAddress != null;
504         }
505     }
506 
507     /**
508      * Returns the local address, or null if not bound
509      */
510     InetSocketAddress localAddress() {
511         synchronized (stateLock) {
512             return localAddress;
513         }
514     }
515 
516     /**
517      * Translates native poll revent set into a ready operation set
518      */
519     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
520         int intOps = ski.nioInterestOps();
521         int oldOps = ski.nioReadyOps();
522         int newOps = initialOps;
523 
524         if ((ops &amp; Net.POLLNVAL) != 0) {
525             // This should only happen if this channel is pre-closed while a
526             // selection operation is in progress
527             // ## Throw an error if this channel has not been pre-closed
528             return false;
529         }
530 
531         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
532             newOps = intOps;
533             ski.nioReadyOps(newOps);
534             return (newOps &amp; ~oldOps) != 0;
535         }
536 
537         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
538             ((intOps &amp; SelectionKey.OP_ACCEPT) != 0))
539                 newOps |= SelectionKey.OP_ACCEPT;
540 
541         ski.nioReadyOps(newOps);
542         return (newOps &amp; ~oldOps) != 0;
543     }
544 
545     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
546         return translateReadyOps(ops, ski.nioReadyOps(), ski);
547     }
548 
549     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
550         return translateReadyOps(ops, 0, ski);
551     }
552 
553     /**
554      * Translates an interest operation set into a native poll event set
555      */
556     public int translateInterestOps(int ops) {
557         int newOps = 0;
558         if ((ops &amp; SelectionKey.OP_ACCEPT) != 0)
559             newOps |= Net.POLLIN;
560         return newOps;
561     }
562 
563     public FileDescriptor getFD() {
564         return fd;
565     }
566 
567     public int getFDVal() {
568         return fdVal;
569     }
570 
571     public String toString() {
572         StringBuilder sb = new StringBuilder();
573         sb.append(this.getClass().getName());
574         sb.append(&#39;[&#39;);
575         if (!isOpen()) {
576             sb.append(&quot;closed&quot;);
577         } else {
578             synchronized (stateLock) {
579                 InetSocketAddress addr = localAddress;
580                 if (addr == null) {
581                     sb.append(&quot;unbound&quot;);
582                 } else {
583                     sb.append(Net.getRevealedLocalAddressAsString(addr));
584                 }
585             }
586         }
587         sb.append(&#39;]&#39;);
588         return sb.toString();
589     }
590 }
    </pre>
  </body>
</html>
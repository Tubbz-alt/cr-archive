<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/Util.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketOptionRegistry.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../cs/ArrayDecoder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/Util.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.lang.reflect.Constructor;
 31 import java.lang.reflect.InvocationTargetException;
 32 import java.nio.ByteBuffer;
 33 import java.nio.MappedByteBuffer;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.util.Collection;
 37 import java.util.Iterator;
 38 import java.util.Set;
 39 

 40 import jdk.internal.misc.TerminatingThreadLocal;
 41 import jdk.internal.misc.Unsafe;
 42 import sun.security.action.GetPropertyAction;
 43 
 44 public class Util {
 45 
 46     // -- Caches --
 47 
 48     // The number of temp buffers in our pool
 49     private static final int TEMP_BUF_POOL_SIZE = IOUtil.IOV_MAX;
 50 
 51     // The max size allowed for a cached temp buffer, in bytes
 52     private static final long MAX_CACHED_BUFFER_SIZE = getMaxCachedBufferSize();
 53 
 54     // Per-thread cache of temporary direct buffers
 55     private static ThreadLocal&lt;BufferCache&gt; bufferCache = new TerminatingThreadLocal&lt;&gt;() {
 56         @Override
 57         protected BufferCache initialValue() {
 58             return new BufferCache();
 59         }
</pre>
<hr />
<pre>
398 
399     private static int pageSize = -1;
400 
401     static int pageSize() {
402         if (pageSize == -1)
403             pageSize = unsafe().pageSize();
404         return pageSize;
405     }
406 
407     private static volatile Constructor&lt;?&gt; directByteBufferConstructor;
408 
409     private static void initDBBConstructor() {
410         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
411                 public Void run() {
412                     try {
413                         Class&lt;?&gt; cl = Class.forName(&quot;java.nio.DirectByteBuffer&quot;);
414                         Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(
415                             new Class&lt;?&gt;[] { int.class,
416                                              long.class,
417                                              FileDescriptor.class,
<span class="line-modified">418                                              Runnable.class });</span>

419                         ctor.setAccessible(true);
420                         directByteBufferConstructor = ctor;
421                     } catch (ClassNotFoundException   |
422                              NoSuchMethodException    |
423                              IllegalArgumentException |
424                              ClassCastException x) {
425                         throw new InternalError(x);
426                     }
427                     return null;
428                 }});
429     }
430 
431     static MappedByteBuffer newMappedByteBuffer(int size, long addr,
432                                                 FileDescriptor fd,
<span class="line-modified">433                                                 Runnable unmapper)</span>

434     {
435         MappedByteBuffer dbb;
436         if (directByteBufferConstructor == null)
437             initDBBConstructor();
438         try {
439             dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(
440               new Object[] { size,
441                              addr,
442                              fd,
<span class="line-modified">443                              unmapper });</span>

444         } catch (InstantiationException |
445                  IllegalAccessException |
446                  InvocationTargetException e) {
447             throw new InternalError(e);
448         }
449         return dbb;
450     }
451 
452     private static volatile Constructor&lt;?&gt; directByteBufferRConstructor;
453 
454     private static void initDBBRConstructor() {
455         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
456                 public Void run() {
457                     try {
458                         Class&lt;?&gt; cl = Class.forName(&quot;java.nio.DirectByteBufferR&quot;);
459                         Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(
460                             new Class&lt;?&gt;[] { int.class,
461                                              long.class,
462                                              FileDescriptor.class,
<span class="line-modified">463                                              Runnable.class });</span>

464                         ctor.setAccessible(true);
465                         directByteBufferRConstructor = ctor;
466                     } catch (ClassNotFoundException |
467                              NoSuchMethodException |
468                              IllegalArgumentException |
469                              ClassCastException x) {
470                         throw new InternalError(x);
471                     }
472                     return null;
473                 }});
474     }
475 
476     static MappedByteBuffer newMappedByteBufferR(int size, long addr,
477                                                  FileDescriptor fd,
<span class="line-modified">478                                                  Runnable unmapper)</span>

479     {
480         MappedByteBuffer dbb;
481         if (directByteBufferRConstructor == null)
482             initDBBRConstructor();
483         try {
484             dbb = (MappedByteBuffer)directByteBufferRConstructor.newInstance(
485               new Object[] { size,
486                              addr,
487                              fd,
<span class="line-modified">488                              unmapper });</span>

489         } catch (InstantiationException |
490                  IllegalAccessException |
491                  InvocationTargetException e) {
492             throw new InternalError(e);
493         }
494         return dbb;
495     }
496 
497     static void checkBufferPositionAligned(ByteBuffer bb,
498                                                      int pos, int alignment)
499         throws IOException
500     {
501         if (bb.alignmentOffset(pos, alignment) != 0) {
502             throw new IOException(&quot;Current location of the bytebuffer (&quot;
503                 + pos + &quot;) is not a multiple of the block size (&quot;
504                 + alignment + &quot;)&quot;);
505         }
506     }
507 
508     static void checkRemainingBufferSizeAligned(int rem,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.lang.reflect.Constructor;
 31 import java.lang.reflect.InvocationTargetException;
 32 import java.nio.ByteBuffer;
 33 import java.nio.MappedByteBuffer;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.util.Collection;
 37 import java.util.Iterator;
 38 import java.util.Set;
 39 
<span class="line-added"> 40 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
 41 import jdk.internal.misc.TerminatingThreadLocal;
 42 import jdk.internal.misc.Unsafe;
 43 import sun.security.action.GetPropertyAction;
 44 
 45 public class Util {
 46 
 47     // -- Caches --
 48 
 49     // The number of temp buffers in our pool
 50     private static final int TEMP_BUF_POOL_SIZE = IOUtil.IOV_MAX;
 51 
 52     // The max size allowed for a cached temp buffer, in bytes
 53     private static final long MAX_CACHED_BUFFER_SIZE = getMaxCachedBufferSize();
 54 
 55     // Per-thread cache of temporary direct buffers
 56     private static ThreadLocal&lt;BufferCache&gt; bufferCache = new TerminatingThreadLocal&lt;&gt;() {
 57         @Override
 58         protected BufferCache initialValue() {
 59             return new BufferCache();
 60         }
</pre>
<hr />
<pre>
399 
400     private static int pageSize = -1;
401 
402     static int pageSize() {
403         if (pageSize == -1)
404             pageSize = unsafe().pageSize();
405         return pageSize;
406     }
407 
408     private static volatile Constructor&lt;?&gt; directByteBufferConstructor;
409 
410     private static void initDBBConstructor() {
411         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
412                 public Void run() {
413                     try {
414                         Class&lt;?&gt; cl = Class.forName(&quot;java.nio.DirectByteBuffer&quot;);
415                         Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(
416                             new Class&lt;?&gt;[] { int.class,
417                                              long.class,
418                                              FileDescriptor.class,
<span class="line-modified">419                                              Runnable.class,</span>
<span class="line-added">420                                              boolean.class, MemorySegmentProxy.class});</span>
421                         ctor.setAccessible(true);
422                         directByteBufferConstructor = ctor;
423                     } catch (ClassNotFoundException   |
424                              NoSuchMethodException    |
425                              IllegalArgumentException |
426                              ClassCastException x) {
427                         throw new InternalError(x);
428                     }
429                     return null;
430                 }});
431     }
432 
433     static MappedByteBuffer newMappedByteBuffer(int size, long addr,
434                                                 FileDescriptor fd,
<span class="line-modified">435                                                 Runnable unmapper,</span>
<span class="line-added">436                                                 boolean isSync)</span>
437     {
438         MappedByteBuffer dbb;
439         if (directByteBufferConstructor == null)
440             initDBBConstructor();
441         try {
442             dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(
443               new Object[] { size,
444                              addr,
445                              fd,
<span class="line-modified">446                              unmapper,</span>
<span class="line-added">447                              isSync, null});</span>
448         } catch (InstantiationException |
449                  IllegalAccessException |
450                  InvocationTargetException e) {
451             throw new InternalError(e);
452         }
453         return dbb;
454     }
455 
456     private static volatile Constructor&lt;?&gt; directByteBufferRConstructor;
457 
458     private static void initDBBRConstructor() {
459         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
460                 public Void run() {
461                     try {
462                         Class&lt;?&gt; cl = Class.forName(&quot;java.nio.DirectByteBufferR&quot;);
463                         Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(
464                             new Class&lt;?&gt;[] { int.class,
465                                              long.class,
466                                              FileDescriptor.class,
<span class="line-modified">467                                              Runnable.class,</span>
<span class="line-added">468                                              boolean.class, MemorySegmentProxy.class });</span>
469                         ctor.setAccessible(true);
470                         directByteBufferRConstructor = ctor;
471                     } catch (ClassNotFoundException |
472                              NoSuchMethodException |
473                              IllegalArgumentException |
474                              ClassCastException x) {
475                         throw new InternalError(x);
476                     }
477                     return null;
478                 }});
479     }
480 
481     static MappedByteBuffer newMappedByteBufferR(int size, long addr,
482                                                  FileDescriptor fd,
<span class="line-modified">483                                                  Runnable unmapper,</span>
<span class="line-added">484                                                  boolean isSync)</span>
485     {
486         MappedByteBuffer dbb;
487         if (directByteBufferRConstructor == null)
488             initDBBRConstructor();
489         try {
490             dbb = (MappedByteBuffer)directByteBufferRConstructor.newInstance(
491               new Object[] { size,
492                              addr,
493                              fd,
<span class="line-modified">494                              unmapper,</span>
<span class="line-added">495                              isSync, null});</span>
496         } catch (InstantiationException |
497                  IllegalAccessException |
498                  InvocationTargetException e) {
499             throw new InternalError(e);
500         }
501         return dbb;
502     }
503 
504     static void checkBufferPositionAligned(ByteBuffer bb,
505                                                      int pos, int alignment)
506         throws IOException
507     {
508         if (bb.alignmentOffset(pos, alignment) != 0) {
509             throw new IOException(&quot;Current location of the bytebuffer (&quot;
510                 + pos + &quot;) is not a multiple of the block size (&quot;
511                 + alignment + &quot;)&quot;);
512         }
513     }
514 
515     static void checkRemainingBufferSizeAligned(int rem,
</pre>
</td>
</tr>
</table>
<center><a href="SocketOptionRegistry.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../cs/ArrayDecoder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
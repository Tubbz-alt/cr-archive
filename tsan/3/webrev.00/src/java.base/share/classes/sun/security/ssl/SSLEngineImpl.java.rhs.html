<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.nio.ReadOnlyBufferException;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedActionException;
  33 import java.security.PrivilegedExceptionAction;
  34 import java.util.List;
  35 import java.util.Map;
<a name="2" id="anc2"></a><span class="line-added">  36 import java.util.concurrent.locks.ReentrantLock;</span>
  37 import java.util.function.BiFunction;
  38 import javax.net.ssl.SSLEngine;
  39 import javax.net.ssl.SSLEngineResult;
  40 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  41 import javax.net.ssl.SSLEngineResult.Status;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLKeyException;
  45 import javax.net.ssl.SSLParameters;
  46 import javax.net.ssl.SSLPeerUnverifiedException;
  47 import javax.net.ssl.SSLProtocolException;
  48 import javax.net.ssl.SSLSession;
  49 
  50 /**
  51  * Implementation of an non-blocking SSLEngine.
  52  *
  53  * @author Brad Wetmore
  54  */
  55 final class SSLEngineImpl extends SSLEngine implements SSLTransport {
  56     private final SSLContextImpl        sslContext;
  57     final TransportContext              conContext;
<a name="3" id="anc3"></a><span class="line-added">  58     private final ReentrantLock         engineLock = new ReentrantLock();</span>
  59 
  60     /**
  61      * Constructor for an SSLEngine from SSLContext, without
  62      * host/port hints.
  63      *
  64      * This Engine will not be able to cache sessions, but must renegotiate
  65      * everything by hand.
  66      */
  67     SSLEngineImpl(SSLContextImpl sslContext) {
  68         this(sslContext, null, -1);
  69     }
  70 
  71     /**
  72      * Constructor for an SSLEngine from SSLContext.
  73      */
  74     SSLEngineImpl(SSLContextImpl sslContext,
  75             String host, int port) {
  76         super(host, port);
  77         this.sslContext = sslContext;
  78         HandshakeHash handshakeHash = new HandshakeHash();
  79         if (sslContext.isDTLS()) {
  80             this.conContext = new TransportContext(sslContext, this,
  81                     new DTLSInputRecord(handshakeHash),
  82                     new DTLSOutputRecord(handshakeHash));
  83         } else {
  84             this.conContext = new TransportContext(sslContext, this,
  85                     new SSLEngineInputRecord(handshakeHash),
  86                     new SSLEngineOutputRecord(handshakeHash));
  87         }
  88 
  89         // Server name indication is a connection scope extension.
  90         if (host != null) {
  91             this.conContext.sslConfig.serverNames =
  92                     Utilities.addToSNIServerNameList(
  93                             conContext.sslConfig.serverNames, host);
  94         }
  95     }
  96 
  97     @Override
<a name="4" id="anc4"></a><span class="line-modified">  98     public void beginHandshake() throws SSLException {</span>
<span class="line-modified">  99         engineLock.lock();</span>




 100         try {
<a name="5" id="anc5"></a><span class="line-modified"> 101             if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 102                 throw new IllegalStateException(</span>
<span class="line-modified"> 103                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified"> 104             }</span>
<span class="line-modified"> 105 </span>
<span class="line-modified"> 106             try {</span>
<span class="line-modified"> 107                 conContext.kickstart();</span>
<span class="line-added"> 108             } catch (IOException ioe) {</span>
<span class="line-added"> 109                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added"> 110                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);</span>
<span class="line-added"> 111             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-added"> 112                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-added"> 113                     &quot;Fail to begin handshake&quot;, ex);</span>
<span class="line-added"> 114             }</span>
<span class="line-added"> 115         } finally {</span>
<span class="line-added"> 116             engineLock.unlock();</span>
 117         }
 118     }
 119 
 120     @Override
<a name="6" id="anc6"></a><span class="line-modified"> 121     public SSLEngineResult wrap(ByteBuffer[] appData,</span>
 122             int offset, int length, ByteBuffer netData) throws SSLException {
 123         return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
 124     }
 125 
 126     // @Override
<a name="7" id="anc7"></a><span class="line-modified"> 127     public SSLEngineResult wrap(</span>
 128         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 129         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 130 
<a name="8" id="anc8"></a><span class="line-modified"> 131         engineLock.lock();</span>
<span class="line-modified"> 132         try {</span>
<span class="line-modified"> 133             if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 134                 throw new IllegalStateException(</span>
<span class="line-added"> 135                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-added"> 136             }</span>
 137 
<a name="9" id="anc9"></a><span class="line-modified"> 138             // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 139             checkTaskThrown();</span>
 140 
<a name="10" id="anc10"></a><span class="line-modified"> 141             // check parameters</span>
<span class="line-modified"> 142             checkParams(srcs, srcsOffset, srcsLength,</span>
<span class="line-added"> 143                     dsts, dstsOffset, dstsLength);</span>
 144 
<a name="11" id="anc11"></a><span class="line-modified"> 145             try {</span>
<span class="line-modified"> 146                 return writeRecord(</span>
<span class="line-modified"> 147                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 148             } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 149                 // may be an unexpected handshake message</span>
<span class="line-modified"> 150                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);</span>
<span class="line-modified"> 151             } catch (IOException ioe) {</span>
<span class="line-modified"> 152                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 153                     &quot;problem wrapping app data&quot;, ioe);</span>
<span class="line-modified"> 154             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 155                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 156                     &quot;Fail to wrap application data&quot;, ex);</span>
<span class="line-added"> 157             }</span>
<span class="line-added"> 158         } finally {</span>
<span class="line-added"> 159             engineLock.unlock();</span>
 160         }
 161     }
 162 
 163     private SSLEngineResult writeRecord(
 164         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 165         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 166 
 167         // May need to deliver cached records.
 168         if (isOutboundDone()) {
 169             return new SSLEngineResult(
 170                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 171         }
 172 
 173         HandshakeContext hc = conContext.handshakeContext;
 174         HandshakeStatus hsStatus = null;
 175         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 176                 !conContext.isInboundClosed() &amp;&amp;
 177                 !conContext.isOutboundClosed()) {
 178             conContext.kickstart();
 179 
 180             hsStatus = getHandshakeStatus();
 181             if (hsStatus == HandshakeStatus.NEED_UNWRAP) {
 182                 /*
 183                  * For DTLS, if the handshake state is
 184                  * HandshakeStatus.NEED_UNWRAP, a call to SSLEngine.wrap()
 185                  * means that the previous handshake packets (if delivered)
 186                  * get lost, and need retransmit the handshake messages.
 187                  */
 188                 if (!sslContext.isDTLS() || hc == null ||
 189                         !hc.sslConfig.enableRetransmissions ||
 190                         conContext.outputRecord.firstMessage) {
 191 
 192                     return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 193                 }   // otherwise, need retransmission
 194             }
 195         }
 196 
 197         if (hsStatus == null) {
 198             hsStatus = getHandshakeStatus();
 199         }
 200 
 201         /*
 202          * If we have a task outstanding, this *MUST* be done before
 203          * doing any more wrapping, because we could be in the middle
 204          * of receiving a handshake message, for example, a finished
 205          * message which would change the ciphers.
 206          */
 207         if (hsStatus == HandshakeStatus.NEED_TASK) {
 208             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 209         }
 210 
 211         int dstsRemains = 0;
 212         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 213             dstsRemains += dsts[i].remaining();
 214         }
 215 
 216         // Check destination buffer size.
 217         //
 218         // We can be smarter about using smaller buffer sizes later.  For
 219         // now, force it to be large enough to handle any valid record.
 220         if (dstsRemains &lt; conContext.conSession.getPacketBufferSize()) {
 221             return new SSLEngineResult(
 222                 Status.BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);
 223         }
 224 
 225         int srcsRemains = 0;
 226         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 227             srcsRemains += srcs[i].remaining();
 228         }
 229 
 230         Ciphertext ciphertext = null;
 231         try {
 232             // Acquire the buffered to-be-delivered records or retransmissions.
 233             //
 234             // May have buffered records, or need retransmission if handshaking.
 235             if (!conContext.outputRecord.isEmpty() || (hc != null &amp;&amp;
 236                     hc.sslConfig.enableRetransmissions &amp;&amp;
 237                     hc.sslContext.isDTLS() &amp;&amp;
 238                     hsStatus == HandshakeStatus.NEED_UNWRAP)) {
 239                 ciphertext = encode(null, 0, 0,
 240                         dsts, dstsOffset, dstsLength);
 241             }
 242 
 243             if (ciphertext == null &amp;&amp; srcsRemains != 0) {
 244                 ciphertext = encode(srcs, srcsOffset, srcsLength,
 245                         dsts, dstsOffset, dstsLength);
 246             }
 247         } catch (IOException ioe) {
 248             if (ioe instanceof SSLException) {
 249                 throw ioe;
 250             } else {
 251                 throw new SSLException(&quot;Write problems&quot;, ioe);
 252             }
 253         }
 254 
 255         /*
 256          * Check for status.
 257          */
 258         Status status = (isOutboundDone() ? Status.CLOSED : Status.OK);
 259         if (ciphertext != null &amp;&amp; ciphertext.handshakeStatus != null) {
 260             hsStatus = ciphertext.handshakeStatus;
 261         } else {
 262             hsStatus = getHandshakeStatus();
 263             if (ciphertext == null &amp;&amp; !conContext.isNegotiated &amp;&amp;
 264                     conContext.isInboundClosed() &amp;&amp;
 265                     hsStatus == HandshakeStatus.NEED_WRAP) {
 266                 // Even the outboud is open, no futher data could be wrapped as:
 267                 //     1. the outbound is empty
 268                 //     2. no negotiated connection
 269                 //     3. the inbound has closed, cannot complete the handshake
 270                 //
 271                 // Mark the engine as closed if the handshake status is
 272                 // NEED_WRAP. Otherwise, it could lead to dead loops in
 273                 // applications.
 274                 status = Status.CLOSED;
 275             }
 276         }
 277 
 278         int deltaSrcs = srcsRemains;
 279         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 280             deltaSrcs -= srcs[i].remaining();
 281         }
 282 
 283         int deltaDsts = dstsRemains;
 284         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 285             deltaDsts -= dsts[i].remaining();
 286         }
 287 
 288         return new SSLEngineResult(status, hsStatus, deltaSrcs, deltaDsts,
 289                 ciphertext != null ? ciphertext.recordSN : -1L);
 290     }
 291 
 292     private Ciphertext encode(
 293         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 294         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 295 
 296         Ciphertext ciphertext = null;
 297         try {
 298             ciphertext = conContext.outputRecord.encode(
 299                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 300         } catch (SSLHandshakeException she) {
 301             // may be record sequence number overflow
 302             throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
 303         } catch (IOException e) {
 304             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);
 305         }
 306 
 307         if (ciphertext == null) {
 308             return null;
 309         }
 310 
 311         // Is the handshake completed?
 312         boolean needRetransmission =
 313                 conContext.sslContext.isDTLS() &amp;&amp;
 314                 conContext.handshakeContext != null &amp;&amp;
 315                 conContext.handshakeContext.sslConfig.enableRetransmissions;
 316         HandshakeStatus hsStatus =
 317                 tryToFinishHandshake(ciphertext.contentType);
 318         if (needRetransmission &amp;&amp;
 319                 hsStatus == HandshakeStatus.FINISHED &amp;&amp;
 320                 conContext.sslContext.isDTLS() &amp;&amp;
 321                 ciphertext.handshakeType == SSLHandshake.FINISHED.id) {
 322             // Retransmit the last flight for DTLS.
 323             //
 324             // The application data transactions may begin immediately
 325             // after the last flight.  If the last flight get lost, the
 326             // application data may be discarded accordingly.  As could
 327             // be an issue for some applications.  This impact can be
 328             // mitigated by sending the last fligth twice.
 329             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 330                 SSLLogger.finest(&quot;retransmit the last flight messages&quot;);
 331             }
 332 
 333             conContext.outputRecord.launchRetransmission();
 334             hsStatus = HandshakeStatus.NEED_WRAP;
 335         }
 336 
 337         if (hsStatus == null) {
 338             hsStatus = conContext.getHandshakeStatus();
 339         }
 340 
 341         // Is the sequence number is nearly overflow?
 342         if (conContext.outputRecord.seqNumIsHuge() ||
 343                 conContext.outputRecord.writeCipher.atKeyLimit()) {
 344             hsStatus = tryKeyUpdate(hsStatus);
 345         }
 346 
<a name="12" id="anc12"></a><span class="line-added"> 347         // Check if NewSessionTicket PostHandshake message needs to be sent</span>
<span class="line-added"> 348         if (conContext.conSession.updateNST &amp;&amp;</span>
<span class="line-added"> 349                 !conContext.sslConfig.isClientMode) {</span>
<span class="line-added"> 350             hsStatus = tryNewSessionTicket(hsStatus);</span>
<span class="line-added"> 351         }</span>
<span class="line-added"> 352 </span>
 353         // update context status
 354         ciphertext.handshakeStatus = hsStatus;
 355 
 356         return ciphertext;
 357     }
 358 
 359     private HandshakeStatus tryToFinishHandshake(byte contentType) {
 360         HandshakeStatus hsStatus = null;
 361         if ((contentType == ContentType.HANDSHAKE.id) &amp;&amp;
 362                 conContext.outputRecord.isEmpty()) {
 363             if (conContext.handshakeContext == null) {
 364                 hsStatus = HandshakeStatus.FINISHED;
 365             } else if (conContext.isPostHandshakeContext()) {
 366                 // unlikely, but just in case.
 367                 hsStatus = conContext.finishPostHandshake();
 368             } else if (conContext.handshakeContext.handshakeFinished) {
 369                 hsStatus = conContext.finishHandshake();
 370             }
 371         }   // Otherwise, the followed call to getHSStatus() will help.
 372 
 373         return hsStatus;
 374     }
 375 
 376     /**
 377      * Try key update for sequence number wrap or key usage limit.
 378      *
 379      * Note that in order to maintain the handshake status properly, we check
 380      * the sequence number and key usage limit after the last record
 381      * reading/writing process.
 382      *
 383      * As we request renegotiation or close the connection for wrapped sequence
 384      * number when there is enough sequence number space left to handle a few
 385      * more records, so the sequence number of the last record cannot be
 386      * wrapped.
 387      */
 388     private HandshakeStatus tryKeyUpdate(
 389             HandshakeStatus currentHandshakeStatus) throws IOException {
 390         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 391         // connection is not duplex-open.
 392         if ((conContext.handshakeContext == null) &amp;&amp;
 393                 !conContext.isOutboundClosed() &amp;&amp;
 394                 !conContext.isInboundClosed() &amp;&amp;
 395                 !conContext.isBroken) {
 396             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 397                 SSLLogger.finest(&quot;trigger key update&quot;);
 398             }
 399             beginHandshake();
 400             return conContext.getHandshakeStatus();
 401         }
 402 
 403         return currentHandshakeStatus;
 404     }
 405 
<a name="13" id="anc13"></a><span class="line-added"> 406     // Try to generate a PostHandshake NewSessionTicket message.  This is</span>
<span class="line-added"> 407     // TLS 1.3 only.</span>
<span class="line-added"> 408     private HandshakeStatus tryNewSessionTicket(</span>
<span class="line-added"> 409             HandshakeStatus currentHandshakeStatus) throws IOException {</span>
<span class="line-added"> 410         // Don&#39;t bother to kickstart if handshaking is in progress, or if the</span>
<span class="line-added"> 411         // connection is not duplex-open.</span>
<span class="line-added"> 412         if ((conContext.handshakeContext == null) &amp;&amp;</span>
<span class="line-added"> 413                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added"> 414                 !conContext.isOutboundClosed() &amp;&amp;</span>
<span class="line-added"> 415                 !conContext.isInboundClosed() &amp;&amp;</span>
<span class="line-added"> 416                 !conContext.isBroken) {</span>
<span class="line-added"> 417             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added"> 418                 SSLLogger.finest(&quot;trigger NST&quot;);</span>
<span class="line-added"> 419             }</span>
<span class="line-added"> 420             conContext.conSession.updateNST = false;</span>
<span class="line-added"> 421             NewSessionTicket.kickstartProducer.produce(</span>
<span class="line-added"> 422                     new PostHandshakeContext(conContext));</span>
<span class="line-added"> 423             return conContext.getHandshakeStatus();</span>
<span class="line-added"> 424         }</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426         return currentHandshakeStatus;</span>
<span class="line-added"> 427     }</span>
<span class="line-added"> 428 </span>
 429     private static void checkParams(
 430             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 431             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 432 
 433         if ((srcs == null) || (dsts == null)) {
 434             throw new IllegalArgumentException(
 435                     &quot;source or destination buffer is null&quot;);
 436         }
 437 
 438         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 439                 (dstsOffset &gt; dsts.length - dstsLength)) {
 440             throw new IndexOutOfBoundsException(
 441                     &quot;index out of bound of the destination buffers&quot;);
 442         }
 443 
 444         if ((srcsOffset &lt; 0) || (srcsLength &lt; 0) ||
 445                 (srcsOffset &gt; srcs.length - srcsLength)) {
 446             throw new IndexOutOfBoundsException(
 447                     &quot;index out of bound of the source buffers&quot;);
 448         }
 449 
 450         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 451             if (dsts[i] == null) {
 452                 throw new IllegalArgumentException(
 453                         &quot;destination buffer[&quot; + i + &quot;] == null&quot;);
 454             }
 455 
 456             /*
 457              * Make sure the destination bufffers are writable.
 458              */
 459             if (dsts[i].isReadOnly()) {
 460                 throw new ReadOnlyBufferException();
 461             }
 462         }
 463 
 464         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 465             if (srcs[i] == null) {
 466                 throw new IllegalArgumentException(
 467                         &quot;source buffer[&quot; + i + &quot;] == null&quot;);
 468             }
 469         }
 470     }
 471 
 472     @Override
<a name="14" id="anc14"></a><span class="line-modified"> 473     public SSLEngineResult unwrap(ByteBuffer src,</span>
 474             ByteBuffer[] dsts, int offset, int length) throws SSLException {
 475         return unwrap(
 476                 new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
 477     }
 478 
 479     // @Override
<a name="15" id="anc15"></a><span class="line-modified"> 480     public SSLEngineResult unwrap(</span>
 481         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 482         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 483 
<a name="16" id="anc16"></a><span class="line-modified"> 484         engineLock.lock();</span>
<span class="line-modified"> 485         try {</span>
<span class="line-modified"> 486             if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 487                 throw new IllegalStateException(</span>
<span class="line-added"> 488                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-added"> 489             }</span>
 490 
<a name="17" id="anc17"></a><span class="line-modified"> 491             // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 492             checkTaskThrown();</span>
 493 
<a name="18" id="anc18"></a><span class="line-modified"> 494             // check parameters</span>
<span class="line-modified"> 495             checkParams(srcs, srcsOffset, srcsLength,</span>
<span class="line-added"> 496                     dsts, dstsOffset, dstsLength);</span>
 497 
<a name="19" id="anc19"></a><span class="line-modified"> 498             try {</span>
<span class="line-modified"> 499                 return readRecord(</span>
<span class="line-modified"> 500                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 501             } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 502                 // may be an unexpected handshake message</span>
<span class="line-modified"> 503                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified"> 504                         spe.getMessage(), spe);</span>
<span class="line-modified"> 505             } catch (IOException ioe) {</span>
<span class="line-modified"> 506                 /*</span>
<span class="line-modified"> 507                  * Don&#39;t reset position so it looks like we didn&#39;t</span>
<span class="line-modified"> 508                  * consume anything.  We did consume something, and it</span>
<span class="line-modified"> 509                  * got us into this situation, so report that much back.</span>
<span class="line-modified"> 510                  * Our days of consuming are now over anyway.</span>
<span class="line-modified"> 511                  */</span>
<span class="line-modified"> 512                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 513                         &quot;problem unwrapping net record&quot;, ioe);</span>
<span class="line-modified"> 514             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 515                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 516                     &quot;Fail to unwrap network record&quot;, ex);</span>
<span class="line-added"> 517             }</span>
<span class="line-added"> 518         } finally {</span>
<span class="line-added"> 519             engineLock.unlock();</span>
 520         }
 521     }
 522 
 523     private SSLEngineResult readRecord(
 524         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 525         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 526 
 527         /*
 528          * Check if we are closing/closed.
 529          */
 530         if (isInboundDone()) {
 531             return new SSLEngineResult(
 532                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 533         }
 534 
 535         HandshakeStatus hsStatus = null;
 536         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 537                 !conContext.isInboundClosed() &amp;&amp;
 538                 !conContext.isOutboundClosed()) {
 539             conContext.kickstart();
 540 
 541             /*
 542              * If there&#39;s still outbound data to flush, we
 543              * can return without trying to unwrap anything.
 544              */
 545             hsStatus = getHandshakeStatus();
 546             if (hsStatus == HandshakeStatus.NEED_WRAP) {
 547                 return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 548             }
 549         }
 550 
 551         if (hsStatus == null) {
 552             hsStatus = getHandshakeStatus();
 553         }
 554 
 555         /*
 556          * If we have a task outstanding, this *MUST* be done before
 557          * doing any more unwrapping, because we could be in the middle
 558          * of receiving a handshake message, for example, a finished
 559          * message which would change the ciphers.
 560          */
 561         if (hsStatus == HandshakeStatus.NEED_TASK) {
 562             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 563         }
 564 
 565         if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
 566             Plaintext plainText = null;
 567             try {
 568                 plainText = decode(null, 0, 0,
 569                         dsts, dstsOffset, dstsLength);
 570             } catch (IOException ioe) {
 571                 if (ioe instanceof SSLException) {
 572                     throw ioe;
 573                 } else {
 574                     throw new SSLException(&quot;readRecord&quot;, ioe);
 575                 }
 576             }
 577 
 578             Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 579             if (plainText.handshakeStatus != null) {
 580                 hsStatus = plainText.handshakeStatus;
 581             } else {
 582                 hsStatus = getHandshakeStatus();
 583             }
 584 
 585             return new SSLEngineResult(
 586                     status, hsStatus, 0, 0, plainText.recordSN);
 587         }
 588 
 589         int srcsRemains = 0;
 590         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 591             srcsRemains += srcs[i].remaining();
 592         }
 593 
 594         if (srcsRemains == 0) {
 595             return new SSLEngineResult(
 596                 Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 597         }
 598 
 599         /*
 600          * Check the packet to make sure enough is here.
 601          * This will also indirectly check for 0 len packets.
 602          */
 603         int packetLen = 0;
 604         try {
 605             packetLen = conContext.inputRecord.bytesInCompletePacket(
 606                     srcs, srcsOffset, srcsLength);
 607         } catch (SSLException ssle) {
 608             // Need to discard invalid records for DTLS protocols.
 609             if (sslContext.isDTLS()) {
 610                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 611                     SSLLogger.finest(&quot;Discard invalid DTLS records&quot;, ssle);
 612                 }
 613 
 614                 // invalid, discard the entire data [section 4.1.2.7, RFC 6347]
 615                 int deltaNet = 0;
 616                 // int deltaNet = netData.remaining();
 617                 // netData.position(netData.limit());
 618 
 619                 Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 620                 if (hsStatus == null) {
 621                     hsStatus = getHandshakeStatus();
 622                 }
 623 
 624                 return new SSLEngineResult(status, hsStatus, deltaNet, 0, -1L);
 625             } else {
 626                 throw ssle;
 627             }
 628         }
 629 
 630         // Is this packet bigger than SSL/TLS normally allows?
 631         if (packetLen &gt; conContext.conSession.getPacketBufferSize()) {
 632             int largestRecordSize = sslContext.isDTLS() ?
 633                     DTLSRecord.maxRecordSize : SSLRecord.maxLargeRecordSize;
 634             if ((packetLen &lt;= largestRecordSize) &amp;&amp; !sslContext.isDTLS()) {
 635                 // Expand the expected maximum packet/application buffer
 636                 // sizes.
 637                 //
 638                 // Only apply to SSL/TLS protocols.
 639 
 640                 // Old behavior: shall we honor the System Property
 641                 // &quot;jsse.SSLEngine.acceptLargeFragments&quot; if it is &quot;false&quot;?
 642                 conContext.conSession.expandBufferSizes();
 643             }
 644 
 645             // check the packet again
 646             largestRecordSize = conContext.conSession.getPacketBufferSize();
 647             if (packetLen &gt; largestRecordSize) {
 648                 throw new SSLProtocolException(
 649                         &quot;Input record too big: max = &quot; +
 650                         largestRecordSize + &quot; len = &quot; + packetLen);
 651             }
 652         }
 653 
 654         /*
 655          * Check for OVERFLOW.
 656          *
 657          * Delay enforcing the application buffer free space requirement
 658          * until after the initial handshaking.
 659          */
 660         int dstsRemains = 0;
 661         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 662             dstsRemains += dsts[i].remaining();
 663         }
 664 
 665         if (conContext.isNegotiated) {
 666             int FragLen =
 667                     conContext.inputRecord.estimateFragmentSize(packetLen);
 668             if (FragLen &gt; dstsRemains) {
 669                 return new SSLEngineResult(
 670                         Status.BUFFER_OVERFLOW, hsStatus, 0, 0);
 671             }
 672         }
 673 
 674         // check for UNDERFLOW.
 675         if ((packetLen == -1) || (srcsRemains &lt; packetLen)) {
 676             return new SSLEngineResult(Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 677         }
 678 
 679         /*
 680          * We&#39;re now ready to actually do the read.
 681          */
 682         Plaintext plainText = null;
 683         try {
 684             plainText = decode(srcs, srcsOffset, srcsLength,
 685                             dsts, dstsOffset, dstsLength);
 686         } catch (IOException ioe) {
 687             if (ioe instanceof SSLException) {
 688                 throw ioe;
 689             } else {
 690                 throw new SSLException(&quot;readRecord&quot;, ioe);
 691             }
 692         }
 693 
 694         /*
 695          * Check the various condition that we could be reporting.
 696          *
 697          * It&#39;s *possible* something might have happened between the
 698          * above and now, but it was better to minimally lock &quot;this&quot;
 699          * during the read process.  We&#39;ll return the current
 700          * status, which is more representative of the current state.
 701          *
 702          * status above should cover:  FINISHED, NEED_TASK
 703          */
 704         Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 705         if (plainText.handshakeStatus != null) {
 706             hsStatus = plainText.handshakeStatus;
 707         } else {
 708             hsStatus = getHandshakeStatus();
 709         }
 710 
 711         int deltaNet = srcsRemains;
 712         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 713             deltaNet -= srcs[i].remaining();
 714         }
 715 
 716         int deltaApp = dstsRemains;
 717         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 718             deltaApp -= dsts[i].remaining();
 719         }
 720 
 721         return new SSLEngineResult(
 722                 status, hsStatus, deltaNet, deltaApp, plainText.recordSN);
 723     }
 724 
 725     private Plaintext decode(
 726         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 727         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 728 
 729         Plaintext pt = SSLTransport.decode(conContext,
 730                             srcs, srcsOffset, srcsLength,
 731                             dsts, dstsOffset, dstsLength);
 732 
 733         // Is the handshake completed?
 734         if (pt != Plaintext.PLAINTEXT_NULL) {
 735             HandshakeStatus hsStatus = tryToFinishHandshake(pt.contentType);
 736             if (hsStatus == null) {
 737                 pt.handshakeStatus = conContext.getHandshakeStatus();
 738             } else {
 739                 pt.handshakeStatus = hsStatus;
 740             }
 741 
 742             // Is the sequence number is nearly overflow?
 743             if (conContext.inputRecord.seqNumIsHuge() ||
 744                     conContext.inputRecord.readCipher.atKeyLimit()) {
 745                 pt.handshakeStatus =
 746                         tryKeyUpdate(pt.handshakeStatus);
 747             }
 748         }
 749 
 750         return pt;
 751     }
 752 
 753     @Override
<a name="20" id="anc20"></a><span class="line-modified"> 754     public Runnable getDelegatedTask() {</span>
<span class="line-modified"> 755         engineLock.lock();</span>
<span class="line-modified"> 756         try {</span>
<span class="line-modified"> 757             if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake</span>
<span class="line-modified"> 758                     !conContext.handshakeContext.taskDelegated &amp;&amp;</span>
<span class="line-modified"> 759                     !conContext.handshakeContext.delegatedActions.isEmpty()) {</span>
<span class="line-added"> 760                 conContext.handshakeContext.taskDelegated = true;</span>
<span class="line-added"> 761                 return new DelegatedTask(this);</span>
<span class="line-added"> 762             }</span>
<span class="line-added"> 763         } finally {</span>
<span class="line-added"> 764             engineLock.unlock();</span>
 765         }
 766 
 767         return null;
 768     }
 769 
 770     @Override
<a name="21" id="anc21"></a><span class="line-modified"> 771     public void closeInbound() throws SSLException {</span>
<span class="line-modified"> 772         engineLock.lock();</span>
<span class="line-modified"> 773         try {</span>
<span class="line-modified"> 774             if (isInboundDone()) {</span>
<span class="line-added"> 775                 return;</span>
<span class="line-added"> 776             }</span>
 777 
<a name="22" id="anc22"></a><span class="line-modified"> 778             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 779                 SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);</span>
<span class="line-modified"> 780             }</span>
 781 
<a name="23" id="anc23"></a><span class="line-modified"> 782             // Is it ready to close inbound?</span>
<span class="line-modified"> 783             //</span>
<span class="line-modified"> 784             // No exception if the initial handshake is not started.</span>
<span class="line-modified"> 785             if (!conContext.isInputCloseNotified &amp;&amp;</span>
<span class="line-modified"> 786                 (conContext.isNegotiated ||</span>
<span class="line-added"> 787                     conContext.handshakeContext != null)) {</span>
 788 
<a name="24" id="anc24"></a><span class="line-modified"> 789                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 790                         &quot;closing inbound before receiving peer&#39;s close_notify&quot;);</span>
<span class="line-modified"> 791             }</span>
 792 
<a name="25" id="anc25"></a><span class="line-modified"> 793             conContext.closeInbound();</span>
<span class="line-added"> 794         } finally {</span>
<span class="line-added"> 795             engineLock.unlock();</span>
<span class="line-added"> 796         }</span>
 797     }
 798 
 799     @Override
<a name="26" id="anc26"></a><span class="line-modified"> 800     public boolean isInboundDone() {</span>
<span class="line-modified"> 801         engineLock.lock();</span>
<span class="line-added"> 802         try {</span>
<span class="line-added"> 803             return conContext.isInboundClosed();</span>
<span class="line-added"> 804         } finally {</span>
<span class="line-added"> 805             engineLock.unlock();</span>
<span class="line-added"> 806         }</span>
 807     }
 808 
 809     @Override
<a name="27" id="anc27"></a><span class="line-modified"> 810     public void closeOutbound() {</span>
<span class="line-modified"> 811         engineLock.lock();</span>
<span class="line-modified"> 812         try {</span>
<span class="line-modified"> 813             if (conContext.isOutboundClosed()) {</span>
<span class="line-added"> 814                 return;</span>
<span class="line-added"> 815             }</span>
 816 
<a name="28" id="anc28"></a><span class="line-modified"> 817             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 818                 SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);</span>
<span class="line-modified"> 819             }</span>
 820 
<a name="29" id="anc29"></a><span class="line-modified"> 821             conContext.closeOutbound();</span>
<span class="line-added"> 822         } finally {</span>
<span class="line-added"> 823             engineLock.unlock();</span>
<span class="line-added"> 824         }</span>
 825     }
 826 
 827     @Override
<a name="30" id="anc30"></a><span class="line-modified"> 828     public boolean isOutboundDone() {</span>
<span class="line-modified"> 829         engineLock.lock();</span>
<span class="line-added"> 830         try {</span>
<span class="line-added"> 831             return conContext.isOutboundDone();</span>
<span class="line-added"> 832         } finally {</span>
<span class="line-added"> 833             engineLock.unlock();</span>
<span class="line-added"> 834         }</span>
 835     }
 836 
 837     @Override
 838     public String[] getSupportedCipherSuites() {
 839         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 840     }
 841 
 842     @Override
<a name="31" id="anc31"></a><span class="line-modified"> 843     public String[] getEnabledCipherSuites() {</span>
<span class="line-modified"> 844         engineLock.lock();</span>
<span class="line-added"> 845         try {</span>
<span class="line-added"> 846             return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>
<span class="line-added"> 847         } finally {</span>
<span class="line-added"> 848             engineLock.unlock();</span>
<span class="line-added"> 849         }</span>
 850     }
 851 
 852     @Override
<a name="32" id="anc32"></a><span class="line-modified"> 853     public void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified"> 854         engineLock.lock();</span>
<span class="line-modified"> 855         try {</span>
<span class="line-added"> 856             conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-added"> 857                     CipherSuite.validValuesOf(suites);</span>
<span class="line-added"> 858         } finally {</span>
<span class="line-added"> 859             engineLock.unlock();</span>
<span class="line-added"> 860         }</span>
 861     }
 862 
 863     @Override
 864     public String[] getSupportedProtocols() {
 865         return ProtocolVersion.toStringArray(
 866                 sslContext.getSupportedProtocolVersions());
 867     }
 868 
 869     @Override
<a name="33" id="anc33"></a><span class="line-modified"> 870     public String[] getEnabledProtocols() {</span>
<span class="line-modified"> 871         engineLock.lock();</span>
<span class="line-modified"> 872         try {</span>
<span class="line-added"> 873             return ProtocolVersion.toStringArray(</span>
<span class="line-added"> 874                     conContext.sslConfig.enabledProtocols);</span>
<span class="line-added"> 875         } finally {</span>
<span class="line-added"> 876             engineLock.unlock();</span>
<span class="line-added"> 877         }</span>
 878     }
 879 
 880     @Override
<a name="34" id="anc34"></a><span class="line-modified"> 881     public void setEnabledProtocols(String[] protocols) {</span>
<span class="line-modified"> 882         engineLock.lock();</span>
<span class="line-modified"> 883         try {</span>
<span class="line-modified"> 884             if (protocols == null) {</span>
<span class="line-added"> 885                 throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);</span>
<span class="line-added"> 886             }</span>
 887 
<a name="35" id="anc35"></a><span class="line-modified"> 888             conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified"> 889                     ProtocolVersion.namesOf(protocols);</span>
<span class="line-added"> 890         } finally {</span>
<span class="line-added"> 891             engineLock.unlock();</span>
<span class="line-added"> 892         }</span>
 893     }
 894 
 895     @Override
<a name="36" id="anc36"></a><span class="line-modified"> 896     public SSLSession getSession() {</span>
<span class="line-modified"> 897         engineLock.lock();</span>
<span class="line-added"> 898         try {</span>
<span class="line-added"> 899             return conContext.conSession;</span>
<span class="line-added"> 900         } finally {</span>
<span class="line-added"> 901             engineLock.unlock();</span>
<span class="line-added"> 902         }</span>
 903     }
 904 
 905     @Override
<a name="37" id="anc37"></a><span class="line-modified"> 906     public SSLSession getHandshakeSession() {</span>
<span class="line-modified"> 907         engineLock.lock();</span>
<span class="line-modified"> 908         try {</span>
<span class="line-added"> 909             return conContext.handshakeContext == null ?</span>
<span class="line-added"> 910                     null : conContext.handshakeContext.handshakeSession;</span>
<span class="line-added"> 911         } finally {</span>
<span class="line-added"> 912             engineLock.unlock();</span>
<span class="line-added"> 913         }</span>
 914     }
 915 
 916     @Override
<a name="38" id="anc38"></a><span class="line-modified"> 917     public SSLEngineResult.HandshakeStatus getHandshakeStatus() {</span>
<span class="line-modified"> 918         engineLock.lock();</span>
<span class="line-added"> 919         try {</span>
<span class="line-added"> 920             return conContext.getHandshakeStatus();</span>
<span class="line-added"> 921         } finally {</span>
<span class="line-added"> 922             engineLock.unlock();</span>
<span class="line-added"> 923         }</span>
 924     }
 925 
 926     @Override
<a name="39" id="anc39"></a><span class="line-modified"> 927     public void setUseClientMode(boolean mode) {</span>
<span class="line-modified"> 928         engineLock.lock();</span>
<span class="line-added"> 929         try {</span>
<span class="line-added"> 930             conContext.setUseClientMode(mode);</span>
<span class="line-added"> 931         } finally {</span>
<span class="line-added"> 932             engineLock.unlock();</span>
<span class="line-added"> 933         }</span>
 934     }
 935 
 936     @Override
<a name="40" id="anc40"></a><span class="line-modified"> 937     public boolean getUseClientMode() {</span>
<span class="line-modified"> 938         engineLock.lock();</span>
<span class="line-added"> 939         try {</span>
<span class="line-added"> 940             return conContext.sslConfig.isClientMode;</span>
<span class="line-added"> 941         } finally {</span>
<span class="line-added"> 942             engineLock.unlock();</span>
<span class="line-added"> 943         }</span>
 944     }
 945 
 946     @Override
<a name="41" id="anc41"></a><span class="line-modified"> 947     public void setNeedClientAuth(boolean need) {</span>
<span class="line-modified"> 948         engineLock.lock();</span>
<span class="line-modified"> 949         try {</span>
<span class="line-modified"> 950             conContext.sslConfig.clientAuthType =</span>
<span class="line-added"> 951                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-added"> 952                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added"> 953         } finally {</span>
<span class="line-added"> 954             engineLock.unlock();</span>
<span class="line-added"> 955         }</span>
 956     }
 957 
 958     @Override
<a name="42" id="anc42"></a><span class="line-modified"> 959     public boolean getNeedClientAuth() {</span>
<span class="line-modified"> 960         engineLock.lock();</span>
<span class="line-modified"> 961         try {</span>
<span class="line-added"> 962             return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-added"> 963                             ClientAuthType.CLIENT_AUTH_REQUIRED);</span>
<span class="line-added"> 964         } finally {</span>
<span class="line-added"> 965             engineLock.unlock();</span>
<span class="line-added"> 966         }</span>
 967     }
 968 
 969     @Override
<a name="43" id="anc43"></a><span class="line-modified"> 970     public void setWantClientAuth(boolean want) {</span>
<span class="line-modified"> 971         engineLock.lock();</span>
<span class="line-modified"> 972         try {</span>
<span class="line-modified"> 973             conContext.sslConfig.clientAuthType =</span>
<span class="line-added"> 974                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-added"> 975                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added"> 976         } finally {</span>
<span class="line-added"> 977             engineLock.unlock();</span>
<span class="line-added"> 978         }</span>
 979     }
 980 
 981     @Override
<a name="44" id="anc44"></a><span class="line-modified"> 982     public boolean getWantClientAuth() {</span>
<span class="line-modified"> 983         engineLock.lock();</span>
<span class="line-modified"> 984         try {</span>
<span class="line-added"> 985             return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-added"> 986                             ClientAuthType.CLIENT_AUTH_REQUESTED);</span>
<span class="line-added"> 987         } finally {</span>
<span class="line-added"> 988             engineLock.unlock();</span>
<span class="line-added"> 989         }</span>
 990     }
 991 
 992     @Override
<a name="45" id="anc45"></a><span class="line-modified"> 993     public void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified"> 994         engineLock.lock();</span>
<span class="line-added"> 995         try {</span>
<span class="line-added"> 996             conContext.sslConfig.enableSessionCreation = flag;</span>
<span class="line-added"> 997         } finally {</span>
<span class="line-added"> 998             engineLock.unlock();</span>
<span class="line-added"> 999         }</span>
1000     }
1001 
1002     @Override
<a name="46" id="anc46"></a><span class="line-modified">1003     public boolean getEnableSessionCreation() {</span>
<span class="line-modified">1004         engineLock.lock();</span>
<span class="line-added">1005         try {</span>
<span class="line-added">1006             return conContext.sslConfig.enableSessionCreation;</span>
<span class="line-added">1007         } finally {</span>
<span class="line-added">1008             engineLock.unlock();</span>
<span class="line-added">1009         }</span>
1010     }
1011 
1012     @Override
<a name="47" id="anc47"></a><span class="line-modified">1013     public SSLParameters getSSLParameters() {</span>
<span class="line-modified">1014         engineLock.lock();</span>
<span class="line-modified">1015         try {</span>
<span class="line-added">1016             return conContext.sslConfig.getSSLParameters();</span>
<span class="line-added">1017         } finally {</span>
<span class="line-added">1018             engineLock.unlock();</span>
<span class="line-added">1019         }</span>
<span class="line-added">1020    }</span>
1021 
1022     @Override
<a name="48" id="anc48"></a><span class="line-modified">1023     public void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">1024         engineLock.lock();</span>
<span class="line-added">1025         try {</span>
<span class="line-added">1026             conContext.sslConfig.setSSLParameters(params);</span>
1027 
<a name="49" id="anc49"></a><span class="line-modified">1028             if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">1029                 conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">1030                         conContext.sslConfig.maximumPacketSize);</span>
<span class="line-added">1031             }</span>
<span class="line-added">1032         } finally {</span>
<span class="line-added">1033             engineLock.unlock();</span>
1034         }
<a name="50" id="anc50"></a><span class="line-modified">1035    }</span>
1036 
1037     @Override
<a name="51" id="anc51"></a><span class="line-modified">1038     public String getApplicationProtocol() {</span>
<span class="line-modified">1039         engineLock.lock();</span>
<span class="line-added">1040         try {</span>
<span class="line-added">1041             return conContext.applicationProtocol;</span>
<span class="line-added">1042         } finally {</span>
<span class="line-added">1043             engineLock.unlock();</span>
<span class="line-added">1044         }</span>
1045     }
1046 
1047     @Override
<a name="52" id="anc52"></a><span class="line-modified">1048     public String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">1049         engineLock.lock();</span>
<span class="line-modified">1050         try {</span>
<span class="line-added">1051             return conContext.handshakeContext == null ?</span>
<span class="line-added">1052                     null : conContext.handshakeContext.applicationProtocol;</span>
<span class="line-added">1053         } finally {</span>
<span class="line-added">1054             engineLock.unlock();</span>
<span class="line-added">1055         }</span>
1056     }
1057 
1058     @Override
<a name="53" id="anc53"></a><span class="line-modified">1059     public void setHandshakeApplicationProtocolSelector(</span>
1060             BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
<a name="54" id="anc54"></a><span class="line-modified">1061         engineLock.lock();</span>
<span class="line-added">1062         try {</span>
<span class="line-added">1063             conContext.sslConfig.engineAPSelector = selector;</span>
<span class="line-added">1064         } finally {</span>
<span class="line-added">1065             engineLock.unlock();</span>
<span class="line-added">1066         }</span>
1067     }
1068 
1069     @Override
<a name="55" id="anc55"></a><span class="line-modified">1070     public BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;</span>
1071             getHandshakeApplicationProtocolSelector() {
<a name="56" id="anc56"></a><span class="line-modified">1072         engineLock.lock();</span>
<span class="line-added">1073         try {</span>
<span class="line-added">1074             return conContext.sslConfig.engineAPSelector;</span>
<span class="line-added">1075         } finally {</span>
<span class="line-added">1076             engineLock.unlock();</span>
<span class="line-added">1077         }</span>
1078     }
1079 
1080     @Override
1081     public boolean useDelegatedTask() {
1082         return true;
1083     }
1084 
1085     /*
1086      * Depending on whether the error was just a warning and the
1087      * handshaker wasn&#39;t closed, or fatal and the handshaker is now
1088      * null, report back the Exception that happened in the delegated
1089      * task(s).
1090      */
<a name="57" id="anc57"></a><span class="line-modified">1091     private void checkTaskThrown() throws SSLException {</span>
1092 
1093         Exception exc = null;
<a name="58" id="anc58"></a><span class="line-added">1094         engineLock.lock();</span>
<span class="line-added">1095         try {</span>
<span class="line-added">1096             // First check the handshake context.</span>
<span class="line-added">1097             HandshakeContext hc = conContext.handshakeContext;</span>
<span class="line-added">1098             if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {</span>
<span class="line-added">1099                 exc = hc.delegatedThrown;</span>
<span class="line-added">1100                 hc.delegatedThrown = null;</span>
<span class="line-added">1101             }</span>
1102 
<a name="59" id="anc59"></a><span class="line-modified">1103             /*</span>
<span class="line-modified">1104              * hc.delegatedThrown and conContext.delegatedThrown are most</span>
<span class="line-modified">1105              * likely the same, but it&#39;s possible we could have had a non-fatal</span>
<span class="line-modified">1106              * exception and thus the new HandshakeContext is still valid</span>
<span class="line-modified">1107              * (alert warning).  If so, then we may have a secondary exception</span>
<span class="line-modified">1108              * waiting to be reported from the TransportContext, so we will</span>
<span class="line-modified">1109              * need to clear that on a successive call. Otherwise, clear it now.</span>
<span class="line-modified">1110              */</span>
<span class="line-modified">1111             if (conContext.delegatedThrown != null) {</span>
<span class="line-modified">1112                 if (exc != null) {</span>
<span class="line-modified">1113                     // hc object comparison</span>
<span class="line-modified">1114                     if (conContext.delegatedThrown == exc) {</span>
<span class="line-modified">1115                         // clear if/only if both are the same</span>
<span class="line-modified">1116                         conContext.delegatedThrown = null;</span>
<span class="line-modified">1117                     } // otherwise report the hc delegatedThrown</span>
<span class="line-modified">1118                 } else {</span>
<span class="line-modified">1119                     // Nothing waiting in HandshakeContext, but one is in the</span>
<span class="line-modified">1120                     // TransportContext.</span>
<span class="line-modified">1121                     exc = conContext.delegatedThrown;</span>

1122                     conContext.delegatedThrown = null;
<a name="60" id="anc60"></a><span class="line-modified">1123                 }</span>





1124             }
<a name="61" id="anc61"></a><span class="line-added">1125         } finally {</span>
<span class="line-added">1126             engineLock.unlock();</span>
1127         }
1128 
1129         // Anything to report?
1130         if (exc == null) {
1131             return;
1132         }
1133 
1134         // If it wasn&#39;t a RuntimeException/SSLException, need to wrap it.
1135         if (exc instanceof SSLException) {
1136             throw (SSLException)exc;
1137         } else if (exc instanceof RuntimeException) {
1138             throw (RuntimeException)exc;
1139         } else {
1140             throw getTaskThrown(exc);
1141         }
1142     }
1143 
1144     private static SSLException getTaskThrown(Exception taskThrown) {
1145         String msg = taskThrown.getMessage();
1146 
1147         if (msg == null) {
1148             msg = &quot;Delegated task threw Exception or Error&quot;;
1149         }
1150 
1151         if (taskThrown instanceof RuntimeException) {
1152             throw new RuntimeException(msg, taskThrown);
1153         } else if (taskThrown instanceof SSLHandshakeException) {
1154             return (SSLHandshakeException)
1155                 new SSLHandshakeException(msg).initCause(taskThrown);
1156         } else if (taskThrown instanceof SSLKeyException) {
1157             return (SSLKeyException)
1158                 new SSLKeyException(msg).initCause(taskThrown);
1159         } else if (taskThrown instanceof SSLPeerUnverifiedException) {
1160             return (SSLPeerUnverifiedException)
1161                 new SSLPeerUnverifiedException(msg).initCause(taskThrown);
1162         } else if (taskThrown instanceof SSLProtocolException) {
1163             return (SSLProtocolException)
1164                 new SSLProtocolException(msg).initCause(taskThrown);
1165         } else if (taskThrown instanceof SSLException) {
1166             return (SSLException)taskThrown;
1167         } else {
1168             return new SSLException(msg, taskThrown);
1169         }
1170     }
1171 
1172     /**
1173      * Implement a simple task delegator.
1174      */
1175     private static class DelegatedTask implements Runnable {
1176         private final SSLEngineImpl engine;
1177 
1178         DelegatedTask(SSLEngineImpl engineInstance) {
1179             this.engine = engineInstance;
1180         }
1181 
1182         @Override
1183         public void run() {
<a name="62" id="anc62"></a><span class="line-modified">1184             engine.engineLock.lock();</span>
<span class="line-added">1185             try {</span>
1186                 HandshakeContext hc = engine.conContext.handshakeContext;
1187                 if (hc == null || hc.delegatedActions.isEmpty()) {
1188                     return;
1189                 }
1190 
1191                 try {
1192                     AccessController.doPrivileged(
1193                             new DelegatedAction(hc), engine.conContext.acc);
1194                 } catch (PrivilegedActionException pae) {
1195                     // Get the handshake context again in case the
1196                     // handshaking has completed.
1197                     Exception reportedException = pae.getException();
1198 
1199                     // Report to both the TransportContext...
1200                     if (engine.conContext.delegatedThrown == null) {
1201                         engine.conContext.delegatedThrown = reportedException;
1202                     }
1203 
1204                     // ...and the HandshakeContext in case condition
1205                     // wasn&#39;t fatal and the handshakeContext is still
1206                     // around.
1207                     hc = engine.conContext.handshakeContext;
1208                     if (hc != null) {
1209                         hc.delegatedThrown = reportedException;
1210                     } else if (engine.conContext.closeReason != null) {
1211                         // Update the reason in case there was a previous.
1212                         engine.conContext.closeReason =
1213                                 getTaskThrown(reportedException);
1214                     }
1215                 } catch (RuntimeException rte) {
1216                     // Get the handshake context again in case the
1217                     // handshaking has completed.
1218 
1219                     // Report to both the TransportContext...
1220                     if (engine.conContext.delegatedThrown == null) {
1221                         engine.conContext.delegatedThrown = rte;
1222                     }
1223 
1224                     // ...and the HandshakeContext in case condition
1225                     // wasn&#39;t fatal and the handshakeContext is still
1226                     // around.
1227                     hc = engine.conContext.handshakeContext;
1228                     if (hc != null) {
1229                         hc.delegatedThrown = rte;
1230                     } else if (engine.conContext.closeReason != null) {
1231                         // Update the reason in case there was a previous.
1232                         engine.conContext.closeReason = rte;
1233                     }
1234                 }
1235 
1236                 // Get the handshake context again in case the
1237                 // handshaking has completed.
1238                 hc = engine.conContext.handshakeContext;
1239                 if (hc != null) {
1240                     hc.taskDelegated = false;
1241                 }
<a name="63" id="anc63"></a><span class="line-added">1242             } finally {</span>
<span class="line-added">1243                 engine.engineLock.unlock();</span>
1244             }
1245         }
1246 
1247         private static class DelegatedAction
1248                 implements PrivilegedExceptionAction&lt;Void&gt; {
1249             final HandshakeContext context;
1250             DelegatedAction(HandshakeContext context) {
1251                 this.context = context;
1252             }
1253 
1254             @Override
1255             public Void run() throws Exception {
1256                 while (!context.delegatedActions.isEmpty()) {
1257                     Map.Entry&lt;Byte, ByteBuffer&gt; me =
1258                             context.delegatedActions.poll();
1259                     if (me != null) {
1260                         context.dispatch(me.getKey(), me.getValue());
1261                     }
1262                 }
1263                 return null;
1264             }
1265         }
1266     }
1267 }
<a name="64" id="anc64"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="64" type="hidden" />
</body>
</html>
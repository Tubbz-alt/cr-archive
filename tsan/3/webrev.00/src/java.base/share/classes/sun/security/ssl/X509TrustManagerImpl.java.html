<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/X509TrustManagerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.net.Socket;
 29 import java.security.*;
 30 import java.security.cert.*;
 31 import java.util.*;
 32 import java.util.concurrent.locks.ReentrantLock;
 33 import javax.net.ssl.*;
 34 import sun.security.util.AnchorCertificates;
 35 import sun.security.util.HostnameChecker;
 36 import sun.security.validator.*;
 37 
 38 /**
 39  * This class implements the SunJSSE X.509 trust manager using the internal
 40  * validator API in J2SE core. The logic in this class is minimal.&lt;p&gt;
 41  * &lt;p&gt;
 42  * This class supports both the Simple validation algorithm from previous
 43  * JSSE versions and PKIX validation. Currently, it is not possible for the
 44  * application to specify PKIX parameters other than trust anchors. This will
 45  * be fixed in a future release using new APIs. When that happens, it may also
 46  * make sense to separate the Simple and PKIX trust managers into separate
 47  * classes.
 48  *
 49  * @author Andreas Sterbenz
 50  */
 51 final class X509TrustManagerImpl extends X509ExtendedTrustManager
 52         implements X509TrustManager {
 53 
 54     private final String validatorType;
 55 
 56     /**
 57      * The Set of trusted X509Certificates.
 58      */
 59     private final Collection&lt;X509Certificate&gt; trustedCerts;
 60 
 61     private final PKIXBuilderParameters pkixParams;
 62 
 63     // note that we need separate validator for client and server due to
 64     // the different extension checks. They are initialized lazily on demand.
 65     private volatile Validator clientValidator, serverValidator;
 66 
 67     private final ReentrantLock validatorLock = new ReentrantLock();
 68 
 69     X509TrustManagerImpl(String validatorType,
 70             Collection&lt;X509Certificate&gt; trustedCerts) {
 71 
 72         this.validatorType = validatorType;
 73         this.pkixParams = null;
 74 
 75         if (trustedCerts == null) {
 76             trustedCerts = Collections.&lt;X509Certificate&gt;emptySet();
 77         }
 78 
 79         this.trustedCerts = trustedCerts;
 80 
 81         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
 82             SSLLogger.fine(&quot;adding as trusted certificates&quot;,
 83                     (Object[])trustedCerts.toArray(new X509Certificate[0]));
 84         }
 85     }
 86 
 87     X509TrustManagerImpl(String validatorType, PKIXBuilderParameters params) {
 88         this.validatorType = validatorType;
 89         this.pkixParams = params;
 90         // create server validator eagerly so that we can conveniently
 91         // get the trusted certificates
 92         // clients need it anyway eventually, and servers will not mind
 93         // the little extra footprint
 94         Validator v = getValidator(Validator.VAR_TLS_SERVER);
 95         trustedCerts = v.getTrustedCertificates();
 96         serverValidator = v;
 97 
 98         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
 99             SSLLogger.fine(&quot;adding as trusted certificates&quot;,
100                     (Object[])trustedCerts.toArray(new X509Certificate[0]));
101         }
102     }
103 
104     @Override
105     public void checkClientTrusted(X509Certificate[] chain, String authType)
106             throws CertificateException {
107         checkTrusted(chain, authType, (Socket)null, true);
108     }
109 
110     @Override
111     public void checkServerTrusted(X509Certificate[] chain, String authType)
112             throws CertificateException {
113         checkTrusted(chain, authType, (Socket)null, false);
114     }
115 
116     @Override
117     public X509Certificate[] getAcceptedIssuers() {
118         X509Certificate[] certsArray = new X509Certificate[trustedCerts.size()];
119         trustedCerts.toArray(certsArray);
120         return certsArray;
121     }
122 
123     @Override
124     public void checkClientTrusted(X509Certificate[] chain, String authType,
125                 Socket socket) throws CertificateException {
126         checkTrusted(chain, authType, socket, true);
127     }
128 
129     @Override
130     public void checkServerTrusted(X509Certificate[] chain, String authType,
131             Socket socket) throws CertificateException {
132         checkTrusted(chain, authType, socket, false);
133     }
134 
135     @Override
136     public void checkClientTrusted(X509Certificate[] chain, String authType,
137             SSLEngine engine) throws CertificateException {
138         checkTrusted(chain, authType, engine, true);
139     }
140 
141     @Override
142     public void checkServerTrusted(X509Certificate[] chain, String authType,
143             SSLEngine engine) throws CertificateException {
144         checkTrusted(chain, authType, engine, false);
145     }
146 
147     private Validator checkTrustedInit(X509Certificate[] chain,
148             String authType, boolean checkClientTrusted) {
149         if (chain == null || chain.length == 0) {
150             throw new IllegalArgumentException(
151                 &quot;null or zero-length certificate chain&quot;);
152         }
153 
154         if (authType == null || authType.isEmpty()) {
155             throw new IllegalArgumentException(
156                 &quot;null or zero-length authentication type&quot;);
157         }
158 
159         Validator v = null;
160         if (checkClientTrusted) {
161             v = clientValidator;
162             if (v == null) {
163                 validatorLock.lock();
164                 try {
165                     v = clientValidator;
166                     if (v == null) {
167                         v = getValidator(Validator.VAR_TLS_CLIENT);
168                         clientValidator = v;
169                     }
170                 } finally {
171                     validatorLock.unlock();
172                 }
173             }
174         } else {
175             // assume double checked locking with a volatile flag works
176             // (guaranteed under the new Tiger memory model)
177             v = serverValidator;
178             if (v == null) {
179                 validatorLock.lock();
180                 try {
181                     v = serverValidator;
182                     if (v == null) {
183                         v = getValidator(Validator.VAR_TLS_SERVER);
184                         serverValidator = v;
185                     }
186                 } finally {
187                     validatorLock.unlock();
188                 }
189             }
190         }
191 
192         return v;
193     }
194 
195     private void checkTrusted(X509Certificate[] chain,
196             String authType, Socket socket,
197             boolean checkClientTrusted) throws CertificateException {
198         Validator v = checkTrustedInit(chain, authType, checkClientTrusted);
199 
200         X509Certificate[] trustedChain = null;
201         if ((socket != null) &amp;&amp; socket.isConnected() &amp;&amp;
202                                         (socket instanceof SSLSocket)) {
203 
204             SSLSocket sslSocket = (SSLSocket)socket;
205             SSLSession session = sslSocket.getHandshakeSession();
206             if (session == null) {
207                 throw new CertificateException(&quot;No handshake session&quot;);
208             }
209 
210             // create the algorithm constraints
211             boolean isExtSession = (session instanceof ExtendedSSLSession);
212             AlgorithmConstraints constraints;
213             if (isExtSession &amp;&amp;
214                     ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
215                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;
216                 String[] localSupportedSignAlgs =
217                         extSession.getLocalSupportedSignatureAlgorithms();
218 
219                 constraints = new SSLAlgorithmConstraints(
220                                 sslSocket, localSupportedSignAlgs, false);
221             } else {
222                 constraints = new SSLAlgorithmConstraints(sslSocket, false);
223             }
224 
225             // Grab any stapled OCSP responses for use in validation
226             List&lt;byte[]&gt; responseList = Collections.emptyList();
227             if (!checkClientTrusted &amp;&amp; isExtSession) {
228                 responseList =
229                         ((ExtendedSSLSession)session).getStatusResponses();
230             }
231             trustedChain = v.validate(chain, null, responseList,
232                     constraints, checkClientTrusted ? null : authType);
233 
234             // check endpoint identity
235             String identityAlg = sslSocket.getSSLParameters().
236                     getEndpointIdentificationAlgorithm();
237             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
238                 checkIdentity(session,
239                         trustedChain, identityAlg, checkClientTrusted);
240             }
241         } else {
242             trustedChain = v.validate(chain, null, Collections.emptyList(),
243                     null, checkClientTrusted ? null : authType);
244         }
245 
246         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
247             SSLLogger.fine(&quot;Found trusted certificate&quot;,
248                     trustedChain[trustedChain.length - 1]);
249         }
250     }
251 
252     private void checkTrusted(X509Certificate[] chain,
253             String authType, SSLEngine engine,
254             boolean checkClientTrusted) throws CertificateException {
255         Validator v = checkTrustedInit(chain, authType, checkClientTrusted);
256 
257         X509Certificate[] trustedChain = null;
258         if (engine != null) {
259             SSLSession session = engine.getHandshakeSession();
260             if (session == null) {
261                 throw new CertificateException(&quot;No handshake session&quot;);
262             }
263 
264             // create the algorithm constraints
265             boolean isExtSession = (session instanceof ExtendedSSLSession);
266             AlgorithmConstraints constraints;
267             if (isExtSession &amp;&amp;
268                     ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
269                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;
270                 String[] localSupportedSignAlgs =
271                         extSession.getLocalSupportedSignatureAlgorithms();
272 
273                 constraints = new SSLAlgorithmConstraints(
274                                 engine, localSupportedSignAlgs, false);
275             } else {
276                 constraints = new SSLAlgorithmConstraints(engine, false);
277             }
278 
279             // Grab any stapled OCSP responses for use in validation
280             List&lt;byte[]&gt; responseList = Collections.emptyList();
281             if (!checkClientTrusted &amp;&amp; isExtSession) {
282                 responseList =
283                         ((ExtendedSSLSession)session).getStatusResponses();
284             }
285             trustedChain = v.validate(chain, null, responseList,
286                     constraints, checkClientTrusted ? null : authType);
287 
288             // check endpoint identity
289             String identityAlg = engine.getSSLParameters().
290                     getEndpointIdentificationAlgorithm();
291             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
292                 checkIdentity(session, trustedChain,
293                         identityAlg, checkClientTrusted);
294             }
295         } else {
296             trustedChain = v.validate(chain, null, Collections.emptyList(),
297                     null, checkClientTrusted ? null : authType);
298         }
299 
300         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
301             SSLLogger.fine(&quot;Found trusted certificate&quot;,
302                     trustedChain[trustedChain.length - 1]);
303         }
304     }
305 
306     private Validator getValidator(String variant) {
307         Validator v;
308         if (pkixParams == null) {
309             v = Validator.getInstance(validatorType, variant, trustedCerts);
310         } else {
311             v = Validator.getInstance(validatorType, variant, pkixParams);
312         }
313         return v;
314     }
315 
316     // Get string representation of HostName from a list of server names.
317     //
318     // We are only accepting host_name name type in the list.
319     private static String getHostNameInSNI(List&lt;SNIServerName&gt; sniNames) {
320 
321         SNIHostName hostname = null;
322         for (SNIServerName sniName : sniNames) {
323             if (sniName.getType() != StandardConstants.SNI_HOST_NAME) {
324                 continue;
325             }
326 
327             if (sniName instanceof SNIHostName) {
328                 hostname = (SNIHostName)sniName;
329             } else {
330                 try {
331                     hostname = new SNIHostName(sniName.getEncoded());
332                 } catch (IllegalArgumentException iae) {
333                     // unlikely to happen, just in case ...
334                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
335                         SSLLogger.fine(&quot;Illegal server name: &quot; + sniName);
336                     }
337                 }
338             }
339 
340             // no more than server name of the same name type
341             break;
342         }
343 
344         if (hostname != null) {
345             return hostname.getAsciiName();
346         }
347 
348         return null;
349     }
350 
351     // Also used by X509KeyManagerImpl
352     static List&lt;SNIServerName&gt; getRequestedServerNames(Socket socket) {
353         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
354                                         socket instanceof SSLSocket) {
355             return getRequestedServerNames(
356                     ((SSLSocket)socket).getHandshakeSession());
357         }
358 
359         return Collections.&lt;SNIServerName&gt;emptyList();
360     }
361 
362     // Also used by X509KeyManagerImpl
363     static List&lt;SNIServerName&gt; getRequestedServerNames(SSLEngine engine) {
364         if (engine != null) {
365             return getRequestedServerNames(engine.getHandshakeSession());
366         }
367 
368         return Collections.&lt;SNIServerName&gt;emptyList();
369     }
370 
371     private static List&lt;SNIServerName&gt; getRequestedServerNames(
372             SSLSession session) {
373         if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {
374             return ((ExtendedSSLSession)session).getRequestedServerNames();
375         }
376 
377         return Collections.&lt;SNIServerName&gt;emptyList();
378     }
379 
380     /*
381      * Per RFC 6066, if an application negotiates a server name using an
382      * application protocol and then upgrades to TLS, and if a server_name
383      * extension is sent, then the extension SHOULD contain the same name
384      * that was negotiated in the application protocol.  If the server_name
385      * is established in the TLS session handshake, the client SHOULD NOT
386      * attempt to request a different server name at the application layer.
387      *
388      * According to the above spec, we only need to check either the identity
389      * in server_name extension or the peer host of the connection.  Peer host
390      * is not always a reliable fully qualified domain name. The HostName in
391      * server_name extension is more reliable than peer host. So we prefer
392      * the identity checking aginst the server_name extension if present, and
393      * may failove to peer host checking.
394      */
395     static void checkIdentity(SSLSession session,
396             X509Certificate[] trustedChain,
397             String algorithm,
398             boolean checkClientTrusted) throws CertificateException {
399 
400         // check if EE certificate chains to a public root CA (as
401         // pre-installed in cacerts)
402         boolean chainsToPublicCA = AnchorCertificates.contains(
403                 trustedChain[trustedChain.length - 1]);
404 
405         boolean identifiable = false;
406         String peerHost = session.getPeerHost();
407         if (!checkClientTrusted) {
408             List&lt;SNIServerName&gt; sniNames = getRequestedServerNames(session);
409             String sniHostName = getHostNameInSNI(sniNames);
410             if (sniHostName != null) {
411                 try {
412                     checkIdentity(sniHostName,
413                             trustedChain[0], algorithm, chainsToPublicCA);
414                     identifiable = true;
415                 } catch (CertificateException ce) {
416                     if (sniHostName.equalsIgnoreCase(peerHost)) {
417                         throw ce;
418                     }
419 
420                     // otherwisw, failover to check peer host
421                 }
422             }
423         }
424 
425         if (!identifiable) {
426             checkIdentity(peerHost,
427                     trustedChain[0], algorithm, chainsToPublicCA);
428         }
429     }
430 
431     /*
432      * Identify the peer by its certificate and hostname.
433      *
434      * Lifted from sun.net.www.protocol.https.HttpsClient.
435      */
436     static void checkIdentity(String hostname, X509Certificate cert,
437             String algorithm) throws CertificateException {
438         checkIdentity(hostname, cert, algorithm, false);
439     }
440 
441     private static void checkIdentity(String hostname, X509Certificate cert,
442             String algorithm, boolean chainsToPublicCA)
443             throws CertificateException {
444         if (algorithm != null &amp;&amp; !algorithm.isEmpty()) {
445             // if IPv6 strip off the &quot;[]&quot;
446             if ((hostname != null) &amp;&amp; hostname.startsWith(&quot;[&quot;) &amp;&amp;
447                     hostname.endsWith(&quot;]&quot;)) {
448                 hostname = hostname.substring(1, hostname.length() - 1);
449             }
450 
451             if (algorithm.equalsIgnoreCase(&quot;HTTPS&quot;)) {
452                 HostnameChecker.getInstance(HostnameChecker.TYPE_TLS).match(
453                         hostname, cert, chainsToPublicCA);
454             } else if (algorithm.equalsIgnoreCase(&quot;LDAP&quot;) ||
455                     algorithm.equalsIgnoreCase(&quot;LDAPS&quot;)) {
456                 HostnameChecker.getInstance(HostnameChecker.TYPE_LDAP).match(
457                         hostname, cert, chainsToPublicCA);
458             } else {
459                 throw new CertificateException(
460                         &quot;Unknown identification algorithm: &quot; + algorithm);
461             }
462         }
463     }
464 }
465 
    </pre>
  </body>
</html>
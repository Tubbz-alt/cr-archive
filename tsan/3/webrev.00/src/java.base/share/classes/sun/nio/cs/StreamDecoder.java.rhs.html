<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/cs/StreamDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  */
 28 
 29 package sun.nio.cs;
 30 
<a name="2" id="anc2"></a><span class="line-modified"> 31 import java.io.FileInputStream;</span>
<span class="line-modified"> 32 import java.io.IOException;</span>
<span class="line-modified"> 33 import java.io.InputStream;</span>
<span class="line-modified"> 34 import java.io.UnsupportedEncodingException;</span>
<span class="line-added"> 35 import java.io.Reader;</span>
<span class="line-added"> 36 import java.nio.ByteBuffer;</span>
<span class="line-added"> 37 import java.nio.CharBuffer;</span>
<span class="line-added"> 38 import java.nio.channels.FileChannel;</span>
<span class="line-added"> 39 import java.nio.channels.ReadableByteChannel;</span>
<span class="line-added"> 40 import java.nio.charset.Charset;</span>
<span class="line-added"> 41 import java.nio.charset.CharsetDecoder;</span>
<span class="line-added"> 42 import java.nio.charset.CoderResult;</span>
<span class="line-added"> 43 import java.nio.charset.CodingErrorAction;</span>
<span class="line-added"> 44 import java.nio.charset.IllegalCharsetNameException;</span>
 45 
 46 public class StreamDecoder extends Reader
 47 {
 48 
 49     private static final int MIN_BYTE_BUFFER_SIZE = 32;
 50     private static final int DEFAULT_BYTE_BUFFER_SIZE = 8192;
 51 
 52     private volatile boolean closed;
 53 
 54     private void ensureOpen() throws IOException {
 55         if (closed)
 56             throw new IOException(&quot;Stream closed&quot;);
 57     }
 58 
 59     // In order to handle surrogates properly we must never try to produce
 60     // fewer than two characters at a time.  If we&#39;re only asked to return one
 61     // character then the other is saved here to be returned later.
 62     //
 63     private boolean haveLeftoverChar = false;
 64     private char leftoverChar;
 65 
 66 
 67     // Factories for java.io.InputStreamReader
 68 
 69     public static StreamDecoder forInputStreamReader(InputStream in,
 70                                                      Object lock,
 71                                                      String charsetName)
 72         throws UnsupportedEncodingException
 73     {
 74         String csn = charsetName;
 75         if (csn == null)
 76             csn = Charset.defaultCharset().name();
 77         try {
 78             if (Charset.isSupported(csn))
 79                 return new StreamDecoder(in, lock, Charset.forName(csn));
 80         } catch (IllegalCharsetNameException x) { }
 81         throw new UnsupportedEncodingException (csn);
 82     }
 83 
 84     public static StreamDecoder forInputStreamReader(InputStream in,
 85                                                      Object lock,
 86                                                      Charset cs)
 87     {
 88         return new StreamDecoder(in, lock, cs);
 89     }
 90 
 91     public static StreamDecoder forInputStreamReader(InputStream in,
 92                                                      Object lock,
 93                                                      CharsetDecoder dec)
 94     {
 95         return new StreamDecoder(in, lock, dec);
 96     }
 97 
 98 
 99     // Factory for java.nio.channels.Channels.newReader
100 
101     public static StreamDecoder forDecoder(ReadableByteChannel ch,
102                                            CharsetDecoder dec,
103                                            int minBufferCap)
104     {
105         return new StreamDecoder(ch, dec, minBufferCap);
106     }
107 
108 
109     // -- Public methods corresponding to those in InputStreamReader --
110 
111     // All synchronization and state/argument checking is done in these public
112     // methods; the concrete stream-decoder subclasses defined below need not
113     // do any such checking.
114 
115     public String getEncoding() {
116         if (isOpen())
117             return encodingName();
118         return null;
119     }
120 
121     public int read() throws IOException {
122         return read0();
123     }
124 
125     @SuppressWarnings(&quot;fallthrough&quot;)
126     private int read0() throws IOException {
127         synchronized (lock) {
128 
129             // Return the leftover char, if there is one
130             if (haveLeftoverChar) {
131                 haveLeftoverChar = false;
132                 return leftoverChar;
133             }
134 
135             // Convert more bytes
136             char cb[] = new char[2];
137             int n = read(cb, 0, 2);
138             switch (n) {
139             case -1:
140                 return -1;
141             case 2:
142                 leftoverChar = cb[1];
143                 haveLeftoverChar = true;
144                 // FALL THROUGH
145             case 1:
146                 return cb[0];
147             default:
148                 assert false : n;
149                 return -1;
150             }
151         }
152     }
153 
154     public int read(char cbuf[], int offset, int length) throws IOException {
155         int off = offset;
156         int len = length;
157         synchronized (lock) {
158             ensureOpen();
159             if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||
160                 ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) {
161                 throw new IndexOutOfBoundsException();
162             }
163             if (len == 0)
164                 return 0;
165 
166             int n = 0;
167 
168             if (haveLeftoverChar) {
169                 // Copy the leftover char into the buffer
170                 cbuf[off] = leftoverChar;
171                 off++; len--;
172                 haveLeftoverChar = false;
173                 n = 1;
174                 if ((len == 0) || !implReady())
175                     // Return now if this is all we can produce w/o blocking
176                     return n;
177             }
178 
179             if (len == 1) {
180                 // Treat single-character array reads just like read()
181                 int c = read0();
182                 if (c == -1)
183                     return (n == 0) ? -1 : n;
184                 cbuf[off] = (char)c;
185                 return n + 1;
186             }
187 
188             return n + implRead(cbuf, off, off + len);
189         }
190     }
191 
192     public boolean ready() throws IOException {
193         synchronized (lock) {
194             ensureOpen();
195             return haveLeftoverChar || implReady();
196         }
197     }
198 
199     public void close() throws IOException {
200         synchronized (lock) {
201             if (closed)
202                 return;
<a name="3" id="anc3"></a><span class="line-modified">203             try {</span>
<span class="line-modified">204                 implClose();</span>
<span class="line-added">205             } finally {</span>
<span class="line-added">206                 closed = true;</span>
<span class="line-added">207             }</span>
208         }
209     }
210 
211     private boolean isOpen() {
212         return !closed;
213     }
214 
215 
216     // -- Charset-based stream decoder impl --
217 
218     // In the early stages of the build we haven&#39;t yet built the NIO native
219     // code, so guard against that by catching the first UnsatisfiedLinkError
220     // and setting this flag so that later attempts fail quickly.
221     //
222     private static volatile boolean channelsAvailable = true;
223 
224     private static FileChannel getChannel(FileInputStream in) {
225         if (!channelsAvailable)
226             return null;
227         try {
228             return in.getChannel();
229         } catch (UnsatisfiedLinkError x) {
230             channelsAvailable = false;
231             return null;
232         }
233     }
234 
235     private Charset cs;
236     private CharsetDecoder decoder;
237     private ByteBuffer bb;
238 
239     // Exactly one of these is non-null
240     private InputStream in;
241     private ReadableByteChannel ch;
242 
243     StreamDecoder(InputStream in, Object lock, Charset cs) {
244         this(in, lock,
245          cs.newDecoder()
246          .onMalformedInput(CodingErrorAction.REPLACE)
247          .onUnmappableCharacter(CodingErrorAction.REPLACE));
248     }
249 
250     StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) {
251         super(lock);
252         this.cs = dec.charset();
253         this.decoder = dec;
254 
255         // This path disabled until direct buffers are faster
256         if (false &amp;&amp; in instanceof FileInputStream) {
257         ch = getChannel((FileInputStream)in);
258         if (ch != null)
259             bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);
260         }
261         if (ch == null) {
262         this.in = in;
263         this.ch = null;
264         bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);
265         }
266         bb.flip();                      // So that bb is initially empty
267     }
268 
269     StreamDecoder(ReadableByteChannel ch, CharsetDecoder dec, int mbc) {
270         this.in = null;
271         this.ch = ch;
272         this.decoder = dec;
273         this.cs = dec.charset();
274         this.bb = ByteBuffer.allocate(mbc &lt; 0
275                                   ? DEFAULT_BYTE_BUFFER_SIZE
276                                   : (mbc &lt; MIN_BYTE_BUFFER_SIZE
277                                      ? MIN_BYTE_BUFFER_SIZE
278                                      : mbc));
279         bb.flip();
280     }
281 
282     private int readBytes() throws IOException {
283         bb.compact();
284         try {
285         if (ch != null) {
286             // Read from the channel
287             int n = ch.read(bb);
288             if (n &lt; 0)
289                 return n;
290         } else {
291             // Read from the input stream, and then update the buffer
292             int lim = bb.limit();
293             int pos = bb.position();
294             assert (pos &lt;= lim);
295             int rem = (pos &lt;= lim ? lim - pos : 0);
296             assert rem &gt; 0;
297             int n = in.read(bb.array(), bb.arrayOffset() + pos, rem);
298             if (n &lt; 0)
299                 return n;
300             if (n == 0)
301                 throw new IOException(&quot;Underlying input stream returned zero bytes&quot;);
302             assert (n &lt;= rem) : &quot;n = &quot; + n + &quot;, rem = &quot; + rem;
303             bb.position(pos + n);
304         }
305         } finally {
306         // Flip even when an IOException is thrown,
307         // otherwise the stream will stutter
308         bb.flip();
309         }
310 
311         int rem = bb.remaining();
312             assert (rem != 0) : rem;
313             return rem;
314     }
315 
316     int implRead(char[] cbuf, int off, int end) throws IOException {
317 
318         // In order to handle surrogate pairs, this method requires that
319         // the invoker attempt to read at least two characters.  Saving the
320         // extra character, if any, at a higher level is easier than trying
321         // to deal with it here.
322         assert (end - off &gt; 1);
323 
324         CharBuffer cb = CharBuffer.wrap(cbuf, off, end - off);
325         if (cb.position() != 0)
326         // Ensure that cb[0] == cbuf[off]
327         cb = cb.slice();
328 
329         boolean eof = false;
330         for (;;) {
331         CoderResult cr = decoder.decode(bb, cb, eof);
332         if (cr.isUnderflow()) {
333             if (eof)
334                 break;
335             if (!cb.hasRemaining())
336                 break;
337             if ((cb.position() &gt; 0) &amp;&amp; !inReady())
338                 break;          // Block at most once
339             int n = readBytes();
340             if (n &lt; 0) {
341                 eof = true;
342                 if ((cb.position() == 0) &amp;&amp; (!bb.hasRemaining()))
343                     break;
344                 decoder.reset();
345             }
346             continue;
347         }
348         if (cr.isOverflow()) {
349             assert cb.position() &gt; 0;
350             break;
351         }
352         cr.throwException();
353         }
354 
355         if (eof) {
356         // ## Need to flush decoder
357         decoder.reset();
358         }
359 
360         if (cb.position() == 0) {
361             if (eof)
362                 return -1;
363             assert false;
364         }
365         return cb.position();
366     }
367 
368     String encodingName() {
369         return ((cs instanceof HistoricallyNamedCharset)
370             ? ((HistoricallyNamedCharset)cs).historicalName()
371             : cs.name());
372     }
373 
374     private boolean inReady() {
375         try {
376         return (((in != null) &amp;&amp; (in.available() &gt; 0))
377                 || (ch instanceof FileChannel)); // ## RBC.available()?
378         } catch (IOException x) {
379         return false;
380         }
381     }
382 
383     boolean implReady() {
384             return bb.hasRemaining() || inReady();
385     }
386 
387     void implClose() throws IOException {
388         if (ch != null)
389         ch.close();
390         else
391         in.close();
392     }
393 
394 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
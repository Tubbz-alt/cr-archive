diff a/src/java.base/share/classes/sun/security/util/DerInputStream.java b/src/java.base/share/classes/sun/security/util/DerInputStream.java
--- a/src/java.base/share/classes/sun/security/util/DerInputStream.java
+++ b/src/java.base/share/classes/sun/security/util/DerInputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,15 +25,16 @@
 
 package sun.security.util;
 
 import java.io.InputStream;
 import java.io.IOException;
-import java.io.EOFException;
+import java.math.BigInteger;
+import java.nio.charset.Charset;
 import java.util.Date;
 import java.util.Vector;
-import java.math.BigInteger;
-import java.io.DataInputStream;
+
+import static java.nio.charset.StandardCharsets.*;
 
 /**
  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
  * that found in X.509 certificates.  DER is a subset of BER/1, which has
  * the advantage that it allows only a single encoding of primitive data.
@@ -128,11 +129,16 @@
             } else {
                 byte[] inData = new byte[len];
                 System.arraycopy(data, offset, inData, 0, len);
 
                 DerIndefLenConverter derIn = new DerIndefLenConverter();
-                buffer = new DerInputBuffer(derIn.convert(inData), allowBER);
+                byte[] result = derIn.convertBytes(inData);
+                if (result == null) {
+                    throw new IOException("not all indef len BER resolved");
+                } else {
+                    buffer = new DerInputBuffer(result, allowBER);
+                }
             }
         } else {
             buffer = new DerInputBuffer(data, offset, len, allowBER);
         }
         buffer.mark(Integer.MAX_VALUE);
@@ -387,20 +393,13 @@
         byte lenByte = (byte)buffer.read();
         int len = getLength(lenByte, buffer);
 
         if (len == -1) {
            // indefinite length encoding found
-           int readLen = buffer.available();
-           int offset = 2;     // for tag and length bytes
-           byte[] indefData = new byte[readLen + offset];
-           indefData[0] = tag;
-           indefData[1] = lenByte;
-           DataInputStream dis = new DataInputStream(buffer);
-           dis.readFully(indefData, offset, readLen);
-           dis.close();
-           DerIndefLenConverter derIn = new DerIndefLenConverter();
-           buffer = new DerInputBuffer(derIn.convert(indefData), buffer.allowBER);
+           buffer = new DerInputBuffer(
+                   DerIndefLenConverter.convertStream(buffer, lenByte, tag),
+                   buffer.allowBER);
 
            if (tag != buffer.read())
                 throw new IOException("Indefinite length encoding" +
                         " not supported");
            len = DerInputStream.getDefiniteLength(buffer);
@@ -459,52 +458,51 @@
 
     /**
      * Read a string that was encoded as a UTF8String DER value.
      */
     public String getUTF8String() throws IOException {
-        return readString(DerValue.tag_UTF8String, "UTF-8", "UTF8");
+        return readString(DerValue.tag_UTF8String, "UTF-8", UTF_8);
     }
 
     /**
      * Read a string that was encoded as a PrintableString DER value.
      */
     public String getPrintableString() throws IOException {
         return readString(DerValue.tag_PrintableString, "Printable",
-                          "ASCII");
+                          US_ASCII);
     }
 
     /**
      * Read a string that was encoded as a T61String DER value.
      */
     public String getT61String() throws IOException {
         /*
          * Works for common characters between T61 and ASCII.
          */
-        return readString(DerValue.tag_T61String, "T61", "ISO-8859-1");
+        return readString(DerValue.tag_T61String, "T61", ISO_8859_1);
     }
 
     /**
-     * Read a string that was encoded as a IA5tring DER value.
+     * Read a string that was encoded as a IA5String DER value.
      */
     public String getIA5String() throws IOException {
-        return readString(DerValue.tag_IA5String, "IA5", "ASCII");
+        return readString(DerValue.tag_IA5String, "IA5", US_ASCII);
     }
 
     /**
      * Read a string that was encoded as a BMPString DER value.
      */
     public String getBMPString() throws IOException {
-        return readString(DerValue.tag_BMPString, "BMP",
-                          "UnicodeBigUnmarked");
+        return readString(DerValue.tag_BMPString, "BMP", UTF_16BE);
     }
 
     /**
      * Read a string that was encoded as a GeneralString DER value.
      */
     public String getGeneralString() throws IOException {
         return readString(DerValue.tag_GeneralString, "General",
-                          "ASCII");
+                          US_ASCII);
     }
 
     /**
      * Private helper routine to read an encoded string from the input
      * stream.
@@ -512,11 +510,11 @@
      * @param stringName a name to display in error messages
      * @param enc the encoder to use to interpret the data. Should
      * correspond to the stringTag above.
      */
     private String readString(byte stringTag, String stringName,
-                              String enc) throws IOException {
+                              Charset charset) throws IOException {
 
         if (buffer.read() != stringTag)
             throw new IOException("DER input not a " +
                                   stringName + " string");
 
@@ -524,11 +522,11 @@
         byte[] retval = new byte[length];
         if ((length != 0) && (buffer.read(retval) != length))
             throw new IOException("Short read of DER " +
                                   stringName + " string");
 
-        return new String(retval, enc);
+        return new String(retval, charset);
     }
 
     /**
      * Get a UTC encoded time value from the input stream.
      */

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AuthCacheValue.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BasicAuthentication.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29,10 +29,11 @@</span>
  import java.io.ObjectInputStream;
  import java.net.PasswordAuthentication;
  import java.net.URL;
  import java.util.HashMap;
  import java.util.Objects;
<span class="udiff-line-added">+ import java.util.function.Function;</span>
  
  import sun.net.www.HeaderParser;
  
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,10 +51,11 @@</span>
  //      policy in HttpURLConnection.  A failure on baz.foo.com shouldn&#39;t
  //      uncache foo.com!
  
  public abstract class AuthenticationInfo extends AuthCacheValue implements Cloneable {
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      static final long serialVersionUID = -2588378268010453259L;
  
      // Constants saying what kind of authroization this is.  This determines
      // the namespace in the hash table lookup.
      public static final char SERVER_AUTHENTICATION = &#39;s&#39;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,37 +125,54 @@</span>
       * at the same time, then all but the first will block until
       * the first completes its authentication.
       */
      private static HashMap&lt;String,Thread&gt; requests = new HashMap&lt;&gt;();
  
<span class="udiff-line-modified-removed">-     /* check if a request for this destination is in progress</span>
<span class="udiff-line-modified-removed">-      * return false immediately if not. Otherwise block until</span>
<span class="udiff-line-modified-removed">-      * request is finished and return true</span>
<span class="udiff-line-modified-added">+     /*</span>
<span class="udiff-line-modified-added">+      * check if AuthenticationInfo is available in the cache.</span>
<span class="udiff-line-modified-added">+      * If not, check if a request for this destination is in progress</span>
<span class="udiff-line-added">+      * and if so block until the other request is finished authenticating</span>
<span class="udiff-line-added">+      * and returns the cached authentication value.</span>
<span class="udiff-line-added">+      * Otherwise, returns the cached authentication value, which may be null.</span>
       */
<span class="udiff-line-modified-removed">-     private static boolean requestIsInProgress (String key) {</span>
<span class="udiff-line-modified-removed">-         if (!serializeAuth) {</span>
<span class="udiff-line-modified-removed">-             /* behavior is disabled. Revert to concurrent requests */</span>
<span class="udiff-line-modified-removed">-             return false;</span>
<span class="udiff-line-modified-added">+     private static AuthenticationInfo requestAuthentication(String key, Function&lt;String, AuthenticationInfo&gt; cache) {</span>
<span class="udiff-line-modified-added">+         AuthenticationInfo cached = cache.apply(key);</span>
<span class="udiff-line-modified-added">+         if (cached != null || !serializeAuth) {</span>
<span class="udiff-line-modified-added">+             // either we already have a value in the cache, and we can</span>
<span class="udiff-line-added">+             // use that immediately, or the serializeAuth behavior is disabled,</span>
<span class="udiff-line-added">+             // and we can revert to concurrent requests</span>
<span class="udiff-line-added">+             return cached;</span>
          }
          synchronized (requests) {
<span class="udiff-line-added">+             // check again after synchronizing, and if available</span>
<span class="udiff-line-added">+             // just return the cached value.</span>
<span class="udiff-line-added">+             cached = cache.apply(key);</span>
<span class="udiff-line-added">+             if (cached != null) return cached;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Otherwise, if no request is in progress, record this</span>
<span class="udiff-line-added">+             // thread as performing authentication and returns null.</span>
              Thread t, c;
              c = Thread.currentThread();
              if ((t = requests.get(key)) == null) {
                  requests.put (key, c);
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-modified-added">+                 assert cached == null;</span>
<span class="udiff-line-added">+                 return cached;</span>
              }
              if (t == c) {
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-modified-added">+                 assert cached == null;</span>
<span class="udiff-line-added">+                 return cached;</span>
              }
<span class="udiff-line-added">+             // Otherwise, an other thread is currently performing authentication:</span>
<span class="udiff-line-added">+             // wait until it finishes.</span>
              while (requests.containsKey(key)) {
                  try {
                      requests.wait ();
                  } catch (InterruptedException e) {}
              }
          }
          /* entry may be in cache now. */
<span class="udiff-line-modified-removed">-         return true;</span>
<span class="udiff-line-modified-added">+         return cache.apply(key);</span>
      }
  
      /* signal completion of an authentication (whether it succeeded or not)
       * so that other threads can continue.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -316,17 +335,17 @@</span>
                       + &quot;:&quot; + port + &quot;:&quot; + realm
                       + &quot;;auth=&quot; + authenticatorKey;
          return key;
      }
  
<span class="udiff-line-added">+     private static AuthenticationInfo getCachedServerAuth(String key) {</span>
<span class="udiff-line-added">+         return getAuth(key, null);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      static AuthenticationInfo getServerAuth(String key) {
<span class="udiff-line-modified-removed">-         AuthenticationInfo cached = getAuth(key, null);</span>
<span class="udiff-line-modified-removed">-         if ((cached == null) &amp;&amp; requestIsInProgress (key)) {</span>
<span class="udiff-line-removed">-             /* check the cache again, it might contain an entry */</span>
<span class="udiff-line-removed">-             cached = getAuth(key, null);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return cached;</span>
<span class="udiff-line-modified-added">+         if (!serializeAuth) return getCachedServerAuth(key);</span>
<span class="udiff-line-modified-added">+         return requestAuthentication(key, AuthenticationInfo::getCachedServerAuth);</span>
      }
  
  
      /**
       * Return the AuthenticationInfo object from the cache if it&#39;s path is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -365,17 +384,17 @@</span>
                          + &quot;:&quot; + port + &quot;:&quot; + realm
                          + &quot;;auth=&quot; + authenticatorKey;
          return key;
      }
  
<span class="udiff-line-added">+     private static AuthenticationInfo getCachedProxyAuth(String key) {</span>
<span class="udiff-line-added">+         return (AuthenticationInfo) cache.get(key, null);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      static AuthenticationInfo getProxyAuth(String key) {
<span class="udiff-line-modified-removed">-         AuthenticationInfo cached = (AuthenticationInfo) cache.get(key, null);</span>
<span class="udiff-line-modified-removed">-         if ((cached == null) &amp;&amp; requestIsInProgress (key)) {</span>
<span class="udiff-line-removed">-             /* check the cache again, it might contain an entry */</span>
<span class="udiff-line-removed">-             cached = (AuthenticationInfo) cache.get(key, null);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return cached;</span>
<span class="udiff-line-modified-added">+         if (!serializeAuth) return getCachedProxyAuth(key);</span>
<span class="udiff-line-modified-added">+         return requestAuthentication(key, AuthenticationInfo::getCachedProxyAuth);</span>
      }
  
  
      /**
       * Add this authentication to the cache
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -478,10 +497,11 @@</span>
          }
      }
  
      String s1, s2;  /* used for serialization of pw */
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      private synchronized void readObject(ObjectInputStream s)
          throws IOException, ClassNotFoundException
      {
          s.defaultReadObject ();
          pw = new PasswordAuthentication (s1, s2.toCharArray());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -489,10 +509,11 @@</span>
          if (authenticatorKey == null) {
              authenticatorKey = AuthenticatorKeys.DEFAULT;
          }
      }
  
<span class="udiff-line-added">+     @java.io.Serial</span>
      private synchronized void writeObject(java.io.ObjectOutputStream s)
          throws IOException
      {
          Objects.requireNonNull(authenticatorKey);
          s1 = pw.getUserName();
</pre>
<center><a href="AuthCacheValue.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BasicAuthentication.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
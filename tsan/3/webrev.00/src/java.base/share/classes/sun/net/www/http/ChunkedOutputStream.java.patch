diff a/src/java.base/share/classes/sun/net/www/http/ChunkedOutputStream.java b/src/java.base/share/classes/sun/net/www/http/ChunkedOutputStream.java
--- a/src/java.base/share/classes/sun/net/www/http/ChunkedOutputStream.java
+++ b/src/java.base/share/classes/sun/net/www/http/ChunkedOutputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,10 +24,12 @@
  */
 package sun.net.www.http;
 
 import java.io.*;
 
+import sun.nio.cs.US_ASCII;
+
 /**
  * OutputStream that sends the output to the underlying stream using chunked
  * encoding as specified in RFC 2068.
  */
 public class ChunkedOutputStream extends PrintStream {
@@ -65,24 +67,19 @@
     private static int getHeaderSize(int size) {
         return (Integer.toHexString(size)).length() + CRLF_SIZE;
     }
 
     /* return a header for a particular chunk size */
-    private static byte[] getHeader(int size){
-        try {
-            String hexStr =  Integer.toHexString(size);
-            byte[] hexBytes = hexStr.getBytes("US-ASCII");
-            byte[] header = new byte[getHeaderSize(size)];
-            for (int i=0; i<hexBytes.length; i++)
-                header[i] = hexBytes[i];
-            header[hexBytes.length] = CRLF[0];
-            header[hexBytes.length+1] = CRLF[1];
-            return header;
-        } catch (java.io.UnsupportedEncodingException e) {
-            /* This should never happen */
-            throw new InternalError(e.getMessage(), e);
-        }
+    private static byte[] getHeader(int size) {
+        String hexStr = Integer.toHexString(size);
+        byte[] hexBytes = hexStr.getBytes(US_ASCII.INSTANCE);
+        byte[] header = new byte[getHeaderSize(size)];
+        for (int i=0; i<hexBytes.length; i++)
+            header[i] = hexBytes[i];
+        header[hexBytes.length] = CRLF[0];
+        header[hexBytes.length+1] = CRLF[1];
+        return header;
     }
 
     public ChunkedOutputStream(PrintStream o) {
         this(o, DEFAULT_CHUNK_SIZE);
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HelloCookieManager.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/HandshakeContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import java.nio.BufferOverflowException;
 30 import java.nio.BufferUnderflowException;
 31 import java.nio.ByteBuffer;
 32 import java.security.AlgorithmConstraints;
 33 import java.security.CryptoPrimitive;
 34 import java.util.AbstractMap.SimpleImmutableEntry;
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.EnumMap;
 38 import java.util.EnumSet;
 39 import java.util.HashMap;
 40 import java.util.LinkedHashMap;
 41 import java.util.LinkedList;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Queue;
 45 import javax.crypto.SecretKey;
 46 import javax.net.ssl.SNIServerName;
 47 import javax.net.ssl.SSLHandshakeException;
 48 import javax.security.auth.x500.X500Principal;
<span class="line-modified"> 49 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-modified"> 50 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
<span class="line-removed"> 51 import static sun.security.ssl.SupportedGroupsExtension.NamedGroupType.*;</span>
 52 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 53 
 54 abstract class HandshakeContext implements ConnectionContext {
 55     // System properties
 56 
 57     // By default, disable the unsafe legacy session renegotiation.
 58     static final boolean allowUnsafeRenegotiation =
 59             Utilities.getBooleanProperty(
 60                     &quot;sun.security.ssl.allowUnsafeRenegotiation&quot;, false);
 61 
 62     // For maximum interoperability and backward compatibility, RFC 5746
 63     // allows server (or client) to accept ClientHello (or ServerHello)
 64     // message without the secure renegotiation_info extension or SCSV.
 65     //
 66     // For maximum security, RFC 5746 also allows server (or client) to
 67     // reject such message with a fatal &quot;handshake_failure&quot; alert.
 68     //
 69     // By default, allow such legacy hello messages.
 70     static final boolean allowLegacyHelloMessages =
 71             Utilities.getBooleanProperty(
</pre>
<hr />
<pre>
 85     final List&lt;CipherSuite&gt;                 activeCipherSuites;
 86     final AlgorithmConstraints              algorithmConstraints;
 87     final ProtocolVersion                   maximumActiveProtocol;
 88 
 89     // output stream
 90     final HandshakeOutStream                handshakeOutput;
 91 
 92     // handshake transcript hash
 93     final HandshakeHash                     handshakeHash;
 94 
 95     // negotiated security parameters
 96     SSLSessionImpl                          handshakeSession;
 97     boolean                                 handshakeFinished;
 98     // boolean                                 isInvalidated;
 99 
100     boolean                                 kickstartMessageDelivered;
101 
102     // Resumption
103     boolean                                 isResumption;
104     SSLSessionImpl                          resumingSession;


105 
106     final Queue&lt;Map.Entry&lt;Byte, ByteBuffer&gt;&gt; delegatedActions;
107     volatile boolean                        taskDelegated = false;
108     volatile Exception                      delegatedThrown = null;
109 
110     ProtocolVersion                         negotiatedProtocol;
111     CipherSuite                             negotiatedCipherSuite;
112     final List&lt;SSLPossession&gt;               handshakePossessions;
113     final List&lt;SSLCredentials&gt;              handshakeCredentials;
114     SSLKeyDerivation                        handshakeKeyDerivation;
115     SSLKeyExchange                          handshakeKeyExchange;
116     SecretKey                               baseReadSecret;
117     SecretKey                               baseWriteSecret;
118 
119     // protocol version being established
120     int                                     clientHelloVersion;
121     String                                  applicationProtocol;
122 
123     RandomCookie                            clientHelloRandom;
124     RandomCookie                            serverHelloRandom;
</pre>
<hr />
<pre>
265     private static List&lt;ProtocolVersion&gt; getActiveProtocols(
266             List&lt;ProtocolVersion&gt; enabledProtocols,
267             List&lt;CipherSuite&gt; enabledCipherSuites,
268             AlgorithmConstraints algorithmConstraints) {
269         boolean enabledSSL20Hello = false;
270         ArrayList&lt;ProtocolVersion&gt; protocols = new ArrayList&lt;&gt;(4);
271         for (ProtocolVersion protocol : enabledProtocols) {
272             if (!enabledSSL20Hello &amp;&amp; protocol == ProtocolVersion.SSL20Hello) {
273                 enabledSSL20Hello = true;
274                 continue;
275             }
276 
277             if (!algorithmConstraints.permits(
278                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
279                     protocol.name, null)) {
280                 // Ignore disabled protocol.
281                 continue;
282             }
283 
284             boolean found = false;
<span class="line-modified">285             Map&lt;NamedGroupType, Boolean&gt; cachedStatus =</span>
<span class="line-modified">286                     new EnumMap&lt;&gt;(NamedGroupType.class);</span>
287             for (CipherSuite suite : enabledCipherSuites) {
288                 if (suite.isAvailable() &amp;&amp; suite.supports(protocol)) {
289                     if (isActivatable(suite,
290                             algorithmConstraints, cachedStatus)) {
291                         protocols.add(protocol);
292                         found = true;
293                         break;
294                     }
295                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
296                     SSLLogger.fine(
297                         &quot;Ignore unsupported cipher suite: &quot; + suite +
298                              &quot; for &quot; + protocol);
299                 }
300             }
301 
302             if (!found &amp;&amp; (SSLLogger.isOn) &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
303                 SSLLogger.fine(
304                     &quot;No available cipher suite for &quot; + protocol);
305             }
306         }
307 
308         if (!protocols.isEmpty()) {
309             if (enabledSSL20Hello) {
310                 protocols.add(ProtocolVersion.SSL20Hello);
311             }
312             Collections.sort(protocols);
313         }
314 
315         return Collections.unmodifiableList(protocols);
316     }
317 
318     private static List&lt;CipherSuite&gt; getActiveCipherSuites(
319             List&lt;ProtocolVersion&gt; enabledProtocols,
320             List&lt;CipherSuite&gt; enabledCipherSuites,
321             AlgorithmConstraints algorithmConstraints) {
322 
323         List&lt;CipherSuite&gt; suites = new LinkedList&lt;&gt;();
324         if (enabledProtocols != null &amp;&amp; !enabledProtocols.isEmpty()) {
<span class="line-modified">325             Map&lt;NamedGroupType, Boolean&gt; cachedStatus =</span>
<span class="line-modified">326                     new EnumMap&lt;&gt;(NamedGroupType.class);</span>
327             for (CipherSuite suite : enabledCipherSuites) {
328                 if (!suite.isAvailable()) {
329                     continue;
330                 }
331 
332                 boolean isSupported = false;
333                 for (ProtocolVersion protocol : enabledProtocols) {
334                     if (!suite.supports(protocol)) {
335                         continue;
336                     }
337                     if (isActivatable(suite,
338                             algorithmConstraints, cachedStatus)) {
339                         suites.add(suite);
340                         isSupported = true;
341                         break;
342                     }
343                 }
344 
345                 if (!isSupported &amp;&amp;
346                         SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
</pre>
<hr />
<pre>
491     }
492 
493     /**
494      * Check if the given protocol version is enabled and available.
495      */
496     boolean isNegotiable(ProtocolVersion protocolVersion) {
497         return activeProtocols.contains(protocolVersion);
498     }
499 
500     /**
501      * Set the active protocol version and propagate it to the SSLSocket
502      * and our handshake streams. Called from ClientHandshaker
503      * and ServerHandshaker with the negotiated protocol version.
504      */
505     void setVersion(ProtocolVersion protocolVersion) {
506         this.conContext.protocolVersion = protocolVersion;
507     }
508 
509     private static boolean isActivatable(CipherSuite suite,
510             AlgorithmConstraints algorithmConstraints,
<span class="line-modified">511             Map&lt;NamedGroupType, Boolean&gt; cachedStatus) {</span>
512 
513         if (algorithmConstraints.permits(
514                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), suite.name, null)) {
515             if (suite.keyExchange == null) {
516                 // TLS 1.3, no definition of key exchange in cipher suite.
517                 return true;
518             }
519 
<span class="line-modified">520             boolean available;</span>
<span class="line-modified">521             NamedGroupType groupType = suite.keyExchange.groupType;</span>
<span class="line-modified">522             if (groupType != NAMED_GROUP_NONE) {</span>
<span class="line-modified">523                 Boolean checkedStatus = cachedStatus.get(groupType);</span>
<span class="line-modified">524                 if (checkedStatus == null) {</span>
<span class="line-modified">525                     available = SupportedGroups.isActivatable(</span>
<span class="line-modified">526                             algorithmConstraints, groupType);</span>
<span class="line-modified">527                     cachedStatus.put(groupType, available);</span>
<span class="line-modified">528 </span>
<span class="line-modified">529                     if (!available &amp;&amp;</span>
<span class="line-modified">530                             SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {</span>
<span class="line-modified">531                         SSLLogger.fine(&quot;No activated named group&quot;);</span>






532                     }


533                 } else {
<span class="line-modified">534                     available = checkedStatus;</span>
535                 }

536 
<span class="line-modified">537                 if (!available &amp;&amp; SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {</span>
<span class="line-modified">538                     SSLLogger.fine(</span>
<span class="line-removed">539                         &quot;No active named group, ignore &quot; + suite);</span>
<span class="line-removed">540                 }</span>
<span class="line-removed">541                 return available;</span>
<span class="line-removed">542             } else {</span>
<span class="line-removed">543                 return true;</span>
544             }



545         } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
546             SSLLogger.fine(&quot;Ignore disabled cipher suite: &quot; + suite);
547         }
548 
549         return false;
550     }
551 
552     List&lt;SNIServerName&gt; getRequestedServerNames() {
553         if (requestedServerNames == null) {
<span class="line-modified">554             return Collections.&lt;SNIServerName&gt;emptyList();</span>
555         }
556         return requestedServerNames;
557     }
558 }
559 
</pre>
</td>
<td>
<hr />
<pre>
 29 import java.nio.BufferOverflowException;
 30 import java.nio.BufferUnderflowException;
 31 import java.nio.ByteBuffer;
 32 import java.security.AlgorithmConstraints;
 33 import java.security.CryptoPrimitive;
 34 import java.util.AbstractMap.SimpleImmutableEntry;
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.EnumMap;
 38 import java.util.EnumSet;
 39 import java.util.HashMap;
 40 import java.util.LinkedHashMap;
 41 import java.util.LinkedList;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Queue;
 45 import javax.crypto.SecretKey;
 46 import javax.net.ssl.SNIServerName;
 47 import javax.net.ssl.SSLHandshakeException;
 48 import javax.security.auth.x500.X500Principal;
<span class="line-modified"> 49 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
<span class="line-modified"> 50 import static sun.security.ssl.NamedGroup.NamedGroupSpec.*;</span>

 51 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 52 
 53 abstract class HandshakeContext implements ConnectionContext {
 54     // System properties
 55 
 56     // By default, disable the unsafe legacy session renegotiation.
 57     static final boolean allowUnsafeRenegotiation =
 58             Utilities.getBooleanProperty(
 59                     &quot;sun.security.ssl.allowUnsafeRenegotiation&quot;, false);
 60 
 61     // For maximum interoperability and backward compatibility, RFC 5746
 62     // allows server (or client) to accept ClientHello (or ServerHello)
 63     // message without the secure renegotiation_info extension or SCSV.
 64     //
 65     // For maximum security, RFC 5746 also allows server (or client) to
 66     // reject such message with a fatal &quot;handshake_failure&quot; alert.
 67     //
 68     // By default, allow such legacy hello messages.
 69     static final boolean allowLegacyHelloMessages =
 70             Utilities.getBooleanProperty(
</pre>
<hr />
<pre>
 84     final List&lt;CipherSuite&gt;                 activeCipherSuites;
 85     final AlgorithmConstraints              algorithmConstraints;
 86     final ProtocolVersion                   maximumActiveProtocol;
 87 
 88     // output stream
 89     final HandshakeOutStream                handshakeOutput;
 90 
 91     // handshake transcript hash
 92     final HandshakeHash                     handshakeHash;
 93 
 94     // negotiated security parameters
 95     SSLSessionImpl                          handshakeSession;
 96     boolean                                 handshakeFinished;
 97     // boolean                                 isInvalidated;
 98 
 99     boolean                                 kickstartMessageDelivered;
100 
101     // Resumption
102     boolean                                 isResumption;
103     SSLSessionImpl                          resumingSession;
<span class="line-added">104     // Session is using stateless resumption</span>
<span class="line-added">105     boolean                                 statelessResumption = false;</span>
106 
107     final Queue&lt;Map.Entry&lt;Byte, ByteBuffer&gt;&gt; delegatedActions;
108     volatile boolean                        taskDelegated = false;
109     volatile Exception                      delegatedThrown = null;
110 
111     ProtocolVersion                         negotiatedProtocol;
112     CipherSuite                             negotiatedCipherSuite;
113     final List&lt;SSLPossession&gt;               handshakePossessions;
114     final List&lt;SSLCredentials&gt;              handshakeCredentials;
115     SSLKeyDerivation                        handshakeKeyDerivation;
116     SSLKeyExchange                          handshakeKeyExchange;
117     SecretKey                               baseReadSecret;
118     SecretKey                               baseWriteSecret;
119 
120     // protocol version being established
121     int                                     clientHelloVersion;
122     String                                  applicationProtocol;
123 
124     RandomCookie                            clientHelloRandom;
125     RandomCookie                            serverHelloRandom;
</pre>
<hr />
<pre>
266     private static List&lt;ProtocolVersion&gt; getActiveProtocols(
267             List&lt;ProtocolVersion&gt; enabledProtocols,
268             List&lt;CipherSuite&gt; enabledCipherSuites,
269             AlgorithmConstraints algorithmConstraints) {
270         boolean enabledSSL20Hello = false;
271         ArrayList&lt;ProtocolVersion&gt; protocols = new ArrayList&lt;&gt;(4);
272         for (ProtocolVersion protocol : enabledProtocols) {
273             if (!enabledSSL20Hello &amp;&amp; protocol == ProtocolVersion.SSL20Hello) {
274                 enabledSSL20Hello = true;
275                 continue;
276             }
277 
278             if (!algorithmConstraints.permits(
279                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
280                     protocol.name, null)) {
281                 // Ignore disabled protocol.
282                 continue;
283             }
284 
285             boolean found = false;
<span class="line-modified">286             Map&lt;NamedGroupSpec, Boolean&gt; cachedStatus =</span>
<span class="line-modified">287                     new EnumMap&lt;&gt;(NamedGroupSpec.class);</span>
288             for (CipherSuite suite : enabledCipherSuites) {
289                 if (suite.isAvailable() &amp;&amp; suite.supports(protocol)) {
290                     if (isActivatable(suite,
291                             algorithmConstraints, cachedStatus)) {
292                         protocols.add(protocol);
293                         found = true;
294                         break;
295                     }
296                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
297                     SSLLogger.fine(
298                         &quot;Ignore unsupported cipher suite: &quot; + suite +
299                              &quot; for &quot; + protocol);
300                 }
301             }
302 
303             if (!found &amp;&amp; (SSLLogger.isOn) &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
304                 SSLLogger.fine(
305                     &quot;No available cipher suite for &quot; + protocol);
306             }
307         }
308 
309         if (!protocols.isEmpty()) {
310             if (enabledSSL20Hello) {
311                 protocols.add(ProtocolVersion.SSL20Hello);
312             }
313             Collections.sort(protocols);
314         }
315 
316         return Collections.unmodifiableList(protocols);
317     }
318 
319     private static List&lt;CipherSuite&gt; getActiveCipherSuites(
320             List&lt;ProtocolVersion&gt; enabledProtocols,
321             List&lt;CipherSuite&gt; enabledCipherSuites,
322             AlgorithmConstraints algorithmConstraints) {
323 
324         List&lt;CipherSuite&gt; suites = new LinkedList&lt;&gt;();
325         if (enabledProtocols != null &amp;&amp; !enabledProtocols.isEmpty()) {
<span class="line-modified">326             Map&lt;NamedGroupSpec, Boolean&gt; cachedStatus =</span>
<span class="line-modified">327                     new EnumMap&lt;&gt;(NamedGroupSpec.class);</span>
328             for (CipherSuite suite : enabledCipherSuites) {
329                 if (!suite.isAvailable()) {
330                     continue;
331                 }
332 
333                 boolean isSupported = false;
334                 for (ProtocolVersion protocol : enabledProtocols) {
335                     if (!suite.supports(protocol)) {
336                         continue;
337                     }
338                     if (isActivatable(suite,
339                             algorithmConstraints, cachedStatus)) {
340                         suites.add(suite);
341                         isSupported = true;
342                         break;
343                     }
344                 }
345 
346                 if (!isSupported &amp;&amp;
347                         SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
</pre>
<hr />
<pre>
492     }
493 
494     /**
495      * Check if the given protocol version is enabled and available.
496      */
497     boolean isNegotiable(ProtocolVersion protocolVersion) {
498         return activeProtocols.contains(protocolVersion);
499     }
500 
501     /**
502      * Set the active protocol version and propagate it to the SSLSocket
503      * and our handshake streams. Called from ClientHandshaker
504      * and ServerHandshaker with the negotiated protocol version.
505      */
506     void setVersion(ProtocolVersion protocolVersion) {
507         this.conContext.protocolVersion = protocolVersion;
508     }
509 
510     private static boolean isActivatable(CipherSuite suite,
511             AlgorithmConstraints algorithmConstraints,
<span class="line-modified">512             Map&lt;NamedGroupSpec, Boolean&gt; cachedStatus) {</span>
513 
514         if (algorithmConstraints.permits(
515                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), suite.name, null)) {
516             if (suite.keyExchange == null) {
517                 // TLS 1.3, no definition of key exchange in cipher suite.
518                 return true;
519             }
520 
<span class="line-modified">521             // Is at least one of the group types available?</span>
<span class="line-modified">522             boolean groupAvailable, retval = false;</span>
<span class="line-modified">523             NamedGroupSpec[] groupTypes = suite.keyExchange.groupTypes;</span>
<span class="line-modified">524             for (NamedGroupSpec groupType : groupTypes) {</span>
<span class="line-modified">525                 if (groupType != NAMED_GROUP_NONE) {</span>
<span class="line-modified">526                     Boolean checkedStatus = cachedStatus.get(groupType);</span>
<span class="line-modified">527                     if (checkedStatus == null) {</span>
<span class="line-modified">528                         groupAvailable = SupportedGroups.isActivatable(</span>
<span class="line-modified">529                                 algorithmConstraints, groupType);</span>
<span class="line-modified">530                         cachedStatus.put(groupType, groupAvailable);</span>
<span class="line-modified">531 </span>
<span class="line-modified">532                         if (!groupAvailable &amp;&amp;</span>
<span class="line-added">533                                 SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {</span>
<span class="line-added">534                             SSLLogger.fine(</span>
<span class="line-added">535                                     &quot;No activated named group in &quot; + groupType);</span>
<span class="line-added">536                         }</span>
<span class="line-added">537                     } else {</span>
<span class="line-added">538                         groupAvailable = checkedStatus;</span>
539                     }
<span class="line-added">540 </span>
<span class="line-added">541                     retval |= groupAvailable;</span>
542                 } else {
<span class="line-modified">543                     retval |= true;</span>
544                 }
<span class="line-added">545             }</span>
546 
<span class="line-modified">547             if (!retval &amp;&amp; SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {</span>
<span class="line-modified">548                 SSLLogger.fine(&quot;No active named group(s), ignore &quot; + suite);</span>





549             }
<span class="line-added">550 </span>
<span class="line-added">551             return retval;</span>
<span class="line-added">552 </span>
553         } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;verbose&quot;)) {
554             SSLLogger.fine(&quot;Ignore disabled cipher suite: &quot; + suite);
555         }
556 
557         return false;
558     }
559 
560     List&lt;SNIServerName&gt; getRequestedServerNames() {
561         if (requestedServerNames == null) {
<span class="line-modified">562             return Collections.emptyList();</span>
563         }
564         return requestedServerNames;
565     }
566 }
567 
</pre>
</td>
</tr>
</table>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HelloCookieManager.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
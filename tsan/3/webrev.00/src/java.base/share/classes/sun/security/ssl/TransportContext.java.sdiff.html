<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/TransportContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SupportedGroupsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TrustStoreManager.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/TransportContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AccessControlContext;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.util.HashMap;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import javax.net.ssl.HandshakeCompletedEvent;
 38 import javax.net.ssl.HandshakeCompletedListener;
 39 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
 40 import javax.net.ssl.SSLException;
 41 import javax.net.ssl.SSLSocket;
<span class="line-removed"> 42 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
 43 
 44 /**
 45  * SSL/(D)TLS transportation context.
 46  */
 47 class TransportContext implements ConnectionContext {
 48     final SSLTransport              transport;
 49 
 50     // registered plaintext consumers
 51     final Map&lt;Byte, SSLConsumer&gt;    consumers;
 52     final AccessControlContext      acc;
 53 
 54     final SSLContextImpl            sslContext;
 55     final SSLConfiguration          sslConfig;
 56     final InputRecord               inputRecord;
 57     final OutputRecord              outputRecord;
 58 
 59     // connection status
 60     boolean                         isUnsureMode;
 61     boolean                         isNegotiated = false;
 62     boolean                         isBroken = false;
</pre>
<hr />
<pre>
142 
143     // Dispatch plaintext to a specific consumer.
144     void dispatch(Plaintext plaintext) throws IOException {
145         if (plaintext == null) {
146             return;
147         }
148 
149         ContentType ct = ContentType.valueOf(plaintext.contentType);
150         if (ct == null) {
151             throw fatal(Alert.UNEXPECTED_MESSAGE,
152                 &quot;Unknown content type: &quot; + plaintext.contentType);
153         }
154 
155         switch (ct) {
156             case HANDSHAKE:
157                 byte type = HandshakeContext.getHandshakeType(this,
158                         plaintext);
159                 if (handshakeContext == null) {
160                     if (type == SSLHandshake.KEY_UPDATE.id ||
161                             type == SSLHandshake.NEW_SESSION_TICKET.id) {
<span class="line-modified">162                         if (isNegotiated &amp;&amp;</span>
<span class="line-modified">163                                 protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-modified">164                             handshakeContext = new PostHandshakeContext(this);</span>
<span class="line-modified">165                         } else {</span>




166                             throw fatal(Alert.UNEXPECTED_MESSAGE,
167                                     &quot;Unexpected post-handshake message: &quot; +
168                                     SSLHandshake.nameOf(type));
169                         }

170                     } else {
171                         handshakeContext = sslConfig.isClientMode ?
172                                 new ClientHandshakeContext(sslContext, this) :
173                                 new ServerHandshakeContext(sslContext, this);
174                         outputRecord.initHandshaker();
175                     }
176                 }
177                 handshakeContext.dispatch(type, plaintext);
178                 break;
179             case ALERT:
180                 Alert.alertConsumer.consume(this, plaintext.fragment);
181                 break;
182             default:
183                 SSLConsumer consumer = consumers.get(plaintext.contentType);
184                 if (consumer != null) {
185                     consumer.consume(this, plaintext.fragment);
186                 } else {
187                     throw fatal(Alert.UNEXPECTED_MESSAGE,
188                         &quot;Unexpected content: &quot; + plaintext.contentType);
189                 }
</pre>
<hr />
<pre>
479 
480         // For TLS 1.2 and prior version, it is required to respond with
481         // a close_notify alert of its own and close down the connection
482         // immediately, discarding any pending writes.
483         if (!isOutboundClosed()) {
484             boolean needCloseNotify = SSLConfiguration.acknowledgeCloseNotify;
485             if (!needCloseNotify) {
486                 if (isNegotiated) {
487                     if (!protocolVersion.useTLS13PlusSpec()) {
488                         needCloseNotify = true;
489                     }
490                 } else if (handshakeContext != null) {  // initial handshake
491                     ProtocolVersion pv = handshakeContext.negotiatedProtocol;
492                     if (pv == null || (!pv.useTLS13PlusSpec())) {
493                         needCloseNotify = true;
494                     }
495                 }
496             }
497 
498             if (needCloseNotify) {
<span class="line-modified">499                 synchronized (outputRecord) {</span>

500                     try {
501                         // send a close_notify alert
502                         warning(Alert.CLOSE_NOTIFY);
503                     } finally {
504                         outputRecord.close();
505                     }


506                 }
507             }
508         }
509     }
510 
511     // Initiate a inbound close when the handshake is not started.
512     private void initiateInboundClose() throws IOException {
513         if (!isInboundClosed()) {
514             inputRecord.close();
515         }
516     }
517 
518     // Close outbound, no more data should be received from the underlying
519     // transportation connection.
520     void closeOutbound() {
521         if (isOutboundClosed()) {
522             return;
523         }
524 
525         try {
526              initiateOutboundClose();
527         } catch (IOException ioe) {
528             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
529                 SSLLogger.warning(&quot;outbound closure failed&quot;, ioe);
530             }
531         }
532     }
533 
534     // Initiate a close by sending a close_notify alert.
535     private void initiateOutboundClose() throws IOException {
536         boolean useUserCanceled = false;
537         if (!isNegotiated &amp;&amp; (handshakeContext != null) &amp;&amp; !peerUserCanceled) {
538             // initial handshake
539             useUserCanceled = true;
540         }
541 
542         // Need a lock here so that the user_canceled alert and the
543         // close_notify alert can be delivered together.
<span class="line-modified">544         synchronized (outputRecord) {</span>

545             try {
546                 // send a user_canceled alert if needed.
547                 if (useUserCanceled) {
548                     warning(Alert.USER_CANCELED);
549                 }
550 
551                 // send a close_notify alert
552                 warning(Alert.CLOSE_NOTIFY);
553             } finally {
554                 outputRecord.close();
555             }


556         }
557     }
558 
559     // Note; HandshakeStatus.FINISHED status is retrieved in other places.
560     HandshakeStatus getHandshakeStatus() {
561         if (!outputRecord.isEmpty()) {
562             // If no handshaking, special case to wrap alters or
563             // post-handshake messages.
564             return HandshakeStatus.NEED_WRAP;
565         } else if (isOutboundClosed() &amp;&amp; isInboundClosed()) {
566             return HandshakeStatus.NOT_HANDSHAKING;
567         } else if (handshakeContext != null) {
568             if (!handshakeContext.delegatedActions.isEmpty()) {
569                 return HandshakeStatus.NEED_TASK;
570             } else if (!isInboundClosed()) {
571                 if (sslContext.isDTLS() &amp;&amp;
572                         !inputRecord.isEmpty()) {
573                     return HandshakeStatus.NEED_UNWRAP_AGAIN;
574                 } else {
575                     return HandshakeStatus.NEED_UNWRAP;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AccessControlContext;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.util.HashMap;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import javax.net.ssl.HandshakeCompletedEvent;
 38 import javax.net.ssl.HandshakeCompletedListener;
 39 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
 40 import javax.net.ssl.SSLException;
 41 import javax.net.ssl.SSLSocket;

 42 
 43 /**
 44  * SSL/(D)TLS transportation context.
 45  */
 46 class TransportContext implements ConnectionContext {
 47     final SSLTransport              transport;
 48 
 49     // registered plaintext consumers
 50     final Map&lt;Byte, SSLConsumer&gt;    consumers;
 51     final AccessControlContext      acc;
 52 
 53     final SSLContextImpl            sslContext;
 54     final SSLConfiguration          sslConfig;
 55     final InputRecord               inputRecord;
 56     final OutputRecord              outputRecord;
 57 
 58     // connection status
 59     boolean                         isUnsureMode;
 60     boolean                         isNegotiated = false;
 61     boolean                         isBroken = false;
</pre>
<hr />
<pre>
141 
142     // Dispatch plaintext to a specific consumer.
143     void dispatch(Plaintext plaintext) throws IOException {
144         if (plaintext == null) {
145             return;
146         }
147 
148         ContentType ct = ContentType.valueOf(plaintext.contentType);
149         if (ct == null) {
150             throw fatal(Alert.UNEXPECTED_MESSAGE,
151                 &quot;Unknown content type: &quot; + plaintext.contentType);
152         }
153 
154         switch (ct) {
155             case HANDSHAKE:
156                 byte type = HandshakeContext.getHandshakeType(this,
157                         plaintext);
158                 if (handshakeContext == null) {
159                     if (type == SSLHandshake.KEY_UPDATE.id ||
160                             type == SSLHandshake.NEW_SESSION_TICKET.id) {
<span class="line-modified">161                         if (!isNegotiated) {</span>
<span class="line-modified">162                             throw fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">163                                     &quot;Unexpected unnegotiated post-handshake&quot; +</span>
<span class="line-modified">164                                             &quot; message: &quot; +</span>
<span class="line-added">165                                             SSLHandshake.nameOf(type));</span>
<span class="line-added">166                         }</span>
<span class="line-added">167                         if (type == SSLHandshake.KEY_UPDATE.id &amp;&amp;</span>
<span class="line-added">168                                 !protocolVersion.useTLS13PlusSpec()) {</span>
169                             throw fatal(Alert.UNEXPECTED_MESSAGE,
170                                     &quot;Unexpected post-handshake message: &quot; +
171                                     SSLHandshake.nameOf(type));
172                         }
<span class="line-added">173                         handshakeContext = new PostHandshakeContext(this);</span>
174                     } else {
175                         handshakeContext = sslConfig.isClientMode ?
176                                 new ClientHandshakeContext(sslContext, this) :
177                                 new ServerHandshakeContext(sslContext, this);
178                         outputRecord.initHandshaker();
179                     }
180                 }
181                 handshakeContext.dispatch(type, plaintext);
182                 break;
183             case ALERT:
184                 Alert.alertConsumer.consume(this, plaintext.fragment);
185                 break;
186             default:
187                 SSLConsumer consumer = consumers.get(plaintext.contentType);
188                 if (consumer != null) {
189                     consumer.consume(this, plaintext.fragment);
190                 } else {
191                     throw fatal(Alert.UNEXPECTED_MESSAGE,
192                         &quot;Unexpected content: &quot; + plaintext.contentType);
193                 }
</pre>
<hr />
<pre>
483 
484         // For TLS 1.2 and prior version, it is required to respond with
485         // a close_notify alert of its own and close down the connection
486         // immediately, discarding any pending writes.
487         if (!isOutboundClosed()) {
488             boolean needCloseNotify = SSLConfiguration.acknowledgeCloseNotify;
489             if (!needCloseNotify) {
490                 if (isNegotiated) {
491                     if (!protocolVersion.useTLS13PlusSpec()) {
492                         needCloseNotify = true;
493                     }
494                 } else if (handshakeContext != null) {  // initial handshake
495                     ProtocolVersion pv = handshakeContext.negotiatedProtocol;
496                     if (pv == null || (!pv.useTLS13PlusSpec())) {
497                         needCloseNotify = true;
498                     }
499                 }
500             }
501 
502             if (needCloseNotify) {
<span class="line-modified">503                 outputRecord.recordLock.lock();</span>
<span class="line-added">504                 try {</span>
505                     try {
506                         // send a close_notify alert
507                         warning(Alert.CLOSE_NOTIFY);
508                     } finally {
509                         outputRecord.close();
510                     }
<span class="line-added">511                 } finally {</span>
<span class="line-added">512                     outputRecord.recordLock.unlock();</span>
513                 }
514             }
515         }
516     }
517 
518     // Initiate a inbound close when the handshake is not started.
519     private void initiateInboundClose() throws IOException {
520         if (!isInboundClosed()) {
521             inputRecord.close();
522         }
523     }
524 
525     // Close outbound, no more data should be received from the underlying
526     // transportation connection.
527     void closeOutbound() {
528         if (isOutboundClosed()) {
529             return;
530         }
531 
532         try {
533              initiateOutboundClose();
534         } catch (IOException ioe) {
535             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
536                 SSLLogger.warning(&quot;outbound closure failed&quot;, ioe);
537             }
538         }
539     }
540 
541     // Initiate a close by sending a close_notify alert.
542     private void initiateOutboundClose() throws IOException {
543         boolean useUserCanceled = false;
544         if (!isNegotiated &amp;&amp; (handshakeContext != null) &amp;&amp; !peerUserCanceled) {
545             // initial handshake
546             useUserCanceled = true;
547         }
548 
549         // Need a lock here so that the user_canceled alert and the
550         // close_notify alert can be delivered together.
<span class="line-modified">551         outputRecord.recordLock.lock();</span>
<span class="line-added">552         try {</span>
553             try {
554                 // send a user_canceled alert if needed.
555                 if (useUserCanceled) {
556                     warning(Alert.USER_CANCELED);
557                 }
558 
559                 // send a close_notify alert
560                 warning(Alert.CLOSE_NOTIFY);
561             } finally {
562                 outputRecord.close();
563             }
<span class="line-added">564         } finally {</span>
<span class="line-added">565             outputRecord.recordLock.unlock();</span>
566         }
567     }
568 
569     // Note; HandshakeStatus.FINISHED status is retrieved in other places.
570     HandshakeStatus getHandshakeStatus() {
571         if (!outputRecord.isEmpty()) {
572             // If no handshaking, special case to wrap alters or
573             // post-handshake messages.
574             return HandshakeStatus.NEED_WRAP;
575         } else if (isOutboundClosed() &amp;&amp; isInboundClosed()) {
576             return HandshakeStatus.NOT_HANDSHAKING;
577         } else if (handshakeContext != null) {
578             if (!handshakeContext.delegatedActions.isEmpty()) {
579                 return HandshakeStatus.NEED_TASK;
580             } else if (!isInboundClosed()) {
581                 if (sslContext.isDTLS() &amp;&amp;
582                         !inputRecord.isEmpty()) {
583                     return HandshakeStatus.NEED_UNWRAP_AGAIN;
584                 } else {
585                     return HandshakeStatus.NEED_UNWRAP;
</pre>
</td>
</tr>
</table>
<center><a href="SupportedGroupsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TrustStoreManager.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
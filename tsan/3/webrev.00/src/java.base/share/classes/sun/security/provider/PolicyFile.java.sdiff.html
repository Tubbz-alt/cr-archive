<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/provider/PolicyFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MoreDrbgParameters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PolicyParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/provider/PolicyFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  25 
  26 package sun.security.provider;
  27 
  28 import java.io.*;
  29 import java.lang.reflect.*;
  30 import java.net.MalformedURLException;
  31 import java.net.URL;
  32 import java.net.URI;
  33 import java.nio.file.Files;
  34 import java.nio.file.Path;
  35 import java.util.*;
  36 import java.security.*;
  37 import java.security.cert.Certificate;
  38 import java.security.cert.X509Certificate;
  39 import javax.security.auth.Subject;
  40 import javax.security.auth.x500.X500Principal;
  41 import java.net.SocketPermission;
  42 import java.net.NetPermission;
  43 import java.util.concurrent.ConcurrentHashMap;
  44 import jdk.internal.access.JavaSecurityAccess;
<span class="line-removed">  45 import static jdk.internal.access.JavaSecurityAccess.ProtectionDomainCache;</span>
  46 import jdk.internal.access.SharedSecrets;
  47 import jdk.internal.util.StaticProperty;
  48 import sun.security.util.*;
  49 import sun.net.www.ParseUtil;
  50 



  51 /**
  52  * This class represents a default Policy implementation for the
  53  * &quot;JavaPolicy&quot; type.
  54  *
  55  * &lt;p&gt; This object stores the policy for the entire Java runtime,
  56  * and is the amalgamation of multiple static policy
  57  * configurations that resides in files.
  58  * The algorithm for locating the policy file(s) and reading their
  59  * information into this &lt;code&gt;Policy&lt;/code&gt; object is:
  60  *
  61  * &lt;ol&gt;
  62  * &lt;li&gt;
  63  *   Read in and load the default policy file named
  64  *   &amp;lt;JAVA_HOME&amp;gt;/lib/security/default.policy. &amp;lt;JAVA_HOME&amp;gt; refers
  65  *   to the value of the java.home system property, and specifies the directory
  66  *   where the JRE is installed. This policy file grants permissions to the
  67  *   modules loaded by the platform class loader. If the default policy file
  68  *   cannot be loaded, a fatal InternalError is thrown as these permissions
  69  *   are needed in order for the runtime to operate correctly.
  70  * &lt;li&gt;
</pre>
<hr />
<pre>
 542         } catch (PolicyParser.ParsingException pe) {
 543             // record bad policy file to avoid later reparsing it
 544             badPolicyURLs.add(policy);
 545             Object[] source = {policy, pe.getNonlocalizedMessage()};
 546             System.err.println(LocalizedMessage.getNonlocalized
 547                 (POLICY + &quot;.error.parsing.policy.message&quot;, source));
 548             if (debug != null) {
 549                 pe.printStackTrace();
 550             }
 551         } catch (Exception e) {
 552             if (debug != null) {
 553                 debug.println(&quot;error parsing &quot;+policy);
 554                 debug.println(e.toString());
 555                 e.printStackTrace();
 556             }
 557         }
 558 
 559         return false;
 560     }
 561 
<span class="line-modified"> 562     private InputStreamReader getInputStreamReader(InputStream is)</span>
<span class="line-removed"> 563                               throws IOException {</span>
 564         /*
 565          * Read in policy using UTF-8 by default.
 566          *
 567          * Check non-standard system property to see if the default encoding
 568          * should be used instead.
 569          */
 570         return (notUtf8)
 571             ? new InputStreamReader(is)
<span class="line-modified"> 572             : new InputStreamReader(is, &quot;UTF-8&quot;);</span>
 573     }
 574 
 575     private void initStaticPolicy(final PolicyInfo newInfo) {
 576         if (debug != null) {
 577             debug.println(&quot;Initializing with static permissions&quot;);
 578         }
 579         AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 580             @Override
 581             public Void run() {
 582                 PolicyEntry pe = new PolicyEntry(new CodeSource(null,
 583                     (Certificate[]) null));
 584                 pe.add(SecurityConstants.LOCAL_LISTEN_PERMISSION);
 585                 pe.add(new PropertyPermission(&quot;java.version&quot;,
 586                     SecurityConstants.PROPERTY_READ_ACTION));
 587                 pe.add(new PropertyPermission(&quot;java.vendor&quot;,
 588                     SecurityConstants.PROPERTY_READ_ACTION));
 589                 pe.add(new PropertyPermission(&quot;java.vendor.url&quot;,
 590                     SecurityConstants.PROPERTY_READ_ACTION));
 591                 pe.add(new PropertyPermission(&quot;java.class.version&quot;,
 592                     SecurityConstants.PROPERTY_READ_ACTION));
</pre>
<hr />
<pre>
1925         @Override public String toString(){
1926             StringBuilder sb = new StringBuilder();
1927             sb.append(ResourcesMgr.getString(&quot;LPARAM&quot;));
1928             sb.append(getCodeSource());
1929             sb.append(&quot;\n&quot;);
1930             for (int j = 0; j &lt; permissions.size(); j++) {
1931                 Permission p = permissions.get(j);
1932                 sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));
1933                 sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));
1934                 sb.append(p);
1935                 sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));
1936             }
1937             sb.append(ResourcesMgr.getString(&quot;RPARAM&quot;));
1938             sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));
1939             return sb.toString();
1940         }
1941     }
1942 
1943     private static class SelfPermission extends Permission {
1944 

1945         private static final long serialVersionUID = -8315562579967246806L;
1946 
1947         /**
1948          * The class name of the Permission class that will be
1949          * created when this self permission is expanded .
1950          *
1951          * @serial
1952          */
1953         private String type;
1954 
1955         /**
1956          * The permission name.
1957          *
1958          * @serial
1959          */
1960         private String name;
1961 
1962         /**
1963          * The actions of the permission.
1964          *
</pre>
</td>
<td>
<hr />
<pre>
  25 
  26 package sun.security.provider;
  27 
  28 import java.io.*;
  29 import java.lang.reflect.*;
  30 import java.net.MalformedURLException;
  31 import java.net.URL;
  32 import java.net.URI;
  33 import java.nio.file.Files;
  34 import java.nio.file.Path;
  35 import java.util.*;
  36 import java.security.*;
  37 import java.security.cert.Certificate;
  38 import java.security.cert.X509Certificate;
  39 import javax.security.auth.Subject;
  40 import javax.security.auth.x500.X500Principal;
  41 import java.net.SocketPermission;
  42 import java.net.NetPermission;
  43 import java.util.concurrent.ConcurrentHashMap;
  44 import jdk.internal.access.JavaSecurityAccess;

  45 import jdk.internal.access.SharedSecrets;
  46 import jdk.internal.util.StaticProperty;
  47 import sun.security.util.*;
  48 import sun.net.www.ParseUtil;
  49 
<span class="line-added">  50 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added">  51 import static jdk.internal.access.JavaSecurityAccess.ProtectionDomainCache;</span>
<span class="line-added">  52 </span>
  53 /**
  54  * This class represents a default Policy implementation for the
  55  * &quot;JavaPolicy&quot; type.
  56  *
  57  * &lt;p&gt; This object stores the policy for the entire Java runtime,
  58  * and is the amalgamation of multiple static policy
  59  * configurations that resides in files.
  60  * The algorithm for locating the policy file(s) and reading their
  61  * information into this &lt;code&gt;Policy&lt;/code&gt; object is:
  62  *
  63  * &lt;ol&gt;
  64  * &lt;li&gt;
  65  *   Read in and load the default policy file named
  66  *   &amp;lt;JAVA_HOME&amp;gt;/lib/security/default.policy. &amp;lt;JAVA_HOME&amp;gt; refers
  67  *   to the value of the java.home system property, and specifies the directory
  68  *   where the JRE is installed. This policy file grants permissions to the
  69  *   modules loaded by the platform class loader. If the default policy file
  70  *   cannot be loaded, a fatal InternalError is thrown as these permissions
  71  *   are needed in order for the runtime to operate correctly.
  72  * &lt;li&gt;
</pre>
<hr />
<pre>
 544         } catch (PolicyParser.ParsingException pe) {
 545             // record bad policy file to avoid later reparsing it
 546             badPolicyURLs.add(policy);
 547             Object[] source = {policy, pe.getNonlocalizedMessage()};
 548             System.err.println(LocalizedMessage.getNonlocalized
 549                 (POLICY + &quot;.error.parsing.policy.message&quot;, source));
 550             if (debug != null) {
 551                 pe.printStackTrace();
 552             }
 553         } catch (Exception e) {
 554             if (debug != null) {
 555                 debug.println(&quot;error parsing &quot;+policy);
 556                 debug.println(e.toString());
 557                 e.printStackTrace();
 558             }
 559         }
 560 
 561         return false;
 562     }
 563 
<span class="line-modified"> 564     private InputStreamReader getInputStreamReader(InputStream is) {</span>

 565         /*
 566          * Read in policy using UTF-8 by default.
 567          *
 568          * Check non-standard system property to see if the default encoding
 569          * should be used instead.
 570          */
 571         return (notUtf8)
 572             ? new InputStreamReader(is)
<span class="line-modified"> 573             : new InputStreamReader(is, UTF_8);</span>
 574     }
 575 
 576     private void initStaticPolicy(final PolicyInfo newInfo) {
 577         if (debug != null) {
 578             debug.println(&quot;Initializing with static permissions&quot;);
 579         }
 580         AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 581             @Override
 582             public Void run() {
 583                 PolicyEntry pe = new PolicyEntry(new CodeSource(null,
 584                     (Certificate[]) null));
 585                 pe.add(SecurityConstants.LOCAL_LISTEN_PERMISSION);
 586                 pe.add(new PropertyPermission(&quot;java.version&quot;,
 587                     SecurityConstants.PROPERTY_READ_ACTION));
 588                 pe.add(new PropertyPermission(&quot;java.vendor&quot;,
 589                     SecurityConstants.PROPERTY_READ_ACTION));
 590                 pe.add(new PropertyPermission(&quot;java.vendor.url&quot;,
 591                     SecurityConstants.PROPERTY_READ_ACTION));
 592                 pe.add(new PropertyPermission(&quot;java.class.version&quot;,
 593                     SecurityConstants.PROPERTY_READ_ACTION));
</pre>
<hr />
<pre>
1926         @Override public String toString(){
1927             StringBuilder sb = new StringBuilder();
1928             sb.append(ResourcesMgr.getString(&quot;LPARAM&quot;));
1929             sb.append(getCodeSource());
1930             sb.append(&quot;\n&quot;);
1931             for (int j = 0; j &lt; permissions.size(); j++) {
1932                 Permission p = permissions.get(j);
1933                 sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));
1934                 sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));
1935                 sb.append(p);
1936                 sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));
1937             }
1938             sb.append(ResourcesMgr.getString(&quot;RPARAM&quot;));
1939             sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));
1940             return sb.toString();
1941         }
1942     }
1943 
1944     private static class SelfPermission extends Permission {
1945 
<span class="line-added">1946         @java.io.Serial</span>
1947         private static final long serialVersionUID = -8315562579967246806L;
1948 
1949         /**
1950          * The class name of the Permission class that will be
1951          * created when this self permission is expanded .
1952          *
1953          * @serial
1954          */
1955         private String type;
1956 
1957         /**
1958          * The permission name.
1959          *
1960          * @serial
1961          */
1962         private String name;
1963 
1964         /**
1965          * The actions of the permission.
1966          *
</pre>
</td>
</tr>
</table>
<center><a href="MoreDrbgParameters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PolicyParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ChannelInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;





  30 import java.net.DatagramSocket;
  31 import java.net.Inet4Address;
  32 import java.net.Inet6Address;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.NetworkInterface;
  36 import java.net.PortUnreachableException;
  37 import java.net.ProtocolFamily;
  38 import java.net.SocketAddress;
  39 import java.net.SocketOption;

  40 import java.net.StandardProtocolFamily;
  41 import java.net.StandardSocketOptions;
  42 import java.nio.ByteBuffer;
  43 import java.nio.channels.AlreadyBoundException;
  44 import java.nio.channels.AlreadyConnectedException;
  45 import java.nio.channels.AsynchronousCloseException;
  46 import java.nio.channels.ClosedChannelException;
  47 import java.nio.channels.DatagramChannel;

  48 import java.nio.channels.MembershipKey;
  49 import java.nio.channels.NotYetConnectedException;
  50 import java.nio.channels.SelectionKey;

  51 import java.nio.channels.spi.SelectorProvider;


  52 import java.util.Collections;

  53 import java.util.HashSet;

  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;

  57 

  58 import sun.net.ResourceManager;
  59 import sun.net.ext.ExtendedSocketOptions;

  60 
  61 /**
  62  * An implementation of DatagramChannels.
  63  */
  64 
  65 class DatagramChannelImpl
  66     extends DatagramChannel
  67     implements SelChImpl
  68 {
  69     // Used to make native read and write calls
<span class="line-modified">  70     private static NativeDispatcher nd = new DatagramDispatcher();</span>



  71 
  72     // The protocol family of the socket
  73     private final ProtocolFamily family;
  74 
  75     // Our file descriptor
  76     private final FileDescriptor fd;
  77     private final int fdVal;
  78 
<span class="line-modified">  79     // Cached InetAddress and port for unconnected DatagramChannels</span>
<span class="line-modified">  80     // used by receive0</span>
<span class="line-modified">  81     private InetAddress cachedSenderInetAddress;</span>
<span class="line-modified">  82     private int cachedSenderPort;</span>








  83 
  84     // Lock held by current reading or connecting thread
  85     private final ReentrantLock readLock = new ReentrantLock();
  86 
  87     // Lock held by current writing or connecting thread
  88     private final ReentrantLock writeLock = new ReentrantLock();
  89 
  90     // Lock held by any thread that modifies the state fields declared below
  91     // DO NOT invoke a blocking I/O operation while holding this lock!
  92     private final Object stateLock = new Object();
  93 
  94     // -- The following fields are protected by stateLock
  95 
  96     // State (does not necessarily increase monotonically)
  97     private static final int ST_UNCONNECTED = 0;
  98     private static final int ST_CONNECTED = 1;
  99     private static final int ST_CLOSING = 2;
<span class="line-modified"> 100     private static final int ST_KILLPENDING = 3;</span>
<span class="line-removed"> 101     private static final int ST_KILLED = 4;</span>
 102     private int state;
 103 
 104     // IDs of native threads doing reads and writes, for signalling
 105     private long readerThread;
 106     private long writerThread;
 107 
<span class="line-modified"> 108     // Binding and remote address (when connected)</span>
 109     private InetSocketAddress localAddress;
 110     private InetSocketAddress remoteAddress;
 111 
<span class="line-modified"> 112     // Our socket adaptor, if any</span>
<span class="line-modified"> 113     private DatagramSocket socket;</span>












 114 
 115     // Multicast support
 116     private MembershipRegistry registry;
 117 
 118     // set true when socket is bound and SO_REUSEADDRESS is emulated
 119     private boolean reuseAddressEmulated;
 120 
 121     // set true/false when socket is already bound and SO_REUSEADDR is emulated
 122     private boolean isReuseAddress;
 123 
 124     // -- End of fields protected by stateLock
 125 
<span class="line-modified"> 126     public DatagramChannelImpl(SelectorProvider sp)</span>
<span class="line-modified"> 127         throws IOException</span>
<span class="line-modified"> 128     {</span>
<span class="line-modified"> 129         super(sp);</span>
<span class="line-modified"> 130         ResourceManager.beforeUdpCreate();</span>
<span class="line-modified"> 131         try {</span>
<span class="line-removed"> 132             this.family = Net.isIPv6Available()</span>
<span class="line-removed"> 133                     ? StandardProtocolFamily.INET6</span>
<span class="line-removed"> 134                     : StandardProtocolFamily.INET;</span>
<span class="line-removed"> 135             this.fd = Net.socket(family, false);</span>
<span class="line-removed"> 136             this.fdVal = IOUtil.fdVal(fd);</span>
<span class="line-removed"> 137         } catch (IOException ioe) {</span>
<span class="line-removed"> 138             ResourceManager.afterUdpClose();</span>
<span class="line-removed"> 139             throw ioe;</span>
<span class="line-removed"> 140         }</span>
 141     }
 142 
<span class="line-modified"> 143     public DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family)</span>
 144         throws IOException
 145     {
 146         super(sp);

 147         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
 148         if ((family != StandardProtocolFamily.INET) &amp;&amp;
<span class="line-modified"> 149             (family != StandardProtocolFamily.INET6)) {</span>
 150             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
 151         }
<span class="line-modified"> 152         if (family == StandardProtocolFamily.INET6) {</span>
<span class="line-modified"> 153             if (!Net.isIPv6Available()) {</span>
<span class="line-removed"> 154                 throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-removed"> 155             }</span>
 156         }
 157 



 158         ResourceManager.beforeUdpCreate();

 159         try {

 160             this.family = family;
<span class="line-modified"> 161             this.fd = Net.socket(family, false);</span>
 162             this.fdVal = IOUtil.fdVal(fd);
<span class="line-modified"> 163         } catch (IOException ioe) {</span>
<span class="line-modified"> 164             ResourceManager.afterUdpClose();</span>
<span class="line-modified"> 165             throw ioe;</span>















 166         }



 167     }
 168 
<span class="line-modified"> 169     public DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)</span>
 170         throws IOException
 171     {
 172         super(sp);
 173 
<span class="line-modified"> 174         // increment UDP count to match decrement when closing</span>

 175         ResourceManager.beforeUdpCreate();






























 176 
<span class="line-removed"> 177         this.family = Net.isIPv6Available()</span>
<span class="line-removed"> 178                 ? StandardProtocolFamily.INET6</span>
<span class="line-removed"> 179                 : StandardProtocolFamily.INET;</span>
<span class="line-removed"> 180         this.fd = fd;</span>
<span class="line-removed"> 181         this.fdVal = IOUtil.fdVal(fd);</span>
 182         synchronized (stateLock) {
 183             this.localAddress = Net.localAddress(fd);
 184         }
 185     }
 186 
 187     // @throws ClosedChannelException if channel is closed
 188     private void ensureOpen() throws ClosedChannelException {
 189         if (!isOpen())
 190             throw new ClosedChannelException();
 191     }
 192 
 193     @Override
 194     public DatagramSocket socket() {
<span class="line-modified"> 195         synchronized (stateLock) {</span>
<span class="line-modified"> 196             if (socket == null)</span>
<span class="line-modified"> 197                 socket = DatagramSocketAdaptor.create(this);</span>
<span class="line-modified"> 198             return socket;</span>


 199         }

 200     }
 201 
 202     @Override
 203     public SocketAddress getLocalAddress() throws IOException {
 204         synchronized (stateLock) {
 205             ensureOpen();
 206             // Perform security check before returning address
 207             return Net.getRevealedLocalAddress(localAddress);
 208         }
 209     }
 210 
 211     @Override
 212     public SocketAddress getRemoteAddress() throws IOException {
 213         synchronized (stateLock) {
 214             ensureOpen();
 215             return remoteAddress;
 216         }
 217     }
 218 


































 219     @Override
 220     public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
 221         throws IOException
 222     {
 223         Objects.requireNonNull(name);
 224         if (!supportedOptions().contains(name))
 225             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);


 226 
 227         synchronized (stateLock) {
 228             ensureOpen();
 229 
<span class="line-modified"> 230             if (name == StandardSocketOptions.IP_TOS ||</span>
<span class="line-modified"> 231                 name == StandardSocketOptions.IP_MULTICAST_TTL ||</span>
<span class="line-modified"> 232                 name == StandardSocketOptions.IP_MULTICAST_LOOP)</span>
<span class="line-modified"> 233             {</span>
<span class="line-modified"> 234                 // options are protocol dependent</span>
<span class="line-modified"> 235                 Net.setSocketOption(fd, family, name, value);</span>
<span class="line-modified"> 236                 return this;</span>
<span class="line-modified"> 237             }</span>

 238 

 239             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
<span class="line-modified"> 240                 if (value == null)</span>
<span class="line-modified"> 241                     throw new IllegalArgumentException(&quot;Cannot set IP_MULTICAST_IF to &#39;null&#39;&quot;);</span>
<span class="line-removed"> 242                 NetworkInterface interf = (NetworkInterface)value;</span>
 243                 if (family == StandardProtocolFamily.INET6) {
 244                     int index = interf.getIndex();
 245                     if (index == -1)
 246                         throw new IOException(&quot;Network interface cannot be identified&quot;);
 247                     Net.setInterface6(fd, index);
<span class="line-modified"> 248                 } else {</span>

 249                     // need IPv4 address to identify interface
 250                     Inet4Address target = Net.anyInet4Address(interf);
<span class="line-modified"> 251                     if (target == null)</span>






 252                         throw new IOException(&quot;Network interface not configured for IPv4&quot;);
<span class="line-modified"> 253                     int targetAddress = Net.inet4AsInt(target);</span>
<span class="line-removed"> 254                     Net.setInterface4(fd, targetAddress);</span>
 255                 }
 256                 return this;
 257             }


 258             if (name == StandardSocketOptions.SO_REUSEADDR
 259                 &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
 260                 reuseAddressEmulated = true;
 261                 this.isReuseAddress = (Boolean)value;
 262             }
 263 
 264             // remaining options don&#39;t need any special handling
<span class="line-modified"> 265             Net.setSocketOption(fd, Net.UNSPEC, name, value);</span>






 266             return this;
 267         }
 268     }
 269 
 270     @Override
 271     @SuppressWarnings(&quot;unchecked&quot;)
 272     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 273         throws IOException
 274     {
 275         Objects.requireNonNull(name);
 276         if (!supportedOptions().contains(name))
 277             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 278 
 279         synchronized (stateLock) {
 280             ensureOpen();
 281 
<span class="line-modified"> 282             if (name == StandardSocketOptions.IP_TOS ||</span>
<span class="line-removed"> 283                 name == StandardSocketOptions.IP_MULTICAST_TTL ||</span>
<span class="line-removed"> 284                 name == StandardSocketOptions.IP_MULTICAST_LOOP)</span>
<span class="line-removed"> 285             {</span>
<span class="line-removed"> 286                 return (T) Net.getSocketOption(fd, family, name);</span>
<span class="line-removed"> 287             }</span>
 288 
 289             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 290                 if (family == StandardProtocolFamily.INET) {
 291                     int address = Net.getInterface4(fd);
 292                     if (address == 0)
 293                         return null;    // default interface
 294 
 295                     InetAddress ia = Net.inet4FromInt(address);
 296                     NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 297                     if (ni == null)
 298                         throw new IOException(&quot;Unable to map address to interface&quot;);
 299                     return (T) ni;
 300                 } else {
 301                     int index = Net.getInterface6(fd);
 302                     if (index == 0)
 303                         return null;    // default interface
 304 
 305                     NetworkInterface ni = NetworkInterface.getByIndex(index);
 306                     if (ni == null)
 307                         throw new IOException(&quot;Unable to map index to interface&quot;);
 308                     return (T) ni;
 309                 }
 310             }
 311 
 312             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
<span class="line-modified"> 313                 return (T)Boolean.valueOf(isReuseAddress);</span>
 314             }
 315 
 316             // no special handling
<span class="line-modified"> 317             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span>
 318         }
 319     }
 320 
 321     private static class DefaultOptionsHolder {
 322         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 323 
 324         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 325             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 326             set.add(StandardSocketOptions.SO_SNDBUF);
 327             set.add(StandardSocketOptions.SO_RCVBUF);
 328             set.add(StandardSocketOptions.SO_REUSEADDR);
 329             if (Net.isReusePortAvailable()) {
 330                 set.add(StandardSocketOptions.SO_REUSEPORT);
 331             }
 332             set.add(StandardSocketOptions.SO_BROADCAST);
 333             set.add(StandardSocketOptions.IP_TOS);
 334             set.add(StandardSocketOptions.IP_MULTICAST_IF);
 335             set.add(StandardSocketOptions.IP_MULTICAST_TTL);
 336             set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
 337             set.addAll(ExtendedSocketOptions.datagramSocketOptions());
</pre>
<hr />
<pre>
 340     }
 341 
 342     @Override
 343     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 344         return DefaultOptionsHolder.defaultOptions;
 345     }
 346 
 347     /**
 348      * Marks the beginning of a read operation that might block.
 349      *
 350      * @param blocking true if configured blocking
 351      * @param mustBeConnected true if the socket must be connected
 352      * @return remote address if connected
 353      * @throws ClosedChannelException if the channel is closed
 354      * @throws NotYetConnectedException if mustBeConnected and not connected
 355      * @throws IOException if socket not bound and cannot be bound
 356      */
 357     private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
 358         throws IOException
 359     {
<span class="line-modified"> 360         if (blocking) {</span>
 361             // set hook for Thread.interrupt
 362             begin();
 363         }
 364         SocketAddress remote;
 365         synchronized (stateLock) {
 366             ensureOpen();
 367             remote = remoteAddress;
 368             if ((remote == null) &amp;&amp; mustBeConnected)
 369                 throw new NotYetConnectedException();
 370             if (localAddress == null)
 371                 bindInternal(null);
 372             if (blocking)
 373                 readerThread = NativeThread.current();
 374         }
 375         return remote;
 376     }
 377 
 378     /**
 379      * Marks the end of a read operation that may have blocked.
 380      *
 381      * @throws AsynchronousCloseException if the channel was closed asynchronously
 382      */
 383     private void endRead(boolean blocking, boolean completed)
 384         throws AsynchronousCloseException
 385     {
 386         if (blocking) {
 387             synchronized (stateLock) {
 388                 readerThread = 0;
<span class="line-removed"> 389                 // notify any thread waiting in implCloseSelectableChannel</span>
 390                 if (state == ST_CLOSING) {
<span class="line-modified"> 391                     stateLock.notifyAll();</span>
 392                 }
 393             }
<span class="line-modified"> 394             // remove hook for Thread.interrupt</span>
<span class="line-modified"> 395             end(completed);</span>




 396         }
 397     }
 398 
<span class="line-removed"> 399     private SocketAddress sender;       // Set by receive0 (## ugh)</span>
<span class="line-removed"> 400 </span>
 401     @Override
 402     public SocketAddress receive(ByteBuffer dst) throws IOException {
 403         if (dst.isReadOnly())
 404             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
<span class="line-removed"> 405 </span>
 406         readLock.lock();
 407         try {
 408             boolean blocking = isBlocking();
<span class="line-modified"> 409             int n = 0;</span>
<span class="line-removed"> 410             ByteBuffer bb = null;</span>
 411             try {
 412                 SocketAddress remote = beginRead(blocking, false);
 413                 boolean connected = (remote != null);
 414                 SecurityManager sm = System.getSecurityManager();
 415                 if (connected || (sm == null)) {
 416                     // connected or no security manager
<span class="line-modified"> 417                     do {</span>
<span class="line-modified"> 418                         n = receive(fd, dst, connected);</span>
<span class="line-modified"> 419                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 420                     if (n == IOStatus.UNAVAILABLE)</span>
<span class="line-modified"> 421                         return null;</span>
<span class="line-removed"> 422                 } else {</span>
<span class="line-removed"> 423                     // Cannot receive into user&#39;s buffer when running with a</span>
<span class="line-removed"> 424                     // security manager and not connected</span>
<span class="line-removed"> 425                     bb = Util.getTemporaryDirectBuffer(dst.remaining());</span>
<span class="line-removed"> 426                     for (;;) {</span>
<span class="line-removed"> 427                         do {</span>
<span class="line-removed"> 428                             n = receive(fd, bb, connected);</span>
<span class="line-removed"> 429                         } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-removed"> 430                         if (n == IOStatus.UNAVAILABLE)</span>
<span class="line-removed"> 431                             return null;</span>
<span class="line-removed"> 432                         InetSocketAddress isa = (InetSocketAddress)sender;</span>
<span class="line-removed"> 433                         try {</span>
<span class="line-removed"> 434                             sm.checkAccept(isa.getAddress().getHostAddress(),</span>
<span class="line-removed"> 435                                            isa.getPort());</span>
<span class="line-removed"> 436                         } catch (SecurityException se) {</span>
<span class="line-removed"> 437                             // Ignore packet</span>
<span class="line-removed"> 438                             bb.clear();</span>
<span class="line-removed"> 439                             n = 0;</span>
<span class="line-removed"> 440                             continue;</span>
 441                         }
<span class="line-removed"> 442                         bb.flip();</span>
<span class="line-removed"> 443                         dst.put(bb);</span>
<span class="line-removed"> 444                         break;</span>
 445                     }







 446                 }
<span class="line-removed"> 447                 assert sender != null;</span>
 448                 return sender;
 449             } finally {
<span class="line-modified"> 450                 if (bb != null)</span>
<span class="line-modified"> 451                     Util.releaseTemporaryDirectBuffer(bb);</span>
<span class="line-modified"> 452                 endRead(blocking, n &gt; 0);</span>
<span class="line-modified"> 453                 assert IOStatus.check(n);</span>









































 454             }








































 455         } finally {
 456             readLock.unlock();
 457         }
 458     }
 459 
<span class="line-modified"> 460     private int receive(FileDescriptor fd, ByteBuffer dst, boolean connected)</span>





 461         throws IOException
 462     {






























































 463         int pos = dst.position();
 464         int lim = dst.limit();
 465         assert (pos &lt;= lim);
 466         int rem = (pos &lt;= lim ? lim - pos : 0);
 467         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
<span class="line-modified"> 468             return receiveIntoNativeBuffer(fd, dst, rem, pos, connected);</span>
 469 
 470         // Substitute a native buffer. If the supplied buffer is empty
 471         // we must instead use a nonempty buffer, otherwise the call
 472         // will not block waiting for a datagram on some platforms.
 473         int newSize = Math.max(rem, 1);
 474         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 475         try {
<span class="line-modified"> 476             int n = receiveIntoNativeBuffer(fd, bb, newSize, 0, connected);</span>
 477             bb.flip();
 478             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 479                 dst.put(bb);
 480             return n;
 481         } finally {
 482             Util.releaseTemporaryDirectBuffer(bb);
 483         }
 484     }
 485 
<span class="line-modified"> 486     private int receiveIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb,</span>
<span class="line-modified"> 487                                         int rem, int pos, boolean connected)</span>
 488         throws IOException
 489     {
<span class="line-modified"> 490         int n = receive0(fd, ((DirectBuffer)bb).address() + pos, rem, connected);</span>



 491         if (n &gt; 0)
 492             bb.position(pos + n);
 493         return n;
 494     }
 495 




















 496     public int send(ByteBuffer src, SocketAddress target)
 497         throws IOException
 498     {
 499         Objects.requireNonNull(src);
 500         InetSocketAddress isa = Net.checkAddress(target, family);
 501 
 502         writeLock.lock();
 503         try {
 504             boolean blocking = isBlocking();
<span class="line-modified"> 505             int n = 0;</span>

 506             try {
 507                 SocketAddress remote = beginWrite(blocking, false);
 508                 if (remote != null) {
 509                     // connected
 510                     if (!target.equals(remote)) {
 511                         throw new AlreadyConnectedException();
 512                     }
<span class="line-modified"> 513                     do {</span>
<span class="line-modified"> 514                         n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified"> 515                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>





 516                 } else {
 517                     // not connected
 518                     SecurityManager sm = System.getSecurityManager();

 519                     if (sm != null) {
<span class="line-removed"> 520                         InetAddress ia = isa.getAddress();</span>
 521                         if (ia.isMulticastAddress()) {
 522                             sm.checkMulticast(ia);
 523                         } else {
 524                             sm.checkConnect(ia.getHostAddress(), isa.getPort());
 525                         }
 526                     }
<span class="line-modified"> 527                     do {</span>
<span class="line-modified"> 528                         n = send(fd, src, isa);</span>
<span class="line-modified"> 529                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>







 530                 }
 531             } finally {
<span class="line-modified"> 532                 endWrite(blocking, n &gt; 0);</span>
<span class="line-removed"> 533                 assert IOStatus.check(n);</span>
 534             }

 535             return IOStatus.normalize(n);
 536         } finally {
 537             writeLock.unlock();
 538         }
 539     }
 540 



















 541     private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
 542         throws IOException
 543     {
 544         if (src instanceof DirectBuffer)
 545             return sendFromNativeBuffer(fd, src, target);
 546 
 547         // Substitute a native buffer
 548         int pos = src.position();
 549         int lim = src.limit();
 550         assert (pos &lt;= lim);
 551         int rem = (pos &lt;= lim ? lim - pos : 0);
 552 
 553         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 554         try {
 555             bb.put(src);
 556             bb.flip();
 557             // Do not update src until we see how many bytes were written
 558             src.position(pos);
 559 
 560             int n = sendFromNativeBuffer(fd, bb, target);
 561             if (n &gt; 0) {
 562                 // now update src
 563                 src.position(pos + n);
 564             }
 565             return n;
 566         } finally {
 567             Util.releaseTemporaryDirectBuffer(bb);
 568         }
 569     }
 570 
 571     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 572                                      InetSocketAddress target)
 573         throws IOException
 574     {
 575         int pos = bb.position();
 576         int lim = bb.limit();
 577         assert (pos &lt;= lim);
 578         int rem = (pos &lt;= lim ? lim - pos : 0);
 579 
<span class="line-removed"> 580         boolean preferIPv6 = (family != StandardProtocolFamily.INET);</span>
 581         int written;
 582         try {
<span class="line-modified"> 583             written = send0(preferIPv6, fd, ((DirectBuffer)bb).address() + pos,</span>
<span class="line-modified"> 584                             rem, target.getAddress(), target.getPort());</span>

 585         } catch (PortUnreachableException pue) {
 586             if (isConnected())
 587                 throw pue;
 588             written = rem;
 589         }
 590         if (written &gt; 0)
 591             bb.position(pos + written);
 592         return written;
 593     }
 594 

















 595     @Override
 596     public int read(ByteBuffer buf) throws IOException {
 597         Objects.requireNonNull(buf);
 598 
 599         readLock.lock();
 600         try {
 601             boolean blocking = isBlocking();
 602             int n = 0;
 603             try {
 604                 beginRead(blocking, true);
<span class="line-modified"> 605                 do {</span>
<span class="line-modified"> 606                     n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-modified"> 607                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 608 </span>



 609             } finally {
 610                 endRead(blocking, n &gt; 0);
 611                 assert IOStatus.check(n);
 612             }
 613             return IOStatus.normalize(n);
 614         } finally {
 615             readLock.unlock();
 616         }
 617     }
 618 
 619     @Override
 620     public long read(ByteBuffer[] dsts, int offset, int length)
 621         throws IOException
 622     {
 623         Objects.checkFromIndexSize(offset, length, dsts.length);
 624 
 625         readLock.lock();
 626         try {
 627             boolean blocking = isBlocking();
 628             long n = 0;
 629             try {
 630                 beginRead(blocking, true);
<span class="line-modified"> 631                 do {</span>
<span class="line-modified"> 632                     n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified"> 633                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 634 </span>



 635             } finally {
 636                 endRead(blocking, n &gt; 0);
 637                 assert IOStatus.check(n);
 638             }
 639             return IOStatus.normalize(n);
 640         } finally {
 641             readLock.unlock();
 642         }
 643     }
 644 
 645     /**
 646      * Marks the beginning of a write operation that might block.
 647      * @param blocking true if configured blocking
 648      * @param mustBeConnected true if the socket must be connected
 649      * @return remote address if connected
 650      * @throws ClosedChannelException if the channel is closed
 651      * @throws NotYetConnectedException if mustBeConnected and not connected
 652      * @throws IOException if socket not bound and cannot be bound
 653      */
 654     private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
 655         throws IOException
 656     {
<span class="line-modified"> 657         if (blocking) {</span>
 658             // set hook for Thread.interrupt
 659             begin();
 660         }
 661         SocketAddress remote;
 662         synchronized (stateLock) {
 663             ensureOpen();
 664             remote = remoteAddress;
 665             if ((remote == null) &amp;&amp; mustBeConnected)
 666                 throw new NotYetConnectedException();
 667             if (localAddress == null)
 668                 bindInternal(null);
 669             if (blocking)
 670                 writerThread = NativeThread.current();
 671         }
 672         return remote;
 673     }
 674 
 675     /**
 676      * Marks the end of a write operation that may have blocked.
 677      *
 678      * @throws AsynchronousCloseException if the channel was closed asynchronously
 679      */
 680     private void endWrite(boolean blocking, boolean completed)
 681         throws AsynchronousCloseException
 682     {
 683         if (blocking) {
 684             synchronized (stateLock) {
 685                 writerThread = 0;
<span class="line-removed"> 686                 // notify any thread waiting in implCloseSelectableChannel</span>
 687                 if (state == ST_CLOSING) {
<span class="line-modified"> 688                     stateLock.notifyAll();</span>
 689                 }
 690             }
<span class="line-modified"> 691             // remove hook for Thread.interrupt</span>
<span class="line-modified"> 692             end(completed);</span>





 693         }
 694     }
 695 
 696     @Override
 697     public int write(ByteBuffer buf) throws IOException {
 698         Objects.requireNonNull(buf);
 699 
 700         writeLock.lock();
 701         try {
 702             boolean blocking = isBlocking();
 703             int n = 0;
 704             try {
 705                 beginWrite(blocking, true);
<span class="line-modified"> 706                 do {</span>
<span class="line-modified"> 707                     n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-modified"> 708                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>




 709             } finally {
 710                 endWrite(blocking, n &gt; 0);
 711                 assert IOStatus.check(n);
 712             }
 713             return IOStatus.normalize(n);
 714         } finally {
 715             writeLock.unlock();
 716         }
 717     }
 718 
 719     @Override
 720     public long write(ByteBuffer[] srcs, int offset, int length)
 721         throws IOException
 722     {
 723         Objects.checkFromIndexSize(offset, length, srcs.length);
 724 
 725         writeLock.lock();
 726         try {
 727             boolean blocking = isBlocking();
 728             long n = 0;
 729             try {
 730                 beginWrite(blocking, true);
<span class="line-modified"> 731                 do {</span>
<span class="line-modified"> 732                     n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified"> 733                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>




 734             } finally {
 735                 endWrite(blocking, n &gt; 0);
 736                 assert IOStatus.check(n);
 737             }
 738             return IOStatus.normalize(n);
 739         } finally {
 740             writeLock.unlock();
 741         }
 742     }
 743 
 744     @Override
 745     protected void implConfigureBlocking(boolean block) throws IOException {
 746         readLock.lock();
 747         try {
 748             writeLock.lock();
 749             try {
<span class="line-modified"> 750                 synchronized (stateLock) {</span>
<span class="line-removed"> 751                     ensureOpen();</span>
<span class="line-removed"> 752                     IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed"> 753                 }</span>
 754             } finally {
 755                 writeLock.unlock();
 756             }
 757         } finally {
 758             readLock.unlock();
 759         }
 760     }
 761 






























 762     InetSocketAddress localAddress() {
 763         synchronized (stateLock) {
 764             return localAddress;
 765         }
 766     }
 767 
 768     InetSocketAddress remoteAddress() {
 769         synchronized (stateLock) {
 770             return remoteAddress;
 771         }
 772     }
 773 
 774     @Override
 775     public DatagramChannel bind(SocketAddress local) throws IOException {
 776         readLock.lock();
 777         try {
 778             writeLock.lock();
 779             try {
 780                 synchronized (stateLock) {
 781                     ensureOpen();
 782                     if (localAddress != null)
 783                         throw new AlreadyBoundException();
 784                     bindInternal(local);
 785                 }
 786             } finally {
 787                 writeLock.unlock();
 788             }
 789         } finally {
 790             readLock.unlock();
 791         }
 792         return this;
 793     }
 794 
 795     private void bindInternal(SocketAddress local) throws IOException {
<span class="line-modified"> 796         assert Thread.holdsLock(stateLock) &amp;&amp; (localAddress == null);</span>
 797 
 798         InetSocketAddress isa;
 799         if (local == null) {
 800             // only Inet4Address allowed with IPv4 socket
 801             if (family == StandardProtocolFamily.INET) {
 802                 isa = new InetSocketAddress(InetAddress.getByName(&quot;0.0.0.0&quot;), 0);
 803             } else {
 804                 isa = new InetSocketAddress(0);
 805             }
 806         } else {
 807             isa = Net.checkAddress(local, family);
 808         }
 809         SecurityManager sm = System.getSecurityManager();
 810         if (sm != null)
 811             sm.checkListen(isa.getPort());
 812 
 813         Net.bind(family, fd, isa.getAddress(), isa.getPort());
 814         localAddress = Net.localAddress(fd);
 815     }
 816 
 817     @Override
 818     public boolean isConnected() {
 819         synchronized (stateLock) {
 820             return (state == ST_CONNECTED);
 821         }
 822     }
 823 
 824     @Override
 825     public DatagramChannel connect(SocketAddress sa) throws IOException {










 826         InetSocketAddress isa = Net.checkAddress(sa, family);
 827         SecurityManager sm = System.getSecurityManager();
 828         if (sm != null) {
 829             InetAddress ia = isa.getAddress();
 830             if (ia.isMulticastAddress()) {
 831                 sm.checkMulticast(ia);
 832             } else {
 833                 sm.checkConnect(ia.getHostAddress(), isa.getPort());
 834                 sm.checkAccept(ia.getHostAddress(), isa.getPort());
 835             }
 836         }
 837 
 838         readLock.lock();
 839         try {
 840             writeLock.lock();
 841             try {
 842                 synchronized (stateLock) {
 843                     ensureOpen();
<span class="line-modified"> 844                     if (state == ST_CONNECTED)</span>
 845                         throw new AlreadyConnectedException();
 846 








 847                     int n = Net.connect(family,
 848                                         fd,
 849                                         isa.getAddress(),
 850                                         isa.getPort());
 851                     if (n &lt;= 0)
 852                         throw new Error();      // Can&#39;t happen
 853 
 854                     // connected
 855                     remoteAddress = isa;
 856                     state = ST_CONNECTED;
 857 
 858                     // refresh local address
 859                     localAddress = Net.localAddress(fd);
 860 
 861                     // flush any packets already received.
 862                     boolean blocking = isBlocking();
 863                     if (blocking) {
 864                         IOUtil.configureBlocking(fd, false);
 865                     }
 866                     try {
 867                         ByteBuffer buf = ByteBuffer.allocate(100);
<span class="line-modified"> 868                         while (receive(buf) != null) {</span>
 869                             buf.clear();
 870                         }
 871                     } finally {
 872                         if (blocking) {
 873                             IOUtil.configureBlocking(fd, true);
 874                         }
 875                     }
 876                 }
 877             } finally {
 878                 writeLock.unlock();
 879             }
 880         } finally {
 881             readLock.unlock();
 882         }
 883         return this;
 884     }
 885 
 886     @Override
 887     public DatagramChannel disconnect() throws IOException {
 888         readLock.lock();
 889         try {
 890             writeLock.lock();
 891             try {
 892                 synchronized (stateLock) {
 893                     if (!isOpen() || (state != ST_CONNECTED))
 894                         return this;
 895 
 896                     // disconnect socket
 897                     boolean isIPv6 = (family == StandardProtocolFamily.INET6);
 898                     disconnect0(fd, isIPv6);
 899 
 900                     // no longer connected
 901                     remoteAddress = null;
 902                     state = ST_UNCONNECTED;
 903 
<span class="line-modified"> 904                     // refresh local address</span>
 905                     localAddress = Net.localAddress(fd);











 906                 }
 907             } finally {
 908                 writeLock.unlock();
 909             }
 910         } finally {
 911             readLock.unlock();
 912         }
 913         return this;
 914     }
 915 
































































































































 916     /**
 917      * Joins channel&#39;s socket to the given group/interface and
 918      * optional source address.
 919      */
 920     private MembershipKey innerJoin(InetAddress group,
 921                                     NetworkInterface interf,
 922                                     InetAddress source)
 923         throws IOException
 924     {
 925         if (!group.isMulticastAddress())
 926             throw new IllegalArgumentException(&quot;Group not a multicast address&quot;);
 927 
 928         // check multicast address is compatible with this socket
 929         if (group instanceof Inet4Address) {
 930             if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.canIPv6SocketJoinIPv4Group())
 931                 throw new IllegalArgumentException(&quot;IPv6 socket cannot join IPv4 multicast group&quot;);
 932         } else if (group instanceof Inet6Address) {
 933             if (family != StandardProtocolFamily.INET6)
 934                 throw new IllegalArgumentException(&quot;Only IPv6 sockets can join IPv6 multicast group&quot;);
 935         } else {
</pre>
<hr />
<pre>
1038                 if (key instanceof MembershipKeyImpl.Type6) {
1039                     MembershipKeyImpl.Type6 key6 =
1040                         (MembershipKeyImpl.Type6)key;
1041                     Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
1042                 } else {
1043                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
1044                     Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
1045                         key4.source());
1046                 }
1047             } catch (IOException ioe) {
1048                 // should not happen
1049                 throw new AssertionError(ioe);
1050             }
1051 
1052             key.invalidate();
1053             registry.remove(key);
1054         }
1055     }
1056 
1057     /**
<span class="line-modified">1058      * Block datagrams from given source if a memory to receive all</span>
<span class="line-modified">1059      * datagrams.</span>















1060      */
1061     void block(MembershipKeyImpl key, InetAddress source)
1062         throws IOException
1063     {
1064         assert key.channel() == this;
1065         assert key.sourceAddress() == null;
1066 
1067         synchronized (stateLock) {
1068             if (!key.isValid())
1069                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1070             if (source.isAnyLocalAddress())
1071                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1072             if (source.isMulticastAddress())
1073                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1074             if (source.getClass() != key.group().getClass())
1075                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1076 
1077             int n;
1078             if (key instanceof MembershipKeyImpl.Type6) {
1079                  MembershipKeyImpl.Type6 key6 =
1080                     (MembershipKeyImpl.Type6)key;
1081                 n = Net.block6(fd, key6.groupAddress(), key6.index(),
1082                                Net.inet6AsByteArray(source));
1083             } else {
1084                 MembershipKeyImpl.Type4 key4 =
1085                     (MembershipKeyImpl.Type4)key;
1086                 n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
1087                                Net.inet4AsInt(source));
1088             }
1089             if (n == IOStatus.UNAVAILABLE) {
1090                 // ancient kernel
1091                 throw new UnsupportedOperationException();
1092             }
1093         }
1094     }
1095 
1096     /**
<span class="line-modified">1097      * Unblock given source.</span>
1098      */
1099     void unblock(MembershipKeyImpl key, InetAddress source) {
1100         assert key.channel() == this;
1101         assert key.sourceAddress() == null;
1102 
1103         synchronized (stateLock) {
1104             if (!key.isValid())
1105                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1106 
1107             try {
1108                 if (key instanceof MembershipKeyImpl.Type6) {
1109                     MembershipKeyImpl.Type6 key6 =
1110                         (MembershipKeyImpl.Type6)key;
1111                     Net.unblock6(fd, key6.groupAddress(), key6.index(),
1112                                  Net.inet6AsByteArray(source));
1113                 } else {
1114                     MembershipKeyImpl.Type4 key4 =
1115                         (MembershipKeyImpl.Type4)key;
1116                     Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
1117                                  Net.inet4AsInt(source));
1118                 }
1119             } catch (IOException ioe) {
1120                 // should not happen
1121                 throw new AssertionError(ioe);
1122             }
1123         }
1124     }
1125 
1126     /**
<span class="line-modified">1127      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">1128      *</span>
<span class="line-removed">1129      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-removed">1130      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-removed">1131      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-removed">1132      * complete quickly.</span>
<span class="line-removed">1133      *</span>
<span class="line-removed">1134      * The socket is closed by this method when it is not registered with a</span>
<span class="line-removed">1135      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-removed">1136      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed">1137      * to blocking mode before the key is flushed from the Selector.</span>
1138      */
<span class="line-modified">1139     @Override</span>
<span class="line-modified">1140     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">1141         assert !isOpen();</span>












1142 
<span class="line-modified">1143         boolean blocking;</span>
<span class="line-modified">1144         boolean interrupted = false;</span>








1145 
<span class="line-modified">1146         // set state to ST_CLOSING and invalid membership keys</span>







1147         synchronized (stateLock) {
1148             assert state &lt; ST_CLOSING;
<span class="line-removed">1149             blocking = isBlocking();</span>
1150             state = ST_CLOSING;
1151 
1152             // if member of any multicast groups then invalidate the keys
1153             if (registry != null)
1154                 registry.invalidateAll();
<span class="line-removed">1155         }</span>
1156 
<span class="line-modified">1157         // wait for any outstanding I/O operations to complete</span>
<span class="line-removed">1158         if (blocking) {</span>
<span class="line-removed">1159             synchronized (stateLock) {</span>
<span class="line-removed">1160                 assert state == ST_CLOSING;</span>
1161                 long reader = readerThread;
1162                 long writer = writerThread;
1163                 if (reader != 0 || writer != 0) {
1164                     nd.preClose(fd);
<span class="line-removed">1165 </span>
1166                     if (reader != 0)
1167                         NativeThread.signal(reader);
1168                     if (writer != 0)
1169                         NativeThread.signal(writer);
<span class="line-removed">1170 </span>
<span class="line-removed">1171                     // wait for blocking I/O operations to end</span>
<span class="line-removed">1172                     while (readerThread != 0 || writerThread != 0) {</span>
<span class="line-removed">1173                         try {</span>
<span class="line-removed">1174                             stateLock.wait();</span>
<span class="line-removed">1175                         } catch (InterruptedException e) {</span>
<span class="line-removed">1176                             interrupted = true;</span>
<span class="line-removed">1177                         }</span>
<span class="line-removed">1178                     }</span>
1179                 }
1180             }
<span class="line-removed">1181         } else {</span>
<span class="line-removed">1182             // non-blocking mode: wait for read/write to complete</span>
<span class="line-removed">1183             readLock.lock();</span>
<span class="line-removed">1184             try {</span>
<span class="line-removed">1185                 writeLock.lock();</span>
<span class="line-removed">1186                 writeLock.unlock();</span>
<span class="line-removed">1187             } finally {</span>
<span class="line-removed">1188                 readLock.unlock();</span>
<span class="line-removed">1189             }</span>
1190         }

1191 
<span class="line-modified">1192         // set state to ST_KILLPENDING</span>






1193         synchronized (stateLock) {
<span class="line-modified">1194             assert state == ST_CLOSING;</span>
<span class="line-modified">1195             state = ST_KILLPENDING;</span>




1196         }
1197 
<span class="line-modified">1198         // close socket if not registered with Selector</span>
<span class="line-modified">1199         if (!isRegistered())</span>
<span class="line-modified">1200             kill();</span>








1201 
<span class="line-modified">1202         // restore interrupt status</span>
<span class="line-modified">1203         if (interrupted)</span>
<span class="line-modified">1204             Thread.currentThread().interrupt();</span>








1205     }
1206 
1207     @Override
<span class="line-modified">1208     public void kill() throws IOException {</span>
1209         synchronized (stateLock) {
<span class="line-modified">1210             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">1211                 state = ST_KILLED;</span>
<span class="line-removed">1212                 try {</span>
<span class="line-removed">1213                     nd.close(fd);</span>
<span class="line-removed">1214                 } finally {</span>
<span class="line-removed">1215                     // notify resource manager</span>
<span class="line-removed">1216                     ResourceManager.afterUdpClose();</span>
<span class="line-removed">1217                 }</span>
1218             }
1219         }
1220     }
1221 
<span class="line-removed">1222     @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-removed">1223     protected void finalize() throws IOException {</span>
<span class="line-removed">1224         // fd is null if constructor threw exception</span>
<span class="line-removed">1225         if (fd != null)</span>
<span class="line-removed">1226             close();</span>
<span class="line-removed">1227     }</span>
<span class="line-removed">1228 </span>
1229     /**
1230      * Translates native poll revent set into a ready operation set
1231      */
1232     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1233         int intOps = ski.nioInterestOps();
1234         int oldOps = ski.nioReadyOps();
1235         int newOps = initialOps;
1236 
1237         if ((ops &amp; Net.POLLNVAL) != 0) {
1238             // This should only happen if this channel is pre-closed while a
1239             // selection operation is in progress
1240             // ## Throw an error if this channel has not been pre-closed
1241             return false;
1242         }
1243 
1244         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1245             newOps = intOps;
1246             ski.nioReadyOps(newOps);
1247             return (newOps &amp; ~oldOps) != 0;
1248         }
</pre>
<hr />
<pre>
1250         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1251             ((intOps &amp; SelectionKey.OP_READ) != 0))
1252             newOps |= SelectionKey.OP_READ;
1253 
1254         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1255             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
1256             newOps |= SelectionKey.OP_WRITE;
1257 
1258         ski.nioReadyOps(newOps);
1259         return (newOps &amp; ~oldOps) != 0;
1260     }
1261 
1262     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1263         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1264     }
1265 
1266     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1267         return translateReadyOps(ops, 0, ski);
1268     }
1269 
<span class="line-removed">1270     /**</span>
<span class="line-removed">1271      * Poll this channel&#39;s socket for reading up to the given timeout.</span>
<span class="line-removed">1272      * @return {@code true} if the socket is polled</span>
<span class="line-removed">1273      */</span>
<span class="line-removed">1274     boolean pollRead(long timeout) throws IOException {</span>
<span class="line-removed">1275         boolean blocking = isBlocking();</span>
<span class="line-removed">1276         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>
<span class="line-removed">1277 </span>
<span class="line-removed">1278         readLock.lock();</span>
<span class="line-removed">1279         try {</span>
<span class="line-removed">1280             boolean polled = false;</span>
<span class="line-removed">1281             try {</span>
<span class="line-removed">1282                 beginRead(blocking, false);</span>
<span class="line-removed">1283                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-removed">1284                 polled = (events != 0);</span>
<span class="line-removed">1285             } finally {</span>
<span class="line-removed">1286                 endRead(blocking, polled);</span>
<span class="line-removed">1287             }</span>
<span class="line-removed">1288             return polled;</span>
<span class="line-removed">1289         } finally {</span>
<span class="line-removed">1290             readLock.unlock();</span>
<span class="line-removed">1291         }</span>
<span class="line-removed">1292     }</span>
<span class="line-removed">1293 </span>
1294     /**
1295      * Translates an interest operation set into a native poll event set
1296      */
1297     public int translateInterestOps(int ops) {
1298         int newOps = 0;
1299         if ((ops &amp; SelectionKey.OP_READ) != 0)
1300             newOps |= Net.POLLIN;
1301         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1302             newOps |= Net.POLLOUT;
1303         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1304             newOps |= Net.POLLIN;
1305         return newOps;
1306     }
1307 
1308     public FileDescriptor getFD() {
1309         return fd;
1310     }
1311 
1312     public int getFDVal() {
1313         return fdVal;
1314     }
1315 
















1316 
1317     // -- Native methods --
1318 
<span class="line-removed">1319     private static native void initIDs();</span>
<span class="line-removed">1320 </span>
1321     private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
1322         throws IOException;
1323 
<span class="line-modified">1324     private native int receive0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">1325                                 boolean connected)</span>
1326         throws IOException;
1327 
<span class="line-modified">1328     private native int send0(boolean preferIPv6, FileDescriptor fd, long address,</span>
<span class="line-modified">1329                              int len, InetAddress addr, int port)</span>
1330         throws IOException;
1331 
1332     static {
1333         IOUtil.load();
<span class="line-removed">1334         initIDs();</span>
1335     }
1336 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
<span class="line-added">  30 import java.io.UncheckedIOException;</span>
<span class="line-added">  31 import java.lang.invoke.MethodHandles;</span>
<span class="line-added">  32 import java.lang.invoke.VarHandle;</span>
<span class="line-added">  33 import java.lang.ref.Cleaner.Cleanable;</span>
<span class="line-added">  34 import java.lang.reflect.Method;</span>
  35 import java.net.DatagramSocket;
  36 import java.net.Inet4Address;
  37 import java.net.Inet6Address;
  38 import java.net.InetAddress;
  39 import java.net.InetSocketAddress;
  40 import java.net.NetworkInterface;
  41 import java.net.PortUnreachableException;
  42 import java.net.ProtocolFamily;
  43 import java.net.SocketAddress;
  44 import java.net.SocketOption;
<span class="line-added">  45 import java.net.SocketTimeoutException;</span>
  46 import java.net.StandardProtocolFamily;
  47 import java.net.StandardSocketOptions;
  48 import java.nio.ByteBuffer;
  49 import java.nio.channels.AlreadyBoundException;
  50 import java.nio.channels.AlreadyConnectedException;
  51 import java.nio.channels.AsynchronousCloseException;
  52 import java.nio.channels.ClosedChannelException;
  53 import java.nio.channels.DatagramChannel;
<span class="line-added">  54 import java.nio.channels.IllegalBlockingModeException;</span>
  55 import java.nio.channels.MembershipKey;
  56 import java.nio.channels.NotYetConnectedException;
  57 import java.nio.channels.SelectionKey;
<span class="line-added">  58 import java.nio.channels.spi.AbstractSelectableChannel;</span>
  59 import java.nio.channels.spi.SelectorProvider;
<span class="line-added">  60 import java.security.AccessController;</span>
<span class="line-added">  61 import java.security.PrivilegedExceptionAction;</span>
  62 import java.util.Collections;
<span class="line-added">  63 import java.util.HashMap;</span>
  64 import java.util.HashSet;
<span class="line-added">  65 import java.util.Map;</span>
  66 import java.util.Objects;
  67 import java.util.Set;
  68 import java.util.concurrent.locks.ReentrantLock;
<span class="line-added">  69 import java.util.function.Consumer;</span>
  70 
<span class="line-added">  71 import jdk.internal.ref.CleanerFactory;</span>
  72 import sun.net.ResourceManager;
  73 import sun.net.ext.ExtendedSocketOptions;
<span class="line-added">  74 import sun.net.util.IPAddressUtil;</span>
  75 
  76 /**
  77  * An implementation of DatagramChannels.
  78  */
  79 
  80 class DatagramChannelImpl
  81     extends DatagramChannel
  82     implements SelChImpl
  83 {
  84     // Used to make native read and write calls
<span class="line-modified">  85     private static final NativeDispatcher nd = new DatagramDispatcher();</span>
<span class="line-added">  86 </span>
<span class="line-added">  87     // true if interruptible (can be false to emulate legacy DatagramSocket)</span>
<span class="line-added">  88     private final boolean interruptible;</span>
  89 
  90     // The protocol family of the socket
  91     private final ProtocolFamily family;
  92 
  93     // Our file descriptor
  94     private final FileDescriptor fd;
  95     private final int fdVal;
  96 
<span class="line-modified">  97     // Native sockaddrs and cached InetSocketAddress for receive, protected by readLock</span>
<span class="line-modified">  98     private NativeSocketAddress sourceSockAddr;</span>
<span class="line-modified">  99     private NativeSocketAddress cachedSockAddr;</span>
<span class="line-modified"> 100     private InetSocketAddress cachedInetSocketAddress;</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102     // Native sockaddr and cached objects for send, protected by writeLock</span>
<span class="line-added"> 103     private final NativeSocketAddress targetSockAddr;</span>
<span class="line-added"> 104     private InetSocketAddress previousTarget;</span>
<span class="line-added"> 105     private int previousSockAddrLength;</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107     // Cleaner to close file descriptor and free native socket address</span>
<span class="line-added"> 108     private final Cleanable cleaner;</span>
 109 
 110     // Lock held by current reading or connecting thread
 111     private final ReentrantLock readLock = new ReentrantLock();
 112 
 113     // Lock held by current writing or connecting thread
 114     private final ReentrantLock writeLock = new ReentrantLock();
 115 
 116     // Lock held by any thread that modifies the state fields declared below
 117     // DO NOT invoke a blocking I/O operation while holding this lock!
 118     private final Object stateLock = new Object();
 119 
 120     // -- The following fields are protected by stateLock
 121 
 122     // State (does not necessarily increase monotonically)
 123     private static final int ST_UNCONNECTED = 0;
 124     private static final int ST_CONNECTED = 1;
 125     private static final int ST_CLOSING = 2;
<span class="line-modified"> 126     private static final int ST_CLOSED = 3;</span>

 127     private int state;
 128 
 129     // IDs of native threads doing reads and writes, for signalling
 130     private long readerThread;
 131     private long writerThread;
 132 
<span class="line-modified"> 133     // Local and remote (connected) address</span>
 134     private InetSocketAddress localAddress;
 135     private InetSocketAddress remoteAddress;
 136 
<span class="line-modified"> 137     // Local address prior to connecting</span>
<span class="line-modified"> 138     private InetSocketAddress initialLocalAddress;</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140     // Socket adaptor, created lazily</span>
<span class="line-added"> 141     private static final VarHandle SOCKET;</span>
<span class="line-added"> 142     static {</span>
<span class="line-added"> 143         try {</span>
<span class="line-added"> 144             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-added"> 145             SOCKET = l.findVarHandle(DatagramChannelImpl.class, &quot;socket&quot;, DatagramSocket.class);</span>
<span class="line-added"> 146         } catch (Exception e) {</span>
<span class="line-added"> 147             throw new InternalError(e);</span>
<span class="line-added"> 148         }</span>
<span class="line-added"> 149     }</span>
<span class="line-added"> 150     private volatile DatagramSocket socket;</span>
 151 
 152     // Multicast support
 153     private MembershipRegistry registry;
 154 
 155     // set true when socket is bound and SO_REUSEADDRESS is emulated
 156     private boolean reuseAddressEmulated;
 157 
 158     // set true/false when socket is already bound and SO_REUSEADDR is emulated
 159     private boolean isReuseAddress;
 160 
 161     // -- End of fields protected by stateLock
 162 
<span class="line-modified"> 163 </span>
<span class="line-modified"> 164     DatagramChannelImpl(SelectorProvider sp, boolean interruptible) throws IOException {</span>
<span class="line-modified"> 165         this(sp, (Net.isIPv6Available()</span>
<span class="line-modified"> 166                 ? StandardProtocolFamily.INET6</span>
<span class="line-modified"> 167                 : StandardProtocolFamily.INET),</span>
<span class="line-modified"> 168                 interruptible);</span>









 169     }
 170 
<span class="line-modified"> 171     DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family, boolean interruptible)</span>
 172         throws IOException
 173     {
 174         super(sp);
<span class="line-added"> 175 </span>
 176         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
 177         if ((family != StandardProtocolFamily.INET) &amp;&amp;
<span class="line-modified"> 178                 (family != StandardProtocolFamily.INET6)) {</span>
 179             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
 180         }
<span class="line-modified"> 181         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-modified"> 182             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>


 183         }
 184 
<span class="line-added"> 185         FileDescriptor fd = null;</span>
<span class="line-added"> 186         NativeSocketAddress[] sockAddrs = null;</span>
<span class="line-added"> 187 </span>
 188         ResourceManager.beforeUdpCreate();
<span class="line-added"> 189         boolean initialized = false;</span>
 190         try {
<span class="line-added"> 191             this.interruptible = interruptible;</span>
 192             this.family = family;
<span class="line-modified"> 193             this.fd = fd = Net.socket(family, false);</span>
 194             this.fdVal = IOUtil.fdVal(fd);
<span class="line-modified"> 195 </span>
<span class="line-modified"> 196             sockAddrs = NativeSocketAddress.allocate(3);</span>
<span class="line-modified"> 197             readLock.lock();</span>
<span class="line-added"> 198             try {</span>
<span class="line-added"> 199                 this.sourceSockAddr = sockAddrs[0];</span>
<span class="line-added"> 200                 this.cachedSockAddr = sockAddrs[1];</span>
<span class="line-added"> 201             } finally {</span>
<span class="line-added"> 202                 readLock.unlock();</span>
<span class="line-added"> 203             }</span>
<span class="line-added"> 204             this.targetSockAddr = sockAddrs[2];</span>
<span class="line-added"> 205 </span>
<span class="line-added"> 206             initialized = true;</span>
<span class="line-added"> 207         } finally {</span>
<span class="line-added"> 208             if (!initialized) {</span>
<span class="line-added"> 209                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added"> 210                 if (fd != null) nd.close(fd);</span>
<span class="line-added"> 211                 ResourceManager.afterUdpClose();</span>
<span class="line-added"> 212             }</span>
 213         }
<span class="line-added"> 214 </span>
<span class="line-added"> 215         Runnable releaser = releaserFor(fd, sockAddrs);</span>
<span class="line-added"> 216         this.cleaner = CleanerFactory.cleaner().register(this, releaser);</span>
 217     }
 218 
<span class="line-modified"> 219     DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)</span>
 220         throws IOException
 221     {
 222         super(sp);
 223 
<span class="line-modified"> 224         NativeSocketAddress[] sockAddrs = null;</span>
<span class="line-added"> 225 </span>
 226         ResourceManager.beforeUdpCreate();
<span class="line-added"> 227         boolean initialized = false;</span>
<span class="line-added"> 228         try {</span>
<span class="line-added"> 229             this.interruptible = true;</span>
<span class="line-added"> 230             this.family = Net.isIPv6Available()</span>
<span class="line-added"> 231                     ? StandardProtocolFamily.INET6</span>
<span class="line-added"> 232                     : StandardProtocolFamily.INET;</span>
<span class="line-added"> 233             this.fd = fd;</span>
<span class="line-added"> 234             this.fdVal = IOUtil.fdVal(fd);</span>
<span class="line-added"> 235 </span>
<span class="line-added"> 236             sockAddrs = NativeSocketAddress.allocate(3);</span>
<span class="line-added"> 237             readLock.lock();</span>
<span class="line-added"> 238             try {</span>
<span class="line-added"> 239                 this.sourceSockAddr = sockAddrs[0];</span>
<span class="line-added"> 240                 this.cachedSockAddr = sockAddrs[1];</span>
<span class="line-added"> 241             } finally {</span>
<span class="line-added"> 242                 readLock.unlock();</span>
<span class="line-added"> 243             }</span>
<span class="line-added"> 244             this.targetSockAddr = sockAddrs[2];</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246             initialized = true;</span>
<span class="line-added"> 247         } finally {</span>
<span class="line-added"> 248             if (!initialized) {</span>
<span class="line-added"> 249                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added"> 250                 nd.close(fd);</span>
<span class="line-added"> 251                 ResourceManager.afterUdpClose();</span>
<span class="line-added"> 252             }</span>
<span class="line-added"> 253         }</span>
<span class="line-added"> 254 </span>
<span class="line-added"> 255         Runnable releaser = releaserFor(fd, sockAddrs);</span>
<span class="line-added"> 256         this.cleaner = CleanerFactory.cleaner().register(this, releaser);</span>
 257 





 258         synchronized (stateLock) {
 259             this.localAddress = Net.localAddress(fd);
 260         }
 261     }
 262 
 263     // @throws ClosedChannelException if channel is closed
 264     private void ensureOpen() throws ClosedChannelException {
 265         if (!isOpen())
 266             throw new ClosedChannelException();
 267     }
 268 
 269     @Override
 270     public DatagramSocket socket() {
<span class="line-modified"> 271         DatagramSocket socket = this.socket;</span>
<span class="line-modified"> 272         if (socket == null) {</span>
<span class="line-modified"> 273             socket = DatagramSocketAdaptor.create(this);</span>
<span class="line-modified"> 274             if (!SOCKET.compareAndSet(this, null, socket)) {</span>
<span class="line-added"> 275                 socket = this.socket;</span>
<span class="line-added"> 276             }</span>
 277         }
<span class="line-added"> 278         return socket;</span>
 279     }
 280 
 281     @Override
 282     public SocketAddress getLocalAddress() throws IOException {
 283         synchronized (stateLock) {
 284             ensureOpen();
 285             // Perform security check before returning address
 286             return Net.getRevealedLocalAddress(localAddress);
 287         }
 288     }
 289 
 290     @Override
 291     public SocketAddress getRemoteAddress() throws IOException {
 292         synchronized (stateLock) {
 293             ensureOpen();
 294             return remoteAddress;
 295         }
 296     }
 297 
<span class="line-added"> 298     /**</span>
<span class="line-added"> 299      * Returns the protocol family to specify to set/getSocketOption for the</span>
<span class="line-added"> 300      * given socket option.</span>
<span class="line-added"> 301      */</span>
<span class="line-added"> 302     private ProtocolFamily familyFor(SocketOption&lt;?&gt; name) {</span>
<span class="line-added"> 303         assert Thread.holdsLock(stateLock);</span>
<span class="line-added"> 304 </span>
<span class="line-added"> 305         // unspecified (most options)</span>
<span class="line-added"> 306         if (SocketOptionRegistry.findOption(name, Net.UNSPEC) != null)</span>
<span class="line-added"> 307             return Net.UNSPEC;</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309         // IPv4 socket</span>
<span class="line-added"> 310         if (family == StandardProtocolFamily.INET)</span>
<span class="line-added"> 311             return StandardProtocolFamily.INET;</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313         // IPv6 socket that is unbound</span>
<span class="line-added"> 314         if (localAddress == null)</span>
<span class="line-added"> 315             return StandardProtocolFamily.INET6;</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317         // IPv6 socket bound to wildcard or IPv6 address</span>
<span class="line-added"> 318         InetAddress address = localAddress.getAddress();</span>
<span class="line-added"> 319         if (address.isAnyLocalAddress() || (address instanceof Inet6Address))</span>
<span class="line-added"> 320             return StandardProtocolFamily.INET6;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322         // IPv6 socket bound to IPv4 address</span>
<span class="line-added"> 323         if (Net.canUseIPv6OptionsWithIPv4LocalAddress()) {</span>
<span class="line-added"> 324             // IPV6_XXX options can be used</span>
<span class="line-added"> 325             return StandardProtocolFamily.INET6;</span>
<span class="line-added"> 326         } else {</span>
<span class="line-added"> 327             // IPV6_XXX options cannot be used</span>
<span class="line-added"> 328             return StandardProtocolFamily.INET;</span>
<span class="line-added"> 329         }</span>
<span class="line-added"> 330     }</span>
<span class="line-added"> 331 </span>
 332     @Override
 333     public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
 334         throws IOException
 335     {
 336         Objects.requireNonNull(name);
 337         if (!supportedOptions().contains(name))
 338             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<span class="line-added"> 339         if (!name.type().isInstance(value))</span>
<span class="line-added"> 340             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
 341 
 342         synchronized (stateLock) {
 343             ensureOpen();
 344 
<span class="line-modified"> 345             ProtocolFamily family = familyFor(name);</span>
<span class="line-modified"> 346 </span>
<span class="line-modified"> 347             // Some platforms require both IPV6_XXX and IP_XXX socket options to</span>
<span class="line-modified"> 348             // be set when the channel&#39;s socket is IPv6 and it is used to send</span>
<span class="line-modified"> 349             // IPv4 multicast datagrams. The IP_XXX socket options are set on a</span>
<span class="line-modified"> 350             // best effort basis.</span>
<span class="line-modified"> 351             boolean needToSetIPv4Option = (family != Net.UNSPEC)</span>
<span class="line-modified"> 352                     &amp;&amp; (this.family == StandardProtocolFamily.INET6)</span>
<span class="line-added"> 353                     &amp;&amp; Net.shouldSetBothIPv4AndIPv6Options();</span>
 354 
<span class="line-added"> 355             // outgoing multicast interface</span>
 356             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
<span class="line-modified"> 357                 assert family != Net.UNSPEC;</span>
<span class="line-modified"> 358                 NetworkInterface interf = (NetworkInterface) value;</span>

 359                 if (family == StandardProtocolFamily.INET6) {
 360                     int index = interf.getIndex();
 361                     if (index == -1)
 362                         throw new IOException(&quot;Network interface cannot be identified&quot;);
 363                     Net.setInterface6(fd, index);
<span class="line-modified"> 364                 }</span>
<span class="line-added"> 365                 if (family == StandardProtocolFamily.INET || needToSetIPv4Option) {</span>
 366                     // need IPv4 address to identify interface
 367                     Inet4Address target = Net.anyInet4Address(interf);
<span class="line-modified"> 368                     if (target != null) {</span>
<span class="line-added"> 369                         try {</span>
<span class="line-added"> 370                             Net.setInterface4(fd, Net.inet4AsInt(target));</span>
<span class="line-added"> 371                         } catch (IOException ioe) {</span>
<span class="line-added"> 372                             if (family == StandardProtocolFamily.INET) throw ioe;</span>
<span class="line-added"> 373                         }</span>
<span class="line-added"> 374                     } else if (family == StandardProtocolFamily.INET) {</span>
 375                         throw new IOException(&quot;Network interface not configured for IPv4&quot;);
<span class="line-modified"> 376                     }</span>

 377                 }
 378                 return this;
 379             }
<span class="line-added"> 380 </span>
<span class="line-added"> 381             // SO_REUSEADDR needs special handling as it may be emulated</span>
 382             if (name == StandardSocketOptions.SO_REUSEADDR
 383                 &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
 384                 reuseAddressEmulated = true;
 385                 this.isReuseAddress = (Boolean)value;
 386             }
 387 
 388             // remaining options don&#39;t need any special handling
<span class="line-modified"> 389             Net.setSocketOption(fd, family, name, value);</span>
<span class="line-added"> 390             if (needToSetIPv4Option &amp;&amp; family != StandardProtocolFamily.INET) {</span>
<span class="line-added"> 391                 try {</span>
<span class="line-added"> 392                     Net.setSocketOption(fd, StandardProtocolFamily.INET, name, value);</span>
<span class="line-added"> 393                 } catch (IOException ignore) { }</span>
<span class="line-added"> 394             }</span>
<span class="line-added"> 395 </span>
 396             return this;
 397         }
 398     }
 399 
 400     @Override
 401     @SuppressWarnings(&quot;unchecked&quot;)
 402     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 403         throws IOException
 404     {
 405         Objects.requireNonNull(name);
 406         if (!supportedOptions().contains(name))
 407             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 408 
 409         synchronized (stateLock) {
 410             ensureOpen();
 411 
<span class="line-modified"> 412             ProtocolFamily family = familyFor(name);</span>





 413 
 414             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 415                 if (family == StandardProtocolFamily.INET) {
 416                     int address = Net.getInterface4(fd);
 417                     if (address == 0)
 418                         return null;    // default interface
 419 
 420                     InetAddress ia = Net.inet4FromInt(address);
 421                     NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 422                     if (ni == null)
 423                         throw new IOException(&quot;Unable to map address to interface&quot;);
 424                     return (T) ni;
 425                 } else {
 426                     int index = Net.getInterface6(fd);
 427                     if (index == 0)
 428                         return null;    // default interface
 429 
 430                     NetworkInterface ni = NetworkInterface.getByIndex(index);
 431                     if (ni == null)
 432                         throw new IOException(&quot;Unable to map index to interface&quot;);
 433                     return (T) ni;
 434                 }
 435             }
 436 
 437             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
<span class="line-modified"> 438                 return (T) Boolean.valueOf(isReuseAddress);</span>
 439             }
 440 
 441             // no special handling
<span class="line-modified"> 442             return (T) Net.getSocketOption(fd, family, name);</span>
 443         }
 444     }
 445 
 446     private static class DefaultOptionsHolder {
 447         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 448 
 449         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 450             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 451             set.add(StandardSocketOptions.SO_SNDBUF);
 452             set.add(StandardSocketOptions.SO_RCVBUF);
 453             set.add(StandardSocketOptions.SO_REUSEADDR);
 454             if (Net.isReusePortAvailable()) {
 455                 set.add(StandardSocketOptions.SO_REUSEPORT);
 456             }
 457             set.add(StandardSocketOptions.SO_BROADCAST);
 458             set.add(StandardSocketOptions.IP_TOS);
 459             set.add(StandardSocketOptions.IP_MULTICAST_IF);
 460             set.add(StandardSocketOptions.IP_MULTICAST_TTL);
 461             set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
 462             set.addAll(ExtendedSocketOptions.datagramSocketOptions());
</pre>
<hr />
<pre>
 465     }
 466 
 467     @Override
 468     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 469         return DefaultOptionsHolder.defaultOptions;
 470     }
 471 
 472     /**
 473      * Marks the beginning of a read operation that might block.
 474      *
 475      * @param blocking true if configured blocking
 476      * @param mustBeConnected true if the socket must be connected
 477      * @return remote address if connected
 478      * @throws ClosedChannelException if the channel is closed
 479      * @throws NotYetConnectedException if mustBeConnected and not connected
 480      * @throws IOException if socket not bound and cannot be bound
 481      */
 482     private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
 483         throws IOException
 484     {
<span class="line-modified"> 485         if (blocking &amp;&amp; interruptible) {</span>
 486             // set hook for Thread.interrupt
 487             begin();
 488         }
 489         SocketAddress remote;
 490         synchronized (stateLock) {
 491             ensureOpen();
 492             remote = remoteAddress;
 493             if ((remote == null) &amp;&amp; mustBeConnected)
 494                 throw new NotYetConnectedException();
 495             if (localAddress == null)
 496                 bindInternal(null);
 497             if (blocking)
 498                 readerThread = NativeThread.current();
 499         }
 500         return remote;
 501     }
 502 
 503     /**
 504      * Marks the end of a read operation that may have blocked.
 505      *
 506      * @throws AsynchronousCloseException if the channel was closed asynchronously
 507      */
 508     private void endRead(boolean blocking, boolean completed)
 509         throws AsynchronousCloseException
 510     {
 511         if (blocking) {
 512             synchronized (stateLock) {
 513                 readerThread = 0;

 514                 if (state == ST_CLOSING) {
<span class="line-modified"> 515                     tryFinishClose();</span>
 516                 }
 517             }
<span class="line-modified"> 518             if (interruptible) {</span>
<span class="line-modified"> 519                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)</span>
<span class="line-added"> 520                 end(completed);</span>
<span class="line-added"> 521             } else if (!completed &amp;&amp; !isOpen()) {</span>
<span class="line-added"> 522                 throw new AsynchronousCloseException();</span>
<span class="line-added"> 523             }</span>
 524         }
 525     }
 526 


 527     @Override
 528     public SocketAddress receive(ByteBuffer dst) throws IOException {
 529         if (dst.isReadOnly())
 530             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);

 531         readLock.lock();
 532         try {
 533             boolean blocking = isBlocking();
<span class="line-modified"> 534             SocketAddress sender = null;</span>

 535             try {
 536                 SocketAddress remote = beginRead(blocking, false);
 537                 boolean connected = (remote != null);
 538                 SecurityManager sm = System.getSecurityManager();
 539                 if (connected || (sm == null)) {
 540                     // connected or no security manager
<span class="line-modified"> 541                     int n = receive(dst, connected);</span>
<span class="line-modified"> 542                     if (blocking) {</span>
<span class="line-modified"> 543                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 544                             park(Net.POLLIN);</span>
<span class="line-modified"> 545                             n = receive(dst, connected);</span>



















 546                         }



 547                     }
<span class="line-added"> 548                     if (n &gt;= 0) {</span>
<span class="line-added"> 549                         // sender address is in socket address buffer</span>
<span class="line-added"> 550                         sender = sourceSocketAddress();</span>
<span class="line-added"> 551                     }</span>
<span class="line-added"> 552                 } else {</span>
<span class="line-added"> 553                     // security manager and unconnected</span>
<span class="line-added"> 554                     sender = untrustedReceive(dst);</span>
 555                 }

 556                 return sender;
 557             } finally {
<span class="line-modified"> 558                 endRead(blocking, (sender != null));</span>
<span class="line-modified"> 559             }</span>
<span class="line-modified"> 560         } finally {</span>
<span class="line-modified"> 561             readLock.unlock();</span>
<span class="line-added"> 562         }</span>
<span class="line-added"> 563     }</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565     /**</span>
<span class="line-added"> 566      * Receives a datagram into an untrusted buffer. When there is a security</span>
<span class="line-added"> 567      * manager set, and the socket is not connected, datagrams have to be received</span>
<span class="line-added"> 568      * into a buffer that is not accessible to the user. The datagram is copied</span>
<span class="line-added"> 569      * into the user&#39;s buffer when the sender address is accepted by the security</span>
<span class="line-added"> 570      * manager.</span>
<span class="line-added"> 571      */</span>
<span class="line-added"> 572     private SocketAddress untrustedReceive(ByteBuffer dst) throws IOException {</span>
<span class="line-added"> 573         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 574         assert readLock.isHeldByCurrentThread()</span>
<span class="line-added"> 575                 &amp;&amp; sm != null &amp;&amp; remoteAddress == null;</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577         ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());</span>
<span class="line-added"> 578         try {</span>
<span class="line-added"> 579             boolean blocking = isBlocking();</span>
<span class="line-added"> 580             for (;;) {</span>
<span class="line-added"> 581                 int n = receive(bb, false);</span>
<span class="line-added"> 582                 if (blocking) {</span>
<span class="line-added"> 583                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 584                         park(Net.POLLIN);</span>
<span class="line-added"> 585                         n = receive(bb, false);</span>
<span class="line-added"> 586                     }</span>
<span class="line-added"> 587                 }</span>
<span class="line-added"> 588                 if (n &gt;= 0) {</span>
<span class="line-added"> 589                     // sender address is in socket address buffer</span>
<span class="line-added"> 590                     InetSocketAddress isa = sourceSocketAddress();</span>
<span class="line-added"> 591                     try {</span>
<span class="line-added"> 592                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added"> 593                         bb.flip();</span>
<span class="line-added"> 594                         dst.put(bb);</span>
<span class="line-added"> 595                         return isa;</span>
<span class="line-added"> 596                     } catch (SecurityException se) {</span>
<span class="line-added"> 597                         // ignore datagram</span>
<span class="line-added"> 598                         bb.clear();</span>
<span class="line-added"> 599                     }</span>
<span class="line-added"> 600                 } else {</span>
<span class="line-added"> 601                     return null;</span>
<span class="line-added"> 602                 }</span>
 603             }
<span class="line-added"> 604         } finally {</span>
<span class="line-added"> 605             Util.releaseTemporaryDirectBuffer(bb);</span>
<span class="line-added"> 606         }</span>
<span class="line-added"> 607     }</span>
<span class="line-added"> 608 </span>
<span class="line-added"> 609     /**</span>
<span class="line-added"> 610      * Receives a datagram into the given buffer.</span>
<span class="line-added"> 611      *</span>
<span class="line-added"> 612      * @apiNote This method is for use by the socket adaptor. The buffer is</span>
<span class="line-added"> 613      * assumed to be trusted, meaning it is not accessible to user code.</span>
<span class="line-added"> 614      *</span>
<span class="line-added"> 615      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added"> 616      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added"> 617      */</span>
<span class="line-added"> 618     SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {</span>
<span class="line-added"> 619         readLock.lock();</span>
<span class="line-added"> 620         try {</span>
<span class="line-added"> 621             ensureOpen();</span>
<span class="line-added"> 622             if (!isBlocking())</span>
<span class="line-added"> 623                 throw new IllegalBlockingModeException();</span>
<span class="line-added"> 624             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 625             boolean connected = isConnected();</span>
<span class="line-added"> 626             SocketAddress sender;</span>
<span class="line-added"> 627             do {</span>
<span class="line-added"> 628                 if (nanos &gt; 0) {</span>
<span class="line-added"> 629                     sender = trustedBlockingReceive(dst, nanos);</span>
<span class="line-added"> 630                 } else {</span>
<span class="line-added"> 631                     sender = trustedBlockingReceive(dst);</span>
<span class="line-added"> 632                 }</span>
<span class="line-added"> 633                 // check sender when security manager set and not connected</span>
<span class="line-added"> 634                 if (sm != null &amp;&amp; !connected) {</span>
<span class="line-added"> 635                     InetSocketAddress isa = (InetSocketAddress) sender;</span>
<span class="line-added"> 636                     try {</span>
<span class="line-added"> 637                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added"> 638                     } catch (SecurityException e) {</span>
<span class="line-added"> 639                         sender = null;</span>
<span class="line-added"> 640                     }</span>
<span class="line-added"> 641                 }</span>
<span class="line-added"> 642             } while (sender == null);</span>
<span class="line-added"> 643             return sender;</span>
 644         } finally {
 645             readLock.unlock();
 646         }
 647     }
 648 
<span class="line-modified"> 649     /**</span>
<span class="line-added"> 650      * Receives a datagram into given buffer. This method is used to support</span>
<span class="line-added"> 651      * the socket adaptor. The buffer is assumed to be trusted.</span>
<span class="line-added"> 652      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added"> 653      */</span>
<span class="line-added"> 654     private SocketAddress trustedBlockingReceive(ByteBuffer dst)</span>
 655         throws IOException
 656     {
<span class="line-added"> 657         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();</span>
<span class="line-added"> 658         SocketAddress sender = null;</span>
<span class="line-added"> 659         try {</span>
<span class="line-added"> 660             SocketAddress remote = beginRead(true, false);</span>
<span class="line-added"> 661             boolean connected = (remote != null);</span>
<span class="line-added"> 662             int n = receive(dst, connected);</span>
<span class="line-added"> 663             while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 664                 park(Net.POLLIN);</span>
<span class="line-added"> 665                 n = receive(dst, connected);</span>
<span class="line-added"> 666             }</span>
<span class="line-added"> 667             if (n &gt;= 0) {</span>
<span class="line-added"> 668                 // sender address is in socket address buffer</span>
<span class="line-added"> 669                 sender = sourceSocketAddress();</span>
<span class="line-added"> 670             }</span>
<span class="line-added"> 671             return sender;</span>
<span class="line-added"> 672         } finally {</span>
<span class="line-added"> 673             endRead(true, (sender != null));</span>
<span class="line-added"> 674         }</span>
<span class="line-added"> 675     }</span>
<span class="line-added"> 676 </span>
<span class="line-added"> 677     /**</span>
<span class="line-added"> 678      * Receives a datagram into given buffer with a timeout. This method is</span>
<span class="line-added"> 679      * used to support the socket adaptor. The buffer is assumed to be trusted.</span>
<span class="line-added"> 680      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added"> 681      */</span>
<span class="line-added"> 682     private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)</span>
<span class="line-added"> 683         throws IOException</span>
<span class="line-added"> 684     {</span>
<span class="line-added"> 685         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();</span>
<span class="line-added"> 686         SocketAddress sender = null;</span>
<span class="line-added"> 687         try {</span>
<span class="line-added"> 688             SocketAddress remote = beginRead(true, false);</span>
<span class="line-added"> 689             boolean connected = (remote != null);</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691             // change socket to non-blocking</span>
<span class="line-added"> 692             lockedConfigureBlocking(false);</span>
<span class="line-added"> 693             try {</span>
<span class="line-added"> 694                 long startNanos = System.nanoTime();</span>
<span class="line-added"> 695                 int n = receive(dst, connected);</span>
<span class="line-added"> 696                 while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-added"> 697                     long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added"> 698                     if (remainingNanos &lt;= 0) {</span>
<span class="line-added"> 699                         throw new SocketTimeoutException(&quot;Receive timed out&quot;);</span>
<span class="line-added"> 700                     }</span>
<span class="line-added"> 701                     park(Net.POLLIN, remainingNanos);</span>
<span class="line-added"> 702                     n = receive(dst, connected);</span>
<span class="line-added"> 703                 }</span>
<span class="line-added"> 704                 if (n &gt;= 0) {</span>
<span class="line-added"> 705                     // sender address is in socket address buffer</span>
<span class="line-added"> 706                     sender = sourceSocketAddress();</span>
<span class="line-added"> 707                 }</span>
<span class="line-added"> 708                 return sender;</span>
<span class="line-added"> 709             } finally {</span>
<span class="line-added"> 710                 // restore socket to blocking mode (if channel is open)</span>
<span class="line-added"> 711                 tryLockedConfigureBlocking(true);</span>
<span class="line-added"> 712             }</span>
<span class="line-added"> 713         } finally {</span>
<span class="line-added"> 714             endRead(true, (sender != null));</span>
<span class="line-added"> 715         }</span>
<span class="line-added"> 716     }</span>
<span class="line-added"> 717 </span>
<span class="line-added"> 718     private int receive(ByteBuffer dst, boolean connected) throws IOException {</span>
 719         int pos = dst.position();
 720         int lim = dst.limit();
 721         assert (pos &lt;= lim);
 722         int rem = (pos &lt;= lim ? lim - pos : 0);
 723         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
<span class="line-modified"> 724             return receiveIntoNativeBuffer(dst, rem, pos, connected);</span>
 725 
 726         // Substitute a native buffer. If the supplied buffer is empty
 727         // we must instead use a nonempty buffer, otherwise the call
 728         // will not block waiting for a datagram on some platforms.
 729         int newSize = Math.max(rem, 1);
 730         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 731         try {
<span class="line-modified"> 732             int n = receiveIntoNativeBuffer(bb, newSize, 0, connected);</span>
 733             bb.flip();
 734             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 735                 dst.put(bb);
 736             return n;
 737         } finally {
 738             Util.releaseTemporaryDirectBuffer(bb);
 739         }
 740     }
 741 
<span class="line-modified"> 742     private int receiveIntoNativeBuffer(ByteBuffer bb, int rem, int pos,</span>
<span class="line-modified"> 743                                         boolean connected)</span>
 744         throws IOException
 745     {
<span class="line-modified"> 746         int n = receive0(fd,</span>
<span class="line-added"> 747                          ((DirectBuffer)bb).address() + pos, rem,</span>
<span class="line-added"> 748                          sourceSockAddr.address(),</span>
<span class="line-added"> 749                          connected);</span>
 750         if (n &gt; 0)
 751             bb.position(pos + n);
 752         return n;
 753     }
 754 
<span class="line-added"> 755     /**</span>
<span class="line-added"> 756      * Return an InetSocketAddress to represent the source/sender socket address</span>
<span class="line-added"> 757      * in sourceSockAddr. Returns the cached InetSocketAddress if the source</span>
<span class="line-added"> 758      * address is the same as the cached address.</span>
<span class="line-added"> 759      */</span>
<span class="line-added"> 760     private InetSocketAddress sourceSocketAddress() throws IOException {</span>
<span class="line-added"> 761         assert readLock.isHeldByCurrentThread();</span>
<span class="line-added"> 762         if (cachedInetSocketAddress != null &amp;&amp; sourceSockAddr.equals(cachedSockAddr)) {</span>
<span class="line-added"> 763             return cachedInetSocketAddress;</span>
<span class="line-added"> 764         }</span>
<span class="line-added"> 765         InetSocketAddress isa = sourceSockAddr.decode();</span>
<span class="line-added"> 766         // swap sourceSockAddr and cachedSockAddr</span>
<span class="line-added"> 767         NativeSocketAddress tmp = cachedSockAddr;</span>
<span class="line-added"> 768         cachedSockAddr = sourceSockAddr;</span>
<span class="line-added"> 769         sourceSockAddr = tmp;</span>
<span class="line-added"> 770         cachedInetSocketAddress = isa;</span>
<span class="line-added"> 771         return isa;</span>
<span class="line-added"> 772     }</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     @Override</span>
 775     public int send(ByteBuffer src, SocketAddress target)
 776         throws IOException
 777     {
 778         Objects.requireNonNull(src);
 779         InetSocketAddress isa = Net.checkAddress(target, family);
 780 
 781         writeLock.lock();
 782         try {
 783             boolean blocking = isBlocking();
<span class="line-modified"> 784             int n;</span>
<span class="line-added"> 785             boolean completed = false;</span>
 786             try {
 787                 SocketAddress remote = beginWrite(blocking, false);
 788                 if (remote != null) {
 789                     // connected
 790                     if (!target.equals(remote)) {
 791                         throw new AlreadyConnectedException();
 792                     }
<span class="line-modified"> 793                     n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified"> 794                     if (blocking) {</span>
<span class="line-modified"> 795                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 796                             park(Net.POLLOUT);</span>
<span class="line-added"> 797                             n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-added"> 798                         }</span>
<span class="line-added"> 799                     }</span>
<span class="line-added"> 800                     completed = (n &gt; 0);</span>
 801                 } else {
 802                     // not connected
 803                     SecurityManager sm = System.getSecurityManager();
<span class="line-added"> 804                     InetAddress ia = isa.getAddress();</span>
 805                     if (sm != null) {

 806                         if (ia.isMulticastAddress()) {
 807                             sm.checkMulticast(ia);
 808                         } else {
 809                             sm.checkConnect(ia.getHostAddress(), isa.getPort());
 810                         }
 811                     }
<span class="line-modified"> 812                     if (ia.isLinkLocalAddress())</span>
<span class="line-modified"> 813                         isa = IPAddressUtil.toScopedAddress(isa);</span>
<span class="line-modified"> 814                     n = send(fd, src, isa);</span>
<span class="line-added"> 815                     if (blocking) {</span>
<span class="line-added"> 816                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 817                             park(Net.POLLOUT);</span>
<span class="line-added"> 818                             n = send(fd, src, isa);</span>
<span class="line-added"> 819                         }</span>
<span class="line-added"> 820                     }</span>
<span class="line-added"> 821                     completed = (n &gt;= 0);</span>
 822                 }
 823             } finally {
<span class="line-modified"> 824                 endWrite(blocking, completed);</span>

 825             }
<span class="line-added"> 826             assert n &gt;= 0 || n == IOStatus.UNAVAILABLE;</span>
 827             return IOStatus.normalize(n);
 828         } finally {
 829             writeLock.unlock();
 830         }
 831     }
 832 
<span class="line-added"> 833     /**</span>
<span class="line-added"> 834      * Sends a datagram from the bytes in given buffer.</span>
<span class="line-added"> 835      *</span>
<span class="line-added"> 836      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added"> 837      *</span>
<span class="line-added"> 838      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added"> 839      */</span>
<span class="line-added"> 840     void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {</span>
<span class="line-added"> 841         writeLock.lock();</span>
<span class="line-added"> 842         try {</span>
<span class="line-added"> 843             ensureOpen();</span>
<span class="line-added"> 844             if (!isBlocking())</span>
<span class="line-added"> 845                 throw new IllegalBlockingModeException();</span>
<span class="line-added"> 846             send(src, target);</span>
<span class="line-added"> 847         } finally {</span>
<span class="line-added"> 848             writeLock.unlock();</span>
<span class="line-added"> 849         }</span>
<span class="line-added"> 850     }</span>
<span class="line-added"> 851 </span>
 852     private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
 853         throws IOException
 854     {
 855         if (src instanceof DirectBuffer)
 856             return sendFromNativeBuffer(fd, src, target);
 857 
 858         // Substitute a native buffer
 859         int pos = src.position();
 860         int lim = src.limit();
 861         assert (pos &lt;= lim);
 862         int rem = (pos &lt;= lim ? lim - pos : 0);
 863 
 864         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 865         try {
 866             bb.put(src);
 867             bb.flip();
 868             // Do not update src until we see how many bytes were written
 869             src.position(pos);
 870 
 871             int n = sendFromNativeBuffer(fd, bb, target);
 872             if (n &gt; 0) {
 873                 // now update src
 874                 src.position(pos + n);
 875             }
 876             return n;
 877         } finally {
 878             Util.releaseTemporaryDirectBuffer(bb);
 879         }
 880     }
 881 
 882     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 883                                      InetSocketAddress target)
 884         throws IOException
 885     {
 886         int pos = bb.position();
 887         int lim = bb.limit();
 888         assert (pos &lt;= lim);
 889         int rem = (pos &lt;= lim ? lim - pos : 0);
 890 

 891         int written;
 892         try {
<span class="line-modified"> 893             int addressLen = targetSocketAddress(target);</span>
<span class="line-modified"> 894             written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,</span>
<span class="line-added"> 895                             targetSockAddr.address(), addressLen);</span>
 896         } catch (PortUnreachableException pue) {
 897             if (isConnected())
 898                 throw pue;
 899             written = rem;
 900         }
 901         if (written &gt; 0)
 902             bb.position(pos + written);
 903         return written;
 904     }
 905 
<span class="line-added"> 906     /**</span>
<span class="line-added"> 907      * Encodes the given InetSocketAddress into targetSockAddr, returning the</span>
<span class="line-added"> 908      * length of the sockaddr structure (sizeof struct sockaddr or sockaddr6).</span>
<span class="line-added"> 909      */</span>
<span class="line-added"> 910     private int targetSocketAddress(InetSocketAddress isa) {</span>
<span class="line-added"> 911         assert writeLock.isHeldByCurrentThread();</span>
<span class="line-added"> 912         // Nothing to do if target address is already in the buffer. Use</span>
<span class="line-added"> 913         // identity rather than equals as Inet6Address.equals ignores scope_id.</span>
<span class="line-added"> 914         if (isa == previousTarget)</span>
<span class="line-added"> 915             return previousSockAddrLength;</span>
<span class="line-added"> 916         previousTarget = null;</span>
<span class="line-added"> 917         int len = targetSockAddr.encode(family, isa);</span>
<span class="line-added"> 918         previousTarget = isa;</span>
<span class="line-added"> 919         previousSockAddrLength = len;</span>
<span class="line-added"> 920         return len;</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922 </span>
 923     @Override
 924     public int read(ByteBuffer buf) throws IOException {
 925         Objects.requireNonNull(buf);
 926 
 927         readLock.lock();
 928         try {
 929             boolean blocking = isBlocking();
 930             int n = 0;
 931             try {
 932                 beginRead(blocking, true);
<span class="line-modified"> 933                 n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-modified"> 934                 if (blocking) {</span>
<span class="line-modified"> 935                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 936                         park(Net.POLLIN);</span>
<span class="line-added"> 937                         n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-added"> 938                     }</span>
<span class="line-added"> 939                 }</span>
 940             } finally {
 941                 endRead(blocking, n &gt; 0);
 942                 assert IOStatus.check(n);
 943             }
 944             return IOStatus.normalize(n);
 945         } finally {
 946             readLock.unlock();
 947         }
 948     }
 949 
 950     @Override
 951     public long read(ByteBuffer[] dsts, int offset, int length)
 952         throws IOException
 953     {
 954         Objects.checkFromIndexSize(offset, length, dsts.length);
 955 
 956         readLock.lock();
 957         try {
 958             boolean blocking = isBlocking();
 959             long n = 0;
 960             try {
 961                 beginRead(blocking, true);
<span class="line-modified"> 962                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified"> 963                 if (blocking) {</span>
<span class="line-modified"> 964                     while (IOStatus.okayToRetry(n)  &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 965                         park(Net.POLLIN);</span>
<span class="line-added"> 966                         n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-added"> 967                     }</span>
<span class="line-added"> 968                 }</span>
 969             } finally {
 970                 endRead(blocking, n &gt; 0);
 971                 assert IOStatus.check(n);
 972             }
 973             return IOStatus.normalize(n);
 974         } finally {
 975             readLock.unlock();
 976         }
 977     }
 978 
 979     /**
 980      * Marks the beginning of a write operation that might block.
 981      * @param blocking true if configured blocking
 982      * @param mustBeConnected true if the socket must be connected
 983      * @return remote address if connected
 984      * @throws ClosedChannelException if the channel is closed
 985      * @throws NotYetConnectedException if mustBeConnected and not connected
 986      * @throws IOException if socket not bound and cannot be bound
 987      */
 988     private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
 989         throws IOException
 990     {
<span class="line-modified"> 991         if (blocking &amp;&amp; interruptible) {</span>
 992             // set hook for Thread.interrupt
 993             begin();
 994         }
 995         SocketAddress remote;
 996         synchronized (stateLock) {
 997             ensureOpen();
 998             remote = remoteAddress;
 999             if ((remote == null) &amp;&amp; mustBeConnected)
1000                 throw new NotYetConnectedException();
1001             if (localAddress == null)
1002                 bindInternal(null);
1003             if (blocking)
1004                 writerThread = NativeThread.current();
1005         }
1006         return remote;
1007     }
1008 
1009     /**
1010      * Marks the end of a write operation that may have blocked.
1011      *
1012      * @throws AsynchronousCloseException if the channel was closed asynchronously
1013      */
1014     private void endWrite(boolean blocking, boolean completed)
1015         throws AsynchronousCloseException
1016     {
1017         if (blocking) {
1018             synchronized (stateLock) {
1019                 writerThread = 0;

1020                 if (state == ST_CLOSING) {
<span class="line-modified">1021                     tryFinishClose();</span>
1022                 }
1023             }
<span class="line-modified">1024 </span>
<span class="line-modified">1025             if (interruptible) {</span>
<span class="line-added">1026                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)</span>
<span class="line-added">1027                 end(completed);</span>
<span class="line-added">1028             } else if (!completed &amp;&amp; !isOpen()) {</span>
<span class="line-added">1029                 throw new AsynchronousCloseException();</span>
<span class="line-added">1030             }</span>
1031         }
1032     }
1033 
1034     @Override
1035     public int write(ByteBuffer buf) throws IOException {
1036         Objects.requireNonNull(buf);
1037 
1038         writeLock.lock();
1039         try {
1040             boolean blocking = isBlocking();
1041             int n = 0;
1042             try {
1043                 beginWrite(blocking, true);
<span class="line-modified">1044                 n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-modified">1045                 if (blocking) {</span>
<span class="line-modified">1046                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">1047                         park(Net.POLLOUT);</span>
<span class="line-added">1048                         n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-added">1049                     }</span>
<span class="line-added">1050                 }</span>
1051             } finally {
1052                 endWrite(blocking, n &gt; 0);
1053                 assert IOStatus.check(n);
1054             }
1055             return IOStatus.normalize(n);
1056         } finally {
1057             writeLock.unlock();
1058         }
1059     }
1060 
1061     @Override
1062     public long write(ByteBuffer[] srcs, int offset, int length)
1063         throws IOException
1064     {
1065         Objects.checkFromIndexSize(offset, length, srcs.length);
1066 
1067         writeLock.lock();
1068         try {
1069             boolean blocking = isBlocking();
1070             long n = 0;
1071             try {
1072                 beginWrite(blocking, true);
<span class="line-modified">1073                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified">1074                 if (blocking) {</span>
<span class="line-modified">1075                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">1076                         park(Net.POLLOUT);</span>
<span class="line-added">1077                         n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-added">1078                     }</span>
<span class="line-added">1079                 }</span>
1080             } finally {
1081                 endWrite(blocking, n &gt; 0);
1082                 assert IOStatus.check(n);
1083             }
1084             return IOStatus.normalize(n);
1085         } finally {
1086             writeLock.unlock();
1087         }
1088     }
1089 
1090     @Override
1091     protected void implConfigureBlocking(boolean block) throws IOException {
1092         readLock.lock();
1093         try {
1094             writeLock.lock();
1095             try {
<span class="line-modified">1096                 lockedConfigureBlocking(block);</span>



1097             } finally {
1098                 writeLock.unlock();
1099             }
1100         } finally {
1101             readLock.unlock();
1102         }
1103     }
1104 
<span class="line-added">1105     /**</span>
<span class="line-added">1106      * Adjusts the blocking mode. readLock or writeLock must already be held.</span>
<span class="line-added">1107      */</span>
<span class="line-added">1108     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">1109         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">1110         synchronized (stateLock) {</span>
<span class="line-added">1111             ensureOpen();</span>
<span class="line-added">1112             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">1113         }</span>
<span class="line-added">1114     }</span>
<span class="line-added">1115 </span>
<span class="line-added">1116     /**</span>
<span class="line-added">1117      * Adjusts the blocking mode if the channel is open. readLock or writeLock</span>
<span class="line-added">1118      * must already be held.</span>
<span class="line-added">1119      *</span>
<span class="line-added">1120      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-added">1121      *         the blocking mode was not adjusted because the channel is closed</span>
<span class="line-added">1122      */</span>
<span class="line-added">1123     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">1124         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">1125         synchronized (stateLock) {</span>
<span class="line-added">1126             if (isOpen()) {</span>
<span class="line-added">1127                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">1128                 return true;</span>
<span class="line-added">1129             } else {</span>
<span class="line-added">1130                 return false;</span>
<span class="line-added">1131             }</span>
<span class="line-added">1132         }</span>
<span class="line-added">1133     }</span>
<span class="line-added">1134 </span>
1135     InetSocketAddress localAddress() {
1136         synchronized (stateLock) {
1137             return localAddress;
1138         }
1139     }
1140 
1141     InetSocketAddress remoteAddress() {
1142         synchronized (stateLock) {
1143             return remoteAddress;
1144         }
1145     }
1146 
1147     @Override
1148     public DatagramChannel bind(SocketAddress local) throws IOException {
1149         readLock.lock();
1150         try {
1151             writeLock.lock();
1152             try {
1153                 synchronized (stateLock) {
1154                     ensureOpen();
1155                     if (localAddress != null)
1156                         throw new AlreadyBoundException();
1157                     bindInternal(local);
1158                 }
1159             } finally {
1160                 writeLock.unlock();
1161             }
1162         } finally {
1163             readLock.unlock();
1164         }
1165         return this;
1166     }
1167 
1168     private void bindInternal(SocketAddress local) throws IOException {
<span class="line-modified">1169         assert Thread.holdsLock(stateLock )&amp;&amp; (localAddress == null);</span>
1170 
1171         InetSocketAddress isa;
1172         if (local == null) {
1173             // only Inet4Address allowed with IPv4 socket
1174             if (family == StandardProtocolFamily.INET) {
1175                 isa = new InetSocketAddress(InetAddress.getByName(&quot;0.0.0.0&quot;), 0);
1176             } else {
1177                 isa = new InetSocketAddress(0);
1178             }
1179         } else {
1180             isa = Net.checkAddress(local, family);
1181         }
1182         SecurityManager sm = System.getSecurityManager();
1183         if (sm != null)
1184             sm.checkListen(isa.getPort());
1185 
1186         Net.bind(family, fd, isa.getAddress(), isa.getPort());
1187         localAddress = Net.localAddress(fd);
1188     }
1189 
1190     @Override
1191     public boolean isConnected() {
1192         synchronized (stateLock) {
1193             return (state == ST_CONNECTED);
1194         }
1195     }
1196 
1197     @Override
1198     public DatagramChannel connect(SocketAddress sa) throws IOException {
<span class="line-added">1199         return connect(sa, true);</span>
<span class="line-added">1200     }</span>
<span class="line-added">1201 </span>
<span class="line-added">1202     /**</span>
<span class="line-added">1203      * Connects the channel&#39;s socket.</span>
<span class="line-added">1204      *</span>
<span class="line-added">1205      * @param sa the remote address to which this channel is to be connected</span>
<span class="line-added">1206      * @param check true to check if the channel is already connected.</span>
<span class="line-added">1207      */</span>
<span class="line-added">1208     DatagramChannel connect(SocketAddress sa, boolean check) throws IOException {</span>
1209         InetSocketAddress isa = Net.checkAddress(sa, family);
1210         SecurityManager sm = System.getSecurityManager();
1211         if (sm != null) {
1212             InetAddress ia = isa.getAddress();
1213             if (ia.isMulticastAddress()) {
1214                 sm.checkMulticast(ia);
1215             } else {
1216                 sm.checkConnect(ia.getHostAddress(), isa.getPort());
1217                 sm.checkAccept(ia.getHostAddress(), isa.getPort());
1218             }
1219         }
1220 
1221         readLock.lock();
1222         try {
1223             writeLock.lock();
1224             try {
1225                 synchronized (stateLock) {
1226                     ensureOpen();
<span class="line-modified">1227                     if (check &amp;&amp; state == ST_CONNECTED)</span>
1228                         throw new AlreadyConnectedException();
1229 
<span class="line-added">1230                     // ensure that the socket is bound</span>
<span class="line-added">1231                     if (localAddress == null) {</span>
<span class="line-added">1232                         bindInternal(null);</span>
<span class="line-added">1233                     }</span>
<span class="line-added">1234 </span>
<span class="line-added">1235                     // capture local address before connect</span>
<span class="line-added">1236                     initialLocalAddress = localAddress;</span>
<span class="line-added">1237 </span>
1238                     int n = Net.connect(family,
1239                                         fd,
1240                                         isa.getAddress(),
1241                                         isa.getPort());
1242                     if (n &lt;= 0)
1243                         throw new Error();      // Can&#39;t happen
1244 
1245                     // connected
1246                     remoteAddress = isa;
1247                     state = ST_CONNECTED;
1248 
1249                     // refresh local address
1250                     localAddress = Net.localAddress(fd);
1251 
1252                     // flush any packets already received.
1253                     boolean blocking = isBlocking();
1254                     if (blocking) {
1255                         IOUtil.configureBlocking(fd, false);
1256                     }
1257                     try {
1258                         ByteBuffer buf = ByteBuffer.allocate(100);
<span class="line-modified">1259                         while (receive(buf, false) &gt;= 0) {</span>
1260                             buf.clear();
1261                         }
1262                     } finally {
1263                         if (blocking) {
1264                             IOUtil.configureBlocking(fd, true);
1265                         }
1266                     }
1267                 }
1268             } finally {
1269                 writeLock.unlock();
1270             }
1271         } finally {
1272             readLock.unlock();
1273         }
1274         return this;
1275     }
1276 
1277     @Override
1278     public DatagramChannel disconnect() throws IOException {
1279         readLock.lock();
1280         try {
1281             writeLock.lock();
1282             try {
1283                 synchronized (stateLock) {
1284                     if (!isOpen() || (state != ST_CONNECTED))
1285                         return this;
1286 
1287                     // disconnect socket
1288                     boolean isIPv6 = (family == StandardProtocolFamily.INET6);
1289                     disconnect0(fd, isIPv6);
1290 
1291                     // no longer connected
1292                     remoteAddress = null;
1293                     state = ST_UNCONNECTED;
1294 
<span class="line-modified">1295                     // refresh localAddress, should be same as it was prior to connect</span>
1296                     localAddress = Net.localAddress(fd);
<span class="line-added">1297                     try {</span>
<span class="line-added">1298                         if (!localAddress.equals(initialLocalAddress)) {</span>
<span class="line-added">1299                             // Workaround connect(2) issues on Linux and macOS</span>
<span class="line-added">1300                             repairSocket(initialLocalAddress);</span>
<span class="line-added">1301                             assert (localAddress != null)</span>
<span class="line-added">1302                                     &amp;&amp; localAddress.equals(Net.localAddress(fd))</span>
<span class="line-added">1303                                     &amp;&amp; localAddress.equals(initialLocalAddress);</span>
<span class="line-added">1304                         }</span>
<span class="line-added">1305                     } finally {</span>
<span class="line-added">1306                         initialLocalAddress = null;</span>
<span class="line-added">1307                     }</span>
1308                 }
1309             } finally {
1310                 writeLock.unlock();
1311             }
1312         } finally {
1313             readLock.unlock();
1314         }
1315         return this;
1316     }
1317 
<span class="line-added">1318     /**</span>
<span class="line-added">1319      * &quot;Repair&quot; the channel&#39;s socket after a disconnect that didn&#39;t restore the</span>
<span class="line-added">1320      * local address.</span>
<span class="line-added">1321      *</span>
<span class="line-added">1322      * On Linux, connect(2) dissolves the association but changes the local port</span>
<span class="line-added">1323      * to 0 when it was initially bound to an ephemeral port. The workaround here</span>
<span class="line-added">1324      * is to rebind to the original port.</span>
<span class="line-added">1325      *</span>
<span class="line-added">1326      * On macOS, connect(2) dissolves the association but rebinds the socket to</span>
<span class="line-added">1327      * the wildcard address when it was initially bound to a specific address.</span>
<span class="line-added">1328      * The workaround here is to re-create the socket.</span>
<span class="line-added">1329      */</span>
<span class="line-added">1330     private void repairSocket(InetSocketAddress target)</span>
<span class="line-added">1331         throws IOException</span>
<span class="line-added">1332     {</span>
<span class="line-added">1333         assert Thread.holdsLock(stateLock);</span>
<span class="line-added">1334 </span>
<span class="line-added">1335         // Linux: try to bind the socket to the original address/port</span>
<span class="line-added">1336         if (localAddress.getPort() == 0) {</span>
<span class="line-added">1337             assert localAddress.getAddress().equals(target.getAddress());</span>
<span class="line-added">1338             Net.bind(family, fd, target.getAddress(), target.getPort());</span>
<span class="line-added">1339             localAddress = Net.localAddress(fd);</span>
<span class="line-added">1340             return;</span>
<span class="line-added">1341         }</span>
<span class="line-added">1342 </span>
<span class="line-added">1343         // capture the value of all existing socket options</span>
<span class="line-added">1344         Map&lt;SocketOption&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="line-added">1345         for (SocketOption&lt;?&gt; option : supportedOptions()) {</span>
<span class="line-added">1346             Object value = getOption(option);</span>
<span class="line-added">1347             if (value != null) {</span>
<span class="line-added">1348                 map.put(option, value);</span>
<span class="line-added">1349             }</span>
<span class="line-added">1350         }</span>
<span class="line-added">1351 </span>
<span class="line-added">1352         // macOS: re-create the socket.</span>
<span class="line-added">1353         FileDescriptor newfd = Net.socket(family, false);</span>
<span class="line-added">1354         try {</span>
<span class="line-added">1355             // copy the socket options that are protocol family agnostic</span>
<span class="line-added">1356             for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {</span>
<span class="line-added">1357                 SocketOption&lt;?&gt; option = e.getKey();</span>
<span class="line-added">1358                 if (SocketOptionRegistry.findOption(option, Net.UNSPEC) != null) {</span>
<span class="line-added">1359                     Object value = e.getValue();</span>
<span class="line-added">1360                     try {</span>
<span class="line-added">1361                         Net.setSocketOption(newfd, Net.UNSPEC, option, value);</span>
<span class="line-added">1362                     } catch (IOException ignore) { }</span>
<span class="line-added">1363                 }</span>
<span class="line-added">1364             }</span>
<span class="line-added">1365 </span>
<span class="line-added">1366             // copy the blocking mode</span>
<span class="line-added">1367             if (!isBlocking()) {</span>
<span class="line-added">1368                 IOUtil.configureBlocking(newfd, false);</span>
<span class="line-added">1369             }</span>
<span class="line-added">1370 </span>
<span class="line-added">1371             // dup this channel&#39;s socket to the new socket. If this succeeds then</span>
<span class="line-added">1372             // fd will reference the new socket. If it fails then it will still</span>
<span class="line-added">1373             // reference the old socket.</span>
<span class="line-added">1374             nd.dup(newfd, fd);</span>
<span class="line-added">1375         } finally {</span>
<span class="line-added">1376             // release the file descriptor</span>
<span class="line-added">1377             nd.close(newfd);</span>
<span class="line-added">1378         }</span>
<span class="line-added">1379 </span>
<span class="line-added">1380         // bind to the original local address</span>
<span class="line-added">1381         try {</span>
<span class="line-added">1382             Net.bind(family, fd, target.getAddress(), target.getPort());</span>
<span class="line-added">1383         } catch (IOException ioe) {</span>
<span class="line-added">1384             // bind failed, socket is left unbound</span>
<span class="line-added">1385             localAddress = null;</span>
<span class="line-added">1386             throw ioe;</span>
<span class="line-added">1387         }</span>
<span class="line-added">1388 </span>
<span class="line-added">1389         // restore local address</span>
<span class="line-added">1390         localAddress = Net.localAddress(fd);</span>
<span class="line-added">1391 </span>
<span class="line-added">1392         // restore all socket options (including those set in first pass)</span>
<span class="line-added">1393         for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {</span>
<span class="line-added">1394             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">1395             SocketOption&lt;Object&gt; option = (SocketOption&lt;Object&gt;) e.getKey();</span>
<span class="line-added">1396             Object value = e.getValue();</span>
<span class="line-added">1397             try {</span>
<span class="line-added">1398                 setOption(option, value);</span>
<span class="line-added">1399             } catch (IOException ignore) { }</span>
<span class="line-added">1400         }</span>
<span class="line-added">1401 </span>
<span class="line-added">1402         // restore multicast group membership</span>
<span class="line-added">1403         MembershipRegistry registry = this.registry;</span>
<span class="line-added">1404         if (registry != null) {</span>
<span class="line-added">1405             registry.forEach(k -&gt; {</span>
<span class="line-added">1406                 if (k instanceof MembershipKeyImpl.Type6) {</span>
<span class="line-added">1407                     MembershipKeyImpl.Type6 key6 = (MembershipKeyImpl.Type6) k;</span>
<span class="line-added">1408                     Net.join6(fd, key6.groupAddress(), key6.index(), key6.source());</span>
<span class="line-added">1409                 } else {</span>
<span class="line-added">1410                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4) k;</span>
<span class="line-added">1411                     Net.join4(fd, key4.groupAddress(), key4.interfaceAddress(), key4.source());</span>
<span class="line-added">1412                 }</span>
<span class="line-added">1413             });</span>
<span class="line-added">1414         }</span>
<span class="line-added">1415 </span>
<span class="line-added">1416         // reset registration in all Selectors that this channel is registered with</span>
<span class="line-added">1417         AbstractSelectableChannels.forEach(this, SelectionKeyImpl::reset);</span>
<span class="line-added">1418     }</span>
<span class="line-added">1419 </span>
<span class="line-added">1420     /**</span>
<span class="line-added">1421      * Defines static methods to access AbstractSelectableChannel non-public members.</span>
<span class="line-added">1422      */</span>
<span class="line-added">1423     private static class AbstractSelectableChannels {</span>
<span class="line-added">1424         private static final Method FOREACH;</span>
<span class="line-added">1425         static {</span>
<span class="line-added">1426             try {</span>
<span class="line-added">1427                 PrivilegedExceptionAction&lt;Method&gt; pae = () -&gt; {</span>
<span class="line-added">1428                     Method m = AbstractSelectableChannel.class.getDeclaredMethod(&quot;forEach&quot;, Consumer.class);</span>
<span class="line-added">1429                     m.setAccessible(true);</span>
<span class="line-added">1430                     return m;</span>
<span class="line-added">1431                 };</span>
<span class="line-added">1432                 FOREACH = AccessController.doPrivileged(pae);</span>
<span class="line-added">1433             } catch (Exception e) {</span>
<span class="line-added">1434                 throw new InternalError(e);</span>
<span class="line-added">1435             }</span>
<span class="line-added">1436         }</span>
<span class="line-added">1437         static void forEach(AbstractSelectableChannel ch, Consumer&lt;SelectionKeyImpl&gt; action) {</span>
<span class="line-added">1438             try {</span>
<span class="line-added">1439                 FOREACH.invoke(ch, action);</span>
<span class="line-added">1440             } catch (Exception e) {</span>
<span class="line-added">1441                 throw new InternalError(e);</span>
<span class="line-added">1442             }</span>
<span class="line-added">1443         }</span>
<span class="line-added">1444     }</span>
<span class="line-added">1445 </span>
1446     /**
1447      * Joins channel&#39;s socket to the given group/interface and
1448      * optional source address.
1449      */
1450     private MembershipKey innerJoin(InetAddress group,
1451                                     NetworkInterface interf,
1452                                     InetAddress source)
1453         throws IOException
1454     {
1455         if (!group.isMulticastAddress())
1456             throw new IllegalArgumentException(&quot;Group not a multicast address&quot;);
1457 
1458         // check multicast address is compatible with this socket
1459         if (group instanceof Inet4Address) {
1460             if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.canIPv6SocketJoinIPv4Group())
1461                 throw new IllegalArgumentException(&quot;IPv6 socket cannot join IPv4 multicast group&quot;);
1462         } else if (group instanceof Inet6Address) {
1463             if (family != StandardProtocolFamily.INET6)
1464                 throw new IllegalArgumentException(&quot;Only IPv6 sockets can join IPv6 multicast group&quot;);
1465         } else {
</pre>
<hr />
<pre>
1568                 if (key instanceof MembershipKeyImpl.Type6) {
1569                     MembershipKeyImpl.Type6 key6 =
1570                         (MembershipKeyImpl.Type6)key;
1571                     Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
1572                 } else {
1573                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
1574                     Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
1575                         key4.source());
1576                 }
1577             } catch (IOException ioe) {
1578                 // should not happen
1579                 throw new AssertionError(ioe);
1580             }
1581 
1582             key.invalidate();
1583             registry.remove(key);
1584         }
1585     }
1586 
1587     /**
<span class="line-modified">1588      * Finds an existing membership of a multicast group. Returns null if this</span>
<span class="line-modified">1589      * channel&#39;s socket is not a member of the group.</span>
<span class="line-added">1590      *</span>
<span class="line-added">1591      * @apiNote This method is for use by the socket adaptor</span>
<span class="line-added">1592      */</span>
<span class="line-added">1593     MembershipKey findMembership(InetAddress group, NetworkInterface interf) {</span>
<span class="line-added">1594         synchronized (stateLock) {</span>
<span class="line-added">1595             if (registry != null) {</span>
<span class="line-added">1596                 return registry.checkMembership(group, interf, null);</span>
<span class="line-added">1597             } else {</span>
<span class="line-added">1598                 return null;</span>
<span class="line-added">1599             }</span>
<span class="line-added">1600         }</span>
<span class="line-added">1601     }</span>
<span class="line-added">1602 </span>
<span class="line-added">1603     /**</span>
<span class="line-added">1604      * Block datagrams from the given source.</span>
1605      */
1606     void block(MembershipKeyImpl key, InetAddress source)
1607         throws IOException
1608     {
1609         assert key.channel() == this;
1610         assert key.sourceAddress() == null;
1611 
1612         synchronized (stateLock) {
1613             if (!key.isValid())
1614                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1615             if (source.isAnyLocalAddress())
1616                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1617             if (source.isMulticastAddress())
1618                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1619             if (source.getClass() != key.group().getClass())
1620                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1621 
1622             int n;
1623             if (key instanceof MembershipKeyImpl.Type6) {
1624                  MembershipKeyImpl.Type6 key6 =
1625                     (MembershipKeyImpl.Type6)key;
1626                 n = Net.block6(fd, key6.groupAddress(), key6.index(),
1627                                Net.inet6AsByteArray(source));
1628             } else {
1629                 MembershipKeyImpl.Type4 key4 =
1630                     (MembershipKeyImpl.Type4)key;
1631                 n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
1632                                Net.inet4AsInt(source));
1633             }
1634             if (n == IOStatus.UNAVAILABLE) {
1635                 // ancient kernel
1636                 throw new UnsupportedOperationException();
1637             }
1638         }
1639     }
1640 
1641     /**
<span class="line-modified">1642      * Unblock the given source.</span>
1643      */
1644     void unblock(MembershipKeyImpl key, InetAddress source) {
1645         assert key.channel() == this;
1646         assert key.sourceAddress() == null;
1647 
1648         synchronized (stateLock) {
1649             if (!key.isValid())
1650                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1651 
1652             try {
1653                 if (key instanceof MembershipKeyImpl.Type6) {
1654                     MembershipKeyImpl.Type6 key6 =
1655                         (MembershipKeyImpl.Type6)key;
1656                     Net.unblock6(fd, key6.groupAddress(), key6.index(),
1657                                  Net.inet6AsByteArray(source));
1658                 } else {
1659                     MembershipKeyImpl.Type4 key4 =
1660                         (MembershipKeyImpl.Type4)key;
1661                     Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
1662                                  Net.inet4AsInt(source));
1663                 }
1664             } catch (IOException ioe) {
1665                 // should not happen
1666                 throw new AssertionError(ioe);
1667             }
1668         }
1669     }
1670 
1671     /**
<span class="line-modified">1672      * Closes the socket if there are no I/O operations in progress and the</span>
<span class="line-modified">1673      * channel is not registered with a Selector.</span>









1674      */
<span class="line-modified">1675     private boolean tryClose() throws IOException {</span>
<span class="line-modified">1676         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-modified">1677         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added">1678             state = ST_CLOSED;</span>
<span class="line-added">1679             try {</span>
<span class="line-added">1680                 // close socket</span>
<span class="line-added">1681                 cleaner.clean();</span>
<span class="line-added">1682             } catch (UncheckedIOException ioe) {</span>
<span class="line-added">1683                 throw ioe.getCause();</span>
<span class="line-added">1684             }</span>
<span class="line-added">1685             return true;</span>
<span class="line-added">1686         } else {</span>
<span class="line-added">1687             return false;</span>
<span class="line-added">1688         }</span>
<span class="line-added">1689     }</span>
1690 
<span class="line-modified">1691     /**</span>
<span class="line-modified">1692      * Invokes tryClose to attempt to close the socket.</span>
<span class="line-added">1693      *</span>
<span class="line-added">1694      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">1695      */</span>
<span class="line-added">1696     private void tryFinishClose() {</span>
<span class="line-added">1697         try {</span>
<span class="line-added">1698             tryClose();</span>
<span class="line-added">1699         } catch (IOException ignore) { }</span>
<span class="line-added">1700     }</span>
1701 
<span class="line-modified">1702     /**</span>
<span class="line-added">1703      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">1704      *</span>
<span class="line-added">1705      * If there is an I/O operation in progress then the socket is pre-closed</span>
<span class="line-added">1706      * and the I/O threads signalled, in which case the final close is deferred</span>
<span class="line-added">1707      * until all I/O operations complete.</span>
<span class="line-added">1708      */</span>
<span class="line-added">1709     private void implCloseBlockingMode() throws IOException {</span>
1710         synchronized (stateLock) {
1711             assert state &lt; ST_CLOSING;

1712             state = ST_CLOSING;
1713 
1714             // if member of any multicast groups then invalidate the keys
1715             if (registry != null)
1716                 registry.invalidateAll();

1717 
<span class="line-modified">1718             if (!tryClose()) {</span>



1719                 long reader = readerThread;
1720                 long writer = writerThread;
1721                 if (reader != 0 || writer != 0) {
1722                     nd.preClose(fd);

1723                     if (reader != 0)
1724                         NativeThread.signal(reader);
1725                     if (writer != 0)
1726                         NativeThread.signal(writer);









1727                 }
1728             }









1729         }
<span class="line-added">1730     }</span>
1731 
<span class="line-modified">1732     /**</span>
<span class="line-added">1733      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">1734      *</span>
<span class="line-added">1735      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">1736      * until the channel is flushed from all Selectors.</span>
<span class="line-added">1737      */</span>
<span class="line-added">1738     private void implCloseNonBlockingMode() throws IOException {</span>
1739         synchronized (stateLock) {
<span class="line-modified">1740             assert state &lt; ST_CLOSING;</span>
<span class="line-modified">1741             state = ST_CLOSING;</span>
<span class="line-added">1742 </span>
<span class="line-added">1743             // if member of any multicast groups then invalidate the keys</span>
<span class="line-added">1744             if (registry != null)</span>
<span class="line-added">1745                 registry.invalidateAll();</span>
1746         }
1747 
<span class="line-modified">1748         // wait for any read/write operations to complete before trying to close</span>
<span class="line-modified">1749         readLock.lock();</span>
<span class="line-modified">1750         readLock.unlock();</span>
<span class="line-added">1751         writeLock.lock();</span>
<span class="line-added">1752         writeLock.unlock();</span>
<span class="line-added">1753         synchronized (stateLock) {</span>
<span class="line-added">1754             if (state == ST_CLOSING) {</span>
<span class="line-added">1755                 tryClose();</span>
<span class="line-added">1756             }</span>
<span class="line-added">1757         }</span>
<span class="line-added">1758     }</span>
1759 
<span class="line-modified">1760     /**</span>
<span class="line-modified">1761      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">1762      */</span>
<span class="line-added">1763     @Override</span>
<span class="line-added">1764     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">1765         assert !isOpen();</span>
<span class="line-added">1766         if (isBlocking()) {</span>
<span class="line-added">1767             implCloseBlockingMode();</span>
<span class="line-added">1768         } else {</span>
<span class="line-added">1769             implCloseNonBlockingMode();</span>
<span class="line-added">1770         }</span>
1771     }
1772 
1773     @Override
<span class="line-modified">1774     public void kill() {</span>
1775         synchronized (stateLock) {
<span class="line-modified">1776             if (state == ST_CLOSING) {</span>
<span class="line-modified">1777                 tryFinishClose();</span>






1778             }
1779         }
1780     }
1781 







1782     /**
1783      * Translates native poll revent set into a ready operation set
1784      */
1785     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1786         int intOps = ski.nioInterestOps();
1787         int oldOps = ski.nioReadyOps();
1788         int newOps = initialOps;
1789 
1790         if ((ops &amp; Net.POLLNVAL) != 0) {
1791             // This should only happen if this channel is pre-closed while a
1792             // selection operation is in progress
1793             // ## Throw an error if this channel has not been pre-closed
1794             return false;
1795         }
1796 
1797         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1798             newOps = intOps;
1799             ski.nioReadyOps(newOps);
1800             return (newOps &amp; ~oldOps) != 0;
1801         }
</pre>
<hr />
<pre>
1803         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1804             ((intOps &amp; SelectionKey.OP_READ) != 0))
1805             newOps |= SelectionKey.OP_READ;
1806 
1807         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1808             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
1809             newOps |= SelectionKey.OP_WRITE;
1810 
1811         ski.nioReadyOps(newOps);
1812         return (newOps &amp; ~oldOps) != 0;
1813     }
1814 
1815     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1816         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1817     }
1818 
1819     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1820         return translateReadyOps(ops, 0, ski);
1821     }
1822 
























1823     /**
1824      * Translates an interest operation set into a native poll event set
1825      */
1826     public int translateInterestOps(int ops) {
1827         int newOps = 0;
1828         if ((ops &amp; SelectionKey.OP_READ) != 0)
1829             newOps |= Net.POLLIN;
1830         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1831             newOps |= Net.POLLOUT;
1832         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1833             newOps |= Net.POLLIN;
1834         return newOps;
1835     }
1836 
1837     public FileDescriptor getFD() {
1838         return fd;
1839     }
1840 
1841     public int getFDVal() {
1842         return fdVal;
1843     }
1844 
<span class="line-added">1845     /**</span>
<span class="line-added">1846      * Returns an action to release the given file descriptor and socket addresses.</span>
<span class="line-added">1847      */</span>
<span class="line-added">1848     private static Runnable releaserFor(FileDescriptor fd, NativeSocketAddress... sockAddrs) {</span>
<span class="line-added">1849         return () -&gt; {</span>
<span class="line-added">1850             try {</span>
<span class="line-added">1851                 nd.close(fd);</span>
<span class="line-added">1852             } catch (IOException ioe) {</span>
<span class="line-added">1853                 throw new UncheckedIOException(ioe);</span>
<span class="line-added">1854             } finally {</span>
<span class="line-added">1855                 // decrement socket count and release memory</span>
<span class="line-added">1856                 ResourceManager.afterUdpClose();</span>
<span class="line-added">1857                 NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added">1858             }</span>
<span class="line-added">1859         };</span>
<span class="line-added">1860     }</span>
1861 
1862     // -- Native methods --
1863 


1864     private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
1865         throws IOException;
1866 
<span class="line-modified">1867     private static native int receive0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">1868                                        long senderAddress, boolean connected)</span>
1869         throws IOException;
1870 
<span class="line-modified">1871     private static native int send0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">1872                                     long targetAddress, int targetAddressLen)</span>
1873         throws IOException;
1874 
1875     static {
1876         IOUtil.load();

1877     }
1878 }
</pre>
</td>
</tr>
</table>
<center><a href="ChannelInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketAdaptor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
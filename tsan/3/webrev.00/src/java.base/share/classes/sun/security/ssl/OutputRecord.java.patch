diff a/src/java.base/share/classes/sun/security/ssl/OutputRecord.java b/src/java.base/share/classes/sun/security/ssl/OutputRecord.java
--- a/src/java.base/share/classes/sun/security/ssl/OutputRecord.java
+++ b/src/java.base/share/classes/sun/security/ssl/OutputRecord.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,10 +28,11 @@
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
+import java.util.concurrent.locks.ReentrantLock;
 import sun.security.ssl.SSLCipher.SSLWriteCipher;
 
 /**
  * {@code OutputRecord} takes care of the management of SSL/(D)TLS
  * output records, including buffering, encryption, handshake
@@ -61,15 +62,17 @@
 
     // packet size
     int                         packetSize;
 
     // fragment size
-    int                         fragmentSize;
+    private int                 fragmentSize;
 
     // closed or not?
     volatile boolean            isClosed;
 
+    final ReentrantLock recordLock = new ReentrantLock();
+
     /*
      * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
      * This is taken from the SSL V3 specification, Appendix E.
      */
     private static final int[] V3toV2CipherMap1 =
@@ -87,32 +90,47 @@
         this.handshakeHash = handshakeHash;
 
         // Please set packetSize and protocolVersion in the implementation.
     }
 
-    synchronized void setVersion(ProtocolVersion protocolVersion) {
-        this.protocolVersion = protocolVersion;
+    void setVersion(ProtocolVersion protocolVersion) {
+        recordLock.lock();
+        try {
+            this.protocolVersion = protocolVersion;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
     /*
      * Updates helloVersion of this record.
      */
-    synchronized void setHelloVersion(ProtocolVersion helloVersion) {
-        this.helloVersion = helloVersion;
+    void setHelloVersion(ProtocolVersion helloVersion) {
+        recordLock.lock();
+        try {
+            this.helloVersion = helloVersion;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
     /*
      * Return true iff the record is empty -- to avoid doing the work
      * of sending empty records over the network.
      */
     boolean isEmpty() {
         return false;
     }
 
-    synchronized boolean seqNumIsHuge() {
-        return (writeCipher.authenticator != null) &&
+    boolean seqNumIsHuge() {
+        recordLock.lock();
+        try {
+            return (writeCipher.authenticator != null) &&
                         writeCipher.authenticator.seqNumIsHuge();
+        } finally {
+            recordLock.unlock();
+        }
     }
 
     // SSLEngine and SSLSocket
     abstract void encodeAlert(byte level, byte description) throws IOException;
 
@@ -146,72 +164,97 @@
     void setDeliverStream(OutputStream outputStream) {
         throw new UnsupportedOperationException();
     }
 
     // Change write ciphers, may use change_cipher_spec record.
-    synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,
+    void changeWriteCiphers(SSLWriteCipher writeCipher,
             boolean useChangeCipherSpec) throws IOException {
-        if (isClosed()) {
-            if (SSLLogger.isOn && SSLLogger.isOn("ssl")) {
-                SSLLogger.warning("outbound has closed, ignore outbound " +
-                    "change_cipher_spec message");
+        recordLock.lock();
+        try {
+            if (isClosed()) {
+                if (SSLLogger.isOn && SSLLogger.isOn("ssl")) {
+                    SSLLogger.warning("outbound has closed, ignore outbound " +
+                        "change_cipher_spec message");
+                }
+                return;
             }
-            return;
-        }
 
-        if (useChangeCipherSpec) {
-            encodeChangeCipherSpec();
-        }
-
-        /*
-         * Dispose of any intermediate state in the underlying cipher.
-         * For PKCS11 ciphers, this will release any attached sessions,
-         * and thus make finalization faster.
-         *
-         * Since MAC's doFinal() is called for every SSL/TLS packet, it's
-         * not necessary to do the same with MAC's.
-         */
-        writeCipher.dispose();
+            if (useChangeCipherSpec) {
+                encodeChangeCipherSpec();
+            }
 
-        this.writeCipher = writeCipher;
-        this.isFirstAppOutputRecord = true;
+            /*
+             * Dispose of any intermediate state in the underlying cipher.
+             * For PKCS11 ciphers, this will release any attached sessions,
+             * and thus make finalization faster.
+             *
+             * Since MAC's doFinal() is called for every SSL/TLS packet, it's
+             * not necessary to do the same with MAC's.
+             */
+            writeCipher.dispose();
+
+            this.writeCipher = writeCipher;
+            this.isFirstAppOutputRecord = true;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
     // Change write ciphers using key_update handshake message.
-    synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,
+    void changeWriteCiphers(SSLWriteCipher writeCipher,
             byte keyUpdateRequest) throws IOException {
-        if (isClosed()) {
-            if (SSLLogger.isOn && SSLLogger.isOn("ssl")) {
-                SSLLogger.warning("outbound has closed, ignore outbound " +
-                    "key_update handshake message");
+        recordLock.lock();
+        try {
+            if (isClosed()) {
+                if (SSLLogger.isOn && SSLLogger.isOn("ssl")) {
+                    SSLLogger.warning("outbound has closed, ignore outbound " +
+                        "key_update handshake message");
+                }
+                return;
             }
-            return;
-        }
 
-        // encode the handshake message, KeyUpdate
-        byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();
-        hm[hm.length - 1] = keyUpdateRequest;
-        encodeHandshake(hm, 0, hm.length);
-        flush();
+            // encode the handshake message, KeyUpdate
+            byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();
+            hm[hm.length - 1] = keyUpdateRequest;
+            encodeHandshake(hm, 0, hm.length);
+            flush();
 
-        // Dispose of any intermediate state in the underlying cipher.
-        writeCipher.dispose();
+            // Dispose of any intermediate state in the underlying cipher.
+            writeCipher.dispose();
 
-        this.writeCipher = writeCipher;
-        this.isFirstAppOutputRecord = true;
+            this.writeCipher = writeCipher;
+            this.isFirstAppOutputRecord = true;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
-    synchronized void changePacketSize(int packetSize) {
-        this.packetSize = packetSize;
+    void changePacketSize(int packetSize) {
+        recordLock.lock();
+        try {
+            this.packetSize = packetSize;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
-    synchronized void changeFragmentSize(int fragmentSize) {
-        this.fragmentSize = fragmentSize;
+    void changeFragmentSize(int fragmentSize) {
+        recordLock.lock();
+        try {
+            this.fragmentSize = fragmentSize;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
-    synchronized int getMaxPacketSize() {
-        return packetSize;
+    int getMaxPacketSize() {
+        recordLock.lock();
+        try {
+            return packetSize;
+        } finally {
+            recordLock.unlock();
+        }
     }
 
     // apply to DTLS SSLEngine
     void initHandshaker() {
         // blank
@@ -226,27 +269,50 @@
     void launchRetransmission() {
         // blank
     }
 
     @Override
-    public synchronized void close() throws IOException {
-        if (isClosed) {
-            return;
-        }
+    public void close() throws IOException {
+        recordLock.lock();
+        try {
+            if (isClosed) {
+                return;
+            }
 
-        isClosed = true;
-        writeCipher.dispose();
+            isClosed = true;
+            writeCipher.dispose();
+        } finally {
+            recordLock.unlock();
+        }
     }
 
     boolean isClosed() {
         return isClosed;
     }
 
     //
     // shared helpers
     //
 
+    private static final class T13PaddingHolder {
+        private static final byte[] zeros = new byte[16];
+    }
+
+    int calculateFragmentSize(int fragmentLimit) {
+        if (fragmentSize > 0) {
+            fragmentLimit = Math.min(fragmentLimit, fragmentSize);
+        }
+
+        if (protocolVersion.useTLS13PlusSpec()) {
+            // No negative integer checking as the fragment capacity should
+            // have been ensured.
+            return fragmentLimit -  T13PaddingHolder.zeros.length - 1;
+        }
+
+        return fragmentLimit;
+    }
+
     // Encrypt a fragment and wrap up a record.
     //
     // To be consistent with the spec of SSLEngine.wrap() methods, the
     // destination ByteBuffer's position is updated to reflect the amount
     // of data produced.  The limit remains the same.
@@ -324,12 +390,16 @@
             int headerOffset, int dstLim, int headerSize,
             ProtocolVersion protocolVersion) {
         if (!encCipher.isNullCipher()) {
             // inner plaintext, using zero length padding.
             int endOfPt = destination.limit();
-            destination.limit(endOfPt + 1);
-            destination.put(endOfPt, contentType);
+            int startOfPt = destination.position();
+            destination.position(endOfPt);
+            destination.limit(endOfPt + 1 + T13PaddingHolder.zeros.length);
+            destination.put(contentType);
+            destination.put(T13PaddingHolder.zeros);
+            destination.position(startOfPt);
         }
 
         // use the right TLSCiphertext.opaque_type and legacy_record_version
         ProtocolVersion pv = protocolVersion;
         if (!encCipher.isNullCipher()) {
@@ -393,14 +463,10 @@
         } else {
             return t10Encrypt(encCipher, contentType, headerSize);
         }
     }
 
-    private static final class T13PaddingHolder {
-        private static final byte[] zeros = new byte[16];
-    }
-
     private long t13Encrypt(
             SSLWriteCipher encCipher, byte contentType, int headerSize) {
         if (!encCipher.isNullCipher()) {
             // inner plaintext
             write(contentType);

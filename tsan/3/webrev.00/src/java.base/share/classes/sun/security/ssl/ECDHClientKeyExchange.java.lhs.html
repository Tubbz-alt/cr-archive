<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<a name="1" id="anc1"></a><span class="line-removed"> 30 import java.security.AlgorithmConstraints;</span>
<span class="line-removed"> 31 import java.security.CryptoPrimitive;</span>
 32 import java.security.GeneralSecurityException;
<a name="2" id="anc2"></a><span class="line-removed"> 33 import java.security.KeyFactory;</span>
<span class="line-removed"> 34 import java.security.PrivateKey;</span>
 35 import java.security.PublicKey;
<a name="3" id="anc3"></a><span class="line-removed"> 36 import java.security.interfaces.ECPrivateKey;</span>
 37 import java.security.interfaces.ECPublicKey;
<a name="4" id="anc4"></a>

 38 import java.security.spec.ECParameterSpec;
<a name="5" id="anc5"></a><span class="line-modified"> 39 import java.security.spec.ECPoint;</span>
<span class="line-removed"> 40 import java.security.spec.ECPublicKeySpec;</span>
 41 import java.text.MessageFormat;
<a name="6" id="anc6"></a><span class="line-removed"> 42 import java.util.EnumSet;</span>
 43 import java.util.Locale;
 44 import javax.crypto.SecretKey;
<a name="7" id="anc7"></a><span class="line-removed"> 45 import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-removed"> 46 import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;</span>
<span class="line-removed"> 47 import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;</span>
 48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<a name="8" id="anc8"></a><span class="line-removed"> 49 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
 50 import sun.security.ssl.X509Authentication.X509Credentials;
 51 import sun.security.ssl.X509Authentication.X509Possession;
<a name="9" id="anc9"></a><span class="line-removed"> 52 import sun.security.util.ECUtil;</span>
 53 import sun.security.util.HexDumpEncoder;
 54 
 55 /**
 56  * Pack of the &quot;ClientKeyExchange&quot; handshake message.
<a name="10" id="anc10"></a>




 57  */
 58 final class ECDHClientKeyExchange {
 59     static final SSLConsumer ecdhHandshakeConsumer =
 60             new ECDHClientKeyExchangeConsumer();
 61     static final HandshakeProducer ecdhHandshakeProducer =
 62             new ECDHClientKeyExchangeProducer();
 63 
 64     static final SSLConsumer ecdheHandshakeConsumer =
 65             new ECDHEClientKeyExchangeConsumer();
 66     static final HandshakeProducer ecdheHandshakeProducer =
 67             new ECDHEClientKeyExchangeProducer();
 68 
 69     /**
<a name="11" id="anc11"></a><span class="line-modified"> 70      * The ECDH/ECDHE ClientKeyExchange handshake message.</span>
 71      */
 72     private static final
 73             class ECDHClientKeyExchangeMessage extends HandshakeMessage {
 74         private final byte[] encodedPoint;
 75 
 76         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
<a name="12" id="anc12"></a><span class="line-modified"> 77                 ECPublicKey publicKey) {</span>
 78             super(handshakeContext);
 79 
<a name="13" id="anc13"></a><span class="line-modified"> 80             ECPoint point = publicKey.getW();</span>
<span class="line-removed"> 81             ECParameterSpec params = publicKey.getParams();</span>
<span class="line-removed"> 82             encodedPoint = ECUtil.encodePoint(point, params.getCurve());</span>
 83         }
 84 
 85         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
 86                 ByteBuffer m) throws IOException {
 87             super(handshakeContext);
 88             if (m.remaining() != 0) {       // explicit PublicValueEncoding
 89                 this.encodedPoint = Record.getBytes8(m);
 90             } else {
 91                 this.encodedPoint = new byte[0];
 92             }
 93         }
 94 
<a name="14" id="anc14"></a><span class="line-removed"> 95         // Check constraints of the specified EC public key.</span>
<span class="line-removed"> 96         static void checkConstraints(AlgorithmConstraints constraints,</span>
<span class="line-removed"> 97                 ECPublicKey publicKey,</span>
<span class="line-removed"> 98                 byte[] encodedPoint) throws SSLHandshakeException {</span>
<span class="line-removed"> 99 </span>
<span class="line-removed">100             try {</span>
<span class="line-removed">101                 ECParameterSpec params = publicKey.getParams();</span>
<span class="line-removed">102                 ECPoint point =</span>
<span class="line-removed">103                         ECUtil.decodePoint(encodedPoint, params.getCurve());</span>
<span class="line-removed">104                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-removed">105 </span>
<span class="line-removed">106                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-removed">107                 ECPublicKey peerPublicKey =</span>
<span class="line-removed">108                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-removed">109 </span>
<span class="line-removed">110                 // check constraints of ECPublicKey</span>
<span class="line-removed">111                 if (!constraints.permits(</span>
<span class="line-removed">112                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">113                         peerPublicKey)) {</span>
<span class="line-removed">114                     throw new SSLHandshakeException(</span>
<span class="line-removed">115                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">116                 }</span>
<span class="line-removed">117             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">118                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">119                         &quot;Could not generate ECPublicKey&quot;).initCause(e);</span>
<span class="line-removed">120             }</span>
<span class="line-removed">121         }</span>
<span class="line-removed">122 </span>
123         @Override
124         public SSLHandshake handshakeType() {
125             return SSLHandshake.CLIENT_KEY_EXCHANGE;
126         }
127 
128         @Override
129         public int messageLength() {
130             if (encodedPoint == null || encodedPoint.length == 0) {
131                 return 0;
132             } else {
133                 return 1 + encodedPoint.length;
134             }
135         }
136 
137         @Override
138         public void send(HandshakeOutStream hos) throws IOException {
139             if (encodedPoint != null &amp;&amp; encodedPoint.length != 0) {
140                 hos.putBytes8(encodedPoint);
141             }
142         }
143 
144         @Override
145         public String toString() {
146             MessageFormat messageFormat = new MessageFormat(
147                 &quot;\&quot;ECDH ClientKeyExchange\&quot;: &#39;{&#39;\n&quot; +
148                 &quot;  \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
149                 &quot;{0}\n&quot; +
150                 &quot;  &#39;}&#39;,\n&quot; +
151                 &quot;&#39;}&#39;&quot;,
152                 Locale.ENGLISH);
153             if (encodedPoint == null || encodedPoint.length == 0) {
154                 Object[] messageFields = {
155                     &quot;    &lt;implicit&gt;&quot;
156                 };
157                 return messageFormat.format(messageFields);
158             } else {
159                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
160                 Object[] messageFields = {
161                     Utilities.indent(
162                             hexEncoder.encodeBuffer(encodedPoint), &quot;    &quot;),
163                 };
164                 return messageFormat.format(messageFields);
165             }
166         }
167     }
168 
169     /**
170      * The ECDH &quot;ClientKeyExchange&quot; handshake message producer.
171      */
172     private static final
173             class ECDHClientKeyExchangeProducer implements HandshakeProducer {
174         // Prevent instantiation of this class.
175         private ECDHClientKeyExchangeProducer() {
176             // blank
177         }
178 
179         @Override
180         public byte[] produce(ConnectionContext context,
181                 HandshakeMessage message) throws IOException {
182             // The producing happens in client side only.
183             ClientHandshakeContext chc = (ClientHandshakeContext)context;
184 
185             X509Credentials x509Credentials = null;
186             for (SSLCredentials credential : chc.handshakeCredentials) {
187                 if (credential instanceof X509Credentials) {
188                     x509Credentials = (X509Credentials)credential;
189                     break;
190                 }
191             }
192 
193             if (x509Credentials == null) {
194                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
195                     &quot;No server certificate for ECDH client key exchange&quot;);
196             }
197 
198             PublicKey publicKey = x509Credentials.popPublicKey;
<a name="15" id="anc15"></a><span class="line-modified">199             if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>
















200                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="16" id="anc16"></a><span class="line-modified">201                     &quot;Not EC server certificate for ECDH client key exchange&quot;);</span>

202             }
203 
<a name="17" id="anc17"></a><span class="line-removed">204             ECParameterSpec params = ((ECPublicKey)publicKey).getParams();</span>
<span class="line-removed">205             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
206             if (namedGroup == null) {
207                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="18" id="anc18"></a><span class="line-modified">208                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);</span>

209             }
210 
<a name="19" id="anc19"></a><span class="line-modified">211             ECDHEPossession ecdhePossession = new ECDHEPossession(</span>
<span class="line-modified">212                     namedGroup, chc.sslContext.getSecureRandom());</span>
<span class="line-modified">213             chc.handshakePossessions.add(ecdhePossession);</span>

214             ECDHClientKeyExchangeMessage cke =
215                     new ECDHClientKeyExchangeMessage(
<a name="20" id="anc20"></a><span class="line-modified">216                             chc, ecdhePossession.publicKey);</span>
217             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
218                 SSLLogger.fine(
219                     &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
220             }
221 
222             // Output the handshake message.
223             cke.write(chc.handshakeOutput);
224             chc.handshakeOutput.flush();
225 
226             // update the states
227             SSLKeyExchange ke = SSLKeyExchange.valueOf(
228                     chc.negotiatedCipherSuite.keyExchange,
229                     chc.negotiatedProtocol);
230             if (ke == null) {
231                 // unlikely
232                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
233                         &quot;Not supported key exchange type&quot;);
234             } else {
235                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
236                 SecretKey masterSecret =
237                         masterKD.deriveKey(&quot;MasterSecret&quot;, null);
238                 chc.handshakeSession.setMasterSecret(masterSecret);
239 
240                 SSLTrafficKeyDerivation kd =
241                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
242                 if (kd == null) {
243                     // unlikely
244                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
245                             &quot;Not supported key derivation: &quot; +
246                             chc.negotiatedProtocol);
247                 } else {
248                     chc.handshakeKeyDerivation =
249                         kd.createKeyDerivation(chc, masterSecret);
250                 }
251             }
252 
253             // The handshake message has been delivered.
254             return null;
255         }
256     }
257 
258     /**
259      * The ECDH &quot;ClientKeyExchange&quot; handshake message consumer.
260      */
261     private static final
262             class ECDHClientKeyExchangeConsumer implements SSLConsumer {
263         // Prevent instantiation of this class.
264         private ECDHClientKeyExchangeConsumer() {
265             // blank
266         }
267 
268         @Override
269         public void consume(ConnectionContext context,
270                 ByteBuffer message) throws IOException {
271             // The consuming happens in server side only.
272             ServerHandshakeContext shc = (ServerHandshakeContext)context;
273 
274             X509Possession x509Possession = null;
275             for (SSLPossession possession : shc.handshakePossessions) {
276                 if (possession instanceof X509Possession) {
277                     x509Possession = (X509Possession)possession;
278                     break;
279                 }
280             }
281 
282             if (x509Possession == null) {
283                 // unlikely, have been checked during cipher suite negotiation.
284                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
285                     &quot;No expected EC server cert for ECDH client key exchange&quot;);
286             }
287 
<a name="21" id="anc21"></a><span class="line-modified">288             PrivateKey privateKey = x509Possession.popPrivateKey;</span>
<span class="line-modified">289             if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>

















290                 // unlikely, have been checked during cipher suite negotiation.
291                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="22" id="anc22"></a><span class="line-modified">292                     &quot;Not EC server cert for ECDH client key exchange&quot;);</span>
293             }
294 
<a name="23" id="anc23"></a><span class="line-modified">295             ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();</span>
<span class="line-removed">296             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
297             if (namedGroup == null) {
<a name="24" id="anc24"></a><span class="line-removed">298                 // unlikely, have been checked during cipher suite negotiation.</span>
299                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="25" id="anc25"></a><span class="line-modified">300                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);</span>

301             }
302 
303             SSLKeyExchange ke = SSLKeyExchange.valueOf(
304                     shc.negotiatedCipherSuite.keyExchange,
305                     shc.negotiatedProtocol);
306             if (ke == null) {
307                 // unlikely
308                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
309                         &quot;Not supported key exchange type&quot;);
310             }
311 
<a name="26" id="anc26"></a><span class="line-modified">312             // parse the handshake message</span>
313             ECDHClientKeyExchangeMessage cke =
314                     new ECDHClientKeyExchangeMessage(shc, message);
315             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
316                 SSLLogger.fine(
317                     &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
318             }
319 
320             // create the credentials
321             try {
<a name="27" id="anc27"></a><span class="line-modified">322                 ECPoint point =</span>
<span class="line-modified">323                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());</span>
<span class="line-modified">324                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-modified">325 </span>
<span class="line-modified">326                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">327                 ECPublicKey peerPublicKey =</span>
<span class="line-modified">328                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-modified">329 </span>
<span class="line-modified">330                 // check constraints of peer ECPublicKey</span>
<span class="line-modified">331                 if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">332                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">333                         peerPublicKey)) {</span>
<span class="line-removed">334                     throw new SSLHandshakeException(</span>
<span class="line-removed">335                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">336                 }</span>
<span class="line-removed">337 </span>
<span class="line-removed">338                 shc.handshakeCredentials.add(new ECDHECredentials(</span>
<span class="line-removed">339                         peerPublicKey, namedGroup));</span>
<span class="line-removed">340             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">341                 throw (SSLHandshakeException)(new SSLHandshakeException(</span>
<span class="line-removed">342                         &quot;Could not generate ECPublicKey&quot;).initCause(e));</span>
343             }
344 
345             // update the states
346             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
347             SecretKey masterSecret =
348                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
349             shc.handshakeSession.setMasterSecret(masterSecret);
350 
351             SSLTrafficKeyDerivation kd =
352                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
353             if (kd == null) {
354                 // unlikely
355                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
356                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
357             } else {
358                 shc.handshakeKeyDerivation =
359                     kd.createKeyDerivation(shc, masterSecret);
360             }
361         }
362     }
363 
364     /**
365      * The ECDHE &quot;ClientKeyExchange&quot; handshake message producer.
366      */
367     private static final
368             class ECDHEClientKeyExchangeProducer implements HandshakeProducer {
369         // Prevent instantiation of this class.
370         private ECDHEClientKeyExchangeProducer() {
371             // blank
372         }
373 
374         @Override
375         public byte[] produce(ConnectionContext context,
376                 HandshakeMessage message) throws IOException {
377             // The producing happens in client side only.
378             ClientHandshakeContext chc = (ClientHandshakeContext)context;
379 
<a name="28" id="anc28"></a><span class="line-modified">380             ECDHECredentials ecdheCredentials = null;</span>





381             for (SSLCredentials cd : chc.handshakeCredentials) {
<a name="29" id="anc29"></a><span class="line-modified">382                 if (cd instanceof ECDHECredentials) {</span>
<span class="line-modified">383                     ecdheCredentials = (ECDHECredentials)cd;</span>



384                     break;
385                 }
386             }
387 
<a name="30" id="anc30"></a><span class="line-modified">388             if (ecdheCredentials == null) {</span>
389                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
390                     &quot;No ECDHE credentials negotiated for client key exchange&quot;);
391             }
392 
<a name="31" id="anc31"></a><span class="line-modified">393             ECDHEPossession ecdhePossession = new ECDHEPossession(</span>
<span class="line-modified">394                     ecdheCredentials, chc.sslContext.getSecureRandom());</span>
<span class="line-modified">395             chc.handshakePossessions.add(ecdhePossession);</span>



396             ECDHClientKeyExchangeMessage cke =
397                     new ECDHClientKeyExchangeMessage(
<a name="32" id="anc32"></a><span class="line-modified">398                             chc, ecdhePossession.publicKey);</span>

399             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
400                 SSLLogger.fine(
401                     &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
402             }
403 
404             // Output the handshake message.
405             cke.write(chc.handshakeOutput);
406             chc.handshakeOutput.flush();
407 
408             // update the states
409             SSLKeyExchange ke = SSLKeyExchange.valueOf(
410                     chc.negotiatedCipherSuite.keyExchange,
411                     chc.negotiatedProtocol);
412             if (ke == null) {
413                 // unlikely
414                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
415                         &quot;Not supported key exchange type&quot;);
416             } else {
417                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
418                 SecretKey masterSecret =
419                         masterKD.deriveKey(&quot;MasterSecret&quot;, null);
420                 chc.handshakeSession.setMasterSecret(masterSecret);
421 
422                 SSLTrafficKeyDerivation kd =
423                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
424                 if (kd == null) {
425                     // unlikely
426                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
427                             &quot;Not supported key derivation: &quot; +
428                             chc.negotiatedProtocol);
429                 } else {
430                     chc.handshakeKeyDerivation =
431                         kd.createKeyDerivation(chc, masterSecret);
432                 }
433             }
434 
435             // The handshake message has been delivered.
436             return null;
437         }
438     }
439 
440     /**
441      * The ECDHE &quot;ClientKeyExchange&quot; handshake message consumer.
442      */
443     private static final
444             class ECDHEClientKeyExchangeConsumer implements SSLConsumer {
445         // Prevent instantiation of this class.
446         private ECDHEClientKeyExchangeConsumer() {
447             // blank
448         }
449 
450         @Override
451         public void consume(ConnectionContext context,
452                 ByteBuffer message) throws IOException {
453             // The consuming happens in server side only.
454             ServerHandshakeContext shc = (ServerHandshakeContext)context;
455 
<a name="33" id="anc33"></a><span class="line-modified">456             ECDHEPossession ecdhePossession = null;</span>




457             for (SSLPossession possession : shc.handshakePossessions) {
<a name="34" id="anc34"></a><span class="line-modified">458                 if (possession instanceof ECDHEPossession) {</span>
<span class="line-modified">459                     ecdhePossession = (ECDHEPossession)possession;</span>



460                     break;
461                 }
462             }
<a name="35" id="anc35"></a><span class="line-modified">463             if (ecdhePossession == null) {</span>

464                 // unlikely
465                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
466                     &quot;No expected ECDHE possessions for client key exchange&quot;);
467             }
468 
<a name="36" id="anc36"></a><span class="line-removed">469             ECParameterSpec params = ecdhePossession.publicKey.getParams();</span>
<span class="line-removed">470             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
471             if (namedGroup == null) {
<a name="37" id="anc37"></a><span class="line-modified">472                 // unlikely, have been checked during cipher suite negotiation.</span>
473                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
474                     &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
475             }
476 
477             SSLKeyExchange ke = SSLKeyExchange.valueOf(
478                     shc.negotiatedCipherSuite.keyExchange,
479                     shc.negotiatedProtocol);
480             if (ke == null) {
481                 // unlikely
482                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
483                         &quot;Not supported key exchange type&quot;);
484             }
485 
<a name="38" id="anc38"></a><span class="line-modified">486             // parse the handshake message</span>
487             ECDHClientKeyExchangeMessage cke =
488                     new ECDHClientKeyExchangeMessage(shc, message);
489             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
490                 SSLLogger.fine(
491                     &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
492             }
493 
494             // create the credentials
495             try {
<a name="39" id="anc39"></a><span class="line-modified">496                 ECPoint point =</span>
<span class="line-modified">497                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());</span>
<span class="line-modified">498                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-modified">499 </span>
<span class="line-modified">500                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">501                 ECPublicKey peerPublicKey =</span>
<span class="line-modified">502                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-modified">503 </span>
<span class="line-modified">504                 // check constraints of peer ECPublicKey</span>
<span class="line-modified">505                 if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">506                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">507                         peerPublicKey)) {</span>
<span class="line-removed">508                     throw new SSLHandshakeException(</span>
<span class="line-removed">509                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">510                 }</span>
<span class="line-removed">511 </span>
<span class="line-removed">512                 shc.handshakeCredentials.add(new ECDHECredentials(</span>
<span class="line-removed">513                         peerPublicKey, namedGroup));</span>
<span class="line-removed">514             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">515                 throw (SSLHandshakeException)(new SSLHandshakeException(</span>
<span class="line-removed">516                         &quot;Could not generate ECPublicKey&quot;).initCause(e));</span>
517             }
518 
519             // update the states
520             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
521             SecretKey masterSecret =
522                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
523             shc.handshakeSession.setMasterSecret(masterSecret);
524 
525             SSLTrafficKeyDerivation kd =
526                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
527             if (kd == null) {
528                 // unlikely
529                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
530                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
531             } else {
532                 shc.handshakeKeyDerivation =
533                     kd.createKeyDerivation(shc, masterSecret);
534             }
535         }
536     }
537 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
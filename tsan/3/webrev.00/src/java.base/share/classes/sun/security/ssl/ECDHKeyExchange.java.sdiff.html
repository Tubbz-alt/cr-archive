<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/ECDHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ECDHClientKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHServerKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ECDHKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AlgorithmConstraints;
 30 import java.security.CryptoPrimitive;
 31 import java.security.GeneralSecurityException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.PrivateKey;
 36 import java.security.PublicKey;
 37 import java.security.SecureRandom;
<span class="line-removed"> 38 import java.security.interfaces.ECPrivateKey;</span>
 39 import java.security.interfaces.ECPublicKey;
<span class="line-removed"> 40 import java.security.spec.AlgorithmParameterSpec;</span>
<span class="line-removed"> 41 import java.security.spec.ECGenParameterSpec;</span>
 42 import java.security.spec.ECParameterSpec;
 43 import java.security.spec.ECPoint;
 44 import java.security.spec.ECPublicKeySpec;
 45 import java.util.EnumSet;
 46 import javax.crypto.KeyAgreement;
 47 import javax.crypto.SecretKey;
<span class="line-removed"> 48 import javax.crypto.spec.SecretKeySpec;</span>
 49 import javax.net.ssl.SSLHandshakeException;
<span class="line-modified"> 50 import sun.security.ssl.CipherSuite.HashAlg;</span>
<span class="line-removed"> 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed"> 52 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
 53 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 54 import sun.security.ssl.X509Authentication.X509Credentials;
 55 import sun.security.ssl.X509Authentication.X509Possession;


 56 import sun.security.util.ECUtil;
 57 
 58 final class ECDHKeyExchange {
 59     static final SSLPossessionGenerator poGenerator =
 60             new ECDHEPossessionGenerator();
<span class="line-removed"> 61     static final SSLKeyAgreementGenerator ecdheKAGenerator =</span>
<span class="line-removed"> 62             new ECDHEKAGenerator();</span>
 63     static final SSLKeyAgreementGenerator ecdhKAGenerator =
 64             new ECDHKAGenerator();
 65 
<span class="line-modified"> 66     static final class ECDHECredentials implements SSLCredentials {</span>








 67         final ECPublicKey popPublicKey;
 68         final NamedGroup namedGroup;
 69 
 70         ECDHECredentials(ECPublicKey popPublicKey, NamedGroup namedGroup) {
 71             this.popPublicKey = popPublicKey;
 72             this.namedGroup = namedGroup;
 73         }
 74 










 75         static ECDHECredentials valueOf(NamedGroup namedGroup,
 76             byte[] encodedPoint) throws IOException, GeneralSecurityException {
 77 
<span class="line-modified"> 78             if (namedGroup.type != NamedGroupType.NAMED_GROUP_ECDHE) {</span>
 79                 throw new RuntimeException(
 80                     &quot;Credentials decoding:  Not ECDHE named group&quot;);
 81             }
 82 
 83             if (encodedPoint == null || encodedPoint.length == 0) {
 84                 return null;
 85             }
 86 
 87             ECParameterSpec parameters =
<span class="line-modified"> 88                     ECUtil.getECParameterSpec(null, namedGroup.oid);</span>
<span class="line-removed"> 89             if (parameters == null) {</span>
<span class="line-removed"> 90                 return null;</span>
<span class="line-removed"> 91             }</span>
<span class="line-removed"> 92 </span>
 93             ECPoint point = ECUtil.decodePoint(
 94                     encodedPoint, parameters.getCurve());
 95             KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
 96             ECPublicKey publicKey = (ECPublicKey)factory.generatePublic(
 97                     new ECPublicKeySpec(point, parameters));
 98             return new ECDHECredentials(publicKey, namedGroup);
 99         }
100     }
101 
<span class="line-modified">102     static final class ECDHEPossession implements SSLPossession {</span>
103         final PrivateKey privateKey;
104         final ECPublicKey publicKey;
105         final NamedGroup namedGroup;
106 
107         ECDHEPossession(NamedGroup namedGroup, SecureRandom random) {
108             try {
109                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
<span class="line-modified">110                 ECGenParameterSpec params =</span>
<span class="line-removed">111                         (ECGenParameterSpec)namedGroup.getParameterSpec();</span>
<span class="line-removed">112                 kpg.initialize(params, random);</span>
113                 KeyPair kp = kpg.generateKeyPair();
114                 privateKey = kp.getPrivate();
115                 publicKey = (ECPublicKey)kp.getPublic();
116             } catch (GeneralSecurityException e) {
117                 throw new RuntimeException(
118                     &quot;Could not generate ECDH keypair&quot;, e);
119             }
120 
121             this.namedGroup = namedGroup;
122         }
123 
124         ECDHEPossession(ECDHECredentials credentials, SecureRandom random) {
125             ECParameterSpec params = credentials.popPublicKey.getParams();
126             try {
127                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
128                 kpg.initialize(params, random);
129                 KeyPair kp = kpg.generateKeyPair();
130                 privateKey = kp.getPrivate();
131                 publicKey = (ECPublicKey)kp.getPublic();
132             } catch (GeneralSecurityException e) {
</pre>
<hr />
<pre>
183 
184                 ECParameterSpec params = publicKey.getParams();
185                 ECPoint point =
186                         ECUtil.decodePoint(encodedPoint, params.getCurve());
187                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
188 
189                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
190                 ECPublicKey pubKey = (ECPublicKey)kf.generatePublic(spec);
191 
192                 // check constraints of ECPublicKey
193                 if (!constraints.permits(
194                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), pubKey)) {
195                     throw new SSLHandshakeException(
196                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
197                 }
198             } catch (GeneralSecurityException | java.io.IOException e) {
199                 throw (SSLHandshakeException) new SSLHandshakeException(
200                         &quot;Could not generate ECPublicKey&quot;).initCause(e);
201             }
202         }















203     }
204 
205     private static final
206             class ECDHEPossessionGenerator implements SSLPossessionGenerator {
207         // Prevent instantiation of this class.
208         private ECDHEPossessionGenerator() {
209             // blank
210         }
211 
212         @Override
213         public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">214             NamedGroup preferableNamedGroup = null;</span>



215             if ((context.clientRequestedNamedGroups != null) &amp;&amp;
216                     (!context.clientRequestedNamedGroups.isEmpty())) {
217                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
218                         context.negotiatedProtocol,
219                         context.algorithmConstraints,
<span class="line-modified">220                         NamedGroupType.NAMED_GROUP_ECDHE,</span>


221                         context.clientRequestedNamedGroups);
222             } else {
223                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
224                         context.negotiatedProtocol,
225                         context.algorithmConstraints,
<span class="line-modified">226                         NamedGroupType.NAMED_GROUP_ECDHE);</span>


227             }
228 
229             if (preferableNamedGroup != null) {
<span class="line-modified">230                 return new ECDHEPossession(preferableNamedGroup,</span>
<span class="line-modified">231                             context.sslContext.getSecureRandom());</span>
232             }
233 
234             // no match found, cannot use this cipher suite.
235             //
236             return null;
237         }
238     }
239 
240     private static final
241             class ECDHKAGenerator implements SSLKeyAgreementGenerator {
242         // Prevent instantiation of this class.
243         private ECDHKAGenerator() {
244             // blank
245         }
246 
247         @Override
248         public SSLKeyDerivation createKeyDerivation(
249                 HandshakeContext context) throws IOException {
250             if (context instanceof ServerHandshakeContext) {
251                 return createServerKeyDerivation(
252                         (ServerHandshakeContext)context);
253             } else {
254                 return createClientKeyDerivation(
255                         (ClientHandshakeContext)context);
256             }
257         }
258 
259         private SSLKeyDerivation createServerKeyDerivation(
260                 ServerHandshakeContext shc) throws IOException {
261             X509Possession x509Possession = null;
262             ECDHECredentials ecdheCredentials = null;
263             for (SSLPossession poss : shc.handshakePossessions) {
264                 if (!(poss instanceof X509Possession)) {
265                     continue;
266                 }
267 
<span class="line-modified">268                 PrivateKey privateKey = ((X509Possession)poss).popPrivateKey;</span>
<span class="line-modified">269                 if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>

270                     continue;
271                 }
272 
<span class="line-removed">273                 ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();</span>
274                 NamedGroup ng = NamedGroup.valueOf(params);
275                 if (ng == null) {
<span class="line-modified">276                     // unlikely, have been checked during cipher suite negotiation.</span>

277                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
278                         &quot;Unsupported EC server cert for ECDH key exchange&quot;);
279                 }
280 
281                 for (SSLCredentials cred : shc.handshakeCredentials) {
282                     if (!(cred instanceof ECDHECredentials)) {
283                         continue;
284                     }
285                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
286                         ecdheCredentials = (ECDHECredentials)cred;
287                         break;
288                     }
289                 }
290 
291                 if (ecdheCredentials != null) {
292                     x509Possession = (X509Possession)poss;
293                     break;
294                 }
295             }
296 
297             if (x509Possession == null || ecdheCredentials == null) {
298                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
299                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
300             }
301 
<span class="line-modified">302             return new ECDHEKAKeyDerivation(shc,</span>
303                 x509Possession.popPrivateKey, ecdheCredentials.popPublicKey);
304         }
305 
306         private SSLKeyDerivation createClientKeyDerivation(
307                 ClientHandshakeContext chc) throws IOException {
308             ECDHEPossession ecdhePossession = null;
309             X509Credentials x509Credentials = null;
310             for (SSLPossession poss : chc.handshakePossessions) {
311                 if (!(poss instanceof ECDHEPossession)) {
312                     continue;
313                 }
314 
315                 NamedGroup ng = ((ECDHEPossession)poss).namedGroup;
316                 for (SSLCredentials cred : chc.handshakeCredentials) {
317                     if (!(cred instanceof X509Credentials)) {
318                         continue;
319                     }
320 
321                     PublicKey publicKey = ((X509Credentials)cred).popPublicKey;
322                     if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {
</pre>
<hr />
<pre>
331                             &quot;Unsupported EC server cert for ECDH key exchange&quot;);
332                     }
333 
334                     if (ng.equals(namedGroup)) {
335                         x509Credentials = (X509Credentials)cred;
336                         break;
337                     }
338                 }
339 
340                 if (x509Credentials != null) {
341                     ecdhePossession = (ECDHEPossession)poss;
342                     break;
343                 }
344             }
345 
346             if (ecdhePossession == null || x509Credentials == null) {
347                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
348                     &quot;No sufficient ECDH key agreement parameters negotiated&quot;);
349             }
350 
<span class="line-modified">351             return new ECDHEKAKeyDerivation(chc,</span>
352                 ecdhePossession.privateKey, x509Credentials.popPublicKey);
353         }
354     }
355 
356     private static final
357             class ECDHEKAGenerator implements SSLKeyAgreementGenerator {
358         // Prevent instantiation of this class.
359         private ECDHEKAGenerator() {
360             // blank
361         }
362 
363         @Override
364         public SSLKeyDerivation createKeyDerivation(
365                 HandshakeContext context) throws IOException {
366             ECDHEPossession ecdhePossession = null;
367             ECDHECredentials ecdheCredentials = null;
368             for (SSLPossession poss : context.handshakePossessions) {
369                 if (!(poss instanceof ECDHEPossession)) {
370                     continue;
371                 }
</pre>
<hr />
<pre>
375                     if (!(cred instanceof ECDHECredentials)) {
376                         continue;
377                     }
378                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
379                         ecdheCredentials = (ECDHECredentials)cred;
380                         break;
381                     }
382                 }
383 
384                 if (ecdheCredentials != null) {
385                     ecdhePossession = (ECDHEPossession)poss;
386                     break;
387                 }
388             }
389 
390             if (ecdhePossession == null || ecdheCredentials == null) {
391                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
392                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
393             }
394 
<span class="line-modified">395             return new ECDHEKAKeyDerivation(context,</span>
396                 ecdhePossession.privateKey, ecdheCredentials.popPublicKey);
397         }
398     }
399 




400     private static final
<span class="line-modified">401             class ECDHEKAKeyDerivation implements SSLKeyDerivation {</span>
<span class="line-modified">402         private final HandshakeContext context;</span>
<span class="line-modified">403         private final PrivateKey localPrivateKey;</span>
<span class="line-modified">404         private final PublicKey peerPublicKey;</span>
<span class="line-removed">405 </span>
<span class="line-removed">406         ECDHEKAKeyDerivation(HandshakeContext context,</span>
<span class="line-removed">407                 PrivateKey localPrivateKey,</span>
<span class="line-removed">408                 PublicKey peerPublicKey) {</span>
<span class="line-removed">409             this.context = context;</span>
<span class="line-removed">410             this.localPrivateKey = localPrivateKey;</span>
<span class="line-removed">411             this.peerPublicKey = peerPublicKey;</span>
412         }
413 
414         @Override
<span class="line-modified">415         public SecretKey deriveKey(String algorithm,</span>
<span class="line-modified">416                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">417             if (!context.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">418                 return t12DeriveKey(algorithm, params);</span>
<span class="line-removed">419             } else {</span>
<span class="line-removed">420                 return t13DeriveKey(algorithm, params);</span>
<span class="line-removed">421             }</span>
<span class="line-removed">422         }</span>
423 
<span class="line-modified">424         private SecretKey t12DeriveKey(String algorithm,</span>
<span class="line-modified">425                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-modified">426             try {</span>
<span class="line-removed">427                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span>
<span class="line-removed">428                 ka.init(localPrivateKey);</span>
<span class="line-removed">429                 ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">430                 SecretKey preMasterSecret =</span>
<span class="line-removed">431                         ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">432 </span>
<span class="line-removed">433                 SSLMasterKeyDerivation mskd =</span>
<span class="line-removed">434                         SSLMasterKeyDerivation.valueOf(</span>
<span class="line-removed">435                                 context.negotiatedProtocol);</span>
<span class="line-removed">436                 if (mskd == null) {</span>
<span class="line-removed">437                     // unlikely</span>
<span class="line-removed">438                     throw new SSLHandshakeException(</span>
<span class="line-removed">439                             &quot;No expected master key derivation for protocol: &quot; +</span>
<span class="line-removed">440                             context.negotiatedProtocol.name);</span>
<span class="line-removed">441                 }</span>
<span class="line-removed">442                 SSLKeyDerivation kd = mskd.createKeyDerivation(</span>
<span class="line-removed">443                         context, preMasterSecret);</span>
<span class="line-removed">444                 return kd.deriveKey(&quot;MasterSecret&quot;, params);</span>
<span class="line-removed">445             } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">446                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">447                     &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">448             }</span>
<span class="line-removed">449         }</span>
450 
<span class="line-modified">451         private SecretKey t13DeriveKey(String algorithm,</span>
<span class="line-modified">452                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-modified">453             try {</span>
<span class="line-modified">454                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span>
<span class="line-modified">455                 ka.init(localPrivateKey);</span>
<span class="line-modified">456                 ka.doPhase(peerPublicKey, true);</span>
<span class="line-modified">457                 SecretKey sharedSecret =</span>
<span class="line-modified">458                         ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-modified">459 </span>
<span class="line-modified">460                 HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;</span>
<span class="line-modified">461                 SSLKeyDerivation kd = context.handshakeKeyDerivation;</span>
<span class="line-modified">462                 HKDF hkdf = new HKDF(hashAlg.name);</span>
<span class="line-modified">463                 if (kd == null) {   // No PSK is in use.</span>
<span class="line-modified">464                     // If PSK is not in use Early Secret will still be</span>
<span class="line-modified">465                     // HKDF-Extract(0, 0).</span>
<span class="line-modified">466                     byte[] zeros = new byte[hashAlg.hashLength];</span>
<span class="line-modified">467                     SecretKeySpec ikm =</span>
<span class="line-modified">468                             new SecretKeySpec(zeros, &quot;TlsPreSharedSecret&quot;);</span>
<span class="line-modified">469                     SecretKey earlySecret =</span>
<span class="line-removed">470                             hkdf.extract(zeros, ikm, &quot;TlsEarlySecret&quot;);</span>
<span class="line-removed">471                     kd = new SSLSecretDerivation(context, earlySecret);</span>
472                 }

473 
<span class="line-modified">474                 // derive salt secret</span>
<span class="line-modified">475                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);</span>



476 
<span class="line-modified">477                 // derive handshake secret</span>
<span class="line-modified">478                 return hkdf.extract(saltSecret, sharedSecret, algorithm);</span>
<span class="line-modified">479             } catch (GeneralSecurityException gse) {</span>
<span class="line-modified">480                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-modified">481                     &quot;Could not generate secret&quot;).initCause(gse);</span>





482             }




483         }
484     }
485 }
</pre>
</td>
<td>
<hr />
<pre>
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.security.AlgorithmConstraints;
 30 import java.security.CryptoPrimitive;
 31 import java.security.GeneralSecurityException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.PrivateKey;
 36 import java.security.PublicKey;
 37 import java.security.SecureRandom;

 38 import java.security.interfaces.ECPublicKey;


 39 import java.security.spec.ECParameterSpec;
 40 import java.security.spec.ECPoint;
 41 import java.security.spec.ECPublicKeySpec;
 42 import java.util.EnumSet;
 43 import javax.crypto.KeyAgreement;
 44 import javax.crypto.SecretKey;

 45 import javax.net.ssl.SSLHandshakeException;
<span class="line-modified"> 46 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>


 47 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 48 import sun.security.ssl.X509Authentication.X509Credentials;
 49 import sun.security.ssl.X509Authentication.X509Possession;
<span class="line-added"> 50 import sun.security.ssl.XDHKeyExchange.XDHECredentials;</span>
<span class="line-added"> 51 import sun.security.ssl.XDHKeyExchange.XDHEPossession;</span>
 52 import sun.security.util.ECUtil;
 53 
 54 final class ECDHKeyExchange {
 55     static final SSLPossessionGenerator poGenerator =
 56             new ECDHEPossessionGenerator();


 57     static final SSLKeyAgreementGenerator ecdhKAGenerator =
 58             new ECDHKAGenerator();
 59 
<span class="line-modified"> 60     // TLSv1.3</span>
<span class="line-added"> 61     static final SSLKeyAgreementGenerator ecdheKAGenerator =</span>
<span class="line-added"> 62             new ECDHEKAGenerator();</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64     // TLSv1-1.2, the KA gets more difficult with EC/XEC keys</span>
<span class="line-added"> 65     static final SSLKeyAgreementGenerator ecdheXdhKAGenerator =</span>
<span class="line-added"> 66             new ECDHEXDHKAGenerator();</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     static final class ECDHECredentials implements NamedGroupCredentials {</span>
 69         final ECPublicKey popPublicKey;
 70         final NamedGroup namedGroup;
 71 
 72         ECDHECredentials(ECPublicKey popPublicKey, NamedGroup namedGroup) {
 73             this.popPublicKey = popPublicKey;
 74             this.namedGroup = namedGroup;
 75         }
 76 
<span class="line-added"> 77         @Override</span>
<span class="line-added"> 78         public PublicKey getPublicKey() {</span>
<span class="line-added"> 79             return popPublicKey;</span>
<span class="line-added"> 80         }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82         @Override</span>
<span class="line-added"> 83         public NamedGroup getNamedGroup() {</span>
<span class="line-added"> 84             return namedGroup;</span>
<span class="line-added"> 85         }</span>
<span class="line-added"> 86 </span>
 87         static ECDHECredentials valueOf(NamedGroup namedGroup,
 88             byte[] encodedPoint) throws IOException, GeneralSecurityException {
 89 
<span class="line-modified"> 90             if (namedGroup.spec != NamedGroupSpec.NAMED_GROUP_ECDHE) {</span>
 91                 throw new RuntimeException(
 92                     &quot;Credentials decoding:  Not ECDHE named group&quot;);
 93             }
 94 
 95             if (encodedPoint == null || encodedPoint.length == 0) {
 96                 return null;
 97             }
 98 
 99             ECParameterSpec parameters =
<span class="line-modified">100                     (ECParameterSpec)namedGroup.keAlgParamSpec;</span>




101             ECPoint point = ECUtil.decodePoint(
102                     encodedPoint, parameters.getCurve());
103             KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
104             ECPublicKey publicKey = (ECPublicKey)factory.generatePublic(
105                     new ECPublicKeySpec(point, parameters));
106             return new ECDHECredentials(publicKey, namedGroup);
107         }
108     }
109 
<span class="line-modified">110     static final class ECDHEPossession implements NamedGroupPossession {</span>
111         final PrivateKey privateKey;
112         final ECPublicKey publicKey;
113         final NamedGroup namedGroup;
114 
115         ECDHEPossession(NamedGroup namedGroup, SecureRandom random) {
116             try {
117                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
<span class="line-modified">118                 kpg.initialize(namedGroup.keAlgParamSpec, random);</span>


119                 KeyPair kp = kpg.generateKeyPair();
120                 privateKey = kp.getPrivate();
121                 publicKey = (ECPublicKey)kp.getPublic();
122             } catch (GeneralSecurityException e) {
123                 throw new RuntimeException(
124                     &quot;Could not generate ECDH keypair&quot;, e);
125             }
126 
127             this.namedGroup = namedGroup;
128         }
129 
130         ECDHEPossession(ECDHECredentials credentials, SecureRandom random) {
131             ECParameterSpec params = credentials.popPublicKey.getParams();
132             try {
133                 KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
134                 kpg.initialize(params, random);
135                 KeyPair kp = kpg.generateKeyPair();
136                 privateKey = kp.getPrivate();
137                 publicKey = (ECPublicKey)kp.getPublic();
138             } catch (GeneralSecurityException e) {
</pre>
<hr />
<pre>
189 
190                 ECParameterSpec params = publicKey.getParams();
191                 ECPoint point =
192                         ECUtil.decodePoint(encodedPoint, params.getCurve());
193                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
194 
195                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
196                 ECPublicKey pubKey = (ECPublicKey)kf.generatePublic(spec);
197 
198                 // check constraints of ECPublicKey
199                 if (!constraints.permits(
200                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), pubKey)) {
201                     throw new SSLHandshakeException(
202                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
203                 }
204             } catch (GeneralSecurityException | java.io.IOException e) {
205                 throw (SSLHandshakeException) new SSLHandshakeException(
206                         &quot;Could not generate ECPublicKey&quot;).initCause(e);
207             }
208         }
<span class="line-added">209 </span>
<span class="line-added">210         @Override</span>
<span class="line-added">211         public PublicKey getPublicKey() {</span>
<span class="line-added">212             return publicKey;</span>
<span class="line-added">213         }</span>
<span class="line-added">214 </span>
<span class="line-added">215         @Override</span>
<span class="line-added">216         public NamedGroup getNamedGroup() {</span>
<span class="line-added">217             return namedGroup;</span>
<span class="line-added">218         }</span>
<span class="line-added">219 </span>
<span class="line-added">220         @Override</span>
<span class="line-added">221         public PrivateKey getPrivateKey() {</span>
<span class="line-added">222             return privateKey;</span>
<span class="line-added">223         }</span>
224     }
225 
226     private static final
227             class ECDHEPossessionGenerator implements SSLPossessionGenerator {
228         // Prevent instantiation of this class.
229         private ECDHEPossessionGenerator() {
230             // blank
231         }
232 
233         @Override
234         public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">235 </span>
<span class="line-added">236             NamedGroup preferableNamedGroup;</span>
<span class="line-added">237 </span>
<span class="line-added">238             // Find most preferred EC or XEC groups</span>
239             if ((context.clientRequestedNamedGroups != null) &amp;&amp;
240                     (!context.clientRequestedNamedGroups.isEmpty())) {
241                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
242                         context.negotiatedProtocol,
243                         context.algorithmConstraints,
<span class="line-modified">244                         new NamedGroupSpec[] {</span>
<span class="line-added">245                             NamedGroupSpec.NAMED_GROUP_ECDHE,</span>
<span class="line-added">246                             NamedGroupSpec.NAMED_GROUP_XDH },</span>
247                         context.clientRequestedNamedGroups);
248             } else {
249                 preferableNamedGroup = SupportedGroups.getPreferredGroup(
250                         context.negotiatedProtocol,
251                         context.algorithmConstraints,
<span class="line-modified">252                         new NamedGroupSpec[] {</span>
<span class="line-added">253                             NamedGroupSpec.NAMED_GROUP_ECDHE,</span>
<span class="line-added">254                             NamedGroupSpec.NAMED_GROUP_XDH });</span>
255             }
256 
257             if (preferableNamedGroup != null) {
<span class="line-modified">258                 return preferableNamedGroup.createPossession(</span>
<span class="line-modified">259                     context.sslContext.getSecureRandom());</span>
260             }
261 
262             // no match found, cannot use this cipher suite.
263             //
264             return null;
265         }
266     }
267 
268     private static final
269             class ECDHKAGenerator implements SSLKeyAgreementGenerator {
270         // Prevent instantiation of this class.
271         private ECDHKAGenerator() {
272             // blank
273         }
274 
275         @Override
276         public SSLKeyDerivation createKeyDerivation(
277                 HandshakeContext context) throws IOException {
278             if (context instanceof ServerHandshakeContext) {
279                 return createServerKeyDerivation(
280                         (ServerHandshakeContext)context);
281             } else {
282                 return createClientKeyDerivation(
283                         (ClientHandshakeContext)context);
284             }
285         }
286 
287         private SSLKeyDerivation createServerKeyDerivation(
288                 ServerHandshakeContext shc) throws IOException {
289             X509Possession x509Possession = null;
290             ECDHECredentials ecdheCredentials = null;
291             for (SSLPossession poss : shc.handshakePossessions) {
292                 if (!(poss instanceof X509Possession)) {
293                     continue;
294                 }
295 
<span class="line-modified">296                 ECParameterSpec params =</span>
<span class="line-modified">297                         ((X509Possession)poss).getECParameterSpec();</span>
<span class="line-added">298                 if (params == null) {</span>
299                     continue;
300                 }
301 

302                 NamedGroup ng = NamedGroup.valueOf(params);
303                 if (ng == null) {
<span class="line-modified">304                     // unlikely, have been checked during cipher suite</span>
<span class="line-added">305                     // negotiation.</span>
306                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
307                         &quot;Unsupported EC server cert for ECDH key exchange&quot;);
308                 }
309 
310                 for (SSLCredentials cred : shc.handshakeCredentials) {
311                     if (!(cred instanceof ECDHECredentials)) {
312                         continue;
313                     }
314                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
315                         ecdheCredentials = (ECDHECredentials)cred;
316                         break;
317                     }
318                 }
319 
320                 if (ecdheCredentials != null) {
321                     x509Possession = (X509Possession)poss;
322                     break;
323                 }
324             }
325 
326             if (x509Possession == null || ecdheCredentials == null) {
327                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
328                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
329             }
330 
<span class="line-modified">331             return new KAKeyDerivation(&quot;ECDH&quot;, shc,</span>
332                 x509Possession.popPrivateKey, ecdheCredentials.popPublicKey);
333         }
334 
335         private SSLKeyDerivation createClientKeyDerivation(
336                 ClientHandshakeContext chc) throws IOException {
337             ECDHEPossession ecdhePossession = null;
338             X509Credentials x509Credentials = null;
339             for (SSLPossession poss : chc.handshakePossessions) {
340                 if (!(poss instanceof ECDHEPossession)) {
341                     continue;
342                 }
343 
344                 NamedGroup ng = ((ECDHEPossession)poss).namedGroup;
345                 for (SSLCredentials cred : chc.handshakeCredentials) {
346                     if (!(cred instanceof X509Credentials)) {
347                         continue;
348                     }
349 
350                     PublicKey publicKey = ((X509Credentials)cred).popPublicKey;
351                     if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {
</pre>
<hr />
<pre>
360                             &quot;Unsupported EC server cert for ECDH key exchange&quot;);
361                     }
362 
363                     if (ng.equals(namedGroup)) {
364                         x509Credentials = (X509Credentials)cred;
365                         break;
366                     }
367                 }
368 
369                 if (x509Credentials != null) {
370                     ecdhePossession = (ECDHEPossession)poss;
371                     break;
372                 }
373             }
374 
375             if (ecdhePossession == null || x509Credentials == null) {
376                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
377                     &quot;No sufficient ECDH key agreement parameters negotiated&quot;);
378             }
379 
<span class="line-modified">380             return new KAKeyDerivation(&quot;ECDH&quot;, chc,</span>
381                 ecdhePossession.privateKey, x509Credentials.popPublicKey);
382         }
383     }
384 
385     private static final
386             class ECDHEKAGenerator implements SSLKeyAgreementGenerator {
387         // Prevent instantiation of this class.
388         private ECDHEKAGenerator() {
389             // blank
390         }
391 
392         @Override
393         public SSLKeyDerivation createKeyDerivation(
394                 HandshakeContext context) throws IOException {
395             ECDHEPossession ecdhePossession = null;
396             ECDHECredentials ecdheCredentials = null;
397             for (SSLPossession poss : context.handshakePossessions) {
398                 if (!(poss instanceof ECDHEPossession)) {
399                     continue;
400                 }
</pre>
<hr />
<pre>
404                     if (!(cred instanceof ECDHECredentials)) {
405                         continue;
406                     }
407                     if (ng.equals(((ECDHECredentials)cred).namedGroup)) {
408                         ecdheCredentials = (ECDHECredentials)cred;
409                         break;
410                     }
411                 }
412 
413                 if (ecdheCredentials != null) {
414                     ecdhePossession = (ECDHEPossession)poss;
415                     break;
416                 }
417             }
418 
419             if (ecdhePossession == null || ecdheCredentials == null) {
420                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
421                     &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
422             }
423 
<span class="line-modified">424             return new KAKeyDerivation(&quot;ECDH&quot;, context,</span>
425                 ecdhePossession.privateKey, ecdheCredentials.popPublicKey);
426         }
427     }
428 
<span class="line-added">429     /*</span>
<span class="line-added">430      * A Generator for TLSv1-1.2 to create a ECDHE or a XDH KeyDerivation</span>
<span class="line-added">431      * object depending on the negotiated group.</span>
<span class="line-added">432      */</span>
433     private static final
<span class="line-modified">434             class ECDHEXDHKAGenerator implements SSLKeyAgreementGenerator {</span>
<span class="line-modified">435         // Prevent instantiation of this class.</span>
<span class="line-modified">436         private ECDHEXDHKAGenerator() {</span>
<span class="line-modified">437             // blank</span>







438         }
439 
440         @Override
<span class="line-modified">441         public SSLKeyDerivation createKeyDerivation(</span>
<span class="line-modified">442                 HandshakeContext context) throws IOException {</span>






443 
<span class="line-modified">444             NamedGroupPossession namedGroupPossession = null;</span>
<span class="line-modified">445             NamedGroupCredentials namedGroupCredentials = null;</span>
<span class="line-modified">446             NamedGroup namedGroup = null;</span>























447 
<span class="line-modified">448             // Find a possession/credential combo using the same named group</span>
<span class="line-modified">449             search:</span>
<span class="line-modified">450             for (SSLPossession poss : context.handshakePossessions) {</span>
<span class="line-modified">451                 for (SSLCredentials cred : context.handshakeCredentials) {</span>
<span class="line-modified">452                     if (((poss instanceof ECDHEPossession) &amp;&amp;</span>
<span class="line-modified">453                             (cred instanceof ECDHECredentials)) ||</span>
<span class="line-modified">454                             (((poss instanceof XDHEPossession) &amp;&amp;</span>
<span class="line-modified">455                             (cred instanceof XDHECredentials)))) {</span>
<span class="line-modified">456                         NamedGroupPossession p = (NamedGroupPossession)poss;</span>
<span class="line-modified">457                         NamedGroupCredentials c = (NamedGroupCredentials)cred;</span>
<span class="line-modified">458                         if (p.getNamedGroup() != c.getNamedGroup()) {</span>
<span class="line-modified">459                             continue;</span>
<span class="line-modified">460                         } else {</span>
<span class="line-modified">461                             namedGroup = p.getNamedGroup();</span>
<span class="line-modified">462                         }</span>
<span class="line-modified">463                         namedGroupPossession = p;</span>
<span class="line-modified">464                         namedGroupCredentials = c;</span>
<span class="line-modified">465                         break search;</span>
<span class="line-modified">466                     }</span>


467                 }
<span class="line-added">468             }</span>
469 
<span class="line-modified">470             if (namedGroupPossession == null || namedGroupCredentials == null) {</span>
<span class="line-modified">471                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added">472                     &quot;No sufficient ECDHE/XDH key agreement &quot; +</span>
<span class="line-added">473                             &quot;parameters negotiated&quot;);</span>
<span class="line-added">474             }</span>
475 
<span class="line-modified">476             String alg;</span>
<span class="line-modified">477             switch (namedGroup.spec) {</span>
<span class="line-modified">478                 case NAMED_GROUP_ECDHE:</span>
<span class="line-modified">479                     alg = &quot;ECDH&quot;;</span>
<span class="line-modified">480                     break;</span>
<span class="line-added">481                 case NAMED_GROUP_XDH:</span>
<span class="line-added">482                     alg = &quot;XDH&quot;;</span>
<span class="line-added">483                     break;</span>
<span class="line-added">484                 default:</span>
<span class="line-added">485                     throw new RuntimeException(&quot;Unexpected named group type&quot;);</span>
486             }
<span class="line-added">487 </span>
<span class="line-added">488             return new KAKeyDerivation(alg, context,</span>
<span class="line-added">489                     namedGroupPossession.getPrivateKey(),</span>
<span class="line-added">490                     namedGroupCredentials.getPublicKey());</span>
491         }
492     }
493 }
</pre>
</td>
</tr>
</table>
<center><a href="ECDHClientKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHServerKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
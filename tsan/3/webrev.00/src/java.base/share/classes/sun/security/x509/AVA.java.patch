diff a/src/java.base/share/classes/sun/security/x509/AVA.java b/src/java.base/share/classes/sun/security/x509/AVA.java
--- a/src/java.base/share/classes/sun/security/x509/AVA.java
+++ b/src/java.base/share/classes/sun/security/x509/AVA.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,10 +31,12 @@
 import java.io.Reader;
 import java.security.AccessController;
 import java.text.Normalizer;
 import java.util.*;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import sun.security.action.GetBooleanAction;
 import sun.security.util.*;
 import sun.security.pkcs.PKCS9Attribute;
 
 
@@ -523,18 +525,17 @@
             }
         }
         return null;
     }
 
-    private static String getEmbeddedHexString(List<Byte> hexList)
-                                                throws IOException {
+    private static String getEmbeddedHexString(List<Byte> hexList) {
         int n = hexList.size();
         byte[] hexBytes = new byte[n];
         for (int i = 0; i < n; i++) {
-                hexBytes[i] = hexList.get(i).byteValue();
+            hexBytes[i] = hexList.get(i).byteValue();
         }
-        return new String(hexBytes, "UTF8");
+        return new String(hexBytes, UTF_8);
     }
 
     private static boolean isTerminator(int ch, int format) {
         switch (ch) {
         case -1:
@@ -596,11 +597,11 @@
         // Individual attribute value assertions are SEQUENCE of two values.
         // That'd be a "struct" outside of ASN.1.
         if (derval.tag != DerValue.tag_Sequence) {
             throw new IOException("AVA not a sequence");
         }
-        oid = X500Name.intern(derval.data.getOID());
+        oid = derval.data.getOID();
         value = derval.data.getDerValue();
 
         if (derval.data.available() != 0) {
             throw new IOException("AVA, extra bytes = "
                 + derval.data.available());
@@ -750,11 +751,11 @@
              * NOTE: this implementation only emits DirectoryStrings of the
              * types returned by isDerString().
              */
             String valStr = null;
             try {
-                valStr = new String(value.getDataBytes(), "UTF8");
+                valStr = new String(value.getDataBytes(), UTF_8);
             } catch (IOException ie) {
                 throw new IllegalArgumentException("DER Value conversion");
             }
 
             /*
@@ -802,17 +803,11 @@
 
                 } else if (debug != null && Debug.isOn("ava")) {
 
                     // embed non-printable/non-escaped char
                     // as escaped hex pairs for debugging
-                    byte[] valueBytes = null;
-                    try {
-                        valueBytes = Character.toString(c).getBytes("UTF8");
-                    } catch (IOException ie) {
-                        throw new IllegalArgumentException
-                                        ("DER Value conversion");
-                    }
+                    byte[] valueBytes = Character.toString(c).getBytes(UTF_8);
                     for (int j = 0; j < valueBytes.length; j++) {
                         sbuffer.append('\\');
                         char hexChar = Character.forDigit
                                 (0xF & (valueBytes[j] >>> 4), 16);
                         sbuffer.append(Character.toUpperCase(hexChar));
@@ -903,11 +898,11 @@
              * NOTE: this implementation only emits DirectoryStrings of the
              * types returned by isDerString().
              */
             String valStr = null;
             try {
-                valStr = new String(value.getDataBytes(), "UTF8");
+                valStr = new String(value.getDataBytes(), UTF_8);
             } catch (IOException ie) {
                 throw new IllegalArgumentException("DER Value conversion");
             }
 
             /*
@@ -964,17 +959,11 @@
                     // embed non-printable/non-escaped char
                     // as escaped hex pairs for debugging
 
                     previousWhite = false;
 
-                    byte[] valueBytes = null;
-                    try {
-                        valueBytes = Character.toString(c).getBytes("UTF8");
-                    } catch (IOException ie) {
-                        throw new IllegalArgumentException
-                                        ("DER Value conversion");
-                    }
+                    byte[] valueBytes = Character.toString(c).getBytes(UTF_8);
                     for (int j = 0; j < valueBytes.length; j++) {
                         sbuffer.append('\\');
                         sbuffer.append(Character.forDigit
                                         (0xF & (valueBytes[j] >>> 4), 16));
                         sbuffer.append(Character.forDigit
@@ -1114,11 +1103,11 @@
 
                         previousWhite = false;
 
                         // embed escaped hex pairs
                         byte[] valueBytes =
-                                Character.toString(c).getBytes("UTF8");
+                                Character.toString(c).getBytes(UTF_8);
                         for (int j = 0; j < valueBytes.length; j++) {
                             sbuffer.append('\\');
                             char hexChar = Character.forDigit
                                         (0xF & (valueBytes[j] >>> 4), 16);
                             sbuffer.append(Character.toUpperCase(hexChar));

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketOptionRegistry.java.template.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
  31 import java.net.InetSocketAddress;
  32 import java.net.ProtocolFamily;
  33 import java.net.Socket;
  34 import java.net.SocketAddress;

  35 import java.net.SocketOption;

  36 import java.net.StandardProtocolFamily;
  37 import java.net.StandardSocketOptions;
  38 import java.nio.ByteBuffer;
  39 import java.nio.channels.AlreadyBoundException;
  40 import java.nio.channels.AlreadyConnectedException;
  41 import java.nio.channels.AsynchronousCloseException;
  42 import java.nio.channels.ClosedChannelException;
  43 import java.nio.channels.ConnectionPendingException;

  44 import java.nio.channels.NoConnectionPendingException;
  45 import java.nio.channels.NotYetConnectedException;
  46 import java.nio.channels.SelectionKey;
  47 import java.nio.channels.SocketChannel;
  48 import java.nio.channels.spi.SelectorProvider;
  49 import java.util.Collections;
  50 import java.util.HashSet;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.concurrent.locks.ReentrantLock;
  54 

  55 import sun.net.NetHooks;
  56 import sun.net.ext.ExtendedSocketOptions;
  57 import sun.net.util.SocketExceptions;
  58 
  59 /**
  60  * An implementation of SocketChannels
  61  */
  62 
  63 class SocketChannelImpl
  64     extends SocketChannel
  65     implements SelChImpl
  66 {
  67     // Used to make native read and write calls
  68     private static final NativeDispatcher nd = new SocketDispatcher();
  69 
  70     // Our file descriptor object
  71     private final FileDescriptor fd;
  72     private final int fdVal;
  73 
  74     // Lock held by current reading or connecting thread
  75     private final ReentrantLock readLock = new ReentrantLock();
  76 
  77     // Lock held by current writing or connecting thread
  78     private final ReentrantLock writeLock = new ReentrantLock();
  79 
  80     // Lock held by any thread that modifies the state fields declared below
  81     // DO NOT invoke a blocking I/O operation while holding this lock!
  82     private final Object stateLock = new Object();
  83 
  84     // Input/Output closed
  85     private volatile boolean isInputClosed;
  86     private volatile boolean isOutputClosed;
  87 



  88     // -- The following fields are protected by stateLock
  89 
  90     // set true when exclusive binding is on and SO_REUSEADDR is emulated
  91     private boolean isReuseAddress;
  92 
  93     // State, increases monotonically
  94     private static final int ST_UNCONNECTED = 0;
  95     private static final int ST_CONNECTIONPENDING = 1;
  96     private static final int ST_CONNECTED = 2;
  97     private static final int ST_CLOSING = 3;
<span class="line-modified">  98     private static final int ST_KILLPENDING = 4;</span>
<span class="line-removed">  99     private static final int ST_KILLED = 5;</span>
 100     private volatile int state;  // need stateLock to change
 101 
 102     // IDs of native threads doing reads and writes, for signalling
 103     private long readerThread;
 104     private long writerThread;
 105 
 106     // Binding
 107     private InetSocketAddress localAddress;
 108     private InetSocketAddress remoteAddress;
 109 
 110     // Socket adaptor, created on demand
 111     private Socket socket;
 112 
 113     // -- End of fields protected by stateLock
 114 
 115 
 116     // Constructor for normal connecting sockets
 117     //
 118     SocketChannelImpl(SelectorProvider sp) throws IOException {
 119         super(sp);
</pre>
<hr />
<pre>
 195             ensureOpen();
 196             return Net.getRevealedLocalAddress(localAddress);
 197         }
 198     }
 199 
 200     @Override
 201     public SocketAddress getRemoteAddress() throws IOException {
 202         synchronized (stateLock) {
 203             ensureOpen();
 204             return remoteAddress;
 205         }
 206     }
 207 
 208     @Override
 209     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 210         throws IOException
 211     {
 212         Objects.requireNonNull(name);
 213         if (!supportedOptions().contains(name))
 214             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);


 215 
 216         synchronized (stateLock) {
 217             ensureOpen();
 218 
 219             if (name == StandardSocketOptions.IP_TOS) {
 220                 ProtocolFamily family = Net.isIPv6Available() ?
 221                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 222                 Net.setSocketOption(fd, family, name, value);
 223                 return this;
 224             }
 225 
 226             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 227                 // SO_REUSEADDR emulated when using exclusive bind
 228                 isReuseAddress = (Boolean)value;
 229                 return this;
 230             }
 231 
 232             // no options that require special handling
<span class="line-modified"> 233             Net.setSocketOption(fd, Net.UNSPEC, name, value);</span>
 234             return this;
 235         }
 236     }
 237 
 238     @Override
 239     @SuppressWarnings(&quot;unchecked&quot;)
 240     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 241         throws IOException
 242     {
 243         Objects.requireNonNull(name);
 244         if (!supportedOptions().contains(name))
 245             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 246 
 247         synchronized (stateLock) {
 248             ensureOpen();
 249 
 250             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 251                 // SO_REUSEADDR emulated when using exclusive bind
 252                 return (T)Boolean.valueOf(isReuseAddress);
 253             }
 254 
 255             // special handling for IP_TOS: always return 0 when IPv6
 256             if (name == StandardSocketOptions.IP_TOS) {
 257                 ProtocolFamily family = Net.isIPv6Available() ?
 258                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 259                 return (T) Net.getSocketOption(fd, family, name);
 260             }
 261 
 262             // no options that require special handling
<span class="line-modified"> 263             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span>
 264         }
 265     }
 266 
 267     private static class DefaultOptionsHolder {
 268         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 269 
 270         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 271             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 272             set.add(StandardSocketOptions.SO_SNDBUF);
 273             set.add(StandardSocketOptions.SO_RCVBUF);
 274             set.add(StandardSocketOptions.SO_KEEPALIVE);
 275             set.add(StandardSocketOptions.SO_REUSEADDR);
 276             if (Net.isReusePortAvailable()) {
 277                 set.add(StandardSocketOptions.SO_REUSEPORT);
 278             }
 279             set.add(StandardSocketOptions.SO_LINGER);
 280             set.add(StandardSocketOptions.TCP_NODELAY);
 281             // additional options required by socket adaptor
 282             set.add(StandardSocketOptions.IP_TOS);
 283             set.add(ExtendedSocketOption.SO_OOBINLINE);
</pre>
<hr />
<pre>
 307                 // record thread so it can be signalled if needed
 308                 readerThread = NativeThread.current();
 309             }
 310         } else {
 311             ensureOpenAndConnected();
 312         }
 313     }
 314 
 315     /**
 316      * Marks the end of a read operation that may have blocked.
 317      *
 318      * @throws AsynchronousCloseException if the channel was closed due to this
 319      * thread being interrupted on a blocking read operation.
 320      */
 321     private void endRead(boolean blocking, boolean completed)
 322         throws AsynchronousCloseException
 323     {
 324         if (blocking) {
 325             synchronized (stateLock) {
 326                 readerThread = 0;
<span class="line-removed"> 327                 // notify any thread waiting in implCloseSelectableChannel</span>
 328                 if (state == ST_CLOSING) {
<span class="line-modified"> 329                     stateLock.notifyAll();</span>
 330                 }
 331             }
 332             // remove hook for Thread.interrupt
 333             end(completed);
 334         }
 335     }
 336 




 337     @Override
 338     public int read(ByteBuffer buf) throws IOException {
 339         Objects.requireNonNull(buf);
 340 
 341         readLock.lock();
 342         try {
 343             boolean blocking = isBlocking();
 344             int n = 0;
 345             try {
 346                 beginRead(blocking);
 347 




 348                 // check if input is shutdown
 349                 if (isInputClosed)
 350                     return IOStatus.EOF;
 351 

 352                 if (blocking) {
<span class="line-modified"> 353                     do {</span>

 354                         n = IOUtil.read(fd, buf, -1, nd);
<span class="line-modified"> 355                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed"> 356                 } else {</span>
<span class="line-removed"> 357                     n = IOUtil.read(fd, buf, -1, nd);</span>
 358                 }



 359             } finally {
 360                 endRead(blocking, n &gt; 0);
 361                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 362                     return IOStatus.EOF;
 363             }
 364             return IOStatus.normalize(n);
 365         } finally {
 366             readLock.unlock();
 367         }
 368     }
 369 
 370     @Override
 371     public long read(ByteBuffer[] dsts, int offset, int length)
 372         throws IOException
 373     {
 374         Objects.checkFromIndexSize(offset, length, dsts.length);
 375 
 376         readLock.lock();
 377         try {
 378             boolean blocking = isBlocking();
 379             long n = 0;
 380             try {
 381                 beginRead(blocking);
 382 




 383                 // check if input is shutdown
 384                 if (isInputClosed)
 385                     return IOStatus.EOF;
 386 

 387                 if (blocking) {
<span class="line-modified"> 388                     do {</span>

 389                         n = IOUtil.read(fd, dsts, offset, length, nd);
<span class="line-modified"> 390                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed"> 391                 } else {</span>
<span class="line-removed"> 392                     n = IOUtil.read(fd, dsts, offset, length, nd);</span>
 393                 }



 394             } finally {
 395                 endRead(blocking, n &gt; 0);
 396                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 397                     return IOStatus.EOF;
 398             }
 399             return IOStatus.normalize(n);
 400         } finally {
 401             readLock.unlock();
 402         }
 403     }
 404 
 405     /**
 406      * Marks the beginning of a write operation that might block.
 407      *
 408      * @throws ClosedChannelException if the channel is closed or output shutdown
 409      * @throws NotYetConnectedException if the channel is not yet connected
 410      */
 411     private void beginWrite(boolean blocking) throws ClosedChannelException {
 412         if (blocking) {
 413             // set hook for Thread.interrupt
</pre>
<hr />
<pre>
 420                 // record thread so it can be signalled if needed
 421                 writerThread = NativeThread.current();
 422             }
 423         } else {
 424             ensureOpenAndConnected();
 425         }
 426     }
 427 
 428     /**
 429      * Marks the end of a write operation that may have blocked.
 430      *
 431      * @throws AsynchronousCloseException if the channel was closed due to this
 432      * thread being interrupted on a blocking write operation.
 433      */
 434     private void endWrite(boolean blocking, boolean completed)
 435         throws AsynchronousCloseException
 436     {
 437         if (blocking) {
 438             synchronized (stateLock) {
 439                 writerThread = 0;
<span class="line-removed"> 440                 // notify any thread waiting in implCloseSelectableChannel</span>
 441                 if (state == ST_CLOSING) {
<span class="line-modified"> 442                     stateLock.notifyAll();</span>
 443                 }
 444             }
 445             // remove hook for Thread.interrupt
 446             end(completed);
 447         }
 448     }
 449 
 450     @Override
 451     public int write(ByteBuffer buf) throws IOException {
 452         Objects.requireNonNull(buf);
 453 
 454         writeLock.lock();
 455         try {
 456             boolean blocking = isBlocking();
 457             int n = 0;
 458             try {
 459                 beginWrite(blocking);

 460                 if (blocking) {
<span class="line-modified"> 461                     do {</span>

 462                         n = IOUtil.write(fd, buf, -1, nd);
<span class="line-modified"> 463                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed"> 464                 } else {</span>
<span class="line-removed"> 465                     n = IOUtil.write(fd, buf, -1, nd);</span>
 466                 }
 467             } finally {
 468                 endWrite(blocking, n &gt; 0);
 469                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 470                     throw new AsynchronousCloseException();
 471             }
 472             return IOStatus.normalize(n);
 473         } finally {
 474             writeLock.unlock();
 475         }
 476     }
 477 
 478     @Override
 479     public long write(ByteBuffer[] srcs, int offset, int length)
 480         throws IOException
 481     {
 482         Objects.checkFromIndexSize(offset, length, srcs.length);
 483 
 484         writeLock.lock();
 485         try {
 486             boolean blocking = isBlocking();
 487             long n = 0;
 488             try {
 489                 beginWrite(blocking);

 490                 if (blocking) {
<span class="line-modified"> 491                     do {</span>

 492                         n = IOUtil.write(fd, srcs, offset, length, nd);
<span class="line-modified"> 493                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed"> 494                 } else {</span>
<span class="line-removed"> 495                     n = IOUtil.write(fd, srcs, offset, length, nd);</span>
 496                 }
 497             } finally {
 498                 endWrite(blocking, n &gt; 0);
 499                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 500                     throw new AsynchronousCloseException();
 501             }
 502             return IOStatus.normalize(n);
 503         } finally {
 504             writeLock.unlock();
 505         }
 506     }
 507 
 508     /**
 509      * Writes a byte of out of band data.
 510      */
 511     int sendOutOfBandData(byte b) throws IOException {
 512         writeLock.lock();
 513         try {
 514             boolean blocking = isBlocking();
 515             int n = 0;
</pre>
<hr />
<pre>
 522                 } else {
 523                     n = Net.sendOOB(fd, b);
 524                 }
 525             } finally {
 526                 endWrite(blocking, n &gt; 0);
 527                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 528                     throw new AsynchronousCloseException();
 529             }
 530             return IOStatus.normalize(n);
 531         } finally {
 532             writeLock.unlock();
 533         }
 534     }
 535 
 536     @Override
 537     protected void implConfigureBlocking(boolean block) throws IOException {
 538         readLock.lock();
 539         try {
 540             writeLock.lock();
 541             try {
<span class="line-modified"> 542                 synchronized (stateLock) {</span>
<span class="line-removed"> 543                     ensureOpen();</span>
<span class="line-removed"> 544                     IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed"> 545                 }</span>
 546             } finally {
 547                 writeLock.unlock();
 548             }
 549         } finally {
 550             readLock.unlock();
 551         }
 552     }
 553 






























 554     /**
 555      * Returns the local address, or null if not bound
 556      */
 557     InetSocketAddress localAddress() {
 558         synchronized (stateLock) {
 559             return localAddress;
 560         }
 561     }
 562 
 563     /**
 564      * Returns the remote address, or null if not connected
 565      */
 566     InetSocketAddress remoteAddress() {
 567         synchronized (stateLock) {
 568             return remoteAddress;
 569         }
 570     }
 571 
 572     @Override
 573     public SocketChannel bind(SocketAddress local) throws IOException {
</pre>
<hr />
<pre>
 652      *
 653      * @throws AsynchronousCloseException if the channel was closed due to this
 654      * thread being interrupted on a blocking connect operation.
 655      * @throws IOException if completed and unable to obtain the local address
 656      */
 657     private void endConnect(boolean blocking, boolean completed)
 658         throws IOException
 659     {
 660         endRead(blocking, completed);
 661 
 662         if (completed) {
 663             synchronized (stateLock) {
 664                 if (state == ST_CONNECTIONPENDING) {
 665                     localAddress = Net.localAddress(fd);
 666                     state = ST_CONNECTED;
 667                 }
 668             }
 669         }
 670     }
 671 
<span class="line-modified"> 672     @Override</span>
<span class="line-modified"> 673     public boolean connect(SocketAddress sa) throws IOException {</span>


 674         InetSocketAddress isa = Net.checkAddress(sa);
 675         SecurityManager sm = System.getSecurityManager();
<span class="line-modified"> 676         if (sm != null)</span>
 677             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());







 678 
<span class="line-modified"> 679         InetAddress ia = isa.getAddress();</span>
<span class="line-modified"> 680         if (ia.isAnyLocalAddress())</span>
<span class="line-modified"> 681             ia = InetAddress.getLocalHost();</span>
<span class="line-removed"> 682 </span>
 683         try {
 684             readLock.lock();
 685             try {
 686                 writeLock.lock();
 687                 try {
<span class="line-removed"> 688                     int n = 0;</span>
 689                     boolean blocking = isBlocking();

 690                     try {
 691                         beginConnect(blocking, isa);
<span class="line-modified"> 692                         do {</span>
<span class="line-modified"> 693                             n = Net.connect(fd, ia, isa.getPort());</span>
<span class="line-modified"> 694                         } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>









 695                     } finally {
<span class="line-modified"> 696                         endConnect(blocking, (n &gt; 0));</span>
 697                     }
<span class="line-modified"> 698                     assert IOStatus.check(n);</span>
<span class="line-removed"> 699                     return n &gt; 0;</span>
 700                 } finally {
 701                     writeLock.unlock();
 702                 }
 703             } finally {
 704                 readLock.unlock();
 705             }
 706         } catch (IOException ioe) {
 707             // connect failed, close the channel
 708             close();
 709             throw SocketExceptions.of(ioe, isa);
 710         }
 711     }
 712 
 713     /**
 714      * Marks the beginning of a finishConnect operation that might block.
 715      *
 716      * @throws ClosedChannelException if the channel is closed
 717      * @throws NoConnectionPendingException if no connection is pending
 718      */
 719     private void beginFinishConnect(boolean blocking) throws ClosedChannelException {
</pre>
<hr />
<pre>
 752                 }
 753             }
 754         }
 755     }
 756 
 757     @Override
 758     public boolean finishConnect() throws IOException {
 759         try {
 760             readLock.lock();
 761             try {
 762                 writeLock.lock();
 763                 try {
 764                     // no-op if already connected
 765                     if (isConnected())
 766                         return true;
 767 
 768                     boolean blocking = isBlocking();
 769                     boolean connected = false;
 770                     try {
 771                         beginFinishConnect(blocking);
<span class="line-modified"> 772                         int n = 0;</span>
 773                         if (blocking) {
<span class="line-modified"> 774                             do {</span>
<span class="line-modified"> 775                                 n = Net.pollConnect(fd, -1);</span>
<span class="line-modified"> 776                             } while ((n == 0 || n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 777                         } else {</span>
<span class="line-removed"> 778                             n = Net.pollConnect(fd, 0);</span>
 779                         }
<span class="line-modified"> 780                         connected = (n &gt; 0);</span>
 781                     } finally {
 782                         endFinishConnect(blocking, connected);
 783                     }
 784                     assert (blocking &amp;&amp; connected) ^ !blocking;
 785                     return connected;
 786                 } finally {
 787                     writeLock.unlock();
 788                 }
 789             } finally {
 790                 readLock.unlock();
 791             }
 792         } catch (IOException ioe) {
 793             // connect failed, close the channel
 794             close();
 795             throw SocketExceptions.of(ioe, remoteAddress);
 796         }
 797     }
 798 
 799     /**
<span class="line-modified"> 800      * Invoked by implCloseChannel to close the channel.</span>















 801      *
<span class="line-modified"> 802      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-modified"> 803      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-modified"> 804      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-modified"> 805      * complete quickly.</span>






 806      *
<span class="line-modified"> 807      * If the socket is connected then it is shutdown by this method. The</span>
<span class="line-modified"> 808      * shutdown ensures that the peer reads EOF for the case that the socket is</span>
<span class="line-modified"> 809      * not pre-closed or closed by this method.</span>
 810      *
<span class="line-modified"> 811      * The socket is closed by this method when it is not registered with a</span>
<span class="line-modified"> 812      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-modified"> 813      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed"> 814      * to blocking mode before the key is flushed from the Selector.</span>
 815      */
<span class="line-modified"> 816     @Override</span>
<span class="line-removed"> 817     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-removed"> 818         assert !isOpen();</span>
<span class="line-removed"> 819 </span>
<span class="line-removed"> 820         boolean blocking;</span>
<span class="line-removed"> 821         boolean connected;</span>
<span class="line-removed"> 822         boolean interrupted = false;</span>
<span class="line-removed"> 823 </span>
<span class="line-removed"> 824         // set state to ST_CLOSING</span>
 825         synchronized (stateLock) {
 826             assert state &lt; ST_CLOSING;
<span class="line-removed"> 827             blocking = isBlocking();</span>
<span class="line-removed"> 828             connected = (state == ST_CONNECTED);</span>
 829             state = ST_CLOSING;
<span class="line-modified"> 830         }</span>
<span class="line-removed"> 831 </span>
<span class="line-removed"> 832         // wait for any outstanding I/O operations to complete</span>
<span class="line-removed"> 833         if (blocking) {</span>
<span class="line-removed"> 834             synchronized (stateLock) {</span>
<span class="line-removed"> 835                 assert state == ST_CLOSING;</span>
 836                 long reader = readerThread;
 837                 long writer = writerThread;
 838                 if (reader != 0 || writer != 0) {
 839                     nd.preClose(fd);
<span class="line-removed"> 840                     connected = false; // fd is no longer connected socket</span>
<span class="line-removed"> 841 </span>
 842                     if (reader != 0)
 843                         NativeThread.signal(reader);
 844                     if (writer != 0)
 845                         NativeThread.signal(writer);
<span class="line-removed"> 846 </span>
<span class="line-removed"> 847                     // wait for blocking I/O operations to end</span>
<span class="line-removed"> 848                     while (readerThread != 0 || writerThread != 0) {</span>
<span class="line-removed"> 849                         try {</span>
<span class="line-removed"> 850                             stateLock.wait();</span>
<span class="line-removed"> 851                         } catch (InterruptedException e) {</span>
<span class="line-removed"> 852                             interrupted = true;</span>
<span class="line-removed"> 853                         }</span>
<span class="line-removed"> 854                     }</span>
 855                 }
 856             }
<span class="line-removed"> 857         } else {</span>
<span class="line-removed"> 858             // non-blocking mode: wait for read/write to complete</span>
<span class="line-removed"> 859             readLock.lock();</span>
<span class="line-removed"> 860             try {</span>
<span class="line-removed"> 861                 writeLock.lock();</span>
<span class="line-removed"> 862                 writeLock.unlock();</span>
<span class="line-removed"> 863             } finally {</span>
<span class="line-removed"> 864                 readLock.unlock();</span>
<span class="line-removed"> 865             }</span>
 866         }

 867 
<span class="line-modified"> 868         // set state to ST_KILLPENDING</span>


























 869         synchronized (stateLock) {
<span class="line-modified"> 870             assert state == ST_CLOSING;</span>
<span class="line-removed"> 871             // if connected and the channel is registered with a Selector then</span>
<span class="line-removed"> 872             // shutdown the output if possible so that the peer reads EOF. If</span>
<span class="line-removed"> 873             // SO_LINGER is enabled and set to a non-zero value then it needs to</span>
<span class="line-removed"> 874             // be disabled so that the Selector does not wait when it closes</span>
<span class="line-removed"> 875             // the socket.</span>
<span class="line-removed"> 876             if (connected &amp;&amp; isRegistered()) {</span>
 877                 try {
 878                     SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
 879                     int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
 880                     if (interval != 0) {
 881                         if (interval &gt; 0) {
 882                             // disable SO_LINGER
 883                             Net.setSocketOption(fd, Net.UNSPEC, opt, -1);
 884                         }
 885                         Net.shutdown(fd, Net.SHUT_WR);
 886                     }
 887                 } catch (IOException ignore) { }
 888             }
<span class="line-removed"> 889             state = ST_KILLPENDING;</span>
 890         }

 891 
<span class="line-modified"> 892         // close socket if not registered with Selector</span>
<span class="line-modified"> 893         if (!isRegistered())</span>
<span class="line-modified"> 894             kill();</span>
<span class="line-modified"> 895 </span>
<span class="line-modified"> 896         // restore interrupt status</span>
<span class="line-modified"> 897         if (interrupted)</span>
<span class="line-modified"> 898             Thread.currentThread().interrupt();</span>




 899     }
 900 
 901     @Override
<span class="line-modified"> 902     public void kill() throws IOException {</span>
 903         synchronized (stateLock) {
<span class="line-modified"> 904             if (state == ST_KILLPENDING) {</span>
<span class="line-modified"> 905                 state = ST_KILLED;</span>
<span class="line-removed"> 906                 nd.close(fd);</span>
 907             }
 908         }
 909     }
 910 
 911     @Override
 912     public SocketChannel shutdownInput() throws IOException {
 913         synchronized (stateLock) {
 914             ensureOpen();
 915             if (!isConnected())
 916                 throw new NotYetConnectedException();
 917             if (!isInputClosed) {
 918                 Net.shutdown(fd, Net.SHUT_RD);
 919                 long thread = readerThread;
 920                 if (thread != 0)
 921                     NativeThread.signal(thread);
 922                 isInputClosed = true;
 923             }
 924             return this;
 925         }
 926     }
</pre>
<hr />
<pre>
 934             if (!isOutputClosed) {
 935                 Net.shutdown(fd, Net.SHUT_WR);
 936                 long thread = writerThread;
 937                 if (thread != 0)
 938                     NativeThread.signal(thread);
 939                 isOutputClosed = true;
 940             }
 941             return this;
 942         }
 943     }
 944 
 945     boolean isInputOpen() {
 946         return !isInputClosed;
 947     }
 948 
 949     boolean isOutputOpen() {
 950         return !isOutputClosed;
 951     }
 952 
 953     /**
<span class="line-modified"> 954      * Poll this channel&#39;s socket for reading up to the given timeout.</span>
<span class="line-modified"> 955      * @return {@code true} if the socket is polled</span>































































 956      */
<span class="line-modified"> 957     boolean pollRead(long timeout) throws IOException {</span>
<span class="line-modified"> 958         boolean blocking = isBlocking();</span>
<span class="line-modified"> 959         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>











































 960 
 961         readLock.lock();
 962         try {
<span class="line-modified"> 963             boolean polled = false;</span>




 964             try {
<span class="line-modified"> 965                 beginRead(blocking);</span>
<span class="line-modified"> 966                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-modified"> 967                 polled = (events != 0);</span>



























 968             } finally {
<span class="line-modified"> 969                 endRead(blocking, polled);</span>


 970             }
<span class="line-modified"> 971             return polled;</span>

 972         } finally {
 973             readLock.unlock();
 974         }
 975     }
 976 
 977     /**
<span class="line-modified"> 978      * Poll this channel&#39;s socket for a connection, up to the given timeout.</span>
<span class="line-modified"> 979      * @return {@code true} if the socket is polled</span>
 980      */
<span class="line-modified"> 981     boolean pollConnected(long timeout) throws IOException {</span>
<span class="line-modified"> 982         boolean blocking = isBlocking();</span>
<span class="line-modified"> 983         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>







 984 
<span class="line-modified"> 985         readLock.lock();</span>












 986         try {
<span class="line-modified"> 987             writeLock.lock();</span>







 988             try {
<span class="line-modified"> 989                 boolean polled = false;</span>
<span class="line-modified"> 990                 try {</span>
<span class="line-modified"> 991                     beginFinishConnect(blocking);</span>
<span class="line-modified"> 992                     int events = Net.poll(fd, Net.POLLCONN, timeout);</span>
<span class="line-modified"> 993                     polled = (events != 0);</span>
<span class="line-modified"> 994                 } finally {</span>
<span class="line-modified"> 995                     // invoke endFinishConnect with completed = false so that</span>
<span class="line-modified"> 996                     // the state is not changed to ST_CONNECTED. The socket</span>
<span class="line-modified"> 997                     // adaptor will use finishConnect to finish.</span>
<span class="line-modified"> 998                     endFinishConnect(blocking, /*completed*/false);</span>
 999                 }
<span class="line-removed">1000                 return polled;</span>
1001             } finally {
<span class="line-modified">1002                 writeLock.unlock();</span>
1003             }
1004         } finally {
<span class="line-modified">1005             readLock.unlock();</span>














1006         }
1007     }
1008 
1009     /**
1010      * Translates native poll revent ops into a ready operation ops
1011      */
1012     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1013         int intOps = ski.nioInterestOps();
1014         int oldOps = ski.nioReadyOps();
1015         int newOps = initialOps;
1016 
1017         if ((ops &amp; Net.POLLNVAL) != 0) {
1018             // This should only happen if this channel is pre-closed while a
1019             // selection operation is in progress
1020             // ## Throw an error if this channel has not been pre-closed
1021             return false;
1022         }
1023 
1024         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1025             newOps = intOps;
</pre>
</td>
<td>
<hr />
<pre>
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
  31 import java.net.InetSocketAddress;
  32 import java.net.ProtocolFamily;
  33 import java.net.Socket;
  34 import java.net.SocketAddress;
<span class="line-added">  35 import java.net.SocketException;</span>
  36 import java.net.SocketOption;
<span class="line-added">  37 import java.net.SocketTimeoutException;</span>
  38 import java.net.StandardProtocolFamily;
  39 import java.net.StandardSocketOptions;
  40 import java.nio.ByteBuffer;
  41 import java.nio.channels.AlreadyBoundException;
  42 import java.nio.channels.AlreadyConnectedException;
  43 import java.nio.channels.AsynchronousCloseException;
  44 import java.nio.channels.ClosedChannelException;
  45 import java.nio.channels.ConnectionPendingException;
<span class="line-added">  46 import java.nio.channels.IllegalBlockingModeException;</span>
  47 import java.nio.channels.NoConnectionPendingException;
  48 import java.nio.channels.NotYetConnectedException;
  49 import java.nio.channels.SelectionKey;
  50 import java.nio.channels.SocketChannel;
  51 import java.nio.channels.spi.SelectorProvider;
  52 import java.util.Collections;
  53 import java.util.HashSet;
  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;
  57 
<span class="line-added">  58 import sun.net.ConnectionResetException;</span>
  59 import sun.net.NetHooks;
  60 import sun.net.ext.ExtendedSocketOptions;
  61 import sun.net.util.SocketExceptions;
  62 
  63 /**
  64  * An implementation of SocketChannels
  65  */
  66 
  67 class SocketChannelImpl
  68     extends SocketChannel
  69     implements SelChImpl
  70 {
  71     // Used to make native read and write calls
  72     private static final NativeDispatcher nd = new SocketDispatcher();
  73 
  74     // Our file descriptor object
  75     private final FileDescriptor fd;
  76     private final int fdVal;
  77 
  78     // Lock held by current reading or connecting thread
  79     private final ReentrantLock readLock = new ReentrantLock();
  80 
  81     // Lock held by current writing or connecting thread
  82     private final ReentrantLock writeLock = new ReentrantLock();
  83 
  84     // Lock held by any thread that modifies the state fields declared below
  85     // DO NOT invoke a blocking I/O operation while holding this lock!
  86     private final Object stateLock = new Object();
  87 
  88     // Input/Output closed
  89     private volatile boolean isInputClosed;
  90     private volatile boolean isOutputClosed;
  91 
<span class="line-added">  92     // Connection reset protected by readLock</span>
<span class="line-added">  93     private boolean connectionReset;</span>
<span class="line-added">  94 </span>
  95     // -- The following fields are protected by stateLock
  96 
  97     // set true when exclusive binding is on and SO_REUSEADDR is emulated
  98     private boolean isReuseAddress;
  99 
 100     // State, increases monotonically
 101     private static final int ST_UNCONNECTED = 0;
 102     private static final int ST_CONNECTIONPENDING = 1;
 103     private static final int ST_CONNECTED = 2;
 104     private static final int ST_CLOSING = 3;
<span class="line-modified"> 105     private static final int ST_CLOSED = 4;</span>

 106     private volatile int state;  // need stateLock to change
 107 
 108     // IDs of native threads doing reads and writes, for signalling
 109     private long readerThread;
 110     private long writerThread;
 111 
 112     // Binding
 113     private InetSocketAddress localAddress;
 114     private InetSocketAddress remoteAddress;
 115 
 116     // Socket adaptor, created on demand
 117     private Socket socket;
 118 
 119     // -- End of fields protected by stateLock
 120 
 121 
 122     // Constructor for normal connecting sockets
 123     //
 124     SocketChannelImpl(SelectorProvider sp) throws IOException {
 125         super(sp);
</pre>
<hr />
<pre>
 201             ensureOpen();
 202             return Net.getRevealedLocalAddress(localAddress);
 203         }
 204     }
 205 
 206     @Override
 207     public SocketAddress getRemoteAddress() throws IOException {
 208         synchronized (stateLock) {
 209             ensureOpen();
 210             return remoteAddress;
 211         }
 212     }
 213 
 214     @Override
 215     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 216         throws IOException
 217     {
 218         Objects.requireNonNull(name);
 219         if (!supportedOptions().contains(name))
 220             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<span class="line-added"> 221         if (!name.type().isInstance(value))</span>
<span class="line-added"> 222             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
 223 
 224         synchronized (stateLock) {
 225             ensureOpen();
 226 
 227             if (name == StandardSocketOptions.IP_TOS) {
 228                 ProtocolFamily family = Net.isIPv6Available() ?
 229                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 230                 Net.setSocketOption(fd, family, name, value);
 231                 return this;
 232             }
 233 
 234             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 235                 // SO_REUSEADDR emulated when using exclusive bind
 236                 isReuseAddress = (Boolean)value;
 237                 return this;
 238             }
 239 
 240             // no options that require special handling
<span class="line-modified"> 241             Net.setSocketOption(fd, name, value);</span>
 242             return this;
 243         }
 244     }
 245 
 246     @Override
 247     @SuppressWarnings(&quot;unchecked&quot;)
 248     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 249         throws IOException
 250     {
 251         Objects.requireNonNull(name);
 252         if (!supportedOptions().contains(name))
 253             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 254 
 255         synchronized (stateLock) {
 256             ensureOpen();
 257 
 258             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 259                 // SO_REUSEADDR emulated when using exclusive bind
 260                 return (T)Boolean.valueOf(isReuseAddress);
 261             }
 262 
 263             // special handling for IP_TOS: always return 0 when IPv6
 264             if (name == StandardSocketOptions.IP_TOS) {
 265                 ProtocolFamily family = Net.isIPv6Available() ?
 266                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 267                 return (T) Net.getSocketOption(fd, family, name);
 268             }
 269 
 270             // no options that require special handling
<span class="line-modified"> 271             return (T) Net.getSocketOption(fd, name);</span>
 272         }
 273     }
 274 
 275     private static class DefaultOptionsHolder {
 276         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 277 
 278         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 279             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 280             set.add(StandardSocketOptions.SO_SNDBUF);
 281             set.add(StandardSocketOptions.SO_RCVBUF);
 282             set.add(StandardSocketOptions.SO_KEEPALIVE);
 283             set.add(StandardSocketOptions.SO_REUSEADDR);
 284             if (Net.isReusePortAvailable()) {
 285                 set.add(StandardSocketOptions.SO_REUSEPORT);
 286             }
 287             set.add(StandardSocketOptions.SO_LINGER);
 288             set.add(StandardSocketOptions.TCP_NODELAY);
 289             // additional options required by socket adaptor
 290             set.add(StandardSocketOptions.IP_TOS);
 291             set.add(ExtendedSocketOption.SO_OOBINLINE);
</pre>
<hr />
<pre>
 315                 // record thread so it can be signalled if needed
 316                 readerThread = NativeThread.current();
 317             }
 318         } else {
 319             ensureOpenAndConnected();
 320         }
 321     }
 322 
 323     /**
 324      * Marks the end of a read operation that may have blocked.
 325      *
 326      * @throws AsynchronousCloseException if the channel was closed due to this
 327      * thread being interrupted on a blocking read operation.
 328      */
 329     private void endRead(boolean blocking, boolean completed)
 330         throws AsynchronousCloseException
 331     {
 332         if (blocking) {
 333             synchronized (stateLock) {
 334                 readerThread = 0;

 335                 if (state == ST_CLOSING) {
<span class="line-modified"> 336                     tryFinishClose();</span>
 337                 }
 338             }
 339             // remove hook for Thread.interrupt
 340             end(completed);
 341         }
 342     }
 343 
<span class="line-added"> 344     private void throwConnectionReset() throws SocketException {</span>
<span class="line-added"> 345         throw new SocketException(&quot;Connection reset&quot;);</span>
<span class="line-added"> 346     }</span>
<span class="line-added"> 347 </span>
 348     @Override
 349     public int read(ByteBuffer buf) throws IOException {
 350         Objects.requireNonNull(buf);
 351 
 352         readLock.lock();
 353         try {
 354             boolean blocking = isBlocking();
 355             int n = 0;
 356             try {
 357                 beginRead(blocking);
 358 
<span class="line-added"> 359                 // check if connection has been reset</span>
<span class="line-added"> 360                 if (connectionReset)</span>
<span class="line-added"> 361                     throwConnectionReset();</span>
<span class="line-added"> 362 </span>
 363                 // check if input is shutdown
 364                 if (isInputClosed)
 365                     return IOStatus.EOF;
 366 
<span class="line-added"> 367                 n = IOUtil.read(fd, buf, -1, nd);</span>
 368                 if (blocking) {
<span class="line-modified"> 369                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 370                         park(Net.POLLIN);</span>
 371                         n = IOUtil.read(fd, buf, -1, nd);
<span class="line-modified"> 372                     }</span>


 373                 }
<span class="line-added"> 374             } catch (ConnectionResetException e) {</span>
<span class="line-added"> 375                 connectionReset = true;</span>
<span class="line-added"> 376                 throwConnectionReset();</span>
 377             } finally {
 378                 endRead(blocking, n &gt; 0);
 379                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 380                     return IOStatus.EOF;
 381             }
 382             return IOStatus.normalize(n);
 383         } finally {
 384             readLock.unlock();
 385         }
 386     }
 387 
 388     @Override
 389     public long read(ByteBuffer[] dsts, int offset, int length)
 390         throws IOException
 391     {
 392         Objects.checkFromIndexSize(offset, length, dsts.length);
 393 
 394         readLock.lock();
 395         try {
 396             boolean blocking = isBlocking();
 397             long n = 0;
 398             try {
 399                 beginRead(blocking);
 400 
<span class="line-added"> 401                 // check if connection has been reset</span>
<span class="line-added"> 402                 if (connectionReset)</span>
<span class="line-added"> 403                     throwConnectionReset();</span>
<span class="line-added"> 404 </span>
 405                 // check if input is shutdown
 406                 if (isInputClosed)
 407                     return IOStatus.EOF;
 408 
<span class="line-added"> 409                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
 410                 if (blocking) {
<span class="line-modified"> 411                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 412                         park(Net.POLLIN);</span>
 413                         n = IOUtil.read(fd, dsts, offset, length, nd);
<span class="line-modified"> 414                     }</span>


 415                 }
<span class="line-added"> 416             } catch (ConnectionResetException e) {</span>
<span class="line-added"> 417                 connectionReset = true;</span>
<span class="line-added"> 418                 throwConnectionReset();</span>
 419             } finally {
 420                 endRead(blocking, n &gt; 0);
 421                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 422                     return IOStatus.EOF;
 423             }
 424             return IOStatus.normalize(n);
 425         } finally {
 426             readLock.unlock();
 427         }
 428     }
 429 
 430     /**
 431      * Marks the beginning of a write operation that might block.
 432      *
 433      * @throws ClosedChannelException if the channel is closed or output shutdown
 434      * @throws NotYetConnectedException if the channel is not yet connected
 435      */
 436     private void beginWrite(boolean blocking) throws ClosedChannelException {
 437         if (blocking) {
 438             // set hook for Thread.interrupt
</pre>
<hr />
<pre>
 445                 // record thread so it can be signalled if needed
 446                 writerThread = NativeThread.current();
 447             }
 448         } else {
 449             ensureOpenAndConnected();
 450         }
 451     }
 452 
 453     /**
 454      * Marks the end of a write operation that may have blocked.
 455      *
 456      * @throws AsynchronousCloseException if the channel was closed due to this
 457      * thread being interrupted on a blocking write operation.
 458      */
 459     private void endWrite(boolean blocking, boolean completed)
 460         throws AsynchronousCloseException
 461     {
 462         if (blocking) {
 463             synchronized (stateLock) {
 464                 writerThread = 0;

 465                 if (state == ST_CLOSING) {
<span class="line-modified"> 466                     tryFinishClose();</span>
 467                 }
 468             }
 469             // remove hook for Thread.interrupt
 470             end(completed);
 471         }
 472     }
 473 
 474     @Override
 475     public int write(ByteBuffer buf) throws IOException {
 476         Objects.requireNonNull(buf);
 477 
 478         writeLock.lock();
 479         try {
 480             boolean blocking = isBlocking();
 481             int n = 0;
 482             try {
 483                 beginWrite(blocking);
<span class="line-added"> 484                 n = IOUtil.write(fd, buf, -1, nd);</span>
 485                 if (blocking) {
<span class="line-modified"> 486                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 487                         park(Net.POLLOUT);</span>
 488                         n = IOUtil.write(fd, buf, -1, nd);
<span class="line-modified"> 489                     }</span>


 490                 }
 491             } finally {
 492                 endWrite(blocking, n &gt; 0);
 493                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 494                     throw new AsynchronousCloseException();
 495             }
 496             return IOStatus.normalize(n);
 497         } finally {
 498             writeLock.unlock();
 499         }
 500     }
 501 
 502     @Override
 503     public long write(ByteBuffer[] srcs, int offset, int length)
 504         throws IOException
 505     {
 506         Objects.checkFromIndexSize(offset, length, srcs.length);
 507 
 508         writeLock.lock();
 509         try {
 510             boolean blocking = isBlocking();
 511             long n = 0;
 512             try {
 513                 beginWrite(blocking);
<span class="line-added"> 514                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
 515                 if (blocking) {
<span class="line-modified"> 516                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 517                         park(Net.POLLOUT);</span>
 518                         n = IOUtil.write(fd, srcs, offset, length, nd);
<span class="line-modified"> 519                     }</span>


 520                 }
 521             } finally {
 522                 endWrite(blocking, n &gt; 0);
 523                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 524                     throw new AsynchronousCloseException();
 525             }
 526             return IOStatus.normalize(n);
 527         } finally {
 528             writeLock.unlock();
 529         }
 530     }
 531 
 532     /**
 533      * Writes a byte of out of band data.
 534      */
 535     int sendOutOfBandData(byte b) throws IOException {
 536         writeLock.lock();
 537         try {
 538             boolean blocking = isBlocking();
 539             int n = 0;
</pre>
<hr />
<pre>
 546                 } else {
 547                     n = Net.sendOOB(fd, b);
 548                 }
 549             } finally {
 550                 endWrite(blocking, n &gt; 0);
 551                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 552                     throw new AsynchronousCloseException();
 553             }
 554             return IOStatus.normalize(n);
 555         } finally {
 556             writeLock.unlock();
 557         }
 558     }
 559 
 560     @Override
 561     protected void implConfigureBlocking(boolean block) throws IOException {
 562         readLock.lock();
 563         try {
 564             writeLock.lock();
 565             try {
<span class="line-modified"> 566                 lockedConfigureBlocking(block);</span>



 567             } finally {
 568                 writeLock.unlock();
 569             }
 570         } finally {
 571             readLock.unlock();
 572         }
 573     }
 574 
<span class="line-added"> 575     /**</span>
<span class="line-added"> 576      * Adjusts the blocking mode. readLock or writeLock must already be held.</span>
<span class="line-added"> 577      */</span>
<span class="line-added"> 578     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added"> 579         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added"> 580         synchronized (stateLock) {</span>
<span class="line-added"> 581             ensureOpen();</span>
<span class="line-added"> 582             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added"> 583         }</span>
<span class="line-added"> 584     }</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     /**</span>
<span class="line-added"> 587      * Adjusts the blocking mode if the channel is open. readLock or writeLock</span>
<span class="line-added"> 588      * must already be held.</span>
<span class="line-added"> 589      *</span>
<span class="line-added"> 590      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-added"> 591      *         the blocking mode was not adjusted because the channel is closed</span>
<span class="line-added"> 592      */</span>
<span class="line-added"> 593     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added"> 594         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added"> 595         synchronized (stateLock) {</span>
<span class="line-added"> 596             if (isOpen()) {</span>
<span class="line-added"> 597                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added"> 598                 return true;</span>
<span class="line-added"> 599             } else {</span>
<span class="line-added"> 600                 return false;</span>
<span class="line-added"> 601             }</span>
<span class="line-added"> 602         }</span>
<span class="line-added"> 603     }</span>
<span class="line-added"> 604 </span>
 605     /**
 606      * Returns the local address, or null if not bound
 607      */
 608     InetSocketAddress localAddress() {
 609         synchronized (stateLock) {
 610             return localAddress;
 611         }
 612     }
 613 
 614     /**
 615      * Returns the remote address, or null if not connected
 616      */
 617     InetSocketAddress remoteAddress() {
 618         synchronized (stateLock) {
 619             return remoteAddress;
 620         }
 621     }
 622 
 623     @Override
 624     public SocketChannel bind(SocketAddress local) throws IOException {
</pre>
<hr />
<pre>
 703      *
 704      * @throws AsynchronousCloseException if the channel was closed due to this
 705      * thread being interrupted on a blocking connect operation.
 706      * @throws IOException if completed and unable to obtain the local address
 707      */
 708     private void endConnect(boolean blocking, boolean completed)
 709         throws IOException
 710     {
 711         endRead(blocking, completed);
 712 
 713         if (completed) {
 714             synchronized (stateLock) {
 715                 if (state == ST_CONNECTIONPENDING) {
 716                     localAddress = Net.localAddress(fd);
 717                     state = ST_CONNECTED;
 718                 }
 719             }
 720         }
 721     }
 722 
<span class="line-modified"> 723     /**</span>
<span class="line-modified"> 724      * Checks the remote address to which this channel is to be connected.</span>
<span class="line-added"> 725      */</span>
<span class="line-added"> 726     private InetSocketAddress checkRemote(SocketAddress sa) throws IOException {</span>
 727         InetSocketAddress isa = Net.checkAddress(sa);
 728         SecurityManager sm = System.getSecurityManager();
<span class="line-modified"> 729         if (sm != null) {</span>
 730             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
<span class="line-added"> 731         }</span>
<span class="line-added"> 732         if (isa.getAddress().isAnyLocalAddress()) {</span>
<span class="line-added"> 733             return new InetSocketAddress(InetAddress.getLocalHost(), isa.getPort());</span>
<span class="line-added"> 734         } else {</span>
<span class="line-added"> 735             return isa;</span>
<span class="line-added"> 736         }</span>
<span class="line-added"> 737     }</span>
 738 
<span class="line-modified"> 739     @Override</span>
<span class="line-modified"> 740     public boolean connect(SocketAddress remote) throws IOException {</span>
<span class="line-modified"> 741         InetSocketAddress isa = checkRemote(remote);</span>

 742         try {
 743             readLock.lock();
 744             try {
 745                 writeLock.lock();
 746                 try {

 747                     boolean blocking = isBlocking();
<span class="line-added"> 748                     boolean connected = false;</span>
 749                     try {
 750                         beginConnect(blocking, isa);
<span class="line-modified"> 751                         int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>
<span class="line-modified"> 752                         if (n &gt; 0) {</span>
<span class="line-modified"> 753                             connected = true;</span>
<span class="line-added"> 754                         } else if (blocking) {</span>
<span class="line-added"> 755                             assert IOStatus.okayToRetry(n);</span>
<span class="line-added"> 756                             boolean polled = false;</span>
<span class="line-added"> 757                             while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-added"> 758                                 park(Net.POLLOUT);</span>
<span class="line-added"> 759                                 polled = Net.pollConnectNow(fd);</span>
<span class="line-added"> 760                             }</span>
<span class="line-added"> 761                             connected = polled &amp;&amp; isOpen();</span>
<span class="line-added"> 762                         }</span>
 763                     } finally {
<span class="line-modified"> 764                         endConnect(blocking, connected);</span>
 765                     }
<span class="line-modified"> 766                     return connected;</span>

 767                 } finally {
 768                     writeLock.unlock();
 769                 }
 770             } finally {
 771                 readLock.unlock();
 772             }
 773         } catch (IOException ioe) {
 774             // connect failed, close the channel
 775             close();
 776             throw SocketExceptions.of(ioe, isa);
 777         }
 778     }
 779 
 780     /**
 781      * Marks the beginning of a finishConnect operation that might block.
 782      *
 783      * @throws ClosedChannelException if the channel is closed
 784      * @throws NoConnectionPendingException if no connection is pending
 785      */
 786     private void beginFinishConnect(boolean blocking) throws ClosedChannelException {
</pre>
<hr />
<pre>
 819                 }
 820             }
 821         }
 822     }
 823 
 824     @Override
 825     public boolean finishConnect() throws IOException {
 826         try {
 827             readLock.lock();
 828             try {
 829                 writeLock.lock();
 830                 try {
 831                     // no-op if already connected
 832                     if (isConnected())
 833                         return true;
 834 
 835                     boolean blocking = isBlocking();
 836                     boolean connected = false;
 837                     try {
 838                         beginFinishConnect(blocking);
<span class="line-modified"> 839                         boolean polled = Net.pollConnectNow(fd);</span>
 840                         if (blocking) {
<span class="line-modified"> 841                             while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 842                                 park(Net.POLLOUT);</span>
<span class="line-modified"> 843                                 polled = Net.pollConnectNow(fd);</span>
<span class="line-modified"> 844                             }</span>

 845                         }
<span class="line-modified"> 846                         connected = polled &amp;&amp; isOpen();</span>
 847                     } finally {
 848                         endFinishConnect(blocking, connected);
 849                     }
 850                     assert (blocking &amp;&amp; connected) ^ !blocking;
 851                     return connected;
 852                 } finally {
 853                     writeLock.unlock();
 854                 }
 855             } finally {
 856                 readLock.unlock();
 857             }
 858         } catch (IOException ioe) {
 859             // connect failed, close the channel
 860             close();
 861             throw SocketExceptions.of(ioe, remoteAddress);
 862         }
 863     }
 864 
 865     /**
<span class="line-modified"> 866      * Closes the socket if there are no I/O operations in progress and the</span>
<span class="line-added"> 867      * channel is not registered with a Selector.</span>
<span class="line-added"> 868      */</span>
<span class="line-added"> 869     private boolean tryClose() throws IOException {</span>
<span class="line-added"> 870         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-added"> 871         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added"> 872             state = ST_CLOSED;</span>
<span class="line-added"> 873             nd.close(fd);</span>
<span class="line-added"> 874             return true;</span>
<span class="line-added"> 875         } else {</span>
<span class="line-added"> 876             return false;</span>
<span class="line-added"> 877         }</span>
<span class="line-added"> 878     }</span>
<span class="line-added"> 879 </span>
<span class="line-added"> 880     /**</span>
<span class="line-added"> 881      * Invokes tryClose to attempt to close the socket.</span>
 882      *
<span class="line-modified"> 883      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-modified"> 884      */</span>
<span class="line-modified"> 885     private void tryFinishClose() {</span>
<span class="line-modified"> 886         try {</span>
<span class="line-added"> 887             tryClose();</span>
<span class="line-added"> 888         } catch (IOException ignore) { }</span>
<span class="line-added"> 889     }</span>
<span class="line-added"> 890 </span>
<span class="line-added"> 891     /**</span>
<span class="line-added"> 892      * Closes this channel when configured in blocking mode.</span>
 893      *
<span class="line-modified"> 894      * If there is an I/O operation in progress then the socket is pre-closed</span>
<span class="line-modified"> 895      * and the I/O threads signalled, in which case the final close is deferred</span>
<span class="line-modified"> 896      * until all I/O operations complete.</span>
 897      *
<span class="line-modified"> 898      * Note that a channel configured blocking may be registered with a Selector</span>
<span class="line-modified"> 899      * This arises when a key is canceled and the channel configured to blocking</span>
<span class="line-modified"> 900      * mode before the key is flushed from the Selector.</span>

 901      */
<span class="line-modified"> 902     private void implCloseBlockingMode() throws IOException {</span>








 903         synchronized (stateLock) {
 904             assert state &lt; ST_CLOSING;


 905             state = ST_CLOSING;
<span class="line-modified"> 906             if (!tryClose()) {</span>





 907                 long reader = readerThread;
 908                 long writer = writerThread;
 909                 if (reader != 0 || writer != 0) {
 910                     nd.preClose(fd);


 911                     if (reader != 0)
 912                         NativeThread.signal(reader);
 913                     if (writer != 0)
 914                         NativeThread.signal(writer);









 915                 }
 916             }









 917         }
<span class="line-added"> 918     }</span>
 919 
<span class="line-modified"> 920     /**</span>
<span class="line-added"> 921      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added"> 922      *</span>
<span class="line-added"> 923      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added"> 924      * until the channel is flushed from all Selectors.</span>
<span class="line-added"> 925      *</span>
<span class="line-added"> 926      * If the socket is connected and the channel is registered with a Selector</span>
<span class="line-added"> 927      * then the socket is shutdown for writing so that the peer reads EOF. In</span>
<span class="line-added"> 928      * addition, if SO_LINGER is set to a non-zero value then it is disabled so</span>
<span class="line-added"> 929      * that the deferred close does not wait.</span>
<span class="line-added"> 930      */</span>
<span class="line-added"> 931     private void implCloseNonBlockingMode() throws IOException {</span>
<span class="line-added"> 932         boolean connected;</span>
<span class="line-added"> 933         synchronized (stateLock) {</span>
<span class="line-added"> 934             assert state &lt; ST_CLOSING;</span>
<span class="line-added"> 935             connected = (state == ST_CONNECTED);</span>
<span class="line-added"> 936             state = ST_CLOSING;</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         // wait for any read/write operations to complete</span>
<span class="line-added"> 940         readLock.lock();</span>
<span class="line-added"> 941         readLock.unlock();</span>
<span class="line-added"> 942         writeLock.lock();</span>
<span class="line-added"> 943         writeLock.unlock();</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945         // if the socket cannot be closed because it&#39;s registered with a Selector</span>
<span class="line-added"> 946         // then shutdown the socket for writing.</span>
 947         synchronized (stateLock) {
<span class="line-modified"> 948             if (state == ST_CLOSING &amp;&amp; !tryClose() &amp;&amp; connected &amp;&amp; isRegistered()) {</span>






 949                 try {
 950                     SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
 951                     int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
 952                     if (interval != 0) {
 953                         if (interval &gt; 0) {
 954                             // disable SO_LINGER
 955                             Net.setSocketOption(fd, Net.UNSPEC, opt, -1);
 956                         }
 957                         Net.shutdown(fd, Net.SHUT_WR);
 958                     }
 959                 } catch (IOException ignore) { }
 960             }

 961         }
<span class="line-added"> 962     }</span>
 963 
<span class="line-modified"> 964     /**</span>
<span class="line-modified"> 965      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified"> 966      */</span>
<span class="line-modified"> 967     @Override</span>
<span class="line-modified"> 968     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified"> 969         assert !isOpen();</span>
<span class="line-modified"> 970         if (isBlocking()) {</span>
<span class="line-added"> 971             implCloseBlockingMode();</span>
<span class="line-added"> 972         } else {</span>
<span class="line-added"> 973             implCloseNonBlockingMode();</span>
<span class="line-added"> 974         }</span>
 975     }
 976 
 977     @Override
<span class="line-modified"> 978     public void kill() {</span>
 979         synchronized (stateLock) {
<span class="line-modified"> 980             if (state == ST_CLOSING) {</span>
<span class="line-modified"> 981                 tryFinishClose();</span>

 982             }
 983         }
 984     }
 985 
 986     @Override
 987     public SocketChannel shutdownInput() throws IOException {
 988         synchronized (stateLock) {
 989             ensureOpen();
 990             if (!isConnected())
 991                 throw new NotYetConnectedException();
 992             if (!isInputClosed) {
 993                 Net.shutdown(fd, Net.SHUT_RD);
 994                 long thread = readerThread;
 995                 if (thread != 0)
 996                     NativeThread.signal(thread);
 997                 isInputClosed = true;
 998             }
 999             return this;
1000         }
1001     }
</pre>
<hr />
<pre>
1009             if (!isOutputClosed) {
1010                 Net.shutdown(fd, Net.SHUT_WR);
1011                 long thread = writerThread;
1012                 if (thread != 0)
1013                     NativeThread.signal(thread);
1014                 isOutputClosed = true;
1015             }
1016             return this;
1017         }
1018     }
1019 
1020     boolean isInputOpen() {
1021         return !isInputClosed;
1022     }
1023 
1024     boolean isOutputOpen() {
1025         return !isOutputClosed;
1026     }
1027 
1028     /**
<span class="line-modified">1029      * Waits for a connection attempt to finish with a timeout</span>
<span class="line-modified">1030      * @throws SocketTimeoutException if the connect timeout elapses</span>
<span class="line-added">1031      */</span>
<span class="line-added">1032     private boolean finishTimedConnect(long nanos) throws IOException {</span>
<span class="line-added">1033         long startNanos = System.nanoTime();</span>
<span class="line-added">1034         boolean polled = Net.pollConnectNow(fd);</span>
<span class="line-added">1035         while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-added">1036             long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">1037             if (remainingNanos &lt;= 0) {</span>
<span class="line-added">1038                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>
<span class="line-added">1039             }</span>
<span class="line-added">1040             park(Net.POLLOUT, remainingNanos);</span>
<span class="line-added">1041             polled = Net.pollConnectNow(fd);</span>
<span class="line-added">1042         }</span>
<span class="line-added">1043         return polled &amp;&amp; isOpen();</span>
<span class="line-added">1044     }</span>
<span class="line-added">1045 </span>
<span class="line-added">1046     /**</span>
<span class="line-added">1047      * Attempts to establish a connection to the given socket address with a</span>
<span class="line-added">1048      * timeout. Closes the socket if connection cannot be established.</span>
<span class="line-added">1049      *</span>
<span class="line-added">1050      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">1051      *</span>
<span class="line-added">1052      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">1053      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">1054      */</span>
<span class="line-added">1055     void blockingConnect(SocketAddress remote, long nanos) throws IOException {</span>
<span class="line-added">1056         InetSocketAddress isa = checkRemote(remote);</span>
<span class="line-added">1057         try {</span>
<span class="line-added">1058             readLock.lock();</span>
<span class="line-added">1059             try {</span>
<span class="line-added">1060                 writeLock.lock();</span>
<span class="line-added">1061                 try {</span>
<span class="line-added">1062                     if (!isBlocking())</span>
<span class="line-added">1063                         throw new IllegalBlockingModeException();</span>
<span class="line-added">1064                     boolean connected = false;</span>
<span class="line-added">1065                     try {</span>
<span class="line-added">1066                         beginConnect(true, isa);</span>
<span class="line-added">1067                         // change socket to non-blocking</span>
<span class="line-added">1068                         lockedConfigureBlocking(false);</span>
<span class="line-added">1069                         try {</span>
<span class="line-added">1070                             int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>
<span class="line-added">1071                             connected = (n &gt; 0) ? true : finishTimedConnect(nanos);</span>
<span class="line-added">1072                         } finally {</span>
<span class="line-added">1073                             // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">1074                             tryLockedConfigureBlocking(true);</span>
<span class="line-added">1075                         }</span>
<span class="line-added">1076                     } finally {</span>
<span class="line-added">1077                         endConnect(true, connected);</span>
<span class="line-added">1078                     }</span>
<span class="line-added">1079                 } finally {</span>
<span class="line-added">1080                     writeLock.unlock();</span>
<span class="line-added">1081                 }</span>
<span class="line-added">1082             } finally {</span>
<span class="line-added">1083                 readLock.unlock();</span>
<span class="line-added">1084             }</span>
<span class="line-added">1085         } catch (IOException ioe) {</span>
<span class="line-added">1086             // connect failed, close the channel</span>
<span class="line-added">1087             close();</span>
<span class="line-added">1088             throw SocketExceptions.of(ioe, isa);</span>
<span class="line-added">1089         }</span>
<span class="line-added">1090     }</span>
<span class="line-added">1091 </span>
<span class="line-added">1092     /**</span>
<span class="line-added">1093      * Attempts to read bytes from the socket into the given byte array.</span>
1094      */
<span class="line-modified">1095     private int tryRead(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">1096         ByteBuffer dst = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">1097         assert dst.position() == 0;</span>
<span class="line-added">1098         try {</span>
<span class="line-added">1099             int n = nd.read(fd, ((DirectBuffer)dst).address(), len);</span>
<span class="line-added">1100             if (n &gt; 0) {</span>
<span class="line-added">1101                 dst.get(b, off, n);</span>
<span class="line-added">1102             }</span>
<span class="line-added">1103             return n;</span>
<span class="line-added">1104         } finally{</span>
<span class="line-added">1105             Util.offerFirstTemporaryDirectBuffer(dst);</span>
<span class="line-added">1106         }</span>
<span class="line-added">1107     }</span>
<span class="line-added">1108 </span>
<span class="line-added">1109     /**</span>
<span class="line-added">1110      * Reads bytes from the socket into the given byte array with a timeout.</span>
<span class="line-added">1111      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">1112      */</span>
<span class="line-added">1113     private int timedRead(byte[] b, int off, int len, long nanos) throws IOException {</span>
<span class="line-added">1114         long startNanos = System.nanoTime();</span>
<span class="line-added">1115         int n = tryRead(b, off, len);</span>
<span class="line-added">1116         while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-added">1117             long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">1118             if (remainingNanos &lt;= 0) {</span>
<span class="line-added">1119                 throw new SocketTimeoutException(&quot;Read timed out&quot;);</span>
<span class="line-added">1120             }</span>
<span class="line-added">1121             park(Net.POLLIN, remainingNanos);</span>
<span class="line-added">1122             n = tryRead(b, off, len);</span>
<span class="line-added">1123         }</span>
<span class="line-added">1124         return n;</span>
<span class="line-added">1125     }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127     /**</span>
<span class="line-added">1128      * Reads bytes from the socket into the given byte array.</span>
<span class="line-added">1129      *</span>
<span class="line-added">1130      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">1131      *</span>
<span class="line-added">1132      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">1133      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">1134      */</span>
<span class="line-added">1135     int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {</span>
<span class="line-added">1136         Objects.checkFromIndexSize(off, len, b.length);</span>
<span class="line-added">1137         if (len == 0) {</span>
<span class="line-added">1138             // nothing to do</span>
<span class="line-added">1139             return 0;</span>
<span class="line-added">1140         }</span>
1141 
1142         readLock.lock();
1143         try {
<span class="line-modified">1144             // check that channel is configured blocking</span>
<span class="line-added">1145             if (!isBlocking())</span>
<span class="line-added">1146                 throw new IllegalBlockingModeException();</span>
<span class="line-added">1147 </span>
<span class="line-added">1148             int n = 0;</span>
1149             try {
<span class="line-modified">1150                 beginRead(true);</span>
<span class="line-modified">1151 </span>
<span class="line-modified">1152                 // check if connection has been reset</span>
<span class="line-added">1153                 if (connectionReset)</span>
<span class="line-added">1154                     throwConnectionReset();</span>
<span class="line-added">1155 </span>
<span class="line-added">1156                 // check if input is shutdown</span>
<span class="line-added">1157                 if (isInputClosed)</span>
<span class="line-added">1158                     return IOStatus.EOF;</span>
<span class="line-added">1159 </span>
<span class="line-added">1160                 if (nanos &gt; 0) {</span>
<span class="line-added">1161                     // change socket to non-blocking</span>
<span class="line-added">1162                     lockedConfigureBlocking(false);</span>
<span class="line-added">1163                     try {</span>
<span class="line-added">1164                         n = timedRead(b, off, len, nanos);</span>
<span class="line-added">1165                     } finally {</span>
<span class="line-added">1166                         // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">1167                         tryLockedConfigureBlocking(true);</span>
<span class="line-added">1168                     }</span>
<span class="line-added">1169                 } else {</span>
<span class="line-added">1170                     // read, no timeout</span>
<span class="line-added">1171                     n = tryRead(b, off, len);</span>
<span class="line-added">1172                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">1173                         park(Net.POLLIN);</span>
<span class="line-added">1174                         n = tryRead(b, off, len);</span>
<span class="line-added">1175                     }</span>
<span class="line-added">1176                 }</span>
<span class="line-added">1177             } catch (ConnectionResetException e) {</span>
<span class="line-added">1178                 connectionReset = true;</span>
<span class="line-added">1179                 throwConnectionReset();</span>
1180             } finally {
<span class="line-modified">1181                 endRead(true, n &gt; 0);</span>
<span class="line-added">1182                 if (n &lt;= 0 &amp;&amp; isInputClosed)</span>
<span class="line-added">1183                     return IOStatus.EOF;</span>
1184             }
<span class="line-modified">1185             assert n &gt; 0 || n == -1;</span>
<span class="line-added">1186             return n;</span>
1187         } finally {
1188             readLock.unlock();
1189         }
1190     }
1191 
1192     /**
<span class="line-modified">1193      * Attempts to write a sequence of bytes to the socket from the given</span>
<span class="line-modified">1194      * byte array.</span>
1195      */
<span class="line-modified">1196     private int tryWrite(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">1197         ByteBuffer src = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">1198         assert src.position() == 0;</span>
<span class="line-added">1199         try {</span>
<span class="line-added">1200             src.put(b, off, len);</span>
<span class="line-added">1201             return nd.write(fd, ((DirectBuffer)src).address(), len);</span>
<span class="line-added">1202         } finally {</span>
<span class="line-added">1203             Util.offerFirstTemporaryDirectBuffer(src);</span>
<span class="line-added">1204         }</span>
<span class="line-added">1205     }</span>
1206 
<span class="line-modified">1207     /**</span>
<span class="line-added">1208      * Writes a sequence of bytes to the socket from the given byte array.</span>
<span class="line-added">1209      *</span>
<span class="line-added">1210      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">1211      */</span>
<span class="line-added">1212     void blockingWriteFully(byte[] b, int off, int len) throws IOException {</span>
<span class="line-added">1213         Objects.checkFromIndexSize(off, len, b.length);</span>
<span class="line-added">1214         if (len == 0) {</span>
<span class="line-added">1215             // nothing to do</span>
<span class="line-added">1216             return;</span>
<span class="line-added">1217         }</span>
<span class="line-added">1218 </span>
<span class="line-added">1219         writeLock.lock();</span>
1220         try {
<span class="line-modified">1221             // check that channel is configured blocking</span>
<span class="line-added">1222             if (!isBlocking())</span>
<span class="line-added">1223                 throw new IllegalBlockingModeException();</span>
<span class="line-added">1224 </span>
<span class="line-added">1225             // loop until all bytes have been written</span>
<span class="line-added">1226             int pos = off;</span>
<span class="line-added">1227             int end = off + len;</span>
<span class="line-added">1228             beginWrite(true);</span>
1229             try {
<span class="line-modified">1230                 while (pos &lt; end &amp;&amp; isOpen()) {</span>
<span class="line-modified">1231                     int size = end - pos;</span>
<span class="line-modified">1232                     int n = tryWrite(b, pos, size);</span>
<span class="line-modified">1233                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified">1234                         park(Net.POLLOUT);</span>
<span class="line-modified">1235                         n = tryWrite(b, pos, size);</span>
<span class="line-modified">1236                     }</span>
<span class="line-modified">1237                     if (n &gt; 0) {</span>
<span class="line-modified">1238                         pos += n;</span>
<span class="line-modified">1239                     }</span>
1240                 }

1241             } finally {
<span class="line-modified">1242                 endWrite(true, pos &gt;= end);</span>
1243             }
1244         } finally {
<span class="line-modified">1245             writeLock.unlock();</span>
<span class="line-added">1246         }</span>
<span class="line-added">1247     }</span>
<span class="line-added">1248 </span>
<span class="line-added">1249     /**</span>
<span class="line-added">1250      * Return the number of bytes in the socket input buffer.</span>
<span class="line-added">1251      */</span>
<span class="line-added">1252     int available() throws IOException {</span>
<span class="line-added">1253         synchronized (stateLock) {</span>
<span class="line-added">1254             ensureOpenAndConnected();</span>
<span class="line-added">1255             if (isInputClosed) {</span>
<span class="line-added">1256                 return 0;</span>
<span class="line-added">1257             } else {</span>
<span class="line-added">1258                 return Net.available(fd);</span>
<span class="line-added">1259             }</span>
1260         }
1261     }
1262 
1263     /**
1264      * Translates native poll revent ops into a ready operation ops
1265      */
1266     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1267         int intOps = ski.nioInterestOps();
1268         int oldOps = ski.nioReadyOps();
1269         int newOps = initialOps;
1270 
1271         if ((ops &amp; Net.POLLNVAL) != 0) {
1272             // This should only happen if this channel is pre-closed while a
1273             // selection operation is in progress
1274             // ## Throw an error if this channel has not been pre-closed
1275             return false;
1276         }
1277 
1278         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1279             newOps = intOps;
</pre>
</td>
</tr>
</table>
<center><a href="SocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketOptionRegistry.java.template.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/DHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DHClientKeyExchange.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DHServerKeyExchange.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/DHKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,23 ***</span>
  import java.security.KeyPairGenerator;
  import java.security.NoSuchAlgorithmException;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.SecureRandom;
<span class="line-removed">- import java.security.spec.AlgorithmParameterSpec;</span>
  import java.security.spec.InvalidKeySpecException;
<span class="line-removed">- import javax.crypto.KeyAgreement;</span>
<span class="line-removed">- import javax.crypto.SecretKey;</span>
  import javax.crypto.interfaces.DHPublicKey;
  import javax.crypto.spec.DHParameterSpec;
  import javax.crypto.spec.DHPublicKeySpec;
<span class="line-removed">- import javax.crypto.spec.SecretKeySpec;</span>
<span class="line-removed">- import javax.net.ssl.SSLHandshakeException;</span>
  import sun.security.action.GetPropertyAction;
<span class="line-modified">! import sun.security.ssl.CipherSuite.HashAlg;</span>
<span class="line-removed">- import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed">- import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
  import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
  import sun.security.ssl.X509Authentication.X509Possession;
  import sun.security.util.KeyUtil;
  
  final class DHKeyExchange {
<span class="line-new-header">--- 34,16 ---</span>
  import java.security.KeyPairGenerator;
  import java.security.NoSuchAlgorithmException;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.SecureRandom;
  import java.security.spec.InvalidKeySpecException;
  import javax.crypto.interfaces.DHPublicKey;
  import javax.crypto.spec.DHParameterSpec;
  import javax.crypto.spec.DHPublicKeySpec;
  import sun.security.action.GetPropertyAction;
<span class="line-modified">! import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
  import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
  import sun.security.ssl.X509Authentication.X509Possession;
  import sun.security.util.KeyUtil;
  
  final class DHKeyExchange {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,36 ***</span>
      static final SSLPossessionGenerator poExportableGenerator =
              new DHEPossessionGenerator(true);
      static final SSLKeyAgreementGenerator kaGenerator =
              new DHEKAGenerator();
  
<span class="line-modified">!     static final class DHECredentials implements SSLCredentials {</span>
          final DHPublicKey popPublicKey;
          final NamedGroup namedGroup;
  
          DHECredentials(DHPublicKey popPublicKey, NamedGroup namedGroup) {
              this.popPublicKey = popPublicKey;
              this.namedGroup = namedGroup;
          }
  
          static DHECredentials valueOf(NamedGroup ng,
              byte[] encodedPublic) throws IOException, GeneralSecurityException {
  
<span class="line-modified">!             if (ng.type != NamedGroupType.NAMED_GROUP_FFDHE) {</span>
                  throw new RuntimeException(
                          &quot;Credentials decoding:  Not FFDHE named group&quot;);
              }
  
              if (encodedPublic == null || encodedPublic.length == 0) {
                  return null;
              }
  
<span class="line-modified">!             DHParameterSpec params = (DHParameterSpec)ng.getParameterSpec();</span>
<span class="line-removed">-             if (params == null) {</span>
<span class="line-removed">-                 return null;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              KeyFactory kf = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
              DHPublicKeySpec spec = new DHPublicKeySpec(
                      new BigInteger(1, encodedPublic),
                      params.getP(), params.getG());
              DHPublicKey publicKey =
<span class="line-new-header">--- 52,42 ---</span>
      static final SSLPossessionGenerator poExportableGenerator =
              new DHEPossessionGenerator(true);
      static final SSLKeyAgreementGenerator kaGenerator =
              new DHEKAGenerator();
  
<span class="line-modified">!     static final class DHECredentials implements NamedGroupCredentials {</span>
          final DHPublicKey popPublicKey;
          final NamedGroup namedGroup;
  
          DHECredentials(DHPublicKey popPublicKey, NamedGroup namedGroup) {
              this.popPublicKey = popPublicKey;
              this.namedGroup = namedGroup;
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public PublicKey getPublicKey() {</span>
<span class="line-added">+             return popPublicKey;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public NamedGroup getNamedGroup() {</span>
<span class="line-added">+             return namedGroup;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          static DHECredentials valueOf(NamedGroup ng,
              byte[] encodedPublic) throws IOException, GeneralSecurityException {
  
<span class="line-modified">!             if (ng.spec != NamedGroupSpec.NAMED_GROUP_FFDHE) {</span>
                  throw new RuntimeException(
                          &quot;Credentials decoding:  Not FFDHE named group&quot;);
              }
  
              if (encodedPublic == null || encodedPublic.length == 0) {
                  return null;
              }
  
<span class="line-modified">!             DHParameterSpec params = (DHParameterSpec)ng.keAlgParamSpec;</span>
              KeyFactory kf = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
              DHPublicKeySpec spec = new DHPublicKeySpec(
                      new BigInteger(1, encodedPublic),
                      params.getP(), params.getG());
              DHPublicKey publicKey =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,22 ***</span>
  
              return new DHECredentials(publicKey, ng);
          }
      }
  
<span class="line-modified">!     static final class DHEPossession implements SSLPossession {</span>
          final PrivateKey privateKey;
          final DHPublicKey publicKey;
          final NamedGroup namedGroup;
  
          DHEPossession(NamedGroup namedGroup, SecureRandom random) {
              try {
                  KeyPairGenerator kpg =
                          KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
<span class="line-modified">!                 DHParameterSpec params =</span>
<span class="line-removed">-                         (DHParameterSpec)namedGroup.getParameterSpec();</span>
<span class="line-removed">-                 kpg.initialize(params, random);</span>
                  KeyPair kp = generateDHKeyPair(kpg);
                  if (kp == null) {
                      throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
                  }
                  privateKey = kp.getPrivate();
<span class="line-new-header">--- 95,20 ---</span>
  
              return new DHECredentials(publicKey, ng);
          }
      }
  
<span class="line-modified">!     static final class DHEPossession implements NamedGroupPossession {</span>
          final PrivateKey privateKey;
          final DHPublicKey publicKey;
          final NamedGroup namedGroup;
  
          DHEPossession(NamedGroup namedGroup, SecureRandom random) {
              try {
                  KeyPairGenerator kpg =
                          KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
<span class="line-modified">!                 kpg.initialize(namedGroup.keAlgParamSpec, random);</span>
                  KeyPair kp = generateDHKeyPair(kpg);
                  if (kp == null) {
                      throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
                  }
                  privateKey = kp.getPrivate();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,17 ***</span>
          }
  
          // Generate and validate DHPublicKeySpec
          private KeyPair generateDHKeyPair(
                  KeyPairGenerator kpg) throws GeneralSecurityException {
<span class="line-modified">!             boolean doExtraValiadtion =</span>
                      (!KeyUtil.isOracleJCEProvider(kpg.getProvider().getName()));
              boolean isRecovering = false;
              for (int i = 0; i &lt;= 2; i++) {      // Try to recover from failure.
                  KeyPair kp = kpg.generateKeyPair();
                  // validate the Diffie-Hellman public key
<span class="line-modified">!                 if (doExtraValiadtion) {</span>
                      DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
                      try {
                          KeyUtil.validate(spec);
                      } catch (InvalidKeyException ivke) {
                          if (isRecovering) {
<span class="line-new-header">--- 169,17 ---</span>
          }
  
          // Generate and validate DHPublicKeySpec
          private KeyPair generateDHKeyPair(
                  KeyPairGenerator kpg) throws GeneralSecurityException {
<span class="line-modified">!             boolean doExtraValidation =</span>
                      (!KeyUtil.isOracleJCEProvider(kpg.getProvider().getName()));
              boolean isRecovering = false;
              for (int i = 0; i &lt;= 2; i++) {      // Try to recover from failure.
                  KeyPair kp = kpg.generateKeyPair();
                  // validate the Diffie-Hellman public key
<span class="line-modified">!                 if (doExtraValidation) {</span>
                      DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
                      try {
                          KeyUtil.validate(spec);
                      } catch (InvalidKeyException ivke) {
                          if (isRecovering) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,10 ***</span>
<span class="line-new-header">--- 226,25 ---</span>
                  encoded = buffer;
              }
  
              return encoded;
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public PublicKey getPublicKey() {</span>
<span class="line-added">+             return publicKey;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public NamedGroup getNamedGroup() {</span>
<span class="line-added">+             return namedGroup;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public PrivateKey getPrivateKey() {</span>
<span class="line-added">+             return privateKey;</span>
<span class="line-added">+         }</span>
      }
  
      private static final class
              DHEPossessionGenerator implements SSLPossessionGenerator {
          // Flag to use smart ephemeral DH key which size matches the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,19 ***</span>
          }
  
          // Used for ServerKeyExchange, TLS 1.2 and prior versions.
          @Override
          public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">!             NamedGroup preferableNamedGroup = null;</span>
              if (!useLegacyEphemeralDHKeys &amp;&amp;
                      (context.clientRequestedNamedGroups != null) &amp;&amp;
                      (!context.clientRequestedNamedGroups.isEmpty())) {
                  preferableNamedGroup =
<span class="line-modified">!                         SupportedGroups.getPreferredGroup(</span>
<span class="line-removed">-                                 context.negotiatedProtocol,</span>
                                  context.algorithmConstraints,
<span class="line-modified">!                                 NamedGroupType.NAMED_GROUP_FFDHE,</span>
                                  context.clientRequestedNamedGroups);
                  if (preferableNamedGroup != null) {
                      return new DHEPossession(preferableNamedGroup,
                                  context.sslContext.getSecureRandom());
                  }
<span class="line-new-header">--- 308,19 ---</span>
          }
  
          // Used for ServerKeyExchange, TLS 1.2 and prior versions.
          @Override
          public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">!             NamedGroup preferableNamedGroup;</span>
              if (!useLegacyEphemeralDHKeys &amp;&amp;
                      (context.clientRequestedNamedGroups != null) &amp;&amp;
                      (!context.clientRequestedNamedGroups.isEmpty())) {
                  preferableNamedGroup =
<span class="line-modified">!                         SupportedGroups.getPreferredGroup(context.negotiatedProtocol,</span>
                                  context.algorithmConstraints,
<span class="line-modified">!                                 new NamedGroupSpec [] {</span>
<span class="line-added">+                                     NamedGroupSpec.NAMED_GROUP_FFDHE },</span>
                                  context.clientRequestedNamedGroups);
                  if (preferableNamedGroup != null) {
                      return new DHEPossession(preferableNamedGroup,
                                  context.sslContext.getSecureRandom());
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,11 ***</span>
          }
      }
  
      private static final
              class DHEKAGenerator implements SSLKeyAgreementGenerator {
<span class="line-modified">!         static private DHEKAGenerator instance = new DHEKAGenerator();</span>
  
          // Prevent instantiation of this class.
          private DHEKAGenerator() {
              // blank
          }
<span class="line-new-header">--- 402,11 ---</span>
          }
      }
  
      private static final
              class DHEKAGenerator implements SSLKeyAgreementGenerator {
<span class="line-modified">!         private static final DHEKAGenerator instance = new DHEKAGenerator();</span>
  
          // Prevent instantiation of this class.
          private DHEKAGenerator() {
              // blank
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,95 ***</span>
              if (dhePossession == null || dheCredentials == null) {
                  throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient DHE key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new DHEKAKeyDerivation(context,</span>
                      dhePossession.privateKey, dheCredentials.popPublicKey);
          }
<span class="line-removed">- </span>
<span class="line-removed">-         private static final</span>
<span class="line-removed">-                 class DHEKAKeyDerivation implements SSLKeyDerivation {</span>
<span class="line-removed">-             private final HandshakeContext context;</span>
<span class="line-removed">-             private final PrivateKey localPrivateKey;</span>
<span class="line-removed">-             private final PublicKey peerPublicKey;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             DHEKAKeyDerivation(HandshakeContext context,</span>
<span class="line-removed">-                     PrivateKey localPrivateKey,</span>
<span class="line-removed">-                     PublicKey peerPublicKey) {</span>
<span class="line-removed">-                 this.context = context;</span>
<span class="line-removed">-                 this.localPrivateKey = localPrivateKey;</span>
<span class="line-removed">-                 this.peerPublicKey = peerPublicKey;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public SecretKey deriveKey(String algorithm,</span>
<span class="line-removed">-                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">-                 if (!context.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">-                     return t12DeriveKey(algorithm, params);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     return t13DeriveKey(algorithm, params);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             private SecretKey t12DeriveKey(String algorithm,</span>
<span class="line-removed">-                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     KeyAgreement ka = KeyAgreement.getInstance(&quot;DiffieHellman&quot;);</span>
<span class="line-removed">-                     ka.init(localPrivateKey);</span>
<span class="line-removed">-                     ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">-                     SecretKey preMasterSecret =</span>
<span class="line-removed">-                             ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">-                     SSLMasterKeyDerivation mskd =</span>
<span class="line-removed">-                             SSLMasterKeyDerivation.valueOf(</span>
<span class="line-removed">-                                     context.negotiatedProtocol);</span>
<span class="line-removed">-                     if (mskd == null) {</span>
<span class="line-removed">-                         // unlikely</span>
<span class="line-removed">-                         throw new SSLHandshakeException(</span>
<span class="line-removed">-                             &quot;No expected master key derivation for protocol: &quot; +</span>
<span class="line-removed">-                             context.negotiatedProtocol.name);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     SSLKeyDerivation kd = mskd.createKeyDerivation(</span>
<span class="line-removed">-                             context, preMasterSecret);</span>
<span class="line-removed">-                     return kd.deriveKey(&quot;MasterSecret&quot;, params);</span>
<span class="line-removed">-                 } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">-                     throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             private SecretKey t13DeriveKey(String algorithm,</span>
<span class="line-removed">-                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     KeyAgreement ka = KeyAgreement.getInstance(&quot;DiffieHellman&quot;);</span>
<span class="line-removed">-                     ka.init(localPrivateKey);</span>
<span class="line-removed">-                     ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">-                     SecretKey sharedSecret =</span>
<span class="line-removed">-                             ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;</span>
<span class="line-removed">-                     SSLKeyDerivation kd = context.handshakeKeyDerivation;</span>
<span class="line-removed">-                     HKDF hkdf = new HKDF(hashAlg.name);</span>
<span class="line-removed">-                     if (kd == null) {   // No PSK is in use.</span>
<span class="line-removed">-                         // If PSK is not in use Early Secret will still be</span>
<span class="line-removed">-                         // HKDF-Extract(0, 0).</span>
<span class="line-removed">-                         byte[] zeros = new byte[hashAlg.hashLength];</span>
<span class="line-removed">-                         SecretKeySpec ikm =</span>
<span class="line-removed">-                                 new SecretKeySpec(zeros, &quot;TlsPreSharedSecret&quot;);</span>
<span class="line-removed">-                         SecretKey earlySecret =</span>
<span class="line-removed">-                                 hkdf.extract(zeros, ikm, &quot;TlsEarlySecret&quot;);</span>
<span class="line-removed">-                         kd = new SSLSecretDerivation(context, earlySecret);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     // derive salt secret</span>
<span class="line-removed">-                     SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     // derive handshake secret</span>
<span class="line-removed">-                     return hkdf.extract(saltSecret, sharedSecret, algorithm);</span>
<span class="line-removed">-                 } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">-                     throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
  }
<span class="line-new-header">--- 452,10 ---</span>
              if (dhePossession == null || dheCredentials == null) {
                  throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient DHE key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new KAKeyDerivation(&quot;DiffieHellman&quot;, context,</span>
                      dhePossession.privateKey, dheCredentials.popPublicKey);
          }
      }
  }
</pre>
<center><a href="DHClientKeyExchange.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DHServerKeyExchange.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/net/www/http/HttpClient.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.net.www.http;
  27 
  28 import java.io.*;
  29 import java.net.*;
  30 import java.util.Locale;
  31 import java.util.Objects;
  32 import java.util.Properties;
  33 import sun.net.NetworkClient;
  34 import sun.net.ProgressSource;
  35 import sun.net.www.MessageHeader;
  36 import sun.net.www.HeaderParser;
  37 import sun.net.www.MeteredStream;
  38 import sun.net.www.ParseUtil;
  39 import sun.net.www.protocol.http.AuthenticatorKeys;
  40 import sun.net.www.protocol.http.HttpURLConnection;
  41 import sun.util.logging.PlatformLogger;
  42 import static sun.net.www.protocol.http.HttpURLConnection.TunnelState.*;
  43 import sun.security.action.GetPropertyAction;
  44 
  45 /**
  46  * @author Herb Jellinek
  47  * @author Dave Brown
  48  */
  49 public class HttpClient extends NetworkClient {
  50     // whether this httpclient comes from the cache
  51     protected boolean cachedHttpClient = false;
  52 
  53     protected boolean inCache;
  54 
  55     // Http requests we send
  56     MessageHeader requests;
  57 
  58     // Http data we send with the headers
  59     PosterOutputStream poster = null;
  60 
  61     // true if we are in streaming mode (fixed length or chunked)
  62     boolean streaming;
  63 
  64     // if we&#39;ve had one io error
  65     boolean failedOnce = false;
  66 
  67     /** Response code for CONTINUE */
  68     private boolean ignoreContinue = true;
  69     private static final int    HTTP_CONTINUE = 100;
  70 
  71     /** Default port number for http daemons. REMIND: make these private */
  72     static final int    httpPortNumber = 80;
  73 
  74     /** return default port number (subclasses may override) */
  75     protected int getDefaultPort () { return httpPortNumber; }
  76 
  77     private static int getDefaultPort(String proto) {
  78         if (&quot;http&quot;.equalsIgnoreCase(proto))
  79             return 80;
  80         if (&quot;https&quot;.equalsIgnoreCase(proto))
  81             return 443;
  82         return -1;
  83     }
  84 
  85     /* All proxying (generic as well as instance-specific) may be
  86      * disabled through use of this flag
  87      */
  88     protected boolean proxyDisabled;
  89 
  90     // are we using proxy in this instance?
  91     public boolean usingProxy = false;
  92     // target host, port for the URL
  93     protected String host;
  94     protected int port;
  95 
  96     /* where we cache currently open, persistent connections */
  97     protected static KeepAliveCache kac = new KeepAliveCache();
  98 
  99     private static boolean keepAliveProp = true;
 100 
 101     // retryPostProp is true by default so as to preserve behavior
 102     // from previous releases.
 103     private static boolean retryPostProp = true;
 104 
 105     /* Value of the system property jdk.ntlm.cache;
 106        if false, then NTLM connections will not be cached.
 107        The default value is &#39;true&#39;. */
 108     private static final boolean cacheNTLMProp;
 109     /* Value of the system property jdk.spnego.cache;
 110        if false, then connections authentified using the Negotiate/Kerberos
 111        scheme will not be cached.
 112        The default value is &#39;true&#39;. */
 113     private static final boolean cacheSPNEGOProp;
 114 
 115     volatile boolean keepingAlive;    /* this is a keep-alive connection */
 116     volatile boolean disableKeepAlive;/* keep-alive has been disabled for this
 117                                          connection - this will be used when
 118                                          recomputing the value of keepingAlive */
 119     int keepAliveConnections = -1;    /* number of keep-alives left */
 120 
 121     /**Idle timeout value, in milliseconds. Zero means infinity,
 122      * iff keepingAlive=true.
 123      * Unfortunately, we can&#39;t always believe this one.  If I&#39;m connected
 124      * through a Netscape proxy to a server that sent me a keep-alive
 125      * time of 15 sec, the proxy unilaterally terminates my connection
 126      * after 5 sec.  So we have to hard code our effective timeout to
 127      * 4 sec for the case where we&#39;re using a proxy. *SIGH*
 128      */
 129     int keepAliveTimeout = 0;
 130 
 131     /** whether the response is to be cached */
 132     private CacheRequest cacheRequest = null;
 133 
 134     /** Url being fetched. */
 135     protected URL       url;
 136 
 137     /* if set, the client will be reused and must not be put in cache */
 138     public boolean reuse = false;
 139 
 140     // Traffic capture tool, if configured. See HttpCapture class for info
 141     private HttpCapture capture = null;
 142 
 143     private static final PlatformLogger logger = HttpURLConnection.getHttpLogger();
 144     private static void logFinest(String msg) {
 145         if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
 146             logger.finest(msg);
 147         }
 148     }
 149 
 150     protected volatile String authenticatorKey;
 151 
 152     /**
 153      * A NOP method kept for backwards binary compatibility
 154      * @deprecated -- system properties are no longer cached.
 155      */
 156     @Deprecated
 157     public static synchronized void resetProperties() {
 158     }
 159 
 160     int getKeepAliveTimeout() {
 161         return keepAliveTimeout;
 162     }
 163 
 164     static {
 165         Properties props = GetPropertyAction.privilegedGetProperties();
 166         String keepAlive = props.getProperty(&quot;http.keepAlive&quot;);
 167         String retryPost = props.getProperty(&quot;sun.net.http.retryPost&quot;);
 168         String cacheNTLM = props.getProperty(&quot;jdk.ntlm.cache&quot;);
 169         String cacheSPNEGO = props.getProperty(&quot;jdk.spnego.cache&quot;);
 170 
 171         if (keepAlive != null) {
 172             keepAliveProp = Boolean.parseBoolean(keepAlive);
 173         } else {
 174             keepAliveProp = true;
 175         }
 176 
 177         if (retryPost != null) {
 178             retryPostProp = Boolean.parseBoolean(retryPost);
 179         } else {
 180             retryPostProp = true;
 181         }
 182 
 183         if (cacheNTLM != null) {
 184             cacheNTLMProp = Boolean.parseBoolean(cacheNTLM);
 185         } else {
 186             cacheNTLMProp = true;
 187         }
 188 
 189         if (cacheSPNEGO != null) {
 190             cacheSPNEGOProp = Boolean.parseBoolean(cacheSPNEGO);
 191         } else {
 192             cacheSPNEGOProp = true;
 193         }
 194     }
 195 
 196     /**
 197      * @return true iff http keep alive is set (i.e. enabled).  Defaults
 198      *          to true if the system property http.keepAlive isn&#39;t set.
 199      */
 200     public boolean getHttpKeepAliveSet() {
 201         return keepAliveProp;
 202     }
 203 
 204 
 205     protected HttpClient() {
 206     }
 207 
 208     private HttpClient(URL url)
 209     throws IOException {
 210         this(url, (String)null, -1, false);
 211     }
 212 
 213     protected HttpClient(URL url,
 214                          boolean proxyDisabled) throws IOException {
 215         this(url, null, -1, proxyDisabled);
 216     }
 217 
 218     /* This package-only CTOR should only be used for FTP piggy-backed on HTTP
 219      * URL&#39;s that use this won&#39;t take advantage of keep-alive.
 220      * Additionally, this constructor may be used as a last resort when the
 221      * first HttpClient gotten through New() failed (probably b/c of a
 222      * Keep-Alive mismatch).
 223      *
 224      * XXX That documentation is wrong ... it&#39;s not package-private any more
 225      */
 226     public HttpClient(URL url, String proxyHost, int proxyPort)
 227     throws IOException {
 228         this(url, proxyHost, proxyPort, false);
 229     }
 230 
 231     protected HttpClient(URL url, Proxy p, int to) throws IOException {
 232         proxy = (p == null) ? Proxy.NO_PROXY : p;
 233         this.host = url.getHost();
 234         this.url = url;
 235         port = url.getPort();
 236         if (port == -1) {
 237             port = getDefaultPort();
 238         }
 239         setConnectTimeout(to);
 240 
 241         capture = HttpCapture.getCapture(url);
 242         openServer();
 243     }
 244 
 245     protected static Proxy newHttpProxy(String proxyHost, int proxyPort,
 246                                       String proto) {
 247         if (proxyHost == null || proto == null)
 248             return Proxy.NO_PROXY;
 249         int pport = proxyPort &lt; 0 ? getDefaultPort(proto) : proxyPort;
 250         InetSocketAddress saddr = InetSocketAddress.createUnresolved(proxyHost, pport);
 251         return new Proxy(Proxy.Type.HTTP, saddr);
 252     }
 253 
 254     /*
 255      * This constructor gives &quot;ultimate&quot; flexibility, including the ability
 256      * to bypass implicit proxying.  Sometimes we need to be using tunneling
 257      * (transport or network level) instead of proxying (application level),
 258      * for example when we don&#39;t want the application level data to become
 259      * visible to third parties.
 260      *
 261      * @param url               the URL to which we&#39;re connecting
 262      * @param proxy             proxy to use for this URL (e.g. forwarding)
 263      * @param proxyPort         proxy port to use for this URL
 264      * @param proxyDisabled     true to disable default proxying
 265      */
 266     private HttpClient(URL url, String proxyHost, int proxyPort,
 267                        boolean proxyDisabled)
 268         throws IOException {
 269         this(url, proxyDisabled ? Proxy.NO_PROXY :
 270              newHttpProxy(proxyHost, proxyPort, &quot;http&quot;), -1);
 271     }
 272 
 273     public HttpClient(URL url, String proxyHost, int proxyPort,
 274                        boolean proxyDisabled, int to)
 275         throws IOException {
 276         this(url, proxyDisabled ? Proxy.NO_PROXY :
 277              newHttpProxy(proxyHost, proxyPort, &quot;http&quot;), to);
 278     }
 279 
 280     /* This class has no public constructor for HTTP.  This method is used to
 281      * get an HttpClient to the specified URL.  If there&#39;s currently an
 282      * active HttpClient to that server/port, you&#39;ll get that one.
 283      */
 284     public static HttpClient New(URL url)
 285     throws IOException {
 286         return HttpClient.New(url, Proxy.NO_PROXY, -1, true, null);
 287     }
 288 
 289     public static HttpClient New(URL url, boolean useCache)
 290         throws IOException {
 291         return HttpClient.New(url, Proxy.NO_PROXY, -1, useCache, null);
 292     }
 293 
 294     public static HttpClient New(URL url, Proxy p, int to, boolean useCache,
 295         HttpURLConnection httpuc) throws IOException
 296     {
 297         if (p == null) {
 298             p = Proxy.NO_PROXY;
 299         }
 300         HttpClient ret = null;
 301         /* see if one&#39;s already around */
 302         if (useCache) {
 303             ret = kac.get(url, null);
 304             if (ret != null &amp;&amp; httpuc != null &amp;&amp;
 305                 httpuc.streaming() &amp;&amp;
 306                 httpuc.getRequestMethod() == &quot;POST&quot;) {
 307                 if (!ret.available()) {
 308                     ret.inCache = false;
 309                     ret.closeServer();
 310                     ret = null;
 311                 }
 312             }
 313             if (ret != null) {
 314                 String ak = httpuc == null ? AuthenticatorKeys.DEFAULT
 315                      : httpuc.getAuthenticatorKey();
 316                 boolean compatible = Objects.equals(ret.proxy, p)
 317                      &amp;&amp; Objects.equals(ret.getAuthenticatorKey(), ak);
 318                 if (compatible) {
 319                     synchronized (ret) {
 320                         ret.cachedHttpClient = true;
 321                         assert ret.inCache;
 322                         ret.inCache = false;
 323                         if (httpuc != null &amp;&amp; ret.needsTunneling())
 324                             httpuc.setTunnelState(TUNNELING);
 325                         logFinest(&quot;KeepAlive stream retrieved from the cache, &quot; + ret);
 326                     }
 327                 } else {
 328                     // We cannot return this connection to the cache as it&#39;s
 329                     // KeepAliveTimeout will get reset. We simply close the connection.
 330                     // This should be fine as it is very rare that a connection
 331                     // to the same host will not use the same proxy.
 332                     synchronized(ret) {
 333                         ret.inCache = false;
 334                         ret.closeServer();
 335                     }
 336                     ret = null;
 337                 }
 338             }
 339         }
 340         if (ret == null) {
 341             ret = new HttpClient(url, p, to);
 342             if (httpuc != null) {
 343                 ret.authenticatorKey = httpuc.getAuthenticatorKey();
 344             }
 345         } else {
 346             SecurityManager security = System.getSecurityManager();
 347             if (security != null) {
 348                 if (ret.proxy == Proxy.NO_PROXY || ret.proxy == null) {
 349                     security.checkConnect(InetAddress.getByName(url.getHost()).getHostAddress(), url.getPort());
 350                 } else {
 351                     security.checkConnect(url.getHost(), url.getPort());
 352                 }
 353             }
 354             ret.url = url;
 355         }
 356         return ret;
 357     }
 358 
 359     public static HttpClient New(URL url, Proxy p, int to,
 360         HttpURLConnection httpuc) throws IOException
 361     {
 362         return New(url, p, to, true, httpuc);
 363     }
 364 
 365     public static HttpClient New(URL url, String proxyHost, int proxyPort,
 366                                  boolean useCache)
 367         throws IOException {
 368         return New(url, newHttpProxy(proxyHost, proxyPort, &quot;http&quot;),
 369             -1, useCache, null);
 370     }
 371 
 372     public static HttpClient New(URL url, String proxyHost, int proxyPort,
 373                                  boolean useCache, int to,
 374                                  HttpURLConnection httpuc)
 375         throws IOException {
 376         return New(url, newHttpProxy(proxyHost, proxyPort, &quot;http&quot;),
 377             to, useCache, httpuc);
 378     }
 379 
 380     public final String getAuthenticatorKey() {
 381         String k = authenticatorKey;
 382         if (k == null) return AuthenticatorKeys.DEFAULT;
 383         return k;
 384     }
 385 
 386     /* return it to the cache as still usable, if:
 387      * 1) It&#39;s keeping alive, AND
 388      * 2) It still has some connections left, AND
 389      * 3) It hasn&#39;t had a error (PrintStream.checkError())
 390      * 4) It hasn&#39;t timed out
 391      *
 392      * If this client is not keepingAlive, it should have been
 393      * removed from the cache in the parseHeaders() method.
 394      */
 395 
 396     public void finished() {
 397         if (reuse) /* will be reused */
 398             return;
 399         keepAliveConnections--;
 400         poster = null;
 401         if (keepAliveConnections &gt; 0 &amp;&amp; isKeepingAlive() &amp;&amp;
 402                !(serverOutput.checkError())) {
 403             /* This connection is keepingAlive &amp;&amp; still valid.
 404              * Return it to the cache.
 405              */
 406             putInKeepAliveCache();
 407         } else {
 408             closeServer();
 409         }
 410     }
 411 
 412     protected synchronized boolean available() {
 413         boolean available = true;
 414         int old = -1;
 415 
 416         try {
 417             try {
 418                 old = serverSocket.getSoTimeout();
 419                 serverSocket.setSoTimeout(1);
 420                 BufferedInputStream tmpbuf =
 421                         new BufferedInputStream(serverSocket.getInputStream());
 422                 int r = tmpbuf.read();
 423                 if (r == -1) {
 424                     logFinest(&quot;HttpClient.available(): &quot; +
 425                             &quot;read returned -1: not available&quot;);
 426                     available = false;
 427                 }
 428             } catch (SocketTimeoutException e) {
 429                 logFinest(&quot;HttpClient.available(): &quot; +
 430                         &quot;SocketTimeout: its available&quot;);
 431             } finally {
 432                 if (old != -1)
 433                     serverSocket.setSoTimeout(old);
 434             }
 435         } catch (IOException e) {
 436             logFinest(&quot;HttpClient.available(): &quot; +
 437                         &quot;SocketException: not available&quot;);
 438             available = false;
 439         }
 440         return available;
 441     }
 442 
 443     protected synchronized void putInKeepAliveCache() {
 444         if (inCache) {
 445             assert false : &quot;Duplicate put to keep alive cache&quot;;
 446             return;
 447         }
 448         inCache = true;
 449         kac.put(url, null, this);
 450     }
 451 
 452     protected synchronized boolean isInKeepAliveCache() {
 453         return inCache;
 454     }
 455 
 456     /*
 457      * Close an idle connection to this URL (if it exists in the
 458      * cache).
 459      */
 460     public void closeIdleConnection() {
 461         HttpClient http = kac.get(url, null);
 462         if (http != null) {
 463             http.closeServer();
 464         }
 465     }
 466 
 467     /* We&#39;re very particular here about what our InputStream to the server
 468      * looks like for reasons that are apparent if you can decipher the
 469      * method parseHTTP().  That&#39;s why this method is overidden from the
 470      * superclass.
 471      */
 472     @Override
 473     public void openServer(String server, int port) throws IOException {
 474         serverSocket = doConnect(server, port);
 475         try {
 476             OutputStream out = serverSocket.getOutputStream();
 477             if (capture != null) {
 478                 out = new HttpCaptureOutputStream(out, capture);
 479             }
 480             serverOutput = new PrintStream(
 481                 new BufferedOutputStream(out),
 482                                          false, encoding);
 483         } catch (UnsupportedEncodingException e) {
 484             throw new InternalError(encoding+&quot; encoding not found&quot;, e);
 485         }
 486         serverSocket.setTcpNoDelay(true);
 487     }
 488 
 489     /*
 490      * Returns true if the http request should be tunneled through proxy.
 491      * An example where this is the case is Https.
 492      */
 493     public boolean needsTunneling() {
 494         return false;
 495     }
 496 
 497     /*
 498      * Returns true if this httpclient is from cache
 499      */
 500     public synchronized boolean isCachedConnection() {
 501         return cachedHttpClient;
 502     }
 503 
 504     /*
 505      * Finish any work left after the socket connection is
 506      * established.  In the normal http case, it&#39;s a NO-OP. Subclass
 507      * may need to override this. An example is Https, where for
 508      * direct connection to the origin server, ssl handshake needs to
 509      * be done; for proxy tunneling, the socket needs to be converted
 510      * into an SSL socket before ssl handshake can take place.
 511      */
 512     public void afterConnect() throws IOException, UnknownHostException {
 513         // NO-OP. Needs to be overwritten by HttpsClient
 514     }
 515 
 516     /*
 517      * call openServer in a privileged block
 518      */
 519     private synchronized void privilegedOpenServer(final InetSocketAddress server)
 520          throws IOException
 521     {
 522         try {
 523             java.security.AccessController.doPrivileged(
 524                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
 525                     public Void run() throws IOException {
 526                     openServer(server.getHostString(), server.getPort());
 527                     return null;
 528                 }
 529             });
 530         } catch (java.security.PrivilegedActionException pae) {
 531             throw (IOException) pae.getException();
 532         }
 533     }
 534 
 535     /*
 536      * call super.openServer
 537      */
 538     private void superOpenServer(final String proxyHost,
 539                                  final int proxyPort)
 540         throws IOException, UnknownHostException
 541     {
 542         super.openServer(proxyHost, proxyPort);
 543     }
 544 
 545     /*
 546      */
 547     protected synchronized void openServer() throws IOException {
 548 
 549         SecurityManager security = System.getSecurityManager();
 550 
 551         if (security != null) {
 552             security.checkConnect(host, port);
 553         }
 554 
 555         if (keepingAlive) { // already opened
 556             return;
 557         }
 558 
 559         if (url.getProtocol().equals(&quot;http&quot;) ||
 560             url.getProtocol().equals(&quot;https&quot;) ) {
 561 
 562             if ((proxy != null) &amp;&amp; (proxy.type() == Proxy.Type.HTTP)) {
 563                 sun.net.www.URLConnection.setProxiedHost(host);
 564                 privilegedOpenServer((InetSocketAddress) proxy.address());
 565                 usingProxy = true;
 566                 return;
 567             } else {
 568                 // make direct connection
 569                 openServer(host, port);
 570                 usingProxy = false;
 571                 return;
 572             }
 573 
 574         } else {
 575             /* we&#39;re opening some other kind of url, most likely an
 576              * ftp url.
 577              */
 578             if ((proxy != null) &amp;&amp; (proxy.type() == Proxy.Type.HTTP)) {
 579                 sun.net.www.URLConnection.setProxiedHost(host);
 580                 privilegedOpenServer((InetSocketAddress) proxy.address());
 581                 usingProxy = true;
 582                 return;
 583             } else {
 584                 // make direct connection
 585                 super.openServer(host, port);
 586                 usingProxy = false;
 587                 return;
 588             }
 589         }
 590     }
 591 
 592     public String getURLFile() throws IOException {
 593 
 594         String fileName;
 595 
 596         /**
 597          * proxyDisabled is set by subclass HttpsClient!
 598          */
 599         if (usingProxy &amp;&amp; !proxyDisabled) {
 600             // Do not use URLStreamHandler.toExternalForm as the fragment
 601             // should not be part of the RequestURI. It should be an
 602             // absolute URI which does not have a fragment part.
 603             StringBuilder result = new StringBuilder(128);
 604             result.append(url.getProtocol());
 605             result.append(&quot;:&quot;);
 606             if (url.getAuthority() != null &amp;&amp; !url.getAuthority().isEmpty()) {
 607                 result.append(&quot;//&quot;);
 608                 result.append(url.getAuthority());
 609             }
 610             if (url.getPath() != null) {
 611                 result.append(url.getPath());
 612             }
 613             if (url.getQuery() != null) {
 614                 result.append(&#39;?&#39;);
 615                 result.append(url.getQuery());
 616             }
 617 
 618             fileName = result.toString();
 619         } else {
 620             fileName = url.getFile();
 621 
 622             if ((fileName == null) || (fileName.isEmpty())) {
 623                 fileName = &quot;/&quot;;
 624             } else if (fileName.charAt(0) == &#39;?&#39;) {
 625                 /* HTTP/1.1 spec says in 5.1.2. about Request-URI:
 626                  * &quot;Note that the absolute path cannot be empty; if
 627                  * none is present in the original URI, it MUST be
 628                  * given as &quot;/&quot; (the server root).&quot;  So if the file
 629                  * name here has only a query string, the path is
 630                  * empty and we also have to add a &quot;/&quot;.
 631                  */
 632                 fileName = &quot;/&quot; + fileName;
 633             }
 634         }
 635 
 636         if (fileName.indexOf(&#39;\n&#39;) == -1)
 637             return fileName;
 638         else
 639             throw new java.net.MalformedURLException(&quot;Illegal character in URL&quot;);
 640     }
 641 
 642     /**
 643      * @deprecated
 644      */
 645     @Deprecated
 646     public void writeRequests(MessageHeader head) {
 647         requests = head;
 648         requests.print(serverOutput);
 649         serverOutput.flush();
 650     }
 651 
 652     public void writeRequests(MessageHeader head,
 653                               PosterOutputStream pos) throws IOException {
 654         requests = head;
 655         requests.print(serverOutput);
 656         poster = pos;
 657         if (poster != null)
 658             poster.writeTo(serverOutput);
 659         serverOutput.flush();
 660     }
 661 
 662     public void writeRequests(MessageHeader head,
 663                               PosterOutputStream pos,
 664                               boolean streaming) throws IOException {
 665         this.streaming = streaming;
 666         writeRequests(head, pos);
 667     }
 668 
 669     /** Parse the first line of the HTTP request.  It usually looks
 670         something like: {@literal &quot;HTTP/1.0 &lt;number&gt; comment\r\n&quot;}. */
 671 
 672     public boolean parseHTTP(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)
 673     throws IOException {
 674         /* If &quot;HTTP/*&quot; is found in the beginning, return true.  Let
 675          * HttpURLConnection parse the mime header itself.
 676          *
 677          * If this isn&#39;t valid HTTP, then we don&#39;t try to parse a header
 678          * out of the beginning of the response into the responses,
 679          * and instead just queue up the output stream to it&#39;s very beginning.
 680          * This seems most reasonable, and is what the NN browser does.
 681          */
 682 
 683         try {
 684             serverInput = serverSocket.getInputStream();
 685             if (capture != null) {
 686                 serverInput = new HttpCaptureInputStream(serverInput, capture);
 687             }
 688             serverInput = new BufferedInputStream(serverInput);
 689             return (parseHTTPHeader(responses, pi, httpuc));
 690         } catch (SocketTimeoutException stex) {
 691             // We don&#39;t want to retry the request when the app. sets a timeout
 692             // but don&#39;t close the server if timeout while waiting for 100-continue
 693             if (ignoreContinue) {
 694                 closeServer();
 695             }
 696             throw stex;
 697         } catch (IOException e) {
 698             closeServer();
 699             cachedHttpClient = false;
 700             if (!failedOnce &amp;&amp; requests != null) {
 701                 failedOnce = true;
 702                 if (getRequestMethod().equals(&quot;CONNECT&quot;)
 703                     || streaming
 704                     || (httpuc.getRequestMethod().equals(&quot;POST&quot;)
 705                         &amp;&amp; !retryPostProp)) {
 706                     // do not retry the request
 707                 }  else {
 708                     // try once more
 709                     openServer();
<a name="2" id="anc2"></a><span class="line-modified"> 710                     checkTunneling(httpuc);</span>




 711                     afterConnect();
 712                     writeRequests(requests, poster);
 713                     return parseHTTP(responses, pi, httpuc);
 714                 }
 715             }
 716             throw e;
 717         }
 718 
 719     }
 720 
<a name="3" id="anc3"></a><span class="line-added"> 721     // Check whether tunnel must be open and open it if necessary</span>
<span class="line-added"> 722     // (in the case of HTTPS with proxy)</span>
<span class="line-added"> 723     private void checkTunneling(HttpURLConnection httpuc) throws IOException {</span>
<span class="line-added"> 724         if (needsTunneling()) {</span>
<span class="line-added"> 725             MessageHeader origRequests = requests;</span>
<span class="line-added"> 726             PosterOutputStream origPoster = poster;</span>
<span class="line-added"> 727             httpuc.doTunneling();</span>
<span class="line-added"> 728             requests = origRequests;</span>
<span class="line-added"> 729             poster = origPoster;</span>
<span class="line-added"> 730         }</span>
<span class="line-added"> 731     }</span>
<span class="line-added"> 732 </span>
 733     private boolean parseHTTPHeader(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)
 734     throws IOException {
 735         /* If &quot;HTTP/*&quot; is found in the beginning, return true.  Let
 736          * HttpURLConnection parse the mime header itself.
 737          *
 738          * If this isn&#39;t valid HTTP, then we don&#39;t try to parse a header
 739          * out of the beginning of the response into the responses,
 740          * and instead just queue up the output stream to it&#39;s very beginning.
 741          * This seems most reasonable, and is what the NN browser does.
 742          */
 743 
 744         keepAliveConnections = -1;
 745         keepAliveTimeout = 0;
 746 
 747         boolean ret = false;
 748         byte[] b = new byte[8];
 749 
 750         try {
 751             int nread = 0;
 752             serverInput.mark(10);
 753             while (nread &lt; 8) {
 754                 int r = serverInput.read(b, nread, 8 - nread);
 755                 if (r &lt; 0) {
 756                     break;
 757                 }
 758                 nread += r;
 759             }
 760             String keep=null;
 761             String authenticate=null;
 762             ret = b[0] == &#39;H&#39; &amp;&amp; b[1] == &#39;T&#39;
 763                     &amp;&amp; b[2] == &#39;T&#39; &amp;&amp; b[3] == &#39;P&#39; &amp;&amp; b[4] == &#39;/&#39; &amp;&amp;
 764                 b[5] == &#39;1&#39; &amp;&amp; b[6] == &#39;.&#39;;
 765             serverInput.reset();
 766             if (ret) { // is valid HTTP - response started w/ &quot;HTTP/1.&quot;
 767                 responses.parseHeader(serverInput);
 768 
 769                 // we&#39;ve finished parsing http headers
 770                 // check if there are any applicable cookies to set (in cache)
 771                 CookieHandler cookieHandler = httpuc.getCookieHandler();
 772                 if (cookieHandler != null) {
 773                     URI uri = ParseUtil.toURI(url);
 774                     // NOTE: That cast from Map shouldn&#39;t be necessary but
 775                     // a bug in javac is triggered under certain circumstances
 776                     // So we do put the cast in as a workaround until
 777                     // it is resolved.
 778                     if (uri != null)
 779                         cookieHandler.put(uri, responses.getHeaders());
 780                 }
 781 
 782                 /* decide if we&#39;re keeping alive:
 783                  * This is a bit tricky.  There&#39;s a spec, but most current
 784                  * servers (10/1/96) that support this differ in dialects.
 785                  * If the server/client misunderstand each other, the
 786                  * protocol should fall back onto HTTP/1.0, no keep-alive.
 787                  */
 788                 if (usingProxy) { // not likely a proxy will return this
 789                     keep = responses.findValue(&quot;Proxy-Connection&quot;);
 790                     authenticate = responses.findValue(&quot;Proxy-Authenticate&quot;);
 791                 }
 792                 if (keep == null) {
 793                     keep = responses.findValue(&quot;Connection&quot;);
 794                     authenticate = responses.findValue(&quot;WWW-Authenticate&quot;);
 795                 }
 796 
 797                 // &#39;disableKeepAlive&#39; starts with the value false.
 798                 // It can transition from false to true, but once true
 799                 // it stays true.
 800                 // If cacheNTLMProp is false, and disableKeepAlive is false,
 801                 // then we need to examine the response headers to figure out
 802                 // whether we are doing NTLM authentication. If we do NTLM,
 803                 // and cacheNTLMProp is false, than we can&#39;t keep this connection
 804                 // alive: we will switch disableKeepAlive to true.
 805                 boolean canKeepAlive = !disableKeepAlive;
 806                 if (canKeepAlive &amp;&amp; (cacheNTLMProp == false || cacheSPNEGOProp == false)
 807                         &amp;&amp; authenticate != null) {
 808                     authenticate = authenticate.toLowerCase(Locale.US);
 809                     if (cacheNTLMProp == false) {
 810                         canKeepAlive &amp;= !authenticate.startsWith(&quot;ntlm &quot;);
 811                     }
 812                     if (cacheSPNEGOProp == false) {
 813                         canKeepAlive &amp;= !authenticate.startsWith(&quot;negotiate &quot;);
 814                         canKeepAlive &amp;= !authenticate.startsWith(&quot;kerberos &quot;);
 815                     }
 816                 }
 817                 disableKeepAlive |= !canKeepAlive;
 818 
 819                 if (keep != null &amp;&amp; keep.toLowerCase(Locale.US).equals(&quot;keep-alive&quot;)) {
 820                     /* some servers, notably Apache1.1, send something like:
 821                      * &quot;Keep-Alive: timeout=15, max=1&quot; which we should respect.
 822                      */
 823                     if (disableKeepAlive) {
 824                         keepAliveConnections = 1;
 825                     } else {
 826                         HeaderParser p = new HeaderParser(
 827                             responses.findValue(&quot;Keep-Alive&quot;));
 828                         /* default should be larger in case of proxy */
 829                         keepAliveConnections = p.findInt(&quot;max&quot;, usingProxy?50:5);
 830                         keepAliveTimeout = p.findInt(&quot;timeout&quot;, usingProxy?60:5);
 831                     }
 832                 } else if (b[7] != &#39;0&#39;) {
 833                     /*
 834                      * We&#39;re talking 1.1 or later. Keep persistent until
 835                      * the server says to close.
 836                      */
 837                     if (keep != null || disableKeepAlive) {
 838                         /*
 839                          * The only Connection token we understand is close.
 840                          * Paranoia: if there is any Connection header then
 841                          * treat as non-persistent.
 842                          */
 843                         keepAliveConnections = 1;
 844                     } else {
 845                         keepAliveConnections = 5;
 846                     }
 847                 }
 848             } else if (nread != 8) {
 849                 if (!failedOnce &amp;&amp; requests != null) {
 850                     failedOnce = true;
 851                     if (getRequestMethod().equals(&quot;CONNECT&quot;)
 852                         || streaming
 853                         || (httpuc.getRequestMethod().equals(&quot;POST&quot;)
 854                             &amp;&amp; !retryPostProp)) {
 855                         // do not retry the request
 856                     } else {
 857                         closeServer();
 858                         cachedHttpClient = false;
 859                         openServer();
<a name="4" id="anc4"></a><span class="line-modified"> 860                         checkTunneling(httpuc);</span>




 861                         afterConnect();
 862                         writeRequests(requests, poster);
 863                         return parseHTTP(responses, pi, httpuc);
 864                     }
 865                 }
 866                 throw new SocketException(&quot;Unexpected end of file from server&quot;);
 867             } else {
 868                 // we can&#39;t vouche for what this is....
 869                 responses.set(&quot;Content-type&quot;, &quot;unknown/unknown&quot;);
 870             }
 871         } catch (IOException e) {
 872             throw e;
 873         }
 874 
 875         int code = -1;
 876         try {
 877             String resp;
 878             resp = responses.getValue(0);
 879             /* should have no leading/trailing LWS
 880              * expedite the typical case by assuming it has
 881              * form &quot;HTTP/1.x &lt;WS&gt; 2XX &lt;mumble&gt;&quot;
 882              */
 883             int ind;
 884             ind = resp.indexOf(&#39; &#39;);
 885             while(resp.charAt(ind) == &#39; &#39;)
 886                 ind++;
 887             code = Integer.parseInt(resp, ind, ind + 3, 10);
 888         } catch (Exception e) {}
 889 
 890         if (code == HTTP_CONTINUE &amp;&amp; ignoreContinue) {
 891             responses.reset();
 892             return parseHTTPHeader(responses, pi, httpuc);
 893         }
 894 
 895         long cl = -1;
 896 
 897         /*
 898          * Set things up to parse the entity body of the reply.
 899          * We should be smarter about avoid pointless work when
 900          * the HTTP method and response code indicate there will be
 901          * no entity body to parse.
 902          */
 903         String te = responses.findValue(&quot;Transfer-Encoding&quot;);
 904         if (te != null &amp;&amp; te.equalsIgnoreCase(&quot;chunked&quot;)) {
 905             serverInput = new ChunkedInputStream(serverInput, this, responses);
 906 
 907             /*
 908              * If keep alive not specified then close after the stream
 909              * has completed.
 910              */
 911             if (keepAliveConnections &lt;= 1) {
 912                 keepAliveConnections = 1;
 913                 keepingAlive = false;
 914             } else {
 915                 keepingAlive = !disableKeepAlive;
 916             }
 917             failedOnce = false;
 918         } else {
 919 
 920             /*
 921              * If it&#39;s a keep alive connection then we will keep
 922              * (alive if :-
 923              * 1. content-length is specified, or
 924              * 2. &quot;Not-Modified&quot; or &quot;No-Content&quot; responses - RFC 2616 states that
 925              *    204 or 304 response must not include a message body.
 926              */
 927             String cls = responses.findValue(&quot;content-length&quot;);
 928             if (cls != null) {
 929                 try {
 930                     cl = Long.parseLong(cls);
 931                 } catch (NumberFormatException e) {
 932                     cl = -1;
 933                 }
 934             }
 935             String requestLine = requests.getKey(0);
 936 
 937             if ((requestLine != null &amp;&amp;
 938                  (requestLine.startsWith(&quot;HEAD&quot;))) ||
 939                 code == HttpURLConnection.HTTP_NOT_MODIFIED ||
 940                 code == HttpURLConnection.HTTP_NO_CONTENT) {
 941                 cl = 0;
 942             }
 943 
 944             if (keepAliveConnections &gt; 1 &amp;&amp;
 945                 (cl &gt;= 0 ||
 946                  code == HttpURLConnection.HTTP_NOT_MODIFIED ||
 947                  code == HttpURLConnection.HTTP_NO_CONTENT)) {
 948                 keepingAlive = !disableKeepAlive;
 949                 failedOnce = false;
 950             } else if (keepingAlive) {
 951                 /* Previously we were keeping alive, and now we&#39;re not.  Remove
 952                  * this from the cache (but only here, once) - otherwise we get
 953                  * multiple removes and the cache count gets messed up.
 954                  */
 955                 keepingAlive=false;
 956             }
 957         }
 958 
 959         /* wrap a KeepAliveStream/MeteredStream around it if appropriate */
 960 
 961         if (cl &gt; 0) {
 962             // In this case, content length is well known, so it is okay
 963             // to wrap the input stream with KeepAliveStream/MeteredStream.
 964 
 965             if (pi != null) {
 966                 // Progress monitor is enabled
 967                 pi.setContentType(responses.findValue(&quot;content-type&quot;));
 968             }
 969 
 970             // If disableKeepAlive == true, the client will not be returned
 971             // to the cache. But we still need to use a keepalive stream to
 972             // allow the multi-message authentication exchange on the connection
 973             boolean useKeepAliveStream = isKeepingAlive() || disableKeepAlive;
 974             if (useKeepAliveStream)   {
 975                 // Wrap KeepAliveStream if keep alive is enabled.
 976                 logFinest(&quot;KeepAlive stream used: &quot; + url);
 977                 serverInput = new KeepAliveStream(serverInput, pi, cl, this);
 978                 failedOnce = false;
 979             }
 980             else        {
 981                 serverInput = new MeteredStream(serverInput, pi, cl);
 982             }
 983         }
 984         else if (cl == -1)  {
 985             // In this case, content length is unknown - the input
 986             // stream would simply be a regular InputStream or
 987             // ChunkedInputStream.
 988 
 989             if (pi != null) {
 990                 // Progress monitoring is enabled.
 991 
 992                 pi.setContentType(responses.findValue(&quot;content-type&quot;));
 993 
 994                 // Wrap MeteredStream for tracking indeterministic
 995                 // progress, even if the input stream is ChunkedInputStream.
 996                 serverInput = new MeteredStream(serverInput, pi, cl);
 997             }
 998             else    {
 999                 // Progress monitoring is disabled, and there is no
1000                 // need to wrap an unknown length input stream.
1001 
1002                 // ** This is an no-op **
1003             }
1004         }
1005         else    {
1006             if (pi != null)
1007                 pi.finishTracking();
1008         }
1009 
1010         return ret;
1011     }
1012 
1013     public synchronized InputStream getInputStream() {
1014         return serverInput;
1015     }
1016 
1017     public OutputStream getOutputStream() {
1018         return serverOutput;
1019     }
1020 
1021     @Override
1022     public String toString() {
1023         return getClass().getName()+&quot;(&quot;+url+&quot;)&quot;;
1024     }
1025 
1026     public final boolean isKeepingAlive() {
1027         return getHttpKeepAliveSet() &amp;&amp; keepingAlive;
1028     }
1029 
1030     public void setCacheRequest(CacheRequest cacheRequest) {
1031         this.cacheRequest = cacheRequest;
1032     }
1033 
1034     CacheRequest getCacheRequest() {
1035         return cacheRequest;
1036     }
1037 
1038     String getRequestMethod() {
1039         if (requests != null) {
1040             String requestLine = requests.getKey(0);
1041             if (requestLine != null) {
1042                return requestLine.split(&quot;\\s+&quot;)[0];
1043             }
1044         }
1045         return &quot;&quot;;
1046     }
1047 
1048     public void setDoNotRetry(boolean value) {
1049         // failedOnce is used to determine if a request should be retried.
1050         failedOnce = value;
1051     }
1052 
1053     public void setIgnoreContinue(boolean value) {
1054         ignoreContinue = value;
1055     }
1056 
1057     /* Use only on connections in error. */
1058     @Override
1059     public void closeServer() {
1060         try {
1061             keepingAlive = false;
1062             serverSocket.close();
1063         } catch (Exception e) {}
1064     }
1065 
1066     /**
1067      * @return the proxy host being used for this client, or null
1068      *          if we&#39;re not going through a proxy
1069      */
1070     public String getProxyHostUsed() {
1071         if (!usingProxy) {
1072             return null;
1073         } else {
1074             return ((InetSocketAddress)proxy.address()).getHostString();
1075         }
1076     }
1077 
1078     /**
1079      * @return the proxy port being used for this client.  Meaningless
1080      *          if getProxyHostUsed() gives null.
1081      */
1082     public int getProxyPortUsed() {
1083         if (usingProxy)
1084             return ((InetSocketAddress)proxy.address()).getPort();
1085         return -1;
1086     }
1087 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
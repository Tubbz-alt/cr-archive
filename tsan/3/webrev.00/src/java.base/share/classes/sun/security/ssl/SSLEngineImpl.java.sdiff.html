<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLContextImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineInputRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.nio.ReadOnlyBufferException;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedActionException;
  33 import java.security.PrivilegedExceptionAction;
  34 import java.util.List;
  35 import java.util.Map;

  36 import java.util.function.BiFunction;
  37 import javax.net.ssl.SSLEngine;
  38 import javax.net.ssl.SSLEngineResult;
  39 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  40 import javax.net.ssl.SSLEngineResult.Status;
  41 import javax.net.ssl.SSLException;
  42 import javax.net.ssl.SSLHandshakeException;
  43 import javax.net.ssl.SSLKeyException;
  44 import javax.net.ssl.SSLParameters;
  45 import javax.net.ssl.SSLPeerUnverifiedException;
  46 import javax.net.ssl.SSLProtocolException;
  47 import javax.net.ssl.SSLSession;
  48 
  49 /**
  50  * Implementation of an non-blocking SSLEngine.
  51  *
  52  * @author Brad Wetmore
  53  */
  54 final class SSLEngineImpl extends SSLEngine implements SSLTransport {
  55     private final SSLContextImpl        sslContext;
  56     final TransportContext              conContext;

  57 
  58     /**
  59      * Constructor for an SSLEngine from SSLContext, without
  60      * host/port hints.
  61      *
  62      * This Engine will not be able to cache sessions, but must renegotiate
  63      * everything by hand.
  64      */
  65     SSLEngineImpl(SSLContextImpl sslContext) {
  66         this(sslContext, null, -1);
  67     }
  68 
  69     /**
  70      * Constructor for an SSLEngine from SSLContext.
  71      */
  72     SSLEngineImpl(SSLContextImpl sslContext,
  73             String host, int port) {
  74         super(host, port);
  75         this.sslContext = sslContext;
  76         HandshakeHash handshakeHash = new HandshakeHash();
  77         if (sslContext.isDTLS()) {
  78             this.conContext = new TransportContext(sslContext, this,
  79                     new DTLSInputRecord(handshakeHash),
  80                     new DTLSOutputRecord(handshakeHash));
  81         } else {
  82             this.conContext = new TransportContext(sslContext, this,
  83                     new SSLEngineInputRecord(handshakeHash),
  84                     new SSLEngineOutputRecord(handshakeHash));
  85         }
  86 
  87         // Server name indication is a connection scope extension.
  88         if (host != null) {
  89             this.conContext.sslConfig.serverNames =
  90                     Utilities.addToSNIServerNameList(
  91                             conContext.sslConfig.serverNames, host);
  92         }
  93     }
  94 
  95     @Override
<span class="line-modified">  96     public synchronized void beginHandshake() throws SSLException {</span>
<span class="line-modified">  97         if (conContext.isUnsureMode) {</span>
<span class="line-removed">  98             throw new IllegalStateException(</span>
<span class="line-removed">  99                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-removed"> 100         }</span>
<span class="line-removed"> 101 </span>
 102         try {
<span class="line-modified"> 103             conContext.kickstart();</span>
<span class="line-modified"> 104         } catch (IOException ioe) {</span>
<span class="line-modified"> 105             throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-modified"> 106                 &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);</span>
<span class="line-modified"> 107         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 108             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 109                 &quot;Fail to begin handshake&quot;, ex);</span>









 110         }
 111     }
 112 
 113     @Override
<span class="line-modified"> 114     public synchronized SSLEngineResult wrap(ByteBuffer[] appData,</span>
 115             int offset, int length, ByteBuffer netData) throws SSLException {
 116         return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
 117     }
 118 
 119     // @Override
<span class="line-modified"> 120     public synchronized SSLEngineResult wrap(</span>
 121         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 122         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 123 
<span class="line-modified"> 124         if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 125             throw new IllegalStateException(</span>
<span class="line-modified"> 126                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified"> 127         }</span>


 128 
<span class="line-modified"> 129         // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 130         checkTaskThrown();</span>
 131 
<span class="line-modified"> 132         // check parameters</span>
<span class="line-modified"> 133         checkParams(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>

 134 
<span class="line-modified"> 135         try {</span>
<span class="line-modified"> 136             return writeRecord(</span>
<span class="line-modified"> 137                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 138         } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 139             // may be an unexpected handshake message</span>
<span class="line-modified"> 140             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);</span>
<span class="line-modified"> 141         } catch (IOException ioe) {</span>
<span class="line-modified"> 142             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 143                 &quot;problem wrapping app data&quot;, ioe);</span>
<span class="line-modified"> 144         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 145             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 146                 &quot;Fail to wrap application data&quot;, ex);</span>



 147         }
 148     }
 149 
 150     private SSLEngineResult writeRecord(
 151         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 152         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 153 
 154         // May need to deliver cached records.
 155         if (isOutboundDone()) {
 156             return new SSLEngineResult(
 157                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 158         }
 159 
 160         HandshakeContext hc = conContext.handshakeContext;
 161         HandshakeStatus hsStatus = null;
 162         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 163                 !conContext.isInboundClosed() &amp;&amp;
 164                 !conContext.isOutboundClosed()) {
 165             conContext.kickstart();
 166 
</pre>
<hr />
<pre>
 314             // be an issue for some applications.  This impact can be
 315             // mitigated by sending the last fligth twice.
 316             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 317                 SSLLogger.finest(&quot;retransmit the last flight messages&quot;);
 318             }
 319 
 320             conContext.outputRecord.launchRetransmission();
 321             hsStatus = HandshakeStatus.NEED_WRAP;
 322         }
 323 
 324         if (hsStatus == null) {
 325             hsStatus = conContext.getHandshakeStatus();
 326         }
 327 
 328         // Is the sequence number is nearly overflow?
 329         if (conContext.outputRecord.seqNumIsHuge() ||
 330                 conContext.outputRecord.writeCipher.atKeyLimit()) {
 331             hsStatus = tryKeyUpdate(hsStatus);
 332         }
 333 






 334         // update context status
 335         ciphertext.handshakeStatus = hsStatus;
 336 
 337         return ciphertext;
 338     }
 339 
 340     private HandshakeStatus tryToFinishHandshake(byte contentType) {
 341         HandshakeStatus hsStatus = null;
 342         if ((contentType == ContentType.HANDSHAKE.id) &amp;&amp;
 343                 conContext.outputRecord.isEmpty()) {
 344             if (conContext.handshakeContext == null) {
 345                 hsStatus = HandshakeStatus.FINISHED;
 346             } else if (conContext.isPostHandshakeContext()) {
 347                 // unlikely, but just in case.
 348                 hsStatus = conContext.finishPostHandshake();
 349             } else if (conContext.handshakeContext.handshakeFinished) {
 350                 hsStatus = conContext.finishHandshake();
 351             }
 352         }   // Otherwise, the followed call to getHSStatus() will help.
 353 
</pre>
<hr />
<pre>
 367      * wrapped.
 368      */
 369     private HandshakeStatus tryKeyUpdate(
 370             HandshakeStatus currentHandshakeStatus) throws IOException {
 371         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 372         // connection is not duplex-open.
 373         if ((conContext.handshakeContext == null) &amp;&amp;
 374                 !conContext.isOutboundClosed() &amp;&amp;
 375                 !conContext.isInboundClosed() &amp;&amp;
 376                 !conContext.isBroken) {
 377             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 378                 SSLLogger.finest(&quot;trigger key update&quot;);
 379             }
 380             beginHandshake();
 381             return conContext.getHandshakeStatus();
 382         }
 383 
 384         return currentHandshakeStatus;
 385     }
 386 























 387     private static void checkParams(
 388             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 389             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 390 
 391         if ((srcs == null) || (dsts == null)) {
 392             throw new IllegalArgumentException(
 393                     &quot;source or destination buffer is null&quot;);
 394         }
 395 
 396         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 397                 (dstsOffset &gt; dsts.length - dstsLength)) {
 398             throw new IndexOutOfBoundsException(
 399                     &quot;index out of bound of the destination buffers&quot;);
 400         }
 401 
 402         if ((srcsOffset &lt; 0) || (srcsLength &lt; 0) ||
 403                 (srcsOffset &gt; srcs.length - srcsLength)) {
 404             throw new IndexOutOfBoundsException(
 405                     &quot;index out of bound of the source buffers&quot;);
 406         }
</pre>
<hr />
<pre>
 411                         &quot;destination buffer[&quot; + i + &quot;] == null&quot;);
 412             }
 413 
 414             /*
 415              * Make sure the destination bufffers are writable.
 416              */
 417             if (dsts[i].isReadOnly()) {
 418                 throw new ReadOnlyBufferException();
 419             }
 420         }
 421 
 422         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 423             if (srcs[i] == null) {
 424                 throw new IllegalArgumentException(
 425                         &quot;source buffer[&quot; + i + &quot;] == null&quot;);
 426             }
 427         }
 428     }
 429 
 430     @Override
<span class="line-modified"> 431     public synchronized SSLEngineResult unwrap(ByteBuffer src,</span>
 432             ByteBuffer[] dsts, int offset, int length) throws SSLException {
 433         return unwrap(
 434                 new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
 435     }
 436 
 437     // @Override
<span class="line-modified"> 438     public synchronized SSLEngineResult unwrap(</span>
 439         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 440         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 441 
<span class="line-modified"> 442         if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 443             throw new IllegalStateException(</span>
<span class="line-modified"> 444                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified"> 445         }</span>


 446 
<span class="line-modified"> 447         // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 448         checkTaskThrown();</span>
 449 
<span class="line-modified"> 450         // check parameters</span>
<span class="line-modified"> 451         checkParams(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>

 452 
<span class="line-modified"> 453         try {</span>
<span class="line-modified"> 454             return readRecord(</span>
<span class="line-modified"> 455                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 456         } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 457             // may be an unexpected handshake message</span>
<span class="line-modified"> 458             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified"> 459                     spe.getMessage(), spe);</span>
<span class="line-modified"> 460         } catch (IOException ioe) {</span>
<span class="line-modified"> 461             /*</span>
<span class="line-modified"> 462              * Don&#39;t reset position so it looks like we didn&#39;t</span>
<span class="line-modified"> 463              * consume anything.  We did consume something, and it</span>
<span class="line-modified"> 464              * got us into this situation, so report that much back.</span>
<span class="line-modified"> 465              * Our days of consuming are now over anyway.</span>
<span class="line-modified"> 466              */</span>
<span class="line-modified"> 467             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 468                     &quot;problem unwrapping net record&quot;, ioe);</span>
<span class="line-modified"> 469         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 470             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 471                 &quot;Fail to unwrap network record&quot;, ex);</span>



 472         }
 473     }
 474 
 475     private SSLEngineResult readRecord(
 476         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 477         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 478 
 479         /*
 480          * Check if we are closing/closed.
 481          */
 482         if (isInboundDone()) {
 483             return new SSLEngineResult(
 484                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 485         }
 486 
 487         HandshakeStatus hsStatus = null;
 488         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 489                 !conContext.isInboundClosed() &amp;&amp;
 490                 !conContext.isOutboundClosed()) {
 491             conContext.kickstart();
</pre>
<hr />
<pre>
 686         if (pt != Plaintext.PLAINTEXT_NULL) {
 687             HandshakeStatus hsStatus = tryToFinishHandshake(pt.contentType);
 688             if (hsStatus == null) {
 689                 pt.handshakeStatus = conContext.getHandshakeStatus();
 690             } else {
 691                 pt.handshakeStatus = hsStatus;
 692             }
 693 
 694             // Is the sequence number is nearly overflow?
 695             if (conContext.inputRecord.seqNumIsHuge() ||
 696                     conContext.inputRecord.readCipher.atKeyLimit()) {
 697                 pt.handshakeStatus =
 698                         tryKeyUpdate(pt.handshakeStatus);
 699             }
 700         }
 701 
 702         return pt;
 703     }
 704 
 705     @Override
<span class="line-modified"> 706     public synchronized Runnable getDelegatedTask() {</span>
<span class="line-modified"> 707         if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake</span>
<span class="line-modified"> 708                 !conContext.handshakeContext.taskDelegated &amp;&amp;</span>
<span class="line-modified"> 709                 !conContext.handshakeContext.delegatedActions.isEmpty()) {</span>
<span class="line-modified"> 710             conContext.handshakeContext.taskDelegated = true;</span>
<span class="line-modified"> 711             return new DelegatedTask(this);</span>





 712         }
 713 
 714         return null;
 715     }
 716 
 717     @Override
<span class="line-modified"> 718     public synchronized void closeInbound() throws SSLException {</span>
<span class="line-modified"> 719         if (isInboundDone()) {</span>
<span class="line-modified"> 720             return;</span>
<span class="line-modified"> 721         }</span>


 722 
<span class="line-modified"> 723         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 724             SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);</span>
<span class="line-modified"> 725         }</span>
 726 
<span class="line-modified"> 727         // Is it ready to close inbound?</span>
<span class="line-modified"> 728         //</span>
<span class="line-modified"> 729         // No need to throw exception if the initial handshake is not started.</span>
<span class="line-modified"> 730         if (!conContext.isInputCloseNotified &amp;&amp;</span>
<span class="line-modified"> 731             (conContext.isNegotiated || conContext.handshakeContext != null)) {</span>

 732 
<span class="line-modified"> 733             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 734                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);</span>
<span class="line-modified"> 735         }</span>
 736 
<span class="line-modified"> 737         conContext.closeInbound();</span>



 738     }
 739 
 740     @Override
<span class="line-modified"> 741     public synchronized boolean isInboundDone() {</span>
<span class="line-modified"> 742         return conContext.isInboundClosed();</span>





 743     }
 744 
 745     @Override
<span class="line-modified"> 746     public synchronized void closeOutbound() {</span>
<span class="line-modified"> 747         if (conContext.isOutboundClosed()) {</span>
<span class="line-modified"> 748             return;</span>
<span class="line-modified"> 749         }</span>


 750 
<span class="line-modified"> 751         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 752             SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);</span>
<span class="line-modified"> 753         }</span>
 754 
<span class="line-modified"> 755         conContext.closeOutbound();</span>



 756     }
 757 
 758     @Override
<span class="line-modified"> 759     public synchronized boolean isOutboundDone() {</span>
<span class="line-modified"> 760         return conContext.isOutboundDone();</span>





 761     }
 762 
 763     @Override
 764     public String[] getSupportedCipherSuites() {
 765         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 766     }
 767 
 768     @Override
<span class="line-modified"> 769     public synchronized String[] getEnabledCipherSuites() {</span>
<span class="line-modified"> 770         return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>





 771     }
 772 
 773     @Override
<span class="line-modified"> 774     public synchronized void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified"> 775         conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-modified"> 776                 CipherSuite.validValuesOf(suites);</span>





 777     }
 778 
 779     @Override
 780     public String[] getSupportedProtocols() {
 781         return ProtocolVersion.toStringArray(
 782                 sslContext.getSupportedProtocolVersions());
 783     }
 784 
 785     @Override
<span class="line-modified"> 786     public synchronized String[] getEnabledProtocols() {</span>
<span class="line-modified"> 787         return ProtocolVersion.toStringArray(</span>
<span class="line-modified"> 788                 conContext.sslConfig.enabledProtocols);</span>





 789     }
 790 
 791     @Override
<span class="line-modified"> 792     public synchronized void setEnabledProtocols(String[] protocols) {</span>
<span class="line-modified"> 793         if (protocols == null) {</span>
<span class="line-modified"> 794             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);</span>
<span class="line-modified"> 795         }</span>


 796 
<span class="line-modified"> 797         conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified"> 798                 ProtocolVersion.namesOf(protocols);</span>



 799     }
 800 
 801     @Override
<span class="line-modified"> 802     public synchronized SSLSession getSession() {</span>
<span class="line-modified"> 803         return conContext.conSession;</span>





 804     }
 805 
 806     @Override
<span class="line-modified"> 807     public synchronized SSLSession getHandshakeSession() {</span>
<span class="line-modified"> 808         return conContext.handshakeContext == null ?</span>
<span class="line-modified"> 809                 null : conContext.handshakeContext.handshakeSession;</span>





 810     }
 811 
 812     @Override
<span class="line-modified"> 813     public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {</span>
<span class="line-modified"> 814         return conContext.getHandshakeStatus();</span>





 815     }
 816 
 817     @Override
<span class="line-modified"> 818     public synchronized void setUseClientMode(boolean mode) {</span>
<span class="line-modified"> 819         conContext.setUseClientMode(mode);</span>





 820     }
 821 
 822     @Override
<span class="line-modified"> 823     public synchronized boolean getUseClientMode() {</span>
<span class="line-modified"> 824         return conContext.sslConfig.isClientMode;</span>





 825     }
 826 
 827     @Override
<span class="line-modified"> 828     public synchronized void setNeedClientAuth(boolean need) {</span>
<span class="line-modified"> 829         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified"> 830                 (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-modified"> 831                         ClientAuthType.CLIENT_AUTH_NONE);</span>





 832     }
 833 
 834     @Override
<span class="line-modified"> 835     public synchronized boolean getNeedClientAuth() {</span>
<span class="line-modified"> 836         return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-modified"> 837                         ClientAuthType.CLIENT_AUTH_REQUIRED);</span>





 838     }
 839 
 840     @Override
<span class="line-modified"> 841     public synchronized void setWantClientAuth(boolean want) {</span>
<span class="line-modified"> 842         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified"> 843                 (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-modified"> 844                         ClientAuthType.CLIENT_AUTH_NONE);</span>





 845     }
 846 
 847     @Override
<span class="line-modified"> 848     public synchronized boolean getWantClientAuth() {</span>
<span class="line-modified"> 849         return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-modified"> 850                         ClientAuthType.CLIENT_AUTH_REQUESTED);</span>





 851     }
 852 
 853     @Override
<span class="line-modified"> 854     public synchronized void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified"> 855         conContext.sslConfig.enableSessionCreation = flag;</span>





 856     }
 857 
 858     @Override
<span class="line-modified"> 859     public synchronized boolean getEnableSessionCreation() {</span>
<span class="line-modified"> 860         return conContext.sslConfig.enableSessionCreation;</span>





 861     }
 862 
 863     @Override
<span class="line-modified"> 864     public synchronized SSLParameters getSSLParameters() {</span>
<span class="line-modified"> 865         return conContext.sslConfig.getSSLParameters();</span>
<span class="line-modified"> 866     }</span>





 867 
 868     @Override
<span class="line-modified"> 869     public synchronized void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified"> 870         conContext.sslConfig.setSSLParameters(params);</span>


 871 
<span class="line-modified"> 872         if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified"> 873             conContext.outputRecord.changePacketSize(</span>
<span class="line-modified"> 874                     conContext.sslConfig.maximumPacketSize);</span>



 875         }
<span class="line-modified"> 876     }</span>
 877 
 878     @Override
<span class="line-modified"> 879     public synchronized String getApplicationProtocol() {</span>
<span class="line-modified"> 880         return conContext.applicationProtocol;</span>





 881     }
 882 
 883     @Override
<span class="line-modified"> 884     public synchronized String getHandshakeApplicationProtocol() {</span>
<span class="line-modified"> 885         return conContext.handshakeContext == null ?</span>
<span class="line-modified"> 886                 null : conContext.handshakeContext.applicationProtocol;</span>





 887     }
 888 
 889     @Override
<span class="line-modified"> 890     public synchronized void setHandshakeApplicationProtocolSelector(</span>
 891             BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified"> 892         conContext.sslConfig.engineAPSelector = selector;</span>





 893     }
 894 
 895     @Override
<span class="line-modified"> 896     public synchronized BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;</span>
 897             getHandshakeApplicationProtocolSelector() {
<span class="line-modified"> 898         return conContext.sslConfig.engineAPSelector;</span>





 899     }
 900 
 901     @Override
 902     public boolean useDelegatedTask() {
 903         return true;
 904     }
 905 
 906     /*
 907      * Depending on whether the error was just a warning and the
 908      * handshaker wasn&#39;t closed, or fatal and the handshaker is now
 909      * null, report back the Exception that happened in the delegated
 910      * task(s).
 911      */
<span class="line-modified"> 912     private synchronized void checkTaskThrown() throws SSLException {</span>
 913 
 914         Exception exc = null;








 915 
<span class="line-modified"> 916         // First check the handshake context.</span>
<span class="line-modified"> 917         HandshakeContext hc = conContext.handshakeContext;</span>
<span class="line-modified"> 918         if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {</span>
<span class="line-modified"> 919             exc = hc.delegatedThrown;</span>
<span class="line-modified"> 920             hc.delegatedThrown = null;</span>
<span class="line-modified"> 921         }</span>
<span class="line-modified"> 922 </span>
<span class="line-modified"> 923         /*</span>
<span class="line-modified"> 924          * hc.delegatedThrown and conContext.delegatedThrown are most likely</span>
<span class="line-modified"> 925          * the same, but it&#39;s possible we could have had a non-fatal</span>
<span class="line-modified"> 926          * exception and thus the new HandshakeContext is still valid</span>
<span class="line-modified"> 927          * (alert warning).  If so, then we may have a secondary exception</span>
<span class="line-modified"> 928          * waiting to be reported from the TransportContext, so we will</span>
<span class="line-modified"> 929          * need to clear that on a successive call.  Otherwise, clear it now.</span>
<span class="line-modified"> 930          */</span>
<span class="line-modified"> 931         if (conContext.delegatedThrown != null) {</span>
<span class="line-modified"> 932             if (exc != null) {</span>
<span class="line-modified"> 933                 // hc object comparison</span>
<span class="line-modified"> 934                 if (conContext.delegatedThrown == exc) {</span>
<span class="line-removed"> 935                     // clear if/only if both are the same</span>
 936                     conContext.delegatedThrown = null;
<span class="line-modified"> 937                 } // otherwise report the hc delegatedThrown</span>
<span class="line-removed"> 938             } else {</span>
<span class="line-removed"> 939                 // Nothing waiting in HandshakeContext, but one is in the</span>
<span class="line-removed"> 940                 // TransportContext.</span>
<span class="line-removed"> 941                 exc = conContext.delegatedThrown;</span>
<span class="line-removed"> 942                 conContext.delegatedThrown = null;</span>
 943             }


 944         }
 945 
 946         // Anything to report?
 947         if (exc == null) {
 948             return;
 949         }
 950 
 951         // If it wasn&#39;t a RuntimeException/SSLException, need to wrap it.
 952         if (exc instanceof SSLException) {
 953             throw (SSLException)exc;
 954         } else if (exc instanceof RuntimeException) {
 955             throw (RuntimeException)exc;
 956         } else {
 957             throw getTaskThrown(exc);
 958         }
 959     }
 960 
 961     private static SSLException getTaskThrown(Exception taskThrown) {
 962         String msg = taskThrown.getMessage();
 963 
</pre>
<hr />
<pre>
 981                 new SSLProtocolException(msg).initCause(taskThrown);
 982         } else if (taskThrown instanceof SSLException) {
 983             return (SSLException)taskThrown;
 984         } else {
 985             return new SSLException(msg, taskThrown);
 986         }
 987     }
 988 
 989     /**
 990      * Implement a simple task delegator.
 991      */
 992     private static class DelegatedTask implements Runnable {
 993         private final SSLEngineImpl engine;
 994 
 995         DelegatedTask(SSLEngineImpl engineInstance) {
 996             this.engine = engineInstance;
 997         }
 998 
 999         @Override
1000         public void run() {
<span class="line-modified">1001             synchronized (engine) {</span>

1002                 HandshakeContext hc = engine.conContext.handshakeContext;
1003                 if (hc == null || hc.delegatedActions.isEmpty()) {
1004                     return;
1005                 }
1006 
1007                 try {
1008                     AccessController.doPrivileged(
1009                             new DelegatedAction(hc), engine.conContext.acc);
1010                 } catch (PrivilegedActionException pae) {
1011                     // Get the handshake context again in case the
1012                     // handshaking has completed.
1013                     Exception reportedException = pae.getException();
1014 
1015                     // Report to both the TransportContext...
1016                     if (engine.conContext.delegatedThrown == null) {
1017                         engine.conContext.delegatedThrown = reportedException;
1018                     }
1019 
1020                     // ...and the HandshakeContext in case condition
1021                     // wasn&#39;t fatal and the handshakeContext is still
</pre>
<hr />
<pre>
1038                     }
1039 
1040                     // ...and the HandshakeContext in case condition
1041                     // wasn&#39;t fatal and the handshakeContext is still
1042                     // around.
1043                     hc = engine.conContext.handshakeContext;
1044                     if (hc != null) {
1045                         hc.delegatedThrown = rte;
1046                     } else if (engine.conContext.closeReason != null) {
1047                         // Update the reason in case there was a previous.
1048                         engine.conContext.closeReason = rte;
1049                     }
1050                 }
1051 
1052                 // Get the handshake context again in case the
1053                 // handshaking has completed.
1054                 hc = engine.conContext.handshakeContext;
1055                 if (hc != null) {
1056                     hc.taskDelegated = false;
1057                 }


1058             }
1059         }
1060 
1061         private static class DelegatedAction
1062                 implements PrivilegedExceptionAction&lt;Void&gt; {
1063             final HandshakeContext context;
1064             DelegatedAction(HandshakeContext context) {
1065                 this.context = context;
1066             }
1067 
1068             @Override
1069             public Void run() throws Exception {
1070                 while (!context.delegatedActions.isEmpty()) {
1071                     Map.Entry&lt;Byte, ByteBuffer&gt; me =
1072                             context.delegatedActions.poll();
1073                     if (me != null) {
1074                         context.dispatch(me.getKey(), me.getValue());
1075                     }
1076                 }
1077                 return null;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.nio.ReadOnlyBufferException;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedActionException;
  33 import java.security.PrivilegedExceptionAction;
  34 import java.util.List;
  35 import java.util.Map;
<span class="line-added">  36 import java.util.concurrent.locks.ReentrantLock;</span>
  37 import java.util.function.BiFunction;
  38 import javax.net.ssl.SSLEngine;
  39 import javax.net.ssl.SSLEngineResult;
  40 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  41 import javax.net.ssl.SSLEngineResult.Status;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLKeyException;
  45 import javax.net.ssl.SSLParameters;
  46 import javax.net.ssl.SSLPeerUnverifiedException;
  47 import javax.net.ssl.SSLProtocolException;
  48 import javax.net.ssl.SSLSession;
  49 
  50 /**
  51  * Implementation of an non-blocking SSLEngine.
  52  *
  53  * @author Brad Wetmore
  54  */
  55 final class SSLEngineImpl extends SSLEngine implements SSLTransport {
  56     private final SSLContextImpl        sslContext;
  57     final TransportContext              conContext;
<span class="line-added">  58     private final ReentrantLock         engineLock = new ReentrantLock();</span>
  59 
  60     /**
  61      * Constructor for an SSLEngine from SSLContext, without
  62      * host/port hints.
  63      *
  64      * This Engine will not be able to cache sessions, but must renegotiate
  65      * everything by hand.
  66      */
  67     SSLEngineImpl(SSLContextImpl sslContext) {
  68         this(sslContext, null, -1);
  69     }
  70 
  71     /**
  72      * Constructor for an SSLEngine from SSLContext.
  73      */
  74     SSLEngineImpl(SSLContextImpl sslContext,
  75             String host, int port) {
  76         super(host, port);
  77         this.sslContext = sslContext;
  78         HandshakeHash handshakeHash = new HandshakeHash();
  79         if (sslContext.isDTLS()) {
  80             this.conContext = new TransportContext(sslContext, this,
  81                     new DTLSInputRecord(handshakeHash),
  82                     new DTLSOutputRecord(handshakeHash));
  83         } else {
  84             this.conContext = new TransportContext(sslContext, this,
  85                     new SSLEngineInputRecord(handshakeHash),
  86                     new SSLEngineOutputRecord(handshakeHash));
  87         }
  88 
  89         // Server name indication is a connection scope extension.
  90         if (host != null) {
  91             this.conContext.sslConfig.serverNames =
  92                     Utilities.addToSNIServerNameList(
  93                             conContext.sslConfig.serverNames, host);
  94         }
  95     }
  96 
  97     @Override
<span class="line-modified">  98     public void beginHandshake() throws SSLException {</span>
<span class="line-modified">  99         engineLock.lock();</span>




 100         try {
<span class="line-modified"> 101             if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 102                 throw new IllegalStateException(</span>
<span class="line-modified"> 103                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified"> 104             }</span>
<span class="line-modified"> 105 </span>
<span class="line-modified"> 106             try {</span>
<span class="line-modified"> 107                 conContext.kickstart();</span>
<span class="line-added"> 108             } catch (IOException ioe) {</span>
<span class="line-added"> 109                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added"> 110                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);</span>
<span class="line-added"> 111             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-added"> 112                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-added"> 113                     &quot;Fail to begin handshake&quot;, ex);</span>
<span class="line-added"> 114             }</span>
<span class="line-added"> 115         } finally {</span>
<span class="line-added"> 116             engineLock.unlock();</span>
 117         }
 118     }
 119 
 120     @Override
<span class="line-modified"> 121     public SSLEngineResult wrap(ByteBuffer[] appData,</span>
 122             int offset, int length, ByteBuffer netData) throws SSLException {
 123         return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
 124     }
 125 
 126     // @Override
<span class="line-modified"> 127     public SSLEngineResult wrap(</span>
 128         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 129         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 130 
<span class="line-modified"> 131         engineLock.lock();</span>
<span class="line-modified"> 132         try {</span>
<span class="line-modified"> 133             if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 134                 throw new IllegalStateException(</span>
<span class="line-added"> 135                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-added"> 136             }</span>
 137 
<span class="line-modified"> 138             // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 139             checkTaskThrown();</span>
 140 
<span class="line-modified"> 141             // check parameters</span>
<span class="line-modified"> 142             checkParams(srcs, srcsOffset, srcsLength,</span>
<span class="line-added"> 143                     dsts, dstsOffset, dstsLength);</span>
 144 
<span class="line-modified"> 145             try {</span>
<span class="line-modified"> 146                 return writeRecord(</span>
<span class="line-modified"> 147                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 148             } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 149                 // may be an unexpected handshake message</span>
<span class="line-modified"> 150                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);</span>
<span class="line-modified"> 151             } catch (IOException ioe) {</span>
<span class="line-modified"> 152                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 153                     &quot;problem wrapping app data&quot;, ioe);</span>
<span class="line-modified"> 154             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 155                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 156                     &quot;Fail to wrap application data&quot;, ex);</span>
<span class="line-added"> 157             }</span>
<span class="line-added"> 158         } finally {</span>
<span class="line-added"> 159             engineLock.unlock();</span>
 160         }
 161     }
 162 
 163     private SSLEngineResult writeRecord(
 164         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 165         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 166 
 167         // May need to deliver cached records.
 168         if (isOutboundDone()) {
 169             return new SSLEngineResult(
 170                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 171         }
 172 
 173         HandshakeContext hc = conContext.handshakeContext;
 174         HandshakeStatus hsStatus = null;
 175         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 176                 !conContext.isInboundClosed() &amp;&amp;
 177                 !conContext.isOutboundClosed()) {
 178             conContext.kickstart();
 179 
</pre>
<hr />
<pre>
 327             // be an issue for some applications.  This impact can be
 328             // mitigated by sending the last fligth twice.
 329             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 330                 SSLLogger.finest(&quot;retransmit the last flight messages&quot;);
 331             }
 332 
 333             conContext.outputRecord.launchRetransmission();
 334             hsStatus = HandshakeStatus.NEED_WRAP;
 335         }
 336 
 337         if (hsStatus == null) {
 338             hsStatus = conContext.getHandshakeStatus();
 339         }
 340 
 341         // Is the sequence number is nearly overflow?
 342         if (conContext.outputRecord.seqNumIsHuge() ||
 343                 conContext.outputRecord.writeCipher.atKeyLimit()) {
 344             hsStatus = tryKeyUpdate(hsStatus);
 345         }
 346 
<span class="line-added"> 347         // Check if NewSessionTicket PostHandshake message needs to be sent</span>
<span class="line-added"> 348         if (conContext.conSession.updateNST &amp;&amp;</span>
<span class="line-added"> 349                 !conContext.sslConfig.isClientMode) {</span>
<span class="line-added"> 350             hsStatus = tryNewSessionTicket(hsStatus);</span>
<span class="line-added"> 351         }</span>
<span class="line-added"> 352 </span>
 353         // update context status
 354         ciphertext.handshakeStatus = hsStatus;
 355 
 356         return ciphertext;
 357     }
 358 
 359     private HandshakeStatus tryToFinishHandshake(byte contentType) {
 360         HandshakeStatus hsStatus = null;
 361         if ((contentType == ContentType.HANDSHAKE.id) &amp;&amp;
 362                 conContext.outputRecord.isEmpty()) {
 363             if (conContext.handshakeContext == null) {
 364                 hsStatus = HandshakeStatus.FINISHED;
 365             } else if (conContext.isPostHandshakeContext()) {
 366                 // unlikely, but just in case.
 367                 hsStatus = conContext.finishPostHandshake();
 368             } else if (conContext.handshakeContext.handshakeFinished) {
 369                 hsStatus = conContext.finishHandshake();
 370             }
 371         }   // Otherwise, the followed call to getHSStatus() will help.
 372 
</pre>
<hr />
<pre>
 386      * wrapped.
 387      */
 388     private HandshakeStatus tryKeyUpdate(
 389             HandshakeStatus currentHandshakeStatus) throws IOException {
 390         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 391         // connection is not duplex-open.
 392         if ((conContext.handshakeContext == null) &amp;&amp;
 393                 !conContext.isOutboundClosed() &amp;&amp;
 394                 !conContext.isInboundClosed() &amp;&amp;
 395                 !conContext.isBroken) {
 396             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 397                 SSLLogger.finest(&quot;trigger key update&quot;);
 398             }
 399             beginHandshake();
 400             return conContext.getHandshakeStatus();
 401         }
 402 
 403         return currentHandshakeStatus;
 404     }
 405 
<span class="line-added"> 406     // Try to generate a PostHandshake NewSessionTicket message.  This is</span>
<span class="line-added"> 407     // TLS 1.3 only.</span>
<span class="line-added"> 408     private HandshakeStatus tryNewSessionTicket(</span>
<span class="line-added"> 409             HandshakeStatus currentHandshakeStatus) throws IOException {</span>
<span class="line-added"> 410         // Don&#39;t bother to kickstart if handshaking is in progress, or if the</span>
<span class="line-added"> 411         // connection is not duplex-open.</span>
<span class="line-added"> 412         if ((conContext.handshakeContext == null) &amp;&amp;</span>
<span class="line-added"> 413                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added"> 414                 !conContext.isOutboundClosed() &amp;&amp;</span>
<span class="line-added"> 415                 !conContext.isInboundClosed() &amp;&amp;</span>
<span class="line-added"> 416                 !conContext.isBroken) {</span>
<span class="line-added"> 417             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added"> 418                 SSLLogger.finest(&quot;trigger NST&quot;);</span>
<span class="line-added"> 419             }</span>
<span class="line-added"> 420             conContext.conSession.updateNST = false;</span>
<span class="line-added"> 421             NewSessionTicket.kickstartProducer.produce(</span>
<span class="line-added"> 422                     new PostHandshakeContext(conContext));</span>
<span class="line-added"> 423             return conContext.getHandshakeStatus();</span>
<span class="line-added"> 424         }</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426         return currentHandshakeStatus;</span>
<span class="line-added"> 427     }</span>
<span class="line-added"> 428 </span>
 429     private static void checkParams(
 430             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 431             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 432 
 433         if ((srcs == null) || (dsts == null)) {
 434             throw new IllegalArgumentException(
 435                     &quot;source or destination buffer is null&quot;);
 436         }
 437 
 438         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 439                 (dstsOffset &gt; dsts.length - dstsLength)) {
 440             throw new IndexOutOfBoundsException(
 441                     &quot;index out of bound of the destination buffers&quot;);
 442         }
 443 
 444         if ((srcsOffset &lt; 0) || (srcsLength &lt; 0) ||
 445                 (srcsOffset &gt; srcs.length - srcsLength)) {
 446             throw new IndexOutOfBoundsException(
 447                     &quot;index out of bound of the source buffers&quot;);
 448         }
</pre>
<hr />
<pre>
 453                         &quot;destination buffer[&quot; + i + &quot;] == null&quot;);
 454             }
 455 
 456             /*
 457              * Make sure the destination bufffers are writable.
 458              */
 459             if (dsts[i].isReadOnly()) {
 460                 throw new ReadOnlyBufferException();
 461             }
 462         }
 463 
 464         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 465             if (srcs[i] == null) {
 466                 throw new IllegalArgumentException(
 467                         &quot;source buffer[&quot; + i + &quot;] == null&quot;);
 468             }
 469         }
 470     }
 471 
 472     @Override
<span class="line-modified"> 473     public SSLEngineResult unwrap(ByteBuffer src,</span>
 474             ByteBuffer[] dsts, int offset, int length) throws SSLException {
 475         return unwrap(
 476                 new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
 477     }
 478 
 479     // @Override
<span class="line-modified"> 480     public SSLEngineResult unwrap(</span>
 481         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 482         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 483 
<span class="line-modified"> 484         engineLock.lock();</span>
<span class="line-modified"> 485         try {</span>
<span class="line-modified"> 486             if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 487                 throw new IllegalStateException(</span>
<span class="line-added"> 488                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-added"> 489             }</span>
 490 
<span class="line-modified"> 491             // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 492             checkTaskThrown();</span>
 493 
<span class="line-modified"> 494             // check parameters</span>
<span class="line-modified"> 495             checkParams(srcs, srcsOffset, srcsLength,</span>
<span class="line-added"> 496                     dsts, dstsOffset, dstsLength);</span>
 497 
<span class="line-modified"> 498             try {</span>
<span class="line-modified"> 499                 return readRecord(</span>
<span class="line-modified"> 500                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 501             } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 502                 // may be an unexpected handshake message</span>
<span class="line-modified"> 503                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified"> 504                         spe.getMessage(), spe);</span>
<span class="line-modified"> 505             } catch (IOException ioe) {</span>
<span class="line-modified"> 506                 /*</span>
<span class="line-modified"> 507                  * Don&#39;t reset position so it looks like we didn&#39;t</span>
<span class="line-modified"> 508                  * consume anything.  We did consume something, and it</span>
<span class="line-modified"> 509                  * got us into this situation, so report that much back.</span>
<span class="line-modified"> 510                  * Our days of consuming are now over anyway.</span>
<span class="line-modified"> 511                  */</span>
<span class="line-modified"> 512                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 513                         &quot;problem unwrapping net record&quot;, ioe);</span>
<span class="line-modified"> 514             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 515                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 516                     &quot;Fail to unwrap network record&quot;, ex);</span>
<span class="line-added"> 517             }</span>
<span class="line-added"> 518         } finally {</span>
<span class="line-added"> 519             engineLock.unlock();</span>
 520         }
 521     }
 522 
 523     private SSLEngineResult readRecord(
 524         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 525         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 526 
 527         /*
 528          * Check if we are closing/closed.
 529          */
 530         if (isInboundDone()) {
 531             return new SSLEngineResult(
 532                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 533         }
 534 
 535         HandshakeStatus hsStatus = null;
 536         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 537                 !conContext.isInboundClosed() &amp;&amp;
 538                 !conContext.isOutboundClosed()) {
 539             conContext.kickstart();
</pre>
<hr />
<pre>
 734         if (pt != Plaintext.PLAINTEXT_NULL) {
 735             HandshakeStatus hsStatus = tryToFinishHandshake(pt.contentType);
 736             if (hsStatus == null) {
 737                 pt.handshakeStatus = conContext.getHandshakeStatus();
 738             } else {
 739                 pt.handshakeStatus = hsStatus;
 740             }
 741 
 742             // Is the sequence number is nearly overflow?
 743             if (conContext.inputRecord.seqNumIsHuge() ||
 744                     conContext.inputRecord.readCipher.atKeyLimit()) {
 745                 pt.handshakeStatus =
 746                         tryKeyUpdate(pt.handshakeStatus);
 747             }
 748         }
 749 
 750         return pt;
 751     }
 752 
 753     @Override
<span class="line-modified"> 754     public Runnable getDelegatedTask() {</span>
<span class="line-modified"> 755         engineLock.lock();</span>
<span class="line-modified"> 756         try {</span>
<span class="line-modified"> 757             if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake</span>
<span class="line-modified"> 758                     !conContext.handshakeContext.taskDelegated &amp;&amp;</span>
<span class="line-modified"> 759                     !conContext.handshakeContext.delegatedActions.isEmpty()) {</span>
<span class="line-added"> 760                 conContext.handshakeContext.taskDelegated = true;</span>
<span class="line-added"> 761                 return new DelegatedTask(this);</span>
<span class="line-added"> 762             }</span>
<span class="line-added"> 763         } finally {</span>
<span class="line-added"> 764             engineLock.unlock();</span>
 765         }
 766 
 767         return null;
 768     }
 769 
 770     @Override
<span class="line-modified"> 771     public void closeInbound() throws SSLException {</span>
<span class="line-modified"> 772         engineLock.lock();</span>
<span class="line-modified"> 773         try {</span>
<span class="line-modified"> 774             if (isInboundDone()) {</span>
<span class="line-added"> 775                 return;</span>
<span class="line-added"> 776             }</span>
 777 
<span class="line-modified"> 778             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 779                 SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);</span>
<span class="line-modified"> 780             }</span>
 781 
<span class="line-modified"> 782             // Is it ready to close inbound?</span>
<span class="line-modified"> 783             //</span>
<span class="line-modified"> 784             // No exception if the initial handshake is not started.</span>
<span class="line-modified"> 785             if (!conContext.isInputCloseNotified &amp;&amp;</span>
<span class="line-modified"> 786                 (conContext.isNegotiated ||</span>
<span class="line-added"> 787                     conContext.handshakeContext != null)) {</span>
 788 
<span class="line-modified"> 789                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 790                         &quot;closing inbound before receiving peer&#39;s close_notify&quot;);</span>
<span class="line-modified"> 791             }</span>
 792 
<span class="line-modified"> 793             conContext.closeInbound();</span>
<span class="line-added"> 794         } finally {</span>
<span class="line-added"> 795             engineLock.unlock();</span>
<span class="line-added"> 796         }</span>
 797     }
 798 
 799     @Override
<span class="line-modified"> 800     public boolean isInboundDone() {</span>
<span class="line-modified"> 801         engineLock.lock();</span>
<span class="line-added"> 802         try {</span>
<span class="line-added"> 803             return conContext.isInboundClosed();</span>
<span class="line-added"> 804         } finally {</span>
<span class="line-added"> 805             engineLock.unlock();</span>
<span class="line-added"> 806         }</span>
 807     }
 808 
 809     @Override
<span class="line-modified"> 810     public void closeOutbound() {</span>
<span class="line-modified"> 811         engineLock.lock();</span>
<span class="line-modified"> 812         try {</span>
<span class="line-modified"> 813             if (conContext.isOutboundClosed()) {</span>
<span class="line-added"> 814                 return;</span>
<span class="line-added"> 815             }</span>
 816 
<span class="line-modified"> 817             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 818                 SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);</span>
<span class="line-modified"> 819             }</span>
 820 
<span class="line-modified"> 821             conContext.closeOutbound();</span>
<span class="line-added"> 822         } finally {</span>
<span class="line-added"> 823             engineLock.unlock();</span>
<span class="line-added"> 824         }</span>
 825     }
 826 
 827     @Override
<span class="line-modified"> 828     public boolean isOutboundDone() {</span>
<span class="line-modified"> 829         engineLock.lock();</span>
<span class="line-added"> 830         try {</span>
<span class="line-added"> 831             return conContext.isOutboundDone();</span>
<span class="line-added"> 832         } finally {</span>
<span class="line-added"> 833             engineLock.unlock();</span>
<span class="line-added"> 834         }</span>
 835     }
 836 
 837     @Override
 838     public String[] getSupportedCipherSuites() {
 839         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 840     }
 841 
 842     @Override
<span class="line-modified"> 843     public String[] getEnabledCipherSuites() {</span>
<span class="line-modified"> 844         engineLock.lock();</span>
<span class="line-added"> 845         try {</span>
<span class="line-added"> 846             return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>
<span class="line-added"> 847         } finally {</span>
<span class="line-added"> 848             engineLock.unlock();</span>
<span class="line-added"> 849         }</span>
 850     }
 851 
 852     @Override
<span class="line-modified"> 853     public void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified"> 854         engineLock.lock();</span>
<span class="line-modified"> 855         try {</span>
<span class="line-added"> 856             conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-added"> 857                     CipherSuite.validValuesOf(suites);</span>
<span class="line-added"> 858         } finally {</span>
<span class="line-added"> 859             engineLock.unlock();</span>
<span class="line-added"> 860         }</span>
 861     }
 862 
 863     @Override
 864     public String[] getSupportedProtocols() {
 865         return ProtocolVersion.toStringArray(
 866                 sslContext.getSupportedProtocolVersions());
 867     }
 868 
 869     @Override
<span class="line-modified"> 870     public String[] getEnabledProtocols() {</span>
<span class="line-modified"> 871         engineLock.lock();</span>
<span class="line-modified"> 872         try {</span>
<span class="line-added"> 873             return ProtocolVersion.toStringArray(</span>
<span class="line-added"> 874                     conContext.sslConfig.enabledProtocols);</span>
<span class="line-added"> 875         } finally {</span>
<span class="line-added"> 876             engineLock.unlock();</span>
<span class="line-added"> 877         }</span>
 878     }
 879 
 880     @Override
<span class="line-modified"> 881     public void setEnabledProtocols(String[] protocols) {</span>
<span class="line-modified"> 882         engineLock.lock();</span>
<span class="line-modified"> 883         try {</span>
<span class="line-modified"> 884             if (protocols == null) {</span>
<span class="line-added"> 885                 throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);</span>
<span class="line-added"> 886             }</span>
 887 
<span class="line-modified"> 888             conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified"> 889                     ProtocolVersion.namesOf(protocols);</span>
<span class="line-added"> 890         } finally {</span>
<span class="line-added"> 891             engineLock.unlock();</span>
<span class="line-added"> 892         }</span>
 893     }
 894 
 895     @Override
<span class="line-modified"> 896     public SSLSession getSession() {</span>
<span class="line-modified"> 897         engineLock.lock();</span>
<span class="line-added"> 898         try {</span>
<span class="line-added"> 899             return conContext.conSession;</span>
<span class="line-added"> 900         } finally {</span>
<span class="line-added"> 901             engineLock.unlock();</span>
<span class="line-added"> 902         }</span>
 903     }
 904 
 905     @Override
<span class="line-modified"> 906     public SSLSession getHandshakeSession() {</span>
<span class="line-modified"> 907         engineLock.lock();</span>
<span class="line-modified"> 908         try {</span>
<span class="line-added"> 909             return conContext.handshakeContext == null ?</span>
<span class="line-added"> 910                     null : conContext.handshakeContext.handshakeSession;</span>
<span class="line-added"> 911         } finally {</span>
<span class="line-added"> 912             engineLock.unlock();</span>
<span class="line-added"> 913         }</span>
 914     }
 915 
 916     @Override
<span class="line-modified"> 917     public SSLEngineResult.HandshakeStatus getHandshakeStatus() {</span>
<span class="line-modified"> 918         engineLock.lock();</span>
<span class="line-added"> 919         try {</span>
<span class="line-added"> 920             return conContext.getHandshakeStatus();</span>
<span class="line-added"> 921         } finally {</span>
<span class="line-added"> 922             engineLock.unlock();</span>
<span class="line-added"> 923         }</span>
 924     }
 925 
 926     @Override
<span class="line-modified"> 927     public void setUseClientMode(boolean mode) {</span>
<span class="line-modified"> 928         engineLock.lock();</span>
<span class="line-added"> 929         try {</span>
<span class="line-added"> 930             conContext.setUseClientMode(mode);</span>
<span class="line-added"> 931         } finally {</span>
<span class="line-added"> 932             engineLock.unlock();</span>
<span class="line-added"> 933         }</span>
 934     }
 935 
 936     @Override
<span class="line-modified"> 937     public boolean getUseClientMode() {</span>
<span class="line-modified"> 938         engineLock.lock();</span>
<span class="line-added"> 939         try {</span>
<span class="line-added"> 940             return conContext.sslConfig.isClientMode;</span>
<span class="line-added"> 941         } finally {</span>
<span class="line-added"> 942             engineLock.unlock();</span>
<span class="line-added"> 943         }</span>
 944     }
 945 
 946     @Override
<span class="line-modified"> 947     public void setNeedClientAuth(boolean need) {</span>
<span class="line-modified"> 948         engineLock.lock();</span>
<span class="line-modified"> 949         try {</span>
<span class="line-modified"> 950             conContext.sslConfig.clientAuthType =</span>
<span class="line-added"> 951                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-added"> 952                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added"> 953         } finally {</span>
<span class="line-added"> 954             engineLock.unlock();</span>
<span class="line-added"> 955         }</span>
 956     }
 957 
 958     @Override
<span class="line-modified"> 959     public boolean getNeedClientAuth() {</span>
<span class="line-modified"> 960         engineLock.lock();</span>
<span class="line-modified"> 961         try {</span>
<span class="line-added"> 962             return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-added"> 963                             ClientAuthType.CLIENT_AUTH_REQUIRED);</span>
<span class="line-added"> 964         } finally {</span>
<span class="line-added"> 965             engineLock.unlock();</span>
<span class="line-added"> 966         }</span>
 967     }
 968 
 969     @Override
<span class="line-modified"> 970     public void setWantClientAuth(boolean want) {</span>
<span class="line-modified"> 971         engineLock.lock();</span>
<span class="line-modified"> 972         try {</span>
<span class="line-modified"> 973             conContext.sslConfig.clientAuthType =</span>
<span class="line-added"> 974                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-added"> 975                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added"> 976         } finally {</span>
<span class="line-added"> 977             engineLock.unlock();</span>
<span class="line-added"> 978         }</span>
 979     }
 980 
 981     @Override
<span class="line-modified"> 982     public boolean getWantClientAuth() {</span>
<span class="line-modified"> 983         engineLock.lock();</span>
<span class="line-modified"> 984         try {</span>
<span class="line-added"> 985             return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-added"> 986                             ClientAuthType.CLIENT_AUTH_REQUESTED);</span>
<span class="line-added"> 987         } finally {</span>
<span class="line-added"> 988             engineLock.unlock();</span>
<span class="line-added"> 989         }</span>
 990     }
 991 
 992     @Override
<span class="line-modified"> 993     public void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified"> 994         engineLock.lock();</span>
<span class="line-added"> 995         try {</span>
<span class="line-added"> 996             conContext.sslConfig.enableSessionCreation = flag;</span>
<span class="line-added"> 997         } finally {</span>
<span class="line-added"> 998             engineLock.unlock();</span>
<span class="line-added"> 999         }</span>
1000     }
1001 
1002     @Override
<span class="line-modified">1003     public boolean getEnableSessionCreation() {</span>
<span class="line-modified">1004         engineLock.lock();</span>
<span class="line-added">1005         try {</span>
<span class="line-added">1006             return conContext.sslConfig.enableSessionCreation;</span>
<span class="line-added">1007         } finally {</span>
<span class="line-added">1008             engineLock.unlock();</span>
<span class="line-added">1009         }</span>
1010     }
1011 
1012     @Override
<span class="line-modified">1013     public SSLParameters getSSLParameters() {</span>
<span class="line-modified">1014         engineLock.lock();</span>
<span class="line-modified">1015         try {</span>
<span class="line-added">1016             return conContext.sslConfig.getSSLParameters();</span>
<span class="line-added">1017         } finally {</span>
<span class="line-added">1018             engineLock.unlock();</span>
<span class="line-added">1019         }</span>
<span class="line-added">1020    }</span>
1021 
1022     @Override
<span class="line-modified">1023     public void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">1024         engineLock.lock();</span>
<span class="line-added">1025         try {</span>
<span class="line-added">1026             conContext.sslConfig.setSSLParameters(params);</span>
1027 
<span class="line-modified">1028             if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">1029                 conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">1030                         conContext.sslConfig.maximumPacketSize);</span>
<span class="line-added">1031             }</span>
<span class="line-added">1032         } finally {</span>
<span class="line-added">1033             engineLock.unlock();</span>
1034         }
<span class="line-modified">1035    }</span>
1036 
1037     @Override
<span class="line-modified">1038     public String getApplicationProtocol() {</span>
<span class="line-modified">1039         engineLock.lock();</span>
<span class="line-added">1040         try {</span>
<span class="line-added">1041             return conContext.applicationProtocol;</span>
<span class="line-added">1042         } finally {</span>
<span class="line-added">1043             engineLock.unlock();</span>
<span class="line-added">1044         }</span>
1045     }
1046 
1047     @Override
<span class="line-modified">1048     public String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">1049         engineLock.lock();</span>
<span class="line-modified">1050         try {</span>
<span class="line-added">1051             return conContext.handshakeContext == null ?</span>
<span class="line-added">1052                     null : conContext.handshakeContext.applicationProtocol;</span>
<span class="line-added">1053         } finally {</span>
<span class="line-added">1054             engineLock.unlock();</span>
<span class="line-added">1055         }</span>
1056     }
1057 
1058     @Override
<span class="line-modified">1059     public void setHandshakeApplicationProtocolSelector(</span>
1060             BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">1061         engineLock.lock();</span>
<span class="line-added">1062         try {</span>
<span class="line-added">1063             conContext.sslConfig.engineAPSelector = selector;</span>
<span class="line-added">1064         } finally {</span>
<span class="line-added">1065             engineLock.unlock();</span>
<span class="line-added">1066         }</span>
1067     }
1068 
1069     @Override
<span class="line-modified">1070     public BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;</span>
1071             getHandshakeApplicationProtocolSelector() {
<span class="line-modified">1072         engineLock.lock();</span>
<span class="line-added">1073         try {</span>
<span class="line-added">1074             return conContext.sslConfig.engineAPSelector;</span>
<span class="line-added">1075         } finally {</span>
<span class="line-added">1076             engineLock.unlock();</span>
<span class="line-added">1077         }</span>
1078     }
1079 
1080     @Override
1081     public boolean useDelegatedTask() {
1082         return true;
1083     }
1084 
1085     /*
1086      * Depending on whether the error was just a warning and the
1087      * handshaker wasn&#39;t closed, or fatal and the handshaker is now
1088      * null, report back the Exception that happened in the delegated
1089      * task(s).
1090      */
<span class="line-modified">1091     private void checkTaskThrown() throws SSLException {</span>
1092 
1093         Exception exc = null;
<span class="line-added">1094         engineLock.lock();</span>
<span class="line-added">1095         try {</span>
<span class="line-added">1096             // First check the handshake context.</span>
<span class="line-added">1097             HandshakeContext hc = conContext.handshakeContext;</span>
<span class="line-added">1098             if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {</span>
<span class="line-added">1099                 exc = hc.delegatedThrown;</span>
<span class="line-added">1100                 hc.delegatedThrown = null;</span>
<span class="line-added">1101             }</span>
1102 
<span class="line-modified">1103             /*</span>
<span class="line-modified">1104              * hc.delegatedThrown and conContext.delegatedThrown are most</span>
<span class="line-modified">1105              * likely the same, but it&#39;s possible we could have had a non-fatal</span>
<span class="line-modified">1106              * exception and thus the new HandshakeContext is still valid</span>
<span class="line-modified">1107              * (alert warning).  If so, then we may have a secondary exception</span>
<span class="line-modified">1108              * waiting to be reported from the TransportContext, so we will</span>
<span class="line-modified">1109              * need to clear that on a successive call. Otherwise, clear it now.</span>
<span class="line-modified">1110              */</span>
<span class="line-modified">1111             if (conContext.delegatedThrown != null) {</span>
<span class="line-modified">1112                 if (exc != null) {</span>
<span class="line-modified">1113                     // hc object comparison</span>
<span class="line-modified">1114                     if (conContext.delegatedThrown == exc) {</span>
<span class="line-modified">1115                         // clear if/only if both are the same</span>
<span class="line-modified">1116                         conContext.delegatedThrown = null;</span>
<span class="line-modified">1117                     } // otherwise report the hc delegatedThrown</span>
<span class="line-modified">1118                 } else {</span>
<span class="line-modified">1119                     // Nothing waiting in HandshakeContext, but one is in the</span>
<span class="line-modified">1120                     // TransportContext.</span>
<span class="line-modified">1121                     exc = conContext.delegatedThrown;</span>

1122                     conContext.delegatedThrown = null;
<span class="line-modified">1123                 }</span>





1124             }
<span class="line-added">1125         } finally {</span>
<span class="line-added">1126             engineLock.unlock();</span>
1127         }
1128 
1129         // Anything to report?
1130         if (exc == null) {
1131             return;
1132         }
1133 
1134         // If it wasn&#39;t a RuntimeException/SSLException, need to wrap it.
1135         if (exc instanceof SSLException) {
1136             throw (SSLException)exc;
1137         } else if (exc instanceof RuntimeException) {
1138             throw (RuntimeException)exc;
1139         } else {
1140             throw getTaskThrown(exc);
1141         }
1142     }
1143 
1144     private static SSLException getTaskThrown(Exception taskThrown) {
1145         String msg = taskThrown.getMessage();
1146 
</pre>
<hr />
<pre>
1164                 new SSLProtocolException(msg).initCause(taskThrown);
1165         } else if (taskThrown instanceof SSLException) {
1166             return (SSLException)taskThrown;
1167         } else {
1168             return new SSLException(msg, taskThrown);
1169         }
1170     }
1171 
1172     /**
1173      * Implement a simple task delegator.
1174      */
1175     private static class DelegatedTask implements Runnable {
1176         private final SSLEngineImpl engine;
1177 
1178         DelegatedTask(SSLEngineImpl engineInstance) {
1179             this.engine = engineInstance;
1180         }
1181 
1182         @Override
1183         public void run() {
<span class="line-modified">1184             engine.engineLock.lock();</span>
<span class="line-added">1185             try {</span>
1186                 HandshakeContext hc = engine.conContext.handshakeContext;
1187                 if (hc == null || hc.delegatedActions.isEmpty()) {
1188                     return;
1189                 }
1190 
1191                 try {
1192                     AccessController.doPrivileged(
1193                             new DelegatedAction(hc), engine.conContext.acc);
1194                 } catch (PrivilegedActionException pae) {
1195                     // Get the handshake context again in case the
1196                     // handshaking has completed.
1197                     Exception reportedException = pae.getException();
1198 
1199                     // Report to both the TransportContext...
1200                     if (engine.conContext.delegatedThrown == null) {
1201                         engine.conContext.delegatedThrown = reportedException;
1202                     }
1203 
1204                     // ...and the HandshakeContext in case condition
1205                     // wasn&#39;t fatal and the handshakeContext is still
</pre>
<hr />
<pre>
1222                     }
1223 
1224                     // ...and the HandshakeContext in case condition
1225                     // wasn&#39;t fatal and the handshakeContext is still
1226                     // around.
1227                     hc = engine.conContext.handshakeContext;
1228                     if (hc != null) {
1229                         hc.delegatedThrown = rte;
1230                     } else if (engine.conContext.closeReason != null) {
1231                         // Update the reason in case there was a previous.
1232                         engine.conContext.closeReason = rte;
1233                     }
1234                 }
1235 
1236                 // Get the handshake context again in case the
1237                 // handshaking has completed.
1238                 hc = engine.conContext.handshakeContext;
1239                 if (hc != null) {
1240                     hc.taskDelegated = false;
1241                 }
<span class="line-added">1242             } finally {</span>
<span class="line-added">1243                 engine.engineLock.unlock();</span>
1244             }
1245         }
1246 
1247         private static class DelegatedAction
1248                 implements PrivilegedExceptionAction&lt;Void&gt; {
1249             final HandshakeContext context;
1250             DelegatedAction(HandshakeContext context) {
1251                 this.context = context;
1252             }
1253 
1254             @Override
1255             public Void run() throws Exception {
1256                 while (!context.delegatedActions.isEmpty()) {
1257                     Map.Entry&lt;Byte, ByteBuffer&gt; me =
1258                             context.delegatedActions.poll();
1259                     if (me != null) {
1260                         context.dispatch(me.getKey(), me.getValue());
1261                     }
1262                 }
1263                 return null;
</pre>
</td>
</tr>
</table>
<center><a href="SSLContextImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineInputRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
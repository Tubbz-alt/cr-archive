<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/Finished.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.GeneralSecurityException;
  31 import java.security.InvalidKeyException;
  32 import java.security.MessageDigest;
  33 import java.security.NoSuchAlgorithmException;
  34 import java.security.ProviderException;
  35 import java.security.spec.AlgorithmParameterSpec;
  36 import java.text.MessageFormat;
  37 import java.util.Locale;
  38 import javax.crypto.KeyGenerator;
  39 import javax.crypto.Mac;
  40 import javax.crypto.SecretKey;
  41 import javax.crypto.spec.IvParameterSpec;
  42 import javax.crypto.spec.SecretKeySpec;
  43 import javax.net.ssl.SSLPeerUnverifiedException;
  44 
  45 import jdk.internal.event.EventHelper;
  46 import jdk.internal.event.TLSHandshakeEvent;
  47 import sun.security.internal.spec.TlsPrfParameterSpec;
  48 import sun.security.ssl.CipherSuite.HashAlg;
  49 import static sun.security.ssl.CipherSuite.HashAlg.H_NONE;
  50 import sun.security.ssl.SSLBasicKeyDerivation.SecretSizeSpec;
  51 import sun.security.ssl.SSLCipher.SSLReadCipher;
  52 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  53 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  54 import sun.security.util.HexDumpEncoder;
  55 
  56 /**
  57  * Pack of the Finished handshake message.
  58  */
  59 final class Finished {
  60     static final SSLConsumer t12HandshakeConsumer =
  61         new T12FinishedConsumer();
  62     static final HandshakeProducer t12HandshakeProducer =
  63         new T12FinishedProducer();
  64 
  65     static final SSLConsumer t13HandshakeConsumer =
  66         new T13FinishedConsumer();
  67     static final HandshakeProducer t13HandshakeProducer =
  68         new T13FinishedProducer();
  69 
  70     /**
  71      * The Finished handshake message.
  72      */
  73     private static final class FinishedMessage extends HandshakeMessage {
  74         private final byte[] verifyData;
  75 
  76         FinishedMessage(HandshakeContext context) throws IOException {
  77             super(context);
  78 
  79             VerifyDataScheme vds =
  80                     VerifyDataScheme.valueOf(context.negotiatedProtocol);
  81 
  82             byte[] vd = null;
  83             try {
  84                 vd = vds.createVerifyData(context, false);
  85             } catch (IOException ioe) {
  86                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
  87                         &quot;Failed to generate verify_data&quot;, ioe);
  88             }
  89 
  90             this.verifyData = vd;
  91         }
  92 
  93         FinishedMessage(HandshakeContext context,
  94                 ByteBuffer m) throws IOException {
  95             super(context);
  96             int verifyDataLen = 12;
  97             if (context.negotiatedProtocol == ProtocolVersion.SSL30) {
  98                 verifyDataLen = 36;
  99             } else if (context.negotiatedProtocol.useTLS13PlusSpec()) {
 100                 verifyDataLen =
 101                         context.negotiatedCipherSuite.hashAlg.hashLength;
 102             }
 103 
 104             if (m.remaining() != verifyDataLen) {
 105                 throw context.conContext.fatal(Alert.DECODE_ERROR,
 106                     &quot;Inappropriate finished message: need &quot; + verifyDataLen +
 107                     &quot; but remaining &quot; + m.remaining() + &quot; bytes verify_data&quot;);
 108             }
 109 
 110             this.verifyData = new byte[verifyDataLen];
 111             m.get(verifyData);
 112 
 113             VerifyDataScheme vd =
 114                     VerifyDataScheme.valueOf(context.negotiatedProtocol);
 115             byte[] myVerifyData;
 116             try {
 117                 myVerifyData = vd.createVerifyData(context, true);
 118             } catch (IOException ioe) {
 119                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 120                         &quot;Failed to generate verify_data&quot;, ioe);
 121             }
 122             if (!MessageDigest.isEqual(myVerifyData, verifyData)) {
 123                 throw context.conContext.fatal(Alert.DECRYPT_ERROR,
 124                         &quot;The Finished message cannot be verified.&quot;);
 125             }
 126         }
 127 
 128         @Override
 129         public SSLHandshake handshakeType() {
 130             return SSLHandshake.FINISHED;
 131         }
 132 
 133         @Override
 134         public int messageLength() {
 135             return verifyData.length;
 136         }
 137 
 138         @Override
 139         public void send(HandshakeOutStream hos) throws IOException {
 140             hos.write(verifyData);
 141         }
 142 
 143         @Override
 144         public String toString() {
 145             MessageFormat messageFormat = new MessageFormat(
 146                     &quot;\&quot;Finished\&quot;: &#39;{&#39;\n&quot; +
 147                     &quot;  \&quot;verify data\&quot;: &#39;{&#39;\n&quot; +
 148                     &quot;{0}\n&quot; +
 149                     &quot;  &#39;}&#39;&quot; +
 150                     &quot;&#39;}&#39;&quot;,
 151                     Locale.ENGLISH);
 152 
 153             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 154             Object[] messageFields = {
 155                     Utilities.indent(hexEncoder.encode(verifyData), &quot;    &quot;),
 156                 };
 157             return messageFormat.format(messageFields);
 158         }
 159     }
 160 
 161     interface VerifyDataGenerator {
 162         byte[] createVerifyData(HandshakeContext context,
 163                 boolean isValidation) throws IOException;
 164     }
 165 
 166     enum VerifyDataScheme {
 167         SSL30       (&quot;kdf_ssl30&quot;, new S30VerifyDataGenerator()),
 168         TLS10       (&quot;kdf_tls10&quot;, new T10VerifyDataGenerator()),
 169         TLS12       (&quot;kdf_tls12&quot;, new T12VerifyDataGenerator()),
 170         TLS13       (&quot;kdf_tls13&quot;, new T13VerifyDataGenerator());
 171 
 172         final String name;
 173         final VerifyDataGenerator generator;
 174 
 175         VerifyDataScheme(String name, VerifyDataGenerator verifyDataGenerator) {
 176             this.name = name;
 177             this.generator = verifyDataGenerator;
 178         }
 179 
 180         static VerifyDataScheme valueOf(ProtocolVersion protocolVersion) {
 181             switch (protocolVersion) {
 182                 case SSL30:
 183                     return VerifyDataScheme.SSL30;
 184                 case TLS10:
 185                 case TLS11:
 186                 case DTLS10:
 187                     return VerifyDataScheme.TLS10;
 188                 case TLS12:
 189                 case DTLS12:
 190                     return VerifyDataScheme.TLS12;
 191                 case TLS13:
 192                     return VerifyDataScheme.TLS13;
 193                 default:
 194                     return null;
 195             }
 196         }
 197 
 198         public byte[] createVerifyData(HandshakeContext context,
 199                 boolean isValidation) throws IOException {
 200             if (generator != null) {
 201                 return generator.createVerifyData(context, isValidation);
 202             }
 203 
 204             throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
 205         }
 206     }
 207 
 208     // SSL 3.0
 209     private static final
 210             class S30VerifyDataGenerator implements VerifyDataGenerator {
 211         @Override
 212         public byte[] createVerifyData(HandshakeContext context,
 213                 boolean isValidation) throws IOException {
 214             HandshakeHash handshakeHash = context.handshakeHash;
 215             SecretKey masterSecretKey =
 216                     context.handshakeSession.getMasterSecret();
 217 
 218             boolean useClientLabel =
 219                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 220                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 221             return handshakeHash.digest(useClientLabel, masterSecretKey);
 222         }
 223     }
 224 
 225     // TLS 1.0, TLS 1.1, DTLS 1.0
 226     private static final
 227             class T10VerifyDataGenerator implements VerifyDataGenerator {
 228         @Override
 229         public byte[] createVerifyData(HandshakeContext context,
 230                 boolean isValidation) throws IOException {
 231             HandshakeHash handshakeHash = context.handshakeHash;
 232             SecretKey masterSecretKey =
 233                     context.handshakeSession.getMasterSecret();
 234 
 235             boolean useClientLabel =
 236                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 237                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 238             String tlsLabel;
 239             if (useClientLabel) {
 240                 tlsLabel = &quot;client finished&quot;;
 241             } else {
 242                 tlsLabel = &quot;server finished&quot;;
 243             }
 244 
 245             try {
 246                 byte[] seed = handshakeHash.digest();
 247                 String prfAlg = &quot;SunTlsPrf&quot;;
 248                 HashAlg hashAlg = H_NONE;
 249 
 250                 /*
 251                  * RFC 5246/7.4.9 says that finished messages can
 252                  * be ciphersuite-specific in both length/PRF hash
 253                  * algorithm.  If we ever run across a different
 254                  * length, this call will need to be updated.
 255                  */
 256                 @SuppressWarnings(&quot;deprecation&quot;)
 257                 TlsPrfParameterSpec spec = new TlsPrfParameterSpec(
 258                     masterSecretKey, tlsLabel, seed, 12,
 259                     hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);
 260                 KeyGenerator kg = KeyGenerator.getInstance(prfAlg);
 261                 kg.init(spec);
 262                 SecretKey prfKey = kg.generateKey();
 263                 if (!&quot;RAW&quot;.equals(prfKey.getFormat())) {
 264                     throw new ProviderException(
 265                         &quot;Invalid PRF output, format must be RAW. &quot; +
 266                         &quot;Format received: &quot; + prfKey.getFormat());
 267                 }
 268                 byte[] finished = prfKey.getEncoded();
 269                 return finished;
 270             } catch (GeneralSecurityException e) {
 271                 throw new RuntimeException(&quot;PRF failed&quot;, e);
 272             }
 273         }
 274     }
 275 
 276     // TLS 1.2
 277     private static final
 278             class T12VerifyDataGenerator implements VerifyDataGenerator {
 279         @Override
 280         public byte[] createVerifyData(HandshakeContext context,
 281                 boolean isValidation) throws IOException {
 282             CipherSuite cipherSuite = context.negotiatedCipherSuite;
 283             HandshakeHash handshakeHash = context.handshakeHash;
 284             SecretKey masterSecretKey =
 285                     context.handshakeSession.getMasterSecret();
 286 
 287             boolean useClientLabel =
 288                     (context.sslConfig.isClientMode &amp;&amp; !isValidation) ||
 289                     (!context.sslConfig.isClientMode &amp;&amp; isValidation);
 290             String tlsLabel;
 291             if (useClientLabel) {
 292                 tlsLabel = &quot;client finished&quot;;
 293             } else {
 294                 tlsLabel = &quot;server finished&quot;;
 295             }
 296 
 297             try {
 298                 byte[] seed = handshakeHash.digest();
 299                 String prfAlg = &quot;SunTls12Prf&quot;;
 300                 HashAlg hashAlg = cipherSuite.hashAlg;
 301 
 302                 /*
 303                  * RFC 5246/7.4.9 says that finished messages can
 304                  * be ciphersuite-specific in both length/PRF hash
 305                  * algorithm.  If we ever run across a different
 306                  * length, this call will need to be updated.
 307                  */
 308                 @SuppressWarnings(&quot;deprecation&quot;)
 309                 TlsPrfParameterSpec spec = new TlsPrfParameterSpec(
 310                     masterSecretKey, tlsLabel, seed, 12,
 311                     hashAlg.name, hashAlg.hashLength, hashAlg.blockSize);
 312                 KeyGenerator kg = KeyGenerator.getInstance(prfAlg);
 313                 kg.init(spec);
 314                 SecretKey prfKey = kg.generateKey();
 315                 if (!&quot;RAW&quot;.equals(prfKey.getFormat())) {
 316                     throw new ProviderException(
 317                         &quot;Invalid PRF output, format must be RAW. &quot; +
 318                         &quot;Format received: &quot; + prfKey.getFormat());
 319                 }
 320                 byte[] finished = prfKey.getEncoded();
 321                 return finished;
 322             } catch (GeneralSecurityException e) {
 323                 throw new RuntimeException(&quot;PRF failed&quot;, e);
 324             }
 325         }
 326     }
 327 
 328     // TLS 1.2
 329     private static final
 330             class T13VerifyDataGenerator implements VerifyDataGenerator {
 331         private static final byte[] hkdfLabel = &quot;tls13 finished&quot;.getBytes();
 332         private static final byte[] hkdfContext = new byte[0];
 333 
 334         @Override
 335         public byte[] createVerifyData(HandshakeContext context,
 336                 boolean isValidation) throws IOException {
 337             // create finished secret key
 338             HashAlg hashAlg =
 339                     context.negotiatedCipherSuite.hashAlg;
 340             SecretKey secret = isValidation ?
 341                     context.baseReadSecret : context.baseWriteSecret;
 342             SSLBasicKeyDerivation kdf = new SSLBasicKeyDerivation(
 343                     secret, hashAlg.name,
 344                     hkdfLabel, hkdfContext, hashAlg.hashLength);
 345             AlgorithmParameterSpec keySpec =
 346                     new SecretSizeSpec(hashAlg.hashLength);
 347             SecretKey finishedSecret =
 348                     kdf.deriveKey(&quot;TlsFinishedSecret&quot;, keySpec);
 349 
 350             String hmacAlg =
 351                 &quot;Hmac&quot; + hashAlg.name.replace(&quot;-&quot;, &quot;&quot;);
 352             try {
 353                 Mac hmac = Mac.getInstance(hmacAlg);
 354                 hmac.init(finishedSecret);
 355                 return hmac.doFinal(context.handshakeHash.digest());
 356             } catch (NoSuchAlgorithmException |InvalidKeyException ex) {
 357                 throw new ProviderException(
 358                         &quot;Failed to generate verify_data&quot;, ex);
 359             }
 360         }
 361     }
 362 
 363     /**
 364      * The &quot;Finished&quot; handshake message producer.
 365      */
 366     private static final
 367             class T12FinishedProducer implements HandshakeProducer {
 368         // Prevent instantiation of this class.
 369         private T12FinishedProducer() {
 370             // blank
 371         }
 372 
 373         @Override
 374         public byte[] produce(ConnectionContext context,
 375                 HandshakeMessage message) throws IOException {
 376             // The consuming happens in handshake context only.
 377             HandshakeContext hc = (HandshakeContext)context;
 378             if (hc.sslConfig.isClientMode) {
 379                 return onProduceFinished(
 380                         (ClientHandshakeContext)context, message);
 381             } else {
 382                 return onProduceFinished(
 383                         (ServerHandshakeContext)context, message);
 384             }
 385         }
 386 
 387         private byte[] onProduceFinished(ClientHandshakeContext chc,
 388                 HandshakeMessage message) throws IOException {
 389             // Refresh handshake hash
 390             chc.handshakeHash.update();
 391 
 392             FinishedMessage fm = new FinishedMessage(chc);
 393 
 394             // Change write cipher and delivery ChangeCipherSpec message.
 395             ChangeCipherSpec.t10Producer.produce(chc, message);
 396 
 397             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 398                 SSLLogger.fine(
 399                         &quot;Produced client Finished handshake message&quot;, fm);
 400             }
 401 
 402             // Output the handshake message.
 403             fm.write(chc.handshakeOutput);
 404             chc.handshakeOutput.flush();
 405 
 406             /*
 407              * save server verify data for secure renegotiation
 408              */
 409             if (chc.conContext.secureRenegotiation) {
 410                 chc.conContext.clientVerifyData = fm.verifyData;
 411             }
 412 
<a name="1" id="anc1"></a><span class="line-added"> 413             if (chc.statelessResumption) {</span>
<span class="line-added"> 414                 chc.handshakeConsumers.put(</span>
<span class="line-added"> 415                         SSLHandshake.NEW_SESSION_TICKET.id, SSLHandshake.NEW_SESSION_TICKET);</span>
<span class="line-added"> 416             }</span>
 417             // update the consumers and producers
 418             if (!chc.isResumption) {
 419                 chc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 420                         ChangeCipherSpec.t10Consumer);
 421                 chc.handshakeConsumers.put(
 422                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 423                 chc.conContext.inputRecord.expectingFinishFlight();
 424             } else {
 425                 if (chc.handshakeSession.isRejoinable()) {
 426                     ((SSLSessionContextImpl)chc.sslContext.
 427                         engineGetClientSessionContext()).put(
 428                             chc.handshakeSession);
 429                 }
 430                 chc.conContext.conSession = chc.handshakeSession.finish();
 431                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 432 
 433                 // handshake context cleanup.
 434                 chc.handshakeFinished = true;
 435 
 436                 // May need to retransmit the last flight for DTLS.
 437                 if (!chc.sslContext.isDTLS()) {
 438                     chc.conContext.finishHandshake();
 439                 }
 440             }
 441 
 442             // The handshake message has been delivered.
 443             return null;
 444         }
 445 
 446         private byte[] onProduceFinished(ServerHandshakeContext shc,
 447                 HandshakeMessage message) throws IOException {
<a name="2" id="anc2"></a><span class="line-added"> 448             if (shc.statelessResumption) {</span>
<span class="line-added"> 449                 NewSessionTicket.handshake12Producer.produce(shc, message);</span>
<span class="line-added"> 450             }</span>
<span class="line-added"> 451 </span>
 452             // Refresh handshake hash
 453             shc.handshakeHash.update();
 454 
 455             FinishedMessage fm = new FinishedMessage(shc);
 456 
 457             // Change write cipher and delivery ChangeCipherSpec message.
 458             ChangeCipherSpec.t10Producer.produce(shc, message);
 459 
 460             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 461                 SSLLogger.fine(
 462                         &quot;Produced server Finished handshake message&quot;, fm);
 463             }
 464 
 465             // Output the handshake message.
 466             fm.write(shc.handshakeOutput);
 467             shc.handshakeOutput.flush();
 468 
 469             /*
 470              * save client verify data for secure renegotiation
 471              */
 472             if (shc.conContext.secureRenegotiation) {
 473                 shc.conContext.serverVerifyData = fm.verifyData;
 474             }
 475 
 476             // update the consumers and producers
 477             if (shc.isResumption) {
 478                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 479                         ChangeCipherSpec.t10Consumer);
 480                 shc.handshakeConsumers.put(
 481                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 482                 shc.conContext.inputRecord.expectingFinishFlight();
 483             } else {
<a name="3" id="anc3"></a><span class="line-modified"> 484                 if (shc.handshakeSession.isRejoinable() &amp;&amp;</span>
<span class="line-added"> 485                         !shc.handshakeSession.isStatelessable(shc)) {</span>
 486                     ((SSLSessionContextImpl)shc.sslContext.
 487                         engineGetServerSessionContext()).put(
 488                             shc.handshakeSession);
 489                 }
 490                 shc.conContext.conSession = shc.handshakeSession.finish();
 491                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 492 
 493                 // handshake context cleanup.
 494                 shc.handshakeFinished = true;
 495 
 496                 // May need to retransmit the last flight for DTLS.
 497                 if (!shc.sslContext.isDTLS()) {
 498                     shc.conContext.finishHandshake();
 499                 }
 500             }
 501 
 502             // The handshake message has been delivered.
 503             return null;
 504         }
 505     }
 506 
 507     /**
 508      * The &quot;Finished&quot; handshake message consumer.
 509      */
 510     private static final class T12FinishedConsumer implements SSLConsumer {
 511         // Prevent instantiation of this class.
 512         private T12FinishedConsumer() {
 513             // blank
 514         }
 515 
 516         @Override
 517         public void consume(ConnectionContext context,
 518                 ByteBuffer message) throws IOException {
 519             // The consuming happens in handshake context only.
 520             HandshakeContext hc = (HandshakeContext)context;
 521 
 522             // This consumer can be used only once.
 523             hc.handshakeConsumers.remove(SSLHandshake.FINISHED.id);
 524 
 525             // We should not be processing finished messages unless
 526             // we have received ChangeCipherSpec
 527             if (hc.conContext.consumers.containsKey(
 528                     ContentType.CHANGE_CIPHER_SPEC.id)) {
 529                 throw hc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 530                         &quot;Missing ChangeCipherSpec message&quot;);
 531             }
 532 
 533             if (hc.sslConfig.isClientMode) {
 534                 onConsumeFinished((ClientHandshakeContext)context, message);
 535             } else {
 536                 onConsumeFinished((ServerHandshakeContext)context, message);
 537             }
 538         }
 539 
 540         private void onConsumeFinished(ClientHandshakeContext chc,
 541                 ByteBuffer message) throws IOException {
 542             FinishedMessage fm = new FinishedMessage(chc, message);
 543             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 544                 SSLLogger.fine(
 545                         &quot;Consuming server Finished handshake message&quot;, fm);
 546             }
 547 
 548             if (chc.conContext.secureRenegotiation) {
 549                 chc.conContext.serverVerifyData = fm.verifyData;
 550             }
 551 
 552             if (!chc.isResumption) {
 553                 if (chc.handshakeSession.isRejoinable()) {
 554                     ((SSLSessionContextImpl)chc.sslContext.
 555                         engineGetClientSessionContext()).put(
 556                             chc.handshakeSession);
 557                 }
 558                 chc.conContext.conSession = chc.handshakeSession.finish();
 559                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 560 
 561                 // handshake context cleanup.
 562                 chc.handshakeFinished = true;
 563                 recordEvent(chc.conContext.conSession);
 564 
 565                 // May need to retransmit the last flight for DTLS.
 566                 if (!chc.sslContext.isDTLS()) {
 567                     chc.conContext.finishHandshake();
 568                 }
 569             } else {
 570                 chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 571                         SSLHandshake.FINISHED);
 572             }
 573 
 574             //
 575             // produce
 576             //
 577             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 578                 SSLHandshake.FINISHED
 579             };
 580 
 581             for (SSLHandshake hs : probableHandshakeMessages) {
 582                 HandshakeProducer handshakeProducer =
 583                         chc.handshakeProducers.remove(hs.id);
 584                 if (handshakeProducer != null) {
 585                     handshakeProducer.produce(chc, fm);
 586                 }
 587             }
 588         }
 589 
 590         private void onConsumeFinished(ServerHandshakeContext shc,
 591                 ByteBuffer message) throws IOException {
<a name="4" id="anc4"></a><span class="line-added"> 592             // Make sure that any expected CertificateVerify message</span>
<span class="line-added"> 593             // has been received and processed.</span>
<span class="line-added"> 594             if (!shc.isResumption) {</span>
<span class="line-added"> 595                 if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 596                         SSLHandshake.CERTIFICATE_VERIFY.id)) {</span>
<span class="line-added"> 597                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 598                             &quot;Unexpected Finished handshake message&quot;);</span>
<span class="line-added"> 599                 }</span>
<span class="line-added"> 600             }</span>
<span class="line-added"> 601 </span>
 602             FinishedMessage fm = new FinishedMessage(shc, message);
 603             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 604                 SSLLogger.fine(
 605                         &quot;Consuming client Finished handshake message&quot;, fm);
 606             }
 607 
 608             if (shc.conContext.secureRenegotiation) {
 609                 shc.conContext.clientVerifyData = fm.verifyData;
 610             }
 611 
 612             if (shc.isResumption) {
<a name="5" id="anc5"></a><span class="line-modified"> 613                 if (shc.handshakeSession.isRejoinable() &amp;&amp;</span>
<span class="line-added"> 614                         !shc.statelessResumption) {</span>
 615                     ((SSLSessionContextImpl)shc.sslContext.
 616                         engineGetServerSessionContext()).put(
 617                             shc.handshakeSession);
 618                 }
 619                 shc.conContext.conSession = shc.handshakeSession.finish();
 620                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 621 
 622                 // handshake context cleanup.
 623                 shc.handshakeFinished = true;
 624                 recordEvent(shc.conContext.conSession);
 625 
 626                 // May need to retransmit the last flight for DTLS.
 627                 if (!shc.sslContext.isDTLS()) {
 628                     shc.conContext.finishHandshake();
 629                 }
 630             } else {
 631                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 632                         SSLHandshake.FINISHED);
 633             }
 634 
 635             //
 636             // produce
 637             //
 638             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 639                 SSLHandshake.FINISHED
 640             };
 641 
 642             for (SSLHandshake hs : probableHandshakeMessages) {
 643                 HandshakeProducer handshakeProducer =
 644                         shc.handshakeProducers.remove(hs.id);
 645                 if (handshakeProducer != null) {
 646                     handshakeProducer.produce(shc, fm);
 647                 }
 648             }
 649         }
 650     }
 651 
 652     /**
 653      * The &quot;Finished&quot; handshake message producer.
 654      */
 655     private static final
 656             class T13FinishedProducer implements HandshakeProducer {
 657         // Prevent instantiation of this class.
 658         private T13FinishedProducer() {
 659             // blank
 660         }
 661 
 662         @Override
 663         public byte[] produce(ConnectionContext context,
 664                 HandshakeMessage message) throws IOException {
 665             // The consuming happens in handshake context only.
 666             HandshakeContext hc = (HandshakeContext)context;
 667             if (hc.sslConfig.isClientMode) {
 668                 return onProduceFinished(
 669                         (ClientHandshakeContext)context, message);
 670             } else {
 671                 return onProduceFinished(
 672                         (ServerHandshakeContext)context, message);
 673             }
 674         }
 675 
 676         private byte[] onProduceFinished(ClientHandshakeContext chc,
 677                 HandshakeMessage message) throws IOException {
 678             // Refresh handshake hash
 679             chc.handshakeHash.update();
 680 
 681             FinishedMessage fm = new FinishedMessage(chc);
 682             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 683                 SSLLogger.fine(
 684                         &quot;Produced client Finished handshake message&quot;, fm);
 685             }
 686 
 687             // Output the handshake message.
 688             fm.write(chc.handshakeOutput);
 689             chc.handshakeOutput.flush();
 690 
 691             // save server verify data for secure renegotiation
 692             if (chc.conContext.secureRenegotiation) {
 693                 chc.conContext.clientVerifyData = fm.verifyData;
 694             }
 695 
 696             // update the context
 697             // Change client/server application traffic secrets.
 698             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 699             if (kd == null) {
 700                 // unlikely
 701                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 702                     &quot;no key derivation&quot;);
 703             }
 704 
 705             SSLTrafficKeyDerivation kdg =
 706                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 707             if (kdg == null) {
 708                 // unlikely
 709                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 710                         &quot;Not supported key derivation: &quot; +
 711                         chc.negotiatedProtocol);
 712             }
 713 
 714             try {
 715                 // update the application traffic read keys.
 716                 SecretKey writeSecret = kd.deriveKey(
 717                         &quot;TlsClientAppTrafficSecret&quot;, null);
 718 
 719                 SSLKeyDerivation writeKD =
 720                         kdg.createKeyDerivation(chc, writeSecret);
 721                 SecretKey writeKey = writeKD.deriveKey(
 722                         &quot;TlsKey&quot;, null);
 723                 SecretKey writeIvSecret = writeKD.deriveKey(
 724                         &quot;TlsIv&quot;, null);
 725                 IvParameterSpec writeIv =
 726                         new IvParameterSpec(writeIvSecret.getEncoded());
 727                 SSLWriteCipher writeCipher =
 728                         chc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 729                                 Authenticator.valueOf(chc.negotiatedProtocol),
 730                                 chc.negotiatedProtocol, writeKey, writeIv,
 731                                 chc.sslContext.getSecureRandom());
 732 
 733                 if (writeCipher == null) {
 734                     throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 735                         &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
 736                         &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
 737                         &quot;)&quot;);
 738                 }
 739 
 740                 chc.baseWriteSecret = writeSecret;
 741                 chc.conContext.outputRecord.changeWriteCiphers(
 742                         writeCipher, false);
 743 
 744             } catch (GeneralSecurityException gse) {
 745                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 746                         &quot;Failure to derive application secrets&quot;, gse);
 747             }
 748 
 749             // The resumption master secret is stored in the session so
 750             // it can be used after the handshake is completed.
 751             SSLSecretDerivation sd = ((SSLSecretDerivation) kd).forContext(chc);
 752             SecretKey resumptionMasterSecret = sd.deriveKey(
 753                     &quot;TlsResumptionMasterSecret&quot;, null);
 754             chc.handshakeSession.setResumptionMasterSecret(
 755                     resumptionMasterSecret);
 756 
 757             chc.conContext.conSession = chc.handshakeSession.finish();
 758             chc.conContext.protocolVersion = chc.negotiatedProtocol;
 759 
 760             // handshake context cleanup.
 761             chc.handshakeFinished = true;
 762             chc.conContext.finishHandshake();
 763             recordEvent(chc.conContext.conSession);
 764 
 765 
 766             // The handshake message has been delivered.
 767             return null;
 768         }
 769 
 770         private byte[] onProduceFinished(ServerHandshakeContext shc,
 771                 HandshakeMessage message) throws IOException {
 772             // Refresh handshake hash
 773             shc.handshakeHash.update();
 774 
 775             FinishedMessage fm = new FinishedMessage(shc);
 776             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 777                 SSLLogger.fine(
 778                         &quot;Produced server Finished handshake message&quot;, fm);
 779             }
 780 
 781             // Output the handshake message.
 782             fm.write(shc.handshakeOutput);
 783             shc.handshakeOutput.flush();
 784 
 785             // Change client/server application traffic secrets.
 786             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
 787             if (kd == null) {
 788                 // unlikely
 789                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 790                     &quot;no key derivation&quot;);
 791             }
 792 
 793             SSLTrafficKeyDerivation kdg =
 794                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 795             if (kdg == null) {
 796                 // unlikely
 797                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 798                         &quot;Not supported key derivation: &quot; +
 799                         shc.negotiatedProtocol);
 800             }
 801 
 802             // derive salt secret
 803             try {
 804                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 805 
 806                 // derive application secrets
 807                 HashAlg hashAlg = shc.negotiatedCipherSuite.hashAlg;
 808                 HKDF hkdf = new HKDF(hashAlg.name);
 809                 byte[] zeros = new byte[hashAlg.hashLength];
 810                 SecretKeySpec sharedSecret =
 811                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 812                 SecretKey masterSecret =
 813                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 814 
 815                 SSLKeyDerivation secretKD =
 816                         new SSLSecretDerivation(shc, masterSecret);
 817 
 818                 // update the handshake traffic write keys.
 819                 SecretKey writeSecret = secretKD.deriveKey(
 820                         &quot;TlsServerAppTrafficSecret&quot;, null);
 821                 SSLKeyDerivation writeKD =
 822                         kdg.createKeyDerivation(shc, writeSecret);
 823                 SecretKey writeKey = writeKD.deriveKey(
 824                         &quot;TlsKey&quot;, null);
 825                 SecretKey writeIvSecret = writeKD.deriveKey(
 826                         &quot;TlsIv&quot;, null);
 827                 IvParameterSpec writeIv =
 828                         new IvParameterSpec(writeIvSecret.getEncoded());
 829                 SSLWriteCipher writeCipher =
 830                         shc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 831                                 Authenticator.valueOf(shc.negotiatedProtocol),
 832                                 shc.negotiatedProtocol, writeKey, writeIv,
 833                                 shc.sslContext.getSecureRandom());
 834 
 835                 if (writeCipher == null) {
 836                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 837                         &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 838                         &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 839                         &quot;)&quot;);
 840                 }
 841 
 842                 shc.baseWriteSecret = writeSecret;
 843                 shc.conContext.outputRecord.changeWriteCiphers(
 844                         writeCipher, false);
 845 
 846                 // update the context for the following key derivation
 847                 shc.handshakeKeyDerivation = secretKD;
 848             } catch (GeneralSecurityException gse) {
 849                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 850                         &quot;Failure to derive application secrets&quot;, gse);
 851             }
 852 
 853             /*
 854              * save client verify data for secure renegotiation
 855              */
 856             if (shc.conContext.secureRenegotiation) {
 857                 shc.conContext.serverVerifyData = fm.verifyData;
 858             }
 859 
<a name="6" id="anc6"></a><span class="line-added"> 860             shc.conContext.conSession = shc.handshakeSession.finish();</span>
<span class="line-added"> 861 </span>
 862             // update the context
 863             shc.handshakeConsumers.put(
 864                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 865 
 866             // The handshake message has been delivered.
 867             return null;
 868         }
 869     }
 870 
 871     /**
 872      * The &quot;Finished&quot; handshake message consumer.
 873      */
 874     private static final class T13FinishedConsumer implements SSLConsumer {
 875         // Prevent instantiation of this class.
 876         private T13FinishedConsumer() {
 877             // blank
 878         }
 879 
 880         @Override
 881         public void consume(ConnectionContext context,
 882                 ByteBuffer message) throws IOException {
 883             // The consuming happens in handshake context only.
 884             HandshakeContext hc = (HandshakeContext)context;
 885             if (hc.sslConfig.isClientMode) {
 886                 onConsumeFinished(
 887                         (ClientHandshakeContext)context, message);
 888             } else {
 889                 onConsumeFinished(
 890                         (ServerHandshakeContext)context, message);
 891             }
 892         }
 893 
 894         private void onConsumeFinished(ClientHandshakeContext chc,
 895                 ByteBuffer message) throws IOException {
<a name="7" id="anc7"></a><span class="line-added"> 896             // Make sure that any expected CertificateVerify message</span>
<span class="line-added"> 897             // has been received and processed.</span>
<span class="line-added"> 898             if (!chc.isResumption) {</span>
<span class="line-added"> 899                 if (chc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 900                         SSLHandshake.CERTIFICATE_VERIFY.id)) {</span>
<span class="line-added"> 901                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 902                             &quot;Unexpected Finished handshake message&quot;);</span>
<span class="line-added"> 903                 }</span>
<span class="line-added"> 904             }</span>
<span class="line-added"> 905 </span>
 906             FinishedMessage fm = new FinishedMessage(chc, message);
 907             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 908                 SSLLogger.fine(
 909                         &quot;Consuming server Finished handshake message&quot;, fm);
 910             }
 911 
 912             // Save client verify data for secure renegotiation.
 913             if (chc.conContext.secureRenegotiation) {
 914                 chc.conContext.serverVerifyData = fm.verifyData;
 915             }
 916 
 917             //
 918             // validate
 919             //
 920             // blank
 921 
 922             //
 923             // update
 924             //
 925             // A change_cipher_spec record received after the peer&#39;s Finished
 926             // message MUST be treated as an unexpected record type.
 927             chc.conContext.consumers.remove(ContentType.CHANGE_CIPHER_SPEC.id);
 928 
 929             // Change client/server application traffic secrets.
 930             // Refresh handshake hash
 931             chc.handshakeHash.update();
 932             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 933             if (kd == null) {
 934                 // unlikely
 935                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 936                     &quot;no key derivation&quot;);
 937             }
 938 
 939             SSLTrafficKeyDerivation kdg =
 940                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 941             if (kdg == null) {
 942                 // unlikely
 943                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 944                         &quot;Not supported key derivation: &quot; +
 945                         chc.negotiatedProtocol);
 946             }
 947 
 948             // save the session
 949             if (!chc.isResumption &amp;&amp; chc.handshakeSession.isRejoinable()) {
<a name="8" id="anc8"></a><span class="line-modified"> 950                 ((SSLSessionContextImpl)chc.sslContext.</span>
<span class="line-modified"> 951                         engineGetClientSessionContext()).</span>
<span class="line-modified"> 952                         put(chc.handshakeSession);</span>
 953             }
 954 
 955             // derive salt secret
 956             try {
 957                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 958 
 959                 // derive application secrets
 960                 HashAlg hashAlg = chc.negotiatedCipherSuite.hashAlg;
 961                 HKDF hkdf = new HKDF(hashAlg.name);
 962                 byte[] zeros = new byte[hashAlg.hashLength];
 963                 SecretKeySpec sharedSecret =
 964                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 965                 SecretKey masterSecret =
 966                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 967 
 968                 SSLKeyDerivation secretKD =
 969                         new SSLSecretDerivation(chc, masterSecret);
 970 
 971                 // update the handshake traffic read keys.
 972                 SecretKey readSecret = secretKD.deriveKey(
 973                         &quot;TlsServerAppTrafficSecret&quot;, null);
 974                 SSLKeyDerivation writeKD =
 975                         kdg.createKeyDerivation(chc, readSecret);
 976                 SecretKey readKey = writeKD.deriveKey(
 977                         &quot;TlsKey&quot;, null);
 978                 SecretKey readIvSecret = writeKD.deriveKey(
 979                         &quot;TlsIv&quot;, null);
 980                 IvParameterSpec readIv =
 981                         new IvParameterSpec(readIvSecret.getEncoded());
 982                 SSLReadCipher readCipher =
 983                         chc.negotiatedCipherSuite.bulkCipher.createReadCipher(
 984                                 Authenticator.valueOf(chc.negotiatedProtocol),
 985                                 chc.negotiatedProtocol, readKey, readIv,
 986                                 chc.sslContext.getSecureRandom());
 987 
 988                 if (readCipher == null) {
 989                     throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 990                         &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
 991                         &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
 992                         &quot;)&quot;);
 993                 }
 994 
 995                 chc.baseReadSecret = readSecret;
 996                 chc.conContext.inputRecord.changeReadCiphers(readCipher);
 997 
 998                 // update the context for the following key derivation
 999                 chc.handshakeKeyDerivation = secretKD;
1000             } catch (GeneralSecurityException gse) {
1001                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1002                         &quot;Failure to derive application secrets&quot;, gse);
1003             }
1004 
1005             //
1006             // produce
1007             //
1008             chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
1009                         SSLHandshake.FINISHED);
1010             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
1011                 // full handshake messages
1012                 SSLHandshake.CERTIFICATE,
1013                 SSLHandshake.CERTIFICATE_VERIFY,
1014                 SSLHandshake.FINISHED
1015             };
1016 
1017             for (SSLHandshake hs : probableHandshakeMessages) {
1018                 HandshakeProducer handshakeProducer =
1019                         chc.handshakeProducers.remove(hs.id);
1020                 if (handshakeProducer != null) {
1021                     handshakeProducer.produce(chc, null);
1022                 }
1023             }
1024         }
1025 
1026         private void onConsumeFinished(ServerHandshakeContext shc,
1027                 ByteBuffer message) throws IOException {
<a name="9" id="anc9"></a><span class="line-added">1028             // Make sure that any expected CertificateVerify message</span>
<span class="line-added">1029             // has been received and processed.</span>
<span class="line-added">1030             if (!shc.isResumption) {</span>
<span class="line-added">1031                 if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added">1032                         SSLHandshake.CERTIFICATE_VERIFY.id)) {</span>
<span class="line-added">1033                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added">1034                             &quot;Unexpected Finished handshake message&quot;);</span>
<span class="line-added">1035                 }</span>
<span class="line-added">1036             }</span>
<span class="line-added">1037 </span>
1038             FinishedMessage fm = new FinishedMessage(shc, message);
1039             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1040                 SSLLogger.fine(
1041                         &quot;Consuming client Finished handshake message&quot;, fm);
1042             }
1043 
1044             if (shc.conContext.secureRenegotiation) {
1045                 shc.conContext.clientVerifyData = fm.verifyData;
1046             }
1047 
1048             //
1049             // validate
1050             //
1051             // blank
1052 
1053             //
1054             // update
1055             //
1056             // Change client/server application traffic secrets.
1057             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1058             if (kd == null) {
1059                 // unlikely
1060                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1061                     &quot;no key derivation&quot;);
1062             }
1063 
1064             SSLTrafficKeyDerivation kdg =
1065                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1066             if (kdg == null) {
1067                 // unlikely
1068                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1069                         &quot;Not supported key derivation: &quot; +
1070                         shc.negotiatedProtocol);
1071             }
1072 
<a name="10" id="anc10"></a><span class="line-modified">1073             // Save the session if possible and not stateless</span>
<span class="line-modified">1074             if (!shc.statelessResumption &amp;&amp; !shc.isResumption &amp;&amp;</span>
<span class="line-added">1075                     shc.handshakeSession.isRejoinable()) {</span>
1076                 SSLSessionContextImpl sessionContext = (SSLSessionContextImpl)
<a name="11" id="anc11"></a><span class="line-modified">1077                         shc.sslContext.engineGetServerSessionContext();</span>
1078                 sessionContext.put(shc.handshakeSession);
1079             }
1080 
1081             try {
1082                 // update the application traffic read keys.
1083                 SecretKey readSecret = kd.deriveKey(
1084                         &quot;TlsClientAppTrafficSecret&quot;, null);
1085 
1086                 SSLKeyDerivation readKD =
1087                         kdg.createKeyDerivation(shc, readSecret);
1088                 SecretKey readKey = readKD.deriveKey(
1089                         &quot;TlsKey&quot;, null);
1090                 SecretKey readIvSecret = readKD.deriveKey(
1091                         &quot;TlsIv&quot;, null);
1092                 IvParameterSpec readIv =
1093                         new IvParameterSpec(readIvSecret.getEncoded());
1094                 SSLReadCipher readCipher =
1095                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1096                                 Authenticator.valueOf(shc.negotiatedProtocol),
1097                                 shc.negotiatedProtocol, readKey, readIv,
1098                                 shc.sslContext.getSecureRandom());
1099 
1100                 if (readCipher == null) {
1101                     throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1102                         &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
1103                         &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
1104                         &quot;)&quot;);
1105                 }
1106 
1107                 shc.baseReadSecret = readSecret;
1108                 shc.conContext.inputRecord.changeReadCiphers(readCipher);
1109 
1110                 // The resumption master secret is stored in the session so
1111                 // it can be used after the handshake is completed.
1112                 shc.handshakeHash.update();
1113                 SSLSecretDerivation sd =
1114                         ((SSLSecretDerivation)kd).forContext(shc);
1115                 SecretKey resumptionMasterSecret = sd.deriveKey(
1116                 &quot;TlsResumptionMasterSecret&quot;, null);
1117                 shc.handshakeSession.setResumptionMasterSecret(
1118                         resumptionMasterSecret);
1119             } catch (GeneralSecurityException gse) {
1120                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1121                         &quot;Failure to derive application secrets&quot;, gse);
1122             }
1123 
1124             //  update connection context
1125             shc.conContext.conSession = shc.handshakeSession.finish();
1126             shc.conContext.protocolVersion = shc.negotiatedProtocol;
1127 
1128             // handshake context cleanup.
1129             shc.handshakeFinished = true;
1130 
1131             // May need to retransmit the last flight for DTLS.
1132             if (!shc.sslContext.isDTLS()) {
1133                 shc.conContext.finishHandshake();
1134             }
1135             recordEvent(shc.conContext.conSession);
1136 
1137             //
1138             // produce
1139             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1140                 SSLLogger.fine(
1141                 &quot;Sending new session ticket&quot;);
1142             }
1143             NewSessionTicket.kickstartProducer.produce(shc);
1144 
1145         }
1146     }
1147 
1148     private static void recordEvent(SSLSessionImpl session) {
1149         TLSHandshakeEvent event = new TLSHandshakeEvent();
1150         if (event.shouldCommit() || EventHelper.isLoggingSecurity()) {
1151             int peerCertificateId = 0;
1152             try {
1153                 // use hash code for Id
1154                 peerCertificateId = session
1155                         .getCertificateChain()[0]
1156                         .hashCode();
1157             } catch (SSLPeerUnverifiedException e) {
1158                  // not verified msg
1159             }
1160             if (event.shouldCommit()) {
1161                 event.peerHost = session.getPeerHost();
1162                 event.peerPort = session.getPeerPort();
1163                 event.cipherSuite = session.getCipherSuite();
1164                 event.protocolVersion = session.getProtocol();
1165                 event.certificateId = peerCertificateId;
1166                 event.commit();
1167             }
1168             if (EventHelper.isLoggingSecurity()) {
1169                 EventHelper.logTLSHandshakeEvent(null,
1170                                 session.getPeerHost(),
1171                                 session.getPeerPort(),
1172                                 session.getCipherSuite(),
1173                                 session.getProtocol(),
1174                                 peerCertificateId);
1175             }
1176         }
1177     }
1178 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/SupportedGroupsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.AlgorithmConstraints;
  31 import java.security.AlgorithmParameters;
  32 import java.security.CryptoPrimitive;
  33 import java.security.NoSuchAlgorithmException;
  34 import java.security.spec.AlgorithmParameterSpec;
  35 import java.security.spec.ECGenParameterSpec;
  36 import java.security.spec.ECParameterSpec;
  37 import java.security.spec.InvalidParameterSpecException;
  38 import java.text.MessageFormat;
  39 import java.util.ArrayList;
  40 import java.util.Collections;
  41 import java.util.EnumSet;
  42 import java.util.HashMap;
  43 import java.util.LinkedList;
  44 import java.util.List;
  45 import java.util.Locale;
  46 import java.util.Map;
  47 import javax.crypto.spec.DHParameterSpec;
  48 import javax.net.ssl.SSLProtocolException;
  49 import sun.security.action.GetPropertyAction;
  50 import static sun.security.ssl.SSLExtension.CH_SUPPORTED_GROUPS;
  51 import static sun.security.ssl.SSLExtension.EE_SUPPORTED_GROUPS;
  52 import sun.security.ssl.SSLExtension.ExtensionConsumer;
  53 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  54 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  55 import sun.security.util.ECUtil;
  56 
  57 /**
  58  * Pack of the &quot;supported_groups&quot; extensions [RFC 4492/7919].
  59  */
  60 final class SupportedGroupsExtension {
  61     static final HandshakeProducer chNetworkProducer =
  62             new CHSupportedGroupsProducer();
  63     static final ExtensionConsumer chOnLoadConsumer =
  64             new CHSupportedGroupsConsumer();
  65     static final SSLStringizer sgsStringizer =
  66             new SupportedGroupsStringizer();
  67 
  68     static final HandshakeProducer eeNetworkProducer =
  69             new EESupportedGroupsProducer();
  70     static final ExtensionConsumer eeOnLoadConsumer =
  71             new EESupportedGroupsConsumer();
  72 
  73     /**
  74      * The &quot;supported_groups&quot; extension.
  75      */
  76     static final class SupportedGroupsSpec implements SSLExtensionSpec {
  77         final int[] namedGroupsIds;
  78 
  79         private SupportedGroupsSpec(int[] namedGroupsIds) {
  80             this.namedGroupsIds = namedGroupsIds;
  81         }
  82 
  83         private SupportedGroupsSpec(List&lt;NamedGroup&gt; namedGroups) {
  84             this.namedGroupsIds = new int[namedGroups.size()];
  85             int i = 0;
  86             for (NamedGroup ng : namedGroups) {
  87                 namedGroupsIds[i++] = ng.id;
  88             }
  89         }
  90 
  91         private SupportedGroupsSpec(ByteBuffer m) throws IOException  {
  92             if (m.remaining() &lt; 2) {      // 2: the length of the list
  93                 throw new SSLProtocolException(
  94                     &quot;Invalid supported_groups extension: insufficient data&quot;);
  95             }
  96 
  97             byte[] ngs = Record.getBytes16(m);
  98             if (m.hasRemaining()) {
  99                 throw new SSLProtocolException(
 100                     &quot;Invalid supported_groups extension: unknown extra data&quot;);
 101             }
 102 
 103             if ((ngs == null) || (ngs.length == 0) || (ngs.length % 2 != 0)) {
 104                 throw new SSLProtocolException(
 105                     &quot;Invalid supported_groups extension: incomplete data&quot;);
 106             }
 107 
 108             int[] ids = new int[ngs.length / 2];
 109             for (int i = 0, j = 0; i &lt; ngs.length;) {
 110                 ids[j++] = ((ngs[i++] &amp; 0xFF) &lt;&lt; 8) | (ngs[i++] &amp; 0xFF);
 111             }
 112 
 113             this.namedGroupsIds = ids;
 114         }
 115 
 116         @Override
 117         public String toString() {
 118             MessageFormat messageFormat = new MessageFormat(
 119                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
 120 
 121             if (namedGroupsIds == null || namedGroupsIds.length == 0) {
 122                 Object[] messageFields = {
 123                         &quot;&lt;no supported named group specified&gt;&quot;
 124                     };
 125                 return messageFormat.format(messageFields);
 126             } else {
 127                 StringBuilder builder = new StringBuilder(512);
 128                 boolean isFirst = true;
 129                 for (int ngid : namedGroupsIds) {
 130                     if (isFirst) {
 131                         isFirst = false;
 132                     } else {
 133                         builder.append(&quot;, &quot;);
 134                     }
 135 
 136                     builder.append(NamedGroup.nameOf(ngid));
 137                 }
 138 
 139                 Object[] messageFields = {
 140                         builder.toString()
 141                     };
 142 
 143                 return messageFormat.format(messageFields);
 144             }
 145         }
 146     }
 147 
 148     private static final
 149             class SupportedGroupsStringizer implements SSLStringizer {
 150         @Override
 151         public String toString(ByteBuffer buffer) {
 152             try {
 153                 return (new SupportedGroupsSpec(buffer)).toString();
 154             } catch (IOException ioe) {
 155                 // For debug logging only, so please swallow exceptions.
 156                 return ioe.getMessage();
 157             }
 158         }
 159     }
 160 
 161     static enum NamedGroupType {
 162         NAMED_GROUP_ECDHE     (&quot;EC&quot;),
 163         NAMED_GROUP_FFDHE     (&quot;DiffieHellman&quot;),
 164         NAMED_GROUP_X25519    (&quot;x25519&quot;),
 165         NAMED_GROUP_X448      (&quot;x448&quot;),
 166         NAMED_GROUP_ARBITRARY (&quot;EC&quot;),
 167         NAMED_GROUP_NONE      (&quot;&quot;);
 168 
 169         private final String algorithm;
 170 
 171         private NamedGroupType(String algorithm) {
 172             this.algorithm = algorithm;
 173         }
 174 
 175         boolean isSupported(List&lt;CipherSuite&gt; cipherSuites) {
 176             for (CipherSuite cs : cipherSuites) {
 177                 if (cs.keyExchange == null ||
 178                         cs.keyExchange.groupType == this) {
 179                     return true;
 180                 }
 181             }
 182 
 183             return false;
 184         }
 185     }
 186 
 187     static enum NamedGroup {
 188         // Elliptic Curves (RFC 4492)
 189         //
 190         // See sun.security.util.CurveDB for the OIDs
 191         // NIST K-163
 192         SECT163_K1  (0x0001, &quot;sect163k1&quot;, &quot;1.3.132.0.1&quot;,
 193                             NamedGroupType.NAMED_GROUP_ECDHE,
 194                             ProtocolVersion.PROTOCOLS_TO_12),
 195         SECT163_R1  (0x0002, &quot;sect163r1&quot;, &quot;1.3.132.0.2&quot;,
 196                             NamedGroupType.NAMED_GROUP_ECDHE,
 197                             ProtocolVersion.PROTOCOLS_TO_12),
 198 
 199         // NIST B-163
 200         SECT163_R2  (0x0003, &quot;sect163r2&quot;, &quot;1.3.132.0.15&quot;,
 201                             NamedGroupType.NAMED_GROUP_ECDHE,
 202                             ProtocolVersion.PROTOCOLS_TO_12),
 203         SECT193_R1  (0x0004, &quot;sect193r1&quot;, &quot;1.3.132.0.24&quot;,
 204                             NamedGroupType.NAMED_GROUP_ECDHE,
 205                             ProtocolVersion.PROTOCOLS_TO_12),
 206         SECT193_R2  (0x0005, &quot;sect193r2&quot;, &quot;1.3.132.0.25&quot;,
 207                             NamedGroupType.NAMED_GROUP_ECDHE,
 208                             ProtocolVersion.PROTOCOLS_TO_12),
 209 
 210         // NIST K-233
 211         SECT233_K1  (0x0006, &quot;sect233k1&quot;, &quot;1.3.132.0.26&quot;,
 212                             NamedGroupType.NAMED_GROUP_ECDHE,
 213                             ProtocolVersion.PROTOCOLS_TO_12),
 214 
 215         // NIST B-233
 216         SECT233_R1  (0x0007, &quot;sect233r1&quot;, &quot;1.3.132.0.27&quot;,
 217                             NamedGroupType.NAMED_GROUP_ECDHE,
 218                             ProtocolVersion.PROTOCOLS_TO_12),
 219         SECT239_K1  (0x0008, &quot;sect239k1&quot;, &quot;1.3.132.0.3&quot;,
 220                             NamedGroupType.NAMED_GROUP_ECDHE,
 221                             ProtocolVersion.PROTOCOLS_TO_12),
 222 
 223         // NIST K-283
 224         SECT283_K1  (0x0009, &quot;sect283k1&quot;, &quot;1.3.132.0.16&quot;,
 225                             NamedGroupType.NAMED_GROUP_ECDHE,
 226                             ProtocolVersion.PROTOCOLS_TO_12),
 227 
 228         // NIST B-283
 229         SECT283_R1  (0x000A, &quot;sect283r1&quot;, &quot;1.3.132.0.17&quot;,
 230                             NamedGroupType.NAMED_GROUP_ECDHE,
 231                             ProtocolVersion.PROTOCOLS_TO_12),
 232 
 233         // NIST K-409
 234         SECT409_K1  (0x000B, &quot;sect409k1&quot;, &quot;1.3.132.0.36&quot;,
 235                             NamedGroupType.NAMED_GROUP_ECDHE,
 236                             ProtocolVersion.PROTOCOLS_TO_12),
 237 
 238         // NIST B-409
 239         SECT409_R1  (0x000C, &quot;sect409r1&quot;, &quot;1.3.132.0.37&quot;,
 240                             NamedGroupType.NAMED_GROUP_ECDHE,
 241                             ProtocolVersion.PROTOCOLS_TO_12),
 242 
 243         // NIST K-571
 244         SECT571_K1  (0x000D, &quot;sect571k1&quot;, &quot;1.3.132.0.38&quot;,
 245                             NamedGroupType.NAMED_GROUP_ECDHE,
 246                             ProtocolVersion.PROTOCOLS_TO_12),
 247 
 248         // NIST B-571
 249         SECT571_R1  (0x000E, &quot;sect571r1&quot;, &quot;1.3.132.0.39&quot;,
 250                             NamedGroupType.NAMED_GROUP_ECDHE,
 251                             ProtocolVersion.PROTOCOLS_TO_12),
 252         SECP160_K1  (0x000F, &quot;secp160k1&quot;, &quot;1.3.132.0.9&quot;,
 253                             NamedGroupType.NAMED_GROUP_ECDHE,
 254                             ProtocolVersion.PROTOCOLS_TO_12),
 255         SECP160_R1  (0x0010, &quot;secp160r1&quot;, &quot;1.3.132.0.8&quot;,
 256                             NamedGroupType.NAMED_GROUP_ECDHE,
 257                             ProtocolVersion.PROTOCOLS_TO_12),
 258         SECP160_R2  (0x0011, &quot;secp160r2&quot;, &quot;1.3.132.0.30&quot;,
 259                             NamedGroupType.NAMED_GROUP_ECDHE,
 260                             ProtocolVersion.PROTOCOLS_TO_12),
 261         SECP192_K1  (0x0012, &quot;secp192k1&quot;, &quot;1.3.132.0.31&quot;,
 262                             NamedGroupType.NAMED_GROUP_ECDHE,
 263                             ProtocolVersion.PROTOCOLS_TO_12),
 264 
 265         // NIST P-192
 266         SECP192_R1  (0x0013, &quot;secp192r1&quot;, &quot;1.2.840.10045.3.1.1&quot;,
 267                             NamedGroupType.NAMED_GROUP_ECDHE,
 268                             ProtocolVersion.PROTOCOLS_TO_12),
 269         SECP224_K1  (0x0014, &quot;secp224k1&quot;, &quot;1.3.132.0.32&quot;,
 270                             NamedGroupType.NAMED_GROUP_ECDHE,
 271                             ProtocolVersion.PROTOCOLS_TO_12),
 272         // NIST P-224
 273         SECP224_R1  (0x0015, &quot;secp224r1&quot;, &quot;1.3.132.0.33&quot;,
 274                             NamedGroupType.NAMED_GROUP_ECDHE,
 275                             ProtocolVersion.PROTOCOLS_TO_12),
 276         SECP256_K1  (0x0016, &quot;secp256k1&quot;, &quot;1.3.132.0.10&quot;,
 277                             NamedGroupType.NAMED_GROUP_ECDHE,
 278                             ProtocolVersion.PROTOCOLS_TO_12),
 279 
 280         // NIST P-256
 281         SECP256_R1  (0x0017, &quot;secp256r1&quot;, &quot;1.2.840.10045.3.1.7&quot;,
 282                             NamedGroupType.NAMED_GROUP_ECDHE,
 283                             ProtocolVersion.PROTOCOLS_TO_13),
 284 
 285         // NIST P-384
 286         SECP384_R1  (0x0018, &quot;secp384r1&quot;, &quot;1.3.132.0.34&quot;,
 287                             NamedGroupType.NAMED_GROUP_ECDHE,
 288                             ProtocolVersion.PROTOCOLS_TO_13),
 289 
 290         // NIST P-521
 291         SECP521_R1  (0x0019, &quot;secp521r1&quot;, &quot;1.3.132.0.35&quot;,
 292                             NamedGroupType.NAMED_GROUP_ECDHE,
 293                             ProtocolVersion.PROTOCOLS_TO_13),
 294 
 295         // x25519 and x448
 296         X25519      (0x001D, &quot;x25519&quot;, null,
 297                             NamedGroupType.NAMED_GROUP_X25519,
 298                             ProtocolVersion.PROTOCOLS_TO_13),
 299         X448        (0x001E, &quot;x448&quot;, null,
 300                             NamedGroupType.NAMED_GROUP_X448,
 301                             ProtocolVersion.PROTOCOLS_TO_13),
 302 
 303         // Finite Field Diffie-Hellman Ephemeral Parameters (RFC 7919)
 304         FFDHE_2048  (0x0100, &quot;ffdhe2048&quot;, null,
 305                             NamedGroupType.NAMED_GROUP_FFDHE,
 306                             ProtocolVersion.PROTOCOLS_TO_13),
 307         FFDHE_3072  (0x0101, &quot;ffdhe3072&quot;, null,
 308                             NamedGroupType.NAMED_GROUP_FFDHE,
 309                             ProtocolVersion.PROTOCOLS_TO_13),
 310         FFDHE_4096  (0x0102, &quot;ffdhe4096&quot;, null,
 311                             NamedGroupType.NAMED_GROUP_FFDHE,
 312                             ProtocolVersion.PROTOCOLS_TO_13),
 313         FFDHE_6144  (0x0103, &quot;ffdhe6144&quot;, null,
 314                             NamedGroupType.NAMED_GROUP_FFDHE,
 315                             ProtocolVersion.PROTOCOLS_TO_13),
 316         FFDHE_8192  (0x0104, &quot;ffdhe8192&quot;, null,
 317                             NamedGroupType.NAMED_GROUP_FFDHE,
 318                             ProtocolVersion.PROTOCOLS_TO_13),
 319 
 320         // Elliptic Curves (RFC 4492)
 321         //
 322         // arbitrary prime and characteristic-2 curves
 323         ARBITRARY_PRIME  (0xFF01, &quot;arbitrary_explicit_prime_curves&quot;, null,
 324                             NamedGroupType.NAMED_GROUP_ARBITRARY,
 325                             ProtocolVersion.PROTOCOLS_TO_12),
 326         ARBITRARY_CHAR2  (0xFF02, &quot;arbitrary_explicit_char2_curves&quot;, null,
 327                             NamedGroupType.NAMED_GROUP_ARBITRARY,
 328                             ProtocolVersion.PROTOCOLS_TO_12);
 329 
 330         final int id;               // hash + signature
 331         final NamedGroupType type;  // group type
 332         final String name;          // literal name
 333         final String oid;           // object identifier of the named group
 334         final String algorithm;     // signature algorithm
 335         final ProtocolVersion[] supportedProtocols;
 336 
 337         private NamedGroup(int id, String name, String oid,
 338                 NamedGroupType namedGroupType,
 339                 ProtocolVersion[] supportedProtocols) {
 340             this.id = id;
 341             this.type = namedGroupType;
 342             this.name = name;
 343             this.oid = oid;
 344             this.algorithm = namedGroupType.algorithm;
 345             this.supportedProtocols = supportedProtocols;
 346         }
 347 
 348         static NamedGroup valueOf(int id) {
 349             for (NamedGroup group : NamedGroup.values()) {
 350                 if (group.id == id) {
 351                     return group;
 352                 }
 353             }
 354 
 355             return null;
 356         }
 357 
 358         static NamedGroup valueOf(ECParameterSpec params) {
 359             String oid = ECUtil.getCurveName(null, params);
 360             if ((oid != null) &amp;&amp; (!oid.isEmpty())) {
 361                 for (NamedGroup group : NamedGroup.values()) {
 362                     if ((group.type == NamedGroupType.NAMED_GROUP_ECDHE) &amp;&amp;
 363                             oid.equals(group.oid)) {
 364                         return group;
 365                     }
 366                 }
 367             }
 368 
 369             return null;
 370         }
 371 
 372         static NamedGroup valueOf(DHParameterSpec params) {
 373             for (Map.Entry&lt;NamedGroup, AlgorithmParameters&gt; me :
 374                     SupportedGroups.namedGroupParams.entrySet()) {
 375                 NamedGroup ng = me.getKey();
 376                 if (ng.type != NamedGroupType.NAMED_GROUP_FFDHE) {
 377                     continue;
 378                 }
 379 
 380                 DHParameterSpec ngParams = null;
 381                 AlgorithmParameters aps = me.getValue();
 382                 try {
 383                     ngParams = aps.getParameterSpec(DHParameterSpec.class);
 384                 } catch (InvalidParameterSpecException ipse) {
 385                     // should be unlikely
 386                 }
 387 
 388                 if (ngParams == null) {
 389                     continue;
 390                 }
 391 
 392                 if (ngParams.getP().equals(params.getP()) &amp;&amp;
 393                         ngParams.getG().equals(params.getG())) {
 394                     return ng;
 395                 }
 396             }
 397 
 398             return null;
 399         }
 400 
 401         static NamedGroup nameOf(String name) {
 402             for (NamedGroup group : NamedGroup.values()) {
 403                 if (group.name.equals(name)) {
 404                     return group;
 405                 }
 406             }
 407 
 408             return null;
 409         }
 410 
 411         static String nameOf(int id) {
 412             for (NamedGroup group : NamedGroup.values()) {
 413                 if (group.id == id) {
 414                     return group.name;
 415                 }
 416             }
 417 
 418             return &quot;UNDEFINED-NAMED-GROUP(&quot; + id + &quot;)&quot;;
 419         }
 420 
 421         boolean isAvailable(List&lt;ProtocolVersion&gt; protocolVersions) {
 422             for (ProtocolVersion pv : supportedProtocols) {
 423                 if (protocolVersions.contains(pv)) {
 424                     return true;
 425                 }
 426             }
 427             return false;
 428         }
 429 
 430         boolean isAvailable(ProtocolVersion protocolVersion) {
 431             for (ProtocolVersion pv : supportedProtocols) {
 432                 if (protocolVersion == pv) {
 433                     return true;
 434                 }
 435             }
 436             return false;
 437         }
 438 
 439         boolean isSupported(List&lt;CipherSuite&gt; cipherSuites) {
 440             for (CipherSuite cs : cipherSuites) {
 441                 boolean isMatch = isAvailable(cs.supportedProtocols);
 442                 if (isMatch &amp;&amp; (cs.keyExchange == null ||
 443                         cs.keyExchange.groupType == type)) {
 444                     return true;
 445                 }
 446             }
 447             return false;
 448         }
 449 
 450         // lazy loading of parameters
 451         AlgorithmParameters getParameters() {
 452             return SupportedGroups.namedGroupParams.get(this);
 453         }
 454 
 455         AlgorithmParameterSpec getParameterSpec() {
 456             if (this.type == NamedGroupType.NAMED_GROUP_ECDHE) {
 457                 return SupportedGroups.getECGenParamSpec(this);
 458             } else if (this.type == NamedGroupType.NAMED_GROUP_FFDHE) {
 459                 return SupportedGroups.getDHParameterSpec(this);
 460             }
 461 
 462             return null;
 463         }
 464     }
 465 
 466     static class SupportedGroups {
 467         // To switch off the supported_groups extension for DHE cipher suite.
 468         static final boolean enableFFDHE =
 469                 Utilities.getBooleanProperty(&quot;jsse.enableFFDHE&quot;, true);
 470 
 471         // cache to speed up the parameters construction
 472         static final Map&lt;NamedGroup,
 473                     AlgorithmParameters&gt; namedGroupParams = new HashMap&lt;&gt;();
 474 
 475         // the supported named groups
 476         static final NamedGroup[] supportedNamedGroups;
 477 
 478         static {
 479             // The value of the System Property defines a list of enabled named
 480             // groups in preference order, separated with comma.  For example:
 481             //
 482             //      jdk.tls.namedGroups=&quot;secp521r1, secp256r1, ffdhe2048&quot;
 483             //
 484             // If the System Property is not defined or the value is empty, the
 485             // default groups and preferences will be used.
 486             String property = GetPropertyAction
 487                     .privilegedGetProperty(&quot;jdk.tls.namedGroups&quot;);
 488             if (property != null &amp;&amp; !property.isEmpty()) {
 489                 // remove double quote marks from beginning/end of the property
 490                 if (property.length() &gt; 1 &amp;&amp; property.charAt(0) == &#39;&quot;&#39; &amp;&amp;
 491                         property.charAt(property.length() - 1) == &#39;&quot;&#39;) {
 492                     property = property.substring(1, property.length() - 1);
 493                 }
 494             }
 495 
 496             ArrayList&lt;NamedGroup&gt; groupList;
 497             if (property != null &amp;&amp; !property.isEmpty()) {
 498                 String[] groups = property.split(&quot;,&quot;);
 499                 groupList = new ArrayList&lt;&gt;(groups.length);
 500                 for (String group : groups) {
 501                     group = group.trim();
 502                     if (!group.isEmpty()) {
 503                         NamedGroup namedGroup = NamedGroup.nameOf(group);
 504                         if (namedGroup != null) {
 505                             if (isAvailableGroup(namedGroup)) {
 506                                 groupList.add(namedGroup);
 507                             }
 508                         }   // ignore unknown groups
 509                     }
 510                 }
 511 
 512                 if (groupList.isEmpty()) {
 513                     throw new IllegalArgumentException(
 514                             &quot;System property jdk.tls.namedGroups(&quot; +
 515                             property + &quot;) contains no supported named groups&quot;);
 516                 }
 517             } else {        // default groups
 518                 NamedGroup[] groups = new NamedGroup[] {
 519                         // NIST curves first
 520                         NamedGroup.SECP256_R1,
 521                         NamedGroup.SECP384_R1,
 522                         NamedGroup.SECP521_R1,
 523                         NamedGroup.SECT283_K1,
 524                         NamedGroup.SECT283_R1,
 525                         NamedGroup.SECT409_K1,
 526                         NamedGroup.SECT409_R1,
 527                         NamedGroup.SECT571_K1,
 528                         NamedGroup.SECT571_R1,
 529 
 530                         // non-NIST curves
 531                         NamedGroup.SECP256_K1,
 532 
 533                         // FFDHE 2048
 534                         NamedGroup.FFDHE_2048,
 535                         NamedGroup.FFDHE_3072,
 536                         NamedGroup.FFDHE_4096,
 537                         NamedGroup.FFDHE_6144,
 538                         NamedGroup.FFDHE_8192,
 539                     };
 540 
 541                 groupList = new ArrayList&lt;&gt;(groups.length);
 542                 for (NamedGroup group : groups) {
 543                     if (isAvailableGroup(group)) {
 544                         groupList.add(group);
 545                     }
 546                 }
 547 
 548                 if (groupList.isEmpty() &amp;&amp;
 549                         SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 550                     SSLLogger.warning(&quot;No default named groups&quot;);
 551                 }
 552             }
 553 
 554             supportedNamedGroups = new NamedGroup[groupList.size()];
 555             int i = 0;
 556             for (NamedGroup namedGroup : groupList) {
 557                 supportedNamedGroups[i++] = namedGroup;
 558             }
 559         }
 560 
 561         // check whether the group is supported by the underlying providers
 562         private static boolean isAvailableGroup(NamedGroup namedGroup) {
 563             AlgorithmParameters params = null;
 564             AlgorithmParameterSpec spec = null;
 565             if (namedGroup.type == NamedGroupType.NAMED_GROUP_ECDHE) {
 566                 if (namedGroup.oid != null) {
 567                     try {
 568                         params = AlgorithmParameters.getInstance(&quot;EC&quot;);
 569                         spec = new ECGenParameterSpec(namedGroup.oid);
 570                     } catch (NoSuchAlgorithmException e) {
 571                         return false;
 572                     }
 573                 }
 574             } else if (namedGroup.type == NamedGroupType.NAMED_GROUP_FFDHE) {
 575                 try {
 576                     params = AlgorithmParameters.getInstance(&quot;DiffieHellman&quot;);
 577                     spec = getFFDHEDHParameterSpec(namedGroup);
 578                 } catch (NoSuchAlgorithmException e) {
 579                     return false;
 580                 }
 581             }   // Otherwise, unsupported.
 582 
 583             if ((params != null) &amp;&amp; (spec != null)) {
 584                 try {
 585                     params.init(spec);
 586                 } catch (InvalidParameterSpecException e) {
 587                     return false;
 588                 }
 589 
 590                 // cache the parameters
 591                 namedGroupParams.put(namedGroup, params);
 592 
 593                 return true;
 594             }
 595 
 596             return false;
 597         }
 598 
 599         private static DHParameterSpec getFFDHEDHParameterSpec(
 600                 NamedGroup namedGroup) {
 601             DHParameterSpec spec = null;
 602             switch (namedGroup) {
 603                 case FFDHE_2048:
 604                     spec = PredefinedDHParameterSpecs.ffdheParams.get(2048);
 605                     break;
 606                 case FFDHE_3072:
 607                     spec = PredefinedDHParameterSpecs.ffdheParams.get(3072);
 608                     break;
 609                 case FFDHE_4096:
 610                     spec = PredefinedDHParameterSpecs.ffdheParams.get(4096);
 611                     break;
 612                 case FFDHE_6144:
 613                     spec = PredefinedDHParameterSpecs.ffdheParams.get(6144);
 614                     break;
 615                 case FFDHE_8192:
 616                     spec = PredefinedDHParameterSpecs.ffdheParams.get(8192);
 617             }
 618 
 619             return spec;
 620         }
 621 
 622         private static DHParameterSpec getPredefinedDHParameterSpec(
 623                 NamedGroup namedGroup) {
 624             DHParameterSpec spec = null;
 625             switch (namedGroup) {
 626                 case FFDHE_2048:
 627                     spec = PredefinedDHParameterSpecs.definedParams.get(2048);
 628                     break;
 629                 case FFDHE_3072:
 630                     spec = PredefinedDHParameterSpecs.definedParams.get(3072);
 631                     break;
 632                 case FFDHE_4096:
 633                     spec = PredefinedDHParameterSpecs.definedParams.get(4096);
 634                     break;
 635                 case FFDHE_6144:
 636                     spec = PredefinedDHParameterSpecs.definedParams.get(6144);
 637                     break;
 638                 case FFDHE_8192:
 639                     spec = PredefinedDHParameterSpecs.definedParams.get(8192);
 640             }
 641 
 642             return spec;
 643         }
 644 
 645         static ECGenParameterSpec getECGenParamSpec(NamedGroup namedGroup) {
 646             if (namedGroup.type != NamedGroupType.NAMED_GROUP_ECDHE) {
 647                 throw new RuntimeException(
 648                         &quot;Not a named EC group: &quot; + namedGroup);
 649             }
 650 
 651             AlgorithmParameters params = namedGroupParams.get(namedGroup);
 652             if (params == null) {
 653                 throw new RuntimeException(
 654                         &quot;Not a supported EC named group: &quot; + namedGroup);
 655             }
 656 
 657             try {
 658                 return params.getParameterSpec(ECGenParameterSpec.class);
 659             } catch (InvalidParameterSpecException ipse) {
 660                 // should be unlikely
 661                 return new ECGenParameterSpec(namedGroup.oid);
 662             }
 663         }
 664 
 665         static DHParameterSpec getDHParameterSpec(NamedGroup namedGroup) {
 666             if (namedGroup.type != NamedGroupType.NAMED_GROUP_FFDHE) {
 667                 throw new RuntimeException(
 668                         &quot;Not a named DH group: &quot; + namedGroup);
 669             }
 670 
 671             AlgorithmParameters params = namedGroupParams.get(namedGroup);
 672             if (params == null) {
 673                 throw new RuntimeException(
 674                         &quot;Not a supported DH named group: &quot; + namedGroup);
 675             }
 676 
 677             try {
 678                 return params.getParameterSpec(DHParameterSpec.class);
 679             } catch (InvalidParameterSpecException ipse) {
 680                 // should be unlikely
 681                 return getPredefinedDHParameterSpec(namedGroup);
 682             }
 683         }
 684 
 685         // Is there any supported group permitted by the constraints?
 686         static boolean isActivatable(
 687                 AlgorithmConstraints constraints, NamedGroupType type) {
 688 
 689             boolean hasFFDHEGroups = false;
 690             for (NamedGroup namedGroup : supportedNamedGroups) {
 691                 if (namedGroup.type == type) {
 692                     if (constraints.permits(
 693                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 694                             namedGroup.algorithm,
 695                             namedGroupParams.get(namedGroup))) {
 696 
 697                         return true;
 698                     }
 699 
 700                     if (!hasFFDHEGroups &amp;&amp;
 701                             (type == NamedGroupType.NAMED_GROUP_FFDHE)) {
 702                         hasFFDHEGroups = true;
 703                     }
 704                 }
 705             }
 706 
 707             // For compatibility, if no FFDHE groups are defined, the non-FFDHE
 708             // compatible mode (using DHE cipher suite without FFDHE extension)
 709             // is allowed.
 710             //
 711             // Note that the constraints checking on DHE parameters will be
 712             // performed during key exchanging in a handshake.
 713             return !hasFFDHEGroups &amp;&amp; type == NamedGroupType.NAMED_GROUP_FFDHE;
 714         }
 715 
 716         // Is the named group permitted by the constraints?
 717         static boolean isActivatable(
 718                 AlgorithmConstraints constraints, NamedGroup namedGroup) {
 719             if (!isSupported(namedGroup)) {
 720                 return false;
 721             }
 722 
 723             return constraints.permits(
 724                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 725                             namedGroup.algorithm,
 726                             namedGroupParams.get(namedGroup));
 727         }
 728 
 729         // Is the named group supported?
 730         static boolean isSupported(NamedGroup namedGroup) {
 731             for (NamedGroup group : supportedNamedGroups) {
 732                 if (namedGroup.id == group.id) {
 733                     return true;
 734                 }
 735             }
 736 
 737             return false;
 738         }
 739 
 740         static NamedGroup getPreferredGroup(
 741                 ProtocolVersion negotiatedProtocol,
 742                 AlgorithmConstraints constraints, NamedGroupType type,
 743                 List&lt;NamedGroup&gt; requestedNamedGroups) {
 744             for (NamedGroup namedGroup : requestedNamedGroups) {
 745                 if ((namedGroup.type == type) &amp;&amp;
 746                         namedGroup.isAvailable(negotiatedProtocol) &amp;&amp;
 747                         isSupported(namedGroup) &amp;&amp;
 748                         constraints.permits(
 749                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 750                                 namedGroup.algorithm,
 751                                 namedGroupParams.get(namedGroup))) {
 752                     return namedGroup;
 753                 }
 754             }
 755 
 756             return null;
 757         }
 758 
 759         static NamedGroup getPreferredGroup(
 760                 ProtocolVersion negotiatedProtocol,
 761                 AlgorithmConstraints constraints, NamedGroupType type) {
 762             for (NamedGroup namedGroup : supportedNamedGroups) {
 763                 if ((namedGroup.type == type) &amp;&amp;
 764                         namedGroup.isAvailable(negotiatedProtocol) &amp;&amp;
 765                         constraints.permits(
 766                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 767                                 namedGroup.algorithm,
 768                                 namedGroupParams.get(namedGroup))) {
 769                     return namedGroup;
 770                 }
 771             }
 772 
 773             return null;
 774         }
 775     }
 776 
 777     /**
 778      * Network data producer of a &quot;supported_groups&quot; extension in
 779      * the ClientHello handshake message.
 780      */
 781     private static final class CHSupportedGroupsProducer
 782             extends SupportedGroups implements HandshakeProducer {
 783         // Prevent instantiation of this class.
 784         private CHSupportedGroupsProducer() {
 785             // blank
 786         }
 787 
 788         @Override
 789         public byte[] produce(ConnectionContext context,
 790                 HandshakeMessage message) throws IOException {
 791             // The producing happens in client side only.
 792             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 793 
 794             // Is it a supported and enabled extension?
 795             if (!chc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
 796                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 797                     SSLLogger.fine(
 798                         &quot;Ignore unavailable supported_groups extension&quot;);
 799                 }
 800                 return null;
 801             }
 802 
 803             // Produce the extension.
 804             ArrayList&lt;NamedGroup&gt; namedGroups =
 805                 new ArrayList&lt;&gt;(SupportedGroups.supportedNamedGroups.length);
 806             for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {
 807                 if ((!SupportedGroups.enableFFDHE) &amp;&amp;
 808                     (ng.type == NamedGroupType.NAMED_GROUP_FFDHE)) {
 809                     continue;
 810                 }
 811 
 812                 if (ng.isAvailable(chc.activeProtocols) &amp;&amp;
 813                         ng.isSupported(chc.activeCipherSuites) &amp;&amp;
 814                         chc.algorithmConstraints.permits(
 815                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 816                             ng.algorithm, namedGroupParams.get(ng))) {
 817                     namedGroups.add(ng);
 818                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 819                     SSLLogger.fine(
 820                         &quot;Ignore inactive or disabled named group: &quot; + ng.name);
 821                 }
 822             }
 823 
 824             if (namedGroups.isEmpty()) {
 825                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 826                     SSLLogger.warning(&quot;no available named group&quot;);
 827                 }
 828 
 829                 return null;
 830             }
 831 
 832             int vectorLen = namedGroups.size() &lt;&lt; 1;
 833             byte[] extData = new byte[vectorLen + 2];
 834             ByteBuffer m = ByteBuffer.wrap(extData);
 835             Record.putInt16(m, vectorLen);
 836             for (NamedGroup namedGroup : namedGroups) {
 837                     Record.putInt16(m, namedGroup.id);
 838             }
 839 
 840             // Update the context.
 841             chc.clientRequestedNamedGroups =
 842                     Collections.&lt;NamedGroup&gt;unmodifiableList(namedGroups);
 843             chc.handshakeExtensions.put(CH_SUPPORTED_GROUPS,
 844                     new SupportedGroupsSpec(namedGroups));
 845 
 846             return extData;
 847         }
 848     }
 849 
 850     /**
 851      * Network data producer of a &quot;supported_groups&quot; extension in
 852      * the ClientHello handshake message.
 853      */
 854     private static final
 855             class CHSupportedGroupsConsumer implements ExtensionConsumer {
 856         // Prevent instantiation of this class.
 857         private CHSupportedGroupsConsumer() {
 858             // blank
 859         }
 860 
 861         @Override
 862         public void consume(ConnectionContext context,
 863             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 864             // The consuming happens in server side only.
 865             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 866 
 867             // Is it a supported and enabled extension?
 868             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
 869                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 870                     SSLLogger.fine(
 871                         &quot;Ignore unavailable supported_groups extension&quot;);
 872                 }
 873                 return;     // ignore the extension
 874             }
 875 
 876             // Parse the extension.
 877             SupportedGroupsSpec spec;
 878             try {
 879                 spec = new SupportedGroupsSpec(buffer);
 880             } catch (IOException ioe) {
 881                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 882             }
 883 
 884             // Update the context.
 885             List&lt;NamedGroup&gt; knownNamedGroups = new LinkedList&lt;&gt;();
 886             for (int id : spec.namedGroupsIds) {
 887                 NamedGroup ng = NamedGroup.valueOf(id);
 888                 if (ng != null) {
 889                     knownNamedGroups.add(ng);
 890                 }
 891             }
 892 
 893             shc.clientRequestedNamedGroups = knownNamedGroups;
 894             shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);
 895 
 896             // No impact on session resumption.
 897         }
 898     }
 899 
 900     /**
 901      * Network data producer of a &quot;supported_groups&quot; extension in
 902      * the EncryptedExtensions handshake message.
 903      */
 904     private static final class EESupportedGroupsProducer
 905             extends SupportedGroups implements HandshakeProducer {
 906 
 907         // Prevent instantiation of this class.
 908         private EESupportedGroupsProducer() {
 909             // blank
 910         }
 911 
 912         @Override
 913         public byte[] produce(ConnectionContext context,
 914                 HandshakeMessage message) throws IOException {
 915             // The producing happens in server side only.
 916             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 917 
 918             // Is it a supported and enabled extension?
 919             if (!shc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
 920                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 921                     SSLLogger.fine(
 922                         &quot;Ignore unavailable supported_groups extension&quot;);
 923                 }
 924                 return null;
 925             }
 926 
 927             // Produce the extension.
 928             //
 929             // Contains all groups the server supports, regardless of whether
 930             // they are currently supported by the client.
 931             ArrayList&lt;NamedGroup&gt; namedGroups = new ArrayList&lt;&gt;(
 932                     SupportedGroups.supportedNamedGroups.length);
 933             for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {
 934                 if ((!SupportedGroups.enableFFDHE) &amp;&amp;
 935                     (ng.type == NamedGroupType.NAMED_GROUP_FFDHE)) {
 936                     continue;
 937                 }
 938 
 939                 if (ng.isAvailable(shc.activeProtocols) &amp;&amp;
 940                         ng.isSupported(shc.activeCipherSuites) &amp;&amp;
 941                         shc.algorithmConstraints.permits(
 942                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 943                             ng.algorithm, namedGroupParams.get(ng))) {
 944                     namedGroups.add(ng);
 945                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 946                     SSLLogger.fine(
 947                         &quot;Ignore inactive or disabled named group: &quot; + ng.name);
 948                 }
 949             }
 950 
 951             if (namedGroups.isEmpty()) {
 952                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 953                     SSLLogger.warning(&quot;no available named group&quot;);
 954                 }
 955 
 956                 return null;
 957             }
 958 
 959             int vectorLen = namedGroups.size() &lt;&lt; 1;
 960             byte[] extData = new byte[vectorLen + 2];
 961             ByteBuffer m = ByteBuffer.wrap(extData);
 962             Record.putInt16(m, vectorLen);
 963             for (NamedGroup namedGroup : namedGroups) {
 964                     Record.putInt16(m, namedGroup.id);
 965             }
 966 
 967             // Update the context.
 968             shc.conContext.serverRequestedNamedGroups =
 969                     Collections.&lt;NamedGroup&gt;unmodifiableList(namedGroups);
 970             SupportedGroupsSpec spec = new SupportedGroupsSpec(namedGroups);
 971             shc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
 972 
 973             return extData;
 974         }
 975     }
 976 
 977     private static final
 978             class EESupportedGroupsConsumer implements ExtensionConsumer {
 979         // Prevent instantiation of this class.
 980         private EESupportedGroupsConsumer() {
 981             // blank
 982         }
 983 
 984         @Override
 985         public void consume(ConnectionContext context,
 986             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 987             // The consuming happens in client side only.
 988             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 989 
 990             // Is it a supported and enabled extension?
 991             if (!chc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
 992                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 993                     SSLLogger.fine(
 994                         &quot;Ignore unavailable supported_groups extension&quot;);
 995                 }
 996                 return;     // ignore the extension
 997             }
 998 
 999             // Parse the extension.
1000             SupportedGroupsSpec spec;
1001             try {
1002                 spec = new SupportedGroupsSpec(buffer);
1003             } catch (IOException ioe) {
1004                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
1005             }
1006 
1007             // Update the context.
1008             List&lt;NamedGroup&gt; knownNamedGroups =
1009                     new ArrayList&lt;&gt;(spec.namedGroupsIds.length);
1010             for (int id : spec.namedGroupsIds) {
1011                 NamedGroup ng = NamedGroup.valueOf(id);
1012                 if (ng != null) {
1013                     knownNamedGroups.add(ng);
1014                 }
1015             }
1016 
1017             chc.conContext.serverRequestedNamedGroups = knownNamedGroups;
1018             chc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
1019 
1020             // No impact on session resumption.
1021         }
1022     }
1023 }
    </pre>
  </body>
</html>
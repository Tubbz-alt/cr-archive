<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/www/http/HttpClient.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ChunkedOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeepAliveCache.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/http/HttpClient.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 690         } catch (SocketTimeoutException stex) {
 691             // We don&#39;t want to retry the request when the app. sets a timeout
 692             // but don&#39;t close the server if timeout while waiting for 100-continue
 693             if (ignoreContinue) {
 694                 closeServer();
 695             }
 696             throw stex;
 697         } catch (IOException e) {
 698             closeServer();
 699             cachedHttpClient = false;
 700             if (!failedOnce &amp;&amp; requests != null) {
 701                 failedOnce = true;
 702                 if (getRequestMethod().equals(&quot;CONNECT&quot;)
 703                     || streaming
 704                     || (httpuc.getRequestMethod().equals(&quot;POST&quot;)
 705                         &amp;&amp; !retryPostProp)) {
 706                     // do not retry the request
 707                 }  else {
 708                     // try once more
 709                     openServer();
<span class="line-modified"> 710                     if (needsTunneling()) {</span>
<span class="line-removed"> 711                         MessageHeader origRequests = requests;</span>
<span class="line-removed"> 712                         httpuc.doTunneling();</span>
<span class="line-removed"> 713                         requests = origRequests;</span>
<span class="line-removed"> 714                     }</span>
 715                     afterConnect();
 716                     writeRequests(requests, poster);
 717                     return parseHTTP(responses, pi, httpuc);
 718                 }
 719             }
 720             throw e;
 721         }
 722 
 723     }
 724 












 725     private boolean parseHTTPHeader(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)
 726     throws IOException {
 727         /* If &quot;HTTP/*&quot; is found in the beginning, return true.  Let
 728          * HttpURLConnection parse the mime header itself.
 729          *
 730          * If this isn&#39;t valid HTTP, then we don&#39;t try to parse a header
 731          * out of the beginning of the response into the responses,
 732          * and instead just queue up the output stream to it&#39;s very beginning.
 733          * This seems most reasonable, and is what the NN browser does.
 734          */
 735 
 736         keepAliveConnections = -1;
 737         keepAliveTimeout = 0;
 738 
 739         boolean ret = false;
 740         byte[] b = new byte[8];
 741 
 742         try {
 743             int nread = 0;
 744             serverInput.mark(10);
</pre>
<hr />
<pre>
 832                          * Paranoia: if there is any Connection header then
 833                          * treat as non-persistent.
 834                          */
 835                         keepAliveConnections = 1;
 836                     } else {
 837                         keepAliveConnections = 5;
 838                     }
 839                 }
 840             } else if (nread != 8) {
 841                 if (!failedOnce &amp;&amp; requests != null) {
 842                     failedOnce = true;
 843                     if (getRequestMethod().equals(&quot;CONNECT&quot;)
 844                         || streaming
 845                         || (httpuc.getRequestMethod().equals(&quot;POST&quot;)
 846                             &amp;&amp; !retryPostProp)) {
 847                         // do not retry the request
 848                     } else {
 849                         closeServer();
 850                         cachedHttpClient = false;
 851                         openServer();
<span class="line-modified"> 852                         if (needsTunneling()) {</span>
<span class="line-removed"> 853                             MessageHeader origRequests = requests;</span>
<span class="line-removed"> 854                             httpuc.doTunneling();</span>
<span class="line-removed"> 855                             requests = origRequests;</span>
<span class="line-removed"> 856                         }</span>
 857                         afterConnect();
 858                         writeRequests(requests, poster);
 859                         return parseHTTP(responses, pi, httpuc);
 860                     }
 861                 }
 862                 throw new SocketException(&quot;Unexpected end of file from server&quot;);
 863             } else {
 864                 // we can&#39;t vouche for what this is....
 865                 responses.set(&quot;Content-type&quot;, &quot;unknown/unknown&quot;);
 866             }
 867         } catch (IOException e) {
 868             throw e;
 869         }
 870 
 871         int code = -1;
 872         try {
 873             String resp;
 874             resp = responses.getValue(0);
 875             /* should have no leading/trailing LWS
 876              * expedite the typical case by assuming it has
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 690         } catch (SocketTimeoutException stex) {
 691             // We don&#39;t want to retry the request when the app. sets a timeout
 692             // but don&#39;t close the server if timeout while waiting for 100-continue
 693             if (ignoreContinue) {
 694                 closeServer();
 695             }
 696             throw stex;
 697         } catch (IOException e) {
 698             closeServer();
 699             cachedHttpClient = false;
 700             if (!failedOnce &amp;&amp; requests != null) {
 701                 failedOnce = true;
 702                 if (getRequestMethod().equals(&quot;CONNECT&quot;)
 703                     || streaming
 704                     || (httpuc.getRequestMethod().equals(&quot;POST&quot;)
 705                         &amp;&amp; !retryPostProp)) {
 706                     // do not retry the request
 707                 }  else {
 708                     // try once more
 709                     openServer();
<span class="line-modified"> 710                     checkTunneling(httpuc);</span>




 711                     afterConnect();
 712                     writeRequests(requests, poster);
 713                     return parseHTTP(responses, pi, httpuc);
 714                 }
 715             }
 716             throw e;
 717         }
 718 
 719     }
 720 
<span class="line-added"> 721     // Check whether tunnel must be open and open it if necessary</span>
<span class="line-added"> 722     // (in the case of HTTPS with proxy)</span>
<span class="line-added"> 723     private void checkTunneling(HttpURLConnection httpuc) throws IOException {</span>
<span class="line-added"> 724         if (needsTunneling()) {</span>
<span class="line-added"> 725             MessageHeader origRequests = requests;</span>
<span class="line-added"> 726             PosterOutputStream origPoster = poster;</span>
<span class="line-added"> 727             httpuc.doTunneling();</span>
<span class="line-added"> 728             requests = origRequests;</span>
<span class="line-added"> 729             poster = origPoster;</span>
<span class="line-added"> 730         }</span>
<span class="line-added"> 731     }</span>
<span class="line-added"> 732 </span>
 733     private boolean parseHTTPHeader(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)
 734     throws IOException {
 735         /* If &quot;HTTP/*&quot; is found in the beginning, return true.  Let
 736          * HttpURLConnection parse the mime header itself.
 737          *
 738          * If this isn&#39;t valid HTTP, then we don&#39;t try to parse a header
 739          * out of the beginning of the response into the responses,
 740          * and instead just queue up the output stream to it&#39;s very beginning.
 741          * This seems most reasonable, and is what the NN browser does.
 742          */
 743 
 744         keepAliveConnections = -1;
 745         keepAliveTimeout = 0;
 746 
 747         boolean ret = false;
 748         byte[] b = new byte[8];
 749 
 750         try {
 751             int nread = 0;
 752             serverInput.mark(10);
</pre>
<hr />
<pre>
 840                          * Paranoia: if there is any Connection header then
 841                          * treat as non-persistent.
 842                          */
 843                         keepAliveConnections = 1;
 844                     } else {
 845                         keepAliveConnections = 5;
 846                     }
 847                 }
 848             } else if (nread != 8) {
 849                 if (!failedOnce &amp;&amp; requests != null) {
 850                     failedOnce = true;
 851                     if (getRequestMethod().equals(&quot;CONNECT&quot;)
 852                         || streaming
 853                         || (httpuc.getRequestMethod().equals(&quot;POST&quot;)
 854                             &amp;&amp; !retryPostProp)) {
 855                         // do not retry the request
 856                     } else {
 857                         closeServer();
 858                         cachedHttpClient = false;
 859                         openServer();
<span class="line-modified"> 860                         checkTunneling(httpuc);</span>




 861                         afterConnect();
 862                         writeRequests(requests, poster);
 863                         return parseHTTP(responses, pi, httpuc);
 864                     }
 865                 }
 866                 throw new SocketException(&quot;Unexpected end of file from server&quot;);
 867             } else {
 868                 // we can&#39;t vouche for what this is....
 869                 responses.set(&quot;Content-type&quot;, &quot;unknown/unknown&quot;);
 870             }
 871         } catch (IOException e) {
 872             throw e;
 873         }
 874 
 875         int code = -1;
 876         try {
 877             String resp;
 878             resp = responses.getValue(0);
 879             /* should have no leading/trailing LWS
 880              * expedite the typical case by assuming it has
</pre>
</td>
</tr>
</table>
<center><a href="ChunkedOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeepAliveCache.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
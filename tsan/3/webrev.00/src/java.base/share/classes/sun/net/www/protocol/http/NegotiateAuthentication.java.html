<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www.protocol.http;
 27 
 28 import java.net.URL;
 29 import java.io.IOException;
 30 import java.net.Authenticator.RequestorType;
 31 import java.util.Base64;
 32 import java.util.HashMap;
 33 import sun.net.www.HeaderParser;
 34 import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
 35 import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
 36 import sun.security.action.GetPropertyAction;
 37 
 38 /**
 39  * NegotiateAuthentication:
 40  *
 41  * @author weijun.wang@sun.com
 42  * @since 1.6
 43  */
 44 
 45 class NegotiateAuthentication extends AuthenticationInfo {
 46 
 47     @java.io.Serial
 48     private static final long serialVersionUID = 100L;
 49 
 50     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 51     private final HttpCallerInfo hci;
 52 
 53     // These maps are used to manage the GSS availability for diffrent
 54     // hosts. The key for both maps is the host name.
 55     // &lt;code&gt;supported&lt;/code&gt; is set when isSupported is checked,
 56     // if it&#39;s true, a cached Negotiator is put into &lt;code&gt;cache&lt;/code&gt;.
 57     // the cache can be used only once, so after the first use, it&#39;s cleaned.
 58     static HashMap &lt;String, Boolean&gt; supported = null;
 59     static ThreadLocal &lt;HashMap &lt;String, Negotiator&gt;&gt; cache = null;
 60     /* Whether cache is enabled for Negotiate/Kerberos */
 61     private static final boolean cacheSPNEGO;
 62     static {
 63         String spnegoCacheProp =
 64             GetPropertyAction.privilegedGetProperty(&quot;jdk.spnego.cache&quot;, &quot;true&quot;);
 65         cacheSPNEGO = Boolean.parseBoolean(spnegoCacheProp);
 66     }
 67 
 68     // The HTTP Negotiate Helper
 69     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 70     private Negotiator negotiator = null;
 71 
 72    /**
 73     * Constructor used for both WWW and proxy entries.
 74     * @param hci a schemed object.
 75     */
 76     public NegotiateAuthentication(HttpCallerInfo hci) {
 77         super(RequestorType.PROXY==hci.authType ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION,
 78               hci.scheme.equalsIgnoreCase(&quot;Negotiate&quot;) ? NEGOTIATE : KERBEROS,
 79               hci.url,
 80               &quot;&quot;,
 81               AuthenticatorKeys.getKey(hci.authenticator));
 82         this.hci = hci;
 83     }
 84 
 85     /**
 86      * @return true if this authentication supports preemptive authorization
 87      */
 88     @Override
 89     public boolean supportsPreemptiveAuthorization() {
 90         return false;
 91     }
 92 
 93     /**
 94      * Find out if the HttpCallerInfo supports Negotiate protocol. In order to
 95      * find out yes or no, an initialization of a Negotiator object against it
 96      * is tried. The generated object will be cached under the name of ths
 97      * hostname at a success try.&lt;br&gt;
 98      *
 99      * If this method is called for the second time on an HttpCallerInfo with
100      * the same hostname, the answer is retrieved from cache.
101      *
102      * @return true if supported
103      */
104     synchronized public static boolean isSupported(HttpCallerInfo hci) {
105         if (supported == null) {
106             supported = new HashMap&lt;&gt;();
107         }
108         String hostname = hci.host;
109         hostname = hostname.toLowerCase();
110         if (supported.containsKey(hostname)) {
111             return supported.get(hostname);
112         }
113 
114         Negotiator neg = Negotiator.getNegotiator(hci);
115         if (neg != null) {
116             supported.put(hostname, true);
117             // the only place cache.put is called. here we can make sure
118             // the object is valid and the oneToken inside is not null
119             if (cache == null) {
120                 cache = new ThreadLocal&lt;&gt;() {
121                     @Override
122                     protected HashMap&lt;String, Negotiator&gt; initialValue() {
123                         return new HashMap&lt;&gt;();
124                     }
125                 };
126             }
127             cache.get().put(hostname, neg);
128             return true;
129         } else {
130             supported.put(hostname, false);
131             return false;
132         }
133     }
134 
135     private static synchronized HashMap&lt;String, Negotiator&gt; getCache() {
136         if (cache == null) return null;
137         return cache.get();
138     }
139 
140     @Override
141     protected boolean useAuthCache() {
142         return super.useAuthCache() &amp;&amp; cacheSPNEGO;
143     }
144 
145     /**
146      * Not supported. Must use the setHeaders() method
147      */
148     @Override
149     public String getHeaderValue(URL url, String method) {
150         throw new RuntimeException (&quot;getHeaderValue not supported&quot;);
151     }
152 
153     /**
154      * Check if the header indicates that the current auth. parameters are stale.
155      * If so, then replace the relevant field with the new value
156      * and return true. Otherwise return false.
157      * returning true means the request can be retried with the same userid/password
158      * returning false means we have to go back to the user to ask for a new
159      * username password.
160      */
161     @Override
162     public boolean isAuthorizationStale (String header) {
163         return false; /* should not be called for Negotiate */
164     }
165 
166     /**
167      * Set header(s) on the given connection.
168      * @param conn The connection to apply the header(s) to
169      * @param p A source of header values for this connection, not used because
170      *          HeaderParser converts the fields to lower case, use raw instead
171      * @param raw The raw header field.
172      * @return true if all goes well, false if no headers were set.
173      */
174     @Override
175     public synchronized boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {
176 
177         try {
178             String response;
179             byte[] incoming = null;
180             String[] parts = raw.split(&quot;\\s+&quot;);
181             if (parts.length &gt; 1) {
182                 incoming = Base64.getDecoder().decode(parts[1]);
183             }
184             response = hci.scheme + &quot; &quot; + Base64.getEncoder().encodeToString(
185                         incoming==null?firstToken():nextToken(incoming));
186 
187             conn.setAuthenticationProperty(getHeaderName(), response);
188             return true;
189         } catch (IOException e) {
190             return false;
191         }
192     }
193 
194     /**
195      * return the first token.
196      * @return the token
197      * @throws IOException if &lt;code&gt;Negotiator.getNegotiator()&lt;/code&gt; or
198      *                     &lt;code&gt;Negotiator.firstToken()&lt;/code&gt; failed.
199      */
200     private byte[] firstToken() throws IOException {
201         negotiator = null;
202         HashMap &lt;String, Negotiator&gt; cachedMap = getCache();
203         if (cachedMap != null) {
204             negotiator = cachedMap.get(getHost());
205             if (negotiator != null) {
206                 cachedMap.remove(getHost()); // so that it is only used once
207             }
208         }
209         if (negotiator == null) {
210             negotiator = Negotiator.getNegotiator(hci);
211             if (negotiator == null) {
212                 IOException ioe = new IOException(&quot;Cannot initialize Negotiator&quot;);
213                 throw ioe;
214             }
215         }
216 
217         return negotiator.firstToken();
218     }
219 
220     /**
221      * return more tokens
222      * @param token the token to be fed into &lt;code&gt;negotiator.nextToken()&lt;/code&gt;
223      * @return the token
224      * @throws IOException if &lt;code&gt;negotiator.nextToken()&lt;/code&gt; throws Exception.
225      *  May happen if the input token is invalid.
226      */
227     private byte[] nextToken(byte[] token) throws IOException {
228         return negotiator.nextToken(token);
229     }
230 
231     // MS will send a final WWW-Authenticate even if the status is already
232     // 200 OK. The token can be fed into initSecContext() again to determine
233     // if the server can be trusted. This is not the same concept as Digest&#39;s
234     // Authentication-Info header.
235     //
236     // Currently we ignore this header.
237 
238 }
    </pre>
  </body>
</html>
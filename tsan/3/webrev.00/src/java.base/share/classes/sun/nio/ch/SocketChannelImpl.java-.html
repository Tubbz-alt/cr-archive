<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
  31 import java.net.InetSocketAddress;
  32 import java.net.ProtocolFamily;
  33 import java.net.Socket;
  34 import java.net.SocketAddress;
  35 import java.net.SocketOption;
  36 import java.net.StandardProtocolFamily;
  37 import java.net.StandardSocketOptions;
  38 import java.nio.ByteBuffer;
  39 import java.nio.channels.AlreadyBoundException;
  40 import java.nio.channels.AlreadyConnectedException;
  41 import java.nio.channels.AsynchronousCloseException;
  42 import java.nio.channels.ClosedChannelException;
  43 import java.nio.channels.ConnectionPendingException;
  44 import java.nio.channels.NoConnectionPendingException;
  45 import java.nio.channels.NotYetConnectedException;
  46 import java.nio.channels.SelectionKey;
  47 import java.nio.channels.SocketChannel;
  48 import java.nio.channels.spi.SelectorProvider;
  49 import java.util.Collections;
  50 import java.util.HashSet;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.concurrent.locks.ReentrantLock;
  54 
  55 import sun.net.NetHooks;
  56 import sun.net.ext.ExtendedSocketOptions;
  57 import sun.net.util.SocketExceptions;
  58 
  59 /**
  60  * An implementation of SocketChannels
  61  */
  62 
  63 class SocketChannelImpl
  64     extends SocketChannel
  65     implements SelChImpl
  66 {
  67     // Used to make native read and write calls
  68     private static final NativeDispatcher nd = new SocketDispatcher();
  69 
  70     // Our file descriptor object
  71     private final FileDescriptor fd;
  72     private final int fdVal;
  73 
  74     // Lock held by current reading or connecting thread
  75     private final ReentrantLock readLock = new ReentrantLock();
  76 
  77     // Lock held by current writing or connecting thread
  78     private final ReentrantLock writeLock = new ReentrantLock();
  79 
  80     // Lock held by any thread that modifies the state fields declared below
  81     // DO NOT invoke a blocking I/O operation while holding this lock!
  82     private final Object stateLock = new Object();
  83 
  84     // Input/Output closed
  85     private volatile boolean isInputClosed;
  86     private volatile boolean isOutputClosed;
  87 
  88     // -- The following fields are protected by stateLock
  89 
  90     // set true when exclusive binding is on and SO_REUSEADDR is emulated
  91     private boolean isReuseAddress;
  92 
  93     // State, increases monotonically
  94     private static final int ST_UNCONNECTED = 0;
  95     private static final int ST_CONNECTIONPENDING = 1;
  96     private static final int ST_CONNECTED = 2;
  97     private static final int ST_CLOSING = 3;
  98     private static final int ST_KILLPENDING = 4;
  99     private static final int ST_KILLED = 5;
 100     private volatile int state;  // need stateLock to change
 101 
 102     // IDs of native threads doing reads and writes, for signalling
 103     private long readerThread;
 104     private long writerThread;
 105 
 106     // Binding
 107     private InetSocketAddress localAddress;
 108     private InetSocketAddress remoteAddress;
 109 
 110     // Socket adaptor, created on demand
 111     private Socket socket;
 112 
 113     // -- End of fields protected by stateLock
 114 
 115 
 116     // Constructor for normal connecting sockets
 117     //
 118     SocketChannelImpl(SelectorProvider sp) throws IOException {
 119         super(sp);
 120         this.fd = Net.socket(true);
 121         this.fdVal = IOUtil.fdVal(fd);
 122     }
 123 
 124     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
 125         throws IOException
 126     {
 127         super(sp);
 128         this.fd = fd;
 129         this.fdVal = IOUtil.fdVal(fd);
 130         if (bound) {
 131             synchronized (stateLock) {
 132                 this.localAddress = Net.localAddress(fd);
 133             }
 134         }
 135     }
 136 
 137     // Constructor for sockets obtained from server sockets
 138     //
 139     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, InetSocketAddress isa)
 140         throws IOException
 141     {
 142         super(sp);
 143         this.fd = fd;
 144         this.fdVal = IOUtil.fdVal(fd);
 145         synchronized (stateLock) {
 146             this.localAddress = Net.localAddress(fd);
 147             this.remoteAddress = isa;
 148             this.state = ST_CONNECTED;
 149         }
 150     }
 151 
 152     /**
 153      * Checks that the channel is open.
 154      *
 155      * @throws ClosedChannelException if channel is closed (or closing)
 156      */
 157     private void ensureOpen() throws ClosedChannelException {
 158         if (!isOpen())
 159             throw new ClosedChannelException();
 160     }
 161 
 162     /**
 163      * Checks that the channel is open and connected.
 164      *
 165      * @apiNote This method uses the &quot;state&quot; field to check if the channel is
 166      * open. It should never be used in conjuncion with isOpen or ensureOpen
 167      * as these methods check AbstractInterruptibleChannel&#39;s closed field - that
 168      * field is set before implCloseSelectableChannel is called and so before
 169      * the state is changed.
 170      *
 171      * @throws ClosedChannelException if channel is closed (or closing)
 172      * @throws NotYetConnectedException if open and not connected
 173      */
 174     private void ensureOpenAndConnected() throws ClosedChannelException {
 175         int state = this.state;
 176         if (state &lt; ST_CONNECTED) {
 177             throw new NotYetConnectedException();
 178         } else if (state &gt; ST_CONNECTED) {
 179             throw new ClosedChannelException();
 180         }
 181     }
 182 
 183     @Override
 184     public Socket socket() {
 185         synchronized (stateLock) {
 186             if (socket == null)
 187                 socket = SocketAdaptor.create(this);
 188             return socket;
 189         }
 190     }
 191 
 192     @Override
 193     public SocketAddress getLocalAddress() throws IOException {
 194         synchronized (stateLock) {
 195             ensureOpen();
 196             return Net.getRevealedLocalAddress(localAddress);
 197         }
 198     }
 199 
 200     @Override
 201     public SocketAddress getRemoteAddress() throws IOException {
 202         synchronized (stateLock) {
 203             ensureOpen();
 204             return remoteAddress;
 205         }
 206     }
 207 
 208     @Override
 209     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 210         throws IOException
 211     {
 212         Objects.requireNonNull(name);
 213         if (!supportedOptions().contains(name))
 214             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 215 
 216         synchronized (stateLock) {
 217             ensureOpen();
 218 
 219             if (name == StandardSocketOptions.IP_TOS) {
 220                 ProtocolFamily family = Net.isIPv6Available() ?
 221                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 222                 Net.setSocketOption(fd, family, name, value);
 223                 return this;
 224             }
 225 
 226             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 227                 // SO_REUSEADDR emulated when using exclusive bind
 228                 isReuseAddress = (Boolean)value;
 229                 return this;
 230             }
 231 
 232             // no options that require special handling
 233             Net.setSocketOption(fd, Net.UNSPEC, name, value);
 234             return this;
 235         }
 236     }
 237 
 238     @Override
 239     @SuppressWarnings(&quot;unchecked&quot;)
 240     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 241         throws IOException
 242     {
 243         Objects.requireNonNull(name);
 244         if (!supportedOptions().contains(name))
 245             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 246 
 247         synchronized (stateLock) {
 248             ensureOpen();
 249 
 250             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 251                 // SO_REUSEADDR emulated when using exclusive bind
 252                 return (T)Boolean.valueOf(isReuseAddress);
 253             }
 254 
 255             // special handling for IP_TOS: always return 0 when IPv6
 256             if (name == StandardSocketOptions.IP_TOS) {
 257                 ProtocolFamily family = Net.isIPv6Available() ?
 258                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 259                 return (T) Net.getSocketOption(fd, family, name);
 260             }
 261 
 262             // no options that require special handling
 263             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
 264         }
 265     }
 266 
 267     private static class DefaultOptionsHolder {
 268         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 269 
 270         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 271             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 272             set.add(StandardSocketOptions.SO_SNDBUF);
 273             set.add(StandardSocketOptions.SO_RCVBUF);
 274             set.add(StandardSocketOptions.SO_KEEPALIVE);
 275             set.add(StandardSocketOptions.SO_REUSEADDR);
 276             if (Net.isReusePortAvailable()) {
 277                 set.add(StandardSocketOptions.SO_REUSEPORT);
 278             }
 279             set.add(StandardSocketOptions.SO_LINGER);
 280             set.add(StandardSocketOptions.TCP_NODELAY);
 281             // additional options required by socket adaptor
 282             set.add(StandardSocketOptions.IP_TOS);
 283             set.add(ExtendedSocketOption.SO_OOBINLINE);
 284             set.addAll(ExtendedSocketOptions.clientSocketOptions());
 285             return Collections.unmodifiableSet(set);
 286         }
 287     }
 288 
 289     @Override
 290     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 291         return DefaultOptionsHolder.defaultOptions;
 292     }
 293 
 294     /**
 295      * Marks the beginning of a read operation that might block.
 296      *
 297      * @throws ClosedChannelException if the channel is closed
 298      * @throws NotYetConnectedException if the channel is not yet connected
 299      */
 300     private void beginRead(boolean blocking) throws ClosedChannelException {
 301         if (blocking) {
 302             // set hook for Thread.interrupt
 303             begin();
 304 
 305             synchronized (stateLock) {
 306                 ensureOpenAndConnected();
 307                 // record thread so it can be signalled if needed
 308                 readerThread = NativeThread.current();
 309             }
 310         } else {
 311             ensureOpenAndConnected();
 312         }
 313     }
 314 
 315     /**
 316      * Marks the end of a read operation that may have blocked.
 317      *
 318      * @throws AsynchronousCloseException if the channel was closed due to this
 319      * thread being interrupted on a blocking read operation.
 320      */
 321     private void endRead(boolean blocking, boolean completed)
 322         throws AsynchronousCloseException
 323     {
 324         if (blocking) {
 325             synchronized (stateLock) {
 326                 readerThread = 0;
 327                 // notify any thread waiting in implCloseSelectableChannel
 328                 if (state == ST_CLOSING) {
 329                     stateLock.notifyAll();
 330                 }
 331             }
 332             // remove hook for Thread.interrupt
 333             end(completed);
 334         }
 335     }
 336 
 337     @Override
 338     public int read(ByteBuffer buf) throws IOException {
 339         Objects.requireNonNull(buf);
 340 
 341         readLock.lock();
 342         try {
 343             boolean blocking = isBlocking();
 344             int n = 0;
 345             try {
 346                 beginRead(blocking);
 347 
 348                 // check if input is shutdown
 349                 if (isInputClosed)
 350                     return IOStatus.EOF;
 351 
 352                 if (blocking) {
 353                     do {
 354                         n = IOUtil.read(fd, buf, -1, nd);
 355                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 356                 } else {
 357                     n = IOUtil.read(fd, buf, -1, nd);
 358                 }
 359             } finally {
 360                 endRead(blocking, n &gt; 0);
 361                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 362                     return IOStatus.EOF;
 363             }
 364             return IOStatus.normalize(n);
 365         } finally {
 366             readLock.unlock();
 367         }
 368     }
 369 
 370     @Override
 371     public long read(ByteBuffer[] dsts, int offset, int length)
 372         throws IOException
 373     {
 374         Objects.checkFromIndexSize(offset, length, dsts.length);
 375 
 376         readLock.lock();
 377         try {
 378             boolean blocking = isBlocking();
 379             long n = 0;
 380             try {
 381                 beginRead(blocking);
 382 
 383                 // check if input is shutdown
 384                 if (isInputClosed)
 385                     return IOStatus.EOF;
 386 
 387                 if (blocking) {
 388                     do {
 389                         n = IOUtil.read(fd, dsts, offset, length, nd);
 390                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 391                 } else {
 392                     n = IOUtil.read(fd, dsts, offset, length, nd);
 393                 }
 394             } finally {
 395                 endRead(blocking, n &gt; 0);
 396                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 397                     return IOStatus.EOF;
 398             }
 399             return IOStatus.normalize(n);
 400         } finally {
 401             readLock.unlock();
 402         }
 403     }
 404 
 405     /**
 406      * Marks the beginning of a write operation that might block.
 407      *
 408      * @throws ClosedChannelException if the channel is closed or output shutdown
 409      * @throws NotYetConnectedException if the channel is not yet connected
 410      */
 411     private void beginWrite(boolean blocking) throws ClosedChannelException {
 412         if (blocking) {
 413             // set hook for Thread.interrupt
 414             begin();
 415 
 416             synchronized (stateLock) {
 417                 ensureOpenAndConnected();
 418                 if (isOutputClosed)
 419                     throw new ClosedChannelException();
 420                 // record thread so it can be signalled if needed
 421                 writerThread = NativeThread.current();
 422             }
 423         } else {
 424             ensureOpenAndConnected();
 425         }
 426     }
 427 
 428     /**
 429      * Marks the end of a write operation that may have blocked.
 430      *
 431      * @throws AsynchronousCloseException if the channel was closed due to this
 432      * thread being interrupted on a blocking write operation.
 433      */
 434     private void endWrite(boolean blocking, boolean completed)
 435         throws AsynchronousCloseException
 436     {
 437         if (blocking) {
 438             synchronized (stateLock) {
 439                 writerThread = 0;
 440                 // notify any thread waiting in implCloseSelectableChannel
 441                 if (state == ST_CLOSING) {
 442                     stateLock.notifyAll();
 443                 }
 444             }
 445             // remove hook for Thread.interrupt
 446             end(completed);
 447         }
 448     }
 449 
 450     @Override
 451     public int write(ByteBuffer buf) throws IOException {
 452         Objects.requireNonNull(buf);
 453 
 454         writeLock.lock();
 455         try {
 456             boolean blocking = isBlocking();
 457             int n = 0;
 458             try {
 459                 beginWrite(blocking);
 460                 if (blocking) {
 461                     do {
 462                         n = IOUtil.write(fd, buf, -1, nd);
 463                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 464                 } else {
 465                     n = IOUtil.write(fd, buf, -1, nd);
 466                 }
 467             } finally {
 468                 endWrite(blocking, n &gt; 0);
 469                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 470                     throw new AsynchronousCloseException();
 471             }
 472             return IOStatus.normalize(n);
 473         } finally {
 474             writeLock.unlock();
 475         }
 476     }
 477 
 478     @Override
 479     public long write(ByteBuffer[] srcs, int offset, int length)
 480         throws IOException
 481     {
 482         Objects.checkFromIndexSize(offset, length, srcs.length);
 483 
 484         writeLock.lock();
 485         try {
 486             boolean blocking = isBlocking();
 487             long n = 0;
 488             try {
 489                 beginWrite(blocking);
 490                 if (blocking) {
 491                     do {
 492                         n = IOUtil.write(fd, srcs, offset, length, nd);
 493                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 494                 } else {
 495                     n = IOUtil.write(fd, srcs, offset, length, nd);
 496                 }
 497             } finally {
 498                 endWrite(blocking, n &gt; 0);
 499                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 500                     throw new AsynchronousCloseException();
 501             }
 502             return IOStatus.normalize(n);
 503         } finally {
 504             writeLock.unlock();
 505         }
 506     }
 507 
 508     /**
 509      * Writes a byte of out of band data.
 510      */
 511     int sendOutOfBandData(byte b) throws IOException {
 512         writeLock.lock();
 513         try {
 514             boolean blocking = isBlocking();
 515             int n = 0;
 516             try {
 517                 beginWrite(blocking);
 518                 if (blocking) {
 519                     do {
 520                         n = Net.sendOOB(fd, b);
 521                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 522                 } else {
 523                     n = Net.sendOOB(fd, b);
 524                 }
 525             } finally {
 526                 endWrite(blocking, n &gt; 0);
 527                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 528                     throw new AsynchronousCloseException();
 529             }
 530             return IOStatus.normalize(n);
 531         } finally {
 532             writeLock.unlock();
 533         }
 534     }
 535 
 536     @Override
 537     protected void implConfigureBlocking(boolean block) throws IOException {
 538         readLock.lock();
 539         try {
 540             writeLock.lock();
 541             try {
 542                 synchronized (stateLock) {
 543                     ensureOpen();
 544                     IOUtil.configureBlocking(fd, block);
 545                 }
 546             } finally {
 547                 writeLock.unlock();
 548             }
 549         } finally {
 550             readLock.unlock();
 551         }
 552     }
 553 
 554     /**
 555      * Returns the local address, or null if not bound
 556      */
 557     InetSocketAddress localAddress() {
 558         synchronized (stateLock) {
 559             return localAddress;
 560         }
 561     }
 562 
 563     /**
 564      * Returns the remote address, or null if not connected
 565      */
 566     InetSocketAddress remoteAddress() {
 567         synchronized (stateLock) {
 568             return remoteAddress;
 569         }
 570     }
 571 
 572     @Override
 573     public SocketChannel bind(SocketAddress local) throws IOException {
 574         readLock.lock();
 575         try {
 576             writeLock.lock();
 577             try {
 578                 synchronized (stateLock) {
 579                     ensureOpen();
 580                     if (state == ST_CONNECTIONPENDING)
 581                         throw new ConnectionPendingException();
 582                     if (localAddress != null)
 583                         throw new AlreadyBoundException();
 584                     InetSocketAddress isa = (local == null) ?
 585                         new InetSocketAddress(0) : Net.checkAddress(local);
 586                     SecurityManager sm = System.getSecurityManager();
 587                     if (sm != null) {
 588                         sm.checkListen(isa.getPort());
 589                     }
 590                     NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
 591                     Net.bind(fd, isa.getAddress(), isa.getPort());
 592                     localAddress = Net.localAddress(fd);
 593                 }
 594             } finally {
 595                 writeLock.unlock();
 596             }
 597         } finally {
 598             readLock.unlock();
 599         }
 600         return this;
 601     }
 602 
 603     @Override
 604     public boolean isConnected() {
 605         return (state == ST_CONNECTED);
 606     }
 607 
 608     @Override
 609     public boolean isConnectionPending() {
 610         return (state == ST_CONNECTIONPENDING);
 611     }
 612 
 613     /**
 614      * Marks the beginning of a connect operation that might block.
 615      * @param blocking true if configured blocking
 616      * @param isa the remote address
 617      * @throws ClosedChannelException if the channel is closed
 618      * @throws AlreadyConnectedException if already connected
 619      * @throws ConnectionPendingException is a connection is pending
 620      * @throws IOException if the pre-connect hook fails
 621      */
 622     private void beginConnect(boolean blocking, InetSocketAddress isa)
 623         throws IOException
 624     {
 625         if (blocking) {
 626             // set hook for Thread.interrupt
 627             begin();
 628         }
 629         synchronized (stateLock) {
 630             ensureOpen();
 631             int state = this.state;
 632             if (state == ST_CONNECTED)
 633                 throw new AlreadyConnectedException();
 634             if (state == ST_CONNECTIONPENDING)
 635                 throw new ConnectionPendingException();
 636             assert state == ST_UNCONNECTED;
 637             this.state = ST_CONNECTIONPENDING;
 638 
 639             if (localAddress == null)
 640                 NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());
 641             remoteAddress = isa;
 642 
 643             if (blocking) {
 644                 // record thread so it can be signalled if needed
 645                 readerThread = NativeThread.current();
 646             }
 647         }
 648     }
 649 
 650     /**
 651      * Marks the end of a connect operation that may have blocked.
 652      *
 653      * @throws AsynchronousCloseException if the channel was closed due to this
 654      * thread being interrupted on a blocking connect operation.
 655      * @throws IOException if completed and unable to obtain the local address
 656      */
 657     private void endConnect(boolean blocking, boolean completed)
 658         throws IOException
 659     {
 660         endRead(blocking, completed);
 661 
 662         if (completed) {
 663             synchronized (stateLock) {
 664                 if (state == ST_CONNECTIONPENDING) {
 665                     localAddress = Net.localAddress(fd);
 666                     state = ST_CONNECTED;
 667                 }
 668             }
 669         }
 670     }
 671 
 672     @Override
 673     public boolean connect(SocketAddress sa) throws IOException {
 674         InetSocketAddress isa = Net.checkAddress(sa);
 675         SecurityManager sm = System.getSecurityManager();
 676         if (sm != null)
 677             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
 678 
 679         InetAddress ia = isa.getAddress();
 680         if (ia.isAnyLocalAddress())
 681             ia = InetAddress.getLocalHost();
 682 
 683         try {
 684             readLock.lock();
 685             try {
 686                 writeLock.lock();
 687                 try {
 688                     int n = 0;
 689                     boolean blocking = isBlocking();
 690                     try {
 691                         beginConnect(blocking, isa);
 692                         do {
 693                             n = Net.connect(fd, ia, isa.getPort());
 694                         } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 695                     } finally {
 696                         endConnect(blocking, (n &gt; 0));
 697                     }
 698                     assert IOStatus.check(n);
 699                     return n &gt; 0;
 700                 } finally {
 701                     writeLock.unlock();
 702                 }
 703             } finally {
 704                 readLock.unlock();
 705             }
 706         } catch (IOException ioe) {
 707             // connect failed, close the channel
 708             close();
 709             throw SocketExceptions.of(ioe, isa);
 710         }
 711     }
 712 
 713     /**
 714      * Marks the beginning of a finishConnect operation that might block.
 715      *
 716      * @throws ClosedChannelException if the channel is closed
 717      * @throws NoConnectionPendingException if no connection is pending
 718      */
 719     private void beginFinishConnect(boolean blocking) throws ClosedChannelException {
 720         if (blocking) {
 721             // set hook for Thread.interrupt
 722             begin();
 723         }
 724         synchronized (stateLock) {
 725             ensureOpen();
 726             if (state != ST_CONNECTIONPENDING)
 727                 throw new NoConnectionPendingException();
 728             if (blocking) {
 729                 // record thread so it can be signalled if needed
 730                 readerThread = NativeThread.current();
 731             }
 732         }
 733     }
 734 
 735     /**
 736      * Marks the end of a finishConnect operation that may have blocked.
 737      *
 738      * @throws AsynchronousCloseException if the channel was closed due to this
 739      * thread being interrupted on a blocking connect operation.
 740      * @throws IOException if completed and unable to obtain the local address
 741      */
 742     private void endFinishConnect(boolean blocking, boolean completed)
 743         throws IOException
 744     {
 745         endRead(blocking, completed);
 746 
 747         if (completed) {
 748             synchronized (stateLock) {
 749                 if (state == ST_CONNECTIONPENDING) {
 750                     localAddress = Net.localAddress(fd);
 751                     state = ST_CONNECTED;
 752                 }
 753             }
 754         }
 755     }
 756 
 757     @Override
 758     public boolean finishConnect() throws IOException {
 759         try {
 760             readLock.lock();
 761             try {
 762                 writeLock.lock();
 763                 try {
 764                     // no-op if already connected
 765                     if (isConnected())
 766                         return true;
 767 
 768                     boolean blocking = isBlocking();
 769                     boolean connected = false;
 770                     try {
 771                         beginFinishConnect(blocking);
 772                         int n = 0;
 773                         if (blocking) {
 774                             do {
 775                                 n = Net.pollConnect(fd, -1);
 776                             } while ((n == 0 || n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 777                         } else {
 778                             n = Net.pollConnect(fd, 0);
 779                         }
 780                         connected = (n &gt; 0);
 781                     } finally {
 782                         endFinishConnect(blocking, connected);
 783                     }
 784                     assert (blocking &amp;&amp; connected) ^ !blocking;
 785                     return connected;
 786                 } finally {
 787                     writeLock.unlock();
 788                 }
 789             } finally {
 790                 readLock.unlock();
 791             }
 792         } catch (IOException ioe) {
 793             // connect failed, close the channel
 794             close();
 795             throw SocketExceptions.of(ioe, remoteAddress);
 796         }
 797     }
 798 
 799     /**
 800      * Invoked by implCloseChannel to close the channel.
 801      *
 802      * This method waits for outstanding I/O operations to complete. When in
 803      * blocking mode, the socket is pre-closed and the threads in blocking I/O
 804      * operations are signalled to ensure that the outstanding I/O operations
 805      * complete quickly.
 806      *
 807      * If the socket is connected then it is shutdown by this method. The
 808      * shutdown ensures that the peer reads EOF for the case that the socket is
 809      * not pre-closed or closed by this method.
 810      *
 811      * The socket is closed by this method when it is not registered with a
 812      * Selector. Note that a channel configured blocking may be registered with
 813      * a Selector. This arises when a key is canceled and the channel configured
 814      * to blocking mode before the key is flushed from the Selector.
 815      */
 816     @Override
 817     protected void implCloseSelectableChannel() throws IOException {
 818         assert !isOpen();
 819 
 820         boolean blocking;
 821         boolean connected;
 822         boolean interrupted = false;
 823 
 824         // set state to ST_CLOSING
 825         synchronized (stateLock) {
 826             assert state &lt; ST_CLOSING;
 827             blocking = isBlocking();
 828             connected = (state == ST_CONNECTED);
 829             state = ST_CLOSING;
 830         }
 831 
 832         // wait for any outstanding I/O operations to complete
 833         if (blocking) {
 834             synchronized (stateLock) {
 835                 assert state == ST_CLOSING;
 836                 long reader = readerThread;
 837                 long writer = writerThread;
 838                 if (reader != 0 || writer != 0) {
 839                     nd.preClose(fd);
 840                     connected = false; // fd is no longer connected socket
 841 
 842                     if (reader != 0)
 843                         NativeThread.signal(reader);
 844                     if (writer != 0)
 845                         NativeThread.signal(writer);
 846 
 847                     // wait for blocking I/O operations to end
 848                     while (readerThread != 0 || writerThread != 0) {
 849                         try {
 850                             stateLock.wait();
 851                         } catch (InterruptedException e) {
 852                             interrupted = true;
 853                         }
 854                     }
 855                 }
 856             }
 857         } else {
 858             // non-blocking mode: wait for read/write to complete
 859             readLock.lock();
 860             try {
 861                 writeLock.lock();
 862                 writeLock.unlock();
 863             } finally {
 864                 readLock.unlock();
 865             }
 866         }
 867 
 868         // set state to ST_KILLPENDING
 869         synchronized (stateLock) {
 870             assert state == ST_CLOSING;
 871             // if connected and the channel is registered with a Selector then
 872             // shutdown the output if possible so that the peer reads EOF. If
 873             // SO_LINGER is enabled and set to a non-zero value then it needs to
 874             // be disabled so that the Selector does not wait when it closes
 875             // the socket.
 876             if (connected &amp;&amp; isRegistered()) {
 877                 try {
 878                     SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
 879                     int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
 880                     if (interval != 0) {
 881                         if (interval &gt; 0) {
 882                             // disable SO_LINGER
 883                             Net.setSocketOption(fd, Net.UNSPEC, opt, -1);
 884                         }
 885                         Net.shutdown(fd, Net.SHUT_WR);
 886                     }
 887                 } catch (IOException ignore) { }
 888             }
 889             state = ST_KILLPENDING;
 890         }
 891 
 892         // close socket if not registered with Selector
 893         if (!isRegistered())
 894             kill();
 895 
 896         // restore interrupt status
 897         if (interrupted)
 898             Thread.currentThread().interrupt();
 899     }
 900 
 901     @Override
 902     public void kill() throws IOException {
 903         synchronized (stateLock) {
 904             if (state == ST_KILLPENDING) {
 905                 state = ST_KILLED;
 906                 nd.close(fd);
 907             }
 908         }
 909     }
 910 
 911     @Override
 912     public SocketChannel shutdownInput() throws IOException {
 913         synchronized (stateLock) {
 914             ensureOpen();
 915             if (!isConnected())
 916                 throw new NotYetConnectedException();
 917             if (!isInputClosed) {
 918                 Net.shutdown(fd, Net.SHUT_RD);
 919                 long thread = readerThread;
 920                 if (thread != 0)
 921                     NativeThread.signal(thread);
 922                 isInputClosed = true;
 923             }
 924             return this;
 925         }
 926     }
 927 
 928     @Override
 929     public SocketChannel shutdownOutput() throws IOException {
 930         synchronized (stateLock) {
 931             ensureOpen();
 932             if (!isConnected())
 933                 throw new NotYetConnectedException();
 934             if (!isOutputClosed) {
 935                 Net.shutdown(fd, Net.SHUT_WR);
 936                 long thread = writerThread;
 937                 if (thread != 0)
 938                     NativeThread.signal(thread);
 939                 isOutputClosed = true;
 940             }
 941             return this;
 942         }
 943     }
 944 
 945     boolean isInputOpen() {
 946         return !isInputClosed;
 947     }
 948 
 949     boolean isOutputOpen() {
 950         return !isOutputClosed;
 951     }
 952 
 953     /**
 954      * Poll this channel&#39;s socket for reading up to the given timeout.
 955      * @return {@code true} if the socket is polled
 956      */
 957     boolean pollRead(long timeout) throws IOException {
 958         boolean blocking = isBlocking();
 959         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;
 960 
 961         readLock.lock();
 962         try {
 963             boolean polled = false;
 964             try {
 965                 beginRead(blocking);
 966                 int events = Net.poll(fd, Net.POLLIN, timeout);
 967                 polled = (events != 0);
 968             } finally {
 969                 endRead(blocking, polled);
 970             }
 971             return polled;
 972         } finally {
 973             readLock.unlock();
 974         }
 975     }
 976 
 977     /**
 978      * Poll this channel&#39;s socket for a connection, up to the given timeout.
 979      * @return {@code true} if the socket is polled
 980      */
 981     boolean pollConnected(long timeout) throws IOException {
 982         boolean blocking = isBlocking();
 983         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;
 984 
 985         readLock.lock();
 986         try {
 987             writeLock.lock();
 988             try {
 989                 boolean polled = false;
 990                 try {
 991                     beginFinishConnect(blocking);
 992                     int events = Net.poll(fd, Net.POLLCONN, timeout);
 993                     polled = (events != 0);
 994                 } finally {
 995                     // invoke endFinishConnect with completed = false so that
 996                     // the state is not changed to ST_CONNECTED. The socket
 997                     // adaptor will use finishConnect to finish.
 998                     endFinishConnect(blocking, /*completed*/false);
 999                 }
1000                 return polled;
1001             } finally {
1002                 writeLock.unlock();
1003             }
1004         } finally {
1005             readLock.unlock();
1006         }
1007     }
1008 
1009     /**
1010      * Translates native poll revent ops into a ready operation ops
1011      */
1012     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1013         int intOps = ski.nioInterestOps();
1014         int oldOps = ski.nioReadyOps();
1015         int newOps = initialOps;
1016 
1017         if ((ops &amp; Net.POLLNVAL) != 0) {
1018             // This should only happen if this channel is pre-closed while a
1019             // selection operation is in progress
1020             // ## Throw an error if this channel has not been pre-closed
1021             return false;
1022         }
1023 
1024         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1025             newOps = intOps;
1026             ski.nioReadyOps(newOps);
1027             return (newOps &amp; ~oldOps) != 0;
1028         }
1029 
1030         boolean connected = isConnected();
1031         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1032             ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp; connected)
1033             newOps |= SelectionKey.OP_READ;
1034 
1035         if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp;
1036             ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp; isConnectionPending())
1037             newOps |= SelectionKey.OP_CONNECT;
1038 
1039         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1040             ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp; connected)
1041             newOps |= SelectionKey.OP_WRITE;
1042 
1043         ski.nioReadyOps(newOps);
1044         return (newOps &amp; ~oldOps) != 0;
1045     }
1046 
1047     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1048         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1049     }
1050 
1051     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1052         return translateReadyOps(ops, 0, ski);
1053     }
1054 
1055     /**
1056      * Translates an interest operation set into a native poll event set
1057      */
1058     public int translateInterestOps(int ops) {
1059         int newOps = 0;
1060         if ((ops &amp; SelectionKey.OP_READ) != 0)
1061             newOps |= Net.POLLIN;
1062         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1063             newOps |= Net.POLLOUT;
1064         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1065             newOps |= Net.POLLCONN;
1066         return newOps;
1067     }
1068 
1069     public FileDescriptor getFD() {
1070         return fd;
1071     }
1072 
1073     public int getFDVal() {
1074         return fdVal;
1075     }
1076 
1077     @Override
1078     public String toString() {
1079         StringBuilder sb = new StringBuilder();
1080         sb.append(this.getClass().getSuperclass().getName());
1081         sb.append(&#39;[&#39;);
1082         if (!isOpen())
1083             sb.append(&quot;closed&quot;);
1084         else {
1085             synchronized (stateLock) {
1086                 switch (state) {
1087                 case ST_UNCONNECTED:
1088                     sb.append(&quot;unconnected&quot;);
1089                     break;
1090                 case ST_CONNECTIONPENDING:
1091                     sb.append(&quot;connection-pending&quot;);
1092                     break;
1093                 case ST_CONNECTED:
1094                     sb.append(&quot;connected&quot;);
1095                     if (isInputClosed)
1096                         sb.append(&quot; ishut&quot;);
1097                     if (isOutputClosed)
1098                         sb.append(&quot; oshut&quot;);
1099                     break;
1100                 }
1101                 InetSocketAddress addr = localAddress();
1102                 if (addr != null) {
1103                     sb.append(&quot; local=&quot;);
1104                     sb.append(Net.getRevealedLocalAddressAsString(addr));
1105                 }
1106                 if (remoteAddress() != null) {
1107                     sb.append(&quot; remote=&quot;);
1108                     sb.append(remoteAddress().toString());
1109                 }
1110             }
1111         }
1112         sb.append(&#39;]&#39;);
1113         return sb.toString();
1114     }
1115 }
    </pre>
  </body>
</html>
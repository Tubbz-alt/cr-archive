<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/Utilities.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="TrustStoreManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509Authentication.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/Utilities.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 44     /**
 45      * Puts {@code hostname} into the {@code serverNames} list.
 46      * &lt;P&gt;
 47      * If the {@code serverNames} does not look like a legal FQDN, it will
 48      * not be put into the returned list.
 49      * &lt;P&gt;
 50      * Note that the returned list does not allow duplicated name type.
 51      *
 52      * @return a list of {@link SNIServerName}
 53      */
 54     static List&lt;SNIServerName&gt; addToSNIServerNameList(
 55             List&lt;SNIServerName&gt; serverNames, String hostname) {
 56 
 57         SNIHostName sniHostName = rawToSNIHostName(hostname);
 58         if (sniHostName == null) {
 59             return serverNames;
 60         }
 61 
 62         int size = serverNames.size();
 63         List&lt;SNIServerName&gt; sniList = (size != 0) ?
<span class="line-modified"> 64                 new ArrayList&lt;SNIServerName&gt;(serverNames) :</span>
<span class="line-modified"> 65                 new ArrayList&lt;SNIServerName&gt;(1);</span>
 66 
 67         boolean reset = false;
 68         for (int i = 0; i &lt; size; i++) {
 69             SNIServerName serverName = sniList.get(i);
 70             if (serverName.getType() == StandardConstants.SNI_HOST_NAME) {
 71                 sniList.set(i, sniHostName);
 72                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 73                      SSLLogger.fine(
 74                         &quot;the previous server name in SNI (&quot; + serverName +
 75                         &quot;) was replaced with (&quot; + sniHostName + &quot;)&quot;);
 76                 }
 77                 reset = true;
 78                 break;
 79             }
 80         }
 81 
 82         if (!reset) {
 83             sniList.add(sniHostName);
 84         }
 85 
</pre>
<hr />
<pre>
130         String b = GetPropertyAction.privilegedGetProperty(propName);
131         if (b == null) {
132             return defaultValue;
133         } else if (b.equalsIgnoreCase(&quot;false&quot;)) {
134             return false;
135         } else if (b.equalsIgnoreCase(&quot;true&quot;)) {
136             return true;
137         } else {
138             throw new RuntimeException(&quot;Value of &quot; + propName
139                 + &quot; must either be &#39;true&#39; or &#39;false&#39;&quot;);
140         }
141     }
142 
143     static String indent(String source) {
144         return Utilities.indent(source, indent);
145     }
146 
147     static String indent(String source, String prefix) {
148         StringBuilder builder = new StringBuilder();
149         if (source == null) {
<span class="line-modified">150              builder.append(&quot;\n&quot; + prefix + &quot;&lt;blank message&gt;&quot;);</span>
151         } else {
152             String[] lines = lineBreakPatern.split(source);
153             boolean isFirst = true;
154             for (String line : lines) {
155                 if (isFirst) {
156                     isFirst = false;
157                 } else {
158                     builder.append(&quot;\n&quot;);
159                 }
160                 builder.append(prefix).append(line);
161             }
162         }
163 
164         return builder.toString();
165     }
166 
167     static String toHexString(byte b) {
168         return String.valueOf(hexDigits[(b &gt;&gt; 4) &amp; 0x0F]) +
169                 String.valueOf(hexDigits[b &amp; 0x0F]);
170     }
</pre>
<hr />
<pre>
215 
216         return builder.toString();
217     }
218 
219     /**
220      * Utility method to convert a BigInteger to a byte array in unsigned
221      * format as needed in the handshake messages. BigInteger uses
222      * 2&#39;s complement format, i.e. it prepends an extra zero if the MSB
223      * is set. We remove that.
224      */
225     static byte[] toByteArray(BigInteger bi) {
226         byte[] b = bi.toByteArray();
227         if ((b.length &gt; 1) &amp;&amp; (b[0] == 0)) {
228             int n = b.length - 1;
229             byte[] newarray = new byte[n];
230             System.arraycopy(b, 1, newarray, 0, n);
231             b = newarray;
232         }
233         return b;
234     }

















235 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 44     /**
 45      * Puts {@code hostname} into the {@code serverNames} list.
 46      * &lt;P&gt;
 47      * If the {@code serverNames} does not look like a legal FQDN, it will
 48      * not be put into the returned list.
 49      * &lt;P&gt;
 50      * Note that the returned list does not allow duplicated name type.
 51      *
 52      * @return a list of {@link SNIServerName}
 53      */
 54     static List&lt;SNIServerName&gt; addToSNIServerNameList(
 55             List&lt;SNIServerName&gt; serverNames, String hostname) {
 56 
 57         SNIHostName sniHostName = rawToSNIHostName(hostname);
 58         if (sniHostName == null) {
 59             return serverNames;
 60         }
 61 
 62         int size = serverNames.size();
 63         List&lt;SNIServerName&gt; sniList = (size != 0) ?
<span class="line-modified"> 64                 new ArrayList&lt;&gt;(serverNames) :</span>
<span class="line-modified"> 65                 new ArrayList&lt;&gt;(1);</span>
 66 
 67         boolean reset = false;
 68         for (int i = 0; i &lt; size; i++) {
 69             SNIServerName serverName = sniList.get(i);
 70             if (serverName.getType() == StandardConstants.SNI_HOST_NAME) {
 71                 sniList.set(i, sniHostName);
 72                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 73                      SSLLogger.fine(
 74                         &quot;the previous server name in SNI (&quot; + serverName +
 75                         &quot;) was replaced with (&quot; + sniHostName + &quot;)&quot;);
 76                 }
 77                 reset = true;
 78                 break;
 79             }
 80         }
 81 
 82         if (!reset) {
 83             sniList.add(sniHostName);
 84         }
 85 
</pre>
<hr />
<pre>
130         String b = GetPropertyAction.privilegedGetProperty(propName);
131         if (b == null) {
132             return defaultValue;
133         } else if (b.equalsIgnoreCase(&quot;false&quot;)) {
134             return false;
135         } else if (b.equalsIgnoreCase(&quot;true&quot;)) {
136             return true;
137         } else {
138             throw new RuntimeException(&quot;Value of &quot; + propName
139                 + &quot; must either be &#39;true&#39; or &#39;false&#39;&quot;);
140         }
141     }
142 
143     static String indent(String source) {
144         return Utilities.indent(source, indent);
145     }
146 
147     static String indent(String source, String prefix) {
148         StringBuilder builder = new StringBuilder();
149         if (source == null) {
<span class="line-modified">150              builder.append(&quot;\n&quot;).append(prefix).append(&quot;&lt;blank message&gt;&quot;);</span>
151         } else {
152             String[] lines = lineBreakPatern.split(source);
153             boolean isFirst = true;
154             for (String line : lines) {
155                 if (isFirst) {
156                     isFirst = false;
157                 } else {
158                     builder.append(&quot;\n&quot;);
159                 }
160                 builder.append(prefix).append(line);
161             }
162         }
163 
164         return builder.toString();
165     }
166 
167     static String toHexString(byte b) {
168         return String.valueOf(hexDigits[(b &gt;&gt; 4) &amp; 0x0F]) +
169                 String.valueOf(hexDigits[b &amp; 0x0F]);
170     }
</pre>
<hr />
<pre>
215 
216         return builder.toString();
217     }
218 
219     /**
220      * Utility method to convert a BigInteger to a byte array in unsigned
221      * format as needed in the handshake messages. BigInteger uses
222      * 2&#39;s complement format, i.e. it prepends an extra zero if the MSB
223      * is set. We remove that.
224      */
225     static byte[] toByteArray(BigInteger bi) {
226         byte[] b = bi.toByteArray();
227         if ((b.length &gt; 1) &amp;&amp; (b[0] == 0)) {
228             int n = b.length - 1;
229             byte[] newarray = new byte[n];
230             System.arraycopy(b, 1, newarray, 0, n);
231             b = newarray;
232         }
233         return b;
234     }
<span class="line-added">235 </span>
<span class="line-added">236     static void reverseBytes(byte[] arr) {</span>
<span class="line-added">237         int i = 0;</span>
<span class="line-added">238         int j = arr.length - 1;</span>
<span class="line-added">239 </span>
<span class="line-added">240         while (i &lt; j) {</span>
<span class="line-added">241             swap(arr, i, j);</span>
<span class="line-added">242             i++;</span>
<span class="line-added">243             j--;</span>
<span class="line-added">244         }</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
<span class="line-added">247     private static void swap(byte[] arr, int i, int j) {</span>
<span class="line-added">248         byte tmp = arr[i];</span>
<span class="line-added">249         arr[i] = arr[j];</span>
<span class="line-added">250         arr[j] = tmp;</span>
<span class="line-added">251     }</span>
252 }
</pre>
</td>
</tr>
</table>
<center><a href="TrustStoreManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509Authentication.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
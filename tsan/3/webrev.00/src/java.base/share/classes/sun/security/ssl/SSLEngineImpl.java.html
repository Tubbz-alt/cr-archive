<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.nio.ReadOnlyBufferException;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedActionException;
  33 import java.security.PrivilegedExceptionAction;
  34 import java.util.List;
  35 import java.util.Map;
  36 import java.util.concurrent.locks.ReentrantLock;
  37 import java.util.function.BiFunction;
  38 import javax.net.ssl.SSLEngine;
  39 import javax.net.ssl.SSLEngineResult;
  40 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  41 import javax.net.ssl.SSLEngineResult.Status;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLKeyException;
  45 import javax.net.ssl.SSLParameters;
  46 import javax.net.ssl.SSLPeerUnverifiedException;
  47 import javax.net.ssl.SSLProtocolException;
  48 import javax.net.ssl.SSLSession;
  49 
  50 /**
  51  * Implementation of an non-blocking SSLEngine.
  52  *
  53  * @author Brad Wetmore
  54  */
  55 final class SSLEngineImpl extends SSLEngine implements SSLTransport {
  56     private final SSLContextImpl        sslContext;
  57     final TransportContext              conContext;
  58     private final ReentrantLock         engineLock = new ReentrantLock();
  59 
  60     /**
  61      * Constructor for an SSLEngine from SSLContext, without
  62      * host/port hints.
  63      *
  64      * This Engine will not be able to cache sessions, but must renegotiate
  65      * everything by hand.
  66      */
  67     SSLEngineImpl(SSLContextImpl sslContext) {
  68         this(sslContext, null, -1);
  69     }
  70 
  71     /**
  72      * Constructor for an SSLEngine from SSLContext.
  73      */
  74     SSLEngineImpl(SSLContextImpl sslContext,
  75             String host, int port) {
  76         super(host, port);
  77         this.sslContext = sslContext;
  78         HandshakeHash handshakeHash = new HandshakeHash();
  79         if (sslContext.isDTLS()) {
  80             this.conContext = new TransportContext(sslContext, this,
  81                     new DTLSInputRecord(handshakeHash),
  82                     new DTLSOutputRecord(handshakeHash));
  83         } else {
  84             this.conContext = new TransportContext(sslContext, this,
  85                     new SSLEngineInputRecord(handshakeHash),
  86                     new SSLEngineOutputRecord(handshakeHash));
  87         }
  88 
  89         // Server name indication is a connection scope extension.
  90         if (host != null) {
  91             this.conContext.sslConfig.serverNames =
  92                     Utilities.addToSNIServerNameList(
  93                             conContext.sslConfig.serverNames, host);
  94         }
  95     }
  96 
  97     @Override
  98     public void beginHandshake() throws SSLException {
  99         engineLock.lock();
 100         try {
 101             if (conContext.isUnsureMode) {
 102                 throw new IllegalStateException(
 103                         &quot;Client/Server mode has not yet been set.&quot;);
 104             }
 105 
 106             try {
 107                 conContext.kickstart();
 108             } catch (IOException ioe) {
 109                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 110                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 111             } catch (Exception ex) {     // including RuntimeException
 112                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 113                     &quot;Fail to begin handshake&quot;, ex);
 114             }
 115         } finally {
 116             engineLock.unlock();
 117         }
 118     }
 119 
 120     @Override
 121     public SSLEngineResult wrap(ByteBuffer[] appData,
 122             int offset, int length, ByteBuffer netData) throws SSLException {
 123         return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
 124     }
 125 
 126     // @Override
 127     public SSLEngineResult wrap(
 128         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 129         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 130 
 131         engineLock.lock();
 132         try {
 133             if (conContext.isUnsureMode) {
 134                 throw new IllegalStateException(
 135                         &quot;Client/Server mode has not yet been set.&quot;);
 136             }
 137 
 138             // See if the handshaker needs to report back some SSLException.
 139             checkTaskThrown();
 140 
 141             // check parameters
 142             checkParams(srcs, srcsOffset, srcsLength,
 143                     dsts, dstsOffset, dstsLength);
 144 
 145             try {
 146                 return writeRecord(
 147                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 148             } catch (SSLProtocolException spe) {
 149                 // may be an unexpected handshake message
 150                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);
 151             } catch (IOException ioe) {
 152                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 153                     &quot;problem wrapping app data&quot;, ioe);
 154             } catch (Exception ex) {     // including RuntimeException
 155                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 156                     &quot;Fail to wrap application data&quot;, ex);
 157             }
 158         } finally {
 159             engineLock.unlock();
 160         }
 161     }
 162 
 163     private SSLEngineResult writeRecord(
 164         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 165         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 166 
 167         // May need to deliver cached records.
 168         if (isOutboundDone()) {
 169             return new SSLEngineResult(
 170                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 171         }
 172 
 173         HandshakeContext hc = conContext.handshakeContext;
 174         HandshakeStatus hsStatus = null;
 175         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 176                 !conContext.isInboundClosed() &amp;&amp;
 177                 !conContext.isOutboundClosed()) {
 178             conContext.kickstart();
 179 
 180             hsStatus = getHandshakeStatus();
 181             if (hsStatus == HandshakeStatus.NEED_UNWRAP) {
 182                 /*
 183                  * For DTLS, if the handshake state is
 184                  * HandshakeStatus.NEED_UNWRAP, a call to SSLEngine.wrap()
 185                  * means that the previous handshake packets (if delivered)
 186                  * get lost, and need retransmit the handshake messages.
 187                  */
 188                 if (!sslContext.isDTLS() || hc == null ||
 189                         !hc.sslConfig.enableRetransmissions ||
 190                         conContext.outputRecord.firstMessage) {
 191 
 192                     return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 193                 }   // otherwise, need retransmission
 194             }
 195         }
 196 
 197         if (hsStatus == null) {
 198             hsStatus = getHandshakeStatus();
 199         }
 200 
 201         /*
 202          * If we have a task outstanding, this *MUST* be done before
 203          * doing any more wrapping, because we could be in the middle
 204          * of receiving a handshake message, for example, a finished
 205          * message which would change the ciphers.
 206          */
 207         if (hsStatus == HandshakeStatus.NEED_TASK) {
 208             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 209         }
 210 
 211         int dstsRemains = 0;
 212         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 213             dstsRemains += dsts[i].remaining();
 214         }
 215 
 216         // Check destination buffer size.
 217         //
 218         // We can be smarter about using smaller buffer sizes later.  For
 219         // now, force it to be large enough to handle any valid record.
 220         if (dstsRemains &lt; conContext.conSession.getPacketBufferSize()) {
 221             return new SSLEngineResult(
 222                 Status.BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);
 223         }
 224 
 225         int srcsRemains = 0;
 226         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 227             srcsRemains += srcs[i].remaining();
 228         }
 229 
 230         Ciphertext ciphertext = null;
 231         try {
 232             // Acquire the buffered to-be-delivered records or retransmissions.
 233             //
 234             // May have buffered records, or need retransmission if handshaking.
 235             if (!conContext.outputRecord.isEmpty() || (hc != null &amp;&amp;
 236                     hc.sslConfig.enableRetransmissions &amp;&amp;
 237                     hc.sslContext.isDTLS() &amp;&amp;
 238                     hsStatus == HandshakeStatus.NEED_UNWRAP)) {
 239                 ciphertext = encode(null, 0, 0,
 240                         dsts, dstsOffset, dstsLength);
 241             }
 242 
 243             if (ciphertext == null &amp;&amp; srcsRemains != 0) {
 244                 ciphertext = encode(srcs, srcsOffset, srcsLength,
 245                         dsts, dstsOffset, dstsLength);
 246             }
 247         } catch (IOException ioe) {
 248             if (ioe instanceof SSLException) {
 249                 throw ioe;
 250             } else {
 251                 throw new SSLException(&quot;Write problems&quot;, ioe);
 252             }
 253         }
 254 
 255         /*
 256          * Check for status.
 257          */
 258         Status status = (isOutboundDone() ? Status.CLOSED : Status.OK);
 259         if (ciphertext != null &amp;&amp; ciphertext.handshakeStatus != null) {
 260             hsStatus = ciphertext.handshakeStatus;
 261         } else {
 262             hsStatus = getHandshakeStatus();
 263             if (ciphertext == null &amp;&amp; !conContext.isNegotiated &amp;&amp;
 264                     conContext.isInboundClosed() &amp;&amp;
 265                     hsStatus == HandshakeStatus.NEED_WRAP) {
 266                 // Even the outboud is open, no futher data could be wrapped as:
 267                 //     1. the outbound is empty
 268                 //     2. no negotiated connection
 269                 //     3. the inbound has closed, cannot complete the handshake
 270                 //
 271                 // Mark the engine as closed if the handshake status is
 272                 // NEED_WRAP. Otherwise, it could lead to dead loops in
 273                 // applications.
 274                 status = Status.CLOSED;
 275             }
 276         }
 277 
 278         int deltaSrcs = srcsRemains;
 279         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 280             deltaSrcs -= srcs[i].remaining();
 281         }
 282 
 283         int deltaDsts = dstsRemains;
 284         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 285             deltaDsts -= dsts[i].remaining();
 286         }
 287 
 288         return new SSLEngineResult(status, hsStatus, deltaSrcs, deltaDsts,
 289                 ciphertext != null ? ciphertext.recordSN : -1L);
 290     }
 291 
 292     private Ciphertext encode(
 293         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 294         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 295 
 296         Ciphertext ciphertext = null;
 297         try {
 298             ciphertext = conContext.outputRecord.encode(
 299                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 300         } catch (SSLHandshakeException she) {
 301             // may be record sequence number overflow
 302             throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
 303         } catch (IOException e) {
 304             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);
 305         }
 306 
 307         if (ciphertext == null) {
 308             return null;
 309         }
 310 
 311         // Is the handshake completed?
 312         boolean needRetransmission =
 313                 conContext.sslContext.isDTLS() &amp;&amp;
 314                 conContext.handshakeContext != null &amp;&amp;
 315                 conContext.handshakeContext.sslConfig.enableRetransmissions;
 316         HandshakeStatus hsStatus =
 317                 tryToFinishHandshake(ciphertext.contentType);
 318         if (needRetransmission &amp;&amp;
 319                 hsStatus == HandshakeStatus.FINISHED &amp;&amp;
 320                 conContext.sslContext.isDTLS() &amp;&amp;
 321                 ciphertext.handshakeType == SSLHandshake.FINISHED.id) {
 322             // Retransmit the last flight for DTLS.
 323             //
 324             // The application data transactions may begin immediately
 325             // after the last flight.  If the last flight get lost, the
 326             // application data may be discarded accordingly.  As could
 327             // be an issue for some applications.  This impact can be
 328             // mitigated by sending the last fligth twice.
 329             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 330                 SSLLogger.finest(&quot;retransmit the last flight messages&quot;);
 331             }
 332 
 333             conContext.outputRecord.launchRetransmission();
 334             hsStatus = HandshakeStatus.NEED_WRAP;
 335         }
 336 
 337         if (hsStatus == null) {
 338             hsStatus = conContext.getHandshakeStatus();
 339         }
 340 
 341         // Is the sequence number is nearly overflow?
 342         if (conContext.outputRecord.seqNumIsHuge() ||
 343                 conContext.outputRecord.writeCipher.atKeyLimit()) {
 344             hsStatus = tryKeyUpdate(hsStatus);
 345         }
 346 
 347         // Check if NewSessionTicket PostHandshake message needs to be sent
 348         if (conContext.conSession.updateNST &amp;&amp;
 349                 !conContext.sslConfig.isClientMode) {
 350             hsStatus = tryNewSessionTicket(hsStatus);
 351         }
 352 
 353         // update context status
 354         ciphertext.handshakeStatus = hsStatus;
 355 
 356         return ciphertext;
 357     }
 358 
 359     private HandshakeStatus tryToFinishHandshake(byte contentType) {
 360         HandshakeStatus hsStatus = null;
 361         if ((contentType == ContentType.HANDSHAKE.id) &amp;&amp;
 362                 conContext.outputRecord.isEmpty()) {
 363             if (conContext.handshakeContext == null) {
 364                 hsStatus = HandshakeStatus.FINISHED;
 365             } else if (conContext.isPostHandshakeContext()) {
 366                 // unlikely, but just in case.
 367                 hsStatus = conContext.finishPostHandshake();
 368             } else if (conContext.handshakeContext.handshakeFinished) {
 369                 hsStatus = conContext.finishHandshake();
 370             }
 371         }   // Otherwise, the followed call to getHSStatus() will help.
 372 
 373         return hsStatus;
 374     }
 375 
 376     /**
 377      * Try key update for sequence number wrap or key usage limit.
 378      *
 379      * Note that in order to maintain the handshake status properly, we check
 380      * the sequence number and key usage limit after the last record
 381      * reading/writing process.
 382      *
 383      * As we request renegotiation or close the connection for wrapped sequence
 384      * number when there is enough sequence number space left to handle a few
 385      * more records, so the sequence number of the last record cannot be
 386      * wrapped.
 387      */
 388     private HandshakeStatus tryKeyUpdate(
 389             HandshakeStatus currentHandshakeStatus) throws IOException {
 390         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 391         // connection is not duplex-open.
 392         if ((conContext.handshakeContext == null) &amp;&amp;
 393                 !conContext.isOutboundClosed() &amp;&amp;
 394                 !conContext.isInboundClosed() &amp;&amp;
 395                 !conContext.isBroken) {
 396             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 397                 SSLLogger.finest(&quot;trigger key update&quot;);
 398             }
 399             beginHandshake();
 400             return conContext.getHandshakeStatus();
 401         }
 402 
 403         return currentHandshakeStatus;
 404     }
 405 
 406     // Try to generate a PostHandshake NewSessionTicket message.  This is
 407     // TLS 1.3 only.
 408     private HandshakeStatus tryNewSessionTicket(
 409             HandshakeStatus currentHandshakeStatus) throws IOException {
 410         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 411         // connection is not duplex-open.
 412         if ((conContext.handshakeContext == null) &amp;&amp;
 413                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;
 414                 !conContext.isOutboundClosed() &amp;&amp;
 415                 !conContext.isInboundClosed() &amp;&amp;
 416                 !conContext.isBroken) {
 417             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 418                 SSLLogger.finest(&quot;trigger NST&quot;);
 419             }
 420             conContext.conSession.updateNST = false;
 421             NewSessionTicket.kickstartProducer.produce(
 422                     new PostHandshakeContext(conContext));
 423             return conContext.getHandshakeStatus();
 424         }
 425 
 426         return currentHandshakeStatus;
 427     }
 428 
 429     private static void checkParams(
 430             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 431             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 432 
 433         if ((srcs == null) || (dsts == null)) {
 434             throw new IllegalArgumentException(
 435                     &quot;source or destination buffer is null&quot;);
 436         }
 437 
 438         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 439                 (dstsOffset &gt; dsts.length - dstsLength)) {
 440             throw new IndexOutOfBoundsException(
 441                     &quot;index out of bound of the destination buffers&quot;);
 442         }
 443 
 444         if ((srcsOffset &lt; 0) || (srcsLength &lt; 0) ||
 445                 (srcsOffset &gt; srcs.length - srcsLength)) {
 446             throw new IndexOutOfBoundsException(
 447                     &quot;index out of bound of the source buffers&quot;);
 448         }
 449 
 450         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 451             if (dsts[i] == null) {
 452                 throw new IllegalArgumentException(
 453                         &quot;destination buffer[&quot; + i + &quot;] == null&quot;);
 454             }
 455 
 456             /*
 457              * Make sure the destination bufffers are writable.
 458              */
 459             if (dsts[i].isReadOnly()) {
 460                 throw new ReadOnlyBufferException();
 461             }
 462         }
 463 
 464         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 465             if (srcs[i] == null) {
 466                 throw new IllegalArgumentException(
 467                         &quot;source buffer[&quot; + i + &quot;] == null&quot;);
 468             }
 469         }
 470     }
 471 
 472     @Override
 473     public SSLEngineResult unwrap(ByteBuffer src,
 474             ByteBuffer[] dsts, int offset, int length) throws SSLException {
 475         return unwrap(
 476                 new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
 477     }
 478 
 479     // @Override
 480     public SSLEngineResult unwrap(
 481         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 482         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 483 
 484         engineLock.lock();
 485         try {
 486             if (conContext.isUnsureMode) {
 487                 throw new IllegalStateException(
 488                         &quot;Client/Server mode has not yet been set.&quot;);
 489             }
 490 
 491             // See if the handshaker needs to report back some SSLException.
 492             checkTaskThrown();
 493 
 494             // check parameters
 495             checkParams(srcs, srcsOffset, srcsLength,
 496                     dsts, dstsOffset, dstsLength);
 497 
 498             try {
 499                 return readRecord(
 500                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 501             } catch (SSLProtocolException spe) {
 502                 // may be an unexpected handshake message
 503                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 504                         spe.getMessage(), spe);
 505             } catch (IOException ioe) {
 506                 /*
 507                  * Don&#39;t reset position so it looks like we didn&#39;t
 508                  * consume anything.  We did consume something, and it
 509                  * got us into this situation, so report that much back.
 510                  * Our days of consuming are now over anyway.
 511                  */
 512                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 513                         &quot;problem unwrapping net record&quot;, ioe);
 514             } catch (Exception ex) {     // including RuntimeException
 515                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 516                     &quot;Fail to unwrap network record&quot;, ex);
 517             }
 518         } finally {
 519             engineLock.unlock();
 520         }
 521     }
 522 
 523     private SSLEngineResult readRecord(
 524         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 525         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 526 
 527         /*
 528          * Check if we are closing/closed.
 529          */
 530         if (isInboundDone()) {
 531             return new SSLEngineResult(
 532                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 533         }
 534 
 535         HandshakeStatus hsStatus = null;
 536         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 537                 !conContext.isInboundClosed() &amp;&amp;
 538                 !conContext.isOutboundClosed()) {
 539             conContext.kickstart();
 540 
 541             /*
 542              * If there&#39;s still outbound data to flush, we
 543              * can return without trying to unwrap anything.
 544              */
 545             hsStatus = getHandshakeStatus();
 546             if (hsStatus == HandshakeStatus.NEED_WRAP) {
 547                 return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 548             }
 549         }
 550 
 551         if (hsStatus == null) {
 552             hsStatus = getHandshakeStatus();
 553         }
 554 
 555         /*
 556          * If we have a task outstanding, this *MUST* be done before
 557          * doing any more unwrapping, because we could be in the middle
 558          * of receiving a handshake message, for example, a finished
 559          * message which would change the ciphers.
 560          */
 561         if (hsStatus == HandshakeStatus.NEED_TASK) {
 562             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 563         }
 564 
 565         if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
 566             Plaintext plainText = null;
 567             try {
 568                 plainText = decode(null, 0, 0,
 569                         dsts, dstsOffset, dstsLength);
 570             } catch (IOException ioe) {
 571                 if (ioe instanceof SSLException) {
 572                     throw ioe;
 573                 } else {
 574                     throw new SSLException(&quot;readRecord&quot;, ioe);
 575                 }
 576             }
 577 
 578             Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 579             if (plainText.handshakeStatus != null) {
 580                 hsStatus = plainText.handshakeStatus;
 581             } else {
 582                 hsStatus = getHandshakeStatus();
 583             }
 584 
 585             return new SSLEngineResult(
 586                     status, hsStatus, 0, 0, plainText.recordSN);
 587         }
 588 
 589         int srcsRemains = 0;
 590         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 591             srcsRemains += srcs[i].remaining();
 592         }
 593 
 594         if (srcsRemains == 0) {
 595             return new SSLEngineResult(
 596                 Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 597         }
 598 
 599         /*
 600          * Check the packet to make sure enough is here.
 601          * This will also indirectly check for 0 len packets.
 602          */
 603         int packetLen = 0;
 604         try {
 605             packetLen = conContext.inputRecord.bytesInCompletePacket(
 606                     srcs, srcsOffset, srcsLength);
 607         } catch (SSLException ssle) {
 608             // Need to discard invalid records for DTLS protocols.
 609             if (sslContext.isDTLS()) {
 610                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 611                     SSLLogger.finest(&quot;Discard invalid DTLS records&quot;, ssle);
 612                 }
 613 
 614                 // invalid, discard the entire data [section 4.1.2.7, RFC 6347]
 615                 int deltaNet = 0;
 616                 // int deltaNet = netData.remaining();
 617                 // netData.position(netData.limit());
 618 
 619                 Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 620                 if (hsStatus == null) {
 621                     hsStatus = getHandshakeStatus();
 622                 }
 623 
 624                 return new SSLEngineResult(status, hsStatus, deltaNet, 0, -1L);
 625             } else {
 626                 throw ssle;
 627             }
 628         }
 629 
 630         // Is this packet bigger than SSL/TLS normally allows?
 631         if (packetLen &gt; conContext.conSession.getPacketBufferSize()) {
 632             int largestRecordSize = sslContext.isDTLS() ?
 633                     DTLSRecord.maxRecordSize : SSLRecord.maxLargeRecordSize;
 634             if ((packetLen &lt;= largestRecordSize) &amp;&amp; !sslContext.isDTLS()) {
 635                 // Expand the expected maximum packet/application buffer
 636                 // sizes.
 637                 //
 638                 // Only apply to SSL/TLS protocols.
 639 
 640                 // Old behavior: shall we honor the System Property
 641                 // &quot;jsse.SSLEngine.acceptLargeFragments&quot; if it is &quot;false&quot;?
 642                 conContext.conSession.expandBufferSizes();
 643             }
 644 
 645             // check the packet again
 646             largestRecordSize = conContext.conSession.getPacketBufferSize();
 647             if (packetLen &gt; largestRecordSize) {
 648                 throw new SSLProtocolException(
 649                         &quot;Input record too big: max = &quot; +
 650                         largestRecordSize + &quot; len = &quot; + packetLen);
 651             }
 652         }
 653 
 654         /*
 655          * Check for OVERFLOW.
 656          *
 657          * Delay enforcing the application buffer free space requirement
 658          * until after the initial handshaking.
 659          */
 660         int dstsRemains = 0;
 661         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 662             dstsRemains += dsts[i].remaining();
 663         }
 664 
 665         if (conContext.isNegotiated) {
 666             int FragLen =
 667                     conContext.inputRecord.estimateFragmentSize(packetLen);
 668             if (FragLen &gt; dstsRemains) {
 669                 return new SSLEngineResult(
 670                         Status.BUFFER_OVERFLOW, hsStatus, 0, 0);
 671             }
 672         }
 673 
 674         // check for UNDERFLOW.
 675         if ((packetLen == -1) || (srcsRemains &lt; packetLen)) {
 676             return new SSLEngineResult(Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 677         }
 678 
 679         /*
 680          * We&#39;re now ready to actually do the read.
 681          */
 682         Plaintext plainText = null;
 683         try {
 684             plainText = decode(srcs, srcsOffset, srcsLength,
 685                             dsts, dstsOffset, dstsLength);
 686         } catch (IOException ioe) {
 687             if (ioe instanceof SSLException) {
 688                 throw ioe;
 689             } else {
 690                 throw new SSLException(&quot;readRecord&quot;, ioe);
 691             }
 692         }
 693 
 694         /*
 695          * Check the various condition that we could be reporting.
 696          *
 697          * It&#39;s *possible* something might have happened between the
 698          * above and now, but it was better to minimally lock &quot;this&quot;
 699          * during the read process.  We&#39;ll return the current
 700          * status, which is more representative of the current state.
 701          *
 702          * status above should cover:  FINISHED, NEED_TASK
 703          */
 704         Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 705         if (plainText.handshakeStatus != null) {
 706             hsStatus = plainText.handshakeStatus;
 707         } else {
 708             hsStatus = getHandshakeStatus();
 709         }
 710 
 711         int deltaNet = srcsRemains;
 712         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 713             deltaNet -= srcs[i].remaining();
 714         }
 715 
 716         int deltaApp = dstsRemains;
 717         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 718             deltaApp -= dsts[i].remaining();
 719         }
 720 
 721         return new SSLEngineResult(
 722                 status, hsStatus, deltaNet, deltaApp, plainText.recordSN);
 723     }
 724 
 725     private Plaintext decode(
 726         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 727         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 728 
 729         Plaintext pt = SSLTransport.decode(conContext,
 730                             srcs, srcsOffset, srcsLength,
 731                             dsts, dstsOffset, dstsLength);
 732 
 733         // Is the handshake completed?
 734         if (pt != Plaintext.PLAINTEXT_NULL) {
 735             HandshakeStatus hsStatus = tryToFinishHandshake(pt.contentType);
 736             if (hsStatus == null) {
 737                 pt.handshakeStatus = conContext.getHandshakeStatus();
 738             } else {
 739                 pt.handshakeStatus = hsStatus;
 740             }
 741 
 742             // Is the sequence number is nearly overflow?
 743             if (conContext.inputRecord.seqNumIsHuge() ||
 744                     conContext.inputRecord.readCipher.atKeyLimit()) {
 745                 pt.handshakeStatus =
 746                         tryKeyUpdate(pt.handshakeStatus);
 747             }
 748         }
 749 
 750         return pt;
 751     }
 752 
 753     @Override
 754     public Runnable getDelegatedTask() {
 755         engineLock.lock();
 756         try {
 757             if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake
 758                     !conContext.handshakeContext.taskDelegated &amp;&amp;
 759                     !conContext.handshakeContext.delegatedActions.isEmpty()) {
 760                 conContext.handshakeContext.taskDelegated = true;
 761                 return new DelegatedTask(this);
 762             }
 763         } finally {
 764             engineLock.unlock();
 765         }
 766 
 767         return null;
 768     }
 769 
 770     @Override
 771     public void closeInbound() throws SSLException {
 772         engineLock.lock();
 773         try {
 774             if (isInboundDone()) {
 775                 return;
 776             }
 777 
 778             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 779                 SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);
 780             }
 781 
 782             // Is it ready to close inbound?
 783             //
 784             // No exception if the initial handshake is not started.
 785             if (!conContext.isInputCloseNotified &amp;&amp;
 786                 (conContext.isNegotiated ||
 787                     conContext.handshakeContext != null)) {
 788 
 789                 throw conContext.fatal(Alert.INTERNAL_ERROR,
 790                         &quot;closing inbound before receiving peer&#39;s close_notify&quot;);
 791             }
 792 
 793             conContext.closeInbound();
 794         } finally {
 795             engineLock.unlock();
 796         }
 797     }
 798 
 799     @Override
 800     public boolean isInboundDone() {
 801         engineLock.lock();
 802         try {
 803             return conContext.isInboundClosed();
 804         } finally {
 805             engineLock.unlock();
 806         }
 807     }
 808 
 809     @Override
 810     public void closeOutbound() {
 811         engineLock.lock();
 812         try {
 813             if (conContext.isOutboundClosed()) {
 814                 return;
 815             }
 816 
 817             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 818                 SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);
 819             }
 820 
 821             conContext.closeOutbound();
 822         } finally {
 823             engineLock.unlock();
 824         }
 825     }
 826 
 827     @Override
 828     public boolean isOutboundDone() {
 829         engineLock.lock();
 830         try {
 831             return conContext.isOutboundDone();
 832         } finally {
 833             engineLock.unlock();
 834         }
 835     }
 836 
 837     @Override
 838     public String[] getSupportedCipherSuites() {
 839         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 840     }
 841 
 842     @Override
 843     public String[] getEnabledCipherSuites() {
 844         engineLock.lock();
 845         try {
 846             return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);
 847         } finally {
 848             engineLock.unlock();
 849         }
 850     }
 851 
 852     @Override
 853     public void setEnabledCipherSuites(String[] suites) {
 854         engineLock.lock();
 855         try {
 856             conContext.sslConfig.enabledCipherSuites =
 857                     CipherSuite.validValuesOf(suites);
 858         } finally {
 859             engineLock.unlock();
 860         }
 861     }
 862 
 863     @Override
 864     public String[] getSupportedProtocols() {
 865         return ProtocolVersion.toStringArray(
 866                 sslContext.getSupportedProtocolVersions());
 867     }
 868 
 869     @Override
 870     public String[] getEnabledProtocols() {
 871         engineLock.lock();
 872         try {
 873             return ProtocolVersion.toStringArray(
 874                     conContext.sslConfig.enabledProtocols);
 875         } finally {
 876             engineLock.unlock();
 877         }
 878     }
 879 
 880     @Override
 881     public void setEnabledProtocols(String[] protocols) {
 882         engineLock.lock();
 883         try {
 884             if (protocols == null) {
 885                 throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 886             }
 887 
 888             conContext.sslConfig.enabledProtocols =
 889                     ProtocolVersion.namesOf(protocols);
 890         } finally {
 891             engineLock.unlock();
 892         }
 893     }
 894 
 895     @Override
 896     public SSLSession getSession() {
 897         engineLock.lock();
 898         try {
 899             return conContext.conSession;
 900         } finally {
 901             engineLock.unlock();
 902         }
 903     }
 904 
 905     @Override
 906     public SSLSession getHandshakeSession() {
 907         engineLock.lock();
 908         try {
 909             return conContext.handshakeContext == null ?
 910                     null : conContext.handshakeContext.handshakeSession;
 911         } finally {
 912             engineLock.unlock();
 913         }
 914     }
 915 
 916     @Override
 917     public SSLEngineResult.HandshakeStatus getHandshakeStatus() {
 918         engineLock.lock();
 919         try {
 920             return conContext.getHandshakeStatus();
 921         } finally {
 922             engineLock.unlock();
 923         }
 924     }
 925 
 926     @Override
 927     public void setUseClientMode(boolean mode) {
 928         engineLock.lock();
 929         try {
 930             conContext.setUseClientMode(mode);
 931         } finally {
 932             engineLock.unlock();
 933         }
 934     }
 935 
 936     @Override
 937     public boolean getUseClientMode() {
 938         engineLock.lock();
 939         try {
 940             return conContext.sslConfig.isClientMode;
 941         } finally {
 942             engineLock.unlock();
 943         }
 944     }
 945 
 946     @Override
 947     public void setNeedClientAuth(boolean need) {
 948         engineLock.lock();
 949         try {
 950             conContext.sslConfig.clientAuthType =
 951                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :
 952                             ClientAuthType.CLIENT_AUTH_NONE);
 953         } finally {
 954             engineLock.unlock();
 955         }
 956     }
 957 
 958     @Override
 959     public boolean getNeedClientAuth() {
 960         engineLock.lock();
 961         try {
 962             return (conContext.sslConfig.clientAuthType ==
 963                             ClientAuthType.CLIENT_AUTH_REQUIRED);
 964         } finally {
 965             engineLock.unlock();
 966         }
 967     }
 968 
 969     @Override
 970     public void setWantClientAuth(boolean want) {
 971         engineLock.lock();
 972         try {
 973             conContext.sslConfig.clientAuthType =
 974                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :
 975                             ClientAuthType.CLIENT_AUTH_NONE);
 976         } finally {
 977             engineLock.unlock();
 978         }
 979     }
 980 
 981     @Override
 982     public boolean getWantClientAuth() {
 983         engineLock.lock();
 984         try {
 985             return (conContext.sslConfig.clientAuthType ==
 986                             ClientAuthType.CLIENT_AUTH_REQUESTED);
 987         } finally {
 988             engineLock.unlock();
 989         }
 990     }
 991 
 992     @Override
 993     public void setEnableSessionCreation(boolean flag) {
 994         engineLock.lock();
 995         try {
 996             conContext.sslConfig.enableSessionCreation = flag;
 997         } finally {
 998             engineLock.unlock();
 999         }
1000     }
1001 
1002     @Override
1003     public boolean getEnableSessionCreation() {
1004         engineLock.lock();
1005         try {
1006             return conContext.sslConfig.enableSessionCreation;
1007         } finally {
1008             engineLock.unlock();
1009         }
1010     }
1011 
1012     @Override
1013     public SSLParameters getSSLParameters() {
1014         engineLock.lock();
1015         try {
1016             return conContext.sslConfig.getSSLParameters();
1017         } finally {
1018             engineLock.unlock();
1019         }
1020    }
1021 
1022     @Override
1023     public void setSSLParameters(SSLParameters params) {
1024         engineLock.lock();
1025         try {
1026             conContext.sslConfig.setSSLParameters(params);
1027 
1028             if (conContext.sslConfig.maximumPacketSize != 0) {
1029                 conContext.outputRecord.changePacketSize(
1030                         conContext.sslConfig.maximumPacketSize);
1031             }
1032         } finally {
1033             engineLock.unlock();
1034         }
1035    }
1036 
1037     @Override
1038     public String getApplicationProtocol() {
1039         engineLock.lock();
1040         try {
1041             return conContext.applicationProtocol;
1042         } finally {
1043             engineLock.unlock();
1044         }
1045     }
1046 
1047     @Override
1048     public String getHandshakeApplicationProtocol() {
1049         engineLock.lock();
1050         try {
1051             return conContext.handshakeContext == null ?
1052                     null : conContext.handshakeContext.applicationProtocol;
1053         } finally {
1054             engineLock.unlock();
1055         }
1056     }
1057 
1058     @Override
1059     public void setHandshakeApplicationProtocolSelector(
1060             BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
1061         engineLock.lock();
1062         try {
1063             conContext.sslConfig.engineAPSelector = selector;
1064         } finally {
1065             engineLock.unlock();
1066         }
1067     }
1068 
1069     @Override
1070     public BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;
1071             getHandshakeApplicationProtocolSelector() {
1072         engineLock.lock();
1073         try {
1074             return conContext.sslConfig.engineAPSelector;
1075         } finally {
1076             engineLock.unlock();
1077         }
1078     }
1079 
1080     @Override
1081     public boolean useDelegatedTask() {
1082         return true;
1083     }
1084 
1085     /*
1086      * Depending on whether the error was just a warning and the
1087      * handshaker wasn&#39;t closed, or fatal and the handshaker is now
1088      * null, report back the Exception that happened in the delegated
1089      * task(s).
1090      */
1091     private void checkTaskThrown() throws SSLException {
1092 
1093         Exception exc = null;
1094         engineLock.lock();
1095         try {
1096             // First check the handshake context.
1097             HandshakeContext hc = conContext.handshakeContext;
1098             if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {
1099                 exc = hc.delegatedThrown;
1100                 hc.delegatedThrown = null;
1101             }
1102 
1103             /*
1104              * hc.delegatedThrown and conContext.delegatedThrown are most
1105              * likely the same, but it&#39;s possible we could have had a non-fatal
1106              * exception and thus the new HandshakeContext is still valid
1107              * (alert warning).  If so, then we may have a secondary exception
1108              * waiting to be reported from the TransportContext, so we will
1109              * need to clear that on a successive call. Otherwise, clear it now.
1110              */
1111             if (conContext.delegatedThrown != null) {
1112                 if (exc != null) {
1113                     // hc object comparison
1114                     if (conContext.delegatedThrown == exc) {
1115                         // clear if/only if both are the same
1116                         conContext.delegatedThrown = null;
1117                     } // otherwise report the hc delegatedThrown
1118                 } else {
1119                     // Nothing waiting in HandshakeContext, but one is in the
1120                     // TransportContext.
1121                     exc = conContext.delegatedThrown;
1122                     conContext.delegatedThrown = null;
1123                 }
1124             }
1125         } finally {
1126             engineLock.unlock();
1127         }
1128 
1129         // Anything to report?
1130         if (exc == null) {
1131             return;
1132         }
1133 
1134         // If it wasn&#39;t a RuntimeException/SSLException, need to wrap it.
1135         if (exc instanceof SSLException) {
1136             throw (SSLException)exc;
1137         } else if (exc instanceof RuntimeException) {
1138             throw (RuntimeException)exc;
1139         } else {
1140             throw getTaskThrown(exc);
1141         }
1142     }
1143 
1144     private static SSLException getTaskThrown(Exception taskThrown) {
1145         String msg = taskThrown.getMessage();
1146 
1147         if (msg == null) {
1148             msg = &quot;Delegated task threw Exception or Error&quot;;
1149         }
1150 
1151         if (taskThrown instanceof RuntimeException) {
1152             throw new RuntimeException(msg, taskThrown);
1153         } else if (taskThrown instanceof SSLHandshakeException) {
1154             return (SSLHandshakeException)
1155                 new SSLHandshakeException(msg).initCause(taskThrown);
1156         } else if (taskThrown instanceof SSLKeyException) {
1157             return (SSLKeyException)
1158                 new SSLKeyException(msg).initCause(taskThrown);
1159         } else if (taskThrown instanceof SSLPeerUnverifiedException) {
1160             return (SSLPeerUnverifiedException)
1161                 new SSLPeerUnverifiedException(msg).initCause(taskThrown);
1162         } else if (taskThrown instanceof SSLProtocolException) {
1163             return (SSLProtocolException)
1164                 new SSLProtocolException(msg).initCause(taskThrown);
1165         } else if (taskThrown instanceof SSLException) {
1166             return (SSLException)taskThrown;
1167         } else {
1168             return new SSLException(msg, taskThrown);
1169         }
1170     }
1171 
1172     /**
1173      * Implement a simple task delegator.
1174      */
1175     private static class DelegatedTask implements Runnable {
1176         private final SSLEngineImpl engine;
1177 
1178         DelegatedTask(SSLEngineImpl engineInstance) {
1179             this.engine = engineInstance;
1180         }
1181 
1182         @Override
1183         public void run() {
1184             engine.engineLock.lock();
1185             try {
1186                 HandshakeContext hc = engine.conContext.handshakeContext;
1187                 if (hc == null || hc.delegatedActions.isEmpty()) {
1188                     return;
1189                 }
1190 
1191                 try {
1192                     AccessController.doPrivileged(
1193                             new DelegatedAction(hc), engine.conContext.acc);
1194                 } catch (PrivilegedActionException pae) {
1195                     // Get the handshake context again in case the
1196                     // handshaking has completed.
1197                     Exception reportedException = pae.getException();
1198 
1199                     // Report to both the TransportContext...
1200                     if (engine.conContext.delegatedThrown == null) {
1201                         engine.conContext.delegatedThrown = reportedException;
1202                     }
1203 
1204                     // ...and the HandshakeContext in case condition
1205                     // wasn&#39;t fatal and the handshakeContext is still
1206                     // around.
1207                     hc = engine.conContext.handshakeContext;
1208                     if (hc != null) {
1209                         hc.delegatedThrown = reportedException;
1210                     } else if (engine.conContext.closeReason != null) {
1211                         // Update the reason in case there was a previous.
1212                         engine.conContext.closeReason =
1213                                 getTaskThrown(reportedException);
1214                     }
1215                 } catch (RuntimeException rte) {
1216                     // Get the handshake context again in case the
1217                     // handshaking has completed.
1218 
1219                     // Report to both the TransportContext...
1220                     if (engine.conContext.delegatedThrown == null) {
1221                         engine.conContext.delegatedThrown = rte;
1222                     }
1223 
1224                     // ...and the HandshakeContext in case condition
1225                     // wasn&#39;t fatal and the handshakeContext is still
1226                     // around.
1227                     hc = engine.conContext.handshakeContext;
1228                     if (hc != null) {
1229                         hc.delegatedThrown = rte;
1230                     } else if (engine.conContext.closeReason != null) {
1231                         // Update the reason in case there was a previous.
1232                         engine.conContext.closeReason = rte;
1233                     }
1234                 }
1235 
1236                 // Get the handshake context again in case the
1237                 // handshaking has completed.
1238                 hc = engine.conContext.handshakeContext;
1239                 if (hc != null) {
1240                     hc.taskDelegated = false;
1241                 }
1242             } finally {
1243                 engine.engineLock.unlock();
1244             }
1245         }
1246 
1247         private static class DelegatedAction
1248                 implements PrivilegedExceptionAction&lt;Void&gt; {
1249             final HandshakeContext context;
1250             DelegatedAction(HandshakeContext context) {
1251                 this.context = context;
1252             }
1253 
1254             @Override
1255             public Void run() throws Exception {
1256                 while (!context.delegatedActions.isEmpty()) {
1257                     Map.Entry&lt;Byte, ByteBuffer&gt; me =
1258                             context.delegatedActions.poll();
1259                     if (me != null) {
1260                         context.dispatch(me.getKey(), me.getValue());
1261                     }
1262                 }
1263                 return null;
1264             }
1265         }
1266     }
1267 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/ECDHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ECDHClientKeyExchange.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHServerKeyExchange.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ECDHKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,85 ***</span>
  import java.security.KeyPair;
  import java.security.KeyPairGenerator;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.SecureRandom;
<span class="line-removed">- import java.security.interfaces.ECPrivateKey;</span>
  import java.security.interfaces.ECPublicKey;
<span class="line-removed">- import java.security.spec.AlgorithmParameterSpec;</span>
<span class="line-removed">- import java.security.spec.ECGenParameterSpec;</span>
  import java.security.spec.ECParameterSpec;
  import java.security.spec.ECPoint;
  import java.security.spec.ECPublicKeySpec;
  import java.util.EnumSet;
  import javax.crypto.KeyAgreement;
  import javax.crypto.SecretKey;
<span class="line-removed">- import javax.crypto.spec.SecretKeySpec;</span>
  import javax.net.ssl.SSLHandshakeException;
<span class="line-modified">! import sun.security.ssl.CipherSuite.HashAlg;</span>
<span class="line-removed">- import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed">- import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
  import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
  import sun.security.ssl.X509Authentication.X509Credentials;
  import sun.security.ssl.X509Authentication.X509Possession;
  import sun.security.util.ECUtil;
  
  final class ECDHKeyExchange {
      static final SSLPossessionGenerator poGenerator =
              new ECDHEPossessionGenerator();
<span class="line-removed">-     static final SSLKeyAgreementGenerator ecdheKAGenerator =</span>
<span class="line-removed">-             new ECDHEKAGenerator();</span>
      static final SSLKeyAgreementGenerator ecdhKAGenerator =
              new ECDHKAGenerator();
  
<span class="line-modified">!     static final class ECDHECredentials implements SSLCredentials {</span>
          final ECPublicKey popPublicKey;
          final NamedGroup namedGroup;
  
          ECDHECredentials(ECPublicKey popPublicKey, NamedGroup namedGroup) {
              this.popPublicKey = popPublicKey;
              this.namedGroup = namedGroup;
          }
  
          static ECDHECredentials valueOf(NamedGroup namedGroup,
              byte[] encodedPoint) throws IOException, GeneralSecurityException {
  
<span class="line-modified">!             if (namedGroup.type != NamedGroupType.NAMED_GROUP_ECDHE) {</span>
                  throw new RuntimeException(
                      &quot;Credentials decoding:  Not ECDHE named group&quot;);
              }
  
              if (encodedPoint == null || encodedPoint.length == 0) {
                  return null;
              }
  
              ECParameterSpec parameters =
<span class="line-modified">!                     ECUtil.getECParameterSpec(null, namedGroup.oid);</span>
<span class="line-removed">-             if (parameters == null) {</span>
<span class="line-removed">-                 return null;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              ECPoint point = ECUtil.decodePoint(
                      encodedPoint, parameters.getCurve());
              KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
              ECPublicKey publicKey = (ECPublicKey)factory.generatePublic(
                      new ECPublicKeySpec(point, parameters));
              return new ECDHECredentials(publicKey, namedGroup);
          }
      }
  
<span class="line-modified">!     static final class ECDHEPossession implements SSLPossession {</span>
          final PrivateKey privateKey;
          final ECPublicKey publicKey;
          final NamedGroup namedGroup;
  
          ECDHEPossession(NamedGroup namedGroup, SecureRandom random) {
              try {
                  KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
<span class="line-modified">!                 ECGenParameterSpec params =</span>
<span class="line-removed">-                         (ECGenParameterSpec)namedGroup.getParameterSpec();</span>
<span class="line-removed">-                 kpg.initialize(params, random);</span>
                  KeyPair kp = kpg.generateKeyPair();
                  privateKey = kp.getPrivate();
                  publicKey = (ECPublicKey)kp.getPublic();
              } catch (GeneralSecurityException e) {
                  throw new RuntimeException(
<span class="line-new-header">--- 33,91 ---</span>
  import java.security.KeyPair;
  import java.security.KeyPairGenerator;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.SecureRandom;
  import java.security.interfaces.ECPublicKey;
  import java.security.spec.ECParameterSpec;
  import java.security.spec.ECPoint;
  import java.security.spec.ECPublicKeySpec;
  import java.util.EnumSet;
  import javax.crypto.KeyAgreement;
  import javax.crypto.SecretKey;
  import javax.net.ssl.SSLHandshakeException;
<span class="line-modified">! import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
  import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
  import sun.security.ssl.X509Authentication.X509Credentials;
  import sun.security.ssl.X509Authentication.X509Possession;
<span class="line-added">+ import sun.security.ssl.XDHKeyExchange.XDHECredentials;</span>
<span class="line-added">+ import sun.security.ssl.XDHKeyExchange.XDHEPossession;</span>
  import sun.security.util.ECUtil;
  
  final class ECDHKeyExchange {
      static final SSLPossessionGenerator poGenerator =
              new ECDHEPossessionGenerator();
      static final SSLKeyAgreementGenerator ecdhKAGenerator =
              new ECDHKAGenerator();
  
<span class="line-modified">!     // TLSv1.3</span>
<span class="line-added">+     static final SSLKeyAgreementGenerator ecdheKAGenerator =</span>
<span class="line-added">+             new ECDHEKAGenerator();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // TLSv1-1.2, the KA gets more difficult with EC/XEC keys</span>
<span class="line-added">+     static final SSLKeyAgreementGenerator ecdheXdhKAGenerator =</span>
<span class="line-added">+             new ECDHEXDHKAGenerator();</span>
<span class="line-added">+ </span>
<span class="line-added">+     static final class ECDHECredentials implements NamedGroupCredentials {</span>
          final ECPublicKey popPublicKey;
          final NamedGroup namedGroup;
  
          ECDHECredentials(ECPublicKey popPublicKey, NamedGroup namedGroup) {
              this.popPublicKey = popPublicKey;
              this.namedGroup = namedGroup;
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public PublicKey getPublicKey() {</span>
<span class="line-added">+             return popPublicKey;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public NamedGroup getNamedGroup() {</span>
<span class="line-added">+             return namedGroup;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          static ECDHECredentials valueOf(NamedGroup namedGroup,
              byte[] encodedPoint) throws IOException, GeneralSecurityException {
  
<span class="line-modified">!             if (namedGroup.spec != NamedGroupSpec.NAMED_GROUP_ECDHE) {</span>
                  throw new RuntimeException(
                      &quot;Credentials decoding:  Not ECDHE named group&quot;);
              }
  
              if (encodedPoint == null || encodedPoint.length == 0) {
                  return null;
              }
  
              ECParameterSpec parameters =
<span class="line-modified">!                     (ECParameterSpec)namedGroup.keAlgParamSpec;</span>
              ECPoint point = ECUtil.decodePoint(
                      encodedPoint, parameters.getCurve());
              KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);
              ECPublicKey publicKey = (ECPublicKey)factory.generatePublic(
                      new ECPublicKeySpec(point, parameters));
              return new ECDHECredentials(publicKey, namedGroup);
          }
      }
  
<span class="line-modified">!     static final class ECDHEPossession implements NamedGroupPossession {</span>
          final PrivateKey privateKey;
          final ECPublicKey publicKey;
          final NamedGroup namedGroup;
  
          ECDHEPossession(NamedGroup namedGroup, SecureRandom random) {
              try {
                  KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
<span class="line-modified">!                 kpg.initialize(namedGroup.keAlgParamSpec, random);</span>
                  KeyPair kp = kpg.generateKeyPair();
                  privateKey = kp.getPrivate();
                  publicKey = (ECPublicKey)kp.getPublic();
              } catch (GeneralSecurityException e) {
                  throw new RuntimeException(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,10 ***</span>
<span class="line-new-header">--- 204,25 ---</span>
              } catch (GeneralSecurityException | java.io.IOException e) {
                  throw (SSLHandshakeException) new SSLHandshakeException(
                          &quot;Could not generate ECPublicKey&quot;).initCause(e);
              }
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public PublicKey getPublicKey() {</span>
<span class="line-added">+             return publicKey;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public NamedGroup getNamedGroup() {</span>
<span class="line-added">+             return namedGroup;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public PrivateKey getPrivateKey() {</span>
<span class="line-added">+             return privateKey;</span>
<span class="line-added">+         }</span>
      }
  
      private static final
              class ECDHEPossessionGenerator implements SSLPossessionGenerator {
          // Prevent instantiation of this class.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,28 ***</span>
              // blank
          }
  
          @Override
          public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">!             NamedGroup preferableNamedGroup = null;</span>
              if ((context.clientRequestedNamedGroups != null) &amp;&amp;
                      (!context.clientRequestedNamedGroups.isEmpty())) {
                  preferableNamedGroup = SupportedGroups.getPreferredGroup(
                          context.negotiatedProtocol,
                          context.algorithmConstraints,
<span class="line-modified">!                         NamedGroupType.NAMED_GROUP_ECDHE,</span>
                          context.clientRequestedNamedGroups);
              } else {
                  preferableNamedGroup = SupportedGroups.getPreferredGroup(
                          context.negotiatedProtocol,
                          context.algorithmConstraints,
<span class="line-modified">!                         NamedGroupType.NAMED_GROUP_ECDHE);</span>
              }
  
              if (preferableNamedGroup != null) {
<span class="line-modified">!                 return new ECDHEPossession(preferableNamedGroup,</span>
<span class="line-modified">!                             context.sslContext.getSecureRandom());</span>
              }
  
              // no match found, cannot use this cipher suite.
              //
              return null;
<span class="line-new-header">--- 230,35 ---</span>
              // blank
          }
  
          @Override
          public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">! </span>
<span class="line-added">+             NamedGroup preferableNamedGroup;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Find most preferred EC or XEC groups</span>
              if ((context.clientRequestedNamedGroups != null) &amp;&amp;
                      (!context.clientRequestedNamedGroups.isEmpty())) {
                  preferableNamedGroup = SupportedGroups.getPreferredGroup(
                          context.negotiatedProtocol,
                          context.algorithmConstraints,
<span class="line-modified">!                         new NamedGroupSpec[] {</span>
<span class="line-added">+                             NamedGroupSpec.NAMED_GROUP_ECDHE,</span>
<span class="line-added">+                             NamedGroupSpec.NAMED_GROUP_XDH },</span>
                          context.clientRequestedNamedGroups);
              } else {
                  preferableNamedGroup = SupportedGroups.getPreferredGroup(
                          context.negotiatedProtocol,
                          context.algorithmConstraints,
<span class="line-modified">!                         new NamedGroupSpec[] {</span>
<span class="line-added">+                             NamedGroupSpec.NAMED_GROUP_ECDHE,</span>
<span class="line-added">+                             NamedGroupSpec.NAMED_GROUP_XDH });</span>
              }
  
              if (preferableNamedGroup != null) {
<span class="line-modified">!                 return preferableNamedGroup.createPossession(</span>
<span class="line-modified">!                     context.sslContext.getSecureRandom());</span>
              }
  
              // no match found, cannot use this cipher suite.
              //
              return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,19 ***</span>
              for (SSLPossession poss : shc.handshakePossessions) {
                  if (!(poss instanceof X509Possession)) {
                      continue;
                  }
  
<span class="line-modified">!                 PrivateKey privateKey = ((X509Possession)poss).popPrivateKey;</span>
<span class="line-modified">!                 if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>
                      continue;
                  }
  
<span class="line-removed">-                 ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();</span>
                  NamedGroup ng = NamedGroup.valueOf(params);
                  if (ng == null) {
<span class="line-modified">!                     // unlikely, have been checked during cipher suite negotiation.</span>
                      throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                          &quot;Unsupported EC server cert for ECDH key exchange&quot;);
                  }
  
                  for (SSLCredentials cred : shc.handshakeCredentials) {
<span class="line-new-header">--- 291,20 ---</span>
              for (SSLPossession poss : shc.handshakePossessions) {
                  if (!(poss instanceof X509Possession)) {
                      continue;
                  }
  
<span class="line-modified">!                 ECParameterSpec params =</span>
<span class="line-modified">!                         ((X509Possession)poss).getECParameterSpec();</span>
<span class="line-added">+                 if (params == null) {</span>
                      continue;
                  }
  
                  NamedGroup ng = NamedGroup.valueOf(params);
                  if (ng == null) {
<span class="line-modified">!                     // unlikely, have been checked during cipher suite</span>
<span class="line-added">+                     // negotiation.</span>
                      throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                          &quot;Unsupported EC server cert for ECDH key exchange&quot;);
                  }
  
                  for (SSLCredentials cred : shc.handshakeCredentials) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,11 ***</span>
              if (x509Possession == null || ecdheCredentials == null) {
                  throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new ECDHEKAKeyDerivation(shc,</span>
                  x509Possession.popPrivateKey, ecdheCredentials.popPublicKey);
          }
  
          private SSLKeyDerivation createClientKeyDerivation(
                  ClientHandshakeContext chc) throws IOException {
<span class="line-new-header">--- 326,11 ---</span>
              if (x509Possession == null || ecdheCredentials == null) {
                  throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new KAKeyDerivation(&quot;ECDH&quot;, shc,</span>
                  x509Possession.popPrivateKey, ecdheCredentials.popPublicKey);
          }
  
          private SSLKeyDerivation createClientKeyDerivation(
                  ClientHandshakeContext chc) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,11 ***</span>
              if (ecdhePossession == null || x509Credentials == null) {
                  throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient ECDH key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new ECDHEKAKeyDerivation(chc,</span>
                  ecdhePossession.privateKey, x509Credentials.popPublicKey);
          }
      }
  
      private static final
<span class="line-new-header">--- 375,11 ---</span>
              if (ecdhePossession == null || x509Credentials == null) {
                  throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient ECDH key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new KAKeyDerivation(&quot;ECDH&quot;, chc,</span>
                  ecdhePossession.privateKey, x509Credentials.popPublicKey);
          }
      }
  
      private static final
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,96 ***</span>
              if (ecdhePossession == null || ecdheCredentials == null) {
                  throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new ECDHEKAKeyDerivation(context,</span>
                  ecdhePossession.privateKey, ecdheCredentials.popPublicKey);
          }
      }
  
      private static final
<span class="line-modified">!             class ECDHEKAKeyDerivation implements SSLKeyDerivation {</span>
<span class="line-modified">!         private final HandshakeContext context;</span>
<span class="line-modified">!         private final PrivateKey localPrivateKey;</span>
<span class="line-modified">!         private final PublicKey peerPublicKey;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ECDHEKAKeyDerivation(HandshakeContext context,</span>
<span class="line-removed">-                 PrivateKey localPrivateKey,</span>
<span class="line-removed">-                 PublicKey peerPublicKey) {</span>
<span class="line-removed">-             this.context = context;</span>
<span class="line-removed">-             this.localPrivateKey = localPrivateKey;</span>
<span class="line-removed">-             this.peerPublicKey = peerPublicKey;</span>
          }
  
          @Override
<span class="line-modified">!         public SecretKey deriveKey(String algorithm,</span>
<span class="line-modified">!                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">-             if (!context.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">-                 return t12DeriveKey(algorithm, params);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return t13DeriveKey(algorithm, params);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         private SecretKey t12DeriveKey(String algorithm,</span>
<span class="line-modified">!                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-modified">!             try {</span>
<span class="line-removed">-                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span>
<span class="line-removed">-                 ka.init(localPrivateKey);</span>
<span class="line-removed">-                 ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">-                 SecretKey preMasterSecret =</span>
<span class="line-removed">-                         ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 SSLMasterKeyDerivation mskd =</span>
<span class="line-removed">-                         SSLMasterKeyDerivation.valueOf(</span>
<span class="line-removed">-                                 context.negotiatedProtocol);</span>
<span class="line-removed">-                 if (mskd == null) {</span>
<span class="line-removed">-                     // unlikely</span>
<span class="line-removed">-                     throw new SSLHandshakeException(</span>
<span class="line-removed">-                             &quot;No expected master key derivation for protocol: &quot; +</span>
<span class="line-removed">-                             context.negotiatedProtocol.name);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 SSLKeyDerivation kd = mskd.createKeyDerivation(</span>
<span class="line-removed">-                         context, preMasterSecret);</span>
<span class="line-removed">-                 return kd.deriveKey(&quot;MasterSecret&quot;, params);</span>
<span class="line-removed">-             } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">-                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">-                     &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         private SecretKey t13DeriveKey(String algorithm,</span>
<span class="line-modified">!                 AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;);</span>
<span class="line-modified">!                 ka.init(localPrivateKey);</span>
<span class="line-modified">!                 ka.doPhase(peerPublicKey, true);</span>
<span class="line-modified">!                 SecretKey sharedSecret =</span>
<span class="line-modified">!                         ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;</span>
<span class="line-modified">!                 SSLKeyDerivation kd = context.handshakeKeyDerivation;</span>
<span class="line-modified">!                 HKDF hkdf = new HKDF(hashAlg.name);</span>
<span class="line-modified">!                 if (kd == null) {   // No PSK is in use.</span>
<span class="line-modified">!                     // If PSK is not in use Early Secret will still be</span>
<span class="line-modified">!                     // HKDF-Extract(0, 0).</span>
<span class="line-modified">!                     byte[] zeros = new byte[hashAlg.hashLength];</span>
<span class="line-modified">!                     SecretKeySpec ikm =</span>
<span class="line-modified">!                             new SecretKeySpec(zeros, &quot;TlsPreSharedSecret&quot;);</span>
<span class="line-modified">!                     SecretKey earlySecret =</span>
<span class="line-removed">-                             hkdf.extract(zeros, ikm, &quot;TlsEarlySecret&quot;);</span>
<span class="line-removed">-                     kd = new SSLSecretDerivation(context, earlySecret);</span>
                  }
  
<span class="line-modified">!                 // derive salt secret</span>
<span class="line-modified">!                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);</span>
  
<span class="line-modified">!                 // derive handshake secret</span>
<span class="line-modified">!                 return hkdf.extract(saltSecret, sharedSecret, algorithm);</span>
<span class="line-modified">!             } catch (GeneralSecurityException gse) {</span>
<span class="line-modified">!                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-modified">!                     &quot;Could not generate secret&quot;).initCause(gse);</span>
              }
          }
      }
  }
<span class="line-new-header">--- 419,75 ---</span>
              if (ecdhePossession == null || ecdheCredentials == null) {
                  throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;No sufficient ECDHE key agreement parameters negotiated&quot;);
              }
  
<span class="line-modified">!             return new KAKeyDerivation(&quot;ECDH&quot;, context,</span>
                  ecdhePossession.privateKey, ecdheCredentials.popPublicKey);
          }
      }
  
<span class="line-added">+     /*</span>
<span class="line-added">+      * A Generator for TLSv1-1.2 to create a ECDHE or a XDH KeyDerivation</span>
<span class="line-added">+      * object depending on the negotiated group.</span>
<span class="line-added">+      */</span>
      private static final
<span class="line-modified">!             class ECDHEXDHKAGenerator implements SSLKeyAgreementGenerator {</span>
<span class="line-modified">!         // Prevent instantiation of this class.</span>
<span class="line-modified">!         private ECDHEXDHKAGenerator() {</span>
<span class="line-modified">!             // blank</span>
          }
  
          @Override
<span class="line-modified">!         public SSLKeyDerivation createKeyDerivation(</span>
<span class="line-modified">!                 HandshakeContext context) throws IOException {</span>
  
<span class="line-modified">!             NamedGroupPossession namedGroupPossession = null;</span>
<span class="line-modified">!             NamedGroupCredentials namedGroupCredentials = null;</span>
<span class="line-modified">!             NamedGroup namedGroup = null;</span>
  
<span class="line-modified">!             // Find a possession/credential combo using the same named group</span>
<span class="line-modified">!             search:</span>
<span class="line-modified">!             for (SSLPossession poss : context.handshakePossessions) {</span>
<span class="line-modified">!                 for (SSLCredentials cred : context.handshakeCredentials) {</span>
<span class="line-modified">!                     if (((poss instanceof ECDHEPossession) &amp;&amp;</span>
<span class="line-modified">!                             (cred instanceof ECDHECredentials)) ||</span>
<span class="line-modified">!                             (((poss instanceof XDHEPossession) &amp;&amp;</span>
<span class="line-modified">!                             (cred instanceof XDHECredentials)))) {</span>
<span class="line-modified">!                         NamedGroupPossession p = (NamedGroupPossession)poss;</span>
<span class="line-modified">!                         NamedGroupCredentials c = (NamedGroupCredentials)cred;</span>
<span class="line-modified">!                         if (p.getNamedGroup() != c.getNamedGroup()) {</span>
<span class="line-modified">!                             continue;</span>
<span class="line-modified">!                         } else {</span>
<span class="line-modified">!                             namedGroup = p.getNamedGroup();</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                         namedGroupPossession = p;</span>
<span class="line-modified">!                         namedGroupCredentials = c;</span>
<span class="line-modified">!                         break search;</span>
<span class="line-modified">!                     }</span>
                  }
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (namedGroupPossession == null || namedGroupCredentials == null) {</span>
<span class="line-modified">!                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added">+                     &quot;No sufficient ECDHE/XDH key agreement &quot; +</span>
<span class="line-added">+                             &quot;parameters negotiated&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             String alg;</span>
<span class="line-modified">!             switch (namedGroup.spec) {</span>
<span class="line-modified">!                 case NAMED_GROUP_ECDHE:</span>
<span class="line-modified">!                     alg = &quot;ECDH&quot;;</span>
<span class="line-modified">!                     break;</span>
<span class="line-added">+                 case NAMED_GROUP_XDH:</span>
<span class="line-added">+                     alg = &quot;XDH&quot;;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     throw new RuntimeException(&quot;Unexpected named group type&quot;);</span>
              }
<span class="line-added">+ </span>
<span class="line-added">+             return new KAKeyDerivation(alg, context,</span>
<span class="line-added">+                     namedGroupPossession.getPrivateKey(),</span>
<span class="line-added">+                     namedGroupCredentials.getPublicKey());</span>
          }
      }
  }
</pre>
<center><a href="ECDHClientKeyExchange.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHServerKeyExchange.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
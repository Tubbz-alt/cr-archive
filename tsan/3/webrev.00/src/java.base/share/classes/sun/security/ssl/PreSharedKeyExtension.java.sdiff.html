<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PostHandshakeContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLCipher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
<span class="line-removed"> 35 import java.util.Objects;</span>
<span class="line-removed"> 36 import java.util.Optional;</span>
 37 import java.util.Collection;
 38 import javax.crypto.Mac;
 39 import javax.crypto.SecretKey;
 40 import javax.net.ssl.SSLPeerUnverifiedException;
 41 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 42 import sun.security.ssl.ClientHello.ClientHelloMessage;
 43 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 44 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 45 import sun.security.ssl.SSLHandshake.HandshakeMessage;



 46 import static sun.security.ssl.SSLExtension.*;
 47 
 48 /**
 49  * Pack of the &quot;pre_shared_key&quot; extension.
 50  */
 51 final class PreSharedKeyExtension {
 52     static final HandshakeProducer chNetworkProducer =
 53             new CHPreSharedKeyProducer();
 54     static final ExtensionConsumer chOnLoadConsumer =
 55             new CHPreSharedKeyConsumer();
 56     static final HandshakeAbsence chOnLoadAbsence =
 57             new CHPreSharedKeyAbsence();
 58     static final HandshakeConsumer chOnTradeConsumer =
 59             new CHPreSharedKeyUpdate();
 60     static final SSLStringizer chStringizer =
 61             new CHPreSharedKeyStringizer();
 62 
 63     static final HandshakeProducer shNetworkProducer =
 64             new SHPreSharedKeyProducer();
 65     static final ExtensionConsumer shOnLoadConsumer =
</pre>
<hr />
<pre>
 72     private static final class PskIdentity {
 73         final byte[] identity;
 74         final int obfuscatedAge;
 75 
 76         PskIdentity(byte[] identity, int obfuscatedAge) {
 77             this.identity = identity;
 78             this.obfuscatedAge = obfuscatedAge;
 79         }
 80 
 81         int getEncodedLength() {
 82             return 2 + identity.length + 4;
 83         }
 84 
 85         void writeEncoded(ByteBuffer m) throws IOException {
 86             Record.putBytes16(m, identity);
 87             Record.putInt32(m, obfuscatedAge);
 88         }
 89 
 90         @Override
 91         public String toString() {
<span class="line-modified"> 92             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;,&quot; +</span>
 93                 obfuscatedAge + &quot;}&quot;;
 94         }
 95     }
 96 
 97     private static final
 98             class CHPreSharedKeySpec implements SSLExtensionSpec {
 99         final List&lt;PskIdentity&gt; identities;
100         final List&lt;byte[]&gt; binders;
101 
102         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
103             this.identities = identities;
104             this.binders = binders;
105         }
106 
107         CHPreSharedKeySpec(HandshakeContext context,
108                 ByteBuffer m) throws IOException {
109             // struct {
110             //     PskIdentity identities&lt;7..2^16-1&gt;;
111             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
112             // } OfferedPsks;
</pre>
<hr />
<pre>
192             int bindersEncodedLength = getBindersEncodedLength();
193             int encodedLength = 4 + idsEncodedLength + bindersEncodedLength;
194             byte[] buffer = new byte[encodedLength];
195             ByteBuffer m = ByteBuffer.wrap(buffer);
196             Record.putInt16(m, idsEncodedLength);
197             for (PskIdentity curId : identities) {
198                 curId.writeEncoded(m);
199             }
200             Record.putInt16(m, bindersEncodedLength);
201             for (byte[] curBinder : binders) {
202                 Record.putBytes8(m, curBinder);
203             }
204 
205             return buffer;
206         }
207 
208         @Override
209         public String toString() {
210             MessageFormat messageFormat = new MessageFormat(
211                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
<span class="line-modified">212                 &quot;  \&quot;identities\&quot;    : \&quot;{0}\&quot;,\n&quot; +</span>
<span class="line-modified">213                 &quot;  \&quot;binders\&quot;       : \&quot;{1}\&quot;,\n&quot; +</span>


214                 &quot;&#39;}&#39;&quot;,
215                 Locale.ENGLISH);
216 
217             Object[] messageFields = {
218                 Utilities.indent(identitiesString()),
219                 Utilities.indent(bindersString())
220             };
221 
222             return messageFormat.format(messageFields);
223         }
224 
225         String identitiesString() {


226             StringBuilder result = new StringBuilder();
227             for (PskIdentity curId : identities) {
<span class="line-modified">228                 result.append(curId.toString() + &quot;\n&quot;);</span>


229             }
230 
231             return result.toString();
232         }
233 
234         String bindersString() {
235             StringBuilder result = new StringBuilder();
236             for (byte[] curBinder : binders) {
237                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
238             }
239 
240             return result.toString();
241         }
242     }
243 
244     private static final
245             class CHPreSharedKeyStringizer implements SSLStringizer {
246         @Override
247         public String toString(ByteBuffer buffer) {
248             try {
</pre>
<hr />
<pre>
262 
263     private static final
264             class SHPreSharedKeySpec implements SSLExtensionSpec {
265         final int selectedIdentity;
266 
267         SHPreSharedKeySpec(int selectedIdentity) {
268             this.selectedIdentity = selectedIdentity;
269         }
270 
271         SHPreSharedKeySpec(HandshakeContext context,
272                 ByteBuffer m) throws IOException {
273             if (m.remaining() &lt; 2) {
274                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
275                         &quot;Invalid pre_shared_key extension: &quot; +
276                         &quot;insufficient selected_identity (length=&quot; +
277                         m.remaining() + &quot;)&quot;);
278             }
279             this.selectedIdentity = Record.getInt16(m);
280         }
281 
<span class="line-modified">282         byte[] getEncoded() throws IOException {</span>
283             return new byte[] {
284                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
285                 (byte)(selectedIdentity &amp; 0xFF)
286             };
287         }
288 
289         @Override
290         public String toString() {
291             MessageFormat messageFormat = new MessageFormat(
292                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
293                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
294                 &quot;&#39;}&#39;&quot;,
295                 Locale.ENGLISH);
296 
297             Object[] messageFields = {
298                 Utilities.byte16HexString(selectedIdentity)
299             };
300 
301             return messageFormat.format(messageFields);
302         }
</pre>
<hr />
<pre>
352             }
353 
354             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
355             if (!shc.handshakeExtensions.containsKey(
356                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
357                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
358                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
359                         &quot;extension is not the last extension&quot;);
360             }
361 
362             // error if id and binder lists are not the same length
363             if (pskSpec.identities.size() != pskSpec.binders.size()) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;PSK extension has incorrect number of binders&quot;);
366             }
367 
368             if (shc.isResumption) {     // resumingSession may not be set
369                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
370                         shc.sslContext.engineGetServerSessionContext();
371                 int idIndex = 0;


372                 for (PskIdentity requestedId : pskSpec.identities) {
<span class="line-modified">373                     SSLSessionImpl s = sessionCache.get(requestedId.identity);</span>


























374                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
375                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
376                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
377                         }
378 
379                         // binder will be checked later
380                         shc.resumingSession = s;
381                         shc.handshakeExtensions.put(SH_PRE_SHARED_KEY,
382                             new SHPreSharedKeySpec(idIndex));   // for the index
383                         break;
384                     }
385 
386                     ++idIndex;
387                 }
388 
389                 if (idIndex == pskSpec.identities.size()) {
390                     // no resumable session
391                     shc.isResumption = false;
392                     shc.resumingSession = null;
393                 }
394             }
<span class="line-removed">395 </span>
396             // update the context
397             shc.handshakeExtensions.put(
398                 SSLExtension.CH_PRE_SHARED_KEY, pskSpec);
399         }
400     }
401 
402     private static boolean canRejoin(ClientHelloMessage clientHello,
403         ServerHandshakeContext shc, SSLSessionImpl s) {
404 
<span class="line-modified">405         boolean result = s.isRejoinable() &amp;&amp; s.getPreSharedKey().isPresent();</span>
406 
407         // Check protocol version
408         if (result &amp;&amp; s.getProtocolVersion() != shc.negotiatedProtocol) {
409             if (SSLLogger.isOn &amp;&amp;
410                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
411 
412                 SSLLogger.finest(&quot;Can&#39;t resume, incorrect protocol version&quot;);
413             }
414             result = false;
415         }
416 
417         // Make sure that the server handshake context&#39;s localSupportedSignAlgs
418         // field is populated.  This is particularly important when
419         // client authentication was used in an initial session and it is
420         // now being resumed.
421         if (shc.localSupportedSignAlgs == null) {
422             shc.localSupportedSignAlgs =
423                     SignatureScheme.getSupportedAlgorithms(
424                             shc.algorithmConstraints, shc.activeProtocols);
425         }
</pre>
<hr />
<pre>
513 
514             // set up PSK binder hash
515             HandshakeHash pskBinderHash = shc.handshakeHash.copy();
516             byte[] lastMessage = pskBinderHash.removeLastReceived();
517             ByteBuffer messageBuf = ByteBuffer.wrap(lastMessage);
518             // skip the type and length
519             messageBuf.position(4);
520             // read to find the beginning of the binders
521             ClientHelloMessage.readPartial(shc.conContext, messageBuf);
522             int length = messageBuf.position();
523             messageBuf.position(0);
524             pskBinderHash.receive(messageBuf, length);
525 
526             checkBinder(shc, shc.resumingSession, pskBinderHash, binder);
527         }
528     }
529 
530     private static void checkBinder(ServerHandshakeContext shc,
531             SSLSessionImpl session,
532             HandshakeHash pskBinderHash, byte[] binder) throws IOException {
<span class="line-modified">533         Optional&lt;SecretKey&gt; pskOpt = session.getPreSharedKey();</span>
<span class="line-modified">534         if (!pskOpt.isPresent()) {</span>
535             throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
536                     &quot;Session has no PSK&quot;);
537         }
<span class="line-removed">538         SecretKey psk = pskOpt.get();</span>
539 
540         SecretKey binderKey = deriveBinderKey(shc, psk, session);
541         byte[] computedBinder =
542                 computeBinder(shc, binderKey, session, pskBinderHash);
543         if (!Arrays.equals(binder, computedBinder)) {
544             throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
545                     &quot;Incorect PSK binder value&quot;);
546         }
547     }
548 
549     // Class that produces partial messages used to compute binder hash
550     static final class PartialClientHelloMessage extends HandshakeMessage {
551 
552         private final ClientHello.ClientHelloMessage msg;
553         private final CHPreSharedKeySpec psk;
554 
555         PartialClientHelloMessage(HandshakeContext ctx,
556                                   ClientHello.ClientHelloMessage msg,
557                                   CHPreSharedKeySpec psk) {
558             super(ctx);
</pre>
<hr />
<pre>
630             ClientHandshakeContext chc = (ClientHandshakeContext)context;
631             if (!chc.isResumption || chc.resumingSession == null) {
632                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
633                     SSLLogger.fine(&quot;No session to resume.&quot;);
634                 }
635                 return null;
636             }
637 
638             // Make sure the list of supported signature algorithms matches
639             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
640                 chc.resumingSession.getLocalSupportedSignatureSchemes();
641             if (!chc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
642                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
643                     SSLLogger.fine(&quot;Existing session uses different &quot; +
644                         &quot;signature algorithms&quot;);
645                 }
646                 return null;
647             }
648 
649             // The session must have a pre-shared key
<span class="line-modified">650             Optional&lt;SecretKey&gt; pskOpt = chc.resumingSession.getPreSharedKey();</span>
<span class="line-modified">651             if (!pskOpt.isPresent()) {</span>
652                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
653                     SSLLogger.fine(&quot;Existing session has no PSK.&quot;);
654                 }
655                 return null;
656             }
<span class="line-modified">657             SecretKey psk = pskOpt.get();</span>
658             // The PSK ID can only be used in one connections, but this method
659             // may be called twice in a connection if the server sends HRR.
660             // ID is saved in the context so it can be used in the second call.
<span class="line-modified">661             Optional&lt;byte[]&gt; pskIdOpt = Optional.ofNullable(chc.pskIdentity)</span>
<span class="line-modified">662                 .or(chc.resumingSession::consumePskIdentity);</span>
<span class="line-modified">663             if (!pskIdOpt.isPresent()) {</span>


664                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
665                     SSLLogger.fine(
666                         &quot;PSK has no identity, or identity was already used&quot;);
667                 }
668                 return null;
669             }
<span class="line-removed">670             chc.pskIdentity = pskIdOpt.get();</span>
671 
672             //The session cannot be used again. Remove it from the cache.
673             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
674                 chc.sslContext.engineGetClientSessionContext();
675             sessionCache.remove(chc.resumingSession.getSessionId());
676 
677             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
678                 SSLLogger.fine(
679                     &quot;Found resumable session. Preparing PSK message.&quot;);
680             }
681 
682             List&lt;PskIdentity&gt; identities = new ArrayList&lt;&gt;();
683             int ageMillis = (int)(System.currentTimeMillis() -
684                     chc.resumingSession.getTicketCreationTime());
685             int obfuscatedAge =
686                     ageMillis + chc.resumingSession.getTicketAgeAdd();
687             identities.add(new PskIdentity(chc.pskIdentity, obfuscatedAge));
688 
689             SecretKey binderKey =
690                     deriveBinderKey(chc, psk, chc.resumingSession);
</pre>
<hr />
<pre>
692             CHPreSharedKeySpec pskPrototype = createPskPrototype(
693                 chc.resumingSession.getSuite().hashAlg.hashLength, identities);
694             HandshakeHash pskBinderHash = chc.handshakeHash.copy();
695 
696             byte[] binder = computeBinder(chc, binderKey, pskBinderHash,
697                     chc.resumingSession, chc, clientHello, pskPrototype);
698 
699             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
700             binders.add(binder);
701 
702             CHPreSharedKeySpec pskMessage =
703                     new CHPreSharedKeySpec(identities, binders);
704             chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);
705             return pskMessage.getEncoded();
706         }
707 
708         private CHPreSharedKeySpec createPskPrototype(
709                 int hashLength, List&lt;PskIdentity&gt; identities) {
710             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
711             byte[] binderProto = new byte[hashLength];
<span class="line-modified">712             for (PskIdentity curId : identities) {</span>

713                 binders.add(binderProto);
714             }
715 
716             return new CHPreSharedKeySpec(identities, binders);
717         }
718     }
719 
720     private static byte[] computeBinder(
721             HandshakeContext context, SecretKey binderKey,
722             SSLSessionImpl session,
723             HandshakeHash pskBinderHash) throws IOException {
724 
725         pskBinderHash.determine(
726                 session.getProtocolVersion(), session.getSuite());
727         pskBinderHash.update();
728         byte[] digest = pskBinderHash.digest();
729 
730         return computeBinder(context, binderKey, session, digest);
731     }
732 
</pre>
</td>
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;


 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;
 39 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 40 import sun.security.ssl.ClientHello.ClientHelloMessage;
 41 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 42 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 43 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-added"> 44 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;</span>
<span class="line-added"> 45 import sun.security.util.HexDumpEncoder;</span>
<span class="line-added"> 46 </span>
 47 import static sun.security.ssl.SSLExtension.*;
 48 
 49 /**
 50  * Pack of the &quot;pre_shared_key&quot; extension.
 51  */
 52 final class PreSharedKeyExtension {
 53     static final HandshakeProducer chNetworkProducer =
 54             new CHPreSharedKeyProducer();
 55     static final ExtensionConsumer chOnLoadConsumer =
 56             new CHPreSharedKeyConsumer();
 57     static final HandshakeAbsence chOnLoadAbsence =
 58             new CHPreSharedKeyAbsence();
 59     static final HandshakeConsumer chOnTradeConsumer =
 60             new CHPreSharedKeyUpdate();
 61     static final SSLStringizer chStringizer =
 62             new CHPreSharedKeyStringizer();
 63 
 64     static final HandshakeProducer shNetworkProducer =
 65             new SHPreSharedKeyProducer();
 66     static final ExtensionConsumer shOnLoadConsumer =
</pre>
<hr />
<pre>
 73     private static final class PskIdentity {
 74         final byte[] identity;
 75         final int obfuscatedAge;
 76 
 77         PskIdentity(byte[] identity, int obfuscatedAge) {
 78             this.identity = identity;
 79             this.obfuscatedAge = obfuscatedAge;
 80         }
 81 
 82         int getEncodedLength() {
 83             return 2 + identity.length + 4;
 84         }
 85 
 86         void writeEncoded(ByteBuffer m) throws IOException {
 87             Record.putBytes16(m, identity);
 88             Record.putInt32(m, obfuscatedAge);
 89         }
 90 
 91         @Override
 92         public String toString() {
<span class="line-modified"> 93             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +</span>
 94                 obfuscatedAge + &quot;}&quot;;
 95         }
 96     }
 97 
 98     private static final
 99             class CHPreSharedKeySpec implements SSLExtensionSpec {
100         final List&lt;PskIdentity&gt; identities;
101         final List&lt;byte[]&gt; binders;
102 
103         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
104             this.identities = identities;
105             this.binders = binders;
106         }
107 
108         CHPreSharedKeySpec(HandshakeContext context,
109                 ByteBuffer m) throws IOException {
110             // struct {
111             //     PskIdentity identities&lt;7..2^16-1&gt;;
112             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
113             // } OfferedPsks;
</pre>
<hr />
<pre>
193             int bindersEncodedLength = getBindersEncodedLength();
194             int encodedLength = 4 + idsEncodedLength + bindersEncodedLength;
195             byte[] buffer = new byte[encodedLength];
196             ByteBuffer m = ByteBuffer.wrap(buffer);
197             Record.putInt16(m, idsEncodedLength);
198             for (PskIdentity curId : identities) {
199                 curId.writeEncoded(m);
200             }
201             Record.putInt16(m, bindersEncodedLength);
202             for (byte[] curBinder : binders) {
203                 Record.putBytes8(m, curBinder);
204             }
205 
206             return buffer;
207         }
208 
209         @Override
210         public String toString() {
211             MessageFormat messageFormat = new MessageFormat(
212                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
<span class="line-modified">213                 &quot;  \&quot;identities\&quot;: &#39;{&#39;\n&quot; +</span>
<span class="line-modified">214                 &quot;{0}\n&quot; +</span>
<span class="line-added">215                 &quot;  &#39;}&#39;&quot; +</span>
<span class="line-added">216                 &quot;  \&quot;binders\&quot;: \&quot;{1}\&quot;,\n&quot; +</span>
217                 &quot;&#39;}&#39;&quot;,
218                 Locale.ENGLISH);
219 
220             Object[] messageFields = {
221                 Utilities.indent(identitiesString()),
222                 Utilities.indent(bindersString())
223             };
224 
225             return messageFormat.format(messageFields);
226         }
227 
228         String identitiesString() {
<span class="line-added">229             HexDumpEncoder hexEncoder = new HexDumpEncoder();</span>
<span class="line-added">230 </span>
231             StringBuilder result = new StringBuilder();
232             for (PskIdentity curId : identities) {
<span class="line-modified">233                 result.append(&quot;  {\n&quot;+ Utilities.indent(</span>
<span class="line-added">234                         hexEncoder.encode(curId.identity), &quot;    &quot;) +</span>
<span class="line-added">235                         &quot;\n  }\n&quot;);</span>
236             }
237 
238             return result.toString();
239         }
240 
241         String bindersString() {
242             StringBuilder result = new StringBuilder();
243             for (byte[] curBinder : binders) {
244                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
245             }
246 
247             return result.toString();
248         }
249     }
250 
251     private static final
252             class CHPreSharedKeyStringizer implements SSLStringizer {
253         @Override
254         public String toString(ByteBuffer buffer) {
255             try {
</pre>
<hr />
<pre>
269 
270     private static final
271             class SHPreSharedKeySpec implements SSLExtensionSpec {
272         final int selectedIdentity;
273 
274         SHPreSharedKeySpec(int selectedIdentity) {
275             this.selectedIdentity = selectedIdentity;
276         }
277 
278         SHPreSharedKeySpec(HandshakeContext context,
279                 ByteBuffer m) throws IOException {
280             if (m.remaining() &lt; 2) {
281                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
282                         &quot;Invalid pre_shared_key extension: &quot; +
283                         &quot;insufficient selected_identity (length=&quot; +
284                         m.remaining() + &quot;)&quot;);
285             }
286             this.selectedIdentity = Record.getInt16(m);
287         }
288 
<span class="line-modified">289         byte[] getEncoded() {</span>
290             return new byte[] {
291                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
292                 (byte)(selectedIdentity &amp; 0xFF)
293             };
294         }
295 
296         @Override
297         public String toString() {
298             MessageFormat messageFormat = new MessageFormat(
299                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
300                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
301                 &quot;&#39;}&#39;&quot;,
302                 Locale.ENGLISH);
303 
304             Object[] messageFields = {
305                 Utilities.byte16HexString(selectedIdentity)
306             };
307 
308             return messageFormat.format(messageFields);
309         }
</pre>
<hr />
<pre>
359             }
360 
361             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
362             if (!shc.handshakeExtensions.containsKey(
363                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
366                         &quot;extension is not the last extension&quot;);
367             }
368 
369             // error if id and binder lists are not the same length
370             if (pskSpec.identities.size() != pskSpec.binders.size()) {
371                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
372                         &quot;PSK extension has incorrect number of binders&quot;);
373             }
374 
375             if (shc.isResumption) {     // resumingSession may not be set
376                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
377                         shc.sslContext.engineGetServerSessionContext();
378                 int idIndex = 0;
<span class="line-added">379                 SSLSessionImpl s = null;</span>
<span class="line-added">380 </span>
381                 for (PskIdentity requestedId : pskSpec.identities) {
<span class="line-modified">382                     // If we are keeping state, see if the identity is in the cache</span>
<span class="line-added">383                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {</span>
<span class="line-added">384                         s = sessionCache.get(requestedId.identity);</span>
<span class="line-added">385                     }</span>
<span class="line-added">386                     // See if the identity is a stateless ticket</span>
<span class="line-added">387                     if (s == null &amp;&amp;</span>
<span class="line-added">388                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;</span>
<span class="line-added">389                             sessionCache.statelessEnabled()) {</span>
<span class="line-added">390                         ByteBuffer b =</span>
<span class="line-added">391                                 new SessionTicketSpec(requestedId.identity).</span>
<span class="line-added">392                                         decrypt(shc);</span>
<span class="line-added">393                         if (b != null) {</span>
<span class="line-added">394                             try {</span>
<span class="line-added">395                                 s = new SSLSessionImpl(shc, b);</span>
<span class="line-added">396                             } catch (IOException | RuntimeException e) {</span>
<span class="line-added">397                                 s = null;</span>
<span class="line-added">398                             }</span>
<span class="line-added">399                         }</span>
<span class="line-added">400                         if (b == null || s == null) {</span>
<span class="line-added">401                             if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">402                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">403                                 SSLLogger.fine(</span>
<span class="line-added">404                                         &quot;Stateless session ticket invalid&quot;);</span>
<span class="line-added">405                             }</span>
<span class="line-added">406                         }</span>
<span class="line-added">407                     }</span>
<span class="line-added">408 </span>
409                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
410                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
411                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
412                         }
413 
414                         // binder will be checked later
415                         shc.resumingSession = s;
416                         shc.handshakeExtensions.put(SH_PRE_SHARED_KEY,
417                             new SHPreSharedKeySpec(idIndex));   // for the index
418                         break;
419                     }
420 
421                     ++idIndex;
422                 }
423 
424                 if (idIndex == pskSpec.identities.size()) {
425                     // no resumable session
426                     shc.isResumption = false;
427                     shc.resumingSession = null;
428                 }
429             }

430             // update the context
431             shc.handshakeExtensions.put(
432                 SSLExtension.CH_PRE_SHARED_KEY, pskSpec);
433         }
434     }
435 
436     private static boolean canRejoin(ClientHelloMessage clientHello,
437         ServerHandshakeContext shc, SSLSessionImpl s) {
438 
<span class="line-modified">439         boolean result = s.isRejoinable() &amp;&amp; (s.getPreSharedKey() != null);</span>
440 
441         // Check protocol version
442         if (result &amp;&amp; s.getProtocolVersion() != shc.negotiatedProtocol) {
443             if (SSLLogger.isOn &amp;&amp;
444                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
445 
446                 SSLLogger.finest(&quot;Can&#39;t resume, incorrect protocol version&quot;);
447             }
448             result = false;
449         }
450 
451         // Make sure that the server handshake context&#39;s localSupportedSignAlgs
452         // field is populated.  This is particularly important when
453         // client authentication was used in an initial session and it is
454         // now being resumed.
455         if (shc.localSupportedSignAlgs == null) {
456             shc.localSupportedSignAlgs =
457                     SignatureScheme.getSupportedAlgorithms(
458                             shc.algorithmConstraints, shc.activeProtocols);
459         }
</pre>
<hr />
<pre>
547 
548             // set up PSK binder hash
549             HandshakeHash pskBinderHash = shc.handshakeHash.copy();
550             byte[] lastMessage = pskBinderHash.removeLastReceived();
551             ByteBuffer messageBuf = ByteBuffer.wrap(lastMessage);
552             // skip the type and length
553             messageBuf.position(4);
554             // read to find the beginning of the binders
555             ClientHelloMessage.readPartial(shc.conContext, messageBuf);
556             int length = messageBuf.position();
557             messageBuf.position(0);
558             pskBinderHash.receive(messageBuf, length);
559 
560             checkBinder(shc, shc.resumingSession, pskBinderHash, binder);
561         }
562     }
563 
564     private static void checkBinder(ServerHandshakeContext shc,
565             SSLSessionImpl session,
566             HandshakeHash pskBinderHash, byte[] binder) throws IOException {
<span class="line-modified">567         SecretKey psk = session.getPreSharedKey();</span>
<span class="line-modified">568         if (psk == null) {</span>
569             throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
570                     &quot;Session has no PSK&quot;);
571         }

572 
573         SecretKey binderKey = deriveBinderKey(shc, psk, session);
574         byte[] computedBinder =
575                 computeBinder(shc, binderKey, session, pskBinderHash);
576         if (!Arrays.equals(binder, computedBinder)) {
577             throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
578                     &quot;Incorect PSK binder value&quot;);
579         }
580     }
581 
582     // Class that produces partial messages used to compute binder hash
583     static final class PartialClientHelloMessage extends HandshakeMessage {
584 
585         private final ClientHello.ClientHelloMessage msg;
586         private final CHPreSharedKeySpec psk;
587 
588         PartialClientHelloMessage(HandshakeContext ctx,
589                                   ClientHello.ClientHelloMessage msg,
590                                   CHPreSharedKeySpec psk) {
591             super(ctx);
</pre>
<hr />
<pre>
663             ClientHandshakeContext chc = (ClientHandshakeContext)context;
664             if (!chc.isResumption || chc.resumingSession == null) {
665                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
666                     SSLLogger.fine(&quot;No session to resume.&quot;);
667                 }
668                 return null;
669             }
670 
671             // Make sure the list of supported signature algorithms matches
672             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
673                 chc.resumingSession.getLocalSupportedSignatureSchemes();
674             if (!chc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
675                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
676                     SSLLogger.fine(&quot;Existing session uses different &quot; +
677                         &quot;signature algorithms&quot;);
678                 }
679                 return null;
680             }
681 
682             // The session must have a pre-shared key
<span class="line-modified">683             SecretKey psk = chc.resumingSession.getPreSharedKey();</span>
<span class="line-modified">684             if (psk == null) {</span>
685                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
686                     SSLLogger.fine(&quot;Existing session has no PSK.&quot;);
687                 }
688                 return null;
689             }
<span class="line-modified">690 </span>
691             // The PSK ID can only be used in one connections, but this method
692             // may be called twice in a connection if the server sends HRR.
693             // ID is saved in the context so it can be used in the second call.
<span class="line-modified">694             if (chc.pskIdentity == null) {</span>
<span class="line-modified">695                 chc.pskIdentity = chc.resumingSession.consumePskIdentity();</span>
<span class="line-modified">696             }</span>
<span class="line-added">697 </span>
<span class="line-added">698             if (chc.pskIdentity == null) {</span>
699                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
700                     SSLLogger.fine(
701                         &quot;PSK has no identity, or identity was already used&quot;);
702                 }
703                 return null;
704             }

705 
706             //The session cannot be used again. Remove it from the cache.
707             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
708                 chc.sslContext.engineGetClientSessionContext();
709             sessionCache.remove(chc.resumingSession.getSessionId());
710 
711             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
712                 SSLLogger.fine(
713                     &quot;Found resumable session. Preparing PSK message.&quot;);
714             }
715 
716             List&lt;PskIdentity&gt; identities = new ArrayList&lt;&gt;();
717             int ageMillis = (int)(System.currentTimeMillis() -
718                     chc.resumingSession.getTicketCreationTime());
719             int obfuscatedAge =
720                     ageMillis + chc.resumingSession.getTicketAgeAdd();
721             identities.add(new PskIdentity(chc.pskIdentity, obfuscatedAge));
722 
723             SecretKey binderKey =
724                     deriveBinderKey(chc, psk, chc.resumingSession);
</pre>
<hr />
<pre>
726             CHPreSharedKeySpec pskPrototype = createPskPrototype(
727                 chc.resumingSession.getSuite().hashAlg.hashLength, identities);
728             HandshakeHash pskBinderHash = chc.handshakeHash.copy();
729 
730             byte[] binder = computeBinder(chc, binderKey, pskBinderHash,
731                     chc.resumingSession, chc, clientHello, pskPrototype);
732 
733             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
734             binders.add(binder);
735 
736             CHPreSharedKeySpec pskMessage =
737                     new CHPreSharedKeySpec(identities, binders);
738             chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);
739             return pskMessage.getEncoded();
740         }
741 
742         private CHPreSharedKeySpec createPskPrototype(
743                 int hashLength, List&lt;PskIdentity&gt; identities) {
744             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
745             byte[] binderProto = new byte[hashLength];
<span class="line-modified">746             int i = identities.size();</span>
<span class="line-added">747             while (i-- &gt; 0) {</span>
748                 binders.add(binderProto);
749             }
750 
751             return new CHPreSharedKeySpec(identities, binders);
752         }
753     }
754 
755     private static byte[] computeBinder(
756             HandshakeContext context, SecretKey binderKey,
757             SSLSessionImpl session,
758             HandshakeHash pskBinderHash) throws IOException {
759 
760         pskBinderHash.determine(
761                 session.getProtocolVersion(), session.getSuite());
762         pskBinderHash.update();
763         byte[] digest = pskBinderHash.digest();
764 
765         return computeBinder(context, binderKey, session, digest);
766     }
767 
</pre>
</td>
</tr>
</table>
<center><a href="PostHandshakeContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLCipher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
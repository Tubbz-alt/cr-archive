<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../pkcs10/PKCS10.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../provider/ConfigFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreSpi;
  36 import java.security.KeyStoreException;
  37 import java.security.PKCS12Attribute;
  38 import java.security.PrivateKey;
  39 import java.security.PrivilegedAction;
  40 import java.security.UnrecoverableEntryException;
  41 import java.security.UnrecoverableKeyException;
  42 import java.security.SecureRandom;
  43 import java.security.Security;
  44 import java.security.cert.Certificate;
  45 import java.security.cert.CertificateFactory;
  46 import java.security.cert.X509Certificate;
  47 import java.security.cert.CertificateException;
  48 import java.security.spec.AlgorithmParameterSpec;
  49 import java.security.spec.InvalidParameterSpecException;
  50 import java.security.spec.KeySpec;
  51 import java.security.spec.PKCS8EncodedKeySpec;
  52 import java.util.*;
  53 


  54 import java.security.AlgorithmParameters;
  55 import java.security.InvalidAlgorithmParameterException;
  56 import javax.crypto.spec.PBEParameterSpec;
  57 import javax.crypto.spec.PBEKeySpec;
  58 import javax.crypto.spec.SecretKeySpec;
  59 import javax.crypto.SecretKeyFactory;
  60 import javax.crypto.SecretKey;
  61 import javax.crypto.Cipher;
  62 import javax.crypto.Mac;
  63 import javax.security.auth.DestroyFailedException;
  64 import javax.security.auth.x500.X500Principal;
  65 
  66 import sun.security.tools.KeyStoreUtil;
  67 import sun.security.util.Debug;
  68 import sun.security.util.DerInputStream;
  69 import sun.security.util.DerOutputStream;
  70 import sun.security.util.DerValue;
  71 import sun.security.util.ObjectIdentifier;
  72 import sun.security.pkcs.ContentInfo;
  73 import sun.security.util.SecurityProperties;
</pre>
<hr />
<pre>
 138     public static final class DualFormatPKCS12 extends KeyStoreDelegator {
 139         public DualFormatPKCS12() {
 140             super(&quot;PKCS12&quot;, PKCS12KeyStore.class, &quot;JKS&quot;, JKS.class);
 141         }
 142     }
 143 
 144     public static final int VERSION_3 = 3;
 145 
 146     private static final int MAX_ITERATION_COUNT = 5000000;
 147     private static final int SALT_LEN = 20;
 148 
 149     // friendlyName, localKeyId, trustedKeyUsage
 150     private static final String[] CORE_ATTRIBUTES = {
 151         &quot;1.2.840.113549.1.9.20&quot;,
 152         &quot;1.2.840.113549.1.9.21&quot;,
 153         &quot;2.16.840.1.113894.746875.1.1&quot;
 154     };
 155 
 156     private static final Debug debug = Debug.getInstance(&quot;pkcs12&quot;);
 157 
<span class="line-modified"> 158     private static final int[] keyBag  = {1, 2, 840, 113549, 1, 12, 10, 1, 2};</span>
<span class="line-modified"> 159     private static final int[] certBag = {1, 2, 840, 113549, 1, 12, 10, 1, 3};</span>
<span class="line-modified"> 160     private static final int[] secretBag = {1, 2, 840, 113549, 1, 12, 10, 1, 5};</span>
<span class="line-modified"> 161 </span>
<span class="line-modified"> 162     private static final int[] pkcs9Name  = {1, 2, 840, 113549, 1, 9, 20};</span>
<span class="line-modified"> 163     private static final int[] pkcs9KeyId = {1, 2, 840, 113549, 1, 9, 21};</span>








 164 
<span class="line-removed"> 165     private static final int[] pkcs9certType = {1, 2, 840, 113549, 1, 9, 22, 1};</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167     private static final int[] pbes2 = {1, 2, 840, 113549, 1, 5, 13};</span>
<span class="line-removed"> 168     // TODO: temporary Oracle OID</span>
 169     /*
<span class="line-modified"> 170      * { joint-iso-itu-t(2) country(16) us(840) organization(1) oracle(113894)</span>
<span class="line-modified"> 171      *   jdk(746875) crypto(1) id-at-trustedKeyUsage(1) }</span>


 172      */
<span class="line-modified"> 173     private static final int[] TrustedKeyUsage =</span>
<span class="line-modified"> 174                                         {2, 16, 840, 1, 113894, 746875, 1, 1};</span>
<span class="line-modified"> 175     private static final int[] AnyExtendedKeyUsage = {2, 5, 29, 37, 0};</span>
<span class="line-modified"> 176 </span>
<span class="line-modified"> 177     private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID;</span>
<span class="line-modified"> 178     private static final ObjectIdentifier CertBag_OID;</span>
<span class="line-modified"> 179     private static final ObjectIdentifier SecretBag_OID;</span>
<span class="line-removed"> 180     private static final ObjectIdentifier PKCS9FriendlyName_OID;</span>
<span class="line-removed"> 181     private static final ObjectIdentifier PKCS9LocalKeyId_OID;</span>
<span class="line-removed"> 182     private static final ObjectIdentifier PKCS9CertType_OID;</span>
<span class="line-removed"> 183     private static final ObjectIdentifier pbes2_OID;</span>
<span class="line-removed"> 184     private static final ObjectIdentifier TrustedKeyUsage_OID;</span>
<span class="line-removed"> 185     private static final ObjectIdentifier[] AnyUsage;</span>
 186 
 187     private int counter = 0;
 188 
 189     // private key count
 190     // Note: This is a workaround to allow null localKeyID attribute
 191     // in pkcs12 with one private key entry and associated cert-chain
 192     private int privateKeyCount = 0;
 193 
 194     // secret key count
 195     private int secretKeyCount = 0;
 196 
 197     // certificate count
 198     private int certificateCount = 0;
 199 
 200     // Alg/params used for *this* keystore. Initialized as -1 for ic and
 201     // null for algorithm names. When an existing file is read, they will be
 202     // assigned inside engineLoad() so storing an existing keystore uses the
 203     // old alg/params. This makes sure if a keystore is created password-less
 204     // it will be password-less forever. Otherwise, engineStore() will read
 205     // the default values. These fields are always reset when load() is called.
 206     private String certProtectionAlgorithm = null;
 207     private int certPbeIterationCount = -1;
 208     private String macAlgorithm = null;
 209     private int macIterationCount = -1;
 210 
 211     // the source of randomness
 212     private SecureRandom random;
 213 
<span class="line-removed"> 214     static {</span>
<span class="line-removed"> 215         try {</span>
<span class="line-removed"> 216             PKCS8ShroudedKeyBag_OID = new ObjectIdentifier(keyBag);</span>
<span class="line-removed"> 217             CertBag_OID = new ObjectIdentifier(certBag);</span>
<span class="line-removed"> 218             SecretBag_OID = new ObjectIdentifier(secretBag);</span>
<span class="line-removed"> 219             PKCS9FriendlyName_OID = new ObjectIdentifier(pkcs9Name);</span>
<span class="line-removed"> 220             PKCS9LocalKeyId_OID = new ObjectIdentifier(pkcs9KeyId);</span>
<span class="line-removed"> 221             PKCS9CertType_OID = new ObjectIdentifier(pkcs9certType);</span>
<span class="line-removed"> 222             pbes2_OID = new ObjectIdentifier(pbes2);</span>
<span class="line-removed"> 223             TrustedKeyUsage_OID = new ObjectIdentifier(TrustedKeyUsage);</span>
<span class="line-removed"> 224             AnyUsage = new ObjectIdentifier[]{</span>
<span class="line-removed"> 225                 new ObjectIdentifier(AnyExtendedKeyUsage)};</span>
<span class="line-removed"> 226         } catch (IOException ioe) {</span>
<span class="line-removed"> 227             throw new AssertionError(&quot;OID not initialized&quot;, ioe);</span>
<span class="line-removed"> 228         }</span>
<span class="line-removed"> 229     }</span>
<span class="line-removed"> 230 </span>
 231     // A keystore entry and associated attributes
 232     private static class Entry {
 233         Date date; // the creation date of this entry
 234         String alias;
 235         byte[] keyId;
 236         Set&lt;KeyStore.Entry.Attribute&gt; attributes;
 237     }
 238 
 239     // A key entry
 240     private static class KeyEntry extends Entry {
 241     }
 242 
 243     // A private key entry and its supporting certificate chain
 244     private static class PrivateKeyEntry extends KeyEntry {
 245         byte[] protectedPrivKey;
 246         Certificate[] chain;
 247     };
 248 
 249     // A secret key
 250     private static class SecretKeyEntry extends KeyEntry {
</pre>
<hr />
<pre>
 670                 // Encrypt the secret key (using same PBE as for private keys)
 671                 keyEntry.protectedSecretKey =
 672                     encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);
 673 
 674                 if (debug != null) {
 675                     debug.println(&quot;Setting a protected secret key at alias &#39;&quot; +
 676                         alias + &quot;&#39;&quot;);
 677                 }
 678                 secretKeyCount++;
 679                 entry = keyEntry;
 680 
 681             } else {
 682                 throw new KeyStoreException(&quot;Unsupported Key type&quot;);
 683             }
 684 
 685             entry.attributes = new HashSet&lt;&gt;();
 686             if (attributes != null) {
 687                 entry.attributes.addAll(attributes);
 688             }
 689             // set the keyId to current date
<span class="line-modified"> 690             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(&quot;UTF8&quot;);</span>
 691             // set the alias
 692             entry.alias = alias.toLowerCase(Locale.ENGLISH);
 693             // add the entry
 694             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 695 


 696         } catch (Exception nsae) {
 697             throw new KeyStoreException(&quot;Key protection&quot; +
 698                        &quot; algorithm not found: &quot; + nsae, nsae);
 699         }
 700     }
 701 
 702     /**
 703      * Assigns the given key (that has already been protected) to the given
 704      * alias.
 705      *
 706      * &lt;p&gt;If the protected key is of type
 707      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 708      * certificate chain certifying the corresponding public key. If the
 709      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 710      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 711      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 712      *
 713      * &lt;p&gt;If the given alias already exists, the keystore information
 714      * associated with it is overridden by the given key (and possibly
 715      * certificate chain).
</pre>
<hr />
<pre>
 729         // Check that all the certs are X.509 certs
 730         checkX509Certs(chain);
 731 
 732         // Private key must be encoded as EncryptedPrivateKeyInfo
 733         // as defined in PKCS#8
 734         try {
 735             new EncryptedPrivateKeyInfo(key);
 736         } catch (IOException ioe) {
 737             throw new KeyStoreException(&quot;Private key is not stored&quot;
 738                     + &quot; as PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe, ioe);
 739         }
 740 
 741         PrivateKeyEntry entry = new PrivateKeyEntry();
 742         entry.date = new Date();
 743 
 744         if (debug != null) {
 745             debug.println(&quot;Setting a protected private key at alias &#39;&quot; +
 746                 alias + &quot;&#39;&quot;);
 747         }
 748 
<span class="line-modified"> 749         try {</span>
<span class="line-modified"> 750             // set the keyId to current date</span>
<span class="line-removed"> 751             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(&quot;UTF8&quot;);</span>
<span class="line-removed"> 752         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed"> 753             // Won&#39;t happen</span>
<span class="line-removed"> 754         }</span>
 755         // set the alias
 756         entry.alias = alias.toLowerCase(Locale.ENGLISH);
 757 
 758         entry.protectedPrivKey = key.clone();
 759         if (chain != null) {
 760             // validate cert-chain
 761             if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain))) {
 762                 throw new KeyStoreException(&quot;Certificate chain is &quot;
 763                         + &quot;not valid&quot;);
 764             }
 765             entry.chain = chain.clone();
 766             certificateCount += chain.length;
 767 
 768             if (debug != null) {
 769                 debug.println(&quot;Setting a &quot; + entry.chain.length +
 770                     &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 771             }
 772         }
 773 
 774         // add the entry
</pre>
<hr />
<pre>
2482 
2483             /*
2484              * As per PKCS12 v1.0 friendlyname (alias) and localKeyId (keyId)
2485              * are optional PKCS12 bagAttributes. But entries in the keyStore
2486              * are identified by their alias. Hence we need to have an
2487              * Unfriendlyname in the alias, if alias is null. The keyId
2488              * attribute is required to match the private key with the
2489              * certificate. If we get a bagItem of type KeyEntry with a
2490              * null keyId, we should skip it entirely.
2491              */
2492             if (bagItem instanceof KeyEntry) {
2493                 KeyEntry entry = (KeyEntry)bagItem;
2494 
2495                 if (keyId == null) {
2496                     if (bagItem instanceof PrivateKeyEntry) {
2497                        // Insert a localKeyID for the privateKey
2498                        // Note: This is a workaround to allow null localKeyID
2499                        // attribute in pkcs12 with one private key entry and
2500                        // associated cert-chain
2501                        if (privateKeyCount == 1) {
<span class="line-modified">2502                             keyId = &quot;01&quot;.getBytes(&quot;UTF8&quot;);</span>
2503                        } else {
2504                             continue;
2505                        }
2506                     } else {
2507                         // keyId in a SecretKeyEntry is not significant
<span class="line-modified">2508                         keyId = &quot;00&quot;.getBytes(&quot;UTF8&quot;);</span>
2509                     }
2510                 }
2511                 entry.keyId = keyId;
2512                 // restore date if it exists
<span class="line-modified">2513                 String keyIdStr = new String(keyId, &quot;UTF8&quot;);</span>
2514                 Date date = null;
2515                 if (keyIdStr.startsWith(&quot;Time &quot;)) {
2516                     try {
2517                         date = new Date(
2518                                 Long.parseLong(keyIdStr.substring(5)));
2519                     } catch (Exception e) {
2520                         date = null;
2521                     }
2522                 }
2523                 if (date == null) {
2524                     date = new Date();
2525                 }
2526                 entry.date = date;
2527 
2528                 if (bagItem instanceof PrivateKeyEntry) {
2529                     keyList.add((PrivateKeyEntry) entry);
2530                 }
2531                 if (entry.attributes == null) {
2532                     entry.attributes = new HashSet&lt;&gt;();
2533                 }
2534                 entry.attributes.addAll(attributes);
2535                 if (alias == null) {
2536                    alias = getUnfriendlyName();
2537                 }
2538                 entry.alias = alias;
2539                 entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
2540 
2541             } else if (bagItem instanceof X509Certificate) {
2542                 X509Certificate cert = (X509Certificate)bagItem;
2543                 // Insert a localKeyID for the corresponding cert
2544                 // Note: This is a workaround to allow null localKeyID
2545                 // attribute in pkcs12 with one private key entry and
2546                 // associated cert-chain
2547                 if ((keyId == null) &amp;&amp; (privateKeyCount == 1)) {
2548                     // insert localKeyID only for EE cert or self-signed cert
2549                     if (i == 0) {
<span class="line-modified">2550                         keyId = &quot;01&quot;.getBytes(&quot;UTF8&quot;);</span>
2551                     }
2552                 }
2553                 // Trusted certificate
2554                 if (trustedKeyUsage != null) {
2555                     if (alias == null) {
2556                         alias = getUnfriendlyName();
2557                     }
2558                     CertEntry certEntry =
2559                         new CertEntry(cert, keyId, alias, trustedKeyUsage,
2560                             attributes);
2561                     entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
2562                 } else {
2563                     certEntries.add(new CertEntry(cert, keyId, alias));
2564                 }
2565                 allCerts.add(cert);
2566             }
2567         }
2568     }
2569 
2570     private String getUnfriendlyName() {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreSpi;
  36 import java.security.KeyStoreException;
  37 import java.security.PKCS12Attribute;
  38 import java.security.PrivateKey;
  39 import java.security.PrivilegedAction;
  40 import java.security.UnrecoverableEntryException;
  41 import java.security.UnrecoverableKeyException;
  42 import java.security.SecureRandom;
  43 import java.security.Security;
  44 import java.security.cert.Certificate;
  45 import java.security.cert.CertificateFactory;
  46 import java.security.cert.X509Certificate;
  47 import java.security.cert.CertificateException;
  48 import java.security.spec.AlgorithmParameterSpec;
  49 import java.security.spec.InvalidParameterSpecException;
  50 import java.security.spec.KeySpec;
  51 import java.security.spec.PKCS8EncodedKeySpec;
  52 import java.util.*;
  53 
<span class="line-added">  54 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added">  55 </span>
  56 import java.security.AlgorithmParameters;
  57 import java.security.InvalidAlgorithmParameterException;
  58 import javax.crypto.spec.PBEParameterSpec;
  59 import javax.crypto.spec.PBEKeySpec;
  60 import javax.crypto.spec.SecretKeySpec;
  61 import javax.crypto.SecretKeyFactory;
  62 import javax.crypto.SecretKey;
  63 import javax.crypto.Cipher;
  64 import javax.crypto.Mac;
  65 import javax.security.auth.DestroyFailedException;
  66 import javax.security.auth.x500.X500Principal;
  67 
  68 import sun.security.tools.KeyStoreUtil;
  69 import sun.security.util.Debug;
  70 import sun.security.util.DerInputStream;
  71 import sun.security.util.DerOutputStream;
  72 import sun.security.util.DerValue;
  73 import sun.security.util.ObjectIdentifier;
  74 import sun.security.pkcs.ContentInfo;
  75 import sun.security.util.SecurityProperties;
</pre>
<hr />
<pre>
 140     public static final class DualFormatPKCS12 extends KeyStoreDelegator {
 141         public DualFormatPKCS12() {
 142             super(&quot;PKCS12&quot;, PKCS12KeyStore.class, &quot;JKS&quot;, JKS.class);
 143         }
 144     }
 145 
 146     public static final int VERSION_3 = 3;
 147 
 148     private static final int MAX_ITERATION_COUNT = 5000000;
 149     private static final int SALT_LEN = 20;
 150 
 151     // friendlyName, localKeyId, trustedKeyUsage
 152     private static final String[] CORE_ATTRIBUTES = {
 153         &quot;1.2.840.113549.1.9.20&quot;,
 154         &quot;1.2.840.113549.1.9.21&quot;,
 155         &quot;2.16.840.1.113894.746875.1.1&quot;
 156     };
 157 
 158     private static final Debug debug = Debug.getInstance(&quot;pkcs12&quot;);
 159 
<span class="line-modified"> 160     private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID =</span>
<span class="line-modified"> 161             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.2&quot;);</span>
<span class="line-modified"> 162     private static final ObjectIdentifier CertBag_OID =</span>
<span class="line-modified"> 163             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.3&quot;);</span>
<span class="line-modified"> 164     private static final ObjectIdentifier SecretBag_OID =</span>
<span class="line-modified"> 165             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.5&quot;);</span>
<span class="line-added"> 166     private static final ObjectIdentifier PKCS9FriendlyName_OID =</span>
<span class="line-added"> 167             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.20&quot;);</span>
<span class="line-added"> 168     private static final ObjectIdentifier PKCS9LocalKeyId_OID =</span>
<span class="line-added"> 169             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.21&quot;);</span>
<span class="line-added"> 170     private static final ObjectIdentifier PKCS9CertType_OID =</span>
<span class="line-added"> 171             ObjectIdentifier.of(&quot;1.2.840.113549.1.9.22.1&quot;);</span>
<span class="line-added"> 172     private static final ObjectIdentifier pbes2_OID =</span>
<span class="line-added"> 173             ObjectIdentifier.of(&quot;1.2.840.113549.1.5.13&quot;);</span>
 174 




 175     /*
<span class="line-modified"> 176      * Temporary Oracle OID</span>
<span class="line-modified"> 177      *</span>
<span class="line-added"> 178      * {joint-iso-itu-t(2) country(16) us(840) organization(1)</span>
<span class="line-added"> 179      *  oracle(113894) jdk(746875) crypto(1) id-at-trustedKeyUsage(1)}</span>
 180      */
<span class="line-modified"> 181     private static final ObjectIdentifier TrustedKeyUsage_OID =</span>
<span class="line-modified"> 182             ObjectIdentifier.of(&quot;2.16.840.1.113894.746875.1.1&quot;);</span>
<span class="line-modified"> 183 </span>
<span class="line-modified"> 184     private static final ObjectIdentifier[] AnyUsage = new ObjectIdentifier[] {</span>
<span class="line-modified"> 185                 // AnyExtendedKeyUsage</span>
<span class="line-modified"> 186                 ObjectIdentifier.of(&quot;2.5.29.37.0&quot;)</span>
<span class="line-modified"> 187             };</span>






 188 
 189     private int counter = 0;
 190 
 191     // private key count
 192     // Note: This is a workaround to allow null localKeyID attribute
 193     // in pkcs12 with one private key entry and associated cert-chain
 194     private int privateKeyCount = 0;
 195 
 196     // secret key count
 197     private int secretKeyCount = 0;
 198 
 199     // certificate count
 200     private int certificateCount = 0;
 201 
 202     // Alg/params used for *this* keystore. Initialized as -1 for ic and
 203     // null for algorithm names. When an existing file is read, they will be
 204     // assigned inside engineLoad() so storing an existing keystore uses the
 205     // old alg/params. This makes sure if a keystore is created password-less
 206     // it will be password-less forever. Otherwise, engineStore() will read
 207     // the default values. These fields are always reset when load() is called.
 208     private String certProtectionAlgorithm = null;
 209     private int certPbeIterationCount = -1;
 210     private String macAlgorithm = null;
 211     private int macIterationCount = -1;
 212 
 213     // the source of randomness
 214     private SecureRandom random;
 215 

















 216     // A keystore entry and associated attributes
 217     private static class Entry {
 218         Date date; // the creation date of this entry
 219         String alias;
 220         byte[] keyId;
 221         Set&lt;KeyStore.Entry.Attribute&gt; attributes;
 222     }
 223 
 224     // A key entry
 225     private static class KeyEntry extends Entry {
 226     }
 227 
 228     // A private key entry and its supporting certificate chain
 229     private static class PrivateKeyEntry extends KeyEntry {
 230         byte[] protectedPrivKey;
 231         Certificate[] chain;
 232     };
 233 
 234     // A secret key
 235     private static class SecretKeyEntry extends KeyEntry {
</pre>
<hr />
<pre>
 655                 // Encrypt the secret key (using same PBE as for private keys)
 656                 keyEntry.protectedSecretKey =
 657                     encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);
 658 
 659                 if (debug != null) {
 660                     debug.println(&quot;Setting a protected secret key at alias &#39;&quot; +
 661                         alias + &quot;&#39;&quot;);
 662                 }
 663                 secretKeyCount++;
 664                 entry = keyEntry;
 665 
 666             } else {
 667                 throw new KeyStoreException(&quot;Unsupported Key type&quot;);
 668             }
 669 
 670             entry.attributes = new HashSet&lt;&gt;();
 671             if (attributes != null) {
 672                 entry.attributes.addAll(attributes);
 673             }
 674             // set the keyId to current date
<span class="line-modified"> 675             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(UTF_8);</span>
 676             // set the alias
 677             entry.alias = alias.toLowerCase(Locale.ENGLISH);
 678             // add the entry
 679             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 680 
<span class="line-added"> 681         } catch (KeyStoreException kse) {</span>
<span class="line-added"> 682             throw kse;</span>
 683         } catch (Exception nsae) {
 684             throw new KeyStoreException(&quot;Key protection&quot; +
 685                        &quot; algorithm not found: &quot; + nsae, nsae);
 686         }
 687     }
 688 
 689     /**
 690      * Assigns the given key (that has already been protected) to the given
 691      * alias.
 692      *
 693      * &lt;p&gt;If the protected key is of type
 694      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 695      * certificate chain certifying the corresponding public key. If the
 696      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 697      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 698      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 699      *
 700      * &lt;p&gt;If the given alias already exists, the keystore information
 701      * associated with it is overridden by the given key (and possibly
 702      * certificate chain).
</pre>
<hr />
<pre>
 716         // Check that all the certs are X.509 certs
 717         checkX509Certs(chain);
 718 
 719         // Private key must be encoded as EncryptedPrivateKeyInfo
 720         // as defined in PKCS#8
 721         try {
 722             new EncryptedPrivateKeyInfo(key);
 723         } catch (IOException ioe) {
 724             throw new KeyStoreException(&quot;Private key is not stored&quot;
 725                     + &quot; as PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe, ioe);
 726         }
 727 
 728         PrivateKeyEntry entry = new PrivateKeyEntry();
 729         entry.date = new Date();
 730 
 731         if (debug != null) {
 732             debug.println(&quot;Setting a protected private key at alias &#39;&quot; +
 733                 alias + &quot;&#39;&quot;);
 734         }
 735 
<span class="line-modified"> 736         // set the keyId to current date</span>
<span class="line-modified"> 737         entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(UTF_8);</span>




 738         // set the alias
 739         entry.alias = alias.toLowerCase(Locale.ENGLISH);
 740 
 741         entry.protectedPrivKey = key.clone();
 742         if (chain != null) {
 743             // validate cert-chain
 744             if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain))) {
 745                 throw new KeyStoreException(&quot;Certificate chain is &quot;
 746                         + &quot;not valid&quot;);
 747             }
 748             entry.chain = chain.clone();
 749             certificateCount += chain.length;
 750 
 751             if (debug != null) {
 752                 debug.println(&quot;Setting a &quot; + entry.chain.length +
 753                     &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 754             }
 755         }
 756 
 757         // add the entry
</pre>
<hr />
<pre>
2465 
2466             /*
2467              * As per PKCS12 v1.0 friendlyname (alias) and localKeyId (keyId)
2468              * are optional PKCS12 bagAttributes. But entries in the keyStore
2469              * are identified by their alias. Hence we need to have an
2470              * Unfriendlyname in the alias, if alias is null. The keyId
2471              * attribute is required to match the private key with the
2472              * certificate. If we get a bagItem of type KeyEntry with a
2473              * null keyId, we should skip it entirely.
2474              */
2475             if (bagItem instanceof KeyEntry) {
2476                 KeyEntry entry = (KeyEntry)bagItem;
2477 
2478                 if (keyId == null) {
2479                     if (bagItem instanceof PrivateKeyEntry) {
2480                        // Insert a localKeyID for the privateKey
2481                        // Note: This is a workaround to allow null localKeyID
2482                        // attribute in pkcs12 with one private key entry and
2483                        // associated cert-chain
2484                        if (privateKeyCount == 1) {
<span class="line-modified">2485                             keyId = &quot;01&quot;.getBytes(UTF_8);</span>
2486                        } else {
2487                             continue;
2488                        }
2489                     } else {
2490                         // keyId in a SecretKeyEntry is not significant
<span class="line-modified">2491                         keyId = &quot;00&quot;.getBytes(UTF_8);</span>
2492                     }
2493                 }
2494                 entry.keyId = keyId;
2495                 // restore date if it exists
<span class="line-modified">2496                 String keyIdStr = new String(keyId, UTF_8);</span>
2497                 Date date = null;
2498                 if (keyIdStr.startsWith(&quot;Time &quot;)) {
2499                     try {
2500                         date = new Date(
2501                                 Long.parseLong(keyIdStr.substring(5)));
2502                     } catch (Exception e) {
2503                         date = null;
2504                     }
2505                 }
2506                 if (date == null) {
2507                     date = new Date();
2508                 }
2509                 entry.date = date;
2510 
2511                 if (bagItem instanceof PrivateKeyEntry) {
2512                     keyList.add((PrivateKeyEntry) entry);
2513                 }
2514                 if (entry.attributes == null) {
2515                     entry.attributes = new HashSet&lt;&gt;();
2516                 }
2517                 entry.attributes.addAll(attributes);
2518                 if (alias == null) {
2519                    alias = getUnfriendlyName();
2520                 }
2521                 entry.alias = alias;
2522                 entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
2523 
2524             } else if (bagItem instanceof X509Certificate) {
2525                 X509Certificate cert = (X509Certificate)bagItem;
2526                 // Insert a localKeyID for the corresponding cert
2527                 // Note: This is a workaround to allow null localKeyID
2528                 // attribute in pkcs12 with one private key entry and
2529                 // associated cert-chain
2530                 if ((keyId == null) &amp;&amp; (privateKeyCount == 1)) {
2531                     // insert localKeyID only for EE cert or self-signed cert
2532                     if (i == 0) {
<span class="line-modified">2533                         keyId = &quot;01&quot;.getBytes(UTF_8);</span>
2534                     }
2535                 }
2536                 // Trusted certificate
2537                 if (trustedKeyUsage != null) {
2538                     if (alias == null) {
2539                         alias = getUnfriendlyName();
2540                     }
2541                     CertEntry certEntry =
2542                         new CertEntry(cert, keyId, alias, trustedKeyUsage,
2543                             attributes);
2544                     entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
2545                 } else {
2546                     certEntries.add(new CertEntry(cert, keyId, alias));
2547                 }
2548                 allCerts.add(cert);
2549             }
2550         }
2551     }
2552 
2553     private String getUnfriendlyName() {
</pre>
</td>
</tr>
</table>
<center><a href="../pkcs10/PKCS10.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../provider/ConfigFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
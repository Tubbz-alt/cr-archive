<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DomainName.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.File;
 30 import java.io.FileInputStream;
 31 import java.io.FileNotFoundException;
 32 import java.io.InputStream;
 33 import java.io.InputStreamReader;
 34 import java.io.IOException;
 35 import java.security.AccessController;
 36 import java.security.PrivilegedAction;
 37 import java.util.Arrays;
 38 import java.util.HashSet;
 39 import java.util.Iterator;
 40 import java.util.LinkedList;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Set;
 44 import java.util.concurrent.ConcurrentHashMap;
 45 import java.util.zip.ZipEntry;
 46 import java.util.zip.ZipInputStream;
 47 
<a name="2" id="anc2"></a><span class="line-added"> 48 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 49 </span>
 50 import sun.security.ssl.SSLLogger;
 51 
 52 /**
 53  * Allows public suffixes and registered domains to be determined from a
 54  * string that represents a target domain name. A database of known
 55  * registered suffixes is used to perform the determination.
 56  *
 57  * A public suffix is defined as the rightmost part of a domain name
 58  * that is not owned by an individual registrant. Examples of
 59  * public suffixes are:
 60  *      com
 61  *      edu
 62  *      co.uk
 63  *      k12.ak.us
 64  *      com.tw
 65  *      \u7db2\u8def.tw
 66  *
 67  * Public suffixes effectively denote registration authorities.
 68  *
 69  * A registered domain is a public suffix preceded by one domain label
 70  * and a &quot;.&quot;. Examples are:
 71  *      oracle.com
 72  *      mit.edu
 73  *
 74  * The internal database is derived from the information maintained at
 75  * http://publicsuffix.org. The information is fixed for a particular
 76  * JDK installation, but may be updated in future releases or updates.
 77  *
 78  * Because of the large number of top-level domains (TLDs) and public
 79  * suffix rules, we only load the rules on demand -- from a Zip file
 80  * containing an entry for each TLD.
 81  *
 82  * As each entry is loaded, its data is stored permanently in a cache.
 83  *
 84  * The containment hierarchy for the data is shown below:
 85  *
 86  * Rules --&gt; contains all the rules for a particular TLD
 87  *    RuleSet --&gt; contains all the rules that match 1 label
 88  *    RuleSet --&gt; contains all the rules that match 2 labels
 89  *    RuleSet --&gt; contains all the rules that match 3 labels
 90  *      :
 91  *    RuleSet --&gt; contains all the rules that match N labels
 92  *      HashSet of rules, where each rule is an exception rule, a &quot;normal&quot;
 93  *      rule, a wildcard rule (rules that contain a wildcard prefix only),
 94  *      or a LinkedList of &quot;other&quot; rules
 95  *
 96  * The general matching algorithm tries to find a longest match. So, the
 97  * search begins at the RuleSet with the most labels, and works backwards.
 98  *
 99  * Exceptions take priority over all other rules, and if a Rule contains
100  * any exceptions, then even if we find a &quot;normal&quot; match, we search all
101  * other RuleSets for exceptions. It is assumed that all other rules don&#39;t
102  * intersect/overlap. If this happens, a match will be returned, but not
103  * necessarily the expected one. For a further explanation of the rules,
104  * see http://publicsuffix.org/list/.
105  *
106  * The &quot;other&quot; rules are for the (possible future) case where wildcards
107  * are located in a rule any place other than the beginning.
108  */
109 
110 class DomainName {
111     /**
112      * For efficiency, the set of rules for each TLD is kept
113      * in text files and only loaded if needed.
114      */
115     private static final Map&lt;String, Rules&gt; cache = new ConcurrentHashMap&lt;&gt;();
116 
117     private DomainName() {}
118 
119     /**
120      * Returns the registered domain of the specified domain.
121      *
122      * @param domain the domain name
123      * @return the registered domain, or null if not known or not registerable
124      * @throws NullPointerException if domain is null
125      */
126     public static RegisteredDomain registeredDomain(String domain) {
127         Match match = getMatch(domain);
128         return (match != null) ? match.registeredDomain() : null;
129     }
130 
131     private static Match getMatch(String domain) {
132         if (domain == null) {
133             throw new NullPointerException();
134         }
135         Rules rules = Rules.getRules(domain);
136         return rules == null ? null : rules.match(domain);
137     }
138 
139     /**
140      * A Rules object contains a list of rules for a particular TLD.
141      *
142      * Rules are stored in a linked list of RuleSet objects. The list is
143      * indexed according to the number of labels in the name (minus one)
144      * such that all rules with the same number of labels are stored
145      * in the same RuleSet.
146      *
147      * Doing this means we can find the longest match first, and also we
148      * can stop comparing as soon as we find a match.
149      */
150     private static class Rules {
151 
152         private final LinkedList&lt;RuleSet&gt; ruleSets = new LinkedList&lt;&gt;();
153         private final boolean hasExceptions;
154 
155         private Rules(InputStream is) throws IOException {
<a name="3" id="anc3"></a><span class="line-modified">156             InputStreamReader isr = new InputStreamReader(is, UTF_8);</span>
157             BufferedReader reader = new BufferedReader(isr);
158             boolean hasExceptions = false;
159 
160             String line;
161             int type = reader.read();
162             while (type != -1 &amp;&amp; (line = reader.readLine()) != null) {
163                 int numLabels = RuleSet.numLabels(line);
164                 if (numLabels != 0) {
165                     RuleSet ruleset = getRuleSet(numLabels - 1);
166                     ruleset.addRule(type, line);
167                     hasExceptions |= ruleset.hasExceptions;
168                 }
169                 type = reader.read();
170             }
171             this.hasExceptions = hasExceptions;
172         }
173 
174         static Rules getRules(String domain) {
175             String tld = getTopLevelDomain(domain);
176             if (tld.isEmpty()) {
177                 return null;
178             }
179             return cache.computeIfAbsent(tld, k -&gt; createRules(tld));
180         }
181 
182         private static String getTopLevelDomain(String domain) {
183             int n = domain.lastIndexOf(&#39;.&#39;);
184             if (n == -1) {
185                 return domain;
186             }
187             return domain.substring(n + 1);
188         }
189 
190         private static Rules createRules(String tld) {
191             try (InputStream pubSuffixStream = getPubSuffixStream()) {
192                 if (pubSuffixStream == null) {
193                     return null;
194                 }
195                 return getRules(tld, new ZipInputStream(pubSuffixStream));
196             } catch (IOException e) {
197                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
198                     SSLLogger.fine(
199                         &quot;cannot parse public suffix data for &quot; + tld +
200                          &quot;: &quot; + e.getMessage());
201                 }
202                 return null;
203             }
204         }
205 
206         private static InputStream getPubSuffixStream() {
207             InputStream is = AccessController.doPrivileged(
208                 new PrivilegedAction&lt;&gt;() {
209                     @Override
210                     public InputStream run() {
211                         File f = new File(System.getProperty(&quot;java.home&quot;),
212                             &quot;lib/security/public_suffix_list.dat&quot;);
213                         try {
214                             return new FileInputStream(f);
215                         } catch (FileNotFoundException e) {
216                             return null;
217                         }
218                     }
219                 }
220             );
221             if (is == null) {
222                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;) &amp;&amp;
223                         SSLLogger.isOn(&quot;trustmanager&quot;)) {
224                     SSLLogger.fine(
225                         &quot;lib/security/public_suffix_list.dat not found&quot;);
226                 }
227             }
228             return is;
229         }
230 
231         private static Rules getRules(String tld,
232                                       ZipInputStream zis) throws IOException {
233             boolean found = false;
234             ZipEntry ze = zis.getNextEntry();
235             while (ze != null &amp;&amp; !found) {
236                 if (ze.getName().equals(tld)) {
237                     found = true;
238                 } else {
239                     ze = zis.getNextEntry();
240                 }
241             }
242             if (!found) {
243                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
244                     SSLLogger.fine(&quot;Domain &quot; + tld + &quot; not found&quot;);
245                 }
246                 return null;
247             }
248             return new Rules(zis);
249         }
250 
251         /**
252          * Return the requested RuleSet. If it hasn&#39;t been created yet,
253          * create it and any RuleSets leading up to it.
254          */
255         private RuleSet getRuleSet(int index) {
256             if (index &lt; ruleSets.size()) {
257                 return ruleSets.get(index);
258             }
259             RuleSet r = null;
260             for (int i = ruleSets.size(); i &lt;= index; i++) {
261                 r = new RuleSet(i + 1);
262                 ruleSets.add(r);
263             }
264             return r;
265         }
266 
267         /**
268          * Find a match for the target string.
269          */
270         Match match(String domain) {
271             // Start at the end of the rules list, looking for longest match.
272             // After we find a normal match, we only look for exceptions.
273             Match possibleMatch = null;
274 
275             Iterator&lt;RuleSet&gt; it = ruleSets.descendingIterator();
276             while (it.hasNext()) {
277                 RuleSet ruleSet = it.next();
278                 Match match = ruleSet.match(domain);
279                 if (match != null) {
280                     if (match.type() == Rule.Type.EXCEPTION || !hasExceptions) {
281                         return match;
282                     }
283                     if (possibleMatch == null) {
284                         possibleMatch = match;
285                     }
286                 }
287             }
288             return possibleMatch;
289         }
290 
291         /**
292          * Represents a set of rules with the same number of labels
293          * and for a particular TLD.
294          *
295          * Examples:
296          *      numLabels = 2
297          *      names: co.uk, ac.uk
298          *      wildcards *.de (only &quot;de&quot; stored in HashSet)
299          *      exceptions: !foo.de (stored as &quot;foo.de&quot;)
300          */
301         private static class RuleSet {
302             // the number of labels in this ruleset
303             private final int numLabels;
304             private final Set&lt;Rule&gt; rules = new HashSet&lt;&gt;();
305             boolean hasExceptions = false;
306             private static final RegisteredDomain.Type[] AUTHS =
307                 RegisteredDomain.Type.values();
308 
309             RuleSet(int n) {
310                 numLabels = n;
311             }
312 
313             void addRule(int auth, String rule) {
314                 if (rule.startsWith(&quot;!&quot;)) {
315                     rules.add(new Rule(rule.substring(1), Rule.Type.EXCEPTION,
316                                        AUTHS[auth]));
317                     hasExceptions = true;
318                 } else if (rule.startsWith(&quot;*.&quot;) &amp;&amp;
319                            rule.lastIndexOf(&#39;*&#39;) == 0) {
320                     rules.add(new Rule(rule.substring(2), Rule.Type.WILDCARD,
321                                        AUTHS[auth]));
322                 } else if (rule.indexOf(&#39;*&#39;) == -1) {
323                     // a &quot;normal&quot; label
324                     rules.add(new Rule(rule, Rule.Type.NORMAL, AUTHS[auth]));
325                 } else {
326                     // There is a wildcard in a non-leading label. This case
327                     // doesn&#39;t currently exist, but we need to handle it anyway.
328                     rules.add(new OtherRule(rule, AUTHS[auth], split(rule)));
329                 }
330             }
331 
332             Match match(String domain) {
333                 Match match = null;
334                 for (Rule rule : rules) {
335                     switch (rule.type) {
336                         case NORMAL:
337                             if (match == null) {
338                                 match = matchNormal(domain, rule);
339                             }
340                             break;
341                         case WILDCARD:
342                             if (match == null) {
343                                 match = matchWildcard(domain, rule);
344                             }
345                             break;
346                         case OTHER:
347                             if (match == null) {
348                                 match = matchOther(domain, rule);
349                             }
350                             break;
351                         case EXCEPTION:
352                             Match excMatch = matchException(domain, rule);
353                             if (excMatch != null) {
354                                 return excMatch;
355                             }
356                             break;
357                     }
358                 }
359                 return match;
360             }
361 
362             private static LinkedList&lt;String&gt; split(String rule) {
363                 String[] labels = rule.split(&quot;\\.&quot;);
364                 return new LinkedList&lt;&gt;(Arrays.asList(labels));
365             }
366 
367             private static int numLabels(String rule) {
368                 if (rule.isEmpty()) {
369                     return 0;
370                 }
371                 int len = rule.length();
372                 int count = 0;
373                 int index = 0;
374                 while (index &lt; len) {
375                     int pos;
376                     if ((pos = rule.indexOf(&#39;.&#39;, index)) == -1) {
377                         return count + 1;
378                     }
379                     index = pos + 1;
380                     count++;
381                 }
382                 return count;
383             }
384 
385             /**
386              * Check for a match with an explicit name rule or a wildcard rule
387              * (i.e., a non-exception rule).
388              */
389             private Match matchNormal(String domain, Rule rule) {
390                 int index = labels(domain, numLabels);
391                 if (index == -1) {
392                     return null;
393                 }
394 
395                 // Check for explicit names.
396                 String substring = domain.substring(index);
397                 if (rule.domain.equals(substring)) {
398                     return new CommonMatch(domain, rule, index);
399                 }
400 
401                 return null;
402             }
403 
404             private Match matchWildcard(String domain, Rule rule) {
405                 // Now check for wildcards. In this case, there is one fewer
406                 // label than numLabels.
407                 int index = labels(domain, numLabels - 1);
408                 if (index &gt; 0) {
409                     String substring = domain.substring(index);
410 
411                     if (rule.domain.equals(substring)) {
412                         return new CommonMatch(domain, rule,
413                                                labels(domain, numLabels));
414                     }
415                 }
416 
417                 return null;
418             }
419 
420             /**
421              * Check for a match with an exception rule.
422              */
423             private Match matchException(String domain, Rule rule) {
424                 int index = labels(domain, numLabels);
425                 if (index == -1) {
426                     return null;
427                 }
428                 String substring = domain.substring(index);
429 
430                 if (rule.domain.equals(substring)) {
431                     return new CommonMatch(domain, rule,
432                                            labels(domain, numLabels - 1));
433                 }
434 
435                 return null;
436             }
437 
438             /**
439              * A left-to-right comparison of labels.
440              * The simplest approach to doing match() would be to
441              * use a descending iterator giving a right-to-left comparison.
442              * But, it&#39;s more efficient to do left-to-right compares
443              * because the left most labels are the ones most likely to be
444              * different. We just have to figure out which label to start at.
445              */
446             private Match matchOther(String domain, Rule rule) {
447                 OtherRule otherRule = (OtherRule)rule;
448                 LinkedList&lt;String&gt; target = split(domain);
449 
450                 int diff = target.size() - numLabels;
451                 if (diff &lt; 0) {
452                     return null;
453                 }
454 
455                 boolean found = true;
456                 for (int i = 0; i &lt; numLabels; i++) {
457                     String ruleLabel = otherRule.labels.get(i);
458                     String targetLabel = target.get(i + diff);
459 
460                     if (ruleLabel.charAt(0) != &#39;*&#39; &amp;&amp;
461                         !ruleLabel.equalsIgnoreCase(targetLabel)) {
462                         found = false;
463                         break;
464                     }
465                 }
466                 if (found) {
467                     return new OtherMatch(rule, numLabels, target);
468                 }
469                 return null;
470             }
471 
472             /**
473              * Returns a substring (index) with the n right-most labels from s.
474              * Returns -1 if s does not have at least n labels, 0, if the
475              * substring is s.
476              */
477             private static int labels(String s, int n) {
478                 if (n &lt; 1) {
479                     return -1;
480                 }
481                 int index = s.length();
482                 for (int i = 0; i &lt; n; i++) {
483                     int next = s.lastIndexOf(&#39;.&#39;, index);
484                     if (next == -1) {
485                         if (i == n - 1) {
486                             return 0;
487                         } else {
488                             return -1;
489                         }
490                     }
491                     index = next - 1;
492                 }
493                 return index + 2;
494             }
495         }
496     }
497 
498     private static class Rule {
499         enum Type { EXCEPTION, NORMAL, OTHER, WILDCARD }
500 
501         String domain;
502         Type type;
503         RegisteredDomain.Type auth;
504         Rule(String domain, Type type, RegisteredDomain.Type auth) {
505             this.domain = domain;
506             this.type = type;
507             this.auth = auth;
508         }
509     }
510 
511     private static class OtherRule extends Rule {
512         List&lt;String&gt; labels;
513         OtherRule(String domain, RegisteredDomain.Type auth,
514                   List&lt;String&gt; labels) {
515             super(domain, Type.OTHER, auth);
516             this.labels = labels;
517         }
518     }
519 
520     /**
521      * Represents a string&#39;s match with a rule in the public suffix list.
522      */
523     private interface Match {
524         RegisteredDomain registeredDomain();
525         Rule.Type type();
526     }
527 
528     private static class RegisteredDomainImpl implements RegisteredDomain {
529         private final String name;
530         private final Type type;
531         private final String publicSuffix;
532         RegisteredDomainImpl(String name, Type type, String publicSuffix) {
533             this.name = name;
534             this.type = type;
535             this.publicSuffix = publicSuffix;
536         }
537         @Override
538         public String name() {
539             return name;
540         }
541         @Override
542         public Type type() {
543             return type;
544         }
545         @Override
546         public String publicSuffix() {
547             return publicSuffix;
548         }
549     }
550 
551     /**
552      * Represents a match against a standard rule in the public suffix list.
553      * A standard rule is an explicit name, a wildcard rule with a wildcard
554      * only in the leading label, or an exception rule.
555      */
556     private static class CommonMatch implements Match {
557         private String domain;
558         private int publicSuffix; // index to
559         private int registeredDomain; // index to
560         private final Rule rule;
561 
562         CommonMatch(String domain, Rule rule, int publicSuffix) {
563             this.domain = domain;
564             this.publicSuffix = publicSuffix;
565             this.rule = rule;
566             // now locate the previous label
567             registeredDomain = domain.lastIndexOf(&#39;.&#39;, publicSuffix - 2);
568             if (registeredDomain == -1) {
569                 registeredDomain = 0;
570             } else {
571                 registeredDomain++;
572             }
573         }
574 
575         @Override
576         public RegisteredDomain registeredDomain() {
577             if (publicSuffix == 0) {
578                 return null;
579             }
580             return new RegisteredDomainImpl(domain.substring(registeredDomain),
581                                             rule.auth,
582                                             domain.substring(publicSuffix));
583         }
584 
585         @Override
586         public Rule.Type type() {
587             return rule.type;
588         }
589     }
590 
591     /**
592      * Represents a non-match with {@code NO_MATCH} or a match against
593      * a non-standard rule in the public suffix list. A non-standard rule
594      * is a wildcard rule that includes wildcards in a label other than
595      * the leading label. The public suffix list doesn&#39;t currently have
596      * such rules.
597      */
598     private static class OtherMatch implements Match {
599         private final Rule rule;
600         private final int numLabels;
601         private final LinkedList&lt;String&gt; target;
602 
603         OtherMatch(Rule rule, int numLabels, LinkedList&lt;String&gt; target) {
604             this.rule = rule;
605             this.numLabels = numLabels;
606             this.target = target;
607         }
608 
609         @Override
610         public RegisteredDomain registeredDomain() {
611             int nlabels = numLabels + 1;
612             if (nlabels &gt; target.size()) {
613                 // special case when registered domain is same as pub suff
614                 return null;
615             }
616             return new RegisteredDomainImpl(getSuffixes(nlabels),
617                                             rule.auth, getSuffixes(numLabels));
618         }
619 
620         @Override
621         public Rule.Type type() {
622             return rule.type;
623         }
624 
625         private String getSuffixes(int n) {
626             Iterator&lt;String&gt; targetIter = target.descendingIterator();
627             StringBuilder sb = new StringBuilder();
628             while (n &gt; 0 &amp;&amp; targetIter.hasNext()) {
629                 String s = targetIter.next();
630                 sb.insert(0, s);
631                 if (n &gt; 1) {
632                     sb.insert(0, &#39;.&#39;);
633                 }
634                 n--;
635             }
636             return sb.toString();
637         }
638     }
639 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
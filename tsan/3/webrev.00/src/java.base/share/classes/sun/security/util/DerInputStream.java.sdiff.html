<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerIndefLenConverter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
<span class="line-modified"> 30 import java.io.EOFException;</span>

 31 import java.util.Date;
 32 import java.util.Vector;
<span class="line-modified"> 33 import java.math.BigInteger;</span>
<span class="line-modified"> 34 import java.io.DataInputStream;</span>
 35 
 36 /**
 37  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 38  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 39  * the advantage that it allows only a single encoding of primitive data.
 40  * (High level data such as dates still support many encodings.)  That is,
 41  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 42  *
 43  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 44  * tagged data values.  Accordingly, this programming interface does
 45  * not expose any variant of the java.io.InputStream interface, since
 46  * that kind of input stream holds untagged data values and using that
 47  * I/O model could prevent correct parsing of the DER data.
 48  *
 49  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 50  * data encodings which are defined.  That subset is sufficient for parsing
 51  * most X.509 certificates.
 52  *
 53  *
 54  * @author David Brownell
</pre>
<hr />
<pre>
113     public DerInputStream(byte[] data, int offset, int len) throws IOException {
114         init(data, offset, len, true);
115     }
116 
117     /*
118      * private helper routine
119      */
120     private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {
121         if ((offset+2 &gt; data.length) || (offset+len &gt; data.length)) {
122             throw new IOException(&quot;Encoding bytes too short&quot;);
123         }
124         // check for indefinite length encoding
125         if (DerIndefLenConverter.isIndefinite(data[offset+1])) {
126             if (!allowBER) {
127                 throw new IOException(&quot;Indefinite length BER encoding found&quot;);
128             } else {
129                 byte[] inData = new byte[len];
130                 System.arraycopy(data, offset, inData, 0, len);
131 
132                 DerIndefLenConverter derIn = new DerIndefLenConverter();
<span class="line-modified">133                 buffer = new DerInputBuffer(derIn.convert(inData), allowBER);</span>





134             }
135         } else {
136             buffer = new DerInputBuffer(data, offset, len, allowBER);
137         }
138         buffer.mark(Integer.MAX_VALUE);
139     }
140 
141     DerInputStream(DerInputBuffer buf) {
142         buffer = buf;
143         buffer.mark(Integer.MAX_VALUE);
144     }
145 
146     /**
147      * Creates a new DER input stream from part of this input stream.
148      *
149      * @param len how long a chunk of the current input stream to use,
150      *          starting at the current position.
151      * @param do_skip true if the existing data in the input stream should
152      *          be skipped.  If this value is false, the next data read
153      *          on this stream and the newly created stream will be the
</pre>
<hr />
<pre>
372             if (tag != DerValue.tag_Set) {
373                 throw new IOException(&quot;Set tag error&quot;);
374             }
375         }
376         return (readVector(startLen));
377     }
378 
379     /*
380      * Read a &quot;vector&quot; of values ... set or sequence have the
381      * same encoding, except for the initial tag, so both use
382      * this same helper routine.
383      */
384     protected DerValue[] readVector(int startLen) throws IOException {
385         DerInputStream  newstr;
386 
387         byte lenByte = (byte)buffer.read();
388         int len = getLength(lenByte, buffer);
389 
390         if (len == -1) {
391            // indefinite length encoding found
<span class="line-modified">392            int readLen = buffer.available();</span>
<span class="line-modified">393            int offset = 2;     // for tag and length bytes</span>
<span class="line-modified">394            byte[] indefData = new byte[readLen + offset];</span>
<span class="line-removed">395            indefData[0] = tag;</span>
<span class="line-removed">396            indefData[1] = lenByte;</span>
<span class="line-removed">397            DataInputStream dis = new DataInputStream(buffer);</span>
<span class="line-removed">398            dis.readFully(indefData, offset, readLen);</span>
<span class="line-removed">399            dis.close();</span>
<span class="line-removed">400            DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-removed">401            buffer = new DerInputBuffer(derIn.convert(indefData), buffer.allowBER);</span>
402 
403            if (tag != buffer.read())
404                 throw new IOException(&quot;Indefinite length encoding&quot; +
405                         &quot; not supported&quot;);
406            len = DerInputStream.getDefiniteLength(buffer);
407         }
408 
409         if (len == 0)
410             // return empty array instead of null, which should be
411             // used only for missing optionals
412             return new DerValue[0];
413 
414         /*
415          * Create a temporary stream from which to read the data,
416          * unless it&#39;s not really needed.
417          */
418         if (buffer.available() == len)
419             newstr = this;
420         else
421             newstr = subStream(len, true);
</pre>
<hr />
<pre>
444             retval[i] = vec.elementAt(i);
445 
446         return retval;
447     }
448 
449     /**
450      * Get a single DER-encoded value from the input stream.
451      * It can often be useful to pull a value from the stream
452      * and defer parsing it.  For example, you can pull a nested
453      * sequence out with one call, and only examine its elements
454      * later when you really need to.
455      */
456     public DerValue getDerValue() throws IOException {
457         return new DerValue(buffer);
458     }
459 
460     /**
461      * Read a string that was encoded as a UTF8String DER value.
462      */
463     public String getUTF8String() throws IOException {
<span class="line-modified">464         return readString(DerValue.tag_UTF8String, &quot;UTF-8&quot;, &quot;UTF8&quot;);</span>
465     }
466 
467     /**
468      * Read a string that was encoded as a PrintableString DER value.
469      */
470     public String getPrintableString() throws IOException {
471         return readString(DerValue.tag_PrintableString, &quot;Printable&quot;,
<span class="line-modified">472                           &quot;ASCII&quot;);</span>
473     }
474 
475     /**
476      * Read a string that was encoded as a T61String DER value.
477      */
478     public String getT61String() throws IOException {
479         /*
480          * Works for common characters between T61 and ASCII.
481          */
<span class="line-modified">482         return readString(DerValue.tag_T61String, &quot;T61&quot;, &quot;ISO-8859-1&quot;);</span>
483     }
484 
485     /**
<span class="line-modified">486      * Read a string that was encoded as a IA5tring DER value.</span>
487      */
488     public String getIA5String() throws IOException {
<span class="line-modified">489         return readString(DerValue.tag_IA5String, &quot;IA5&quot;, &quot;ASCII&quot;);</span>
490     }
491 
492     /**
493      * Read a string that was encoded as a BMPString DER value.
494      */
495     public String getBMPString() throws IOException {
<span class="line-modified">496         return readString(DerValue.tag_BMPString, &quot;BMP&quot;,</span>
<span class="line-removed">497                           &quot;UnicodeBigUnmarked&quot;);</span>
498     }
499 
500     /**
501      * Read a string that was encoded as a GeneralString DER value.
502      */
503     public String getGeneralString() throws IOException {
504         return readString(DerValue.tag_GeneralString, &quot;General&quot;,
<span class="line-modified">505                           &quot;ASCII&quot;);</span>
506     }
507 
508     /**
509      * Private helper routine to read an encoded string from the input
510      * stream.
511      * @param stringTag the tag for the type of string to read
512      * @param stringName a name to display in error messages
513      * @param enc the encoder to use to interpret the data. Should
514      * correspond to the stringTag above.
515      */
516     private String readString(byte stringTag, String stringName,
<span class="line-modified">517                               String enc) throws IOException {</span>
518 
519         if (buffer.read() != stringTag)
520             throw new IOException(&quot;DER input not a &quot; +
521                                   stringName + &quot; string&quot;);
522 
523         int length = getDefiniteLength(buffer);
524         byte[] retval = new byte[length];
525         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))
526             throw new IOException(&quot;Short read of DER &quot; +
527                                   stringName + &quot; string&quot;);
528 
<span class="line-modified">529         return new String(retval, enc);</span>
530     }
531 
532     /**
533      * Get a UTC encoded time value from the input stream.
534      */
535     public Date getUTCTime() throws IOException {
536         if (buffer.read() != DerValue.tag_UtcTime)
537             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);
538         return buffer.getUTCTime(getDefiniteLength(buffer));
539     }
540 
541     /**
542      * Get a Generalized encoded time value from the input stream.
543      */
544     public Date getGeneralizedTime() throws IOException {
545         if (buffer.read() != DerValue.tag_GeneralizedTime)
546             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);
547         return buffer.getGeneralizedTime(getDefiniteLength(buffer));
548     }
549 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
<span class="line-modified"> 30 import java.math.BigInteger;</span>
<span class="line-added"> 31 import java.nio.charset.Charset;</span>
 32 import java.util.Date;
 33 import java.util.Vector;
<span class="line-modified"> 34 </span>
<span class="line-modified"> 35 import static java.nio.charset.StandardCharsets.*;</span>
 36 
 37 /**
 38  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 39  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 40  * the advantage that it allows only a single encoding of primitive data.
 41  * (High level data such as dates still support many encodings.)  That is,
 42  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 43  *
 44  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 45  * tagged data values.  Accordingly, this programming interface does
 46  * not expose any variant of the java.io.InputStream interface, since
 47  * that kind of input stream holds untagged data values and using that
 48  * I/O model could prevent correct parsing of the DER data.
 49  *
 50  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 51  * data encodings which are defined.  That subset is sufficient for parsing
 52  * most X.509 certificates.
 53  *
 54  *
 55  * @author David Brownell
</pre>
<hr />
<pre>
114     public DerInputStream(byte[] data, int offset, int len) throws IOException {
115         init(data, offset, len, true);
116     }
117 
118     /*
119      * private helper routine
120      */
121     private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {
122         if ((offset+2 &gt; data.length) || (offset+len &gt; data.length)) {
123             throw new IOException(&quot;Encoding bytes too short&quot;);
124         }
125         // check for indefinite length encoding
126         if (DerIndefLenConverter.isIndefinite(data[offset+1])) {
127             if (!allowBER) {
128                 throw new IOException(&quot;Indefinite length BER encoding found&quot;);
129             } else {
130                 byte[] inData = new byte[len];
131                 System.arraycopy(data, offset, inData, 0, len);
132 
133                 DerIndefLenConverter derIn = new DerIndefLenConverter();
<span class="line-modified">134                 byte[] result = derIn.convertBytes(inData);</span>
<span class="line-added">135                 if (result == null) {</span>
<span class="line-added">136                     throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="line-added">137                 } else {</span>
<span class="line-added">138                     buffer = new DerInputBuffer(result, allowBER);</span>
<span class="line-added">139                 }</span>
140             }
141         } else {
142             buffer = new DerInputBuffer(data, offset, len, allowBER);
143         }
144         buffer.mark(Integer.MAX_VALUE);
145     }
146 
147     DerInputStream(DerInputBuffer buf) {
148         buffer = buf;
149         buffer.mark(Integer.MAX_VALUE);
150     }
151 
152     /**
153      * Creates a new DER input stream from part of this input stream.
154      *
155      * @param len how long a chunk of the current input stream to use,
156      *          starting at the current position.
157      * @param do_skip true if the existing data in the input stream should
158      *          be skipped.  If this value is false, the next data read
159      *          on this stream and the newly created stream will be the
</pre>
<hr />
<pre>
378             if (tag != DerValue.tag_Set) {
379                 throw new IOException(&quot;Set tag error&quot;);
380             }
381         }
382         return (readVector(startLen));
383     }
384 
385     /*
386      * Read a &quot;vector&quot; of values ... set or sequence have the
387      * same encoding, except for the initial tag, so both use
388      * this same helper routine.
389      */
390     protected DerValue[] readVector(int startLen) throws IOException {
391         DerInputStream  newstr;
392 
393         byte lenByte = (byte)buffer.read();
394         int len = getLength(lenByte, buffer);
395 
396         if (len == -1) {
397            // indefinite length encoding found
<span class="line-modified">398            buffer = new DerInputBuffer(</span>
<span class="line-modified">399                    DerIndefLenConverter.convertStream(buffer, lenByte, tag),</span>
<span class="line-modified">400                    buffer.allowBER);</span>







401 
402            if (tag != buffer.read())
403                 throw new IOException(&quot;Indefinite length encoding&quot; +
404                         &quot; not supported&quot;);
405            len = DerInputStream.getDefiniteLength(buffer);
406         }
407 
408         if (len == 0)
409             // return empty array instead of null, which should be
410             // used only for missing optionals
411             return new DerValue[0];
412 
413         /*
414          * Create a temporary stream from which to read the data,
415          * unless it&#39;s not really needed.
416          */
417         if (buffer.available() == len)
418             newstr = this;
419         else
420             newstr = subStream(len, true);
</pre>
<hr />
<pre>
443             retval[i] = vec.elementAt(i);
444 
445         return retval;
446     }
447 
448     /**
449      * Get a single DER-encoded value from the input stream.
450      * It can often be useful to pull a value from the stream
451      * and defer parsing it.  For example, you can pull a nested
452      * sequence out with one call, and only examine its elements
453      * later when you really need to.
454      */
455     public DerValue getDerValue() throws IOException {
456         return new DerValue(buffer);
457     }
458 
459     /**
460      * Read a string that was encoded as a UTF8String DER value.
461      */
462     public String getUTF8String() throws IOException {
<span class="line-modified">463         return readString(DerValue.tag_UTF8String, &quot;UTF-8&quot;, UTF_8);</span>
464     }
465 
466     /**
467      * Read a string that was encoded as a PrintableString DER value.
468      */
469     public String getPrintableString() throws IOException {
470         return readString(DerValue.tag_PrintableString, &quot;Printable&quot;,
<span class="line-modified">471                           US_ASCII);</span>
472     }
473 
474     /**
475      * Read a string that was encoded as a T61String DER value.
476      */
477     public String getT61String() throws IOException {
478         /*
479          * Works for common characters between T61 and ASCII.
480          */
<span class="line-modified">481         return readString(DerValue.tag_T61String, &quot;T61&quot;, ISO_8859_1);</span>
482     }
483 
484     /**
<span class="line-modified">485      * Read a string that was encoded as a IA5String DER value.</span>
486      */
487     public String getIA5String() throws IOException {
<span class="line-modified">488         return readString(DerValue.tag_IA5String, &quot;IA5&quot;, US_ASCII);</span>
489     }
490 
491     /**
492      * Read a string that was encoded as a BMPString DER value.
493      */
494     public String getBMPString() throws IOException {
<span class="line-modified">495         return readString(DerValue.tag_BMPString, &quot;BMP&quot;, UTF_16BE);</span>

496     }
497 
498     /**
499      * Read a string that was encoded as a GeneralString DER value.
500      */
501     public String getGeneralString() throws IOException {
502         return readString(DerValue.tag_GeneralString, &quot;General&quot;,
<span class="line-modified">503                           US_ASCII);</span>
504     }
505 
506     /**
507      * Private helper routine to read an encoded string from the input
508      * stream.
509      * @param stringTag the tag for the type of string to read
510      * @param stringName a name to display in error messages
511      * @param enc the encoder to use to interpret the data. Should
512      * correspond to the stringTag above.
513      */
514     private String readString(byte stringTag, String stringName,
<span class="line-modified">515                               Charset charset) throws IOException {</span>
516 
517         if (buffer.read() != stringTag)
518             throw new IOException(&quot;DER input not a &quot; +
519                                   stringName + &quot; string&quot;);
520 
521         int length = getDefiniteLength(buffer);
522         byte[] retval = new byte[length];
523         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))
524             throw new IOException(&quot;Short read of DER &quot; +
525                                   stringName + &quot; string&quot;);
526 
<span class="line-modified">527         return new String(retval, charset);</span>
528     }
529 
530     /**
531      * Get a UTC encoded time value from the input stream.
532      */
533     public Date getUTCTime() throws IOException {
534         if (buffer.read() != DerValue.tag_UtcTime)
535             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);
536         return buffer.getUTCTime(getDefiniteLength(buffer));
537     }
538 
539     /**
540      * Get a Generalized encoded time value from the input stream.
541      */
542     public Date getGeneralizedTime() throws IOException {
543         if (buffer.read() != DerValue.tag_GeneralizedTime)
544             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);
545         return buffer.getGeneralizedTime(getDefiniteLength(buffer));
546     }
547 
</pre>
</td>
</tr>
</table>
<center><a href="DerIndefLenConverter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLHandshake.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLExtensions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLHandshake.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 98 
 99     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
100     HELLO_VERIFY_REQUEST        ((byte)0x03, &quot;hello_verify_request&quot;,
101         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
102             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
103                 HelloVerifyRequest.handshakeConsumer,
104                 ProtocolVersion.PROTOCOLS_TO_12
105             )
106         }),
107         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
108             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
109                 HelloVerifyRequest.handshakeProducer,
110                 ProtocolVersion.PROTOCOLS_TO_12
111             )
112         })),
113 
114     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
115     NEW_SESSION_TICKET          ((byte)0x04, &quot;new_session_ticket&quot;,
116         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
117             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
<span class="line-modified">118                 NewSessionTicket.handshakeConsumer,</span>
<span class="line-modified">119                 ProtocolVersion.PROTOCOLS_OF_13</span>
<span class="line-modified">120         )</span>




121         }),
122         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
123             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
<span class="line-modified">124                 NewSessionTicket.handshakeProducer,</span>
<span class="line-modified">125                 ProtocolVersion.PROTOCOLS_OF_13</span>
<span class="line-modified">126         )</span>
127         })),
128     END_OF_EARLY_DATA           ((byte)0x05, &quot;end_of_early_data&quot;),
129 
130     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
131     ENCRYPTED_EXTENSIONS        ((byte)0x08, &quot;encrypted_extensions&quot;,
132         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
133             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
134                 EncryptedExtensions.handshakeConsumer,
135                 ProtocolVersion.PROTOCOLS_OF_13
136             )
137         }),
138         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
139             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
140                 EncryptedExtensions.handshakeProducer,
141                 ProtocolVersion.PROTOCOLS_OF_13
142             )
143         })),
144 
145     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
146     CERTIFICATE                 ((byte)0x0B, &quot;certificate&quot;,
</pre>
<hr />
<pre>
476     @Override
477     public String toString() {
478         return name;
479     }
480 
481     static String nameOf(byte id) {
482         // If two handshake message share the same handshake type, returns
483         // the first handshake message name.
484         //
485         // It is not a big issue at present as only ServerHello and
486         // HellRetryRequest share a handshake type.
487         for (SSLHandshake hs : SSLHandshake.values()) {
488             if (hs.id == id) {
489                 return hs.name;
490             }
491         }
492 
493         return &quot;UNKNOWN-HANDSHAKE-MESSAGE(&quot; + id + &quot;)&quot;;
494     }
495 










496     static final void kickstart(HandshakeContext context) throws IOException {
497         if (context instanceof ClientHandshakeContext) {
498             // For initial handshaking, including session resumption,
499             // ClientHello message is used as the kickstart message.
500             //
501             // (D)TLS 1.2 and older protocols support renegotiation on existing
502             // connections.  A ClientHello messages is used to kickstart the
503             // renegotiation.
504             //
505             // (D)TLS 1.3 forbids renegotiation.  The post-handshake KeyUpdate
506             // message is used to update the sending cryptographic keys.
507             if (context.conContext.isNegotiated &amp;&amp;
508                     context.conContext.protocolVersion.useTLS13PlusSpec()) {
509                 // Use KeyUpdate message for renegotiation.
510                 KeyUpdate.kickstartProducer.produce(context);
511             } else {
512                 // Using ClientHello message for the initial handshaking
513                 // (including session resumption) or renegotiation.
514                 // SSLHandshake.CLIENT_HELLO.produce(context);
515                 ClientHello.kickstartProducer.produce(context);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 98 
 99     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
100     HELLO_VERIFY_REQUEST        ((byte)0x03, &quot;hello_verify_request&quot;,
101         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
102             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
103                 HelloVerifyRequest.handshakeConsumer,
104                 ProtocolVersion.PROTOCOLS_TO_12
105             )
106         }),
107         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
108             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
109                 HelloVerifyRequest.handshakeProducer,
110                 ProtocolVersion.PROTOCOLS_TO_12
111             )
112         })),
113 
114     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
115     NEW_SESSION_TICKET          ((byte)0x04, &quot;new_session_ticket&quot;,
116         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
117             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
<span class="line-modified">118                  NewSessionTicket.handshake12Consumer,</span>
<span class="line-modified">119                  ProtocolVersion.PROTOCOLS_TO_12</span>
<span class="line-modified">120             ),</span>
<span class="line-added">121             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(</span>
<span class="line-added">122                  NewSessionTicket.handshakeConsumer,</span>
<span class="line-added">123                  ProtocolVersion.PROTOCOLS_OF_13</span>
<span class="line-added">124             )</span>
125         }),
126         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
127             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
<span class="line-modified">128                  NewSessionTicket.handshake12Producer,</span>
<span class="line-modified">129                  ProtocolVersion.PROTOCOLS_TO_12</span>
<span class="line-modified">130             )</span>
131         })),
132     END_OF_EARLY_DATA           ((byte)0x05, &quot;end_of_early_data&quot;),
133 
134     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
135     ENCRYPTED_EXTENSIONS        ((byte)0x08, &quot;encrypted_extensions&quot;,
136         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
137             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
138                 EncryptedExtensions.handshakeConsumer,
139                 ProtocolVersion.PROTOCOLS_OF_13
140             )
141         }),
142         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
143             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
144                 EncryptedExtensions.handshakeProducer,
145                 ProtocolVersion.PROTOCOLS_OF_13
146             )
147         })),
148 
149     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
150     CERTIFICATE                 ((byte)0x0B, &quot;certificate&quot;,
</pre>
<hr />
<pre>
480     @Override
481     public String toString() {
482         return name;
483     }
484 
485     static String nameOf(byte id) {
486         // If two handshake message share the same handshake type, returns
487         // the first handshake message name.
488         //
489         // It is not a big issue at present as only ServerHello and
490         // HellRetryRequest share a handshake type.
491         for (SSLHandshake hs : SSLHandshake.values()) {
492             if (hs.id == id) {
493                 return hs.name;
494             }
495         }
496 
497         return &quot;UNKNOWN-HANDSHAKE-MESSAGE(&quot; + id + &quot;)&quot;;
498     }
499 
<span class="line-added">500     static boolean isKnown(byte id) {</span>
<span class="line-added">501         for (SSLHandshake hs : SSLHandshake.values()) {</span>
<span class="line-added">502             if (hs.id == id &amp;&amp; id != NOT_APPLICABLE.id) {</span>
<span class="line-added">503                 return true;</span>
<span class="line-added">504             }</span>
<span class="line-added">505         }</span>
<span class="line-added">506 </span>
<span class="line-added">507         return false;</span>
<span class="line-added">508     }</span>
<span class="line-added">509 </span>
510     static final void kickstart(HandshakeContext context) throws IOException {
511         if (context instanceof ClientHandshakeContext) {
512             // For initial handshaking, including session resumption,
513             // ClientHello message is used as the kickstart message.
514             //
515             // (D)TLS 1.2 and older protocols support renegotiation on existing
516             // connections.  A ClientHello messages is used to kickstart the
517             // renegotiation.
518             //
519             // (D)TLS 1.3 forbids renegotiation.  The post-handshake KeyUpdate
520             // message is used to update the sending cryptographic keys.
521             if (context.conContext.isNegotiated &amp;&amp;
522                     context.conContext.protocolVersion.useTLS13PlusSpec()) {
523                 // Use KeyUpdate message for renegotiation.
524                 KeyUpdate.kickstartProducer.produce(context);
525             } else {
526                 // Using ClientHello message for the initial handshaking
527                 // (including session resumption) or renegotiation.
528                 // SSLHandshake.CLIENT_HELLO.produce(context);
529                 ClientHello.kickstartProducer.produce(context);
</pre>
</td>
</tr>
</table>
<center><a href="SSLExtensions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.nio.ReadOnlyBufferException;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedActionException;
  33 import java.security.PrivilegedExceptionAction;
  34 import java.util.List;
  35 import java.util.Map;
<a name="2" id="anc2"></a>
  36 import java.util.function.BiFunction;
  37 import javax.net.ssl.SSLEngine;
  38 import javax.net.ssl.SSLEngineResult;
  39 import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  40 import javax.net.ssl.SSLEngineResult.Status;
  41 import javax.net.ssl.SSLException;
  42 import javax.net.ssl.SSLHandshakeException;
  43 import javax.net.ssl.SSLKeyException;
  44 import javax.net.ssl.SSLParameters;
  45 import javax.net.ssl.SSLPeerUnverifiedException;
  46 import javax.net.ssl.SSLProtocolException;
  47 import javax.net.ssl.SSLSession;
  48 
  49 /**
  50  * Implementation of an non-blocking SSLEngine.
  51  *
  52  * @author Brad Wetmore
  53  */
  54 final class SSLEngineImpl extends SSLEngine implements SSLTransport {
  55     private final SSLContextImpl        sslContext;
  56     final TransportContext              conContext;
<a name="3" id="anc3"></a>
  57 
  58     /**
  59      * Constructor for an SSLEngine from SSLContext, without
  60      * host/port hints.
  61      *
  62      * This Engine will not be able to cache sessions, but must renegotiate
  63      * everything by hand.
  64      */
  65     SSLEngineImpl(SSLContextImpl sslContext) {
  66         this(sslContext, null, -1);
  67     }
  68 
  69     /**
  70      * Constructor for an SSLEngine from SSLContext.
  71      */
  72     SSLEngineImpl(SSLContextImpl sslContext,
  73             String host, int port) {
  74         super(host, port);
  75         this.sslContext = sslContext;
  76         HandshakeHash handshakeHash = new HandshakeHash();
  77         if (sslContext.isDTLS()) {
  78             this.conContext = new TransportContext(sslContext, this,
  79                     new DTLSInputRecord(handshakeHash),
  80                     new DTLSOutputRecord(handshakeHash));
  81         } else {
  82             this.conContext = new TransportContext(sslContext, this,
  83                     new SSLEngineInputRecord(handshakeHash),
  84                     new SSLEngineOutputRecord(handshakeHash));
  85         }
  86 
  87         // Server name indication is a connection scope extension.
  88         if (host != null) {
  89             this.conContext.sslConfig.serverNames =
  90                     Utilities.addToSNIServerNameList(
  91                             conContext.sslConfig.serverNames, host);
  92         }
  93     }
  94 
  95     @Override
<a name="4" id="anc4"></a><span class="line-modified">  96     public synchronized void beginHandshake() throws SSLException {</span>
<span class="line-modified">  97         if (conContext.isUnsureMode) {</span>
<span class="line-removed">  98             throw new IllegalStateException(</span>
<span class="line-removed">  99                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-removed"> 100         }</span>
<span class="line-removed"> 101 </span>
 102         try {
<a name="5" id="anc5"></a><span class="line-modified"> 103             conContext.kickstart();</span>
<span class="line-modified"> 104         } catch (IOException ioe) {</span>
<span class="line-modified"> 105             throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-modified"> 106                 &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);</span>
<span class="line-modified"> 107         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 108             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 109                 &quot;Fail to begin handshake&quot;, ex);</span>









 110         }
 111     }
 112 
 113     @Override
<a name="6" id="anc6"></a><span class="line-modified"> 114     public synchronized SSLEngineResult wrap(ByteBuffer[] appData,</span>
 115             int offset, int length, ByteBuffer netData) throws SSLException {
 116         return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
 117     }
 118 
 119     // @Override
<a name="7" id="anc7"></a><span class="line-modified"> 120     public synchronized SSLEngineResult wrap(</span>
 121         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 122         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 123 
<a name="8" id="anc8"></a><span class="line-modified"> 124         if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 125             throw new IllegalStateException(</span>
<span class="line-modified"> 126                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified"> 127         }</span>


 128 
<a name="9" id="anc9"></a><span class="line-modified"> 129         // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 130         checkTaskThrown();</span>
 131 
<a name="10" id="anc10"></a><span class="line-modified"> 132         // check parameters</span>
<span class="line-modified"> 133         checkParams(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>

 134 
<a name="11" id="anc11"></a><span class="line-modified"> 135         try {</span>
<span class="line-modified"> 136             return writeRecord(</span>
<span class="line-modified"> 137                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 138         } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 139             // may be an unexpected handshake message</span>
<span class="line-modified"> 140             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);</span>
<span class="line-modified"> 141         } catch (IOException ioe) {</span>
<span class="line-modified"> 142             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 143                 &quot;problem wrapping app data&quot;, ioe);</span>
<span class="line-modified"> 144         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 145             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 146                 &quot;Fail to wrap application data&quot;, ex);</span>



 147         }
 148     }
 149 
 150     private SSLEngineResult writeRecord(
 151         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 152         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 153 
 154         // May need to deliver cached records.
 155         if (isOutboundDone()) {
 156             return new SSLEngineResult(
 157                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 158         }
 159 
 160         HandshakeContext hc = conContext.handshakeContext;
 161         HandshakeStatus hsStatus = null;
 162         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 163                 !conContext.isInboundClosed() &amp;&amp;
 164                 !conContext.isOutboundClosed()) {
 165             conContext.kickstart();
 166 
 167             hsStatus = getHandshakeStatus();
 168             if (hsStatus == HandshakeStatus.NEED_UNWRAP) {
 169                 /*
 170                  * For DTLS, if the handshake state is
 171                  * HandshakeStatus.NEED_UNWRAP, a call to SSLEngine.wrap()
 172                  * means that the previous handshake packets (if delivered)
 173                  * get lost, and need retransmit the handshake messages.
 174                  */
 175                 if (!sslContext.isDTLS() || hc == null ||
 176                         !hc.sslConfig.enableRetransmissions ||
 177                         conContext.outputRecord.firstMessage) {
 178 
 179                     return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 180                 }   // otherwise, need retransmission
 181             }
 182         }
 183 
 184         if (hsStatus == null) {
 185             hsStatus = getHandshakeStatus();
 186         }
 187 
 188         /*
 189          * If we have a task outstanding, this *MUST* be done before
 190          * doing any more wrapping, because we could be in the middle
 191          * of receiving a handshake message, for example, a finished
 192          * message which would change the ciphers.
 193          */
 194         if (hsStatus == HandshakeStatus.NEED_TASK) {
 195             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 196         }
 197 
 198         int dstsRemains = 0;
 199         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 200             dstsRemains += dsts[i].remaining();
 201         }
 202 
 203         // Check destination buffer size.
 204         //
 205         // We can be smarter about using smaller buffer sizes later.  For
 206         // now, force it to be large enough to handle any valid record.
 207         if (dstsRemains &lt; conContext.conSession.getPacketBufferSize()) {
 208             return new SSLEngineResult(
 209                 Status.BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);
 210         }
 211 
 212         int srcsRemains = 0;
 213         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 214             srcsRemains += srcs[i].remaining();
 215         }
 216 
 217         Ciphertext ciphertext = null;
 218         try {
 219             // Acquire the buffered to-be-delivered records or retransmissions.
 220             //
 221             // May have buffered records, or need retransmission if handshaking.
 222             if (!conContext.outputRecord.isEmpty() || (hc != null &amp;&amp;
 223                     hc.sslConfig.enableRetransmissions &amp;&amp;
 224                     hc.sslContext.isDTLS() &amp;&amp;
 225                     hsStatus == HandshakeStatus.NEED_UNWRAP)) {
 226                 ciphertext = encode(null, 0, 0,
 227                         dsts, dstsOffset, dstsLength);
 228             }
 229 
 230             if (ciphertext == null &amp;&amp; srcsRemains != 0) {
 231                 ciphertext = encode(srcs, srcsOffset, srcsLength,
 232                         dsts, dstsOffset, dstsLength);
 233             }
 234         } catch (IOException ioe) {
 235             if (ioe instanceof SSLException) {
 236                 throw ioe;
 237             } else {
 238                 throw new SSLException(&quot;Write problems&quot;, ioe);
 239             }
 240         }
 241 
 242         /*
 243          * Check for status.
 244          */
 245         Status status = (isOutboundDone() ? Status.CLOSED : Status.OK);
 246         if (ciphertext != null &amp;&amp; ciphertext.handshakeStatus != null) {
 247             hsStatus = ciphertext.handshakeStatus;
 248         } else {
 249             hsStatus = getHandshakeStatus();
 250             if (ciphertext == null &amp;&amp; !conContext.isNegotiated &amp;&amp;
 251                     conContext.isInboundClosed() &amp;&amp;
 252                     hsStatus == HandshakeStatus.NEED_WRAP) {
 253                 // Even the outboud is open, no futher data could be wrapped as:
 254                 //     1. the outbound is empty
 255                 //     2. no negotiated connection
 256                 //     3. the inbound has closed, cannot complete the handshake
 257                 //
 258                 // Mark the engine as closed if the handshake status is
 259                 // NEED_WRAP. Otherwise, it could lead to dead loops in
 260                 // applications.
 261                 status = Status.CLOSED;
 262             }
 263         }
 264 
 265         int deltaSrcs = srcsRemains;
 266         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 267             deltaSrcs -= srcs[i].remaining();
 268         }
 269 
 270         int deltaDsts = dstsRemains;
 271         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 272             deltaDsts -= dsts[i].remaining();
 273         }
 274 
 275         return new SSLEngineResult(status, hsStatus, deltaSrcs, deltaDsts,
 276                 ciphertext != null ? ciphertext.recordSN : -1L);
 277     }
 278 
 279     private Ciphertext encode(
 280         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 281         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 282 
 283         Ciphertext ciphertext = null;
 284         try {
 285             ciphertext = conContext.outputRecord.encode(
 286                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);
 287         } catch (SSLHandshakeException she) {
 288             // may be record sequence number overflow
 289             throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
 290         } catch (IOException e) {
 291             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);
 292         }
 293 
 294         if (ciphertext == null) {
 295             return null;
 296         }
 297 
 298         // Is the handshake completed?
 299         boolean needRetransmission =
 300                 conContext.sslContext.isDTLS() &amp;&amp;
 301                 conContext.handshakeContext != null &amp;&amp;
 302                 conContext.handshakeContext.sslConfig.enableRetransmissions;
 303         HandshakeStatus hsStatus =
 304                 tryToFinishHandshake(ciphertext.contentType);
 305         if (needRetransmission &amp;&amp;
 306                 hsStatus == HandshakeStatus.FINISHED &amp;&amp;
 307                 conContext.sslContext.isDTLS() &amp;&amp;
 308                 ciphertext.handshakeType == SSLHandshake.FINISHED.id) {
 309             // Retransmit the last flight for DTLS.
 310             //
 311             // The application data transactions may begin immediately
 312             // after the last flight.  If the last flight get lost, the
 313             // application data may be discarded accordingly.  As could
 314             // be an issue for some applications.  This impact can be
 315             // mitigated by sending the last fligth twice.
 316             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 317                 SSLLogger.finest(&quot;retransmit the last flight messages&quot;);
 318             }
 319 
 320             conContext.outputRecord.launchRetransmission();
 321             hsStatus = HandshakeStatus.NEED_WRAP;
 322         }
 323 
 324         if (hsStatus == null) {
 325             hsStatus = conContext.getHandshakeStatus();
 326         }
 327 
 328         // Is the sequence number is nearly overflow?
 329         if (conContext.outputRecord.seqNumIsHuge() ||
 330                 conContext.outputRecord.writeCipher.atKeyLimit()) {
 331             hsStatus = tryKeyUpdate(hsStatus);
 332         }
 333 
<a name="12" id="anc12"></a>





 334         // update context status
 335         ciphertext.handshakeStatus = hsStatus;
 336 
 337         return ciphertext;
 338     }
 339 
 340     private HandshakeStatus tryToFinishHandshake(byte contentType) {
 341         HandshakeStatus hsStatus = null;
 342         if ((contentType == ContentType.HANDSHAKE.id) &amp;&amp;
 343                 conContext.outputRecord.isEmpty()) {
 344             if (conContext.handshakeContext == null) {
 345                 hsStatus = HandshakeStatus.FINISHED;
 346             } else if (conContext.isPostHandshakeContext()) {
 347                 // unlikely, but just in case.
 348                 hsStatus = conContext.finishPostHandshake();
 349             } else if (conContext.handshakeContext.handshakeFinished) {
 350                 hsStatus = conContext.finishHandshake();
 351             }
 352         }   // Otherwise, the followed call to getHSStatus() will help.
 353 
 354         return hsStatus;
 355     }
 356 
 357     /**
 358      * Try key update for sequence number wrap or key usage limit.
 359      *
 360      * Note that in order to maintain the handshake status properly, we check
 361      * the sequence number and key usage limit after the last record
 362      * reading/writing process.
 363      *
 364      * As we request renegotiation or close the connection for wrapped sequence
 365      * number when there is enough sequence number space left to handle a few
 366      * more records, so the sequence number of the last record cannot be
 367      * wrapped.
 368      */
 369     private HandshakeStatus tryKeyUpdate(
 370             HandshakeStatus currentHandshakeStatus) throws IOException {
 371         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
 372         // connection is not duplex-open.
 373         if ((conContext.handshakeContext == null) &amp;&amp;
 374                 !conContext.isOutboundClosed() &amp;&amp;
 375                 !conContext.isInboundClosed() &amp;&amp;
 376                 !conContext.isBroken) {
 377             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 378                 SSLLogger.finest(&quot;trigger key update&quot;);
 379             }
 380             beginHandshake();
 381             return conContext.getHandshakeStatus();
 382         }
 383 
 384         return currentHandshakeStatus;
 385     }
 386 
<a name="13" id="anc13"></a>






















 387     private static void checkParams(
 388             ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 389             ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
 390 
 391         if ((srcs == null) || (dsts == null)) {
 392             throw new IllegalArgumentException(
 393                     &quot;source or destination buffer is null&quot;);
 394         }
 395 
 396         if ((dstsOffset &lt; 0) || (dstsLength &lt; 0) ||
 397                 (dstsOffset &gt; dsts.length - dstsLength)) {
 398             throw new IndexOutOfBoundsException(
 399                     &quot;index out of bound of the destination buffers&quot;);
 400         }
 401 
 402         if ((srcsOffset &lt; 0) || (srcsLength &lt; 0) ||
 403                 (srcsOffset &gt; srcs.length - srcsLength)) {
 404             throw new IndexOutOfBoundsException(
 405                     &quot;index out of bound of the source buffers&quot;);
 406         }
 407 
 408         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 409             if (dsts[i] == null) {
 410                 throw new IllegalArgumentException(
 411                         &quot;destination buffer[&quot; + i + &quot;] == null&quot;);
 412             }
 413 
 414             /*
 415              * Make sure the destination bufffers are writable.
 416              */
 417             if (dsts[i].isReadOnly()) {
 418                 throw new ReadOnlyBufferException();
 419             }
 420         }
 421 
 422         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 423             if (srcs[i] == null) {
 424                 throw new IllegalArgumentException(
 425                         &quot;source buffer[&quot; + i + &quot;] == null&quot;);
 426             }
 427         }
 428     }
 429 
 430     @Override
<a name="14" id="anc14"></a><span class="line-modified"> 431     public synchronized SSLEngineResult unwrap(ByteBuffer src,</span>
 432             ByteBuffer[] dsts, int offset, int length) throws SSLException {
 433         return unwrap(
 434                 new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
 435     }
 436 
 437     // @Override
<a name="15" id="anc15"></a><span class="line-modified"> 438     public synchronized SSLEngineResult unwrap(</span>
 439         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 440         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
 441 
<a name="16" id="anc16"></a><span class="line-modified"> 442         if (conContext.isUnsureMode) {</span>
<span class="line-modified"> 443             throw new IllegalStateException(</span>
<span class="line-modified"> 444                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified"> 445         }</span>


 446 
<a name="17" id="anc17"></a><span class="line-modified"> 447         // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified"> 448         checkTaskThrown();</span>
 449 
<a name="18" id="anc18"></a><span class="line-modified"> 450         // check parameters</span>
<span class="line-modified"> 451         checkParams(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>

 452 
<a name="19" id="anc19"></a><span class="line-modified"> 453         try {</span>
<span class="line-modified"> 454             return readRecord(</span>
<span class="line-modified"> 455                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified"> 456         } catch (SSLProtocolException spe) {</span>
<span class="line-modified"> 457             // may be an unexpected handshake message</span>
<span class="line-modified"> 458             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified"> 459                     spe.getMessage(), spe);</span>
<span class="line-modified"> 460         } catch (IOException ioe) {</span>
<span class="line-modified"> 461             /*</span>
<span class="line-modified"> 462              * Don&#39;t reset position so it looks like we didn&#39;t</span>
<span class="line-modified"> 463              * consume anything.  We did consume something, and it</span>
<span class="line-modified"> 464              * got us into this situation, so report that much back.</span>
<span class="line-modified"> 465              * Our days of consuming are now over anyway.</span>
<span class="line-modified"> 466              */</span>
<span class="line-modified"> 467             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 468                     &quot;problem unwrapping net record&quot;, ioe);</span>
<span class="line-modified"> 469         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified"> 470             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 471                 &quot;Fail to unwrap network record&quot;, ex);</span>



 472         }
 473     }
 474 
 475     private SSLEngineResult readRecord(
 476         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 477         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 478 
 479         /*
 480          * Check if we are closing/closed.
 481          */
 482         if (isInboundDone()) {
 483             return new SSLEngineResult(
 484                     Status.CLOSED, getHandshakeStatus(), 0, 0);
 485         }
 486 
 487         HandshakeStatus hsStatus = null;
 488         if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 489                 !conContext.isInboundClosed() &amp;&amp;
 490                 !conContext.isOutboundClosed()) {
 491             conContext.kickstart();
 492 
 493             /*
 494              * If there&#39;s still outbound data to flush, we
 495              * can return without trying to unwrap anything.
 496              */
 497             hsStatus = getHandshakeStatus();
 498             if (hsStatus == HandshakeStatus.NEED_WRAP) {
 499                 return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 500             }
 501         }
 502 
 503         if (hsStatus == null) {
 504             hsStatus = getHandshakeStatus();
 505         }
 506 
 507         /*
 508          * If we have a task outstanding, this *MUST* be done before
 509          * doing any more unwrapping, because we could be in the middle
 510          * of receiving a handshake message, for example, a finished
 511          * message which would change the ciphers.
 512          */
 513         if (hsStatus == HandshakeStatus.NEED_TASK) {
 514             return new SSLEngineResult(Status.OK, hsStatus, 0, 0);
 515         }
 516 
 517         if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
 518             Plaintext plainText = null;
 519             try {
 520                 plainText = decode(null, 0, 0,
 521                         dsts, dstsOffset, dstsLength);
 522             } catch (IOException ioe) {
 523                 if (ioe instanceof SSLException) {
 524                     throw ioe;
 525                 } else {
 526                     throw new SSLException(&quot;readRecord&quot;, ioe);
 527                 }
 528             }
 529 
 530             Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 531             if (plainText.handshakeStatus != null) {
 532                 hsStatus = plainText.handshakeStatus;
 533             } else {
 534                 hsStatus = getHandshakeStatus();
 535             }
 536 
 537             return new SSLEngineResult(
 538                     status, hsStatus, 0, 0, plainText.recordSN);
 539         }
 540 
 541         int srcsRemains = 0;
 542         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 543             srcsRemains += srcs[i].remaining();
 544         }
 545 
 546         if (srcsRemains == 0) {
 547             return new SSLEngineResult(
 548                 Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 549         }
 550 
 551         /*
 552          * Check the packet to make sure enough is here.
 553          * This will also indirectly check for 0 len packets.
 554          */
 555         int packetLen = 0;
 556         try {
 557             packetLen = conContext.inputRecord.bytesInCompletePacket(
 558                     srcs, srcsOffset, srcsLength);
 559         } catch (SSLException ssle) {
 560             // Need to discard invalid records for DTLS protocols.
 561             if (sslContext.isDTLS()) {
 562                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,verbose&quot;)) {
 563                     SSLLogger.finest(&quot;Discard invalid DTLS records&quot;, ssle);
 564                 }
 565 
 566                 // invalid, discard the entire data [section 4.1.2.7, RFC 6347]
 567                 int deltaNet = 0;
 568                 // int deltaNet = netData.remaining();
 569                 // netData.position(netData.limit());
 570 
 571                 Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 572                 if (hsStatus == null) {
 573                     hsStatus = getHandshakeStatus();
 574                 }
 575 
 576                 return new SSLEngineResult(status, hsStatus, deltaNet, 0, -1L);
 577             } else {
 578                 throw ssle;
 579             }
 580         }
 581 
 582         // Is this packet bigger than SSL/TLS normally allows?
 583         if (packetLen &gt; conContext.conSession.getPacketBufferSize()) {
 584             int largestRecordSize = sslContext.isDTLS() ?
 585                     DTLSRecord.maxRecordSize : SSLRecord.maxLargeRecordSize;
 586             if ((packetLen &lt;= largestRecordSize) &amp;&amp; !sslContext.isDTLS()) {
 587                 // Expand the expected maximum packet/application buffer
 588                 // sizes.
 589                 //
 590                 // Only apply to SSL/TLS protocols.
 591 
 592                 // Old behavior: shall we honor the System Property
 593                 // &quot;jsse.SSLEngine.acceptLargeFragments&quot; if it is &quot;false&quot;?
 594                 conContext.conSession.expandBufferSizes();
 595             }
 596 
 597             // check the packet again
 598             largestRecordSize = conContext.conSession.getPacketBufferSize();
 599             if (packetLen &gt; largestRecordSize) {
 600                 throw new SSLProtocolException(
 601                         &quot;Input record too big: max = &quot; +
 602                         largestRecordSize + &quot; len = &quot; + packetLen);
 603             }
 604         }
 605 
 606         /*
 607          * Check for OVERFLOW.
 608          *
 609          * Delay enforcing the application buffer free space requirement
 610          * until after the initial handshaking.
 611          */
 612         int dstsRemains = 0;
 613         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 614             dstsRemains += dsts[i].remaining();
 615         }
 616 
 617         if (conContext.isNegotiated) {
 618             int FragLen =
 619                     conContext.inputRecord.estimateFragmentSize(packetLen);
 620             if (FragLen &gt; dstsRemains) {
 621                 return new SSLEngineResult(
 622                         Status.BUFFER_OVERFLOW, hsStatus, 0, 0);
 623             }
 624         }
 625 
 626         // check for UNDERFLOW.
 627         if ((packetLen == -1) || (srcsRemains &lt; packetLen)) {
 628             return new SSLEngineResult(Status.BUFFER_UNDERFLOW, hsStatus, 0, 0);
 629         }
 630 
 631         /*
 632          * We&#39;re now ready to actually do the read.
 633          */
 634         Plaintext plainText = null;
 635         try {
 636             plainText = decode(srcs, srcsOffset, srcsLength,
 637                             dsts, dstsOffset, dstsLength);
 638         } catch (IOException ioe) {
 639             if (ioe instanceof SSLException) {
 640                 throw ioe;
 641             } else {
 642                 throw new SSLException(&quot;readRecord&quot;, ioe);
 643             }
 644         }
 645 
 646         /*
 647          * Check the various condition that we could be reporting.
 648          *
 649          * It&#39;s *possible* something might have happened between the
 650          * above and now, but it was better to minimally lock &quot;this&quot;
 651          * during the read process.  We&#39;ll return the current
 652          * status, which is more representative of the current state.
 653          *
 654          * status above should cover:  FINISHED, NEED_TASK
 655          */
 656         Status status = (isInboundDone() ? Status.CLOSED : Status.OK);
 657         if (plainText.handshakeStatus != null) {
 658             hsStatus = plainText.handshakeStatus;
 659         } else {
 660             hsStatus = getHandshakeStatus();
 661         }
 662 
 663         int deltaNet = srcsRemains;
 664         for (int i = srcsOffset; i &lt; srcsOffset + srcsLength; i++) {
 665             deltaNet -= srcs[i].remaining();
 666         }
 667 
 668         int deltaApp = dstsRemains;
 669         for (int i = dstsOffset; i &lt; dstsOffset + dstsLength; i++) {
 670             deltaApp -= dsts[i].remaining();
 671         }
 672 
 673         return new SSLEngineResult(
 674                 status, hsStatus, deltaNet, deltaApp, plainText.recordSN);
 675     }
 676 
 677     private Plaintext decode(
 678         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
 679         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
 680 
 681         Plaintext pt = SSLTransport.decode(conContext,
 682                             srcs, srcsOffset, srcsLength,
 683                             dsts, dstsOffset, dstsLength);
 684 
 685         // Is the handshake completed?
 686         if (pt != Plaintext.PLAINTEXT_NULL) {
 687             HandshakeStatus hsStatus = tryToFinishHandshake(pt.contentType);
 688             if (hsStatus == null) {
 689                 pt.handshakeStatus = conContext.getHandshakeStatus();
 690             } else {
 691                 pt.handshakeStatus = hsStatus;
 692             }
 693 
 694             // Is the sequence number is nearly overflow?
 695             if (conContext.inputRecord.seqNumIsHuge() ||
 696                     conContext.inputRecord.readCipher.atKeyLimit()) {
 697                 pt.handshakeStatus =
 698                         tryKeyUpdate(pt.handshakeStatus);
 699             }
 700         }
 701 
 702         return pt;
 703     }
 704 
 705     @Override
<a name="20" id="anc20"></a><span class="line-modified"> 706     public synchronized Runnable getDelegatedTask() {</span>
<span class="line-modified"> 707         if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake</span>
<span class="line-modified"> 708                 !conContext.handshakeContext.taskDelegated &amp;&amp;</span>
<span class="line-modified"> 709                 !conContext.handshakeContext.delegatedActions.isEmpty()) {</span>
<span class="line-modified"> 710             conContext.handshakeContext.taskDelegated = true;</span>
<span class="line-modified"> 711             return new DelegatedTask(this);</span>





 712         }
 713 
 714         return null;
 715     }
 716 
 717     @Override
<a name="21" id="anc21"></a><span class="line-modified"> 718     public synchronized void closeInbound() throws SSLException {</span>
<span class="line-modified"> 719         if (isInboundDone()) {</span>
<span class="line-modified"> 720             return;</span>
<span class="line-modified"> 721         }</span>


 722 
<a name="22" id="anc22"></a><span class="line-modified"> 723         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 724             SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);</span>
<span class="line-modified"> 725         }</span>
 726 
<a name="23" id="anc23"></a><span class="line-modified"> 727         // Is it ready to close inbound?</span>
<span class="line-modified"> 728         //</span>
<span class="line-modified"> 729         // No need to throw exception if the initial handshake is not started.</span>
<span class="line-modified"> 730         if (!conContext.isInputCloseNotified &amp;&amp;</span>
<span class="line-modified"> 731             (conContext.isNegotiated || conContext.handshakeContext != null)) {</span>

 732 
<a name="24" id="anc24"></a><span class="line-modified"> 733             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified"> 734                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);</span>
<span class="line-modified"> 735         }</span>
 736 
<a name="25" id="anc25"></a><span class="line-modified"> 737         conContext.closeInbound();</span>



 738     }
 739 
 740     @Override
<a name="26" id="anc26"></a><span class="line-modified"> 741     public synchronized boolean isInboundDone() {</span>
<span class="line-modified"> 742         return conContext.isInboundClosed();</span>





 743     }
 744 
 745     @Override
<a name="27" id="anc27"></a><span class="line-modified"> 746     public synchronized void closeOutbound() {</span>
<span class="line-modified"> 747         if (conContext.isOutboundClosed()) {</span>
<span class="line-modified"> 748             return;</span>
<span class="line-modified"> 749         }</span>


 750 
<a name="28" id="anc28"></a><span class="line-modified"> 751         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 752             SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);</span>
<span class="line-modified"> 753         }</span>
 754 
<a name="29" id="anc29"></a><span class="line-modified"> 755         conContext.closeOutbound();</span>



 756     }
 757 
 758     @Override
<a name="30" id="anc30"></a><span class="line-modified"> 759     public synchronized boolean isOutboundDone() {</span>
<span class="line-modified"> 760         return conContext.isOutboundDone();</span>





 761     }
 762 
 763     @Override
 764     public String[] getSupportedCipherSuites() {
 765         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 766     }
 767 
 768     @Override
<a name="31" id="anc31"></a><span class="line-modified"> 769     public synchronized String[] getEnabledCipherSuites() {</span>
<span class="line-modified"> 770         return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>





 771     }
 772 
 773     @Override
<a name="32" id="anc32"></a><span class="line-modified"> 774     public synchronized void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified"> 775         conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-modified"> 776                 CipherSuite.validValuesOf(suites);</span>





 777     }
 778 
 779     @Override
 780     public String[] getSupportedProtocols() {
 781         return ProtocolVersion.toStringArray(
 782                 sslContext.getSupportedProtocolVersions());
 783     }
 784 
 785     @Override
<a name="33" id="anc33"></a><span class="line-modified"> 786     public synchronized String[] getEnabledProtocols() {</span>
<span class="line-modified"> 787         return ProtocolVersion.toStringArray(</span>
<span class="line-modified"> 788                 conContext.sslConfig.enabledProtocols);</span>





 789     }
 790 
 791     @Override
<a name="34" id="anc34"></a><span class="line-modified"> 792     public synchronized void setEnabledProtocols(String[] protocols) {</span>
<span class="line-modified"> 793         if (protocols == null) {</span>
<span class="line-modified"> 794             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);</span>
<span class="line-modified"> 795         }</span>


 796 
<a name="35" id="anc35"></a><span class="line-modified"> 797         conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified"> 798                 ProtocolVersion.namesOf(protocols);</span>



 799     }
 800 
 801     @Override
<a name="36" id="anc36"></a><span class="line-modified"> 802     public synchronized SSLSession getSession() {</span>
<span class="line-modified"> 803         return conContext.conSession;</span>





 804     }
 805 
 806     @Override
<a name="37" id="anc37"></a><span class="line-modified"> 807     public synchronized SSLSession getHandshakeSession() {</span>
<span class="line-modified"> 808         return conContext.handshakeContext == null ?</span>
<span class="line-modified"> 809                 null : conContext.handshakeContext.handshakeSession;</span>





 810     }
 811 
 812     @Override
<a name="38" id="anc38"></a><span class="line-modified"> 813     public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {</span>
<span class="line-modified"> 814         return conContext.getHandshakeStatus();</span>





 815     }
 816 
 817     @Override
<a name="39" id="anc39"></a><span class="line-modified"> 818     public synchronized void setUseClientMode(boolean mode) {</span>
<span class="line-modified"> 819         conContext.setUseClientMode(mode);</span>





 820     }
 821 
 822     @Override
<a name="40" id="anc40"></a><span class="line-modified"> 823     public synchronized boolean getUseClientMode() {</span>
<span class="line-modified"> 824         return conContext.sslConfig.isClientMode;</span>





 825     }
 826 
 827     @Override
<a name="41" id="anc41"></a><span class="line-modified"> 828     public synchronized void setNeedClientAuth(boolean need) {</span>
<span class="line-modified"> 829         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified"> 830                 (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-modified"> 831                         ClientAuthType.CLIENT_AUTH_NONE);</span>





 832     }
 833 
 834     @Override
<a name="42" id="anc42"></a><span class="line-modified"> 835     public synchronized boolean getNeedClientAuth() {</span>
<span class="line-modified"> 836         return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-modified"> 837                         ClientAuthType.CLIENT_AUTH_REQUIRED);</span>





 838     }
 839 
 840     @Override
<a name="43" id="anc43"></a><span class="line-modified"> 841     public synchronized void setWantClientAuth(boolean want) {</span>
<span class="line-modified"> 842         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified"> 843                 (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-modified"> 844                         ClientAuthType.CLIENT_AUTH_NONE);</span>





 845     }
 846 
 847     @Override
<a name="44" id="anc44"></a><span class="line-modified"> 848     public synchronized boolean getWantClientAuth() {</span>
<span class="line-modified"> 849         return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-modified"> 850                         ClientAuthType.CLIENT_AUTH_REQUESTED);</span>





 851     }
 852 
 853     @Override
<a name="45" id="anc45"></a><span class="line-modified"> 854     public synchronized void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified"> 855         conContext.sslConfig.enableSessionCreation = flag;</span>





 856     }
 857 
 858     @Override
<a name="46" id="anc46"></a><span class="line-modified"> 859     public synchronized boolean getEnableSessionCreation() {</span>
<span class="line-modified"> 860         return conContext.sslConfig.enableSessionCreation;</span>





 861     }
 862 
 863     @Override
<a name="47" id="anc47"></a><span class="line-modified"> 864     public synchronized SSLParameters getSSLParameters() {</span>
<span class="line-modified"> 865         return conContext.sslConfig.getSSLParameters();</span>
<span class="line-modified"> 866     }</span>





 867 
 868     @Override
<a name="48" id="anc48"></a><span class="line-modified"> 869     public synchronized void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified"> 870         conContext.sslConfig.setSSLParameters(params);</span>


 871 
<a name="49" id="anc49"></a><span class="line-modified"> 872         if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified"> 873             conContext.outputRecord.changePacketSize(</span>
<span class="line-modified"> 874                     conContext.sslConfig.maximumPacketSize);</span>



 875         }
<a name="50" id="anc50"></a><span class="line-modified"> 876     }</span>
 877 
 878     @Override
<a name="51" id="anc51"></a><span class="line-modified"> 879     public synchronized String getApplicationProtocol() {</span>
<span class="line-modified"> 880         return conContext.applicationProtocol;</span>





 881     }
 882 
 883     @Override
<a name="52" id="anc52"></a><span class="line-modified"> 884     public synchronized String getHandshakeApplicationProtocol() {</span>
<span class="line-modified"> 885         return conContext.handshakeContext == null ?</span>
<span class="line-modified"> 886                 null : conContext.handshakeContext.applicationProtocol;</span>





 887     }
 888 
 889     @Override
<a name="53" id="anc53"></a><span class="line-modified"> 890     public synchronized void setHandshakeApplicationProtocolSelector(</span>
 891             BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
<a name="54" id="anc54"></a><span class="line-modified"> 892         conContext.sslConfig.engineAPSelector = selector;</span>





 893     }
 894 
 895     @Override
<a name="55" id="anc55"></a><span class="line-modified"> 896     public synchronized BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;</span>
 897             getHandshakeApplicationProtocolSelector() {
<a name="56" id="anc56"></a><span class="line-modified"> 898         return conContext.sslConfig.engineAPSelector;</span>





 899     }
 900 
 901     @Override
 902     public boolean useDelegatedTask() {
 903         return true;
 904     }
 905 
 906     /*
 907      * Depending on whether the error was just a warning and the
 908      * handshaker wasn&#39;t closed, or fatal and the handshaker is now
 909      * null, report back the Exception that happened in the delegated
 910      * task(s).
 911      */
<a name="57" id="anc57"></a><span class="line-modified"> 912     private synchronized void checkTaskThrown() throws SSLException {</span>
 913 
 914         Exception exc = null;
<a name="58" id="anc58"></a>







 915 
<a name="59" id="anc59"></a><span class="line-modified"> 916         // First check the handshake context.</span>
<span class="line-modified"> 917         HandshakeContext hc = conContext.handshakeContext;</span>
<span class="line-modified"> 918         if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {</span>
<span class="line-modified"> 919             exc = hc.delegatedThrown;</span>
<span class="line-modified"> 920             hc.delegatedThrown = null;</span>
<span class="line-modified"> 921         }</span>
<span class="line-modified"> 922 </span>
<span class="line-modified"> 923         /*</span>
<span class="line-modified"> 924          * hc.delegatedThrown and conContext.delegatedThrown are most likely</span>
<span class="line-modified"> 925          * the same, but it&#39;s possible we could have had a non-fatal</span>
<span class="line-modified"> 926          * exception and thus the new HandshakeContext is still valid</span>
<span class="line-modified"> 927          * (alert warning).  If so, then we may have a secondary exception</span>
<span class="line-modified"> 928          * waiting to be reported from the TransportContext, so we will</span>
<span class="line-modified"> 929          * need to clear that on a successive call.  Otherwise, clear it now.</span>
<span class="line-modified"> 930          */</span>
<span class="line-modified"> 931         if (conContext.delegatedThrown != null) {</span>
<span class="line-modified"> 932             if (exc != null) {</span>
<span class="line-modified"> 933                 // hc object comparison</span>
<span class="line-modified"> 934                 if (conContext.delegatedThrown == exc) {</span>
<span class="line-removed"> 935                     // clear if/only if both are the same</span>
 936                     conContext.delegatedThrown = null;
<a name="60" id="anc60"></a><span class="line-modified"> 937                 } // otherwise report the hc delegatedThrown</span>
<span class="line-removed"> 938             } else {</span>
<span class="line-removed"> 939                 // Nothing waiting in HandshakeContext, but one is in the</span>
<span class="line-removed"> 940                 // TransportContext.</span>
<span class="line-removed"> 941                 exc = conContext.delegatedThrown;</span>
<span class="line-removed"> 942                 conContext.delegatedThrown = null;</span>
 943             }
<a name="61" id="anc61"></a>

 944         }
 945 
 946         // Anything to report?
 947         if (exc == null) {
 948             return;
 949         }
 950 
 951         // If it wasn&#39;t a RuntimeException/SSLException, need to wrap it.
 952         if (exc instanceof SSLException) {
 953             throw (SSLException)exc;
 954         } else if (exc instanceof RuntimeException) {
 955             throw (RuntimeException)exc;
 956         } else {
 957             throw getTaskThrown(exc);
 958         }
 959     }
 960 
 961     private static SSLException getTaskThrown(Exception taskThrown) {
 962         String msg = taskThrown.getMessage();
 963 
 964         if (msg == null) {
 965             msg = &quot;Delegated task threw Exception or Error&quot;;
 966         }
 967 
 968         if (taskThrown instanceof RuntimeException) {
 969             throw new RuntimeException(msg, taskThrown);
 970         } else if (taskThrown instanceof SSLHandshakeException) {
 971             return (SSLHandshakeException)
 972                 new SSLHandshakeException(msg).initCause(taskThrown);
 973         } else if (taskThrown instanceof SSLKeyException) {
 974             return (SSLKeyException)
 975                 new SSLKeyException(msg).initCause(taskThrown);
 976         } else if (taskThrown instanceof SSLPeerUnverifiedException) {
 977             return (SSLPeerUnverifiedException)
 978                 new SSLPeerUnverifiedException(msg).initCause(taskThrown);
 979         } else if (taskThrown instanceof SSLProtocolException) {
 980             return (SSLProtocolException)
 981                 new SSLProtocolException(msg).initCause(taskThrown);
 982         } else if (taskThrown instanceof SSLException) {
 983             return (SSLException)taskThrown;
 984         } else {
 985             return new SSLException(msg, taskThrown);
 986         }
 987     }
 988 
 989     /**
 990      * Implement a simple task delegator.
 991      */
 992     private static class DelegatedTask implements Runnable {
 993         private final SSLEngineImpl engine;
 994 
 995         DelegatedTask(SSLEngineImpl engineInstance) {
 996             this.engine = engineInstance;
 997         }
 998 
 999         @Override
1000         public void run() {
<a name="62" id="anc62"></a><span class="line-modified">1001             synchronized (engine) {</span>

1002                 HandshakeContext hc = engine.conContext.handshakeContext;
1003                 if (hc == null || hc.delegatedActions.isEmpty()) {
1004                     return;
1005                 }
1006 
1007                 try {
1008                     AccessController.doPrivileged(
1009                             new DelegatedAction(hc), engine.conContext.acc);
1010                 } catch (PrivilegedActionException pae) {
1011                     // Get the handshake context again in case the
1012                     // handshaking has completed.
1013                     Exception reportedException = pae.getException();
1014 
1015                     // Report to both the TransportContext...
1016                     if (engine.conContext.delegatedThrown == null) {
1017                         engine.conContext.delegatedThrown = reportedException;
1018                     }
1019 
1020                     // ...and the HandshakeContext in case condition
1021                     // wasn&#39;t fatal and the handshakeContext is still
1022                     // around.
1023                     hc = engine.conContext.handshakeContext;
1024                     if (hc != null) {
1025                         hc.delegatedThrown = reportedException;
1026                     } else if (engine.conContext.closeReason != null) {
1027                         // Update the reason in case there was a previous.
1028                         engine.conContext.closeReason =
1029                                 getTaskThrown(reportedException);
1030                     }
1031                 } catch (RuntimeException rte) {
1032                     // Get the handshake context again in case the
1033                     // handshaking has completed.
1034 
1035                     // Report to both the TransportContext...
1036                     if (engine.conContext.delegatedThrown == null) {
1037                         engine.conContext.delegatedThrown = rte;
1038                     }
1039 
1040                     // ...and the HandshakeContext in case condition
1041                     // wasn&#39;t fatal and the handshakeContext is still
1042                     // around.
1043                     hc = engine.conContext.handshakeContext;
1044                     if (hc != null) {
1045                         hc.delegatedThrown = rte;
1046                     } else if (engine.conContext.closeReason != null) {
1047                         // Update the reason in case there was a previous.
1048                         engine.conContext.closeReason = rte;
1049                     }
1050                 }
1051 
1052                 // Get the handshake context again in case the
1053                 // handshaking has completed.
1054                 hc = engine.conContext.handshakeContext;
1055                 if (hc != null) {
1056                     hc.taskDelegated = false;
1057                 }
<a name="63" id="anc63"></a>

1058             }
1059         }
1060 
1061         private static class DelegatedAction
1062                 implements PrivilegedExceptionAction&lt;Void&gt; {
1063             final HandshakeContext context;
1064             DelegatedAction(HandshakeContext context) {
1065                 this.context = context;
1066             }
1067 
1068             @Override
1069             public Void run() throws Exception {
1070                 while (!context.delegatedActions.isEmpty()) {
1071                     Map.Entry&lt;Byte, ByteBuffer&gt; me =
1072                             context.delegatedActions.poll();
1073                     if (me != null) {
1074                         context.dispatch(me.getKey(), me.getValue());
1075                     }
1076                 }
1077                 return null;
1078             }
1079         }
1080     }
1081 }
<a name="64" id="anc64"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="64" type="hidden" />
</body>
</html>
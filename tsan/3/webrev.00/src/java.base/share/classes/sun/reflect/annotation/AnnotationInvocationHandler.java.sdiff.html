<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnnotatedTypeFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="AnnotationTypeMismatchExceptionProxy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 24  */
 25 
 26 package sun.reflect.annotation;
 27 
 28 import java.io.ObjectInputStream;
 29 import java.lang.annotation.*;
 30 import java.lang.reflect.*;
 31 import java.io.Serializable;
 32 import java.util.*;
 33 import java.util.stream.*;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 
 37 /**
 38  * InvocationHandler for dynamic proxy implementation of Annotation.
 39  *
 40  * @author  Josh Bloch
 41  * @since   1.5
 42  */
 43 class AnnotationInvocationHandler implements InvocationHandler, Serializable {

 44     private static final long serialVersionUID = 6182022883658399397L;
 45     private final Class&lt;? extends Annotation&gt; type;

 46     private final Map&lt;String, Object&gt; memberValues;
 47 
 48     AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) {
 49         Class&lt;?&gt;[] superInterfaces = type.getInterfaces();
 50         if (!type.isAnnotation() ||
 51             superInterfaces.length != 1 ||
 52             superInterfaces[0] != java.lang.annotation.Annotation.class)
 53             throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);
 54         this.type = type;
 55         this.memberValues = memberValues;
 56     }
 57 
 58     public Object invoke(Object proxy, Method method, Object[] args) {
 59         String member = method.getName();
 60         int parameterCount = method.getParameterCount();
 61 
 62         // Handle Object and Annotation methods
 63         if (parameterCount == 1 &amp;&amp; member == &quot;equals&quot; &amp;&amp;
 64                 method.getParameterTypes()[0] == Object.class) {
 65             return equalsImpl(proxy, args[0]);
</pre>
<hr />
<pre>
128         }
129         if (type == boolean[].class) {
130             boolean[] booleanArray = (boolean[])array;
131             return booleanArray.clone();
132         }
133 
134         Object[] objectArray = (Object[])array;
135         return objectArray.clone();
136     }
137 
138 
139     /**
140      * Implementation of dynamicProxy.toString()
141      */
142     private String toStringImpl() {
143         StringBuilder result = new StringBuilder(128);
144         result.append(&#39;@&#39;);
145         result.append(type.getName());
146         result.append(&#39;(&#39;);
147         boolean firstMember = true;
<span class="line-modified">148         for (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) {</span>


149             if (firstMember)
150                 firstMember = false;
151             else
152                 result.append(&quot;, &quot;);
153 
<span class="line-modified">154             result.append(e.getKey());</span>
<span class="line-modified">155             result.append(&#39;=&#39;);</span>




156             result.append(memberValueToString(e.getValue()));
157         }
158         result.append(&#39;)&#39;);
159         return result.toString();
160     }
161 
162     /**
163      * Translates a member value (in &quot;dynamic proxy return form&quot;) into a string.
164      */
165     private static String memberValueToString(Object value) {
166         Class&lt;?&gt; type = value.getClass();
167         if (!type.isArray()) {
168             // primitive value, string, class, enum const, or annotation
169             if (type == Class.class)
170                 return toSourceString((Class&lt;?&gt;) value);
171             else if (type == String.class)
172                 return  toSourceString((String) value);
173             if (type == Character.class)
174                 return toSourceString((char) value);
175             else if (type == Double.class)
176                 return  toSourceString((double) value);
177             else if (type == Float.class)
178                 return  toSourceString((float) value);
179             else if (type == Long.class)
180                 return  toSourceString((long) value);


181             else
182                 return value.toString();
183         } else {
184             Stream&lt;String&gt; stringStream;
185             if (type == byte[].class)
186                 stringStream = convert((byte[]) value);
187             else if (type == char[].class)
188                 stringStream = convert((char[]) value);
189             else if (type == double[].class)
190                 stringStream = DoubleStream.of((double[]) value)
191                     .mapToObj(AnnotationInvocationHandler::toSourceString);
192             else if (type == float[].class)
193                 stringStream = convert((float[]) value);
194             else if (type == int[].class)
195                 stringStream = IntStream.of((int[]) value).mapToObj(String::valueOf);
196             else if (type == long[].class) {
197                 stringStream = LongStream.of((long[]) value)
198                     .mapToObj(AnnotationInvocationHandler::toSourceString);
199             } else if (type == short[].class)
200                 stringStream = convert((short[]) value);
</pre>
<hr />
<pre>
204                 stringStream =
205                     Arrays.stream((Class&lt;?&gt;[]) value).
206                     map(AnnotationInvocationHandler::toSourceString);
207             else if (type == String[].class)
208                 stringStream =
209                     Arrays.stream((String[])value).
210                     map(AnnotationInvocationHandler::toSourceString);
211             else
212                 stringStream = Arrays.stream((Object[])value).map(Objects::toString);
213 
214             return stringStreamToString(stringStream);
215         }
216     }
217 
218     /**
219      * Translates a Class value to a form suitable for use in the
220      * string representation of an annotation.
221      */
222     private static String toSourceString(Class&lt;?&gt; clazz) {
223         Class&lt;?&gt; finalComponent = clazz;
<span class="line-modified">224         StringBuilder arrayBackets = new StringBuilder();</span>
225 
226         while(finalComponent.isArray()) {
227             finalComponent = finalComponent.getComponentType();
<span class="line-modified">228             arrayBackets.append(&quot;[]&quot;);</span>
229         }
230 
<span class="line-modified">231         return finalComponent.getName() + arrayBackets.toString() + &quot;.class&quot; ;</span>
232     }
233 
234     private static String toSourceString(float f) {
235         if (Float.isFinite(f))
236             return Float.toString(f) + &quot;f&quot; ;
237         else {
238             if (Float.isInfinite(f)) {
239                 return (f &lt; 0.0f) ? &quot;-1.0f/0.0f&quot;: &quot;1.0f/0.0f&quot;;
240             } else
241                 return &quot;0.0f/0.0f&quot;;
242         }
243     }
244 
245     private static String toSourceString(double d) {
246         if (Double.isFinite(d))
247             return Double.toString(d);
248         else {
249             if (Double.isInfinite(d)) {
250                 return (d &lt; 0.0f) ? &quot;-1.0/0.0&quot;: &quot;1.0/0.0&quot;;
251             } else
252                 return &quot;0.0/0.0&quot;;
253         }
254     }
255 
256     private static String toSourceString(char c) {
257         StringBuilder sb = new StringBuilder(4);
258         sb.append(&#39;\&#39;&#39;);
<span class="line-modified">259         if (c == &#39;\&#39;&#39;)</span>
<span class="line-modified">260             sb.append(&quot;\\&#39;&quot;);</span>
<span class="line-modified">261         else</span>
<span class="line-modified">262             sb.append(c);</span>
<span class="line-modified">263         return sb.append(&#39;\&#39;&#39;)</span>
<span class="line-modified">264                 .toString();</span>




























265     }
266 
267     private static String toSourceString(long ell) {
<span class="line-modified">268         String str = String.valueOf(ell);</span>
<span class="line-removed">269         return (ell &lt; Integer.MIN_VALUE || ell &gt; Integer.MAX_VALUE)</span>
<span class="line-removed">270                 ? (str + &#39;L&#39;) : str;</span>
271     }
272 
273     /**
274      * Return a string suitable for use in the string representation
275      * of an annotation.
276      */
277     private static String toSourceString(String s) {
278         StringBuilder sb = new StringBuilder();
279         sb.append(&#39;&quot;&#39;);
<span class="line-modified">280         // Escape embedded quote characters, if present, but don&#39;t do</span>
<span class="line-modified">281         // anything more heroic.</span>
<span class="line-modified">282         sb.append(s.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;));</span>
283         sb.append(&#39;&quot;&#39;);
284         return sb.toString();
285     }
286 
287     private static Stream&lt;String&gt; convert(byte[] values) {
288         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
289         for (byte b : values)
<span class="line-modified">290             list.add(Byte.toString(b));</span>
291         return list.stream();
292     }
293 
294     private static Stream&lt;String&gt; convert(char[] values) {
295         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
296         for (char c : values)
297             list.add(toSourceString(c));
298         return list.stream();
299     }
300 
301     private static Stream&lt;String&gt; convert(float[] values) {
302         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
303         for (float f : values) {
304             list.add(toSourceString(f));
305         }
306         return list.stream();
307     }
308 
309     private static Stream&lt;String&gt; convert(short[] values) {
310         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
</pre>
<hr />
<pre>
552 
553         if (type == byte[].class)
554             return Arrays.hashCode((byte[]) value);
555         if (type == char[].class)
556             return Arrays.hashCode((char[]) value);
557         if (type == double[].class)
558             return Arrays.hashCode((double[]) value);
559         if (type == float[].class)
560             return Arrays.hashCode((float[]) value);
561         if (type == int[].class)
562             return Arrays.hashCode((int[]) value);
563         if (type == long[].class)
564             return Arrays.hashCode((long[]) value);
565         if (type == short[].class)
566             return Arrays.hashCode((short[]) value);
567         if (type == boolean[].class)
568             return Arrays.hashCode((boolean[]) value);
569         return Arrays.hashCode((Object[]) value);
570     }
571 

572     private void readObject(java.io.ObjectInputStream s)
573         throws java.io.IOException, ClassNotFoundException {
574         ObjectInputStream.GetField fields = s.readFields();
575 
576         @SuppressWarnings(&quot;unchecked&quot;)
577         Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);
578         @SuppressWarnings(&quot;unchecked&quot;)
579         Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);
580 
581         // Check to make sure that types have not evolved incompatibly
582 
583         AnnotationType annotationType = null;
584         try {
585             annotationType = AnnotationType.getInstance(t);
586         } catch(IllegalArgumentException e) {
587             // Class is no longer an annotation type; time to punch out
588             throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);
589         }
590 
591         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 24  */
 25 
 26 package sun.reflect.annotation;
 27 
 28 import java.io.ObjectInputStream;
 29 import java.lang.annotation.*;
 30 import java.lang.reflect.*;
 31 import java.io.Serializable;
 32 import java.util.*;
 33 import java.util.stream.*;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 
 37 /**
 38  * InvocationHandler for dynamic proxy implementation of Annotation.
 39  *
 40  * @author  Josh Bloch
 41  * @since   1.5
 42  */
 43 class AnnotationInvocationHandler implements InvocationHandler, Serializable {
<span class="line-added"> 44     @java.io.Serial</span>
 45     private static final long serialVersionUID = 6182022883658399397L;
 46     private final Class&lt;? extends Annotation&gt; type;
<span class="line-added"> 47     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 48     private final Map&lt;String, Object&gt; memberValues;
 49 
 50     AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) {
 51         Class&lt;?&gt;[] superInterfaces = type.getInterfaces();
 52         if (!type.isAnnotation() ||
 53             superInterfaces.length != 1 ||
 54             superInterfaces[0] != java.lang.annotation.Annotation.class)
 55             throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);
 56         this.type = type;
 57         this.memberValues = memberValues;
 58     }
 59 
 60     public Object invoke(Object proxy, Method method, Object[] args) {
 61         String member = method.getName();
 62         int parameterCount = method.getParameterCount();
 63 
 64         // Handle Object and Annotation methods
 65         if (parameterCount == 1 &amp;&amp; member == &quot;equals&quot; &amp;&amp;
 66                 method.getParameterTypes()[0] == Object.class) {
 67             return equalsImpl(proxy, args[0]);
</pre>
<hr />
<pre>
130         }
131         if (type == boolean[].class) {
132             boolean[] booleanArray = (boolean[])array;
133             return booleanArray.clone();
134         }
135 
136         Object[] objectArray = (Object[])array;
137         return objectArray.clone();
138     }
139 
140 
141     /**
142      * Implementation of dynamicProxy.toString()
143      */
144     private String toStringImpl() {
145         StringBuilder result = new StringBuilder(128);
146         result.append(&#39;@&#39;);
147         result.append(type.getName());
148         result.append(&#39;(&#39;);
149         boolean firstMember = true;
<span class="line-modified">150         Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = memberValues.entrySet();</span>
<span class="line-added">151         boolean loneValue = entries.size() == 1;</span>
<span class="line-added">152         for (Map.Entry&lt;String, Object&gt; e : entries) {</span>
153             if (firstMember)
154                 firstMember = false;
155             else
156                 result.append(&quot;, &quot;);
157 
<span class="line-modified">158             String key = e.getKey();</span>
<span class="line-modified">159             if (!loneValue || !&quot;value&quot;.equals(key)) {</span>
<span class="line-added">160                 result.append(key);</span>
<span class="line-added">161                 result.append(&#39;=&#39;);</span>
<span class="line-added">162             }</span>
<span class="line-added">163             loneValue = false;</span>
164             result.append(memberValueToString(e.getValue()));
165         }
166         result.append(&#39;)&#39;);
167         return result.toString();
168     }
169 
170     /**
171      * Translates a member value (in &quot;dynamic proxy return form&quot;) into a string.
172      */
173     private static String memberValueToString(Object value) {
174         Class&lt;?&gt; type = value.getClass();
175         if (!type.isArray()) {
176             // primitive value, string, class, enum const, or annotation
177             if (type == Class.class)
178                 return toSourceString((Class&lt;?&gt;) value);
179             else if (type == String.class)
180                 return  toSourceString((String) value);
181             if (type == Character.class)
182                 return toSourceString((char) value);
183             else if (type == Double.class)
184                 return  toSourceString((double) value);
185             else if (type == Float.class)
186                 return  toSourceString((float) value);
187             else if (type == Long.class)
188                 return  toSourceString((long) value);
<span class="line-added">189             else if (type == Byte.class)</span>
<span class="line-added">190                 return  toSourceString((byte) value);</span>
191             else
192                 return value.toString();
193         } else {
194             Stream&lt;String&gt; stringStream;
195             if (type == byte[].class)
196                 stringStream = convert((byte[]) value);
197             else if (type == char[].class)
198                 stringStream = convert((char[]) value);
199             else if (type == double[].class)
200                 stringStream = DoubleStream.of((double[]) value)
201                     .mapToObj(AnnotationInvocationHandler::toSourceString);
202             else if (type == float[].class)
203                 stringStream = convert((float[]) value);
204             else if (type == int[].class)
205                 stringStream = IntStream.of((int[]) value).mapToObj(String::valueOf);
206             else if (type == long[].class) {
207                 stringStream = LongStream.of((long[]) value)
208                     .mapToObj(AnnotationInvocationHandler::toSourceString);
209             } else if (type == short[].class)
210                 stringStream = convert((short[]) value);
</pre>
<hr />
<pre>
214                 stringStream =
215                     Arrays.stream((Class&lt;?&gt;[]) value).
216                     map(AnnotationInvocationHandler::toSourceString);
217             else if (type == String[].class)
218                 stringStream =
219                     Arrays.stream((String[])value).
220                     map(AnnotationInvocationHandler::toSourceString);
221             else
222                 stringStream = Arrays.stream((Object[])value).map(Objects::toString);
223 
224             return stringStreamToString(stringStream);
225         }
226     }
227 
228     /**
229      * Translates a Class value to a form suitable for use in the
230      * string representation of an annotation.
231      */
232     private static String toSourceString(Class&lt;?&gt; clazz) {
233         Class&lt;?&gt; finalComponent = clazz;
<span class="line-modified">234         StringBuilder arrayBrackets = new StringBuilder();</span>
235 
236         while(finalComponent.isArray()) {
237             finalComponent = finalComponent.getComponentType();
<span class="line-modified">238             arrayBrackets.append(&quot;[]&quot;);</span>
239         }
240 
<span class="line-modified">241         return finalComponent.getName() + arrayBrackets.toString() + &quot;.class&quot;;</span>
242     }
243 
244     private static String toSourceString(float f) {
245         if (Float.isFinite(f))
246             return Float.toString(f) + &quot;f&quot; ;
247         else {
248             if (Float.isInfinite(f)) {
249                 return (f &lt; 0.0f) ? &quot;-1.0f/0.0f&quot;: &quot;1.0f/0.0f&quot;;
250             } else
251                 return &quot;0.0f/0.0f&quot;;
252         }
253     }
254 
255     private static String toSourceString(double d) {
256         if (Double.isFinite(d))
257             return Double.toString(d);
258         else {
259             if (Double.isInfinite(d)) {
260                 return (d &lt; 0.0f) ? &quot;-1.0/0.0&quot;: &quot;1.0/0.0&quot;;
261             } else
262                 return &quot;0.0/0.0&quot;;
263         }
264     }
265 
266     private static String toSourceString(char c) {
267         StringBuilder sb = new StringBuilder(4);
268         sb.append(&#39;\&#39;&#39;);
<span class="line-modified">269         sb.append(quote(c));</span>
<span class="line-modified">270         return sb.append(&#39;\&#39;&#39;) .toString();</span>
<span class="line-modified">271     }</span>
<span class="line-modified">272 </span>
<span class="line-modified">273     /**</span>
<span class="line-modified">274      * Escapes a character if it has an escape sequence or is</span>
<span class="line-added">275      * non-printable ASCII.  Leaves non-ASCII characters alone.</span>
<span class="line-added">276      */</span>
<span class="line-added">277     private static String quote(char ch) {</span>
<span class="line-added">278         switch (ch) {</span>
<span class="line-added">279         case &#39;\b&#39;:  return &quot;\\b&quot;;</span>
<span class="line-added">280         case &#39;\f&#39;:  return &quot;\\f&quot;;</span>
<span class="line-added">281         case &#39;\n&#39;:  return &quot;\\n&quot;;</span>
<span class="line-added">282         case &#39;\r&#39;:  return &quot;\\r&quot;;</span>
<span class="line-added">283         case &#39;\t&#39;:  return &quot;\\t&quot;;</span>
<span class="line-added">284         case &#39;\&#39;&#39;:  return &quot;\\&#39;&quot;;</span>
<span class="line-added">285         case &#39;\&quot;&#39;:  return &quot;\\\&quot;&quot;;</span>
<span class="line-added">286         case &#39;\\&#39;:  return &quot;\\\\&quot;;</span>
<span class="line-added">287         default:</span>
<span class="line-added">288             return (isPrintableAscii(ch))</span>
<span class="line-added">289                 ? String.valueOf(ch)</span>
<span class="line-added">290                 : String.format(&quot;\\u%04x&quot;, (int) ch);</span>
<span class="line-added">291         }</span>
<span class="line-added">292     }</span>
<span class="line-added">293 </span>
<span class="line-added">294     /**</span>
<span class="line-added">295      * Is a character printable ASCII?</span>
<span class="line-added">296      */</span>
<span class="line-added">297     private static boolean isPrintableAscii(char ch) {</span>
<span class="line-added">298         return ch &gt;= &#39; &#39; &amp;&amp; ch &lt;= &#39;~&#39;;</span>
<span class="line-added">299     }</span>
<span class="line-added">300 </span>
<span class="line-added">301     private static String toSourceString(byte b) {</span>
<span class="line-added">302         return String.format(&quot;(byte)0x%02x&quot;, b);</span>
303     }
304 
305     private static String toSourceString(long ell) {
<span class="line-modified">306         return String.valueOf(ell) + &quot;L&quot;;</span>


307     }
308 
309     /**
310      * Return a string suitable for use in the string representation
311      * of an annotation.
312      */
313     private static String toSourceString(String s) {
314         StringBuilder sb = new StringBuilder();
315         sb.append(&#39;&quot;&#39;);
<span class="line-modified">316         for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="line-modified">317             sb.append(quote(s.charAt(i)));</span>
<span class="line-modified">318         }</span>
319         sb.append(&#39;&quot;&#39;);
320         return sb.toString();
321     }
322 
323     private static Stream&lt;String&gt; convert(byte[] values) {
324         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
325         for (byte b : values)
<span class="line-modified">326             list.add(toSourceString(b));</span>
327         return list.stream();
328     }
329 
330     private static Stream&lt;String&gt; convert(char[] values) {
331         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
332         for (char c : values)
333             list.add(toSourceString(c));
334         return list.stream();
335     }
336 
337     private static Stream&lt;String&gt; convert(float[] values) {
338         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
339         for (float f : values) {
340             list.add(toSourceString(f));
341         }
342         return list.stream();
343     }
344 
345     private static Stream&lt;String&gt; convert(short[] values) {
346         List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
</pre>
<hr />
<pre>
588 
589         if (type == byte[].class)
590             return Arrays.hashCode((byte[]) value);
591         if (type == char[].class)
592             return Arrays.hashCode((char[]) value);
593         if (type == double[].class)
594             return Arrays.hashCode((double[]) value);
595         if (type == float[].class)
596             return Arrays.hashCode((float[]) value);
597         if (type == int[].class)
598             return Arrays.hashCode((int[]) value);
599         if (type == long[].class)
600             return Arrays.hashCode((long[]) value);
601         if (type == short[].class)
602             return Arrays.hashCode((short[]) value);
603         if (type == boolean[].class)
604             return Arrays.hashCode((boolean[]) value);
605         return Arrays.hashCode((Object[]) value);
606     }
607 
<span class="line-added">608     @java.io.Serial</span>
609     private void readObject(java.io.ObjectInputStream s)
610         throws java.io.IOException, ClassNotFoundException {
611         ObjectInputStream.GetField fields = s.readFields();
612 
613         @SuppressWarnings(&quot;unchecked&quot;)
614         Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);
615         @SuppressWarnings(&quot;unchecked&quot;)
616         Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);
617 
618         // Check to make sure that types have not evolved incompatibly
619 
620         AnnotationType annotationType = null;
621         try {
622             annotationType = AnnotationType.getInstance(t);
623         } catch(IllegalArgumentException e) {
624             // Class is no longer an annotation type; time to punch out
625             throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);
626         }
627 
628         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();
</pre>
</td>
</tr>
</table>
<center><a href="AnnotatedTypeFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="AnnotationTypeMismatchExceptionProxy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
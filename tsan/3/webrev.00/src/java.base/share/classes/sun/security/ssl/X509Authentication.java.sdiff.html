<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/X509Authentication.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Utilities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509KeyManagerImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/X509Authentication.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.PrivateKey;
 29 import java.security.PublicKey;
 30 import java.security.cert.X509Certificate;

 31 import java.security.interfaces.ECPublicKey;


 32 import java.security.spec.ECParameterSpec;

 33 import java.util.AbstractMap.SimpleImmutableEntry;
 34 import java.util.Map;
 35 import javax.net.ssl.SSLEngine;
 36 import javax.net.ssl.SSLSocket;
 37 import javax.net.ssl.X509ExtendedKeyManager;
<span class="line-removed"> 38 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
 39 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 40 
 41 enum X509Authentication implements SSLAuthentication {
 42     // Require rsaEncryption public key
 43     RSA         (&quot;RSA&quot;,         new X509PossessionGenerator(
 44                                     new String[]{&quot;RSA&quot;})),
 45 
 46     // Require RSASSA-PSS public key
 47     RSASSA_PSS  (&quot;RSASSA-PSS&quot;,  new X509PossessionGenerator(
 48                                     new String[] {&quot;RSASSA-PSS&quot;})),
 49 
 50     // Require rsaEncryption or RSASSA-PSS public key
 51     //
 52     // Note that this is a specifical scheme for TLS 1.2. (EC)DHE_RSA cipher
 53     // suites of TLS 1.2 can use either rsaEncryption or RSASSA-PSS public
 54     // key for authentication and handshake.
 55     RSA_OR_PSS  (&quot;RSA_OR_PSS&quot;,  new X509PossessionGenerator(
 56                                     new String[] {&quot;RSA&quot;, &quot;RSASSA-PSS&quot;})),
 57 
 58     // Require DSA public key
 59     DSA         (&quot;DSA&quot;,         new X509PossessionGenerator(
 60                                     new String[] {&quot;DSA&quot;})),
 61 
 62     // Require EC public key
 63     EC          (&quot;EC&quot;,          new X509PossessionGenerator(
 64                                     new String[] {&quot;EC&quot;}));
 65 
 66     final String keyType;
 67     final SSLPossessionGenerator possessionGenerator;
 68 
<span class="line-modified"> 69     X509Authentication(String keyType,</span>
 70             SSLPossessionGenerator possessionGenerator) {
 71         this.keyType = keyType;
 72         this.possessionGenerator = possessionGenerator;
 73     }
 74 
 75     static X509Authentication valueOf(SignatureScheme signatureScheme) {
 76         for (X509Authentication au : X509Authentication.values()) {
 77             if (au.keyType.equals(signatureScheme.keyAlgorithm)) {
 78                 return au;
 79             }
 80         }
 81 
 82         return null;
 83     }
 84 
 85     @Override
 86     public SSLPossession createPossession(HandshakeContext handshakeContext) {
 87         return possessionGenerator.createPossession(handshakeContext);
 88     }
 89 
</pre>
<hr />
<pre>
110                         SSLHandshake.CERTIFICATE.id,
111                         SSLHandshake.CERTIFICATE
112                     )
113                 });
114         }   // Otherwise, TLS 1.3 does not use this method.
115 
116         return (Map.Entry&lt;Byte, HandshakeProducer&gt;[])(new Map.Entry[0]);
117     }
118 
119     static final class X509Possession implements SSLPossession {
120         // Proof of possession of the private key corresponding to the public
121         // key for which a certificate is being provided for authentication.
122         final X509Certificate[]   popCerts;
123         final PrivateKey          popPrivateKey;
124 
125         X509Possession(PrivateKey popPrivateKey,
126                 X509Certificate[] popCerts) {
127             this.popCerts = popCerts;
128             this.popPrivateKey = popPrivateKey;
129         }

















































130     }
131 
132     static final class X509Credentials implements SSLCredentials {
133         final X509Certificate[]   popCerts;
134         final PublicKey           popPublicKey;
135 
136         X509Credentials(PublicKey popPublicKey, X509Certificate[] popCerts) {
137             this.popCerts = popCerts;
138             this.popPublicKey = popPublicKey;
139         }
140     }
141 
142     private static final
143             class X509PossessionGenerator implements SSLPossessionGenerator {
144         private final String[] keyTypes;
145 
146         private X509PossessionGenerator(String[] keyTypes) {
147             this.keyTypes = keyTypes;
148         }
149 
</pre>
<hr />
<pre>
257             X509Certificate[] serverCerts = km.getCertificateChain(serverAlias);
258             if ((serverCerts == null) || (serverCerts.length == 0)) {
259                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
260                     SSLLogger.finest(
261                             serverAlias + &quot; is not a certificate entry&quot;);
262                 }
263                 return null;
264             }
265 
266             PublicKey serverPublicKey = serverCerts[0].getPublicKey();
267             if ((!serverPrivateKey.getAlgorithm().equals(keyType))
268                     || (!serverPublicKey.getAlgorithm().equals(keyType))) {
269                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
270                     SSLLogger.fine(
271                             serverAlias + &quot; private or public key is not of &quot; +
272                             keyType + &quot; algorithm&quot;);
273                 }
274                 return null;
275             }
276 
<span class="line-modified">277             // For ECC certs, check whether we support the EC domain</span>
<span class="line-modified">278             // parameters.  If the client sent a SupportedEllipticCurves</span>
<span class="line-modified">279             // ClientHello extension, check against that too.</span>
<span class="line-modified">280             if (keyType.equals(&quot;EC&quot;)) {</span>


281                 if (!(serverPublicKey instanceof ECPublicKey)) {
282                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
283                         SSLLogger.warning(serverAlias +
284                             &quot; public key is not an instance of ECPublicKey&quot;);
285                     }
286                     return null;
287                 }
288 
289                 // For ECC certs, check whether we support the EC domain
<span class="line-modified">290                 // parameters. If the client sent a SupportedEllipticCurves</span>
<span class="line-modified">291                 // ClientHello extension, check against that too.</span>

292                 ECParameterSpec params =
293                         ((ECPublicKey)serverPublicKey).getParams();
294                 NamedGroup namedGroup = NamedGroup.valueOf(params);
295                 if ((namedGroup == null) ||
296                         (!SupportedGroups.isSupported(namedGroup)) ||
297                         ((shc.clientRequestedNamedGroups != null) &amp;&amp;
298                         !shc.clientRequestedNamedGroups.contains(namedGroup))) {
299 
300                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
301                         SSLLogger.warning(
302                             &quot;Unsupported named group (&quot; + namedGroup +
303                             &quot;) used in the &quot; + serverAlias + &quot; certificate&quot;);
304                     }
305 
306                     return null;
307                 }
308             }
309 
310             return new X509Possession(serverPrivateKey, serverCerts);
311         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.PrivateKey;
 29 import java.security.PublicKey;
 30 import java.security.cert.X509Certificate;
<span class="line-added"> 31 import java.security.interfaces.ECKey;</span>
 32 import java.security.interfaces.ECPublicKey;
<span class="line-added"> 33 import java.security.interfaces.XECKey;</span>
<span class="line-added"> 34 import java.security.spec.AlgorithmParameterSpec;</span>
 35 import java.security.spec.ECParameterSpec;
<span class="line-added"> 36 import java.security.spec.NamedParameterSpec;</span>
 37 import java.util.AbstractMap.SimpleImmutableEntry;
 38 import java.util.Map;
 39 import javax.net.ssl.SSLEngine;
 40 import javax.net.ssl.SSLSocket;
 41 import javax.net.ssl.X509ExtendedKeyManager;

 42 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 43 
 44 enum X509Authentication implements SSLAuthentication {
 45     // Require rsaEncryption public key
 46     RSA         (&quot;RSA&quot;,         new X509PossessionGenerator(
 47                                     new String[]{&quot;RSA&quot;})),
 48 
 49     // Require RSASSA-PSS public key
 50     RSASSA_PSS  (&quot;RSASSA-PSS&quot;,  new X509PossessionGenerator(
 51                                     new String[] {&quot;RSASSA-PSS&quot;})),
 52 
 53     // Require rsaEncryption or RSASSA-PSS public key
 54     //
 55     // Note that this is a specifical scheme for TLS 1.2. (EC)DHE_RSA cipher
 56     // suites of TLS 1.2 can use either rsaEncryption or RSASSA-PSS public
 57     // key for authentication and handshake.
 58     RSA_OR_PSS  (&quot;RSA_OR_PSS&quot;,  new X509PossessionGenerator(
 59                                     new String[] {&quot;RSA&quot;, &quot;RSASSA-PSS&quot;})),
 60 
 61     // Require DSA public key
 62     DSA         (&quot;DSA&quot;,         new X509PossessionGenerator(
 63                                     new String[] {&quot;DSA&quot;})),
 64 
 65     // Require EC public key
 66     EC          (&quot;EC&quot;,          new X509PossessionGenerator(
 67                                     new String[] {&quot;EC&quot;}));
 68 
 69     final String keyType;
 70     final SSLPossessionGenerator possessionGenerator;
 71 
<span class="line-modified"> 72     private X509Authentication(String keyType,</span>
 73             SSLPossessionGenerator possessionGenerator) {
 74         this.keyType = keyType;
 75         this.possessionGenerator = possessionGenerator;
 76     }
 77 
 78     static X509Authentication valueOf(SignatureScheme signatureScheme) {
 79         for (X509Authentication au : X509Authentication.values()) {
 80             if (au.keyType.equals(signatureScheme.keyAlgorithm)) {
 81                 return au;
 82             }
 83         }
 84 
 85         return null;
 86     }
 87 
 88     @Override
 89     public SSLPossession createPossession(HandshakeContext handshakeContext) {
 90         return possessionGenerator.createPossession(handshakeContext);
 91     }
 92 
</pre>
<hr />
<pre>
113                         SSLHandshake.CERTIFICATE.id,
114                         SSLHandshake.CERTIFICATE
115                     )
116                 });
117         }   // Otherwise, TLS 1.3 does not use this method.
118 
119         return (Map.Entry&lt;Byte, HandshakeProducer&gt;[])(new Map.Entry[0]);
120     }
121 
122     static final class X509Possession implements SSLPossession {
123         // Proof of possession of the private key corresponding to the public
124         // key for which a certificate is being provided for authentication.
125         final X509Certificate[]   popCerts;
126         final PrivateKey          popPrivateKey;
127 
128         X509Possession(PrivateKey popPrivateKey,
129                 X509Certificate[] popCerts) {
130             this.popCerts = popCerts;
131             this.popPrivateKey = popPrivateKey;
132         }
<span class="line-added">133 </span>
<span class="line-added">134         ECParameterSpec getECParameterSpec() {</span>
<span class="line-added">135             if (popPrivateKey == null ||</span>
<span class="line-added">136                     !&quot;EC&quot;.equals(popPrivateKey.getAlgorithm())) {</span>
<span class="line-added">137                 return null;</span>
<span class="line-added">138             }</span>
<span class="line-added">139 </span>
<span class="line-added">140             if (popPrivateKey instanceof ECKey) {</span>
<span class="line-added">141                 return ((ECKey)popPrivateKey).getParams();</span>
<span class="line-added">142             } else if (popCerts != null &amp;&amp; popCerts.length != 0) {</span>
<span class="line-added">143                 // The private key not extractable, get the parameters from</span>
<span class="line-added">144                 // the X.509 certificate.</span>
<span class="line-added">145                 PublicKey publicKey = popCerts[0].getPublicKey();</span>
<span class="line-added">146                 if (publicKey instanceof ECKey) {</span>
<span class="line-added">147                     return ((ECKey)publicKey).getParams();</span>
<span class="line-added">148                 }</span>
<span class="line-added">149             }</span>
<span class="line-added">150 </span>
<span class="line-added">151             return null;</span>
<span class="line-added">152         }</span>
<span class="line-added">153 </span>
<span class="line-added">154         // Similar to above, but for XEC.</span>
<span class="line-added">155         NamedParameterSpec getXECParameterSpec() {</span>
<span class="line-added">156             if (popPrivateKey == null ||</span>
<span class="line-added">157                     !&quot;XEC&quot;.equals(popPrivateKey.getAlgorithm())) {</span>
<span class="line-added">158                 return null;</span>
<span class="line-added">159             }</span>
<span class="line-added">160 </span>
<span class="line-added">161             if (popPrivateKey instanceof XECKey) {</span>
<span class="line-added">162                 AlgorithmParameterSpec params =</span>
<span class="line-added">163                         ((XECKey)popPrivateKey).getParams();</span>
<span class="line-added">164                 if (params instanceof NamedParameterSpec){</span>
<span class="line-added">165                     return (NamedParameterSpec)params;</span>
<span class="line-added">166                 }</span>
<span class="line-added">167             } else if (popCerts != null &amp;&amp; popCerts.length != 0) {</span>
<span class="line-added">168                 // The private key not extractable, get the parameters from</span>
<span class="line-added">169                 // the X.509 certificate.</span>
<span class="line-added">170                 PublicKey publicKey = popCerts[0].getPublicKey();</span>
<span class="line-added">171                 if (publicKey instanceof XECKey) {</span>
<span class="line-added">172                     AlgorithmParameterSpec params =</span>
<span class="line-added">173                             ((XECKey)publicKey).getParams();</span>
<span class="line-added">174                     if (params instanceof NamedParameterSpec){</span>
<span class="line-added">175                         return (NamedParameterSpec)params;</span>
<span class="line-added">176                     }</span>
<span class="line-added">177                 }</span>
<span class="line-added">178             }</span>
<span class="line-added">179 </span>
<span class="line-added">180             return null;</span>
<span class="line-added">181         }</span>
182     }
183 
184     static final class X509Credentials implements SSLCredentials {
185         final X509Certificate[]   popCerts;
186         final PublicKey           popPublicKey;
187 
188         X509Credentials(PublicKey popPublicKey, X509Certificate[] popCerts) {
189             this.popCerts = popCerts;
190             this.popPublicKey = popPublicKey;
191         }
192     }
193 
194     private static final
195             class X509PossessionGenerator implements SSLPossessionGenerator {
196         private final String[] keyTypes;
197 
198         private X509PossessionGenerator(String[] keyTypes) {
199             this.keyTypes = keyTypes;
200         }
201 
</pre>
<hr />
<pre>
309             X509Certificate[] serverCerts = km.getCertificateChain(serverAlias);
310             if ((serverCerts == null) || (serverCerts.length == 0)) {
311                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
312                     SSLLogger.finest(
313                             serverAlias + &quot; is not a certificate entry&quot;);
314                 }
315                 return null;
316             }
317 
318             PublicKey serverPublicKey = serverCerts[0].getPublicKey();
319             if ((!serverPrivateKey.getAlgorithm().equals(keyType))
320                     || (!serverPublicKey.getAlgorithm().equals(keyType))) {
321                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
322                     SSLLogger.fine(
323                             serverAlias + &quot; private or public key is not of &quot; +
324                             keyType + &quot; algorithm&quot;);
325                 }
326                 return null;
327             }
328 
<span class="line-modified">329             // For TLS 1.2 and prior versions, the public key of a EC cert</span>
<span class="line-modified">330             // MUST use a curve and point format supported by the client.</span>
<span class="line-modified">331             // But for TLS 1.3, signature algorithms are negotiated</span>
<span class="line-modified">332             // independently via the &quot;signature_algorithms&quot; extension.</span>
<span class="line-added">333             if (!shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">334                     keyType.equals(&quot;EC&quot;)) {</span>
335                 if (!(serverPublicKey instanceof ECPublicKey)) {
336                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
337                         SSLLogger.warning(serverAlias +
338                             &quot; public key is not an instance of ECPublicKey&quot;);
339                     }
340                     return null;
341                 }
342 
343                 // For ECC certs, check whether we support the EC domain
<span class="line-modified">344                 // parameters.  If the client sent a supported_groups</span>
<span class="line-modified">345                 // ClientHello extension, check against that too for</span>
<span class="line-added">346                 // TLS 1.2 and prior versions.</span>
347                 ECParameterSpec params =
348                         ((ECPublicKey)serverPublicKey).getParams();
349                 NamedGroup namedGroup = NamedGroup.valueOf(params);
350                 if ((namedGroup == null) ||
351                         (!SupportedGroups.isSupported(namedGroup)) ||
352                         ((shc.clientRequestedNamedGroups != null) &amp;&amp;
353                         !shc.clientRequestedNamedGroups.contains(namedGroup))) {
354 
355                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
356                         SSLLogger.warning(
357                             &quot;Unsupported named group (&quot; + namedGroup +
358                             &quot;) used in the &quot; + serverAlias + &quot; certificate&quot;);
359                     }
360 
361                     return null;
362                 }
363             }
364 
365             return new X509Possession(serverPrivateKey, serverCerts);
366         }
</pre>
</td>
</tr>
</table>
<center><a href="Utilities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509KeyManagerImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HttpURLConnection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../https/DelegateHttpsURLConnection.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www.protocol.http;
 27 
 28 import java.net.URL;
 29 import java.io.IOException;
 30 import java.net.Authenticator.RequestorType;
 31 import java.util.Base64;
 32 import java.util.HashMap;
 33 import sun.net.www.HeaderParser;
<span class="line-removed"> 34 import sun.util.logging.PlatformLogger;</span>
 35 import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
 36 import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
 37 import sun.security.action.GetPropertyAction;
 38 
 39 /**
 40  * NegotiateAuthentication:
 41  *
 42  * @author weijun.wang@sun.com
 43  * @since 1.6
 44  */
 45 
 46 class NegotiateAuthentication extends AuthenticationInfo {
 47 

 48     private static final long serialVersionUID = 100L;
<span class="line-removed"> 49     private static final PlatformLogger logger = HttpURLConnection.getHttpLogger();</span>
 50 

 51     private final HttpCallerInfo hci;
 52 
 53     // These maps are used to manage the GSS availability for diffrent
 54     // hosts. The key for both maps is the host name.
 55     // &lt;code&gt;supported&lt;/code&gt; is set when isSupported is checked,
 56     // if it&#39;s true, a cached Negotiator is put into &lt;code&gt;cache&lt;/code&gt;.
 57     // the cache can be used only once, so after the first use, it&#39;s cleaned.
 58     static HashMap &lt;String, Boolean&gt; supported = null;
 59     static ThreadLocal &lt;HashMap &lt;String, Negotiator&gt;&gt; cache = null;
 60     /* Whether cache is enabled for Negotiate/Kerberos */
 61     private static final boolean cacheSPNEGO;
 62     static {
 63         String spnegoCacheProp =
 64             GetPropertyAction.privilegedGetProperty(&quot;jdk.spnego.cache&quot;, &quot;true&quot;);
 65         cacheSPNEGO = Boolean.parseBoolean(spnegoCacheProp);
 66     }
 67 
 68     // The HTTP Negotiate Helper

 69     private Negotiator negotiator = null;
 70 
 71    /**
 72     * Constructor used for both WWW and proxy entries.
 73     * @param hci a schemed object.
 74     */
 75     public NegotiateAuthentication(HttpCallerInfo hci) {
 76         super(RequestorType.PROXY==hci.authType ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION,
 77               hci.scheme.equalsIgnoreCase(&quot;Negotiate&quot;) ? NEGOTIATE : KERBEROS,
 78               hci.url,
 79               &quot;&quot;,
 80               AuthenticatorKeys.getKey(hci.authenticator));
 81         this.hci = hci;
 82     }
 83 
 84     /**
 85      * @return true if this authentication supports preemptive authorization
 86      */
 87     @Override
 88     public boolean supportsPreemptiveAuthorization() {
 89         return false;
 90     }
 91 
<span class="line-removed"> 92     /**</span>
<span class="line-removed"> 93      * Find out if the HttpCallerInfo supports Negotiate protocol.</span>
<span class="line-removed"> 94      * @return true if supported</span>
<span class="line-removed"> 95      */</span>
<span class="line-removed"> 96     public static boolean isSupported(HttpCallerInfo hci) {</span>
<span class="line-removed"> 97         ClassLoader loader = null;</span>
<span class="line-removed"> 98         try {</span>
<span class="line-removed"> 99             loader = Thread.currentThread().getContextClassLoader();</span>
<span class="line-removed">100         } catch (SecurityException se) {</span>
<span class="line-removed">101             if (logger.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="line-removed">102                 logger.finer(&quot;NegotiateAuthentication: &quot; +</span>
<span class="line-removed">103                     &quot;Attempt to get the context class loader failed - &quot; + se);</span>
<span class="line-removed">104             }</span>
<span class="line-removed">105         }</span>
<span class="line-removed">106 </span>
<span class="line-removed">107         if (loader != null) {</span>
<span class="line-removed">108             // Lock on the class loader instance to avoid the deadlock engaging</span>
<span class="line-removed">109             // the lock in &quot;ClassLoader.loadClass(String, boolean)&quot; method.</span>
<span class="line-removed">110             synchronized (loader) {</span>
<span class="line-removed">111                 return isSupportedImpl(hci);</span>
<span class="line-removed">112             }</span>
<span class="line-removed">113         }</span>
<span class="line-removed">114         return isSupportedImpl(hci);</span>
<span class="line-removed">115     }</span>
<span class="line-removed">116 </span>
117     /**
118      * Find out if the HttpCallerInfo supports Negotiate protocol. In order to
119      * find out yes or no, an initialization of a Negotiator object against it
120      * is tried. The generated object will be cached under the name of ths
121      * hostname at a success try.&lt;br&gt;
122      *
123      * If this method is called for the second time on an HttpCallerInfo with
124      * the same hostname, the answer is retrieved from cache.
125      *
126      * @return true if supported
127      */
<span class="line-modified">128     private static synchronized boolean isSupportedImpl(HttpCallerInfo hci) {</span>
129         if (supported == null) {
130             supported = new HashMap&lt;&gt;();
131         }
132         String hostname = hci.host;
133         hostname = hostname.toLowerCase();
134         if (supported.containsKey(hostname)) {
135             return supported.get(hostname);
136         }
137 
138         Negotiator neg = Negotiator.getNegotiator(hci);
139         if (neg != null) {
140             supported.put(hostname, true);
141             // the only place cache.put is called. here we can make sure
142             // the object is valid and the oneToken inside is not null
143             if (cache == null) {
144                 cache = new ThreadLocal&lt;&gt;() {
145                     @Override
146                     protected HashMap&lt;String, Negotiator&gt; initialValue() {
147                         return new HashMap&lt;&gt;();
148                     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www.protocol.http;
 27 
 28 import java.net.URL;
 29 import java.io.IOException;
 30 import java.net.Authenticator.RequestorType;
 31 import java.util.Base64;
 32 import java.util.HashMap;
 33 import sun.net.www.HeaderParser;

 34 import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
 35 import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
 36 import sun.security.action.GetPropertyAction;
 37 
 38 /**
 39  * NegotiateAuthentication:
 40  *
 41  * @author weijun.wang@sun.com
 42  * @since 1.6
 43  */
 44 
 45 class NegotiateAuthentication extends AuthenticationInfo {
 46 
<span class="line-added"> 47     @java.io.Serial</span>
 48     private static final long serialVersionUID = 100L;

 49 
<span class="line-added"> 50     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 51     private final HttpCallerInfo hci;
 52 
 53     // These maps are used to manage the GSS availability for diffrent
 54     // hosts. The key for both maps is the host name.
 55     // &lt;code&gt;supported&lt;/code&gt; is set when isSupported is checked,
 56     // if it&#39;s true, a cached Negotiator is put into &lt;code&gt;cache&lt;/code&gt;.
 57     // the cache can be used only once, so after the first use, it&#39;s cleaned.
 58     static HashMap &lt;String, Boolean&gt; supported = null;
 59     static ThreadLocal &lt;HashMap &lt;String, Negotiator&gt;&gt; cache = null;
 60     /* Whether cache is enabled for Negotiate/Kerberos */
 61     private static final boolean cacheSPNEGO;
 62     static {
 63         String spnegoCacheProp =
 64             GetPropertyAction.privilegedGetProperty(&quot;jdk.spnego.cache&quot;, &quot;true&quot;);
 65         cacheSPNEGO = Boolean.parseBoolean(spnegoCacheProp);
 66     }
 67 
 68     // The HTTP Negotiate Helper
<span class="line-added"> 69     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 70     private Negotiator negotiator = null;
 71 
 72    /**
 73     * Constructor used for both WWW and proxy entries.
 74     * @param hci a schemed object.
 75     */
 76     public NegotiateAuthentication(HttpCallerInfo hci) {
 77         super(RequestorType.PROXY==hci.authType ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION,
 78               hci.scheme.equalsIgnoreCase(&quot;Negotiate&quot;) ? NEGOTIATE : KERBEROS,
 79               hci.url,
 80               &quot;&quot;,
 81               AuthenticatorKeys.getKey(hci.authenticator));
 82         this.hci = hci;
 83     }
 84 
 85     /**
 86      * @return true if this authentication supports preemptive authorization
 87      */
 88     @Override
 89     public boolean supportsPreemptiveAuthorization() {
 90         return false;
 91     }
 92 

























 93     /**
 94      * Find out if the HttpCallerInfo supports Negotiate protocol. In order to
 95      * find out yes or no, an initialization of a Negotiator object against it
 96      * is tried. The generated object will be cached under the name of ths
 97      * hostname at a success try.&lt;br&gt;
 98      *
 99      * If this method is called for the second time on an HttpCallerInfo with
100      * the same hostname, the answer is retrieved from cache.
101      *
102      * @return true if supported
103      */
<span class="line-modified">104     synchronized public static boolean isSupported(HttpCallerInfo hci) {</span>
105         if (supported == null) {
106             supported = new HashMap&lt;&gt;();
107         }
108         String hostname = hci.host;
109         hostname = hostname.toLowerCase();
110         if (supported.containsKey(hostname)) {
111             return supported.get(hostname);
112         }
113 
114         Negotiator neg = Negotiator.getNegotiator(hci);
115         if (neg != null) {
116             supported.put(hostname, true);
117             // the only place cache.put is called. here we can make sure
118             // the object is valid and the oneToken inside is not null
119             if (cache == null) {
120                 cache = new ThreadLocal&lt;&gt;() {
121                     @Override
122                     protected HashMap&lt;String, Negotiator&gt; initialValue() {
123                         return new HashMap&lt;&gt;();
124                     }
</pre>
</td>
</tr>
</table>
<center><a href="HttpURLConnection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../https/DelegateHttpsURLConnection.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
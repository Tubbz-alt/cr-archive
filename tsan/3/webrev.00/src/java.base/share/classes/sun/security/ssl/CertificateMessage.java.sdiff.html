<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/CertificateMessage.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertStatusExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateRequest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertificateMessage.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 354             T12CertificateMessage cm = new T12CertificateMessage(hc, message);
 355             if (hc.sslConfig.isClientMode) {
 356                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 357                     SSLLogger.fine(
 358                         &quot;Consuming server Certificate handshake message&quot;, cm);
 359                 }
 360                 onCertificate((ClientHandshakeContext)context, cm);
 361             } else {
 362                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 363                     SSLLogger.fine(
 364                         &quot;Consuming client Certificate handshake message&quot;, cm);
 365                 }
 366                 onCertificate((ServerHandshakeContext)context, cm);
 367             }
 368         }
 369 
 370         private void onCertificate(ServerHandshakeContext shc,
 371                 T12CertificateMessage certificateMessage )throws IOException {
 372             List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
 373             if (encodedCerts == null || encodedCerts.isEmpty()) {




 374                 if (shc.sslConfig.clientAuthType !=
 375                         ClientAuthType.CLIENT_AUTH_REQUESTED) {
 376                     // unexpected or require client authentication
 377                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
 378                         &quot;Empty server certificate chain&quot;);
 379                 } else {
 380                     return;
 381                 }
 382             }
 383 
 384             X509Certificate[] x509Certs =
 385                     new X509Certificate[encodedCerts.size()];
 386             try {
 387                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 388                 int i = 0;
 389                 for (byte[] encodedCert : encodedCerts) {
 390                     x509Certs[i++] = (X509Certificate)cf.generateCertificate(
 391                                     new ByteArrayInputStream(encodedCert));
 392                 }
 393             } catch (CertificateException ce) {
</pre>
<hr />
<pre>
1017                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1018                     SSLLogger.warning(
1019                             &quot;No signature_algorithms(_cert) in ClientHello&quot;);
1020                 }
1021                 return null;
1022             }
1023 
1024             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
1025             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
1026                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
1027                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1028                         SSLLogger.warning(
1029                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1030                     }
1031                     continue;
1032                 }
1033 
1034                 // Don&#39;t select a signature scheme unless we will be able to
1035                 // produce a CertificateVerify message later
1036                 if (SignatureScheme.getPreferableAlgorithm(

1037                         hc.peerRequestedSignatureSchemes,
1038                         ss, hc.negotiatedProtocol) == null) {
1039 
1040                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1041                         SSLLogger.warning(
1042                             &quot;Unable to produce CertificateVerify for &quot; +
1043                             &quot;signature scheme: &quot; + ss.name);
1044                     }
1045                     checkedKeyTypes.add(ss.keyAlgorithm);
1046                     continue;
1047                 }
1048 
1049                 SSLAuthentication ka = X509Authentication.valueOf(ss);
1050                 if (ka == null) {
1051                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1052                         SSLLogger.warning(
1053                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1054                     }
1055                     checkedKeyTypes.add(ss.keyAlgorithm);
1056                     continue;
</pre>
<hr />
<pre>
1147             T13CertificateMessage cm = new T13CertificateMessage(hc, message);
1148             if (hc.sslConfig.isClientMode) {
1149                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1150                     SSLLogger.fine(
1151                         &quot;Consuming server Certificate handshake message&quot;, cm);
1152                 }
1153                 onConsumeCertificate((ClientHandshakeContext)context, cm);
1154             } else {
1155                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1156                     SSLLogger.fine(
1157                         &quot;Consuming client Certificate handshake message&quot;, cm);
1158                 }
1159                 onConsumeCertificate((ServerHandshakeContext)context, cm);
1160             }
1161         }
1162 
1163         private void onConsumeCertificate(ServerHandshakeContext shc,
1164                 T13CertificateMessage certificateMessage )throws IOException {
1165             if (certificateMessage.certEntries == null ||
1166                     certificateMessage.certEntries.isEmpty()) {




1167                 if (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED) {
1168                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1169                         &quot;Empty client certificate chain&quot;);
1170                 } else {
1171                     // optional client authentication
1172                     return;
1173                 }
1174             }
1175 
1176             // check client certificate entries
1177             X509Certificate[] cliCerts =
1178                     checkClientCerts(shc, certificateMessage.certEntries);
1179 
1180             //
1181             // update
1182             //
1183             shc.handshakeCredentials.add(
1184                 new X509Credentials(cliCerts[0].getPublicKey(), cliCerts));
1185             shc.handshakeSession.setPeerCertificates(cliCerts);
1186         }
</pre>
</td>
<td>
<hr />
<pre>
 354             T12CertificateMessage cm = new T12CertificateMessage(hc, message);
 355             if (hc.sslConfig.isClientMode) {
 356                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 357                     SSLLogger.fine(
 358                         &quot;Consuming server Certificate handshake message&quot;, cm);
 359                 }
 360                 onCertificate((ClientHandshakeContext)context, cm);
 361             } else {
 362                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 363                     SSLLogger.fine(
 364                         &quot;Consuming client Certificate handshake message&quot;, cm);
 365                 }
 366                 onCertificate((ServerHandshakeContext)context, cm);
 367             }
 368         }
 369 
 370         private void onCertificate(ServerHandshakeContext shc,
 371                 T12CertificateMessage certificateMessage )throws IOException {
 372             List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
 373             if (encodedCerts == null || encodedCerts.isEmpty()) {
<span class="line-added"> 374                 // For empty Certificate messages, we should not expect</span>
<span class="line-added"> 375                 // a CertificateVerify message to follow</span>
<span class="line-added"> 376                 shc.handshakeConsumers.remove(</span>
<span class="line-added"> 377                         SSLHandshake.CERTIFICATE_VERIFY.id);</span>
 378                 if (shc.sslConfig.clientAuthType !=
 379                         ClientAuthType.CLIENT_AUTH_REQUESTED) {
 380                     // unexpected or require client authentication
 381                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
 382                         &quot;Empty server certificate chain&quot;);
 383                 } else {
 384                     return;
 385                 }
 386             }
 387 
 388             X509Certificate[] x509Certs =
 389                     new X509Certificate[encodedCerts.size()];
 390             try {
 391                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 392                 int i = 0;
 393                 for (byte[] encodedCert : encodedCerts) {
 394                     x509Certs[i++] = (X509Certificate)cf.generateCertificate(
 395                                     new ByteArrayInputStream(encodedCert));
 396                 }
 397             } catch (CertificateException ce) {
</pre>
<hr />
<pre>
1021                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1022                     SSLLogger.warning(
1023                             &quot;No signature_algorithms(_cert) in ClientHello&quot;);
1024                 }
1025                 return null;
1026             }
1027 
1028             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
1029             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
1030                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
1031                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1032                         SSLLogger.warning(
1033                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1034                     }
1035                     continue;
1036                 }
1037 
1038                 // Don&#39;t select a signature scheme unless we will be able to
1039                 // produce a CertificateVerify message later
1040                 if (SignatureScheme.getPreferableAlgorithm(
<span class="line-added">1041                         hc.algorithmConstraints,</span>
1042                         hc.peerRequestedSignatureSchemes,
1043                         ss, hc.negotiatedProtocol) == null) {
1044 
1045                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1046                         SSLLogger.warning(
1047                             &quot;Unable to produce CertificateVerify for &quot; +
1048                             &quot;signature scheme: &quot; + ss.name);
1049                     }
1050                     checkedKeyTypes.add(ss.keyAlgorithm);
1051                     continue;
1052                 }
1053 
1054                 SSLAuthentication ka = X509Authentication.valueOf(ss);
1055                 if (ka == null) {
1056                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1057                         SSLLogger.warning(
1058                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1059                     }
1060                     checkedKeyTypes.add(ss.keyAlgorithm);
1061                     continue;
</pre>
<hr />
<pre>
1152             T13CertificateMessage cm = new T13CertificateMessage(hc, message);
1153             if (hc.sslConfig.isClientMode) {
1154                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1155                     SSLLogger.fine(
1156                         &quot;Consuming server Certificate handshake message&quot;, cm);
1157                 }
1158                 onConsumeCertificate((ClientHandshakeContext)context, cm);
1159             } else {
1160                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1161                     SSLLogger.fine(
1162                         &quot;Consuming client Certificate handshake message&quot;, cm);
1163                 }
1164                 onConsumeCertificate((ServerHandshakeContext)context, cm);
1165             }
1166         }
1167 
1168         private void onConsumeCertificate(ServerHandshakeContext shc,
1169                 T13CertificateMessage certificateMessage )throws IOException {
1170             if (certificateMessage.certEntries == null ||
1171                     certificateMessage.certEntries.isEmpty()) {
<span class="line-added">1172                 // For empty Certificate messages, we should not expect</span>
<span class="line-added">1173                 // a CertificateVerify message to follow</span>
<span class="line-added">1174                 shc.handshakeConsumers.remove(</span>
<span class="line-added">1175                         SSLHandshake.CERTIFICATE_VERIFY.id);</span>
1176                 if (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED) {
1177                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1178                         &quot;Empty client certificate chain&quot;);
1179                 } else {
1180                     // optional client authentication
1181                     return;
1182                 }
1183             }
1184 
1185             // check client certificate entries
1186             X509Certificate[] cliCerts =
1187                     checkClientCerts(shc, certificateMessage.certEntries);
1188 
1189             //
1190             // update
1191             //
1192             shc.handshakeCredentials.add(
1193                 new X509Credentials(cliCerts[0].getPublicKey(), cliCerts));
1194             shc.handshakeSession.setPeerCertificates(cliCerts);
1195         }
</pre>
</td>
</tr>
</table>
<center><a href="CertStatusExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateRequest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
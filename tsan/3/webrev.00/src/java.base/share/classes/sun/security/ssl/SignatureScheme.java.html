<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SignatureScheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.*;
 29 import java.security.spec.AlgorithmParameterSpec;
 30 import java.security.spec.ECParameterSpec;
 31 import java.security.spec.MGF1ParameterSpec;
 32 import java.security.spec.PSSParameterSpec;
 33 import java.util.AbstractMap.SimpleImmutableEntry;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.Collection;
 37 import java.util.Collections;
 38 import java.util.EnumSet;
 39 import java.util.LinkedList;
 40 import java.util.List;
 41 import java.util.Map;
 42 import java.util.Set;
 43 import sun.security.ssl.NamedGroup.NamedGroupSpec;
 44 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 45 import sun.security.ssl.X509Authentication.X509Possession;
 46 import sun.security.util.KeyUtil;
 47 import sun.security.util.SignatureUtil;
 48 
 49 enum SignatureScheme {
 50     // EdDSA algorithms
 51     ED25519                 (0x0807, &quot;ed25519&quot;, &quot;ed25519&quot;,
 52                                     &quot;ed25519&quot;,
 53                                     ProtocolVersion.PROTOCOLS_OF_13),
 54     ED448                   (0x0808, &quot;ed448&quot;, &quot;ed448&quot;,
 55                                     &quot;ed448&quot;,
 56                                     ProtocolVersion.PROTOCOLS_OF_13),
 57 
 58     // ECDSA algorithms
 59     ECDSA_SECP256R1_SHA256  (0x0403, &quot;ecdsa_secp256r1_sha256&quot;,
 60                                     &quot;SHA256withECDSA&quot;,
 61                                     &quot;EC&quot;,
 62                                     NamedGroup.SECP256_R1,
 63                                     ProtocolVersion.PROTOCOLS_TO_13),
 64     ECDSA_SECP384R1_SHA384  (0x0503, &quot;ecdsa_secp384r1_sha384&quot;,
 65                                     &quot;SHA384withECDSA&quot;,
 66                                     &quot;EC&quot;,
 67                                     NamedGroup.SECP384_R1,
 68                                     ProtocolVersion.PROTOCOLS_TO_13),
 69     ECDSA_SECP521R1_SHA512  (0x0603, &quot;ecdsa_secp521r1_sha512&quot;,
 70                                     &quot;SHA512withECDSA&quot;,
 71                                     &quot;EC&quot;,
 72                                     NamedGroup.SECP521_R1,
 73                                     ProtocolVersion.PROTOCOLS_TO_13),
 74 
 75     // RSASSA-PSS algorithms with public key OID rsaEncryption
 76     //
 77     // The minimalKeySize is calculated as (See RFC 8017 for details):
 78     //     hash length + salt length + 16
 79     RSA_PSS_RSAE_SHA256     (0x0804, &quot;rsa_pss_rsae_sha256&quot;,
 80                                     &quot;RSASSA-PSS&quot;, &quot;RSA&quot;,
 81                                     SigAlgParamSpec.RSA_PSS_SHA256, 528,
 82                                     ProtocolVersion.PROTOCOLS_12_13),
 83     RSA_PSS_RSAE_SHA384     (0x0805, &quot;rsa_pss_rsae_sha384&quot;,
 84                                     &quot;RSASSA-PSS&quot;, &quot;RSA&quot;,
 85                                     SigAlgParamSpec.RSA_PSS_SHA384, 784,
 86                                     ProtocolVersion.PROTOCOLS_12_13),
 87     RSA_PSS_RSAE_SHA512     (0x0806, &quot;rsa_pss_rsae_sha512&quot;,
 88                                     &quot;RSASSA-PSS&quot;, &quot;RSA&quot;,
 89                                     SigAlgParamSpec.RSA_PSS_SHA512, 1040,
 90                                     ProtocolVersion.PROTOCOLS_12_13),
 91 
 92     // RSASSA-PSS algorithms with public key OID RSASSA-PSS
 93     //
 94     // The minimalKeySize is calculated as (See RFC 8017 for details):
 95     //     hash length + salt length + 16
 96     RSA_PSS_PSS_SHA256      (0x0809, &quot;rsa_pss_pss_sha256&quot;,
 97                                     &quot;RSASSA-PSS&quot;, &quot;RSASSA-PSS&quot;,
 98                                     SigAlgParamSpec.RSA_PSS_SHA256, 528,
 99                                     ProtocolVersion.PROTOCOLS_12_13),
100     RSA_PSS_PSS_SHA384      (0x080A, &quot;rsa_pss_pss_sha384&quot;,
101                                     &quot;RSASSA-PSS&quot;, &quot;RSASSA-PSS&quot;,
102                                     SigAlgParamSpec.RSA_PSS_SHA384, 784,
103                                     ProtocolVersion.PROTOCOLS_12_13),
104     RSA_PSS_PSS_SHA512      (0x080B, &quot;rsa_pss_pss_sha512&quot;,
105                                     &quot;RSASSA-PSS&quot;, &quot;RSASSA-PSS&quot;,
106                                     SigAlgParamSpec.RSA_PSS_SHA512, 1040,
107                                     ProtocolVersion.PROTOCOLS_12_13),
108 
109     // RSASSA-PKCS1-v1_5 algorithms
110     RSA_PKCS1_SHA256        (0x0401, &quot;rsa_pkcs1_sha256&quot;, &quot;SHA256withRSA&quot;,
111                                     &quot;RSA&quot;, null, null, 511,
112                                     ProtocolVersion.PROTOCOLS_TO_13,
113                                     ProtocolVersion.PROTOCOLS_TO_12),
114     RSA_PKCS1_SHA384        (0x0501, &quot;rsa_pkcs1_sha384&quot;, &quot;SHA384withRSA&quot;,
115                                     &quot;RSA&quot;, null, null, 768,
116                                     ProtocolVersion.PROTOCOLS_TO_13,
117                                     ProtocolVersion.PROTOCOLS_TO_12),
118     RSA_PKCS1_SHA512        (0x0601, &quot;rsa_pkcs1_sha512&quot;, &quot;SHA512withRSA&quot;,
119                                     &quot;RSA&quot;, null, null, 768,
120                                     ProtocolVersion.PROTOCOLS_TO_13,
121                                     ProtocolVersion.PROTOCOLS_TO_12),
122 
123     // Legacy algorithms
124     DSA_SHA256              (0x0402, &quot;dsa_sha256&quot;, &quot;SHA256withDSA&quot;,
125                                     &quot;DSA&quot;,
126                                     ProtocolVersion.PROTOCOLS_TO_12),
127     ECDSA_SHA224            (0x0303, &quot;ecdsa_sha224&quot;, &quot;SHA224withECDSA&quot;,
128                                     &quot;EC&quot;,
129                                     ProtocolVersion.PROTOCOLS_TO_12),
130     RSA_SHA224              (0x0301, &quot;rsa_sha224&quot;, &quot;SHA224withRSA&quot;,
131                                     &quot;RSA&quot;, 511,
132                                     ProtocolVersion.PROTOCOLS_TO_12),
133     DSA_SHA224              (0x0302, &quot;dsa_sha224&quot;, &quot;SHA224withDSA&quot;,
134                                     &quot;DSA&quot;,
135                                     ProtocolVersion.PROTOCOLS_TO_12),
136     ECDSA_SHA1              (0x0203, &quot;ecdsa_sha1&quot;, &quot;SHA1withECDSA&quot;,
137                                     &quot;EC&quot;,
138                                     ProtocolVersion.PROTOCOLS_TO_13),
139     RSA_PKCS1_SHA1          (0x0201, &quot;rsa_pkcs1_sha1&quot;, &quot;SHA1withRSA&quot;,
140                                     &quot;RSA&quot;, null, null, 511,
141                                     ProtocolVersion.PROTOCOLS_TO_13,
142                                     ProtocolVersion.PROTOCOLS_TO_12),
143     DSA_SHA1                (0x0202, &quot;dsa_sha1&quot;, &quot;SHA1withDSA&quot;,
144                                     &quot;DSA&quot;,
145                                     ProtocolVersion.PROTOCOLS_TO_12),
146     RSA_MD5                 (0x0101, &quot;rsa_md5&quot;, &quot;MD5withRSA&quot;,
147                                     &quot;RSA&quot;, 511,
148                                     ProtocolVersion.PROTOCOLS_TO_12);
149 
150     final int id;                       // hash + signature
151     final String name;                  // literal name
152     private final String algorithm;     // signature algorithm
153     final String keyAlgorithm;          // signature key algorithm
154     private final SigAlgParamSpec signAlgParams;    // signature parameters
155     private final NamedGroup namedGroup;    // associated named group
156 
157     // The minimal required key size in bits.
158     //
159     // Only need to check RSA algorithm at present. RSA keys of 512 bits
160     // have been shown to be practically breakable, it does not make much
161     // sense to use the strong hash algorithm for keys whose key size less
162     // than 512 bits.  So it is not necessary to calculate the minimal
163     // required key size exactly for a hash algorithm.
164     //
165     // Note that some provider may use 511 bits for 512-bit strength RSA keys.
166     final int minimalKeySize;
167     final List&lt;ProtocolVersion&gt; supportedProtocols;
168 
169     // Some signature schemes are supported in different versions for handshake
170     // messages and certificates. This field holds the supported protocols
171     // for handshake messages.
172     final List&lt;ProtocolVersion&gt; handshakeSupportedProtocols;
173     final boolean isAvailable;
174 
175     private static final String[] hashAlgorithms = new String[] {
176             &quot;none&quot;,         &quot;md5&quot;,      &quot;sha1&quot;,     &quot;sha224&quot;,
177             &quot;sha256&quot;,       &quot;sha384&quot;,   &quot;sha512&quot;
178         };
179 
180     private static final String[] signatureAlgorithms = new String[] {
181             &quot;anonymous&quot;,    &quot;rsa&quot;,      &quot;dsa&quot;,      &quot;ecdsa&quot;,
182         };
183 
184     static enum SigAlgParamSpec {   // support RSASSA-PSS only now
185         RSA_PSS_SHA256 (&quot;SHA-256&quot;, 32),
186         RSA_PSS_SHA384 (&quot;SHA-384&quot;, 48),
187         RSA_PSS_SHA512 (&quot;SHA-512&quot;, 64);
188 
189         private final AlgorithmParameterSpec parameterSpec;
190         private final AlgorithmParameters parameters;
191         private final boolean isAvailable;
192 
193         SigAlgParamSpec(String hash, int saltLength) {
194             // See RFC 8017
195             PSSParameterSpec pssParamSpec =
196                     new PSSParameterSpec(hash, &quot;MGF1&quot;,
197                             new MGF1ParameterSpec(hash), saltLength, 1);
198             AlgorithmParameters pssParams = null;
199 
200             boolean mediator = true;
201             try {
202                 Signature signer = Signature.getInstance(&quot;RSASSA-PSS&quot;);
203                 signer.setParameter(pssParamSpec);
204                 pssParams = signer.getParameters();
205             } catch (InvalidAlgorithmParameterException |
206                     NoSuchAlgorithmException | RuntimeException exp) {
207                 // Signature.getParameters() may throw RuntimeException.
208                 mediator = false;
209                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
210                     SSLLogger.warning(
211                         &quot;RSASSA-PSS signature with &quot; + hash +
212                         &quot; is not supported by the underlying providers&quot;, exp);
213                 }
214             }
215 
216             this.isAvailable = mediator;
217             this.parameterSpec = mediator ? pssParamSpec : null;
218             this.parameters = mediator ? pssParams : null;
219         }
220     }
221 
222     // performance optimization
223     private static final Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
224         Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
225 
226 
227     private SignatureScheme(int id, String name,
228             String algorithm, String keyAlgorithm,
229             ProtocolVersion[] supportedProtocols) {
230         this(id, name, algorithm, keyAlgorithm, -1, supportedProtocols);
231     }
232 
233     private SignatureScheme(int id, String name,
234             String algorithm, String keyAlgorithm,
235             int minimalKeySize,
236             ProtocolVersion[] supportedProtocols) {
237         this(id, name, algorithm, keyAlgorithm,
238                 null, minimalKeySize, supportedProtocols);
239     }
240 
241     private SignatureScheme(int id, String name,
242             String algorithm, String keyAlgorithm,
243             SigAlgParamSpec signAlgParamSpec, int minimalKeySize,
244             ProtocolVersion[] supportedProtocols) {
245         this(id, name, algorithm, keyAlgorithm,
246                 signAlgParamSpec, null, minimalKeySize,
247                 supportedProtocols, supportedProtocols);
248     }
249 
250     private SignatureScheme(int id, String name,
251             String algorithm, String keyAlgorithm,
252             NamedGroup namedGroup,
253             ProtocolVersion[] supportedProtocols) {
254         this(id, name, algorithm, keyAlgorithm,
255                 null, namedGroup, -1,
256                 supportedProtocols, supportedProtocols);
257     }
258 
259     private SignatureScheme(int id, String name,
260             String algorithm, String keyAlgorithm,
261             SigAlgParamSpec signAlgParams,
262             NamedGroup namedGroup, int minimalKeySize,
263             ProtocolVersion[] supportedProtocols,
264             ProtocolVersion[] handshakeSupportedProtocols) {
265         this.id = id;
266         this.name = name;
267         this.algorithm = algorithm;
268         this.keyAlgorithm = keyAlgorithm;
269         this.signAlgParams = signAlgParams;
270         this.namedGroup = namedGroup;
271         this.minimalKeySize = minimalKeySize;
272         this.supportedProtocols = Arrays.asList(supportedProtocols);
273         this.handshakeSupportedProtocols =
274                 Arrays.asList(handshakeSupportedProtocols);
275 
276         boolean mediator = true;
277         // An EC provider, for example the SunEC provider, may support
278         // AlgorithmParameters but not KeyPairGenerator or Signature.
279         //
280         // Note: Please be careful if removing this block!
281         if (&quot;EC&quot;.equals(keyAlgorithm)) {
282             mediator = JsseJce.isEcAvailable();
283         }
284 
285         // Check the specific algorithm and parameters.
286         if (mediator) {
287             if (signAlgParams != null) {
288                 mediator = signAlgParams.isAvailable;
289             } else {
290                 try {
291                     Signature.getInstance(algorithm);
292                 } catch (Exception e) {
293                     mediator = false;
294                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
295                         SSLLogger.warning(
296                             &quot;Signature algorithm, &quot; + algorithm +
297                             &quot;, is not supported by the underlying providers&quot;);
298                     }
299                 }
300             }
301         }
302 
303         if (mediator &amp;&amp; ((id &gt;&gt; 8) &amp; 0xFF) == 0x03) {   // SHA224
304             // There are some problems to use SHA224 on Windows.
305             if (Security.getProvider(&quot;SunMSCAPI&quot;) != null) {
306                 mediator = false;
307             }
308         }
309 
310         this.isAvailable = mediator;
311     }
312 
313     static SignatureScheme valueOf(int id) {
314         for (SignatureScheme ss: SignatureScheme.values()) {
315             if (ss.id == id) {
316                 return ss;
317             }
318         }
319 
320         return null;
321     }
322 
323     static String nameOf(int id) {
324         for (SignatureScheme ss: SignatureScheme.values()) {
325             if (ss.id == id) {
326                 return ss.name;
327             }
328         }
329 
330         // Use TLS 1.2 style name for unknown signature scheme.
331         int hashId = ((id &gt;&gt; 8) &amp; 0xFF);
332         int signId = (id &amp; 0xFF);
333         String hashName = (hashId &gt;= hashAlgorithms.length) ?
334             &quot;UNDEFINED-HASH(&quot; + hashId + &quot;)&quot; : hashAlgorithms[hashId];
335         String signName = (signId &gt;= signatureAlgorithms.length) ?
336             &quot;UNDEFINED-SIGNATURE(&quot; + signId + &quot;)&quot; :
337             signatureAlgorithms[signId];
338 
339         return signName + &quot;_&quot; + hashName;
340     }
341 
342     // Return the size of a SignatureScheme structure in TLS record
343     static int sizeInRecord() {
344         return 2;
345     }
346 
347     private boolean isPermitted(AlgorithmConstraints constraints) {
348         return constraints.permits(SIGNATURE_PRIMITIVE_SET,
349                         this.name, null) &amp;&amp;
350                constraints.permits(SIGNATURE_PRIMITIVE_SET,
351                         this.keyAlgorithm, null) &amp;&amp;
352                constraints.permits(SIGNATURE_PRIMITIVE_SET,
353                         this.algorithm, (signAlgParams != null ?
354                                 signAlgParams.parameters : null)) &amp;&amp;
355                (namedGroup != null ?
356                         namedGroup.isPermitted(constraints) : true);
357     }
358 
359     // Get local supported algorithm collection complying to algorithm
360     // constraints.
361     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
362             AlgorithmConstraints constraints,
363             List&lt;ProtocolVersion&gt; activeProtocols) {
364         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
365         for (SignatureScheme ss: SignatureScheme.values()) {
366             if (!ss.isAvailable) {
367                 continue;
368             }
369 
370             boolean isMatch = false;
371             for (ProtocolVersion pv : activeProtocols) {
372                 if (ss.supportedProtocols.contains(pv)) {
373                     isMatch = true;
374                     break;
375                 }
376             }
377 
378             if (isMatch) {
379                 if (ss.isPermitted(constraints)) {
380                     supported.add(ss);
381                 } else if (SSLLogger.isOn &amp;&amp;
382                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
383                     SSLLogger.finest(
384                         &quot;Ignore disabled signature scheme: &quot; + ss.name);
385                 }
386             } else if (SSLLogger.isOn &amp;&amp;
387                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
388                 SSLLogger.finest(
389                     &quot;Ignore inactive signature scheme: &quot; + ss.name);
390             }
391         }
392 
393         return supported;
394     }
395 
396     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
397             AlgorithmConstraints constraints,
398             ProtocolVersion protocolVersion, int[] algorithmIds) {
399         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
400         for (int ssid : algorithmIds) {
401             SignatureScheme ss = SignatureScheme.valueOf(ssid);
402             if (ss == null) {
403                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
404                     SSLLogger.warning(
405                             &quot;Unsupported signature scheme: &quot; +
406                             SignatureScheme.nameOf(ssid));
407                 }
408             } else if (ss.isAvailable &amp;&amp;
409                     ss.supportedProtocols.contains(protocolVersion) &amp;&amp;
410                     ss.isPermitted(constraints)) {
411                 supported.add(ss);
412             } else {
413                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
414                     SSLLogger.warning(
415                             &quot;Unsupported signature scheme: &quot; + ss.name);
416                 }
417             }
418         }
419 
420         return supported;
421     }
422 
423     static SignatureScheme getPreferableAlgorithm(
424             AlgorithmConstraints constraints,
425             List&lt;SignatureScheme&gt; schemes,
426             SignatureScheme certScheme,
427             ProtocolVersion version) {
428 
429         for (SignatureScheme ss : schemes) {
430             if (ss.isAvailable &amp;&amp;
431                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
432                     certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;
433                     ss.isPermitted(constraints)) {
434                 return ss;
435             }
436         }
437 
438         return null;
439     }
440 
441     static Map.Entry&lt;SignatureScheme, Signature&gt; getSignerOfPreferableAlgorithm(
442             AlgorithmConstraints constraints,
443             List&lt;SignatureScheme&gt; schemes,
444             X509Possession x509Possession,
445             ProtocolVersion version) {
446 
447         PrivateKey signingKey = x509Possession.popPrivateKey;
448         String keyAlgorithm = signingKey.getAlgorithm();
449         int keySize;
450         // Only need to check RSA algorithm at present.
451         if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;) ||
452                 keyAlgorithm.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
453             keySize = KeyUtil.getKeySize(signingKey);
454         } else {
455             keySize = Integer.MAX_VALUE;
456         }
457         for (SignatureScheme ss : schemes) {
458             if (ss.isAvailable &amp;&amp; (keySize &gt;= ss.minimalKeySize) &amp;&amp;
459                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
460                     keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;
461                     ss.isPermitted(constraints)) {
462                 if ((ss.namedGroup != null) &amp;&amp; (ss.namedGroup.spec ==
463                         NamedGroupSpec.NAMED_GROUP_ECDHE)) {
464                     ECParameterSpec params =
465                             x509Possession.getECParameterSpec();
466                     if (params != null &amp;&amp;
467                             ss.namedGroup == NamedGroup.valueOf(params)) {
468                         Signature signer = ss.getSigner(signingKey);
469                         if (signer != null) {
470                             return new SimpleImmutableEntry&lt;&gt;(ss, signer);
471                         }
472                     }
473 
474                     if (SSLLogger.isOn &amp;&amp;
475                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
476                         SSLLogger.finest(
477                             &quot;Ignore the signature algorithm (&quot; + ss +
478                             &quot;), unsupported EC parameter spec: &quot; + params);
479                     }
480                 } else if (&quot;EC&quot;.equals(ss.keyAlgorithm)) {
481                     // Must be a legacy signature algorithm, which does not
482                     // specify the associated named groups.  The connection
483                     // cannot be established if the peer cannot recognize
484                     // the named group used for the signature.  RFC 8446
485                     // does not define countermeasures for the corner cases.
486                     // In order to mitigate the impact, we choose to check
487                     // against the local supported named groups.  The risk
488                     // should be minimal as applications should not use
489                     // unsupported named groups for its certificates.
490                     ECParameterSpec params =
491                             x509Possession.getECParameterSpec();
492                     if (params != null) {
493                         NamedGroup keyGroup = NamedGroup.valueOf(params);
494                         if (keyGroup != null &amp;&amp;
495                                 SupportedGroups.isSupported(keyGroup)) {
496                             Signature signer = ss.getSigner(signingKey);
497                             if (signer != null) {
498                                 return new SimpleImmutableEntry&lt;&gt;(ss, signer);
499                             }
500                         }
501                     }
502 
503                     if (SSLLogger.isOn &amp;&amp;
504                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
505                         SSLLogger.finest(
506                             &quot;Ignore the legacy signature algorithm (&quot; + ss +
507                             &quot;), unsupported EC parameter spec: &quot; + params);
508                     }
509                 } else {
510                     Signature signer = ss.getSigner(signingKey);
511                     if (signer != null) {
512                         return new SimpleImmutableEntry&lt;&gt;(ss, signer);
513                     }
514                 }
515             }
516         }
517 
518         return null;
519     }
520 
521     static String[] getAlgorithmNames(Collection&lt;SignatureScheme&gt; schemes) {
522         if (schemes != null) {
523             ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(schemes.size());
524             for (SignatureScheme scheme : schemes) {
525                 names.add(scheme.algorithm);
526             }
527 
528             return names.toArray(new String[0]);
529         }
530 
531         return new String[0];
532     }
533 
534     // This method is used to get the signature instance of this signature
535     // scheme for the specific public key.  Unlike getSigner(), the exception
536     // is bubbled up.  If the public key does not support this signature
537     // scheme, it normally means the TLS handshaking cannot continue and
538     // the connection should be terminated.
539     Signature getVerifier(PublicKey publicKey) throws NoSuchAlgorithmException,
540             InvalidAlgorithmParameterException, InvalidKeyException {
541         if (!isAvailable) {
542             return null;
543         }
544 
545         Signature verifier = Signature.getInstance(algorithm);
546         SignatureUtil.initVerifyWithParam(verifier, publicKey,
547                 (signAlgParams != null ? signAlgParams.parameterSpec : null));
548 
549         return verifier;
550     }
551 
552     // This method is also used to choose preferable signature scheme for the
553     // specific private key.  If the private key does not support the signature
554     // scheme, {@code null} is returned, and the caller may fail back to next
555     // available signature scheme.
556     private Signature getSigner(PrivateKey privateKey) {
557         if (!isAvailable) {
558             return null;
559         }
560 
561         try {
562             Signature signer = Signature.getInstance(algorithm);
563             SignatureUtil.initSignWithParam(signer, privateKey,
564                 (signAlgParams != null ? signAlgParams.parameterSpec : null),
565                 null);
566             return signer;
567         } catch (NoSuchAlgorithmException | InvalidKeyException |
568                 InvalidAlgorithmParameterException nsae) {
569             if (SSLLogger.isOn &amp;&amp;
570                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
571                 SSLLogger.finest(
572                     &quot;Ignore unsupported signature algorithm (&quot; +
573                     this.name + &quot;)&quot;, nsae);
574             }
575         }
576 
577         return null;
578     }
579 }
    </pre>
  </body>
</html>
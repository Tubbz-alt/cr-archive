<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.DatagramSocket;
  31 import java.net.Inet4Address;
  32 import java.net.Inet6Address;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.NetworkInterface;
  36 import java.net.PortUnreachableException;
  37 import java.net.ProtocolFamily;
  38 import java.net.SocketAddress;
  39 import java.net.SocketOption;
  40 import java.net.StandardProtocolFamily;
  41 import java.net.StandardSocketOptions;
  42 import java.nio.ByteBuffer;
  43 import java.nio.channels.AlreadyBoundException;
  44 import java.nio.channels.AlreadyConnectedException;
  45 import java.nio.channels.AsynchronousCloseException;
  46 import java.nio.channels.ClosedChannelException;
  47 import java.nio.channels.DatagramChannel;
  48 import java.nio.channels.MembershipKey;
  49 import java.nio.channels.NotYetConnectedException;
  50 import java.nio.channels.SelectionKey;
  51 import java.nio.channels.spi.SelectorProvider;
  52 import java.util.Collections;
  53 import java.util.HashSet;
  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;
  57 
  58 import sun.net.ResourceManager;
  59 import sun.net.ext.ExtendedSocketOptions;
  60 
  61 /**
  62  * An implementation of DatagramChannels.
  63  */
  64 
  65 class DatagramChannelImpl
  66     extends DatagramChannel
  67     implements SelChImpl
  68 {
  69     // Used to make native read and write calls
  70     private static NativeDispatcher nd = new DatagramDispatcher();
  71 
  72     // The protocol family of the socket
  73     private final ProtocolFamily family;
  74 
  75     // Our file descriptor
  76     private final FileDescriptor fd;
  77     private final int fdVal;
  78 
  79     // Cached InetAddress and port for unconnected DatagramChannels
  80     // used by receive0
  81     private InetAddress cachedSenderInetAddress;
  82     private int cachedSenderPort;
  83 
  84     // Lock held by current reading or connecting thread
  85     private final ReentrantLock readLock = new ReentrantLock();
  86 
  87     // Lock held by current writing or connecting thread
  88     private final ReentrantLock writeLock = new ReentrantLock();
  89 
  90     // Lock held by any thread that modifies the state fields declared below
  91     // DO NOT invoke a blocking I/O operation while holding this lock!
  92     private final Object stateLock = new Object();
  93 
  94     // -- The following fields are protected by stateLock
  95 
  96     // State (does not necessarily increase monotonically)
  97     private static final int ST_UNCONNECTED = 0;
  98     private static final int ST_CONNECTED = 1;
  99     private static final int ST_CLOSING = 2;
 100     private static final int ST_KILLPENDING = 3;
 101     private static final int ST_KILLED = 4;
 102     private int state;
 103 
 104     // IDs of native threads doing reads and writes, for signalling
 105     private long readerThread;
 106     private long writerThread;
 107 
 108     // Binding and remote address (when connected)
 109     private InetSocketAddress localAddress;
 110     private InetSocketAddress remoteAddress;
 111 
 112     // Our socket adaptor, if any
 113     private DatagramSocket socket;
 114 
 115     // Multicast support
 116     private MembershipRegistry registry;
 117 
 118     // set true when socket is bound and SO_REUSEADDRESS is emulated
 119     private boolean reuseAddressEmulated;
 120 
 121     // set true/false when socket is already bound and SO_REUSEADDR is emulated
 122     private boolean isReuseAddress;
 123 
 124     // -- End of fields protected by stateLock
 125 
 126     public DatagramChannelImpl(SelectorProvider sp)
 127         throws IOException
 128     {
 129         super(sp);
 130         ResourceManager.beforeUdpCreate();
 131         try {
 132             this.family = Net.isIPv6Available()
 133                     ? StandardProtocolFamily.INET6
 134                     : StandardProtocolFamily.INET;
 135             this.fd = Net.socket(family, false);
 136             this.fdVal = IOUtil.fdVal(fd);
 137         } catch (IOException ioe) {
 138             ResourceManager.afterUdpClose();
 139             throw ioe;
 140         }
 141     }
 142 
 143     public DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family)
 144         throws IOException
 145     {
 146         super(sp);
 147         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
 148         if ((family != StandardProtocolFamily.INET) &amp;&amp;
 149             (family != StandardProtocolFamily.INET6)) {
 150             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
 151         }
 152         if (family == StandardProtocolFamily.INET6) {
 153             if (!Net.isIPv6Available()) {
 154                 throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);
 155             }
 156         }
 157 
 158         ResourceManager.beforeUdpCreate();
 159         try {
 160             this.family = family;
 161             this.fd = Net.socket(family, false);
 162             this.fdVal = IOUtil.fdVal(fd);
 163         } catch (IOException ioe) {
 164             ResourceManager.afterUdpClose();
 165             throw ioe;
 166         }
 167     }
 168 
 169     public DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)
 170         throws IOException
 171     {
 172         super(sp);
 173 
 174         // increment UDP count to match decrement when closing
 175         ResourceManager.beforeUdpCreate();
 176 
 177         this.family = Net.isIPv6Available()
 178                 ? StandardProtocolFamily.INET6
 179                 : StandardProtocolFamily.INET;
 180         this.fd = fd;
 181         this.fdVal = IOUtil.fdVal(fd);
 182         synchronized (stateLock) {
 183             this.localAddress = Net.localAddress(fd);
 184         }
 185     }
 186 
 187     // @throws ClosedChannelException if channel is closed
 188     private void ensureOpen() throws ClosedChannelException {
 189         if (!isOpen())
 190             throw new ClosedChannelException();
 191     }
 192 
 193     @Override
 194     public DatagramSocket socket() {
 195         synchronized (stateLock) {
 196             if (socket == null)
 197                 socket = DatagramSocketAdaptor.create(this);
 198             return socket;
 199         }
 200     }
 201 
 202     @Override
 203     public SocketAddress getLocalAddress() throws IOException {
 204         synchronized (stateLock) {
 205             ensureOpen();
 206             // Perform security check before returning address
 207             return Net.getRevealedLocalAddress(localAddress);
 208         }
 209     }
 210 
 211     @Override
 212     public SocketAddress getRemoteAddress() throws IOException {
 213         synchronized (stateLock) {
 214             ensureOpen();
 215             return remoteAddress;
 216         }
 217     }
 218 
 219     @Override
 220     public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
 221         throws IOException
 222     {
 223         Objects.requireNonNull(name);
 224         if (!supportedOptions().contains(name))
 225             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 226 
 227         synchronized (stateLock) {
 228             ensureOpen();
 229 
 230             if (name == StandardSocketOptions.IP_TOS ||
 231                 name == StandardSocketOptions.IP_MULTICAST_TTL ||
 232                 name == StandardSocketOptions.IP_MULTICAST_LOOP)
 233             {
 234                 // options are protocol dependent
 235                 Net.setSocketOption(fd, family, name, value);
 236                 return this;
 237             }
 238 
 239             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 240                 if (value == null)
 241                     throw new IllegalArgumentException(&quot;Cannot set IP_MULTICAST_IF to &#39;null&#39;&quot;);
 242                 NetworkInterface interf = (NetworkInterface)value;
 243                 if (family == StandardProtocolFamily.INET6) {
 244                     int index = interf.getIndex();
 245                     if (index == -1)
 246                         throw new IOException(&quot;Network interface cannot be identified&quot;);
 247                     Net.setInterface6(fd, index);
 248                 } else {
 249                     // need IPv4 address to identify interface
 250                     Inet4Address target = Net.anyInet4Address(interf);
 251                     if (target == null)
 252                         throw new IOException(&quot;Network interface not configured for IPv4&quot;);
 253                     int targetAddress = Net.inet4AsInt(target);
 254                     Net.setInterface4(fd, targetAddress);
 255                 }
 256                 return this;
 257             }
 258             if (name == StandardSocketOptions.SO_REUSEADDR
 259                 &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
 260                 reuseAddressEmulated = true;
 261                 this.isReuseAddress = (Boolean)value;
 262             }
 263 
 264             // remaining options don&#39;t need any special handling
 265             Net.setSocketOption(fd, Net.UNSPEC, name, value);
 266             return this;
 267         }
 268     }
 269 
 270     @Override
 271     @SuppressWarnings(&quot;unchecked&quot;)
 272     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 273         throws IOException
 274     {
 275         Objects.requireNonNull(name);
 276         if (!supportedOptions().contains(name))
 277             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 278 
 279         synchronized (stateLock) {
 280             ensureOpen();
 281 
 282             if (name == StandardSocketOptions.IP_TOS ||
 283                 name == StandardSocketOptions.IP_MULTICAST_TTL ||
 284                 name == StandardSocketOptions.IP_MULTICAST_LOOP)
 285             {
 286                 return (T) Net.getSocketOption(fd, family, name);
 287             }
 288 
 289             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 290                 if (family == StandardProtocolFamily.INET) {
 291                     int address = Net.getInterface4(fd);
 292                     if (address == 0)
 293                         return null;    // default interface
 294 
 295                     InetAddress ia = Net.inet4FromInt(address);
 296                     NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 297                     if (ni == null)
 298                         throw new IOException(&quot;Unable to map address to interface&quot;);
 299                     return (T) ni;
 300                 } else {
 301                     int index = Net.getInterface6(fd);
 302                     if (index == 0)
 303                         return null;    // default interface
 304 
 305                     NetworkInterface ni = NetworkInterface.getByIndex(index);
 306                     if (ni == null)
 307                         throw new IOException(&quot;Unable to map index to interface&quot;);
 308                     return (T) ni;
 309                 }
 310             }
 311 
 312             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
 313                 return (T)Boolean.valueOf(isReuseAddress);
 314             }
 315 
 316             // no special handling
 317             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
 318         }
 319     }
 320 
 321     private static class DefaultOptionsHolder {
 322         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 323 
 324         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 325             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 326             set.add(StandardSocketOptions.SO_SNDBUF);
 327             set.add(StandardSocketOptions.SO_RCVBUF);
 328             set.add(StandardSocketOptions.SO_REUSEADDR);
 329             if (Net.isReusePortAvailable()) {
 330                 set.add(StandardSocketOptions.SO_REUSEPORT);
 331             }
 332             set.add(StandardSocketOptions.SO_BROADCAST);
 333             set.add(StandardSocketOptions.IP_TOS);
 334             set.add(StandardSocketOptions.IP_MULTICAST_IF);
 335             set.add(StandardSocketOptions.IP_MULTICAST_TTL);
 336             set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
 337             set.addAll(ExtendedSocketOptions.datagramSocketOptions());
 338             return Collections.unmodifiableSet(set);
 339         }
 340     }
 341 
 342     @Override
 343     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 344         return DefaultOptionsHolder.defaultOptions;
 345     }
 346 
 347     /**
 348      * Marks the beginning of a read operation that might block.
 349      *
 350      * @param blocking true if configured blocking
 351      * @param mustBeConnected true if the socket must be connected
 352      * @return remote address if connected
 353      * @throws ClosedChannelException if the channel is closed
 354      * @throws NotYetConnectedException if mustBeConnected and not connected
 355      * @throws IOException if socket not bound and cannot be bound
 356      */
 357     private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
 358         throws IOException
 359     {
 360         if (blocking) {
 361             // set hook for Thread.interrupt
 362             begin();
 363         }
 364         SocketAddress remote;
 365         synchronized (stateLock) {
 366             ensureOpen();
 367             remote = remoteAddress;
 368             if ((remote == null) &amp;&amp; mustBeConnected)
 369                 throw new NotYetConnectedException();
 370             if (localAddress == null)
 371                 bindInternal(null);
 372             if (blocking)
 373                 readerThread = NativeThread.current();
 374         }
 375         return remote;
 376     }
 377 
 378     /**
 379      * Marks the end of a read operation that may have blocked.
 380      *
 381      * @throws AsynchronousCloseException if the channel was closed asynchronously
 382      */
 383     private void endRead(boolean blocking, boolean completed)
 384         throws AsynchronousCloseException
 385     {
 386         if (blocking) {
 387             synchronized (stateLock) {
 388                 readerThread = 0;
 389                 // notify any thread waiting in implCloseSelectableChannel
 390                 if (state == ST_CLOSING) {
 391                     stateLock.notifyAll();
 392                 }
 393             }
 394             // remove hook for Thread.interrupt
 395             end(completed);
 396         }
 397     }
 398 
 399     private SocketAddress sender;       // Set by receive0 (## ugh)
 400 
 401     @Override
 402     public SocketAddress receive(ByteBuffer dst) throws IOException {
 403         if (dst.isReadOnly())
 404             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
 405 
 406         readLock.lock();
 407         try {
 408             boolean blocking = isBlocking();
 409             int n = 0;
 410             ByteBuffer bb = null;
 411             try {
 412                 SocketAddress remote = beginRead(blocking, false);
 413                 boolean connected = (remote != null);
 414                 SecurityManager sm = System.getSecurityManager();
 415                 if (connected || (sm == null)) {
 416                     // connected or no security manager
 417                     do {
 418                         n = receive(fd, dst, connected);
 419                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 420                     if (n == IOStatus.UNAVAILABLE)
 421                         return null;
 422                 } else {
 423                     // Cannot receive into user&#39;s buffer when running with a
 424                     // security manager and not connected
 425                     bb = Util.getTemporaryDirectBuffer(dst.remaining());
 426                     for (;;) {
 427                         do {
 428                             n = receive(fd, bb, connected);
 429                         } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 430                         if (n == IOStatus.UNAVAILABLE)
 431                             return null;
 432                         InetSocketAddress isa = (InetSocketAddress)sender;
 433                         try {
 434                             sm.checkAccept(isa.getAddress().getHostAddress(),
 435                                            isa.getPort());
 436                         } catch (SecurityException se) {
 437                             // Ignore packet
 438                             bb.clear();
 439                             n = 0;
 440                             continue;
 441                         }
 442                         bb.flip();
 443                         dst.put(bb);
 444                         break;
 445                     }
 446                 }
 447                 assert sender != null;
 448                 return sender;
 449             } finally {
 450                 if (bb != null)
 451                     Util.releaseTemporaryDirectBuffer(bb);
 452                 endRead(blocking, n &gt; 0);
 453                 assert IOStatus.check(n);
 454             }
 455         } finally {
 456             readLock.unlock();
 457         }
 458     }
 459 
 460     private int receive(FileDescriptor fd, ByteBuffer dst, boolean connected)
 461         throws IOException
 462     {
 463         int pos = dst.position();
 464         int lim = dst.limit();
 465         assert (pos &lt;= lim);
 466         int rem = (pos &lt;= lim ? lim - pos : 0);
 467         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
 468             return receiveIntoNativeBuffer(fd, dst, rem, pos, connected);
 469 
 470         // Substitute a native buffer. If the supplied buffer is empty
 471         // we must instead use a nonempty buffer, otherwise the call
 472         // will not block waiting for a datagram on some platforms.
 473         int newSize = Math.max(rem, 1);
 474         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 475         try {
 476             int n = receiveIntoNativeBuffer(fd, bb, newSize, 0, connected);
 477             bb.flip();
 478             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 479                 dst.put(bb);
 480             return n;
 481         } finally {
 482             Util.releaseTemporaryDirectBuffer(bb);
 483         }
 484     }
 485 
 486     private int receiveIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 487                                         int rem, int pos, boolean connected)
 488         throws IOException
 489     {
 490         int n = receive0(fd, ((DirectBuffer)bb).address() + pos, rem, connected);
 491         if (n &gt; 0)
 492             bb.position(pos + n);
 493         return n;
 494     }
 495 
 496     public int send(ByteBuffer src, SocketAddress target)
 497         throws IOException
 498     {
 499         Objects.requireNonNull(src);
 500         InetSocketAddress isa = Net.checkAddress(target, family);
 501 
 502         writeLock.lock();
 503         try {
 504             boolean blocking = isBlocking();
 505             int n = 0;
 506             try {
 507                 SocketAddress remote = beginWrite(blocking, false);
 508                 if (remote != null) {
 509                     // connected
 510                     if (!target.equals(remote)) {
 511                         throw new AlreadyConnectedException();
 512                     }
 513                     do {
 514                         n = IOUtil.write(fd, src, -1, nd);
 515                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 516                 } else {
 517                     // not connected
 518                     SecurityManager sm = System.getSecurityManager();
 519                     if (sm != null) {
 520                         InetAddress ia = isa.getAddress();
 521                         if (ia.isMulticastAddress()) {
 522                             sm.checkMulticast(ia);
 523                         } else {
 524                             sm.checkConnect(ia.getHostAddress(), isa.getPort());
 525                         }
 526                     }
 527                     do {
 528                         n = send(fd, src, isa);
 529                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 530                 }
 531             } finally {
 532                 endWrite(blocking, n &gt; 0);
 533                 assert IOStatus.check(n);
 534             }
 535             return IOStatus.normalize(n);
 536         } finally {
 537             writeLock.unlock();
 538         }
 539     }
 540 
 541     private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
 542         throws IOException
 543     {
 544         if (src instanceof DirectBuffer)
 545             return sendFromNativeBuffer(fd, src, target);
 546 
 547         // Substitute a native buffer
 548         int pos = src.position();
 549         int lim = src.limit();
 550         assert (pos &lt;= lim);
 551         int rem = (pos &lt;= lim ? lim - pos : 0);
 552 
 553         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 554         try {
 555             bb.put(src);
 556             bb.flip();
 557             // Do not update src until we see how many bytes were written
 558             src.position(pos);
 559 
 560             int n = sendFromNativeBuffer(fd, bb, target);
 561             if (n &gt; 0) {
 562                 // now update src
 563                 src.position(pos + n);
 564             }
 565             return n;
 566         } finally {
 567             Util.releaseTemporaryDirectBuffer(bb);
 568         }
 569     }
 570 
 571     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 572                                      InetSocketAddress target)
 573         throws IOException
 574     {
 575         int pos = bb.position();
 576         int lim = bb.limit();
 577         assert (pos &lt;= lim);
 578         int rem = (pos &lt;= lim ? lim - pos : 0);
 579 
 580         boolean preferIPv6 = (family != StandardProtocolFamily.INET);
 581         int written;
 582         try {
 583             written = send0(preferIPv6, fd, ((DirectBuffer)bb).address() + pos,
 584                             rem, target.getAddress(), target.getPort());
 585         } catch (PortUnreachableException pue) {
 586             if (isConnected())
 587                 throw pue;
 588             written = rem;
 589         }
 590         if (written &gt; 0)
 591             bb.position(pos + written);
 592         return written;
 593     }
 594 
 595     @Override
 596     public int read(ByteBuffer buf) throws IOException {
 597         Objects.requireNonNull(buf);
 598 
 599         readLock.lock();
 600         try {
 601             boolean blocking = isBlocking();
 602             int n = 0;
 603             try {
 604                 beginRead(blocking, true);
 605                 do {
 606                     n = IOUtil.read(fd, buf, -1, nd);
 607                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 608 
 609             } finally {
 610                 endRead(blocking, n &gt; 0);
 611                 assert IOStatus.check(n);
 612             }
 613             return IOStatus.normalize(n);
 614         } finally {
 615             readLock.unlock();
 616         }
 617     }
 618 
 619     @Override
 620     public long read(ByteBuffer[] dsts, int offset, int length)
 621         throws IOException
 622     {
 623         Objects.checkFromIndexSize(offset, length, dsts.length);
 624 
 625         readLock.lock();
 626         try {
 627             boolean blocking = isBlocking();
 628             long n = 0;
 629             try {
 630                 beginRead(blocking, true);
 631                 do {
 632                     n = IOUtil.read(fd, dsts, offset, length, nd);
 633                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 634 
 635             } finally {
 636                 endRead(blocking, n &gt; 0);
 637                 assert IOStatus.check(n);
 638             }
 639             return IOStatus.normalize(n);
 640         } finally {
 641             readLock.unlock();
 642         }
 643     }
 644 
 645     /**
 646      * Marks the beginning of a write operation that might block.
 647      * @param blocking true if configured blocking
 648      * @param mustBeConnected true if the socket must be connected
 649      * @return remote address if connected
 650      * @throws ClosedChannelException if the channel is closed
 651      * @throws NotYetConnectedException if mustBeConnected and not connected
 652      * @throws IOException if socket not bound and cannot be bound
 653      */
 654     private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
 655         throws IOException
 656     {
 657         if (blocking) {
 658             // set hook for Thread.interrupt
 659             begin();
 660         }
 661         SocketAddress remote;
 662         synchronized (stateLock) {
 663             ensureOpen();
 664             remote = remoteAddress;
 665             if ((remote == null) &amp;&amp; mustBeConnected)
 666                 throw new NotYetConnectedException();
 667             if (localAddress == null)
 668                 bindInternal(null);
 669             if (blocking)
 670                 writerThread = NativeThread.current();
 671         }
 672         return remote;
 673     }
 674 
 675     /**
 676      * Marks the end of a write operation that may have blocked.
 677      *
 678      * @throws AsynchronousCloseException if the channel was closed asynchronously
 679      */
 680     private void endWrite(boolean blocking, boolean completed)
 681         throws AsynchronousCloseException
 682     {
 683         if (blocking) {
 684             synchronized (stateLock) {
 685                 writerThread = 0;
 686                 // notify any thread waiting in implCloseSelectableChannel
 687                 if (state == ST_CLOSING) {
 688                     stateLock.notifyAll();
 689                 }
 690             }
 691             // remove hook for Thread.interrupt
 692             end(completed);
 693         }
 694     }
 695 
 696     @Override
 697     public int write(ByteBuffer buf) throws IOException {
 698         Objects.requireNonNull(buf);
 699 
 700         writeLock.lock();
 701         try {
 702             boolean blocking = isBlocking();
 703             int n = 0;
 704             try {
 705                 beginWrite(blocking, true);
 706                 do {
 707                     n = IOUtil.write(fd, buf, -1, nd);
 708                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 709             } finally {
 710                 endWrite(blocking, n &gt; 0);
 711                 assert IOStatus.check(n);
 712             }
 713             return IOStatus.normalize(n);
 714         } finally {
 715             writeLock.unlock();
 716         }
 717     }
 718 
 719     @Override
 720     public long write(ByteBuffer[] srcs, int offset, int length)
 721         throws IOException
 722     {
 723         Objects.checkFromIndexSize(offset, length, srcs.length);
 724 
 725         writeLock.lock();
 726         try {
 727             boolean blocking = isBlocking();
 728             long n = 0;
 729             try {
 730                 beginWrite(blocking, true);
 731                 do {
 732                     n = IOUtil.write(fd, srcs, offset, length, nd);
 733                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 734             } finally {
 735                 endWrite(blocking, n &gt; 0);
 736                 assert IOStatus.check(n);
 737             }
 738             return IOStatus.normalize(n);
 739         } finally {
 740             writeLock.unlock();
 741         }
 742     }
 743 
 744     @Override
 745     protected void implConfigureBlocking(boolean block) throws IOException {
 746         readLock.lock();
 747         try {
 748             writeLock.lock();
 749             try {
 750                 synchronized (stateLock) {
 751                     ensureOpen();
 752                     IOUtil.configureBlocking(fd, block);
 753                 }
 754             } finally {
 755                 writeLock.unlock();
 756             }
 757         } finally {
 758             readLock.unlock();
 759         }
 760     }
 761 
 762     InetSocketAddress localAddress() {
 763         synchronized (stateLock) {
 764             return localAddress;
 765         }
 766     }
 767 
 768     InetSocketAddress remoteAddress() {
 769         synchronized (stateLock) {
 770             return remoteAddress;
 771         }
 772     }
 773 
 774     @Override
 775     public DatagramChannel bind(SocketAddress local) throws IOException {
 776         readLock.lock();
 777         try {
 778             writeLock.lock();
 779             try {
 780                 synchronized (stateLock) {
 781                     ensureOpen();
 782                     if (localAddress != null)
 783                         throw new AlreadyBoundException();
 784                     bindInternal(local);
 785                 }
 786             } finally {
 787                 writeLock.unlock();
 788             }
 789         } finally {
 790             readLock.unlock();
 791         }
 792         return this;
 793     }
 794 
 795     private void bindInternal(SocketAddress local) throws IOException {
 796         assert Thread.holdsLock(stateLock) &amp;&amp; (localAddress == null);
 797 
 798         InetSocketAddress isa;
 799         if (local == null) {
 800             // only Inet4Address allowed with IPv4 socket
 801             if (family == StandardProtocolFamily.INET) {
 802                 isa = new InetSocketAddress(InetAddress.getByName(&quot;0.0.0.0&quot;), 0);
 803             } else {
 804                 isa = new InetSocketAddress(0);
 805             }
 806         } else {
 807             isa = Net.checkAddress(local, family);
 808         }
 809         SecurityManager sm = System.getSecurityManager();
 810         if (sm != null)
 811             sm.checkListen(isa.getPort());
 812 
 813         Net.bind(family, fd, isa.getAddress(), isa.getPort());
 814         localAddress = Net.localAddress(fd);
 815     }
 816 
 817     @Override
 818     public boolean isConnected() {
 819         synchronized (stateLock) {
 820             return (state == ST_CONNECTED);
 821         }
 822     }
 823 
 824     @Override
 825     public DatagramChannel connect(SocketAddress sa) throws IOException {
 826         InetSocketAddress isa = Net.checkAddress(sa, family);
 827         SecurityManager sm = System.getSecurityManager();
 828         if (sm != null) {
 829             InetAddress ia = isa.getAddress();
 830             if (ia.isMulticastAddress()) {
 831                 sm.checkMulticast(ia);
 832             } else {
 833                 sm.checkConnect(ia.getHostAddress(), isa.getPort());
 834                 sm.checkAccept(ia.getHostAddress(), isa.getPort());
 835             }
 836         }
 837 
 838         readLock.lock();
 839         try {
 840             writeLock.lock();
 841             try {
 842                 synchronized (stateLock) {
 843                     ensureOpen();
 844                     if (state == ST_CONNECTED)
 845                         throw new AlreadyConnectedException();
 846 
 847                     int n = Net.connect(family,
 848                                         fd,
 849                                         isa.getAddress(),
 850                                         isa.getPort());
 851                     if (n &lt;= 0)
 852                         throw new Error();      // Can&#39;t happen
 853 
 854                     // connected
 855                     remoteAddress = isa;
 856                     state = ST_CONNECTED;
 857 
 858                     // refresh local address
 859                     localAddress = Net.localAddress(fd);
 860 
 861                     // flush any packets already received.
 862                     boolean blocking = isBlocking();
 863                     if (blocking) {
 864                         IOUtil.configureBlocking(fd, false);
 865                     }
 866                     try {
 867                         ByteBuffer buf = ByteBuffer.allocate(100);
 868                         while (receive(buf) != null) {
 869                             buf.clear();
 870                         }
 871                     } finally {
 872                         if (blocking) {
 873                             IOUtil.configureBlocking(fd, true);
 874                         }
 875                     }
 876                 }
 877             } finally {
 878                 writeLock.unlock();
 879             }
 880         } finally {
 881             readLock.unlock();
 882         }
 883         return this;
 884     }
 885 
 886     @Override
 887     public DatagramChannel disconnect() throws IOException {
 888         readLock.lock();
 889         try {
 890             writeLock.lock();
 891             try {
 892                 synchronized (stateLock) {
 893                     if (!isOpen() || (state != ST_CONNECTED))
 894                         return this;
 895 
 896                     // disconnect socket
 897                     boolean isIPv6 = (family == StandardProtocolFamily.INET6);
 898                     disconnect0(fd, isIPv6);
 899 
 900                     // no longer connected
 901                     remoteAddress = null;
 902                     state = ST_UNCONNECTED;
 903 
 904                     // refresh local address
 905                     localAddress = Net.localAddress(fd);
 906                 }
 907             } finally {
 908                 writeLock.unlock();
 909             }
 910         } finally {
 911             readLock.unlock();
 912         }
 913         return this;
 914     }
 915 
 916     /**
 917      * Joins channel&#39;s socket to the given group/interface and
 918      * optional source address.
 919      */
 920     private MembershipKey innerJoin(InetAddress group,
 921                                     NetworkInterface interf,
 922                                     InetAddress source)
 923         throws IOException
 924     {
 925         if (!group.isMulticastAddress())
 926             throw new IllegalArgumentException(&quot;Group not a multicast address&quot;);
 927 
 928         // check multicast address is compatible with this socket
 929         if (group instanceof Inet4Address) {
 930             if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.canIPv6SocketJoinIPv4Group())
 931                 throw new IllegalArgumentException(&quot;IPv6 socket cannot join IPv4 multicast group&quot;);
 932         } else if (group instanceof Inet6Address) {
 933             if (family != StandardProtocolFamily.INET6)
 934                 throw new IllegalArgumentException(&quot;Only IPv6 sockets can join IPv6 multicast group&quot;);
 935         } else {
 936             throw new IllegalArgumentException(&quot;Address type not supported&quot;);
 937         }
 938 
 939         // check source address
 940         if (source != null) {
 941             if (source.isAnyLocalAddress())
 942                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
 943             if (source.isMulticastAddress())
 944                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
 945             if (source.getClass() != group.getClass())
 946                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
 947         }
 948 
 949         SecurityManager sm = System.getSecurityManager();
 950         if (sm != null)
 951             sm.checkMulticast(group);
 952 
 953         synchronized (stateLock) {
 954             ensureOpen();
 955 
 956             // check the registry to see if we are already a member of the group
 957             if (registry == null) {
 958                 registry = new MembershipRegistry();
 959             } else {
 960                 // return existing membership key
 961                 MembershipKey key = registry.checkMembership(group, interf, source);
 962                 if (key != null)
 963                     return key;
 964             }
 965 
 966             MembershipKeyImpl key;
 967             if ((family == StandardProtocolFamily.INET6) &amp;&amp;
 968                 ((group instanceof Inet6Address) || Net.canJoin6WithIPv4Group()))
 969             {
 970                 int index = interf.getIndex();
 971                 if (index == -1)
 972                     throw new IOException(&quot;Network interface cannot be identified&quot;);
 973 
 974                 // need multicast and source address as byte arrays
 975                 byte[] groupAddress = Net.inet6AsByteArray(group);
 976                 byte[] sourceAddress = (source == null) ? null :
 977                     Net.inet6AsByteArray(source);
 978 
 979                 // join the group
 980                 int n = Net.join6(fd, groupAddress, index, sourceAddress);
 981                 if (n == IOStatus.UNAVAILABLE)
 982                     throw new UnsupportedOperationException();
 983 
 984                 key = new MembershipKeyImpl.Type6(this, group, interf, source,
 985                                                   groupAddress, index, sourceAddress);
 986 
 987             } else {
 988                 // need IPv4 address to identify interface
 989                 Inet4Address target = Net.anyInet4Address(interf);
 990                 if (target == null)
 991                     throw new IOException(&quot;Network interface not configured for IPv4&quot;);
 992 
 993                 int groupAddress = Net.inet4AsInt(group);
 994                 int targetAddress = Net.inet4AsInt(target);
 995                 int sourceAddress = (source == null) ? 0 : Net.inet4AsInt(source);
 996 
 997                 // join the group
 998                 int n = Net.join4(fd, groupAddress, targetAddress, sourceAddress);
 999                 if (n == IOStatus.UNAVAILABLE)
1000                     throw new UnsupportedOperationException();
1001 
1002                 key = new MembershipKeyImpl.Type4(this, group, interf, source,
1003                                                   groupAddress, targetAddress, sourceAddress);
1004             }
1005 
1006             registry.add(key);
1007             return key;
1008         }
1009     }
1010 
1011     @Override
1012     public MembershipKey join(InetAddress group,
1013                               NetworkInterface interf)
1014         throws IOException
1015     {
1016         return innerJoin(group, interf, null);
1017     }
1018 
1019     @Override
1020     public MembershipKey join(InetAddress group,
1021                               NetworkInterface interf,
1022                               InetAddress source)
1023         throws IOException
1024     {
1025         Objects.requireNonNull(source);
1026         return innerJoin(group, interf, source);
1027     }
1028 
1029     // package-private
1030     void drop(MembershipKeyImpl key) {
1031         assert key.channel() == this;
1032 
1033         synchronized (stateLock) {
1034             if (!key.isValid())
1035                 return;
1036 
1037             try {
1038                 if (key instanceof MembershipKeyImpl.Type6) {
1039                     MembershipKeyImpl.Type6 key6 =
1040                         (MembershipKeyImpl.Type6)key;
1041                     Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
1042                 } else {
1043                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
1044                     Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
1045                         key4.source());
1046                 }
1047             } catch (IOException ioe) {
1048                 // should not happen
1049                 throw new AssertionError(ioe);
1050             }
1051 
1052             key.invalidate();
1053             registry.remove(key);
1054         }
1055     }
1056 
1057     /**
1058      * Block datagrams from given source if a memory to receive all
1059      * datagrams.
1060      */
1061     void block(MembershipKeyImpl key, InetAddress source)
1062         throws IOException
1063     {
1064         assert key.channel() == this;
1065         assert key.sourceAddress() == null;
1066 
1067         synchronized (stateLock) {
1068             if (!key.isValid())
1069                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1070             if (source.isAnyLocalAddress())
1071                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1072             if (source.isMulticastAddress())
1073                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1074             if (source.getClass() != key.group().getClass())
1075                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1076 
1077             int n;
1078             if (key instanceof MembershipKeyImpl.Type6) {
1079                  MembershipKeyImpl.Type6 key6 =
1080                     (MembershipKeyImpl.Type6)key;
1081                 n = Net.block6(fd, key6.groupAddress(), key6.index(),
1082                                Net.inet6AsByteArray(source));
1083             } else {
1084                 MembershipKeyImpl.Type4 key4 =
1085                     (MembershipKeyImpl.Type4)key;
1086                 n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
1087                                Net.inet4AsInt(source));
1088             }
1089             if (n == IOStatus.UNAVAILABLE) {
1090                 // ancient kernel
1091                 throw new UnsupportedOperationException();
1092             }
1093         }
1094     }
1095 
1096     /**
1097      * Unblock given source.
1098      */
1099     void unblock(MembershipKeyImpl key, InetAddress source) {
1100         assert key.channel() == this;
1101         assert key.sourceAddress() == null;
1102 
1103         synchronized (stateLock) {
1104             if (!key.isValid())
1105                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1106 
1107             try {
1108                 if (key instanceof MembershipKeyImpl.Type6) {
1109                     MembershipKeyImpl.Type6 key6 =
1110                         (MembershipKeyImpl.Type6)key;
1111                     Net.unblock6(fd, key6.groupAddress(), key6.index(),
1112                                  Net.inet6AsByteArray(source));
1113                 } else {
1114                     MembershipKeyImpl.Type4 key4 =
1115                         (MembershipKeyImpl.Type4)key;
1116                     Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
1117                                  Net.inet4AsInt(source));
1118                 }
1119             } catch (IOException ioe) {
1120                 // should not happen
1121                 throw new AssertionError(ioe);
1122             }
1123         }
1124     }
1125 
1126     /**
1127      * Invoked by implCloseChannel to close the channel.
1128      *
1129      * This method waits for outstanding I/O operations to complete. When in
1130      * blocking mode, the socket is pre-closed and the threads in blocking I/O
1131      * operations are signalled to ensure that the outstanding I/O operations
1132      * complete quickly.
1133      *
1134      * The socket is closed by this method when it is not registered with a
1135      * Selector. Note that a channel configured blocking may be registered with
1136      * a Selector. This arises when a key is canceled and the channel configured
1137      * to blocking mode before the key is flushed from the Selector.
1138      */
1139     @Override
1140     protected void implCloseSelectableChannel() throws IOException {
1141         assert !isOpen();
1142 
1143         boolean blocking;
1144         boolean interrupted = false;
1145 
1146         // set state to ST_CLOSING and invalid membership keys
1147         synchronized (stateLock) {
1148             assert state &lt; ST_CLOSING;
1149             blocking = isBlocking();
1150             state = ST_CLOSING;
1151 
1152             // if member of any multicast groups then invalidate the keys
1153             if (registry != null)
1154                 registry.invalidateAll();
1155         }
1156 
1157         // wait for any outstanding I/O operations to complete
1158         if (blocking) {
1159             synchronized (stateLock) {
1160                 assert state == ST_CLOSING;
1161                 long reader = readerThread;
1162                 long writer = writerThread;
1163                 if (reader != 0 || writer != 0) {
1164                     nd.preClose(fd);
1165 
1166                     if (reader != 0)
1167                         NativeThread.signal(reader);
1168                     if (writer != 0)
1169                         NativeThread.signal(writer);
1170 
1171                     // wait for blocking I/O operations to end
1172                     while (readerThread != 0 || writerThread != 0) {
1173                         try {
1174                             stateLock.wait();
1175                         } catch (InterruptedException e) {
1176                             interrupted = true;
1177                         }
1178                     }
1179                 }
1180             }
1181         } else {
1182             // non-blocking mode: wait for read/write to complete
1183             readLock.lock();
1184             try {
1185                 writeLock.lock();
1186                 writeLock.unlock();
1187             } finally {
1188                 readLock.unlock();
1189             }
1190         }
1191 
1192         // set state to ST_KILLPENDING
1193         synchronized (stateLock) {
1194             assert state == ST_CLOSING;
1195             state = ST_KILLPENDING;
1196         }
1197 
1198         // close socket if not registered with Selector
1199         if (!isRegistered())
1200             kill();
1201 
1202         // restore interrupt status
1203         if (interrupted)
1204             Thread.currentThread().interrupt();
1205     }
1206 
1207     @Override
1208     public void kill() throws IOException {
1209         synchronized (stateLock) {
1210             if (state == ST_KILLPENDING) {
1211                 state = ST_KILLED;
1212                 try {
1213                     nd.close(fd);
1214                 } finally {
1215                     // notify resource manager
1216                     ResourceManager.afterUdpClose();
1217                 }
1218             }
1219         }
1220     }
1221 
1222     @SuppressWarnings(&quot;deprecation&quot;)
1223     protected void finalize() throws IOException {
1224         // fd is null if constructor threw exception
1225         if (fd != null)
1226             close();
1227     }
1228 
1229     /**
1230      * Translates native poll revent set into a ready operation set
1231      */
1232     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1233         int intOps = ski.nioInterestOps();
1234         int oldOps = ski.nioReadyOps();
1235         int newOps = initialOps;
1236 
1237         if ((ops &amp; Net.POLLNVAL) != 0) {
1238             // This should only happen if this channel is pre-closed while a
1239             // selection operation is in progress
1240             // ## Throw an error if this channel has not been pre-closed
1241             return false;
1242         }
1243 
1244         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1245             newOps = intOps;
1246             ski.nioReadyOps(newOps);
1247             return (newOps &amp; ~oldOps) != 0;
1248         }
1249 
1250         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1251             ((intOps &amp; SelectionKey.OP_READ) != 0))
1252             newOps |= SelectionKey.OP_READ;
1253 
1254         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1255             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
1256             newOps |= SelectionKey.OP_WRITE;
1257 
1258         ski.nioReadyOps(newOps);
1259         return (newOps &amp; ~oldOps) != 0;
1260     }
1261 
1262     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1263         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1264     }
1265 
1266     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1267         return translateReadyOps(ops, 0, ski);
1268     }
1269 
1270     /**
1271      * Poll this channel&#39;s socket for reading up to the given timeout.
1272      * @return {@code true} if the socket is polled
1273      */
1274     boolean pollRead(long timeout) throws IOException {
1275         boolean blocking = isBlocking();
1276         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;
1277 
1278         readLock.lock();
1279         try {
1280             boolean polled = false;
1281             try {
1282                 beginRead(blocking, false);
1283                 int events = Net.poll(fd, Net.POLLIN, timeout);
1284                 polled = (events != 0);
1285             } finally {
1286                 endRead(blocking, polled);
1287             }
1288             return polled;
1289         } finally {
1290             readLock.unlock();
1291         }
1292     }
1293 
1294     /**
1295      * Translates an interest operation set into a native poll event set
1296      */
1297     public int translateInterestOps(int ops) {
1298         int newOps = 0;
1299         if ((ops &amp; SelectionKey.OP_READ) != 0)
1300             newOps |= Net.POLLIN;
1301         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1302             newOps |= Net.POLLOUT;
1303         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1304             newOps |= Net.POLLIN;
1305         return newOps;
1306     }
1307 
1308     public FileDescriptor getFD() {
1309         return fd;
1310     }
1311 
1312     public int getFDVal() {
1313         return fdVal;
1314     }
1315 
1316 
1317     // -- Native methods --
1318 
1319     private static native void initIDs();
1320 
1321     private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
1322         throws IOException;
1323 
1324     private native int receive0(FileDescriptor fd, long address, int len,
1325                                 boolean connected)
1326         throws IOException;
1327 
1328     private native int send0(boolean preferIPv6, FileDescriptor fd, long address,
1329                              int len, InetAddress addr, int port)
1330         throws IOException;
1331 
1332     static {
1333         IOUtil.load();
1334         initIDs();
1335     }
1336 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.AccessControlContext;
 29 import java.security.AccessController;
 30 import java.security.AlgorithmConstraints;
 31 import java.security.NoSuchAlgorithmException;
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.Collection;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.List;
 38 import java.util.function.BiFunction;
 39 import javax.crypto.KeyGenerator;
 40 import javax.net.ssl.HandshakeCompletedListener;
 41 import javax.net.ssl.SNIMatcher;
 42 import javax.net.ssl.SNIServerName;
 43 import javax.net.ssl.SSLEngine;
 44 import javax.net.ssl.SSLParameters;
 45 import javax.net.ssl.SSLSocket;
 46 import sun.security.ssl.SSLExtension.ClientExtensions;
 47 import sun.security.ssl.SSLExtension.ServerExtensions;
 48 
 49 /**
 50  * SSL/(D)TLS configuration.
 51  */
 52 final class SSLConfiguration implements Cloneable {
 53     // configurations with SSLParameters
 54     AlgorithmConstraints        algorithmConstraints;
 55     List&lt;ProtocolVersion&gt;       enabledProtocols;
 56     List&lt;CipherSuite&gt;           enabledCipherSuites;
 57     ClientAuthType              clientAuthType;
 58     String                      identificationProtocol;
 59     List&lt;SNIServerName&gt;         serverNames;
 60     Collection&lt;SNIMatcher&gt;      sniMatchers;
 61     String[]                    applicationProtocols;
 62     boolean                     preferLocalCipherSuites;
 63     boolean                     enableRetransmissions;
 64     int                         maximumPacketSize;
 65 
 66     // the maximum protocol version of enabled protocols
 67     ProtocolVersion             maximumProtocolVersion;
 68 
 69     // Configurations per SSLSocket or SSLEngine instance.
 70     boolean                     isClientMode;
 71     boolean                     enableSessionCreation;
 72 
 73     // the application layer protocol negotiation configuration
 74     BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; socketAPSelector;
 75     BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; engineAPSelector;
 76 
 77     HashMap&lt;HandshakeCompletedListener, AccessControlContext&gt;
 78                                 handshakeListeners;
 79 
 80     boolean                     noSniExtension;
 81     boolean                     noSniMatcher;
 82 
 83     // To switch off the extended_master_secret extension.
 84     static final boolean useExtendedMasterSecret;
 85 
 86     // Allow session resumption without Extended Master Secret extension.
 87     static final boolean allowLegacyResumption =
 88         Utilities.getBooleanProperty(&quot;jdk.tls.allowLegacyResumption&quot;, true);
 89 
 90     // Allow full handshake without Extended Master Secret extension.
 91     static final boolean allowLegacyMasterSecret =
 92         Utilities.getBooleanProperty(&quot;jdk.tls.allowLegacyMasterSecret&quot;, true);
 93 
 94     // Allow full handshake without Extended Master Secret extension.
 95     static final boolean useCompatibilityMode = Utilities.getBooleanProperty(
 96             &quot;jdk.tls.client.useCompatibilityMode&quot;, true);
 97 
 98     // Respond a close_notify alert if receiving close_notify alert.
 99     static final boolean acknowledgeCloseNotify  = Utilities.getBooleanProperty(
100             &quot;jdk.tls.acknowledgeCloseNotify&quot;, false);
101 
102     // Is the extended_master_secret extension supported?
103     static {
104         boolean supportExtendedMasterSecret = Utilities.getBooleanProperty(
105                     &quot;jdk.tls.useExtendedMasterSecret&quot;, true);
106         if (supportExtendedMasterSecret) {
107             try {
108                 KeyGenerator.getInstance(&quot;SunTlsExtendedMasterSecret&quot;);
109             } catch (NoSuchAlgorithmException nae) {
110                 supportExtendedMasterSecret = false;
111             }
112         }
113         useExtendedMasterSecret = supportExtendedMasterSecret;
114     }
115 
116     SSLConfiguration(SSLContextImpl sslContext, boolean isClientMode) {
117 
118         // Configurations with SSLParameters, default values.
119         this.algorithmConstraints = SSLAlgorithmConstraints.DEFAULT;
120         this.enabledProtocols =
121                 sslContext.getDefaultProtocolVersions(!isClientMode);
122         this.enabledCipherSuites =
123                 sslContext.getDefaultCipherSuites(!isClientMode);
124         this.clientAuthType = ClientAuthType.CLIENT_AUTH_NONE;
125 
126         this.identificationProtocol = null;
127         this.serverNames = Collections.&lt;SNIServerName&gt;emptyList();
128         this.sniMatchers = Collections.&lt;SNIMatcher&gt;emptyList();
129         this.preferLocalCipherSuites = true;
130 
131         this.applicationProtocols = new String[0];
132         this.enableRetransmissions = sslContext.isDTLS();
133         this.maximumPacketSize = 0;         // please reset it explicitly later
134 
135         this.maximumProtocolVersion = ProtocolVersion.NONE;
136         for (ProtocolVersion pv : enabledProtocols) {
137             if (pv.compareTo(maximumProtocolVersion) &gt; 0) {
138                 this.maximumProtocolVersion = pv;
139             }
140         }
141 
142         // Configurations per SSLSocket or SSLEngine instance.
143         this.isClientMode = isClientMode;
144         this.enableSessionCreation = true;
145         this.socketAPSelector = null;
146         this.engineAPSelector = null;
147 
148         this.handshakeListeners = null;
149         this.noSniExtension = false;
150         this.noSniMatcher = false;
151     }
152 
153     SSLParameters getSSLParameters() {
154         SSLParameters params = new SSLParameters();
155 
156         params.setAlgorithmConstraints(this.algorithmConstraints);
157         params.setProtocols(ProtocolVersion.toStringArray(enabledProtocols));
158         params.setCipherSuites(CipherSuite.namesOf(enabledCipherSuites));
159         switch (this.clientAuthType) {
160             case CLIENT_AUTH_REQUIRED:
161                 params.setNeedClientAuth(true);
162                 break;
163             case CLIENT_AUTH_REQUESTED:
164                 params.setWantClientAuth(true);
165                 break;
166             default:
167                 params.setWantClientAuth(false);
168         }
169         params.setEndpointIdentificationAlgorithm(this.identificationProtocol);
170 
171         if (serverNames.isEmpty() &amp;&amp; !noSniExtension) {
172             // &#39;null&#39; indicates none has been set
173             params.setServerNames(null);
174         } else {
175             params.setServerNames(this.serverNames);
176         }
177 
178         if (sniMatchers.isEmpty() &amp;&amp; !noSniMatcher) {
179             // &#39;null&#39; indicates none has been set
180             params.setSNIMatchers(null);
181         } else {
182             params.setSNIMatchers(this.sniMatchers);
183         }
184 
185         params.setApplicationProtocols(this.applicationProtocols);
186         params.setUseCipherSuitesOrder(this.preferLocalCipherSuites);
187         params.setEnableRetransmissions(this.enableRetransmissions);
188         params.setMaximumPacketSize(this.maximumPacketSize);
189 
190         return params;
191     }
192 
193     void setSSLParameters(SSLParameters params) {
194         AlgorithmConstraints ac = params.getAlgorithmConstraints();
195         if (ac != null) {
196             this.algorithmConstraints = ac;
197         }   // otherwise, use the default value
198 
199         String[] sa = params.getCipherSuites();
200         if (sa != null) {
201             this.enabledCipherSuites = CipherSuite.validValuesOf(sa);
202         }   // otherwise, use the default values
203 
204         sa = params.getProtocols();
205         if (sa != null) {
206             this.enabledProtocols = ProtocolVersion.namesOf(sa);
207 
208             this.maximumProtocolVersion = ProtocolVersion.NONE;
209             for (ProtocolVersion pv : enabledProtocols) {
210                 if (pv.compareTo(maximumProtocolVersion) &gt; 0) {
211                     this.maximumProtocolVersion = pv;
212                 }
213             }
214         }   // otherwise, use the default values
215 
216         if (params.getNeedClientAuth()) {
217             this.clientAuthType = ClientAuthType.CLIENT_AUTH_REQUIRED;
218         } else if (params.getWantClientAuth()) {
219             this.clientAuthType = ClientAuthType.CLIENT_AUTH_REQUESTED;
220         } else {
221             this.clientAuthType = ClientAuthType.CLIENT_AUTH_NONE;
222         }
223 
224         String s = params.getEndpointIdentificationAlgorithm();
225         if (s != null) {
226             this.identificationProtocol = s;
227         }   // otherwise, use the default value
228 
229         List&lt;SNIServerName&gt; sniNames = params.getServerNames();
230         if (sniNames != null) {
231             this.noSniExtension = sniNames.isEmpty();
232             this.serverNames = sniNames;
233         }   // null if none has been set
234 
235         Collection&lt;SNIMatcher&gt; matchers = params.getSNIMatchers();
236         if (matchers != null) {
237             this.noSniMatcher = matchers.isEmpty();
238             this.sniMatchers = matchers;
239         }   // null if none has been set
240 
241         sa = params.getApplicationProtocols();
242         if (sa != null) {
243             this.applicationProtocols = sa;
244         }   // otherwise, use the default values
245 
246         this.preferLocalCipherSuites = params.getUseCipherSuitesOrder();
247         this.enableRetransmissions = params.getEnableRetransmissions();
248         this.maximumPacketSize = params.getMaximumPacketSize();
249     }
250 
251     // SSLSocket only
252     void addHandshakeCompletedListener(
253             HandshakeCompletedListener listener) {
254 
255         if (handshakeListeners == null) {
256             handshakeListeners = new HashMap&lt;&gt;(4);
257         }
258 
259         handshakeListeners.put(listener, AccessController.getContext());
260     }
261 
262     // SSLSocket only
263     void removeHandshakeCompletedListener(
264             HandshakeCompletedListener listener) {
265 
266         if (handshakeListeners == null) {
267             throw new IllegalArgumentException(&quot;no listeners&quot;);
268         }
269 
270         if (handshakeListeners.remove(listener) == null) {
271             throw new IllegalArgumentException(&quot;listener not registered&quot;);
272         }
273 
274         if (handshakeListeners.isEmpty()) {
275             handshakeListeners = null;
276         }
277     }
278 
279     /**
280      * Return true if the extension is available.
281      */
282     boolean isAvailable(SSLExtension extension) {
283         for (ProtocolVersion protocolVersion : enabledProtocols) {
284             if (extension.isAvailable(protocolVersion)) {
285                 if (isClientMode ?
286                         ClientExtensions.defaults.contains(extension) :
287                         ServerExtensions.defaults.contains(extension)) {
288                     return true;
289                 }
290             }
291         }
292 
293         return false;
294     }
295 
296     /**
297      * Return true if the extension is available for the specific protocol.
298      */
299     boolean isAvailable(SSLExtension extension,
300             ProtocolVersion protocolVersion) {
301         return extension.isAvailable(protocolVersion) &amp;&amp;
302                 (isClientMode ? ClientExtensions.defaults.contains(extension) :
303                                 ServerExtensions.defaults.contains(extension));
304     }
305 
306     /**
307      * Get the enabled extensions for the specific handshake message.
308      *
309      * Used to consume handshake extensions.
310      */
311     SSLExtension[] getEnabledExtensions(SSLHandshake handshakeType) {
312         List&lt;SSLExtension&gt; extensions = new ArrayList&lt;&gt;();
313         for (SSLExtension extension : SSLExtension.values()) {
314             if (extension.handshakeType == handshakeType) {
315                 if (isAvailable(extension)) {
316                     extensions.add(extension);
317                 }
318             }
319         }
320 
321         return extensions.toArray(new SSLExtension[0]);
322     }
323 
324     /**
325      * Get the enabled extensions for the specific handshake message, excluding
326      * the specified extensions.
327      *
328      * Used to consume handshake extensions.
329      */
330     SSLExtension[] getExclusiveExtensions(SSLHandshake handshakeType,
331             List&lt;SSLExtension&gt; excluded) {
332         List&lt;SSLExtension&gt; extensions = new ArrayList&lt;&gt;();
333         for (SSLExtension extension : SSLExtension.values()) {
334             if (extension.handshakeType == handshakeType) {
335                 if (isAvailable(extension) &amp;&amp; !excluded.contains(extension)) {
336                     extensions.add(extension);
337                 }
338             }
339         }
340 
341         return extensions.toArray(new SSLExtension[0]);
342     }
343 
344     /**
345      * Get the enabled extensions for the specific handshake message
346      * and the specific protocol version.
347      *
348      * Used to produce handshake extensions after handshake protocol
349      * version negotiation.
350      */
351     SSLExtension[] getEnabledExtensions(
352             SSLHandshake handshakeType, ProtocolVersion protocolVersion) {
353         return getEnabledExtensions(
354             handshakeType, Arrays.asList(protocolVersion));
355     }
356 
357     /**
358      * Get the enabled extensions for the specific handshake message
359      * and the specific protocol versions.
360      *
361      * Used to produce ClientHello extensions before handshake protocol
362      * version negotiation.
363      */
364     SSLExtension[] getEnabledExtensions(
365             SSLHandshake handshakeType, List&lt;ProtocolVersion&gt; activeProtocols) {
366         List&lt;SSLExtension&gt; extensions = new ArrayList&lt;&gt;();
367         for (SSLExtension extension : SSLExtension.values()) {
368             if (extension.handshakeType == handshakeType) {
369                 if (!isAvailable(extension)) {
370                     continue;
371                 }
372 
373                 for (ProtocolVersion protocolVersion : activeProtocols) {
374                     if (extension.isAvailable(protocolVersion)) {
375                         extensions.add(extension);
376                         break;
377                     }
378                 }
379             }
380         }
381 
382         return extensions.toArray(new SSLExtension[0]);
383     }
384 
385     @Override
386     @SuppressWarnings({&quot;unchecked&quot;, &quot;CloneDeclaresCloneNotSupported&quot;})
387     public Object clone() {
388         // Note that only references to the configurations are copied.
389         try {
390             SSLConfiguration config = (SSLConfiguration)super.clone();
391             if (handshakeListeners != null) {
392                 config.handshakeListeners =
393                     (HashMap&lt;HandshakeCompletedListener, AccessControlContext&gt;)
394                             handshakeListeners.clone();
395             }
396 
397             return config;
398         } catch (CloneNotSupportedException cnse) {
399             // unlikely
400         }
401 
402         return null;    // unlikely
403     }
404 }
    </pre>
  </body>
</html>
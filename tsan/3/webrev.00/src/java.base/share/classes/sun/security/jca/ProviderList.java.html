<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/jca/ProviderList.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.jca;
 27 
 28 import java.util.*;
 29 
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.security.Provider;
 33 import java.security.Provider.Service;
 34 import java.security.Security;
 35 
 36 /**
 37  * List of Providers. Used to represent the provider preferences.
 38  *
 39  * The system starts out with a ProviderList that only has the names
 40  * of the Providers.
 41  * When using ServiceLoader to load the providers, Providers are created
 42  * semi-eagerly as we iterate through them looking for a match.
 43  *
 44  * For compatibility reasons, Providers that could not be loaded are ignored
 45  * and internally presented as the instance EMPTY_PROVIDER. However, those
 46  * objects cannot be presented to applications. Call the convert() method
 47  * to force all Providers to be loaded and to obtain a ProviderList with
 48  * invalid entries removed. All this is handled by the Security class.
 49  *
 50  * Note that all indices used by this class are 0-based per general Java
 51  * convention. These must be converted to the 1-based indices used by the
 52  * Security class externally when needed.
 53  *
 54  * Instances of this class are immutable. This eliminates the need for
 55  * cloning and synchronization in consumers. The add() and remove() style
 56  * methods are static in order to avoid confusion about the immutability.
 57  *
 58  * @author  Andreas Sterbenz
 59  * @since   1.5
 60  */
 61 public final class ProviderList {
 62 
 63     static final sun.security.util.Debug debug =
 64         sun.security.util.Debug.getInstance(&quot;jca&quot;, &quot;ProviderList&quot;);
 65 
 66     private static final ProviderConfig[] PC0 = new ProviderConfig[0];
 67 
 68     private static final Provider[] P0 = new Provider[0];
 69 
 70     // constant for an ProviderList with no elements
 71     static final ProviderList EMPTY = new ProviderList(PC0, true);
 72 
 73     // list of all jdk.security.provider.preferred entries
 74     static private PreferredList preferredPropList = null;
 75 
 76     // dummy provider object to use during initialization
 77     // used to avoid explicit null checks in various places
 78     private static final Provider EMPTY_PROVIDER =
 79         new Provider(&quot;##Empty##&quot;, &quot;1.0&quot;, &quot;initialization in progress&quot;) {
 80             @java.io.Serial
 81             private static final long serialVersionUID = 1151354171352296389L;
 82             // override getService() to return null slightly faster
 83             public Service getService(String type, String algorithm) {
 84                 return null;
 85             }
 86         };
 87 
 88     // construct a ProviderList from the security properties
 89     // (static provider configuration in the java.security file)
 90     static ProviderList fromSecurityProperties() {
 91         // doPrivileged() because of Security.getProperty()
 92         return AccessController.doPrivileged(
 93                         new PrivilegedAction&lt;ProviderList&gt;() {
 94             public ProviderList run() {
 95                 return new ProviderList();
 96             }
 97         });
 98     }
 99 
100     public static ProviderList add(ProviderList providerList, Provider p) {
101         return insertAt(providerList, p, -1);
102     }
103 
104     public static ProviderList insertAt(ProviderList providerList, Provider p,
105             int position) {
106         if (providerList.getProvider(p.getName()) != null) {
107             return providerList;
108         }
109         List&lt;ProviderConfig&gt; list = new ArrayList&lt;&gt;
110                                     (Arrays.asList(providerList.configs));
111         int n = list.size();
112         if ((position &lt; 0) || (position &gt; n)) {
113             position = n;
114         }
115         list.add(position, new ProviderConfig(p));
116         return new ProviderList(list.toArray(PC0), true);
117     }
118 
119     public static ProviderList remove(ProviderList providerList, String name) {
120         // make sure provider exists
121         if (providerList.getProvider(name) == null) {
122             return providerList;
123         }
124         // copy all except matching to new list
125         ProviderConfig[] configs = new ProviderConfig[providerList.size() - 1];
126         int j = 0;
127         for (ProviderConfig config : providerList.configs) {
128             if (config.getProvider().getName().equals(name) == false) {
129                 configs[j++] = config;
130             }
131         }
132         return new ProviderList(configs, true);
133     }
134 
135     // Create a new ProviderList from the specified Providers.
136     // This method is for use by SunJSSE.
137     public static ProviderList newList(Provider ... providers) {
138         ProviderConfig[] configs = new ProviderConfig[providers.length];
139         for (int i = 0; i &lt; providers.length; i++) {
140             configs[i] = new ProviderConfig(providers[i]);
141         }
142         return new ProviderList(configs, true);
143     }
144 
145     // configuration of the providers
146     private final ProviderConfig[] configs;
147 
148     // flag indicating whether all configs have been loaded successfully
149     private volatile boolean allLoaded;
150 
151     // List returned by providers()
152     private final List&lt;Provider&gt; userList = new AbstractList&lt;Provider&gt;() {
153         public int size() {
154             return configs.length;
155         }
156         public Provider get(int index) {
157             return getProvider(index);
158         }
159     };
160 
161     /**
162      * Create a new ProviderList from an array of configs
163      */
164     private ProviderList(ProviderConfig[] configs, boolean allLoaded) {
165         this.configs = configs;
166         this.allLoaded = allLoaded;
167     }
168 
169     /**
170      * Return a new ProviderList parsed from the java.security Properties.
171      */
172     private ProviderList() {
173         List&lt;ProviderConfig&gt; configList = new ArrayList&lt;&gt;();
174         String entry;
175         int i = 1;
176 
177         while ((entry = Security.getProperty(&quot;security.provider.&quot; + i)) != null) {
178             entry = entry.trim();
179             if (entry.isEmpty()) {
180                 System.err.println(&quot;invalid entry for &quot; +
181                                    &quot;security.provider.&quot; + i);
182                 break;
183             }
184             int k = entry.indexOf(&#39; &#39;);
185             ProviderConfig config;
186             if (k == -1) {
187                 config = new ProviderConfig(entry);
188             } else {
189                 String provName = entry.substring(0, k);
190                 String argument = entry.substring(k + 1).trim();
191                 config = new ProviderConfig(provName, argument);
192             }
193 
194             // Get rid of duplicate providers.
195             if (configList.contains(config) == false) {
196                 configList.add(config);
197             }
198             i++;
199         }
200         configs = configList.toArray(PC0);
201 
202         // Load config entries for use when getInstance is called
203         entry = Security.getProperty(&quot;jdk.security.provider.preferred&quot;);
204         if (entry != null &amp;&amp; !(entry = entry.trim()).isEmpty()) {
205             String[] entries = entry.split(&quot;,&quot;);
206             if (ProviderList.preferredPropList == null) {
207                 ProviderList.preferredPropList = new PreferredList();
208             }
209 
210             for (String e : entries) {
211                 i = e.indexOf(&#39;:&#39;);
212                 if (i &lt; 0) {
213                     if (debug != null) {
214                         debug.println(&quot;invalid preferred entry skipped.  &quot; +
215                                 &quot;Missing colon delimiter \&quot;&quot; + e + &quot;\&quot;&quot;);
216                     }
217                     continue;
218                 }
219                 ProviderList.preferredPropList.add(new PreferredEntry(
220                         e.substring(0, i).trim(), e.substring(i + 1).trim()));
221             }
222         }
223 
224         if (debug != null) {
225             debug.println(&quot;provider configuration: &quot; + configList);
226             debug.println(&quot;config configuration: &quot; +
227                     ProviderList.preferredPropList);
228         }
229     }
230 
231     /**
232      * Construct a special ProviderList for JAR verification. It consists
233      * of the providers specified via jarClassNames, which must be on the
234      * bootclasspath and cannot be in signed JAR files. This is to avoid
235      * possible recursion and deadlock during verification.
236      */
237     ProviderList getJarList(String[] jarProvNames) {
238         List&lt;ProviderConfig&gt; newConfigs = new ArrayList&lt;&gt;();
239         for (String provName : jarProvNames) {
240             ProviderConfig newConfig = new ProviderConfig(provName);
241             for (ProviderConfig config : configs) {
242                 // if the equivalent object is present in this provider list,
243                 // use the old object rather than the new object.
244                 // this ensures that when the provider is loaded in the
245                 // new thread local list, it will also become available
246                 // in this provider list
247                 if (config.equals(newConfig)) {
248                     newConfig = config;
249                     break;
250                 }
251             }
252             newConfigs.add(newConfig);
253         }
254         ProviderConfig[] configArray = newConfigs.toArray(PC0);
255         return new ProviderList(configArray, false);
256     }
257 
258     public int size() {
259         return configs.length;
260     }
261 
262     /**
263      * Return the Provider at the specified index. Returns EMPTY_PROVIDER
264      * if the provider could not be loaded at this time.
265      */
266     Provider getProvider(int index) {
267         Provider p = configs[index].getProvider();
268         return (p != null) ? p : EMPTY_PROVIDER;
269     }
270 
271     /**
272      * Return an unmodifiable List of all Providers in this List. The
273      * individual Providers are loaded on demand. Elements that could not
274      * be initialized are replaced with EMPTY_PROVIDER.
275      */
276     public List&lt;Provider&gt; providers() {
277         return userList;
278     }
279 
280     private ProviderConfig getProviderConfig(String name) {
281         int index = getIndex(name);
282         return (index != -1) ? configs[index] : null;
283     }
284 
285     // return the Provider with the specified name or null
286     public Provider getProvider(String name) {
287         ProviderConfig config = getProviderConfig(name);
288         return (config == null) ? null : config.getProvider();
289     }
290 
291     /**
292      * Return the index at which the provider with the specified name is
293      * installed or -1 if it is not present in this ProviderList.
294      */
295     public int getIndex(String name) {
296         for (int i = 0; i &lt; configs.length; i++) {
297             Provider p = getProvider(i);
298             if (p.getName().equals(name)) {
299                 return i;
300             }
301         }
302         return -1;
303     }
304 
305     // attempt to load all Providers not already loaded
306     private int loadAll() {
307         if (allLoaded) {
308             return configs.length;
309         }
310         if (debug != null) {
311             debug.println(&quot;Loading all providers&quot;);
312             new Exception(&quot;Debug Info. Call trace:&quot;).printStackTrace();
313         }
314         int n = 0;
315         for (int i = 0; i &lt; configs.length; i++) {
316             Provider p = configs[i].getProvider();
317             if (p != null) {
318                 n++;
319             }
320         }
321         if (n == configs.length) {
322             allLoaded = true;
323         }
324         return n;
325     }
326 
327     /**
328      * Try to load all Providers and return the ProviderList. If one or
329      * more Providers could not be loaded, a new ProviderList with those
330      * entries removed is returned. Otherwise, the method returns this.
331      */
332     ProviderList removeInvalid() {
333         int n = loadAll();
334         if (n == configs.length) {
335             return this;
336         }
337         ProviderConfig[] newConfigs = new ProviderConfig[n];
338         for (int i = 0, j = 0; i &lt; configs.length; i++) {
339             ProviderConfig config = configs[i];
340             if (config.isLoaded()) {
341                 newConfigs[j++] = config;
342             }
343         }
344         return new ProviderList(newConfigs, true);
345     }
346 
347     // return the providers as an array
348     public Provider[] toArray() {
349         return providers().toArray(P0);
350     }
351 
352     // return a String representation of this ProviderList
353     public String toString() {
354         return Arrays.asList(configs).toString();
355     }
356 
357     /**
358      * Return a Service describing an implementation of the specified
359      * algorithm from the Provider with the highest precedence that
360      * supports that algorithm. Return null if no Provider supports this
361      * algorithm.
362      */
363     public Service getService(String type, String name) {
364         ArrayList&lt;PreferredEntry&gt; pList = null;
365         int i;
366 
367         // Preferred provider list
368         if (preferredPropList != null &amp;&amp;
369                 (pList = preferredPropList.getAll(type, name)) != null) {
370             for (i = 0; i &lt; pList.size(); i++) {
371                 Provider p = getProvider(pList.get(i).provider);
372                 Service s = p.getService(type, name);
373                 if (s != null) {
374                     return s;
375                 }
376             }
377         }
378 
379         for (i = 0; i &lt; configs.length; i++) {
380             Provider p = getProvider(i);
381             Service s = p.getService(type, name);
382             if (s != null) {
383                 return s;
384             }
385         }
386         return null;
387     }
388 
389     /**
390      * Return a List containing all the Services describing implementations
391      * of the specified algorithms in precedence order. If no implementation
392      * exists, this method returns an empty List.
393      *
394      * The elements of this list are determined lazily on demand.
395      *
396      * The List returned is NOT thread safe.
397      */
398     public List&lt;Service&gt; getServices(String type, String algorithm) {
399         return new ServiceList(type, algorithm);
400     }
401 
402     /**
403      * This method exists for compatibility with JCE only. It will be removed
404      * once JCE has been changed to use the replacement method.
405      * @deprecated use {@code getServices(List&lt;ServiceId&gt;)} instead
406      */
407     @Deprecated
408     public List&lt;Service&gt; getServices(String type, List&lt;String&gt; algorithms) {
409         List&lt;ServiceId&gt; ids = new ArrayList&lt;&gt;();
410         for (String alg : algorithms) {
411             ids.add(new ServiceId(type, alg));
412         }
413         return getServices(ids);
414     }
415 
416     public List&lt;Service&gt; getServices(List&lt;ServiceId&gt; ids) {
417         return new ServiceList(ids);
418     }
419 
420     /**
421      * Inner class for a List of Services. Custom List implementation in
422      * order to delay Provider initialization and lookup.
423      * Not thread safe.
424      */
425     private final class ServiceList extends AbstractList&lt;Service&gt; {
426 
427         // type and algorithm for simple lookup
428         // avoid allocating/traversing the ServiceId list for these lookups
429         private final String type;
430         private final String algorithm;
431 
432         // list of ids for parallel lookup
433         // if ids is non-null, type and algorithm are null
434         private final List&lt;ServiceId&gt; ids;
435 
436         // first service we have found
437         // it is stored in a separate variable so that we can avoid
438         // allocating the services list if we do not need the second service.
439         // this is the case if we don&#39;t failover (failovers are typically rare)
440         private Service firstService;
441 
442         // list of the services we have found so far
443         private List&lt;Service&gt; services;
444 
445         // index into config[] of the next provider we need to query
446         private int providerIndex = 0;
447 
448         // Matching preferred provider list for this ServiceList
449         ArrayList&lt;PreferredEntry&gt; preferredList = null;
450         private int preferredIndex = 0;
451 
452         ServiceList(String type, String algorithm) {
453             this.type = type;
454             this.algorithm = algorithm;
455             this.ids = null;
456         }
457 
458         ServiceList(List&lt;ServiceId&gt; ids) {
459             this.type = null;
460             this.algorithm = null;
461             this.ids = ids;
462         }
463 
464         private void addService(Service s) {
465             if (firstService == null) {
466                 firstService = s;
467             } else {
468                 if (services == null) {
469                     services = new ArrayList&lt;Service&gt;(4);
470                     services.add(firstService);
471                 }
472                 services.add(s);
473             }
474         }
475 
476         private Service tryGet(int index) {
477             Provider p;
478 
479             // If preferred providers are configured, check for matches with
480             // the requested service.
481             if (preferredPropList != null &amp;&amp; preferredList == null) {
482                 preferredList = preferredPropList.getAll(this);
483             }
484 
485             while (true) {
486                 if ((index == 0) &amp;&amp; (firstService != null)) {
487                     return firstService;
488                 } else if ((services != null) &amp;&amp; (services.size() &gt; index)) {
489                     return services.get(index);
490                 }
491                 if (providerIndex &gt;= configs.length) {
492                     return null;
493                 }
494 
495                 // If there were matches with a preferred provider, iterate
496                 // through the list first before going through the
497                 // ordered list (java.security.provider.#)
498                 if (preferredList != null &amp;&amp;
499                         preferredIndex &lt; preferredList.size()) {
500                     PreferredEntry entry = preferredList.get(preferredIndex++);
501                     // Look for the provider name in the PreferredEntry
502                     p = getProvider(entry.provider);
503                     if (p == null) {
504                         if (debug != null) {
505                             debug.println(&quot;No provider found with name: &quot; +
506                                     entry.provider);
507                         }
508                         continue;
509                     }
510                 } else {
511                     // check all algorithms in this provider before moving on
512                     p = getProvider(providerIndex++);
513                 }
514 
515                 if (type != null) {
516                     // simple lookup
517                     Service s = p.getService(type, algorithm);
518                     if (s != null) {
519                         addService(s);
520                     }
521                 } else {
522                     // parallel lookup
523                     for (ServiceId id : ids) {
524                         Service s = p.getService(id.type, id.algorithm);
525                         if (s != null) {
526                             addService(s);
527                         }
528                     }
529                 }
530             }
531         }
532 
533         public Service get(int index) {
534             Service s = tryGet(index);
535             if (s == null) {
536                 throw new IndexOutOfBoundsException();
537             }
538             return s;
539         }
540 
541         public int size() {
542             int n;
543             if (services != null) {
544                 n = services.size();
545             } else {
546                 n = (firstService != null) ? 1 : 0;
547             }
548             while (tryGet(n) != null) {
549                 n++;
550             }
551             return n;
552         }
553 
554         // override isEmpty() and iterator() to not call size()
555         // this avoids loading + checking all Providers
556 
557         public boolean isEmpty() {
558             return (tryGet(0) == null);
559         }
560 
561         public Iterator&lt;Service&gt; iterator() {
562             return new Iterator&lt;Service&gt;() {
563                 int index;
564 
565                 public boolean hasNext() {
566                     return tryGet(index) != null;
567                 }
568 
569                 public Service next() {
570                     Service s = tryGet(index);
571                     if (s == null) {
572                         throw new NoSuchElementException();
573                     }
574                     index++;
575                     return s;
576                 }
577 
578                 public void remove() {
579                     throw new UnsupportedOperationException();
580                 }
581             };
582         }
583     }
584 
585     // Provider list defined by jdk.security.provider.preferred entry
586     static final class PreferredList {
587         ArrayList&lt;PreferredEntry&gt; list = new ArrayList&lt;PreferredEntry&gt;();
588 
589         /*
590          * Return a list of all preferred entries that match the passed
591          * ServiceList.
592          */
593         ArrayList&lt;PreferredEntry&gt; getAll(ServiceList s) {
594             if (s.ids == null) {
595                 return getAll(s.type, s.algorithm);
596 
597             }
598 
599             ArrayList&lt;PreferredEntry&gt; l = new ArrayList&lt;PreferredEntry&gt;();
600             for (ServiceId id : s.ids) {
601                 implGetAll(l, id.type, id.algorithm);
602             }
603 
604             return l;
605         }
606 
607         /*
608          * Return a list of all preferred entries that match the passed
609          * type and algorithm.
610          */
611         ArrayList&lt;PreferredEntry&gt; getAll(String type, String algorithm) {
612             ArrayList&lt;PreferredEntry&gt; l = new ArrayList&lt;PreferredEntry&gt;();
613             implGetAll(l, type, algorithm);
614             return l;
615         }
616 
617         /*
618          * Compare each preferred entry against the passed type and
619          * algorithm, putting any matches in the passed ArrayList.
620          */
621         private void implGetAll(ArrayList&lt;PreferredEntry&gt; l, String type,
622                 String algorithm) {
623             PreferredEntry e;
624 
625             for (int i = 0; i &lt; size(); i++) {
626                 e = list.get(i);
627                 if (e.match(type, algorithm)) {
628                     l.add(e);
629                 }
630             }
631         }
632 
633         public PreferredEntry get(int i) {
634             return list.get(i);
635         }
636 
637         public int size() {
638             return list.size();
639         }
640 
641         public boolean add(PreferredEntry e) {
642             return list.add(e);
643         }
644 
645         public String toString() {
646             String s = &quot;&quot;;
647             for (PreferredEntry e: list) {
648                 s += e.toString();
649             }
650             return s;
651         }
652     }
653 
654     /* Defined Groups for jdk.security.provider.preferred */
655     private static final String SHA2Group[] = { &quot;SHA-224&quot;, &quot;SHA-256&quot;,
656             &quot;SHA-384&quot;, &quot;SHA-512&quot;, &quot;SHA-512/224&quot;, &quot;SHA-512/256&quot; };
657     private static final String HmacSHA2Group[] = { &quot;HmacSHA224&quot;,
658             &quot;HmacSHA256&quot;, &quot;HmacSHA384&quot;, &quot;HmacSHA512&quot;};
659     private static final String SHA2RSAGroup[] = { &quot;SHA224withRSA&quot;,
660             &quot;SHA256withRSA&quot;, &quot;SHA384withRSA&quot;, &quot;SHA512withRSA&quot;};
661     private static final String SHA2DSAGroup[] = { &quot;SHA224withDSA&quot;,
662             &quot;SHA256withDSA&quot;, &quot;SHA384withDSA&quot;, &quot;SHA512withDSA&quot;};
663     private static final String SHA2ECDSAGroup[] = { &quot;SHA224withECDSA&quot;,
664             &quot;SHA256withECDSA&quot;, &quot;SHA384withECDSA&quot;, &quot;SHA512withECDSA&quot;};
665     private static final String SHA3Group[] = { &quot;SHA3-224&quot;, &quot;SHA3-256&quot;,
666             &quot;SHA3-384&quot;, &quot;SHA3-512&quot; };
667     private static final String HmacSHA3Group[] = { &quot;HmacSHA3-224&quot;,
668             &quot;HmacSHA3-256&quot;, &quot;HmacSHA3-384&quot;, &quot;HmacSHA3-512&quot;};
669 
670     // Individual preferred property entry from jdk.security.provider.preferred
671     private static class PreferredEntry {
672         private String type = null;
673         private String algorithm;
674         private String provider;
675         private String alternateNames[] = null;
676         private boolean group = false;
677 
678         PreferredEntry(String t, String p) {
679             int i = t.indexOf(&#39;.&#39;);
680             if (i &gt; 0) {
681                 type = t.substring(0, i);
682                 algorithm = t.substring(i + 1);
683             } else {
684                 algorithm = t;
685             }
686 
687             provider = p;
688             // Group definitions
689             if (type != null &amp;&amp; type.compareToIgnoreCase(&quot;Group&quot;) == 0) {
690                 // Currently intrinsic algorithm groups
691                 if (algorithm.compareToIgnoreCase(&quot;SHA2&quot;) == 0) {
692                     alternateNames = SHA2Group;
693                 } else if (algorithm.compareToIgnoreCase(&quot;HmacSHA2&quot;) == 0) {
694                     alternateNames = HmacSHA2Group;
695                 } else if (algorithm.compareToIgnoreCase(&quot;SHA2RSA&quot;) == 0) {
696                     alternateNames = SHA2RSAGroup;
697                 } else if (algorithm.compareToIgnoreCase(&quot;SHA2DSA&quot;) == 0) {
698                     alternateNames = SHA2DSAGroup;
699                 } else if (algorithm.compareToIgnoreCase(&quot;SHA2ECDSA&quot;) == 0) {
700                     alternateNames = SHA2ECDSAGroup;
701                 } else if (algorithm.compareToIgnoreCase(&quot;SHA3&quot;) == 0) {
702                     alternateNames = SHA3Group;
703                 } else if (algorithm.compareToIgnoreCase(&quot;HmacSHA3&quot;) == 0) {
704                     alternateNames = HmacSHA3Group;
705                 }
706                 if (alternateNames != null) {
707                     group = true;
708                 }
709 
710             // If the algorithm name given is SHA1
711             } else if (algorithm.compareToIgnoreCase(&quot;SHA1&quot;) == 0) {
712                 alternateNames = new String[] { &quot;SHA-1&quot; };
713             } else if (algorithm.compareToIgnoreCase(&quot;SHA-1&quot;) == 0) {
714                 alternateNames = new String[] { &quot;SHA1&quot; };
715             }
716         }
717 
718         boolean match(String t, String a) {
719             if (debug != null) {
720                 debug.println(&quot;Config check:  &quot; + toString() + &quot; == &quot; +
721                         print(t, a, null));
722             }
723 
724             // Compare service type if configured
725             if (type != null &amp;&amp; !group &amp;&amp; type.compareToIgnoreCase(t) != 0) {
726                 return false;
727             }
728 
729             // Compare the algorithm string.
730             if (!group &amp;&amp; a.compareToIgnoreCase(algorithm) == 0) {
731                 if (debug != null) {
732                     debug.println(&quot;Config entry matched:  &quot; + toString());
733                 }
734                 return true;
735             }
736 
737             if (alternateNames != null) {
738                 for (String alt : alternateNames) {
739                     if (debug != null) {
740                         debug.println(&quot;AltName check:  &quot; + print(type, alt,
741                                 provider));
742                     }
743                     if (a.compareToIgnoreCase(alt) == 0) {
744                         if (debug != null) {
745                             debug.println(&quot;AltName entry matched:  &quot; +
746                                     provider);
747                         }
748                         return true;
749                     }
750                 }
751             }
752 
753             // No match
754             return false;
755         }
756 
757         // Print debugging output of PreferredEntry
758         private String print(String t, String a, String p) {
759             return &quot;[&quot; + ((t != null) ? t : &quot;&quot; ) + &quot;, &quot; + a +
760                     ((p != null) ? &quot; : &quot; + p : &quot;&quot; ) + &quot;] &quot;;
761         }
762 
763         public String toString() {
764             return print(type, algorithm, provider);
765         }
766     }
767 
768 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/Finished.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="EphemeralKeyManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HandshakeContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/Finished.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 393 
 394             // Change write cipher and delivery ChangeCipherSpec message.
 395             ChangeCipherSpec.t10Producer.produce(chc, message);
 396 
 397             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 398                 SSLLogger.fine(
 399                         &quot;Produced client Finished handshake message&quot;, fm);
 400             }
 401 
 402             // Output the handshake message.
 403             fm.write(chc.handshakeOutput);
 404             chc.handshakeOutput.flush();
 405 
 406             /*
 407              * save server verify data for secure renegotiation
 408              */
 409             if (chc.conContext.secureRenegotiation) {
 410                 chc.conContext.clientVerifyData = fm.verifyData;
 411             }
 412 




 413             // update the consumers and producers
 414             if (!chc.isResumption) {
 415                 chc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 416                         ChangeCipherSpec.t10Consumer);
 417                 chc.handshakeConsumers.put(
 418                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 419                 chc.conContext.inputRecord.expectingFinishFlight();
 420             } else {
 421                 if (chc.handshakeSession.isRejoinable()) {
 422                     ((SSLSessionContextImpl)chc.sslContext.
 423                         engineGetClientSessionContext()).put(
 424                             chc.handshakeSession);
 425                 }
 426                 chc.conContext.conSession = chc.handshakeSession.finish();
 427                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 428 
 429                 // handshake context cleanup.
 430                 chc.handshakeFinished = true;
 431 
 432                 // May need to retransmit the last flight for DTLS.
 433                 if (!chc.sslContext.isDTLS()) {
 434                     chc.conContext.finishHandshake();
 435                 }
 436             }
 437 
 438             // The handshake message has been delivered.
 439             return null;
 440         }
 441 
 442         private byte[] onProduceFinished(ServerHandshakeContext shc,
 443                 HandshakeMessage message) throws IOException {




 444             // Refresh handshake hash
 445             shc.handshakeHash.update();
 446 
 447             FinishedMessage fm = new FinishedMessage(shc);
 448 
 449             // Change write cipher and delivery ChangeCipherSpec message.
 450             ChangeCipherSpec.t10Producer.produce(shc, message);
 451 
 452             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 453                 SSLLogger.fine(
 454                         &quot;Produced server Finished handshake message&quot;, fm);
 455             }
 456 
 457             // Output the handshake message.
 458             fm.write(shc.handshakeOutput);
 459             shc.handshakeOutput.flush();
 460 
 461             /*
 462              * save client verify data for secure renegotiation
 463              */
 464             if (shc.conContext.secureRenegotiation) {
 465                 shc.conContext.serverVerifyData = fm.verifyData;
 466             }
 467 
 468             // update the consumers and producers
 469             if (shc.isResumption) {
 470                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 471                         ChangeCipherSpec.t10Consumer);
 472                 shc.handshakeConsumers.put(
 473                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 474                 shc.conContext.inputRecord.expectingFinishFlight();
 475             } else {
<span class="line-modified"> 476                 if (shc.handshakeSession.isRejoinable()) {</span>

 477                     ((SSLSessionContextImpl)shc.sslContext.
 478                         engineGetServerSessionContext()).put(
 479                             shc.handshakeSession);
 480                 }
 481                 shc.conContext.conSession = shc.handshakeSession.finish();
 482                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 483 
 484                 // handshake context cleanup.
 485                 shc.handshakeFinished = true;
 486 
 487                 // May need to retransmit the last flight for DTLS.
 488                 if (!shc.sslContext.isDTLS()) {
 489                     shc.conContext.finishHandshake();
 490                 }
 491             }
 492 
 493             // The handshake message has been delivered.
 494             return null;
 495         }
 496     }
</pre>
<hr />
<pre>
 563             }
 564 
 565             //
 566             // produce
 567             //
 568             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 569                 SSLHandshake.FINISHED
 570             };
 571 
 572             for (SSLHandshake hs : probableHandshakeMessages) {
 573                 HandshakeProducer handshakeProducer =
 574                         chc.handshakeProducers.remove(hs.id);
 575                 if (handshakeProducer != null) {
 576                     handshakeProducer.produce(chc, fm);
 577                 }
 578             }
 579         }
 580 
 581         private void onConsumeFinished(ServerHandshakeContext shc,
 582                 ByteBuffer message) throws IOException {










 583             FinishedMessage fm = new FinishedMessage(shc, message);
 584             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 585                 SSLLogger.fine(
 586                         &quot;Consuming client Finished handshake message&quot;, fm);
 587             }
 588 
 589             if (shc.conContext.secureRenegotiation) {
 590                 shc.conContext.clientVerifyData = fm.verifyData;
 591             }
 592 
 593             if (shc.isResumption) {
<span class="line-modified"> 594                 if (shc.handshakeSession.isRejoinable()) {</span>

 595                     ((SSLSessionContextImpl)shc.sslContext.
 596                         engineGetServerSessionContext()).put(
 597                             shc.handshakeSession);
 598                 }
 599                 shc.conContext.conSession = shc.handshakeSession.finish();
 600                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 601 
 602                 // handshake context cleanup.
 603                 shc.handshakeFinished = true;
 604                 recordEvent(shc.conContext.conSession);
 605 
 606                 // May need to retransmit the last flight for DTLS.
 607                 if (!shc.sslContext.isDTLS()) {
 608                     shc.conContext.finishHandshake();
 609                 }
 610             } else {
 611                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 612                         SSLHandshake.FINISHED);
 613             }
 614 
</pre>
<hr />
<pre>
 820                 }
 821 
 822                 shc.baseWriteSecret = writeSecret;
 823                 shc.conContext.outputRecord.changeWriteCiphers(
 824                         writeCipher, false);
 825 
 826                 // update the context for the following key derivation
 827                 shc.handshakeKeyDerivation = secretKD;
 828             } catch (GeneralSecurityException gse) {
 829                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 830                         &quot;Failure to derive application secrets&quot;, gse);
 831             }
 832 
 833             /*
 834              * save client verify data for secure renegotiation
 835              */
 836             if (shc.conContext.secureRenegotiation) {
 837                 shc.conContext.serverVerifyData = fm.verifyData;
 838             }
 839 


 840             // update the context
 841             shc.handshakeConsumers.put(
 842                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 843 
 844             // The handshake message has been delivered.
 845             return null;
 846         }
 847     }
 848 
 849     /**
 850      * The &quot;Finished&quot; handshake message consumer.
 851      */
 852     private static final class T13FinishedConsumer implements SSLConsumer {
 853         // Prevent instantiation of this class.
 854         private T13FinishedConsumer() {
 855             // blank
 856         }
 857 
 858         @Override
 859         public void consume(ConnectionContext context,
 860                 ByteBuffer message) throws IOException {
 861             // The consuming happens in handshake context only.
 862             HandshakeContext hc = (HandshakeContext)context;
 863             if (hc.sslConfig.isClientMode) {
 864                 onConsumeFinished(
 865                         (ClientHandshakeContext)context, message);
 866             } else {
 867                 onConsumeFinished(
 868                         (ServerHandshakeContext)context, message);
 869             }
 870         }
 871 
 872         private void onConsumeFinished(ClientHandshakeContext chc,
 873                 ByteBuffer message) throws IOException {










 874             FinishedMessage fm = new FinishedMessage(chc, message);
 875             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 876                 SSLLogger.fine(
 877                         &quot;Consuming server Finished handshake message&quot;, fm);
 878             }
 879 
 880             // Save client verify data for secure renegotiation.
 881             if (chc.conContext.secureRenegotiation) {
 882                 chc.conContext.serverVerifyData = fm.verifyData;
 883             }
 884 
 885             //
 886             // validate
 887             //
 888             // blank
 889 
 890             //
 891             // update
 892             //
 893             // A change_cipher_spec record received after the peer&#39;s Finished
</pre>
<hr />
<pre>
 898             // Refresh handshake hash
 899             chc.handshakeHash.update();
 900             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 901             if (kd == null) {
 902                 // unlikely
 903                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 904                     &quot;no key derivation&quot;);
 905             }
 906 
 907             SSLTrafficKeyDerivation kdg =
 908                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 909             if (kdg == null) {
 910                 // unlikely
 911                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 912                         &quot;Not supported key derivation: &quot; +
 913                         chc.negotiatedProtocol);
 914             }
 915 
 916             // save the session
 917             if (!chc.isResumption &amp;&amp; chc.handshakeSession.isRejoinable()) {
<span class="line-modified"> 918                 SSLSessionContextImpl sessionContext = (SSLSessionContextImpl)</span>
<span class="line-modified"> 919                 chc.sslContext.engineGetClientSessionContext();</span>
<span class="line-modified"> 920                 sessionContext.put(chc.handshakeSession);</span>
 921             }
 922 
 923             // derive salt secret
 924             try {
 925                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 926 
 927                 // derive application secrets
 928                 HashAlg hashAlg = chc.negotiatedCipherSuite.hashAlg;
 929                 HKDF hkdf = new HKDF(hashAlg.name);
 930                 byte[] zeros = new byte[hashAlg.hashLength];
 931                 SecretKeySpec sharedSecret =
 932                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 933                 SecretKey masterSecret =
 934                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 935 
 936                 SSLKeyDerivation secretKD =
 937                         new SSLSecretDerivation(chc, masterSecret);
 938 
 939                 // update the handshake traffic read keys.
 940                 SecretKey readSecret = secretKD.deriveKey(
</pre>
<hr />
<pre>
 976             chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 977                         SSLHandshake.FINISHED);
 978             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 979                 // full handshake messages
 980                 SSLHandshake.CERTIFICATE,
 981                 SSLHandshake.CERTIFICATE_VERIFY,
 982                 SSLHandshake.FINISHED
 983             };
 984 
 985             for (SSLHandshake hs : probableHandshakeMessages) {
 986                 HandshakeProducer handshakeProducer =
 987                         chc.handshakeProducers.remove(hs.id);
 988                 if (handshakeProducer != null) {
 989                     handshakeProducer.produce(chc, null);
 990                 }
 991             }
 992         }
 993 
 994         private void onConsumeFinished(ServerHandshakeContext shc,
 995                 ByteBuffer message) throws IOException {










 996             FinishedMessage fm = new FinishedMessage(shc, message);
 997             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 998                 SSLLogger.fine(
 999                         &quot;Consuming client Finished handshake message&quot;, fm);
1000             }
1001 
1002             if (shc.conContext.secureRenegotiation) {
1003                 shc.conContext.clientVerifyData = fm.verifyData;
1004             }
1005 
1006             //
1007             // validate
1008             //
1009             // blank
1010 
1011             //
1012             // update
1013             //
1014             // Change client/server application traffic secrets.
1015             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1016             if (kd == null) {
1017                 // unlikely
1018                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1019                     &quot;no key derivation&quot;);
1020             }
1021 
1022             SSLTrafficKeyDerivation kdg =
1023                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1024             if (kdg == null) {
1025                 // unlikely
1026                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1027                         &quot;Not supported key derivation: &quot; +
1028                         shc.negotiatedProtocol);
1029             }
1030 
<span class="line-modified">1031             // save the session</span>
<span class="line-modified">1032             if (!shc.isResumption &amp;&amp; shc.handshakeSession.isRejoinable()) {</span>

1033                 SSLSessionContextImpl sessionContext = (SSLSessionContextImpl)
<span class="line-modified">1034                 shc.sslContext.engineGetServerSessionContext();</span>
1035                 sessionContext.put(shc.handshakeSession);
1036             }
1037 
1038             try {
1039                 // update the application traffic read keys.
1040                 SecretKey readSecret = kd.deriveKey(
1041                         &quot;TlsClientAppTrafficSecret&quot;, null);
1042 
1043                 SSLKeyDerivation readKD =
1044                         kdg.createKeyDerivation(shc, readSecret);
1045                 SecretKey readKey = readKD.deriveKey(
1046                         &quot;TlsKey&quot;, null);
1047                 SecretKey readIvSecret = readKD.deriveKey(
1048                         &quot;TlsIv&quot;, null);
1049                 IvParameterSpec readIv =
1050                         new IvParameterSpec(readIvSecret.getEncoded());
1051                 SSLReadCipher readCipher =
1052                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1053                                 Authenticator.valueOf(shc.negotiatedProtocol),
1054                                 shc.negotiatedProtocol, readKey, readIv,
</pre>
</td>
<td>
<hr />
<pre>
 393 
 394             // Change write cipher and delivery ChangeCipherSpec message.
 395             ChangeCipherSpec.t10Producer.produce(chc, message);
 396 
 397             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 398                 SSLLogger.fine(
 399                         &quot;Produced client Finished handshake message&quot;, fm);
 400             }
 401 
 402             // Output the handshake message.
 403             fm.write(chc.handshakeOutput);
 404             chc.handshakeOutput.flush();
 405 
 406             /*
 407              * save server verify data for secure renegotiation
 408              */
 409             if (chc.conContext.secureRenegotiation) {
 410                 chc.conContext.clientVerifyData = fm.verifyData;
 411             }
 412 
<span class="line-added"> 413             if (chc.statelessResumption) {</span>
<span class="line-added"> 414                 chc.handshakeConsumers.put(</span>
<span class="line-added"> 415                         SSLHandshake.NEW_SESSION_TICKET.id, SSLHandshake.NEW_SESSION_TICKET);</span>
<span class="line-added"> 416             }</span>
 417             // update the consumers and producers
 418             if (!chc.isResumption) {
 419                 chc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 420                         ChangeCipherSpec.t10Consumer);
 421                 chc.handshakeConsumers.put(
 422                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 423                 chc.conContext.inputRecord.expectingFinishFlight();
 424             } else {
 425                 if (chc.handshakeSession.isRejoinable()) {
 426                     ((SSLSessionContextImpl)chc.sslContext.
 427                         engineGetClientSessionContext()).put(
 428                             chc.handshakeSession);
 429                 }
 430                 chc.conContext.conSession = chc.handshakeSession.finish();
 431                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 432 
 433                 // handshake context cleanup.
 434                 chc.handshakeFinished = true;
 435 
 436                 // May need to retransmit the last flight for DTLS.
 437                 if (!chc.sslContext.isDTLS()) {
 438                     chc.conContext.finishHandshake();
 439                 }
 440             }
 441 
 442             // The handshake message has been delivered.
 443             return null;
 444         }
 445 
 446         private byte[] onProduceFinished(ServerHandshakeContext shc,
 447                 HandshakeMessage message) throws IOException {
<span class="line-added"> 448             if (shc.statelessResumption) {</span>
<span class="line-added"> 449                 NewSessionTicket.handshake12Producer.produce(shc, message);</span>
<span class="line-added"> 450             }</span>
<span class="line-added"> 451 </span>
 452             // Refresh handshake hash
 453             shc.handshakeHash.update();
 454 
 455             FinishedMessage fm = new FinishedMessage(shc);
 456 
 457             // Change write cipher and delivery ChangeCipherSpec message.
 458             ChangeCipherSpec.t10Producer.produce(shc, message);
 459 
 460             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 461                 SSLLogger.fine(
 462                         &quot;Produced server Finished handshake message&quot;, fm);
 463             }
 464 
 465             // Output the handshake message.
 466             fm.write(shc.handshakeOutput);
 467             shc.handshakeOutput.flush();
 468 
 469             /*
 470              * save client verify data for secure renegotiation
 471              */
 472             if (shc.conContext.secureRenegotiation) {
 473                 shc.conContext.serverVerifyData = fm.verifyData;
 474             }
 475 
 476             // update the consumers and producers
 477             if (shc.isResumption) {
 478                 shc.conContext.consumers.put(ContentType.CHANGE_CIPHER_SPEC.id,
 479                         ChangeCipherSpec.t10Consumer);
 480                 shc.handshakeConsumers.put(
 481                         SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 482                 shc.conContext.inputRecord.expectingFinishFlight();
 483             } else {
<span class="line-modified"> 484                 if (shc.handshakeSession.isRejoinable() &amp;&amp;</span>
<span class="line-added"> 485                         !shc.handshakeSession.isStatelessable(shc)) {</span>
 486                     ((SSLSessionContextImpl)shc.sslContext.
 487                         engineGetServerSessionContext()).put(
 488                             shc.handshakeSession);
 489                 }
 490                 shc.conContext.conSession = shc.handshakeSession.finish();
 491                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 492 
 493                 // handshake context cleanup.
 494                 shc.handshakeFinished = true;
 495 
 496                 // May need to retransmit the last flight for DTLS.
 497                 if (!shc.sslContext.isDTLS()) {
 498                     shc.conContext.finishHandshake();
 499                 }
 500             }
 501 
 502             // The handshake message has been delivered.
 503             return null;
 504         }
 505     }
</pre>
<hr />
<pre>
 572             }
 573 
 574             //
 575             // produce
 576             //
 577             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
 578                 SSLHandshake.FINISHED
 579             };
 580 
 581             for (SSLHandshake hs : probableHandshakeMessages) {
 582                 HandshakeProducer handshakeProducer =
 583                         chc.handshakeProducers.remove(hs.id);
 584                 if (handshakeProducer != null) {
 585                     handshakeProducer.produce(chc, fm);
 586                 }
 587             }
 588         }
 589 
 590         private void onConsumeFinished(ServerHandshakeContext shc,
 591                 ByteBuffer message) throws IOException {
<span class="line-added"> 592             // Make sure that any expected CertificateVerify message</span>
<span class="line-added"> 593             // has been received and processed.</span>
<span class="line-added"> 594             if (!shc.isResumption) {</span>
<span class="line-added"> 595                 if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 596                         SSLHandshake.CERTIFICATE_VERIFY.id)) {</span>
<span class="line-added"> 597                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 598                             &quot;Unexpected Finished handshake message&quot;);</span>
<span class="line-added"> 599                 }</span>
<span class="line-added"> 600             }</span>
<span class="line-added"> 601 </span>
 602             FinishedMessage fm = new FinishedMessage(shc, message);
 603             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 604                 SSLLogger.fine(
 605                         &quot;Consuming client Finished handshake message&quot;, fm);
 606             }
 607 
 608             if (shc.conContext.secureRenegotiation) {
 609                 shc.conContext.clientVerifyData = fm.verifyData;
 610             }
 611 
 612             if (shc.isResumption) {
<span class="line-modified"> 613                 if (shc.handshakeSession.isRejoinable() &amp;&amp;</span>
<span class="line-added"> 614                         !shc.statelessResumption) {</span>
 615                     ((SSLSessionContextImpl)shc.sslContext.
 616                         engineGetServerSessionContext()).put(
 617                             shc.handshakeSession);
 618                 }
 619                 shc.conContext.conSession = shc.handshakeSession.finish();
 620                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
 621 
 622                 // handshake context cleanup.
 623                 shc.handshakeFinished = true;
 624                 recordEvent(shc.conContext.conSession);
 625 
 626                 // May need to retransmit the last flight for DTLS.
 627                 if (!shc.sslContext.isDTLS()) {
 628                     shc.conContext.finishHandshake();
 629                 }
 630             } else {
 631                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 632                         SSLHandshake.FINISHED);
 633             }
 634 
</pre>
<hr />
<pre>
 840                 }
 841 
 842                 shc.baseWriteSecret = writeSecret;
 843                 shc.conContext.outputRecord.changeWriteCiphers(
 844                         writeCipher, false);
 845 
 846                 // update the context for the following key derivation
 847                 shc.handshakeKeyDerivation = secretKD;
 848             } catch (GeneralSecurityException gse) {
 849                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 850                         &quot;Failure to derive application secrets&quot;, gse);
 851             }
 852 
 853             /*
 854              * save client verify data for secure renegotiation
 855              */
 856             if (shc.conContext.secureRenegotiation) {
 857                 shc.conContext.serverVerifyData = fm.verifyData;
 858             }
 859 
<span class="line-added"> 860             shc.conContext.conSession = shc.handshakeSession.finish();</span>
<span class="line-added"> 861 </span>
 862             // update the context
 863             shc.handshakeConsumers.put(
 864                     SSLHandshake.FINISHED.id, SSLHandshake.FINISHED);
 865 
 866             // The handshake message has been delivered.
 867             return null;
 868         }
 869     }
 870 
 871     /**
 872      * The &quot;Finished&quot; handshake message consumer.
 873      */
 874     private static final class T13FinishedConsumer implements SSLConsumer {
 875         // Prevent instantiation of this class.
 876         private T13FinishedConsumer() {
 877             // blank
 878         }
 879 
 880         @Override
 881         public void consume(ConnectionContext context,
 882                 ByteBuffer message) throws IOException {
 883             // The consuming happens in handshake context only.
 884             HandshakeContext hc = (HandshakeContext)context;
 885             if (hc.sslConfig.isClientMode) {
 886                 onConsumeFinished(
 887                         (ClientHandshakeContext)context, message);
 888             } else {
 889                 onConsumeFinished(
 890                         (ServerHandshakeContext)context, message);
 891             }
 892         }
 893 
 894         private void onConsumeFinished(ClientHandshakeContext chc,
 895                 ByteBuffer message) throws IOException {
<span class="line-added"> 896             // Make sure that any expected CertificateVerify message</span>
<span class="line-added"> 897             // has been received and processed.</span>
<span class="line-added"> 898             if (!chc.isResumption) {</span>
<span class="line-added"> 899                 if (chc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 900                         SSLHandshake.CERTIFICATE_VERIFY.id)) {</span>
<span class="line-added"> 901                     throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 902                             &quot;Unexpected Finished handshake message&quot;);</span>
<span class="line-added"> 903                 }</span>
<span class="line-added"> 904             }</span>
<span class="line-added"> 905 </span>
 906             FinishedMessage fm = new FinishedMessage(chc, message);
 907             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 908                 SSLLogger.fine(
 909                         &quot;Consuming server Finished handshake message&quot;, fm);
 910             }
 911 
 912             // Save client verify data for secure renegotiation.
 913             if (chc.conContext.secureRenegotiation) {
 914                 chc.conContext.serverVerifyData = fm.verifyData;
 915             }
 916 
 917             //
 918             // validate
 919             //
 920             // blank
 921 
 922             //
 923             // update
 924             //
 925             // A change_cipher_spec record received after the peer&#39;s Finished
</pre>
<hr />
<pre>
 930             // Refresh handshake hash
 931             chc.handshakeHash.update();
 932             SSLKeyDerivation kd = chc.handshakeKeyDerivation;
 933             if (kd == null) {
 934                 // unlikely
 935                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 936                     &quot;no key derivation&quot;);
 937             }
 938 
 939             SSLTrafficKeyDerivation kdg =
 940                     SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
 941             if (kdg == null) {
 942                 // unlikely
 943                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
 944                         &quot;Not supported key derivation: &quot; +
 945                         chc.negotiatedProtocol);
 946             }
 947 
 948             // save the session
 949             if (!chc.isResumption &amp;&amp; chc.handshakeSession.isRejoinable()) {
<span class="line-modified"> 950                 ((SSLSessionContextImpl)chc.sslContext.</span>
<span class="line-modified"> 951                         engineGetClientSessionContext()).</span>
<span class="line-modified"> 952                         put(chc.handshakeSession);</span>
 953             }
 954 
 955             // derive salt secret
 956             try {
 957                 SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);
 958 
 959                 // derive application secrets
 960                 HashAlg hashAlg = chc.negotiatedCipherSuite.hashAlg;
 961                 HKDF hkdf = new HKDF(hashAlg.name);
 962                 byte[] zeros = new byte[hashAlg.hashLength];
 963                 SecretKeySpec sharedSecret =
 964                         new SecretKeySpec(zeros, &quot;TlsZeroSecret&quot;);
 965                 SecretKey masterSecret =
 966                     hkdf.extract(saltSecret, sharedSecret, &quot;TlsMasterSecret&quot;);
 967 
 968                 SSLKeyDerivation secretKD =
 969                         new SSLSecretDerivation(chc, masterSecret);
 970 
 971                 // update the handshake traffic read keys.
 972                 SecretKey readSecret = secretKD.deriveKey(
</pre>
<hr />
<pre>
1008             chc.handshakeProducers.put(SSLHandshake.FINISHED.id,
1009                         SSLHandshake.FINISHED);
1010             SSLHandshake[] probableHandshakeMessages = new SSLHandshake[] {
1011                 // full handshake messages
1012                 SSLHandshake.CERTIFICATE,
1013                 SSLHandshake.CERTIFICATE_VERIFY,
1014                 SSLHandshake.FINISHED
1015             };
1016 
1017             for (SSLHandshake hs : probableHandshakeMessages) {
1018                 HandshakeProducer handshakeProducer =
1019                         chc.handshakeProducers.remove(hs.id);
1020                 if (handshakeProducer != null) {
1021                     handshakeProducer.produce(chc, null);
1022                 }
1023             }
1024         }
1025 
1026         private void onConsumeFinished(ServerHandshakeContext shc,
1027                 ByteBuffer message) throws IOException {
<span class="line-added">1028             // Make sure that any expected CertificateVerify message</span>
<span class="line-added">1029             // has been received and processed.</span>
<span class="line-added">1030             if (!shc.isResumption) {</span>
<span class="line-added">1031                 if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added">1032                         SSLHandshake.CERTIFICATE_VERIFY.id)) {</span>
<span class="line-added">1033                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added">1034                             &quot;Unexpected Finished handshake message&quot;);</span>
<span class="line-added">1035                 }</span>
<span class="line-added">1036             }</span>
<span class="line-added">1037 </span>
1038             FinishedMessage fm = new FinishedMessage(shc, message);
1039             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1040                 SSLLogger.fine(
1041                         &quot;Consuming client Finished handshake message&quot;, fm);
1042             }
1043 
1044             if (shc.conContext.secureRenegotiation) {
1045                 shc.conContext.clientVerifyData = fm.verifyData;
1046             }
1047 
1048             //
1049             // validate
1050             //
1051             // blank
1052 
1053             //
1054             // update
1055             //
1056             // Change client/server application traffic secrets.
1057             SSLKeyDerivation kd = shc.handshakeKeyDerivation;
1058             if (kd == null) {
1059                 // unlikely
1060                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1061                     &quot;no key derivation&quot;);
1062             }
1063 
1064             SSLTrafficKeyDerivation kdg =
1065                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
1066             if (kdg == null) {
1067                 // unlikely
1068                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
1069                         &quot;Not supported key derivation: &quot; +
1070                         shc.negotiatedProtocol);
1071             }
1072 
<span class="line-modified">1073             // Save the session if possible and not stateless</span>
<span class="line-modified">1074             if (!shc.statelessResumption &amp;&amp; !shc.isResumption &amp;&amp;</span>
<span class="line-added">1075                     shc.handshakeSession.isRejoinable()) {</span>
1076                 SSLSessionContextImpl sessionContext = (SSLSessionContextImpl)
<span class="line-modified">1077                         shc.sslContext.engineGetServerSessionContext();</span>
1078                 sessionContext.put(shc.handshakeSession);
1079             }
1080 
1081             try {
1082                 // update the application traffic read keys.
1083                 SecretKey readSecret = kd.deriveKey(
1084                         &quot;TlsClientAppTrafficSecret&quot;, null);
1085 
1086                 SSLKeyDerivation readKD =
1087                         kdg.createKeyDerivation(shc, readSecret);
1088                 SecretKey readKey = readKD.deriveKey(
1089                         &quot;TlsKey&quot;, null);
1090                 SecretKey readIvSecret = readKD.deriveKey(
1091                         &quot;TlsIv&quot;, null);
1092                 IvParameterSpec readIv =
1093                         new IvParameterSpec(readIvSecret.getEncoded());
1094                 SSLReadCipher readCipher =
1095                         shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1096                                 Authenticator.valueOf(shc.negotiatedProtocol),
1097                                 shc.negotiatedProtocol, readKey, readIv,
</pre>
</td>
</tr>
</table>
<center><a href="EphemeralKeyManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="HandshakeContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
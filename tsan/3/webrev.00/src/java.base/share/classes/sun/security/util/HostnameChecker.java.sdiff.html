<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/HostnameChecker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="HexDumpEncoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="IOUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/HostnameChecker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
243             Principal subjectDN = cert.getSubjectDN();
244             if (subjectDN instanceof X500Name) {
245                 return (X500Name)subjectDN;
246             } else {
247                 X500Principal subjectX500 = cert.getSubjectX500Principal();
248                 return new X500Name(subjectX500.getEncoded());
249             }
250         } catch (IOException e) {
251             throw(CertificateParsingException)
252                 new CertificateParsingException().initCause(e);
253         }
254     }
255 
256 
257     /**
258      * Returns true if name matches against template.&lt;p&gt;
259      *
260      * The matching is performed as per RFC 2818 rules for TLS and
261      * RFC 2830 rules for LDAP.&lt;p&gt;
262      *
<span class="line-modified">263      * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.</span>
<span class="line-modified">264      * The &lt;code&gt;template&lt;/code&gt; parameter</span>
<span class="line-removed">265      * may contain the wildcard character *</span>
266      */
267     private boolean isMatched(String name, String template,
268                               boolean chainsToPublicCA) {
269 
270         // Normalize to Unicode, because PSL is in Unicode.
<span class="line-modified">271         name = IDN.toUnicode(IDN.toASCII(name));</span>
<span class="line-modified">272         template = IDN.toUnicode(IDN.toASCII(template));</span>





273 
<span class="line-modified">274         if (hasIllegalWildcard(name, template, chainsToPublicCA)) {</span>



275             return false;
276         }
277 
278         // check the validity of the domain name template.
279         try {
<span class="line-modified">280             // Replacing wildcard character &#39;*&#39; with &#39;x&#39; so as to check</span>
281             // the domain name template validity.
282             //
283             // Using the checking implemented in SNIHostName
<span class="line-modified">284             new SNIHostName(template.replace(&#39;*&#39;, &#39;x&#39;));</span>
285         } catch (IllegalArgumentException iae) {
286             // It would be nice to add debug log if not matching.
287             return false;
288         }
289 
290         if (checkType == TYPE_TLS) {
291             return matchAllWildcards(name, template);
292         } else if (checkType == TYPE_LDAP) {
293             return matchLeftmostWildcard(name, template);
294         } else {
295             return false;
296         }
297     }
298 
299     /**
300      * Returns true if the template contains an illegal wildcard character.
301      */
<span class="line-modified">302     private static boolean hasIllegalWildcard(String domain, String template,</span>
<span class="line-modified">303                                               boolean chainsToPublicCA) {</span>
304         // not ok if it is a single wildcard character or &quot;*.&quot;
305         if (template.equals(&quot;*&quot;) || template.equals(&quot;*.&quot;)) {
306             if (SSLLogger.isOn) {
307                 SSLLogger.fine(
308                     &quot;Certificate domain name has illegal single &quot; +
309                       &quot;wildcard character: &quot; + template);
310             }
311             return true;
312         }
313 
314         int lastWildcardIndex = template.lastIndexOf(&quot;*&quot;);
315 
316         // ok if it has no wildcard character
317         if (lastWildcardIndex == -1) {
318             return false;
319         }
320 
321         String afterWildcard = template.substring(lastWildcardIndex);
322         int firstDotIndex = afterWildcard.indexOf(&quot;.&quot;);
323 
324         // not ok if there is no dot after wildcard (ex: &quot;*com&quot;)
325         if (firstDotIndex == -1) {
326             if (SSLLogger.isOn) {
327                 SSLLogger.fine(
328                     &quot;Certificate domain name has illegal wildcard, &quot; +
329                     &quot;no dot after wildcard character: &quot; + template);
330             }
331             return true;
332         }
333 
<span class="line-removed">334         // If the wildcarded domain is a top-level domain under which names</span>
<span class="line-removed">335         // can be registered, then a wildcard is not allowed.</span>
<span class="line-removed">336 </span>
337         if (!chainsToPublicCA) {
338             return false; // skip check for non-public certificates
339         }
<span class="line-modified">340         Optional&lt;RegisteredDomain&gt; rd = RegisteredDomain.from(domain)</span>
<span class="line-modified">341                 .filter(d -&gt; d.type() == RegisteredDomain.Type.ICANN);</span>
<span class="line-modified">342 </span>
<span class="line-modified">343         if (rd.isPresent()) {</span>
<span class="line-modified">344             String wDomain = afterWildcard.substring(firstDotIndex + 1);</span>
<span class="line-modified">345             if (rd.get().publicSuffix().equalsIgnoreCase(wDomain)) {</span>
<span class="line-modified">346                 if (SSLLogger.isOn) {</span>
<span class="line-modified">347                     SSLLogger.fine(</span>
<span class="line-modified">348                         &quot;Certificate domain name has illegal &quot; +</span>
<span class="line-modified">349                         &quot;wildcard for public suffix: &quot; + template);</span>
<span class="line-modified">350                 }</span>
<span class="line-modified">351                 return true;</span>






352             }

353         }
354 
355         return false;
356     }
357 
358     /**
359      * Returns true if name matches against template.&lt;p&gt;
360      *
361      * According to RFC 2818, section 3.1 -
362      * Names may contain the wildcard character * which is
363      * considered to match any single domain name component
364      * or component fragment.
365      * E.g., *.a.com matches foo.a.com but not
366      * bar.foo.a.com. f*.com matches foo.com but not bar.com.
367      */
368     private static boolean matchAllWildcards(String name,
369          String template) {
370         name = name.toLowerCase(Locale.ENGLISH);
371         template = template.toLowerCase(Locale.ENGLISH);
372         StringTokenizer nameSt = new StringTokenizer(name, &quot;.&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
243             Principal subjectDN = cert.getSubjectDN();
244             if (subjectDN instanceof X500Name) {
245                 return (X500Name)subjectDN;
246             } else {
247                 X500Principal subjectX500 = cert.getSubjectX500Principal();
248                 return new X500Name(subjectX500.getEncoded());
249             }
250         } catch (IOException e) {
251             throw(CertificateParsingException)
252                 new CertificateParsingException().initCause(e);
253         }
254     }
255 
256 
257     /**
258      * Returns true if name matches against template.&lt;p&gt;
259      *
260      * The matching is performed as per RFC 2818 rules for TLS and
261      * RFC 2830 rules for LDAP.&lt;p&gt;
262      *
<span class="line-modified">263      * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.  The</span>
<span class="line-modified">264      * &lt;code&gt;template&lt;/code&gt; parameter may contain the wildcard character &#39;*&#39;.</span>

265      */
266     private boolean isMatched(String name, String template,
267                               boolean chainsToPublicCA) {
268 
269         // Normalize to Unicode, because PSL is in Unicode.
<span class="line-modified">270         try {</span>
<span class="line-modified">271             name = IDN.toUnicode(IDN.toASCII(name));</span>
<span class="line-added">272             template = IDN.toUnicode(IDN.toASCII(template));</span>
<span class="line-added">273         } catch (RuntimeException re) {</span>
<span class="line-added">274             if (SSLLogger.isOn) {</span>
<span class="line-added">275                 SSLLogger.fine(&quot;Failed to normalize to Unicode: &quot; + re);</span>
<span class="line-added">276             }</span>
277 
<span class="line-modified">278             return false;</span>
<span class="line-added">279         }</span>
<span class="line-added">280 </span>
<span class="line-added">281         if (hasIllegalWildcard(template, chainsToPublicCA)) {</span>
282             return false;
283         }
284 
285         // check the validity of the domain name template.
286         try {
<span class="line-modified">287             // Replacing wildcard character &#39;*&#39; with &#39;z&#39; so as to check</span>
288             // the domain name template validity.
289             //
290             // Using the checking implemented in SNIHostName
<span class="line-modified">291             new SNIHostName(template.replace(&#39;*&#39;, &#39;z&#39;));</span>
292         } catch (IllegalArgumentException iae) {
293             // It would be nice to add debug log if not matching.
294             return false;
295         }
296 
297         if (checkType == TYPE_TLS) {
298             return matchAllWildcards(name, template);
299         } else if (checkType == TYPE_LDAP) {
300             return matchLeftmostWildcard(name, template);
301         } else {
302             return false;
303         }
304     }
305 
306     /**
307      * Returns true if the template contains an illegal wildcard character.
308      */
<span class="line-modified">309     private static boolean hasIllegalWildcard(</span>
<span class="line-modified">310             String template, boolean chainsToPublicCA) {</span>
311         // not ok if it is a single wildcard character or &quot;*.&quot;
312         if (template.equals(&quot;*&quot;) || template.equals(&quot;*.&quot;)) {
313             if (SSLLogger.isOn) {
314                 SSLLogger.fine(
315                     &quot;Certificate domain name has illegal single &quot; +
316                       &quot;wildcard character: &quot; + template);
317             }
318             return true;
319         }
320 
321         int lastWildcardIndex = template.lastIndexOf(&quot;*&quot;);
322 
323         // ok if it has no wildcard character
324         if (lastWildcardIndex == -1) {
325             return false;
326         }
327 
328         String afterWildcard = template.substring(lastWildcardIndex);
329         int firstDotIndex = afterWildcard.indexOf(&quot;.&quot;);
330 
331         // not ok if there is no dot after wildcard (ex: &quot;*com&quot;)
332         if (firstDotIndex == -1) {
333             if (SSLLogger.isOn) {
334                 SSLLogger.fine(
335                     &quot;Certificate domain name has illegal wildcard, &quot; +
336                     &quot;no dot after wildcard character: &quot; + template);
337             }
338             return true;
339         }
340 



341         if (!chainsToPublicCA) {
342             return false; // skip check for non-public certificates
343         }
<span class="line-modified">344 </span>
<span class="line-modified">345         // If the wildcarded domain is a top-level domain under which names</span>
<span class="line-modified">346         // can be registered, then a wildcard is not allowed.</span>
<span class="line-modified">347         String wildcardedDomain = afterWildcard.substring(firstDotIndex + 1);</span>
<span class="line-modified">348         String templateDomainSuffix =</span>
<span class="line-modified">349                 RegisteredDomain.from(&quot;z.&quot; + wildcardedDomain)</span>
<span class="line-modified">350                     .filter(d -&gt; d.type() == RegisteredDomain.Type.ICANN)</span>
<span class="line-modified">351                     .map(RegisteredDomain::publicSuffix).orElse(null);</span>
<span class="line-modified">352         if (templateDomainSuffix == null) {</span>
<span class="line-modified">353             return false;   // skip check if not known public suffix</span>
<span class="line-modified">354         }</span>
<span class="line-modified">355 </span>
<span class="line-added">356         // Is it a top-level domain?</span>
<span class="line-added">357         if (wildcardedDomain.equalsIgnoreCase(templateDomainSuffix)) {</span>
<span class="line-added">358             if (SSLLogger.isOn) {</span>
<span class="line-added">359                 SSLLogger.fine(</span>
<span class="line-added">360                     &quot;Certificate domain name has illegal &quot; +</span>
<span class="line-added">361                     &quot;wildcard for top-level public suffix: &quot; + template);</span>
362             }
<span class="line-added">363             return true;</span>
364         }
365 
366         return false;
367     }
368 
369     /**
370      * Returns true if name matches against template.&lt;p&gt;
371      *
372      * According to RFC 2818, section 3.1 -
373      * Names may contain the wildcard character * which is
374      * considered to match any single domain name component
375      * or component fragment.
376      * E.g., *.a.com matches foo.a.com but not
377      * bar.foo.a.com. f*.com matches foo.com but not bar.com.
378      */
379     private static boolean matchAllWildcards(String name,
380          String template) {
381         name = name.toLowerCase(Locale.ENGLISH);
382         template = template.toLowerCase(Locale.ENGLISH);
383         StringTokenizer nameSt = new StringTokenizer(name, &quot;.&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="HexDumpEncoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="IOUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
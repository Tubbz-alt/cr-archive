<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SignatureScheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.*;
<a name="1" id="anc1"></a>
 29 import java.security.spec.AlgorithmParameterSpec;
 30 import java.security.spec.ECParameterSpec;
 31 import java.security.spec.MGF1ParameterSpec;
 32 import java.security.spec.PSSParameterSpec;
<a name="2" id="anc2"></a><span class="line-added"> 33 import java.util.AbstractMap.SimpleImmutableEntry;</span>
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.Collection;
 37 import java.util.Collections;
 38 import java.util.EnumSet;
 39 import java.util.LinkedList;
 40 import java.util.List;
<a name="3" id="anc3"></a><span class="line-added"> 41 import java.util.Map;</span>
 42 import java.util.Set;
<a name="4" id="anc4"></a><span class="line-modified"> 43 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
<span class="line-modified"> 44 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;</span>
<span class="line-added"> 45 import sun.security.ssl.X509Authentication.X509Possession;</span>
 46 import sun.security.util.KeyUtil;
<a name="5" id="anc5"></a><span class="line-added"> 47 import sun.security.util.SignatureUtil;</span>
 48 
 49 enum SignatureScheme {
 50     // EdDSA algorithms
 51     ED25519                 (0x0807, &quot;ed25519&quot;, &quot;ed25519&quot;,
 52                                     &quot;ed25519&quot;,
 53                                     ProtocolVersion.PROTOCOLS_OF_13),
 54     ED448                   (0x0808, &quot;ed448&quot;, &quot;ed448&quot;,
 55                                     &quot;ed448&quot;,
 56                                     ProtocolVersion.PROTOCOLS_OF_13),
 57 
 58     // ECDSA algorithms
 59     ECDSA_SECP256R1_SHA256  (0x0403, &quot;ecdsa_secp256r1_sha256&quot;,
 60                                     &quot;SHA256withECDSA&quot;,
 61                                     &quot;EC&quot;,
 62                                     NamedGroup.SECP256_R1,
 63                                     ProtocolVersion.PROTOCOLS_TO_13),
 64     ECDSA_SECP384R1_SHA384  (0x0503, &quot;ecdsa_secp384r1_sha384&quot;,
 65                                     &quot;SHA384withECDSA&quot;,
 66                                     &quot;EC&quot;,
 67                                     NamedGroup.SECP384_R1,
 68                                     ProtocolVersion.PROTOCOLS_TO_13),
 69     ECDSA_SECP521R1_SHA512  (0x0603, &quot;ecdsa_secp521r1_sha512&quot;,
 70                                     &quot;SHA512withECDSA&quot;,
 71                                     &quot;EC&quot;,
 72                                     NamedGroup.SECP521_R1,
 73                                     ProtocolVersion.PROTOCOLS_TO_13),
 74 
 75     // RSASSA-PSS algorithms with public key OID rsaEncryption
 76     //
 77     // The minimalKeySize is calculated as (See RFC 8017 for details):
 78     //     hash length + salt length + 16
 79     RSA_PSS_RSAE_SHA256     (0x0804, &quot;rsa_pss_rsae_sha256&quot;,
 80                                     &quot;RSASSA-PSS&quot;, &quot;RSA&quot;,
 81                                     SigAlgParamSpec.RSA_PSS_SHA256, 528,
 82                                     ProtocolVersion.PROTOCOLS_12_13),
 83     RSA_PSS_RSAE_SHA384     (0x0805, &quot;rsa_pss_rsae_sha384&quot;,
 84                                     &quot;RSASSA-PSS&quot;, &quot;RSA&quot;,
 85                                     SigAlgParamSpec.RSA_PSS_SHA384, 784,
 86                                     ProtocolVersion.PROTOCOLS_12_13),
 87     RSA_PSS_RSAE_SHA512     (0x0806, &quot;rsa_pss_rsae_sha512&quot;,
 88                                     &quot;RSASSA-PSS&quot;, &quot;RSA&quot;,
 89                                     SigAlgParamSpec.RSA_PSS_SHA512, 1040,
 90                                     ProtocolVersion.PROTOCOLS_12_13),
 91 
 92     // RSASSA-PSS algorithms with public key OID RSASSA-PSS
 93     //
 94     // The minimalKeySize is calculated as (See RFC 8017 for details):
 95     //     hash length + salt length + 16
 96     RSA_PSS_PSS_SHA256      (0x0809, &quot;rsa_pss_pss_sha256&quot;,
 97                                     &quot;RSASSA-PSS&quot;, &quot;RSASSA-PSS&quot;,
 98                                     SigAlgParamSpec.RSA_PSS_SHA256, 528,
 99                                     ProtocolVersion.PROTOCOLS_12_13),
100     RSA_PSS_PSS_SHA384      (0x080A, &quot;rsa_pss_pss_sha384&quot;,
101                                     &quot;RSASSA-PSS&quot;, &quot;RSASSA-PSS&quot;,
102                                     SigAlgParamSpec.RSA_PSS_SHA384, 784,
103                                     ProtocolVersion.PROTOCOLS_12_13),
104     RSA_PSS_PSS_SHA512      (0x080B, &quot;rsa_pss_pss_sha512&quot;,
105                                     &quot;RSASSA-PSS&quot;, &quot;RSASSA-PSS&quot;,
106                                     SigAlgParamSpec.RSA_PSS_SHA512, 1040,
107                                     ProtocolVersion.PROTOCOLS_12_13),
108 
109     // RSASSA-PKCS1-v1_5 algorithms
110     RSA_PKCS1_SHA256        (0x0401, &quot;rsa_pkcs1_sha256&quot;, &quot;SHA256withRSA&quot;,
111                                     &quot;RSA&quot;, null, null, 511,
112                                     ProtocolVersion.PROTOCOLS_TO_13,
113                                     ProtocolVersion.PROTOCOLS_TO_12),
114     RSA_PKCS1_SHA384        (0x0501, &quot;rsa_pkcs1_sha384&quot;, &quot;SHA384withRSA&quot;,
115                                     &quot;RSA&quot;, null, null, 768,
116                                     ProtocolVersion.PROTOCOLS_TO_13,
117                                     ProtocolVersion.PROTOCOLS_TO_12),
118     RSA_PKCS1_SHA512        (0x0601, &quot;rsa_pkcs1_sha512&quot;, &quot;SHA512withRSA&quot;,
119                                     &quot;RSA&quot;, null, null, 768,
120                                     ProtocolVersion.PROTOCOLS_TO_13,
121                                     ProtocolVersion.PROTOCOLS_TO_12),
122 
123     // Legacy algorithms
124     DSA_SHA256              (0x0402, &quot;dsa_sha256&quot;, &quot;SHA256withDSA&quot;,
125                                     &quot;DSA&quot;,
126                                     ProtocolVersion.PROTOCOLS_TO_12),
127     ECDSA_SHA224            (0x0303, &quot;ecdsa_sha224&quot;, &quot;SHA224withECDSA&quot;,
128                                     &quot;EC&quot;,
129                                     ProtocolVersion.PROTOCOLS_TO_12),
130     RSA_SHA224              (0x0301, &quot;rsa_sha224&quot;, &quot;SHA224withRSA&quot;,
131                                     &quot;RSA&quot;, 511,
132                                     ProtocolVersion.PROTOCOLS_TO_12),
133     DSA_SHA224              (0x0302, &quot;dsa_sha224&quot;, &quot;SHA224withDSA&quot;,
134                                     &quot;DSA&quot;,
135                                     ProtocolVersion.PROTOCOLS_TO_12),
136     ECDSA_SHA1              (0x0203, &quot;ecdsa_sha1&quot;, &quot;SHA1withECDSA&quot;,
137                                     &quot;EC&quot;,
138                                     ProtocolVersion.PROTOCOLS_TO_13),
139     RSA_PKCS1_SHA1          (0x0201, &quot;rsa_pkcs1_sha1&quot;, &quot;SHA1withRSA&quot;,
140                                     &quot;RSA&quot;, null, null, 511,
141                                     ProtocolVersion.PROTOCOLS_TO_13,
142                                     ProtocolVersion.PROTOCOLS_TO_12),
143     DSA_SHA1                (0x0202, &quot;dsa_sha1&quot;, &quot;SHA1withDSA&quot;,
144                                     &quot;DSA&quot;,
145                                     ProtocolVersion.PROTOCOLS_TO_12),
146     RSA_MD5                 (0x0101, &quot;rsa_md5&quot;, &quot;MD5withRSA&quot;,
147                                     &quot;RSA&quot;, 511,
148                                     ProtocolVersion.PROTOCOLS_TO_12);
149 
150     final int id;                       // hash + signature
151     final String name;                  // literal name
152     private final String algorithm;     // signature algorithm
153     final String keyAlgorithm;          // signature key algorithm
<a name="6" id="anc6"></a><span class="line-modified">154     private final SigAlgParamSpec signAlgParams;    // signature parameters</span>
155     private final NamedGroup namedGroup;    // associated named group
156 
157     // The minimal required key size in bits.
158     //
159     // Only need to check RSA algorithm at present. RSA keys of 512 bits
160     // have been shown to be practically breakable, it does not make much
161     // sense to use the strong hash algorithm for keys whose key size less
162     // than 512 bits.  So it is not necessary to calculate the minimal
163     // required key size exactly for a hash algorithm.
164     //
165     // Note that some provider may use 511 bits for 512-bit strength RSA keys.
166     final int minimalKeySize;
167     final List&lt;ProtocolVersion&gt; supportedProtocols;
168 
169     // Some signature schemes are supported in different versions for handshake
170     // messages and certificates. This field holds the supported protocols
171     // for handshake messages.
172     final List&lt;ProtocolVersion&gt; handshakeSupportedProtocols;
173     final boolean isAvailable;
174 
175     private static final String[] hashAlgorithms = new String[] {
176             &quot;none&quot;,         &quot;md5&quot;,      &quot;sha1&quot;,     &quot;sha224&quot;,
177             &quot;sha256&quot;,       &quot;sha384&quot;,   &quot;sha512&quot;
178         };
179 
180     private static final String[] signatureAlgorithms = new String[] {
181             &quot;anonymous&quot;,    &quot;rsa&quot;,      &quot;dsa&quot;,      &quot;ecdsa&quot;,
182         };
183 
184     static enum SigAlgParamSpec {   // support RSASSA-PSS only now
185         RSA_PSS_SHA256 (&quot;SHA-256&quot;, 32),
186         RSA_PSS_SHA384 (&quot;SHA-384&quot;, 48),
187         RSA_PSS_SHA512 (&quot;SHA-512&quot;, 64);
188 
<a name="7" id="anc7"></a><span class="line-modified">189         private final AlgorithmParameterSpec parameterSpec;</span>
<span class="line-modified">190         private final AlgorithmParameters parameters;</span>
<span class="line-added">191         private final boolean isAvailable;</span>
192 
193         SigAlgParamSpec(String hash, int saltLength) {
194             // See RFC 8017
195             PSSParameterSpec pssParamSpec =
196                     new PSSParameterSpec(hash, &quot;MGF1&quot;,
197                             new MGF1ParameterSpec(hash), saltLength, 1);
<a name="8" id="anc8"></a><span class="line-added">198             AlgorithmParameters pssParams = null;</span>
199 
200             boolean mediator = true;
201             try {
202                 Signature signer = Signature.getInstance(&quot;RSASSA-PSS&quot;);
203                 signer.setParameter(pssParamSpec);
<a name="9" id="anc9"></a><span class="line-added">204                 pssParams = signer.getParameters();</span>
205             } catch (InvalidAlgorithmParameterException |
<a name="10" id="anc10"></a><span class="line-modified">206                     NoSuchAlgorithmException | RuntimeException exp) {</span>
<span class="line-added">207                 // Signature.getParameters() may throw RuntimeException.</span>
208                 mediator = false;
209                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
210                     SSLLogger.warning(
211                         &quot;RSASSA-PSS signature with &quot; + hash +
212                         &quot; is not supported by the underlying providers&quot;, exp);
213                 }
214             }
215 
216             this.isAvailable = mediator;
217             this.parameterSpec = mediator ? pssParamSpec : null;
<a name="11" id="anc11"></a><span class="line-modified">218             this.parameters = mediator ? pssParams : null;</span>



219         }
220     }
221 
222     // performance optimization
223     private static final Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
224         Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
225 
226 
227     private SignatureScheme(int id, String name,
228             String algorithm, String keyAlgorithm,
229             ProtocolVersion[] supportedProtocols) {
230         this(id, name, algorithm, keyAlgorithm, -1, supportedProtocols);
231     }
232 
233     private SignatureScheme(int id, String name,
234             String algorithm, String keyAlgorithm,
235             int minimalKeySize,
236             ProtocolVersion[] supportedProtocols) {
237         this(id, name, algorithm, keyAlgorithm,
238                 null, minimalKeySize, supportedProtocols);
239     }
240 
241     private SignatureScheme(int id, String name,
242             String algorithm, String keyAlgorithm,
243             SigAlgParamSpec signAlgParamSpec, int minimalKeySize,
244             ProtocolVersion[] supportedProtocols) {
245         this(id, name, algorithm, keyAlgorithm,
246                 signAlgParamSpec, null, minimalKeySize,
247                 supportedProtocols, supportedProtocols);
248     }
249 
250     private SignatureScheme(int id, String name,
251             String algorithm, String keyAlgorithm,
252             NamedGroup namedGroup,
253             ProtocolVersion[] supportedProtocols) {
254         this(id, name, algorithm, keyAlgorithm,
255                 null, namedGroup, -1,
256                 supportedProtocols, supportedProtocols);
257     }
258 
259     private SignatureScheme(int id, String name,
260             String algorithm, String keyAlgorithm,
<a name="12" id="anc12"></a><span class="line-modified">261             SigAlgParamSpec signAlgParams,</span>
262             NamedGroup namedGroup, int minimalKeySize,
263             ProtocolVersion[] supportedProtocols,
264             ProtocolVersion[] handshakeSupportedProtocols) {
265         this.id = id;
266         this.name = name;
267         this.algorithm = algorithm;
268         this.keyAlgorithm = keyAlgorithm;
<a name="13" id="anc13"></a><span class="line-modified">269         this.signAlgParams = signAlgParams;</span>

270         this.namedGroup = namedGroup;
271         this.minimalKeySize = minimalKeySize;
272         this.supportedProtocols = Arrays.asList(supportedProtocols);
273         this.handshakeSupportedProtocols =
274                 Arrays.asList(handshakeSupportedProtocols);
275 
276         boolean mediator = true;
<a name="14" id="anc14"></a><span class="line-modified">277         // An EC provider, for example the SunEC provider, may support</span>
<span class="line-modified">278         // AlgorithmParameters but not KeyPairGenerator or Signature.</span>
<span class="line-modified">279         //</span>
<span class="line-modified">280         // Note: Please be careful if removing this block!</span>
<span class="line-modified">281         if (&quot;EC&quot;.equals(keyAlgorithm)) {</span>
<span class="line-modified">282             mediator = JsseJce.isEcAvailable();</span>
<span class="line-modified">283         }</span>
<span class="line-modified">284 </span>
<span class="line-modified">285         // Check the specific algorithm and parameters.</span>
<span class="line-modified">286         if (mediator) {</span>
<span class="line-modified">287             if (signAlgParams != null) {</span>
<span class="line-added">288                 mediator = signAlgParams.isAvailable;</span>
<span class="line-added">289             } else {</span>
<span class="line-added">290                 try {</span>
<span class="line-added">291                     Signature.getInstance(algorithm);</span>
<span class="line-added">292                 } catch (Exception e) {</span>
<span class="line-added">293                     mediator = false;</span>
<span class="line-added">294                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">295                         SSLLogger.warning(</span>
<span class="line-added">296                             &quot;Signature algorithm, &quot; + algorithm +</span>
<span class="line-added">297                             &quot;, is not supported by the underlying providers&quot;);</span>
<span class="line-added">298                     }</span>
299                 }
300             }
301         }
302 
303         if (mediator &amp;&amp; ((id &gt;&gt; 8) &amp; 0xFF) == 0x03) {   // SHA224
304             // There are some problems to use SHA224 on Windows.
305             if (Security.getProvider(&quot;SunMSCAPI&quot;) != null) {
306                 mediator = false;
307             }
308         }
309 
310         this.isAvailable = mediator;
311     }
312 
313     static SignatureScheme valueOf(int id) {
314         for (SignatureScheme ss: SignatureScheme.values()) {
315             if (ss.id == id) {
316                 return ss;
317             }
318         }
319 
320         return null;
321     }
322 
323     static String nameOf(int id) {
324         for (SignatureScheme ss: SignatureScheme.values()) {
325             if (ss.id == id) {
326                 return ss.name;
327             }
328         }
329 
330         // Use TLS 1.2 style name for unknown signature scheme.
331         int hashId = ((id &gt;&gt; 8) &amp; 0xFF);
332         int signId = (id &amp; 0xFF);
333         String hashName = (hashId &gt;= hashAlgorithms.length) ?
334             &quot;UNDEFINED-HASH(&quot; + hashId + &quot;)&quot; : hashAlgorithms[hashId];
335         String signName = (signId &gt;= signatureAlgorithms.length) ?
336             &quot;UNDEFINED-SIGNATURE(&quot; + signId + &quot;)&quot; :
337             signatureAlgorithms[signId];
338 
339         return signName + &quot;_&quot; + hashName;
340     }
341 
342     // Return the size of a SignatureScheme structure in TLS record
343     static int sizeInRecord() {
344         return 2;
345     }
346 
<a name="15" id="anc15"></a><span class="line-added">347     private boolean isPermitted(AlgorithmConstraints constraints) {</span>
<span class="line-added">348         return constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">349                         this.name, null) &amp;&amp;</span>
<span class="line-added">350                constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">351                         this.keyAlgorithm, null) &amp;&amp;</span>
<span class="line-added">352                constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">353                         this.algorithm, (signAlgParams != null ?</span>
<span class="line-added">354                                 signAlgParams.parameters : null)) &amp;&amp;</span>
<span class="line-added">355                (namedGroup != null ?</span>
<span class="line-added">356                         namedGroup.isPermitted(constraints) : true);</span>
<span class="line-added">357     }</span>
<span class="line-added">358 </span>
359     // Get local supported algorithm collection complying to algorithm
360     // constraints.
361     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
362             AlgorithmConstraints constraints,
363             List&lt;ProtocolVersion&gt; activeProtocols) {
364         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
365         for (SignatureScheme ss: SignatureScheme.values()) {
366             if (!ss.isAvailable) {
367                 continue;
368             }
369 
370             boolean isMatch = false;
371             for (ProtocolVersion pv : activeProtocols) {
372                 if (ss.supportedProtocols.contains(pv)) {
373                     isMatch = true;
374                     break;
375                 }
376             }
377 
378             if (isMatch) {
<a name="16" id="anc16"></a><span class="line-modified">379                 if (ss.isPermitted(constraints)) {</span>

380                     supported.add(ss);
381                 } else if (SSLLogger.isOn &amp;&amp;
382                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
383                     SSLLogger.finest(
384                         &quot;Ignore disabled signature scheme: &quot; + ss.name);
385                 }
386             } else if (SSLLogger.isOn &amp;&amp;
387                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
388                 SSLLogger.finest(
389                     &quot;Ignore inactive signature scheme: &quot; + ss.name);
390             }
391         }
392 
393         return supported;
394     }
395 
396     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
397             AlgorithmConstraints constraints,
398             ProtocolVersion protocolVersion, int[] algorithmIds) {
399         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
400         for (int ssid : algorithmIds) {
401             SignatureScheme ss = SignatureScheme.valueOf(ssid);
402             if (ss == null) {
403                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
404                     SSLLogger.warning(
405                             &quot;Unsupported signature scheme: &quot; +
406                             SignatureScheme.nameOf(ssid));
407                 }
408             } else if (ss.isAvailable &amp;&amp;
409                     ss.supportedProtocols.contains(protocolVersion) &amp;&amp;
<a name="17" id="anc17"></a><span class="line-modified">410                     ss.isPermitted(constraints)) {</span>

411                 supported.add(ss);
412             } else {
413                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
414                     SSLLogger.warning(
415                             &quot;Unsupported signature scheme: &quot; + ss.name);
416                 }
417             }
418         }
419 
420         return supported;
421     }
422 
423     static SignatureScheme getPreferableAlgorithm(
<a name="18" id="anc18"></a><span class="line-added">424             AlgorithmConstraints constraints,</span>
425             List&lt;SignatureScheme&gt; schemes,
426             SignatureScheme certScheme,
427             ProtocolVersion version) {
428 
429         for (SignatureScheme ss : schemes) {
430             if (ss.isAvailable &amp;&amp;
431                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
<a name="19" id="anc19"></a><span class="line-modified">432                     certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;</span>
<span class="line-modified">433                     ss.isPermitted(constraints)) {</span>
434                 return ss;
435             }
436         }
437 
438         return null;
439     }
440 
<a name="20" id="anc20"></a><span class="line-modified">441     static Map.Entry&lt;SignatureScheme, Signature&gt; getSignerOfPreferableAlgorithm(</span>
<span class="line-added">442             AlgorithmConstraints constraints,</span>
443             List&lt;SignatureScheme&gt; schemes,
<a name="21" id="anc21"></a><span class="line-modified">444             X509Possession x509Possession,</span>
445             ProtocolVersion version) {
446 
<a name="22" id="anc22"></a><span class="line-added">447         PrivateKey signingKey = x509Possession.popPrivateKey;</span>
448         String keyAlgorithm = signingKey.getAlgorithm();
449         int keySize;
450         // Only need to check RSA algorithm at present.
451         if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;) ||
452                 keyAlgorithm.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
453             keySize = KeyUtil.getKeySize(signingKey);
454         } else {
455             keySize = Integer.MAX_VALUE;
456         }
457         for (SignatureScheme ss : schemes) {
458             if (ss.isAvailable &amp;&amp; (keySize &gt;= ss.minimalKeySize) &amp;&amp;
<a name="23" id="anc23"></a><span class="line-modified">459                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;</span>
<span class="line-modified">460                     keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;</span>
<span class="line-modified">461                     ss.isPermitted(constraints)) {</span>
<span class="line-modified">462                 if ((ss.namedGroup != null) &amp;&amp; (ss.namedGroup.spec ==</span>
<span class="line-added">463                         NamedGroupSpec.NAMED_GROUP_ECDHE)) {</span>
464                     ECParameterSpec params =
<a name="24" id="anc24"></a><span class="line-modified">465                             x509Possession.getECParameterSpec();</span>
<span class="line-modified">466                     if (params != null &amp;&amp;</span>
<span class="line-modified">467                             ss.namedGroup == NamedGroup.valueOf(params)) {</span>
<span class="line-added">468                         Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">469                         if (signer != null) {</span>
<span class="line-added">470                             return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">471                         }</span>
<span class="line-added">472                     }</span>
<span class="line-added">473 </span>
<span class="line-added">474                     if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">475                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">476                         SSLLogger.finest(</span>
<span class="line-added">477                             &quot;Ignore the signature algorithm (&quot; + ss +</span>
<span class="line-added">478                             &quot;), unsupported EC parameter spec: &quot; + params);</span>
<span class="line-added">479                     }</span>
<span class="line-added">480                 } else if (&quot;EC&quot;.equals(ss.keyAlgorithm)) {</span>
<span class="line-added">481                     // Must be a legacy signature algorithm, which does not</span>
<span class="line-added">482                     // specify the associated named groups.  The connection</span>
<span class="line-added">483                     // cannot be established if the peer cannot recognize</span>
<span class="line-added">484                     // the named group used for the signature.  RFC 8446</span>
<span class="line-added">485                     // does not define countermeasures for the corner cases.</span>
<span class="line-added">486                     // In order to mitigate the impact, we choose to check</span>
<span class="line-added">487                     // against the local supported named groups.  The risk</span>
<span class="line-added">488                     // should be minimal as applications should not use</span>
<span class="line-added">489                     // unsupported named groups for its certificates.</span>
<span class="line-added">490                     ECParameterSpec params =</span>
<span class="line-added">491                             x509Possession.getECParameterSpec();</span>
<span class="line-added">492                     if (params != null) {</span>
<span class="line-added">493                         NamedGroup keyGroup = NamedGroup.valueOf(params);</span>
<span class="line-added">494                         if (keyGroup != null &amp;&amp;</span>
<span class="line-added">495                                 SupportedGroups.isSupported(keyGroup)) {</span>
<span class="line-added">496                             Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">497                             if (signer != null) {</span>
<span class="line-added">498                                 return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">499                             }</span>
<span class="line-added">500                         }</span>
<span class="line-added">501                     }</span>
<span class="line-added">502 </span>
<span class="line-added">503                     if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">504                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">505                         SSLLogger.finest(</span>
<span class="line-added">506                             &quot;Ignore the legacy signature algorithm (&quot; + ss +</span>
<span class="line-added">507                             &quot;), unsupported EC parameter spec: &quot; + params);</span>
508                     }
509                 } else {
<a name="25" id="anc25"></a><span class="line-modified">510                     Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">511                     if (signer != null) {</span>
<span class="line-added">512                         return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">513                     }</span>
514                 }
515             }
516         }
517 
518         return null;
519     }
520 
521     static String[] getAlgorithmNames(Collection&lt;SignatureScheme&gt; schemes) {
522         if (schemes != null) {
523             ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(schemes.size());
524             for (SignatureScheme scheme : schemes) {
525                 names.add(scheme.algorithm);
526             }
527 
528             return names.toArray(new String[0]);
529         }
530 
531         return new String[0];
532     }
533 
<a name="26" id="anc26"></a><span class="line-modified">534     // This method is used to get the signature instance of this signature</span>
<span class="line-added">535     // scheme for the specific public key.  Unlike getSigner(), the exception</span>
<span class="line-added">536     // is bubbled up.  If the public key does not support this signature</span>
<span class="line-added">537     // scheme, it normally means the TLS handshaking cannot continue and</span>
<span class="line-added">538     // the connection should be terminated.</span>
<span class="line-added">539     Signature getVerifier(PublicKey publicKey) throws NoSuchAlgorithmException,</span>
540             InvalidAlgorithmParameterException, InvalidKeyException {
541         if (!isAvailable) {
542             return null;
543         }
544 
<a name="27" id="anc27"></a><span class="line-modified">545         Signature verifier = Signature.getInstance(algorithm);</span>
<span class="line-modified">546         SignatureUtil.initVerifyWithParam(verifier, publicKey,</span>
<span class="line-modified">547                 (signAlgParams != null ? signAlgParams.parameterSpec : null));</span>
<span class="line-modified">548 </span>
<span class="line-modified">549         return verifier;</span>
<span class="line-added">550     }</span>
<span class="line-added">551 </span>
<span class="line-added">552     // This method is also used to choose preferable signature scheme for the</span>
<span class="line-added">553     // specific private key.  If the private key does not support the signature</span>
<span class="line-added">554     // scheme, {@code null} is returned, and the caller may fail back to next</span>
<span class="line-added">555     // available signature scheme.</span>
<span class="line-added">556     private Signature getSigner(PrivateKey privateKey) {</span>
<span class="line-added">557         if (!isAvailable) {</span>
<span class="line-added">558             return null;</span>
559         }
560 
<a name="28" id="anc28"></a><span class="line-modified">561         try {</span>
<span class="line-modified">562             Signature signer = Signature.getInstance(algorithm);</span>
<span class="line-modified">563             SignatureUtil.initSignWithParam(signer, privateKey,</span>
<span class="line-modified">564                 (signAlgParams != null ? signAlgParams.parameterSpec : null),</span>
<span class="line-modified">565                 null);</span>
<span class="line-added">566             return signer;</span>
<span class="line-added">567         } catch (NoSuchAlgorithmException | InvalidKeyException |</span>
<span class="line-added">568                 InvalidAlgorithmParameterException nsae) {</span>
<span class="line-added">569             if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">570                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">571                 SSLLogger.finest(</span>
<span class="line-added">572                     &quot;Ignore unsupported signature algorithm (&quot; +</span>
<span class="line-added">573                     this.name + &quot;)&quot;, nsae);</span>
<span class="line-added">574             }</span>
575         }
576 
<a name="29" id="anc29"></a><span class="line-modified">577         return null;</span>
578     }
579 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
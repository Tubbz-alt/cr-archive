<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/reflect/annotation/AnnotatedTypeFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.reflect.annotation;
 27 
 28 import java.lang.annotation.*;
 29 import java.lang.reflect.*;
 30 import java.util.ArrayList;
 31 import java.util.Arrays;
 32 import java.util.List;
 33 import java.util.Map;
 34 import java.util.Objects;
 35 import java.util.StringJoiner;
 36 import java.util.stream.Stream;
 37 import java.util.stream.Collectors;
 38 
 39 import static sun.reflect.annotation.TypeAnnotation.*;
 40 
 41 public final class AnnotatedTypeFactory {
 42     /**
 43      * Create an AnnotatedType.
 44      *
 45      * @param type the type this AnnotatedType corresponds to
 46      * @param currentLoc the location this AnnotatedType corresponds to
 47      * @param actualTypeAnnos the type annotations this AnnotatedType has
 48      * @param allOnSameTarget all type annotation on the same TypeAnnotationTarget
 49      *                          as the AnnotatedType being built
 50      * @param decl the declaration having the type use this AnnotatedType
 51      *                          corresponds to
 52      */
 53     public static AnnotatedType buildAnnotatedType(Type type,
 54             LocationInfo currentLoc,
 55             TypeAnnotation[] actualTypeAnnos,
 56             TypeAnnotation[] allOnSameTarget,
 57             AnnotatedElement decl) {
 58         if (type == null) {
 59             return EMPTY_ANNOTATED_TYPE;
 60         }
 61         if (isArray(type))
 62             return new AnnotatedArrayTypeImpl(type,
 63                     currentLoc,
 64                     actualTypeAnnos,
 65                     allOnSameTarget,
 66                     decl);
 67         if (type instanceof Class) {
 68             return new AnnotatedTypeBaseImpl(type,
 69                     currentLoc,
 70                     actualTypeAnnos,
 71                     allOnSameTarget,
 72                     decl);
 73         } else if (type instanceof TypeVariable) {
 74             return new AnnotatedTypeVariableImpl((TypeVariable)type,
 75                     currentLoc,
 76                     actualTypeAnnos,
 77                     allOnSameTarget,
 78                     decl);
 79         } else if (type instanceof ParameterizedType) {
 80             return new AnnotatedParameterizedTypeImpl((ParameterizedType)type,
 81                     currentLoc,
 82                     actualTypeAnnos,
 83                     allOnSameTarget,
 84                     decl);
 85         } else if (type instanceof WildcardType) {
 86             return new AnnotatedWildcardTypeImpl((WildcardType) type,
 87                     currentLoc,
 88                     actualTypeAnnos,
 89                     allOnSameTarget,
 90                     decl);
 91         }
 92         throw new AssertionError(&quot;Unknown instance of Type: &quot; + type + &quot;\nThis should not happen.&quot;);
 93     }
 94 
 95     public static LocationInfo nestingForType(Type type, LocationInfo addTo) {
 96         if (isArray(type))
 97             return addTo;
 98         if (type instanceof Class) {
 99             Class&lt;?&gt; clz = (Class)type;
100             if (clz.getEnclosingClass() == null)
101                 return addTo;
102             if (Modifier.isStatic(clz.getModifiers()))
103                 return addTo;
104             return nestingForType(clz.getEnclosingClass(), addTo.pushInner());
105         } else if (type instanceof ParameterizedType) {
106             ParameterizedType t = (ParameterizedType)type;
107             if (t.getOwnerType() == null)
108                 return addTo;
109             if (t.getRawType() instanceof Class
110                     &amp;&amp; Modifier.isStatic(((Class) t.getRawType()).getModifiers()))
111                 return addTo;
112             return nestingForType(t.getOwnerType(), addTo.pushInner());
113         }
114         return addTo;
115     }
116 
117     private static boolean isArray(Type t) {
118         if (t instanceof Class) {
119             Class&lt;?&gt; c = (Class)t;
120             if (c.isArray())
121                 return true;
122         } else if (t instanceof GenericArrayType) {
123             return true;
124         }
125         return false;
126     }
127 
128     static final TypeAnnotation[] EMPTY_TYPE_ANNOTATION_ARRAY = new TypeAnnotation[0];
129     static final AnnotatedType EMPTY_ANNOTATED_TYPE = new AnnotatedTypeBaseImpl(null, LocationInfo.BASE_LOCATION,
130             EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY, null);
131     static final AnnotatedType[] EMPTY_ANNOTATED_TYPE_ARRAY = new AnnotatedType[0];
132 
133     /*
134      * Note that if additional subclasses of AnnotatedTypeBaseImpl are
135      * added, the equals methods of AnnotatedTypeBaseImpl will need to
136      * be updated to properly implement the equals contract.
137      */
138 
139     private static class AnnotatedTypeBaseImpl implements AnnotatedType {
140         private final Type type;
141         private final AnnotatedElement decl;
142         private final LocationInfo location;
143         private final TypeAnnotation[] allOnSameTargetTypeAnnotations;
144         private final Map&lt;Class &lt;? extends Annotation&gt;, Annotation&gt; annotations;
145 
146         AnnotatedTypeBaseImpl(Type type, LocationInfo location,
147                 TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
148                 AnnotatedElement decl) {
149             this.type = type;
150             this.decl = decl;
151             this.location = location;
152             this.allOnSameTargetTypeAnnotations = allOnSameTargetTypeAnnotations;
153             this.annotations = TypeAnnotationParser.mapTypeAnnotations(location.filter(actualTypeAnnotations));
154         }
155 
156         // AnnotatedElement
157         @Override
158         public final Annotation[] getAnnotations() {
159             return getDeclaredAnnotations();
160         }
161 
162         @Override
163         public final &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotation) {
164             return getDeclaredAnnotation(annotation);
165         }
166 
167         @Override
168         public final &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotation) {
169             return getDeclaredAnnotationsByType(annotation);
170         }
171 
172         @Override
173         public final Annotation[] getDeclaredAnnotations() {
174             return annotations.values().toArray(new Annotation[0]);
175         }
176 
177         @Override
178         @SuppressWarnings(&quot;unchecked&quot;)
179         public final &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotation) {
180             return (T)annotations.get(annotation);
181         }
182 
183         @Override
184         public final &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotation) {
185             return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotations, annotation);
186         }
187 
188         // AnnotatedType
189         @Override
190         public final Type getType() {
191             return type;
192         }
193 
194         @Override
195         public AnnotatedType getAnnotatedOwnerType() {
196             if (!(type instanceof Class&lt;?&gt;))
197                 throw new IllegalStateException(&quot;Can&#39;t compute owner&quot;);
198 
199             Class&lt;?&gt; nested = (Class&lt;?&gt;)type;
200             Class&lt;?&gt; owner = nested.getDeclaringClass();
201             if (owner == null) // top-level, local or anonymous
202                 return null;
203             if (nested.isPrimitive() || nested == Void.TYPE)
204                 return null;
205 
206             LocationInfo outerLoc = getLocation().popLocation((byte)1);
207             if (outerLoc == null) {
208               return buildAnnotatedType(owner, LocationInfo.BASE_LOCATION,
209                       EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY, getDecl());
210             }
211             TypeAnnotation[]all = getTypeAnnotations();
212             List&lt;TypeAnnotation&gt; l = new ArrayList&lt;&gt;(all.length);
213 
214             for (TypeAnnotation t : all)
215                 if (t.getLocationInfo().isSameLocationInfo(outerLoc))
216                     l.add(t);
217 
218             return buildAnnotatedType(owner, outerLoc, l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY), all, getDecl());
219 
220         }
221 
222         @Override // java.lang.Object
223         public String toString() {
224             // Reusable toString implementation, but needs to be
225             // specialized for quirks of arrays and interior types of
226             // wildcards, etc.
227             return annotationsToString(getAnnotations(), false) +
228                 ((type instanceof Class) ? type.getTypeName(): type.toString());
229         }
230 
231         protected String annotationsToString(Annotation[] annotations, boolean leadingSpace) {
232             if (annotations != null &amp;&amp; annotations.length &gt; 0) {
233                 StringBuffer sb = new StringBuffer();
234 
235                 sb.append(Stream.of(annotations).
236                           map(Annotation::toString).
237                           collect(Collectors.joining(&quot; &quot;)));
238 
239                 if (leadingSpace)
240                     sb.insert(0, &quot; &quot;);
241                 else
242                     sb.append(&quot; &quot;);
243 
244                 return sb.toString();
245             } else {
246                 return &quot;&quot;;
247             }
248         }
249 
250         protected boolean equalsTypeAndAnnotations(AnnotatedType that) {
251             return getType().equals(that.getType()) &amp;&amp;
252                 // Treat ordering of annotations as significant
253                 Arrays.equals(getAnnotations(), that.getAnnotations()) &amp;&amp;
254                 Objects.equals(getAnnotatedOwnerType(), that.getAnnotatedOwnerType());
255         }
256 
257         int baseHashCode() {
258             return type.hashCode() ^
259                 // Acceptable to use Objects.hash rather than
260                 // Arrays.deepHashCode since the elements of the array
261                 // are not themselves arrays.
262                 Objects.hash((Object[])getAnnotations()) ^
263                 Objects.hash(getAnnotatedOwnerType());
264         }
265 
266         @Override
267         public boolean equals(Object o) {
268             if (o instanceof AnnotatedType &amp;&amp;
269                 !(o instanceof AnnotatedArrayType) &amp;&amp;
270                 !(o instanceof AnnotatedTypeVariable) &amp;&amp;
271                 !(o instanceof AnnotatedParameterizedType) &amp;&amp;
272                 !(o instanceof AnnotatedWildcardType)) {
273                 AnnotatedType that = (AnnotatedType) o;
274                 return equalsTypeAndAnnotations(that);
275             } else {
276                 return false;
277             }
278         }
279 
280         @Override
281         public int hashCode() {
282             return baseHashCode();
283         }
284 
285         // Implementation details
286         final LocationInfo getLocation() {
287             return location;
288         }
289         final TypeAnnotation[] getTypeAnnotations() {
290             return allOnSameTargetTypeAnnotations;
291         }
292         final AnnotatedElement getDecl() {
293             return decl;
294         }
295     }
296 
297     private static final class AnnotatedArrayTypeImpl extends AnnotatedTypeBaseImpl implements AnnotatedArrayType {
298         AnnotatedArrayTypeImpl(Type type, LocationInfo location,
299                 TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
300                 AnnotatedElement decl) {
301             super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
302         }
303 
304         @Override
305         public AnnotatedType getAnnotatedGenericComponentType() {
306             Type t = getComponentType();
307             return AnnotatedTypeFactory.buildAnnotatedType(t,
308                     nestingForType(t, getLocation().pushArray()),
309                     getTypeAnnotations(),
310                     getTypeAnnotations(),
311                     getDecl());
312         }
313 
314         @Override
315         public AnnotatedType getAnnotatedOwnerType() {
316             return null;
317         }
318 
319         private Type getComponentType() {
320             Type t = getType();
321             if (t instanceof Class) {
322                 Class&lt;?&gt; c = (Class)t;
323                 return c.getComponentType();
324             }
325             return ((GenericArrayType)t).getGenericComponentType();
326         }
327 
328         @Override
329         public String toString() {
330             // To annotate the full type of an array, the annotations
331             // are placed between the type and the brackets. For
332             // example, to annotate an array of Strings, the syntax used is
333             //
334             // String @TypeAnnotation []
335             //
336             // and *not*
337             //
338             // @TypeAnnotation String[].
339             //
340             // The toString output should strive to be reusable in
341             // source code. Therefore, the general logic of putting
342             // the annotations before a textual representation of the
343             // type need to be overridden for arrays.
344             StringBuilder sb = new StringBuilder();
345 
346             AnnotatedType componentType = this;
347             while (componentType instanceof AnnotatedArrayType) {
348                 AnnotatedArrayType annotatedArrayType = (AnnotatedArrayType) componentType;
349                 sb.append(annotationsToString(annotatedArrayType.getAnnotations(), true) + &quot;[]&quot;);
350                 componentType = annotatedArrayType.getAnnotatedGenericComponentType();
351             }
352 
353             sb.insert(0, componentType.toString());
354             return sb.toString();
355         }
356 
357         @Override
358         public boolean equals(Object o) {
359             if (o instanceof AnnotatedArrayType) {
360                 AnnotatedArrayType that = (AnnotatedArrayType) o;
361                 return equalsTypeAndAnnotations(that) &amp;&amp;
362                     Objects.equals(getAnnotatedGenericComponentType(),
363                                    that.getAnnotatedGenericComponentType());
364             } else {
365                 return false;
366             }
367         }
368 
369         @Override
370         public int hashCode() {
371             return baseHashCode() ^ getAnnotatedGenericComponentType().hashCode();
372         }
373     }
374 
375     private static final class AnnotatedTypeVariableImpl extends AnnotatedTypeBaseImpl implements AnnotatedTypeVariable {
376         AnnotatedTypeVariableImpl(TypeVariable&lt;?&gt; type, LocationInfo location,
377                 TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
378                 AnnotatedElement decl) {
379             super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
380         }
381 
382         @Override
383         public AnnotatedType[] getAnnotatedBounds() {
384             return getTypeVariable().getAnnotatedBounds();
385         }
386 
387         @Override
388         public AnnotatedType getAnnotatedOwnerType() {
389             return null;
390         }
391 
392         private TypeVariable&lt;?&gt; getTypeVariable() {
393             return (TypeVariable)getType();
394         }
395 
<a name="2" id="anc2"></a><span class="line-modified">396         // The declaration of a type variable should</span>
<span class="line-modified">397         // include information about its bounds, etc. However, the</span>
398         // use of a type variable should not. For that reason, it is
<a name="3" id="anc3"></a><span class="line-modified">399         // acceptable for the toString and hashCode implementations of</span>
400         // AnnotatedTypeVariableImpl to use the inherited
<a name="4" id="anc4"></a><span class="line-modified">401         // implementations from AnnotatedTypeBaseImpl.</span>
402 
403         @Override
404         public boolean equals(Object o) {
405             if (o instanceof AnnotatedTypeVariable) {
406                 AnnotatedTypeVariable that = (AnnotatedTypeVariable) o;
<a name="5" id="anc5"></a><span class="line-modified">407                 return equalsTypeAndAnnotations(that);</span>

408             } else {
409                 return false;
410             }
411         }
<a name="6" id="anc6"></a>





412     }
413 
414     private static final class AnnotatedParameterizedTypeImpl extends AnnotatedTypeBaseImpl
415             implements AnnotatedParameterizedType {
416         AnnotatedParameterizedTypeImpl(ParameterizedType type, LocationInfo location,
417                 TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
418                 AnnotatedElement decl) {
419             super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
420         }
421 
422         @Override
423         public AnnotatedType[] getAnnotatedActualTypeArguments() {
424             Type[] arguments = getParameterizedType().getActualTypeArguments();
425             AnnotatedType[] res = new AnnotatedType[arguments.length];
426             Arrays.fill(res, EMPTY_ANNOTATED_TYPE);
427             int initialCapacity = getTypeAnnotations().length;
428             for (int i = 0; i &lt; res.length; i++) {
429                 List&lt;TypeAnnotation&gt; l = new ArrayList&lt;&gt;(initialCapacity);
430                 LocationInfo newLoc = nestingForType(arguments[i], getLocation().pushTypeArg((byte)i));
431                 for (TypeAnnotation t : getTypeAnnotations())
432                     if (t.getLocationInfo().isSameLocationInfo(newLoc))
433                         l.add(t);
434                 res[i] = buildAnnotatedType(arguments[i],
435                         newLoc,
436                         l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY),
437                         getTypeAnnotations(),
438                         getDecl());
439             }
440             return res;
441         }
442 
443         @Override
444         public AnnotatedType getAnnotatedOwnerType() {
445             Type owner = getParameterizedType().getOwnerType();
446             if (owner == null)
447                 return null;
448 
449             LocationInfo outerLoc = getLocation().popLocation((byte)1);
450             if (outerLoc == null) {
451               return buildAnnotatedType(owner, LocationInfo.BASE_LOCATION,
452                       EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY, getDecl());
453             }
454             TypeAnnotation[]all = getTypeAnnotations();
455             List&lt;TypeAnnotation&gt; l = new ArrayList&lt;&gt;(all.length);
456 
457             for (TypeAnnotation t : all)
458                 if (t.getLocationInfo().isSameLocationInfo(outerLoc))
459                     l.add(t);
460 
461             return buildAnnotatedType(owner, outerLoc, l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY), all, getDecl());
462         }
463 
464         private ParameterizedType getParameterizedType() {
465             return (ParameterizedType)getType();
466         }
467 
468         @Override
469         public String toString() {
470             StringBuilder sb = new StringBuilder();
471             sb.append(annotationsToString(getAnnotations(), false));
472 
473             Type t = getParameterizedType().getRawType();
474             sb.append(t.getTypeName());
475 
476             AnnotatedType[] typeArgs = getAnnotatedActualTypeArguments();
477             if (typeArgs.length &gt; 0) {
478                 sb.append(Stream.of(typeArgs).map(AnnotatedType::toString).
479                           collect(Collectors.joining(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
480             }
481 
482             return sb.toString();
483         }
484 
485         @Override
486         public boolean equals(Object o) {
487             if (o instanceof AnnotatedParameterizedType) {
488                 AnnotatedParameterizedType that = (AnnotatedParameterizedType) o;
489                 return equalsTypeAndAnnotations(that) &amp;&amp;
490                     Arrays.equals(getAnnotatedActualTypeArguments(), that.getAnnotatedActualTypeArguments());
491             } else {
492                 return false;
493             }
494         }
495 
496         @Override
497         public int hashCode() {
498             return baseHashCode() ^
499                 Objects.hash((Object[])getAnnotatedActualTypeArguments());
500         }
501     }
502 
503     private static final class AnnotatedWildcardTypeImpl extends AnnotatedTypeBaseImpl implements AnnotatedWildcardType {
504         private final boolean hasUpperBounds;
505         AnnotatedWildcardTypeImpl(WildcardType type, LocationInfo location,
506                 TypeAnnotation[] actualTypeAnnotations, TypeAnnotation[] allOnSameTargetTypeAnnotations,
507                 AnnotatedElement decl) {
508             super(type, location, actualTypeAnnotations, allOnSameTargetTypeAnnotations, decl);
509             hasUpperBounds = (type.getLowerBounds().length == 0);
510         }
511 
512         @Override
513         public AnnotatedType[] getAnnotatedUpperBounds() {
514             if (!hasUpperBounds()) {
515                 return new AnnotatedType[] { buildAnnotatedType(Object.class,
516                         LocationInfo.BASE_LOCATION,
517                         EMPTY_TYPE_ANNOTATION_ARRAY,
518                         EMPTY_TYPE_ANNOTATION_ARRAY,
519                         null)
520                 };
521             }
522             return getAnnotatedBounds(getWildcardType().getUpperBounds());
523         }
524 
525         @Override
526         public AnnotatedType[] getAnnotatedLowerBounds() {
527             if (hasUpperBounds)
528                 return new AnnotatedType[0];
529             return getAnnotatedBounds(getWildcardType().getLowerBounds());
530         }
531 
532         @Override
533         public AnnotatedType getAnnotatedOwnerType() {
534             return null;
535         }
536 
537         private AnnotatedType[] getAnnotatedBounds(Type[] bounds) {
538             AnnotatedType[] res = new AnnotatedType[bounds.length];
539             Arrays.fill(res, EMPTY_ANNOTATED_TYPE);
540             int initialCapacity = getTypeAnnotations().length;
541             for (int i = 0; i &lt; res.length; i++) {
542                 LocationInfo newLoc = nestingForType(bounds[i], getLocation().pushWildcard());
543                 List&lt;TypeAnnotation&gt; l = new ArrayList&lt;&gt;(initialCapacity);
544                 for (TypeAnnotation t : getTypeAnnotations())
545                     if (t.getLocationInfo().isSameLocationInfo(newLoc))
546                         l.add(t);
547                 res[i] = buildAnnotatedType(bounds[i],
548                         newLoc,
549                         l.toArray(EMPTY_TYPE_ANNOTATION_ARRAY),
550                         getTypeAnnotations(),
551                         getDecl());
552             }
553             return res;
554         }
555 
556         private WildcardType getWildcardType() {
557             return (WildcardType)getType();
558         }
559 
560         private boolean hasUpperBounds() {
561             return hasUpperBounds;
562         }
563 
564         @Override
565         public String toString() {
566             StringBuilder sb = new StringBuilder();
567             sb.append(annotationsToString(getAnnotations(), false));
568             sb.append(&quot;?&quot;);
569 
570             // Note that the wildcard API is written to accommodate
571             // multiple bounds for wildcards, but at the time of
572             // writing only a single bound is allowed in the
573             // language.
574             AnnotatedType[] bounds = getAnnotatedLowerBounds();
575             if (bounds.length &gt; 0) {
576                 sb.append(&quot; super &quot;);
577             } else {
578                 bounds = getAnnotatedUpperBounds();
579                 if (bounds.length &gt; 0) {
580                     if (bounds.length == 1) {
581                         // Check for and elide &quot; extends java.lang.Object&quot; if a lone
582                         // Object bound is not annotated.
583                         AnnotatedType bound = bounds[0];
584                         if (bound.getType().equals(Object.class) &amp;&amp;
585                             bound.getAnnotations().length == 0) {
586                             return sb.toString();
587                         }
588                     }
589                     sb.append(&quot; extends &quot;);
590                 }
591             }
592 
593             sb.append(Stream.of(bounds).map(AnnotatedType::toString).
594                       collect(Collectors.joining(&quot; &amp; &quot;)));
595 
596             return sb.toString();
597         }
598 
599 
600         @Override
601         public boolean equals(Object o) {
602             if (o instanceof AnnotatedWildcardType) {
603                 AnnotatedWildcardType that = (AnnotatedWildcardType) o;
604                 return equalsTypeAndAnnotations(that) &amp;&amp;
605                     // Treats ordering as significant
606                     Arrays.equals(getAnnotatedLowerBounds(), that.getAnnotatedLowerBounds()) &amp;&amp;
607                     // Treats ordering as significant
608                     Arrays.equals(getAnnotatedUpperBounds(), that.getAnnotatedUpperBounds());
609             } else {
610                 return false;
611             }
612         }
613 
614         @Override
615         public int hashCode() {
616             return baseHashCode() ^
617                 Objects.hash((Object[])getAnnotatedLowerBounds()) ^
618                 Objects.hash((Object[])getAnnotatedUpperBounds());
619         }
620     }
621 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
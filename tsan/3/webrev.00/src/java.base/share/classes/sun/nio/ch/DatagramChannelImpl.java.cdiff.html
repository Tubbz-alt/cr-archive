<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ChannelInputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketAdaptor.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,63 ***</span>
  
  package sun.nio.ch;
  
  import java.io.FileDescriptor;
  import java.io.IOException;
  import java.net.DatagramSocket;
  import java.net.Inet4Address;
  import java.net.Inet6Address;
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.NetworkInterface;
  import java.net.PortUnreachableException;
  import java.net.ProtocolFamily;
  import java.net.SocketAddress;
  import java.net.SocketOption;
  import java.net.StandardProtocolFamily;
  import java.net.StandardSocketOptions;
  import java.nio.ByteBuffer;
  import java.nio.channels.AlreadyBoundException;
  import java.nio.channels.AlreadyConnectedException;
  import java.nio.channels.AsynchronousCloseException;
  import java.nio.channels.ClosedChannelException;
  import java.nio.channels.DatagramChannel;
  import java.nio.channels.MembershipKey;
  import java.nio.channels.NotYetConnectedException;
  import java.nio.channels.SelectionKey;
  import java.nio.channels.spi.SelectorProvider;
  import java.util.Collections;
  import java.util.HashSet;
  import java.util.Objects;
  import java.util.Set;
  import java.util.concurrent.locks.ReentrantLock;
  
  import sun.net.ResourceManager;
  import sun.net.ext.ExtendedSocketOptions;
  
  /**
   * An implementation of DatagramChannels.
   */
  
  class DatagramChannelImpl
      extends DatagramChannel
      implements SelChImpl
  {
      // Used to make native read and write calls
<span class="line-modified">!     private static NativeDispatcher nd = new DatagramDispatcher();</span>
  
      // The protocol family of the socket
      private final ProtocolFamily family;
  
      // Our file descriptor
      private final FileDescriptor fd;
      private final int fdVal;
  
<span class="line-modified">!     // Cached InetAddress and port for unconnected DatagramChannels</span>
<span class="line-modified">!     // used by receive0</span>
<span class="line-modified">!     private InetAddress cachedSenderInetAddress;</span>
<span class="line-modified">!     private int cachedSenderPort;</span>
  
      // Lock held by current reading or connecting thread
      private final ReentrantLock readLock = new ReentrantLock();
  
      // Lock held by current writing or connecting thread
<span class="line-new-header">--- 25,89 ---</span>
  
  package sun.nio.ch;
  
  import java.io.FileDescriptor;
  import java.io.IOException;
<span class="line-added">+ import java.io.UncheckedIOException;</span>
<span class="line-added">+ import java.lang.invoke.MethodHandles;</span>
<span class="line-added">+ import java.lang.invoke.VarHandle;</span>
<span class="line-added">+ import java.lang.ref.Cleaner.Cleanable;</span>
<span class="line-added">+ import java.lang.reflect.Method;</span>
  import java.net.DatagramSocket;
  import java.net.Inet4Address;
  import java.net.Inet6Address;
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.NetworkInterface;
  import java.net.PortUnreachableException;
  import java.net.ProtocolFamily;
  import java.net.SocketAddress;
  import java.net.SocketOption;
<span class="line-added">+ import java.net.SocketTimeoutException;</span>
  import java.net.StandardProtocolFamily;
  import java.net.StandardSocketOptions;
  import java.nio.ByteBuffer;
  import java.nio.channels.AlreadyBoundException;
  import java.nio.channels.AlreadyConnectedException;
  import java.nio.channels.AsynchronousCloseException;
  import java.nio.channels.ClosedChannelException;
  import java.nio.channels.DatagramChannel;
<span class="line-added">+ import java.nio.channels.IllegalBlockingModeException;</span>
  import java.nio.channels.MembershipKey;
  import java.nio.channels.NotYetConnectedException;
  import java.nio.channels.SelectionKey;
<span class="line-added">+ import java.nio.channels.spi.AbstractSelectableChannel;</span>
  import java.nio.channels.spi.SelectorProvider;
<span class="line-added">+ import java.security.AccessController;</span>
<span class="line-added">+ import java.security.PrivilegedExceptionAction;</span>
  import java.util.Collections;
<span class="line-added">+ import java.util.HashMap;</span>
  import java.util.HashSet;
<span class="line-added">+ import java.util.Map;</span>
  import java.util.Objects;
  import java.util.Set;
  import java.util.concurrent.locks.ReentrantLock;
<span class="line-added">+ import java.util.function.Consumer;</span>
  
<span class="line-added">+ import jdk.internal.ref.CleanerFactory;</span>
  import sun.net.ResourceManager;
  import sun.net.ext.ExtendedSocketOptions;
<span class="line-added">+ import sun.net.util.IPAddressUtil;</span>
  
  /**
   * An implementation of DatagramChannels.
   */
  
  class DatagramChannelImpl
      extends DatagramChannel
      implements SelChImpl
  {
      // Used to make native read and write calls
<span class="line-modified">!     private static final NativeDispatcher nd = new DatagramDispatcher();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // true if interruptible (can be false to emulate legacy DatagramSocket)</span>
<span class="line-added">+     private final boolean interruptible;</span>
  
      // The protocol family of the socket
      private final ProtocolFamily family;
  
      // Our file descriptor
      private final FileDescriptor fd;
      private final int fdVal;
  
<span class="line-modified">!     // Native sockaddrs and cached InetSocketAddress for receive, protected by readLock</span>
<span class="line-modified">!     private NativeSocketAddress sourceSockAddr;</span>
<span class="line-modified">!     private NativeSocketAddress cachedSockAddr;</span>
<span class="line-modified">!     private InetSocketAddress cachedInetSocketAddress;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Native sockaddr and cached objects for send, protected by writeLock</span>
<span class="line-added">+     private final NativeSocketAddress targetSockAddr;</span>
<span class="line-added">+     private InetSocketAddress previousTarget;</span>
<span class="line-added">+     private int previousSockAddrLength;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Cleaner to close file descriptor and free native socket address</span>
<span class="line-added">+     private final Cleanable cleaner;</span>
  
      // Lock held by current reading or connecting thread
      private final ReentrantLock readLock = new ReentrantLock();
  
      // Lock held by current writing or connecting thread
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,24 ***</span>
  
      // State (does not necessarily increase monotonically)
      private static final int ST_UNCONNECTED = 0;
      private static final int ST_CONNECTED = 1;
      private static final int ST_CLOSING = 2;
<span class="line-modified">!     private static final int ST_KILLPENDING = 3;</span>
<span class="line-removed">-     private static final int ST_KILLED = 4;</span>
      private int state;
  
      // IDs of native threads doing reads and writes, for signalling
      private long readerThread;
      private long writerThread;
  
<span class="line-modified">!     // Binding and remote address (when connected)</span>
      private InetSocketAddress localAddress;
      private InetSocketAddress remoteAddress;
  
<span class="line-modified">!     // Our socket adaptor, if any</span>
<span class="line-modified">!     private DatagramSocket socket;</span>
  
      // Multicast support
      private MembershipRegistry registry;
  
      // set true when socket is bound and SO_REUSEADDRESS is emulated
<span class="line-new-header">--- 121,35 ---</span>
  
      // State (does not necessarily increase monotonically)
      private static final int ST_UNCONNECTED = 0;
      private static final int ST_CONNECTED = 1;
      private static final int ST_CLOSING = 2;
<span class="line-modified">!     private static final int ST_CLOSED = 3;</span>
      private int state;
  
      // IDs of native threads doing reads and writes, for signalling
      private long readerThread;
      private long writerThread;
  
<span class="line-modified">!     // Local and remote (connected) address</span>
      private InetSocketAddress localAddress;
      private InetSocketAddress remoteAddress;
  
<span class="line-modified">!     // Local address prior to connecting</span>
<span class="line-modified">!     private InetSocketAddress initialLocalAddress;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Socket adaptor, created lazily</span>
<span class="line-added">+     private static final VarHandle SOCKET;</span>
<span class="line-added">+     static {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-added">+             SOCKET = l.findVarHandle(DatagramChannelImpl.class, &quot;socket&quot;, DatagramSocket.class);</span>
<span class="line-added">+         } catch (Exception e) {</span>
<span class="line-added">+             throw new InternalError(e);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     private volatile DatagramSocket socket;</span>
  
      // Multicast support
      private MembershipRegistry registry;
  
      // set true when socket is bound and SO_REUSEADDRESS is emulated
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,66 ***</span>
      // set true/false when socket is already bound and SO_REUSEADDR is emulated
      private boolean isReuseAddress;
  
      // -- End of fields protected by stateLock
  
<span class="line-modified">!     public DatagramChannelImpl(SelectorProvider sp)</span>
<span class="line-modified">!         throws IOException</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         super(sp);</span>
<span class="line-modified">!         ResourceManager.beforeUdpCreate();</span>
<span class="line-modified">!         try {</span>
<span class="line-removed">-             this.family = Net.isIPv6Available()</span>
<span class="line-removed">-                     ? StandardProtocolFamily.INET6</span>
<span class="line-removed">-                     : StandardProtocolFamily.INET;</span>
<span class="line-removed">-             this.fd = Net.socket(family, false);</span>
<span class="line-removed">-             this.fdVal = IOUtil.fdVal(fd);</span>
<span class="line-removed">-         } catch (IOException ioe) {</span>
<span class="line-removed">-             ResourceManager.afterUdpClose();</span>
<span class="line-removed">-             throw ioe;</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     public DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family)</span>
          throws IOException
      {
          super(sp);
          Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
          if ((family != StandardProtocolFamily.INET) &amp;&amp;
<span class="line-modified">!             (family != StandardProtocolFamily.INET6)) {</span>
              throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
          }
<span class="line-modified">!         if (family == StandardProtocolFamily.INET6) {</span>
<span class="line-modified">!             if (!Net.isIPv6Available()) {</span>
<span class="line-removed">-                 throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-removed">-             }</span>
          }
  
          ResourceManager.beforeUdpCreate();
          try {
              this.family = family;
<span class="line-modified">!             this.fd = Net.socket(family, false);</span>
              this.fdVal = IOUtil.fdVal(fd);
<span class="line-modified">!         } catch (IOException ioe) {</span>
<span class="line-modified">!             ResourceManager.afterUdpClose();</span>
<span class="line-modified">!             throw ioe;</span>
          }
      }
  
<span class="line-modified">!     public DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)</span>
          throws IOException
      {
          super(sp);
  
<span class="line-modified">!         // increment UDP count to match decrement when closing</span>
          ResourceManager.beforeUdpCreate();
  
<span class="line-removed">-         this.family = Net.isIPv6Available()</span>
<span class="line-removed">-                 ? StandardProtocolFamily.INET6</span>
<span class="line-removed">-                 : StandardProtocolFamily.INET;</span>
<span class="line-removed">-         this.fd = fd;</span>
<span class="line-removed">-         this.fdVal = IOUtil.fdVal(fd);</span>
          synchronized (stateLock) {
              this.localAddress = Net.localAddress(fd);
          }
      }
  
<span class="line-new-header">--- 158,105 ---</span>
      // set true/false when socket is already bound and SO_REUSEADDR is emulated
      private boolean isReuseAddress;
  
      // -- End of fields protected by stateLock
  
<span class="line-modified">! </span>
<span class="line-modified">!     DatagramChannelImpl(SelectorProvider sp, boolean interruptible) throws IOException {</span>
<span class="line-modified">!         this(sp, (Net.isIPv6Available()</span>
<span class="line-modified">!                 ? StandardProtocolFamily.INET6</span>
<span class="line-modified">!                 : StandardProtocolFamily.INET),</span>
<span class="line-modified">!                 interruptible);</span>
      }
  
<span class="line-modified">!     DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family, boolean interruptible)</span>
          throws IOException
      {
          super(sp);
<span class="line-added">+ </span>
          Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
          if ((family != StandardProtocolFamily.INET) &amp;&amp;
<span class="line-modified">!                 (family != StandardProtocolFamily.INET6)) {</span>
              throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
          }
<span class="line-modified">!         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {</span>
<span class="line-modified">!             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
          }
  
<span class="line-added">+         FileDescriptor fd = null;</span>
<span class="line-added">+         NativeSocketAddress[] sockAddrs = null;</span>
<span class="line-added">+ </span>
          ResourceManager.beforeUdpCreate();
<span class="line-added">+         boolean initialized = false;</span>
          try {
<span class="line-added">+             this.interruptible = interruptible;</span>
              this.family = family;
<span class="line-modified">!             this.fd = fd = Net.socket(family, false);</span>
              this.fdVal = IOUtil.fdVal(fd);
<span class="line-modified">! </span>
<span class="line-modified">!             sockAddrs = NativeSocketAddress.allocate(3);</span>
<span class="line-modified">!             readLock.lock();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 this.sourceSockAddr = sockAddrs[0];</span>
<span class="line-added">+                 this.cachedSockAddr = sockAddrs[1];</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 readLock.unlock();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             this.targetSockAddr = sockAddrs[2];</span>
<span class="line-added">+ </span>
<span class="line-added">+             initialized = true;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             if (!initialized) {</span>
<span class="line-added">+                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added">+                 if (fd != null) nd.close(fd);</span>
<span class="line-added">+                 ResourceManager.afterUdpClose();</span>
<span class="line-added">+             }</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         Runnable releaser = releaserFor(fd, sockAddrs);</span>
<span class="line-added">+         this.cleaner = CleanerFactory.cleaner().register(this, releaser);</span>
      }
  
<span class="line-modified">!     DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)</span>
          throws IOException
      {
          super(sp);
  
<span class="line-modified">!         NativeSocketAddress[] sockAddrs = null;</span>
<span class="line-added">+ </span>
          ResourceManager.beforeUdpCreate();
<span class="line-added">+         boolean initialized = false;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             this.interruptible = true;</span>
<span class="line-added">+             this.family = Net.isIPv6Available()</span>
<span class="line-added">+                     ? StandardProtocolFamily.INET6</span>
<span class="line-added">+                     : StandardProtocolFamily.INET;</span>
<span class="line-added">+             this.fd = fd;</span>
<span class="line-added">+             this.fdVal = IOUtil.fdVal(fd);</span>
<span class="line-added">+ </span>
<span class="line-added">+             sockAddrs = NativeSocketAddress.allocate(3);</span>
<span class="line-added">+             readLock.lock();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 this.sourceSockAddr = sockAddrs[0];</span>
<span class="line-added">+                 this.cachedSockAddr = sockAddrs[1];</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 readLock.unlock();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             this.targetSockAddr = sockAddrs[2];</span>
<span class="line-added">+ </span>
<span class="line-added">+             initialized = true;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             if (!initialized) {</span>
<span class="line-added">+                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added">+                 nd.close(fd);</span>
<span class="line-added">+                 ResourceManager.afterUdpClose();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Runnable releaser = releaserFor(fd, sockAddrs);</span>
<span class="line-added">+         this.cleaner = CleanerFactory.cleaner().register(this, releaser);</span>
  
          synchronized (stateLock) {
              this.localAddress = Net.localAddress(fd);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,15 ***</span>
              throw new ClosedChannelException();
      }
  
      @Override
      public DatagramSocket socket() {
<span class="line-modified">!         synchronized (stateLock) {</span>
<span class="line-modified">!             if (socket == null)</span>
<span class="line-modified">!                 socket = DatagramSocketAdaptor.create(this);</span>
<span class="line-modified">!             return socket;</span>
          }
      }
  
      @Override
      public SocketAddress getLocalAddress() throws IOException {
          synchronized (stateLock) {
<span class="line-new-header">--- 266,18 ---</span>
              throw new ClosedChannelException();
      }
  
      @Override
      public DatagramSocket socket() {
<span class="line-modified">!         DatagramSocket socket = this.socket;</span>
<span class="line-modified">!         if (socket == null) {</span>
<span class="line-modified">!             socket = DatagramSocketAdaptor.create(this);</span>
<span class="line-modified">!             if (!SOCKET.compareAndSet(this, null, socket)) {</span>
<span class="line-added">+                 socket = this.socket;</span>
<span class="line-added">+             }</span>
          }
<span class="line-added">+         return socket;</span>
      }
  
      @Override
      public SocketAddress getLocalAddress() throws IOException {
          synchronized (stateLock) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,57 ***</span>
              ensureOpen();
              return remoteAddress;
          }
      }
  
      @Override
      public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
          throws IOException
      {
          Objects.requireNonNull(name);
          if (!supportedOptions().contains(name))
              throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
  
          synchronized (stateLock) {
              ensureOpen();
  
<span class="line-modified">!             if (name == StandardSocketOptions.IP_TOS ||</span>
<span class="line-modified">!                 name == StandardSocketOptions.IP_MULTICAST_TTL ||</span>
<span class="line-modified">!                 name == StandardSocketOptions.IP_MULTICAST_LOOP)</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 // options are protocol dependent</span>
<span class="line-modified">!                 Net.setSocketOption(fd, family, name, value);</span>
<span class="line-modified">!                 return this;</span>
<span class="line-modified">!             }</span>
  
              if (name == StandardSocketOptions.IP_MULTICAST_IF) {
<span class="line-modified">!                 if (value == null)</span>
<span class="line-modified">!                     throw new IllegalArgumentException(&quot;Cannot set IP_MULTICAST_IF to &#39;null&#39;&quot;);</span>
<span class="line-removed">-                 NetworkInterface interf = (NetworkInterface)value;</span>
                  if (family == StandardProtocolFamily.INET6) {
                      int index = interf.getIndex();
                      if (index == -1)
                          throw new IOException(&quot;Network interface cannot be identified&quot;);
                      Net.setInterface6(fd, index);
<span class="line-modified">!                 } else {</span>
                      // need IPv4 address to identify interface
                      Inet4Address target = Net.anyInet4Address(interf);
<span class="line-modified">!                     if (target == null)</span>
                          throw new IOException(&quot;Network interface not configured for IPv4&quot;);
<span class="line-modified">!                     int targetAddress = Net.inet4AsInt(target);</span>
<span class="line-removed">-                     Net.setInterface4(fd, targetAddress);</span>
                  }
                  return this;
              }
              if (name == StandardSocketOptions.SO_REUSEADDR
                  &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
                  reuseAddressEmulated = true;
                  this.isReuseAddress = (Boolean)value;
              }
  
              // remaining options don&#39;t need any special handling
<span class="line-modified">!             Net.setSocketOption(fd, Net.UNSPEC, name, value);</span>
              return this;
          }
      }
  
      @Override
<span class="line-new-header">--- 293,108 ---</span>
              ensureOpen();
              return remoteAddress;
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the protocol family to specify to set/getSocketOption for the</span>
<span class="line-added">+      * given socket option.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private ProtocolFamily familyFor(SocketOption&lt;?&gt; name) {</span>
<span class="line-added">+         assert Thread.holdsLock(stateLock);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // unspecified (most options)</span>
<span class="line-added">+         if (SocketOptionRegistry.findOption(name, Net.UNSPEC) != null)</span>
<span class="line-added">+             return Net.UNSPEC;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // IPv4 socket</span>
<span class="line-added">+         if (family == StandardProtocolFamily.INET)</span>
<span class="line-added">+             return StandardProtocolFamily.INET;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // IPv6 socket that is unbound</span>
<span class="line-added">+         if (localAddress == null)</span>
<span class="line-added">+             return StandardProtocolFamily.INET6;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // IPv6 socket bound to wildcard or IPv6 address</span>
<span class="line-added">+         InetAddress address = localAddress.getAddress();</span>
<span class="line-added">+         if (address.isAnyLocalAddress() || (address instanceof Inet6Address))</span>
<span class="line-added">+             return StandardProtocolFamily.INET6;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // IPv6 socket bound to IPv4 address</span>
<span class="line-added">+         if (Net.canUseIPv6OptionsWithIPv4LocalAddress()) {</span>
<span class="line-added">+             // IPV6_XXX options can be used</span>
<span class="line-added">+             return StandardProtocolFamily.INET6;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // IPV6_XXX options cannot be used</span>
<span class="line-added">+             return StandardProtocolFamily.INET;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
          throws IOException
      {
          Objects.requireNonNull(name);
          if (!supportedOptions().contains(name))
              throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<span class="line-added">+         if (!name.type().isInstance(value))</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
  
          synchronized (stateLock) {
              ensureOpen();
  
<span class="line-modified">!             ProtocolFamily family = familyFor(name);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Some platforms require both IPV6_XXX and IP_XXX socket options to</span>
<span class="line-modified">!             // be set when the channel&#39;s socket is IPv6 and it is used to send</span>
<span class="line-modified">!             // IPv4 multicast datagrams. The IP_XXX socket options are set on a</span>
<span class="line-modified">!             // best effort basis.</span>
<span class="line-modified">!             boolean needToSetIPv4Option = (family != Net.UNSPEC)</span>
<span class="line-modified">!                     &amp;&amp; (this.family == StandardProtocolFamily.INET6)</span>
<span class="line-added">+                     &amp;&amp; Net.shouldSetBothIPv4AndIPv6Options();</span>
  
<span class="line-added">+             // outgoing multicast interface</span>
              if (name == StandardSocketOptions.IP_MULTICAST_IF) {
<span class="line-modified">!                 assert family != Net.UNSPEC;</span>
<span class="line-modified">!                 NetworkInterface interf = (NetworkInterface) value;</span>
                  if (family == StandardProtocolFamily.INET6) {
                      int index = interf.getIndex();
                      if (index == -1)
                          throw new IOException(&quot;Network interface cannot be identified&quot;);
                      Net.setInterface6(fd, index);
<span class="line-modified">!                 }</span>
<span class="line-added">+                 if (family == StandardProtocolFamily.INET || needToSetIPv4Option) {</span>
                      // need IPv4 address to identify interface
                      Inet4Address target = Net.anyInet4Address(interf);
<span class="line-modified">!                     if (target != null) {</span>
<span class="line-added">+                         try {</span>
<span class="line-added">+                             Net.setInterface4(fd, Net.inet4AsInt(target));</span>
<span class="line-added">+                         } catch (IOException ioe) {</span>
<span class="line-added">+                             if (family == StandardProtocolFamily.INET) throw ioe;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } else if (family == StandardProtocolFamily.INET) {</span>
                          throw new IOException(&quot;Network interface not configured for IPv4&quot;);
<span class="line-modified">!                     }</span>
                  }
                  return this;
              }
<span class="line-added">+ </span>
<span class="line-added">+             // SO_REUSEADDR needs special handling as it may be emulated</span>
              if (name == StandardSocketOptions.SO_REUSEADDR
                  &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
                  reuseAddressEmulated = true;
                  this.isReuseAddress = (Boolean)value;
              }
  
              // remaining options don&#39;t need any special handling
<span class="line-modified">!             Net.setSocketOption(fd, family, name, value);</span>
<span class="line-added">+             if (needToSetIPv4Option &amp;&amp; family != StandardProtocolFamily.INET) {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     Net.setSocketOption(fd, StandardProtocolFamily.INET, name, value);</span>
<span class="line-added">+                 } catch (IOException ignore) { }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              return this;
          }
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,16 ***</span>
              throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
  
          synchronized (stateLock) {
              ensureOpen();
  
<span class="line-modified">!             if (name == StandardSocketOptions.IP_TOS ||</span>
<span class="line-removed">-                 name == StandardSocketOptions.IP_MULTICAST_TTL ||</span>
<span class="line-removed">-                 name == StandardSocketOptions.IP_MULTICAST_LOOP)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 return (T) Net.getSocketOption(fd, family, name);</span>
<span class="line-removed">-             }</span>
  
              if (name == StandardSocketOptions.IP_MULTICAST_IF) {
                  if (family == StandardProtocolFamily.INET) {
                      int address = Net.getInterface4(fd);
                      if (address == 0)
<span class="line-new-header">--- 407,11 ---</span>
              throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
  
          synchronized (stateLock) {
              ensureOpen();
  
<span class="line-modified">!             ProtocolFamily family = familyFor(name);</span>
  
              if (name == StandardSocketOptions.IP_MULTICAST_IF) {
                  if (family == StandardProtocolFamily.INET) {
                      int address = Net.getInterface4(fd);
                      if (address == 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,15 ***</span>
                      return (T) ni;
                  }
              }
  
              if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
<span class="line-modified">!                 return (T)Boolean.valueOf(isReuseAddress);</span>
              }
  
              // no special handling
<span class="line-modified">!             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span>
          }
      }
  
      private static class DefaultOptionsHolder {
          static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
<span class="line-new-header">--- 433,15 ---</span>
                      return (T) ni;
                  }
              }
  
              if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
<span class="line-modified">!                 return (T) Boolean.valueOf(isReuseAddress);</span>
              }
  
              // no special handling
<span class="line-modified">!             return (T) Net.getSocketOption(fd, family, name);</span>
          }
      }
  
      private static class DefaultOptionsHolder {
          static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,11 ***</span>
       * @throws IOException if socket not bound and cannot be bound
       */
      private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
          throws IOException
      {
<span class="line-modified">!         if (blocking) {</span>
              // set hook for Thread.interrupt
              begin();
          }
          SocketAddress remote;
          synchronized (stateLock) {
<span class="line-new-header">--- 480,11 ---</span>
       * @throws IOException if socket not bound and cannot be bound
       */
      private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
          throws IOException
      {
<span class="line-modified">!         if (blocking &amp;&amp; interruptible) {</span>
              // set hook for Thread.interrupt
              begin();
          }
          SocketAddress remote;
          synchronized (stateLock) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,162 ***</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  readerThread = 0;
<span class="line-removed">-                 // notify any thread waiting in implCloseSelectableChannel</span>
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     stateLock.notifyAll();</span>
                  }
              }
<span class="line-modified">!             // remove hook for Thread.interrupt</span>
<span class="line-modified">!             end(completed);</span>
          }
      }
  
<span class="line-removed">-     private SocketAddress sender;       // Set by receive0 (## ugh)</span>
<span class="line-removed">- </span>
      @Override
      public SocketAddress receive(ByteBuffer dst) throws IOException {
          if (dst.isReadOnly())
              throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
<span class="line-removed">- </span>
          readLock.lock();
          try {
              boolean blocking = isBlocking();
<span class="line-modified">!             int n = 0;</span>
<span class="line-removed">-             ByteBuffer bb = null;</span>
              try {
                  SocketAddress remote = beginRead(blocking, false);
                  boolean connected = (remote != null);
                  SecurityManager sm = System.getSecurityManager();
                  if (connected || (sm == null)) {
                      // connected or no security manager
<span class="line-modified">!                     do {</span>
<span class="line-modified">!                         n = receive(fd, dst, connected);</span>
<span class="line-modified">!                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified">!                     if (n == IOStatus.UNAVAILABLE)</span>
<span class="line-modified">!                         return null;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     // Cannot receive into user&#39;s buffer when running with a</span>
<span class="line-removed">-                     // security manager and not connected</span>
<span class="line-removed">-                     bb = Util.getTemporaryDirectBuffer(dst.remaining());</span>
<span class="line-removed">-                     for (;;) {</span>
<span class="line-removed">-                         do {</span>
<span class="line-removed">-                             n = receive(fd, bb, connected);</span>
<span class="line-removed">-                         } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-removed">-                         if (n == IOStatus.UNAVAILABLE)</span>
<span class="line-removed">-                             return null;</span>
<span class="line-removed">-                         InetSocketAddress isa = (InetSocketAddress)sender;</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             sm.checkAccept(isa.getAddress().getHostAddress(),</span>
<span class="line-removed">-                                            isa.getPort());</span>
<span class="line-removed">-                         } catch (SecurityException se) {</span>
<span class="line-removed">-                             // Ignore packet</span>
<span class="line-removed">-                             bb.clear();</span>
<span class="line-removed">-                             n = 0;</span>
<span class="line-removed">-                             continue;</span>
                          }
<span class="line-removed">-                         bb.flip();</span>
<span class="line-removed">-                         dst.put(bb);</span>
<span class="line-removed">-                         break;</span>
                      }
                  }
<span class="line-removed">-                 assert sender != null;</span>
                  return sender;
              } finally {
<span class="line-modified">!                 if (bb != null)</span>
<span class="line-modified">!                     Util.releaseTemporaryDirectBuffer(bb);</span>
<span class="line-modified">!                 endRead(blocking, n &gt; 0);</span>
<span class="line-modified">!                 assert IOStatus.check(n);</span>
              }
          } finally {
              readLock.unlock();
          }
      }
  
<span class="line-modified">!     private int receive(FileDescriptor fd, ByteBuffer dst, boolean connected)</span>
          throws IOException
      {
          int pos = dst.position();
          int lim = dst.limit();
          assert (pos &lt;= lim);
          int rem = (pos &lt;= lim ? lim - pos : 0);
          if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
<span class="line-modified">!             return receiveIntoNativeBuffer(fd, dst, rem, pos, connected);</span>
  
          // Substitute a native buffer. If the supplied buffer is empty
          // we must instead use a nonempty buffer, otherwise the call
          // will not block waiting for a datagram on some platforms.
          int newSize = Math.max(rem, 1);
          ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
          try {
<span class="line-modified">!             int n = receiveIntoNativeBuffer(fd, bb, newSize, 0, connected);</span>
              bb.flip();
              if (n &gt; 0 &amp;&amp; rem &gt; 0)
                  dst.put(bb);
              return n;
          } finally {
              Util.releaseTemporaryDirectBuffer(bb);
          }
      }
  
<span class="line-modified">!     private int receiveIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb,</span>
<span class="line-modified">!                                         int rem, int pos, boolean connected)</span>
          throws IOException
      {
<span class="line-modified">!         int n = receive0(fd, ((DirectBuffer)bb).address() + pos, rem, connected);</span>
          if (n &gt; 0)
              bb.position(pos + n);
          return n;
      }
  
      public int send(ByteBuffer src, SocketAddress target)
          throws IOException
      {
          Objects.requireNonNull(src);
          InetSocketAddress isa = Net.checkAddress(target, family);
  
          writeLock.lock();
          try {
              boolean blocking = isBlocking();
<span class="line-modified">!             int n = 0;</span>
              try {
                  SocketAddress remote = beginWrite(blocking, false);
                  if (remote != null) {
                      // connected
                      if (!target.equals(remote)) {
                          throw new AlreadyConnectedException();
                      }
<span class="line-modified">!                     do {</span>
<span class="line-modified">!                         n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified">!                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
                  } else {
                      // not connected
                      SecurityManager sm = System.getSecurityManager();
                      if (sm != null) {
<span class="line-removed">-                         InetAddress ia = isa.getAddress();</span>
                          if (ia.isMulticastAddress()) {
                              sm.checkMulticast(ia);
                          } else {
                              sm.checkConnect(ia.getHostAddress(), isa.getPort());
                          }
                      }
<span class="line-modified">!                     do {</span>
<span class="line-modified">!                         n = send(fd, src, isa);</span>
<span class="line-modified">!                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
                  }
              } finally {
<span class="line-modified">!                 endWrite(blocking, n &gt; 0);</span>
<span class="line-removed">-                 assert IOStatus.check(n);</span>
              }
              return IOStatus.normalize(n);
          } finally {
              writeLock.unlock();
          }
      }
  
      private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
          throws IOException
      {
          if (src instanceof DirectBuffer)
              return sendFromNativeBuffer(fd, src, target);
<span class="line-new-header">--- 509,348 ---</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  readerThread = 0;
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     tryFinishClose();</span>
                  }
              }
<span class="line-modified">!             if (interruptible) {</span>
<span class="line-modified">!                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)</span>
<span class="line-added">+                 end(completed);</span>
<span class="line-added">+             } else if (!completed &amp;&amp; !isOpen()) {</span>
<span class="line-added">+                 throw new AsynchronousCloseException();</span>
<span class="line-added">+             }</span>
          }
      }
  
      @Override
      public SocketAddress receive(ByteBuffer dst) throws IOException {
          if (dst.isReadOnly())
              throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
          readLock.lock();
          try {
              boolean blocking = isBlocking();
<span class="line-modified">!             SocketAddress sender = null;</span>
              try {
                  SocketAddress remote = beginRead(blocking, false);
                  boolean connected = (remote != null);
                  SecurityManager sm = System.getSecurityManager();
                  if (connected || (sm == null)) {
                      // connected or no security manager
<span class="line-modified">!                     int n = receive(dst, connected);</span>
<span class="line-modified">!                     if (blocking) {</span>
<span class="line-modified">!                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified">!                             park(Net.POLLIN);</span>
<span class="line-modified">!                             n = receive(dst, connected);</span>
                          }
                      }
<span class="line-added">+                     if (n &gt;= 0) {</span>
<span class="line-added">+                         // sender address is in socket address buffer</span>
<span class="line-added">+                         sender = sourceSocketAddress();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // security manager and unconnected</span>
<span class="line-added">+                     sender = untrustedReceive(dst);</span>
                  }
                  return sender;
              } finally {
<span class="line-modified">!                 endRead(blocking, (sender != null));</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             readLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Receives a datagram into an untrusted buffer. When there is a security</span>
<span class="line-added">+      * manager set, and the socket is not connected, datagrams have to be received</span>
<span class="line-added">+      * into a buffer that is not accessible to the user. The datagram is copied</span>
<span class="line-added">+      * into the user&#39;s buffer when the sender address is accepted by the security</span>
<span class="line-added">+      * manager.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private SocketAddress untrustedReceive(ByteBuffer dst) throws IOException {</span>
<span class="line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread()</span>
<span class="line-added">+                 &amp;&amp; sm != null &amp;&amp; remoteAddress == null;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             boolean blocking = isBlocking();</span>
<span class="line-added">+             for (;;) {</span>
<span class="line-added">+                 int n = receive(bb, false);</span>
<span class="line-added">+                 if (blocking) {</span>
<span class="line-added">+                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLIN);</span>
<span class="line-added">+                         n = receive(bb, false);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (n &gt;= 0) {</span>
<span class="line-added">+                     // sender address is in socket address buffer</span>
<span class="line-added">+                     InetSocketAddress isa = sourceSocketAddress();</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added">+                         bb.flip();</span>
<span class="line-added">+                         dst.put(bb);</span>
<span class="line-added">+                         return isa;</span>
<span class="line-added">+                     } catch (SecurityException se) {</span>
<span class="line-added">+                         // ignore datagram</span>
<span class="line-added">+                         bb.clear();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     return null;</span>
<span class="line-added">+                 }</span>
              }
<span class="line-added">+         } finally {</span>
<span class="line-added">+             Util.releaseTemporaryDirectBuffer(bb);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Receives a datagram into the given buffer.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote This method is for use by the socket adaptor. The buffer is</span>
<span class="line-added">+      * assumed to be trusted, meaning it is not accessible to user code.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">+      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {</span>
<span class="line-added">+         readLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             if (!isBlocking())</span>
<span class="line-added">+                 throw new IllegalBlockingModeException();</span>
<span class="line-added">+             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+             boolean connected = isConnected();</span>
<span class="line-added">+             SocketAddress sender;</span>
<span class="line-added">+             do {</span>
<span class="line-added">+                 if (nanos &gt; 0) {</span>
<span class="line-added">+                     sender = trustedBlockingReceive(dst, nanos);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     sender = trustedBlockingReceive(dst);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // check sender when security manager set and not connected</span>
<span class="line-added">+                 if (sm != null &amp;&amp; !connected) {</span>
<span class="line-added">+                     InetSocketAddress isa = (InetSocketAddress) sender;</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added">+                     } catch (SecurityException e) {</span>
<span class="line-added">+                         sender = null;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } while (sender == null);</span>
<span class="line-added">+             return sender;</span>
          } finally {
              readLock.unlock();
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Receives a datagram into given buffer. This method is used to support</span>
<span class="line-added">+      * the socket adaptor. The buffer is assumed to be trusted.</span>
<span class="line-added">+      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private SocketAddress trustedBlockingReceive(ByteBuffer dst)</span>
          throws IOException
      {
<span class="line-added">+         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();</span>
<span class="line-added">+         SocketAddress sender = null;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             SocketAddress remote = beginRead(true, false);</span>
<span class="line-added">+             boolean connected = (remote != null);</span>
<span class="line-added">+             int n = receive(dst, connected);</span>
<span class="line-added">+             while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                 park(Net.POLLIN);</span>
<span class="line-added">+                 n = receive(dst, connected);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (n &gt;= 0) {</span>
<span class="line-added">+                 // sender address is in socket address buffer</span>
<span class="line-added">+                 sender = sourceSocketAddress();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return sender;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endRead(true, (sender != null));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Receives a datagram into given buffer with a timeout. This method is</span>
<span class="line-added">+      * used to support the socket adaptor. The buffer is assumed to be trusted.</span>
<span class="line-added">+      * @throws SocketTimeoutException if the timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)</span>
<span class="line-added">+         throws IOException</span>
<span class="line-added">+     {</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();</span>
<span class="line-added">+         SocketAddress sender = null;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             SocketAddress remote = beginRead(true, false);</span>
<span class="line-added">+             boolean connected = (remote != null);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // change socket to non-blocking</span>
<span class="line-added">+             lockedConfigureBlocking(false);</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 long startNanos = System.nanoTime();</span>
<span class="line-added">+                 int n = receive(dst, connected);</span>
<span class="line-added">+                 while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-added">+                     long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">+                     if (remainingNanos &lt;= 0) {</span>
<span class="line-added">+                         throw new SocketTimeoutException(&quot;Receive timed out&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     park(Net.POLLIN, remainingNanos);</span>
<span class="line-added">+                     n = receive(dst, connected);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (n &gt;= 0) {</span>
<span class="line-added">+                     // sender address is in socket address buffer</span>
<span class="line-added">+                     sender = sourceSocketAddress();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return sender;</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">+                 tryLockedConfigureBlocking(true);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endRead(true, (sender != null));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private int receive(ByteBuffer dst, boolean connected) throws IOException {</span>
          int pos = dst.position();
          int lim = dst.limit();
          assert (pos &lt;= lim);
          int rem = (pos &lt;= lim ? lim - pos : 0);
          if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
<span class="line-modified">!             return receiveIntoNativeBuffer(dst, rem, pos, connected);</span>
  
          // Substitute a native buffer. If the supplied buffer is empty
          // we must instead use a nonempty buffer, otherwise the call
          // will not block waiting for a datagram on some platforms.
          int newSize = Math.max(rem, 1);
          ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
          try {
<span class="line-modified">!             int n = receiveIntoNativeBuffer(bb, newSize, 0, connected);</span>
              bb.flip();
              if (n &gt; 0 &amp;&amp; rem &gt; 0)
                  dst.put(bb);
              return n;
          } finally {
              Util.releaseTemporaryDirectBuffer(bb);
          }
      }
  
<span class="line-modified">!     private int receiveIntoNativeBuffer(ByteBuffer bb, int rem, int pos,</span>
<span class="line-modified">!                                         boolean connected)</span>
          throws IOException
      {
<span class="line-modified">!         int n = receive0(fd,</span>
<span class="line-added">+                          ((DirectBuffer)bb).address() + pos, rem,</span>
<span class="line-added">+                          sourceSockAddr.address(),</span>
<span class="line-added">+                          connected);</span>
          if (n &gt; 0)
              bb.position(pos + n);
          return n;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return an InetSocketAddress to represent the source/sender socket address</span>
<span class="line-added">+      * in sourceSockAddr. Returns the cached InetSocketAddress if the source</span>
<span class="line-added">+      * address is the same as the cached address.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private InetSocketAddress sourceSocketAddress() throws IOException {</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread();</span>
<span class="line-added">+         if (cachedInetSocketAddress != null &amp;&amp; sourceSockAddr.equals(cachedSockAddr)) {</span>
<span class="line-added">+             return cachedInetSocketAddress;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         InetSocketAddress isa = sourceSockAddr.decode();</span>
<span class="line-added">+         // swap sourceSockAddr and cachedSockAddr</span>
<span class="line-added">+         NativeSocketAddress tmp = cachedSockAddr;</span>
<span class="line-added">+         cachedSockAddr = sourceSockAddr;</span>
<span class="line-added">+         sourceSockAddr = tmp;</span>
<span class="line-added">+         cachedInetSocketAddress = isa;</span>
<span class="line-added">+         return isa;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
      public int send(ByteBuffer src, SocketAddress target)
          throws IOException
      {
          Objects.requireNonNull(src);
          InetSocketAddress isa = Net.checkAddress(target, family);
  
          writeLock.lock();
          try {
              boolean blocking = isBlocking();
<span class="line-modified">!             int n;</span>
<span class="line-added">+             boolean completed = false;</span>
              try {
                  SocketAddress remote = beginWrite(blocking, false);
                  if (remote != null) {
                      // connected
                      if (!target.equals(remote)) {
                          throw new AlreadyConnectedException();
                      }
<span class="line-modified">!                     n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified">!                     if (blocking) {</span>
<span class="line-modified">!                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                             park(Net.POLLOUT);</span>
<span class="line-added">+                             n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     completed = (n &gt; 0);</span>
                  } else {
                      // not connected
                      SecurityManager sm = System.getSecurityManager();
<span class="line-added">+                     InetAddress ia = isa.getAddress();</span>
                      if (sm != null) {
                          if (ia.isMulticastAddress()) {
                              sm.checkMulticast(ia);
                          } else {
                              sm.checkConnect(ia.getHostAddress(), isa.getPort());
                          }
                      }
<span class="line-modified">!                     if (ia.isLinkLocalAddress())</span>
<span class="line-modified">!                         isa = IPAddressUtil.toScopedAddress(isa);</span>
<span class="line-modified">!                     n = send(fd, src, isa);</span>
<span class="line-added">+                     if (blocking) {</span>
<span class="line-added">+                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                             park(Net.POLLOUT);</span>
<span class="line-added">+                             n = send(fd, src, isa);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     completed = (n &gt;= 0);</span>
                  }
              } finally {
<span class="line-modified">!                 endWrite(blocking, completed);</span>
              }
<span class="line-added">+             assert n &gt;= 0 || n == IOStatus.UNAVAILABLE;</span>
              return IOStatus.normalize(n);
          } finally {
              writeLock.unlock();
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Sends a datagram from the bytes in given buffer.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {</span>
<span class="line-added">+         writeLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             if (!isBlocking())</span>
<span class="line-added">+                 throw new IllegalBlockingModeException();</span>
<span class="line-added">+             send(src, target);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             writeLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
          throws IOException
      {
          if (src instanceof DirectBuffer)
              return sendFromNativeBuffer(fd, src, target);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,39 ***</span>
          int pos = bb.position();
          int lim = bb.limit();
          assert (pos &lt;= lim);
          int rem = (pos &lt;= lim ? lim - pos : 0);
  
<span class="line-removed">-         boolean preferIPv6 = (family != StandardProtocolFamily.INET);</span>
          int written;
          try {
<span class="line-modified">!             written = send0(preferIPv6, fd, ((DirectBuffer)bb).address() + pos,</span>
<span class="line-modified">!                             rem, target.getAddress(), target.getPort());</span>
          } catch (PortUnreachableException pue) {
              if (isConnected())
                  throw pue;
              written = rem;
          }
          if (written &gt; 0)
              bb.position(pos + written);
          return written;
      }
  
      @Override
      public int read(ByteBuffer buf) throws IOException {
          Objects.requireNonNull(buf);
  
          readLock.lock();
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginRead(blocking, true);
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-modified">!                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified">! </span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
<span class="line-new-header">--- 886,59 ---</span>
          int pos = bb.position();
          int lim = bb.limit();
          assert (pos &lt;= lim);
          int rem = (pos &lt;= lim ? lim - pos : 0);
  
          int written;
          try {
<span class="line-modified">!             int addressLen = targetSocketAddress(target);</span>
<span class="line-modified">!             written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,</span>
<span class="line-added">+                             targetSockAddr.address(), addressLen);</span>
          } catch (PortUnreachableException pue) {
              if (isConnected())
                  throw pue;
              written = rem;
          }
          if (written &gt; 0)
              bb.position(pos + written);
          return written;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Encodes the given InetSocketAddress into targetSockAddr, returning the</span>
<span class="line-added">+      * length of the sockaddr structure (sizeof struct sockaddr or sockaddr6).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int targetSocketAddress(InetSocketAddress isa) {</span>
<span class="line-added">+         assert writeLock.isHeldByCurrentThread();</span>
<span class="line-added">+         // Nothing to do if target address is already in the buffer. Use</span>
<span class="line-added">+         // identity rather than equals as Inet6Address.equals ignores scope_id.</span>
<span class="line-added">+         if (isa == previousTarget)</span>
<span class="line-added">+             return previousSockAddrLength;</span>
<span class="line-added">+         previousTarget = null;</span>
<span class="line-added">+         int len = targetSockAddr.encode(family, isa);</span>
<span class="line-added">+         previousTarget = isa;</span>
<span class="line-added">+         previousSockAddrLength = len;</span>
<span class="line-added">+         return len;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public int read(ByteBuffer buf) throws IOException {
          Objects.requireNonNull(buf);
  
          readLock.lock();
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginRead(blocking, true);
<span class="line-modified">!                 n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-modified">!                 if (blocking) {</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified">!                         park(Net.POLLIN);</span>
<span class="line-added">+                         n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,14 ***</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginRead(blocking, true);
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified">!                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified">! </span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
<span class="line-new-header">--- 957,17 ---</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginRead(blocking, true);
<span class="line-modified">!                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified">!                 if (blocking) {</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n)  &amp;&amp; isOpen()) {</span>
<span class="line-modified">!                         park(Net.POLLIN);</span>
<span class="line-added">+                         n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,11 ***</span>
       * @throws IOException if socket not bound and cannot be bound
       */
      private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
          throws IOException
      {
<span class="line-modified">!         if (blocking) {</span>
              // set hook for Thread.interrupt
              begin();
          }
          SocketAddress remote;
          synchronized (stateLock) {
<span class="line-new-header">--- 986,11 ---</span>
       * @throws IOException if socket not bound and cannot be bound
       */
      private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
          throws IOException
      {
<span class="line-modified">!         if (blocking &amp;&amp; interruptible) {</span>
              // set hook for Thread.interrupt
              begin();
          }
          SocketAddress remote;
          synchronized (stateLock) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 681,17 ***</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  writerThread = 0;
<span class="line-removed">-                 // notify any thread waiting in implCloseSelectableChannel</span>
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     stateLock.notifyAll();</span>
                  }
              }
<span class="line-modified">!             // remove hook for Thread.interrupt</span>
<span class="line-modified">!             end(completed);</span>
          }
      }
  
      @Override
      public int write(ByteBuffer buf) throws IOException {
<span class="line-new-header">--- 1015,21 ---</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  writerThread = 0;
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     tryFinishClose();</span>
                  }
              }
<span class="line-modified">! </span>
<span class="line-modified">!             if (interruptible) {</span>
<span class="line-added">+                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)</span>
<span class="line-added">+                 end(completed);</span>
<span class="line-added">+             } else if (!completed &amp;&amp; !isOpen()) {</span>
<span class="line-added">+                 throw new AsynchronousCloseException();</span>
<span class="line-added">+             }</span>
          }
      }
  
      @Override
      public int write(ByteBuffer buf) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,13 ***</span>
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginWrite(blocking, true);
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-modified">!                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
              } finally {
                  endWrite(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
<span class="line-new-header">--- 1039,17 ---</span>
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginWrite(blocking, true);
<span class="line-modified">!                 n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-modified">!                 if (blocking) {</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLOUT);</span>
<span class="line-added">+                         n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } finally {
                  endWrite(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,13 ***</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginWrite(blocking, true);
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified">!                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
              } finally {
                  endWrite(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
<span class="line-new-header">--- 1068,17 ---</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginWrite(blocking, true);
<span class="line-modified">!                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified">!                 if (blocking) {</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLOUT);</span>
<span class="line-added">+                         n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } finally {
                  endWrite(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,22 ***</span>
      protected void implConfigureBlocking(boolean block) throws IOException {
          readLock.lock();
          try {
              writeLock.lock();
              try {
<span class="line-modified">!                 synchronized (stateLock) {</span>
<span class="line-removed">-                     ensureOpen();</span>
<span class="line-removed">-                     IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed">-                 }</span>
              } finally {
                  writeLock.unlock();
              }
          } finally {
              readLock.unlock();
          }
      }
  
      InetSocketAddress localAddress() {
          synchronized (stateLock) {
              return localAddress;
          }
      }
<span class="line-new-header">--- 1091,49 ---</span>
      protected void implConfigureBlocking(boolean block) throws IOException {
          readLock.lock();
          try {
              writeLock.lock();
              try {
<span class="line-modified">!                 lockedConfigureBlocking(block);</span>
              } finally {
                  writeLock.unlock();
              }
          } finally {
              readLock.unlock();
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adjusts the blocking mode. readLock or writeLock must already be held.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adjusts the blocking mode if the channel is open. readLock or writeLock</span>
<span class="line-added">+      * must already be held.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-added">+      *         the blocking mode was not adjusted because the channel is closed</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             if (isOpen()) {</span>
<span class="line-added">+                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      InetSocketAddress localAddress() {
          synchronized (stateLock) {
              return localAddress;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 791,11 ***</span>
          }
          return this;
      }
  
      private void bindInternal(SocketAddress local) throws IOException {
<span class="line-modified">!         assert Thread.holdsLock(stateLock) &amp;&amp; (localAddress == null);</span>
  
          InetSocketAddress isa;
          if (local == null) {
              // only Inet4Address allowed with IPv4 socket
              if (family == StandardProtocolFamily.INET) {
<span class="line-new-header">--- 1164,11 ---</span>
          }
          return this;
      }
  
      private void bindInternal(SocketAddress local) throws IOException {
<span class="line-modified">!         assert Thread.holdsLock(stateLock )&amp;&amp; (localAddress == null);</span>
  
          InetSocketAddress isa;
          if (local == null) {
              // only Inet4Address allowed with IPv4 socket
              if (family == StandardProtocolFamily.INET) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 821,10 ***</span>
<span class="line-new-header">--- 1194,20 ---</span>
          }
      }
  
      @Override
      public DatagramChannel connect(SocketAddress sa) throws IOException {
<span class="line-added">+         return connect(sa, true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Connects the channel&#39;s socket.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param sa the remote address to which this channel is to be connected</span>
<span class="line-added">+      * @param check true to check if the channel is already connected.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     DatagramChannel connect(SocketAddress sa, boolean check) throws IOException {</span>
          InetSocketAddress isa = Net.checkAddress(sa, family);
          SecurityManager sm = System.getSecurityManager();
          if (sm != null) {
              InetAddress ia = isa.getAddress();
              if (ia.isMulticastAddress()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 839,13 ***</span>
          try {
              writeLock.lock();
              try {
                  synchronized (stateLock) {
                      ensureOpen();
<span class="line-modified">!                     if (state == ST_CONNECTED)</span>
                          throw new AlreadyConnectedException();
  
                      int n = Net.connect(family,
                                          fd,
                                          isa.getAddress(),
                                          isa.getPort());
                      if (n &lt;= 0)
<span class="line-new-header">--- 1222,21 ---</span>
          try {
              writeLock.lock();
              try {
                  synchronized (stateLock) {
                      ensureOpen();
<span class="line-modified">!                     if (check &amp;&amp; state == ST_CONNECTED)</span>
                          throw new AlreadyConnectedException();
  
<span class="line-added">+                     // ensure that the socket is bound</span>
<span class="line-added">+                     if (localAddress == null) {</span>
<span class="line-added">+                         bindInternal(null);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // capture local address before connect</span>
<span class="line-added">+                     initialLocalAddress = localAddress;</span>
<span class="line-added">+ </span>
                      int n = Net.connect(family,
                                          fd,
                                          isa.getAddress(),
                                          isa.getPort());
                      if (n &lt;= 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,11 ***</span>
                      if (blocking) {
                          IOUtil.configureBlocking(fd, false);
                      }
                      try {
                          ByteBuffer buf = ByteBuffer.allocate(100);
<span class="line-modified">!                         while (receive(buf) != null) {</span>
                              buf.clear();
                          }
                      } finally {
                          if (blocking) {
                              IOUtil.configureBlocking(fd, true);
<span class="line-new-header">--- 1254,11 ---</span>
                      if (blocking) {
                          IOUtil.configureBlocking(fd, false);
                      }
                      try {
                          ByteBuffer buf = ByteBuffer.allocate(100);
<span class="line-modified">!                         while (receive(buf, false) &gt;= 0) {</span>
                              buf.clear();
                          }
                      } finally {
                          if (blocking) {
                              IOUtil.configureBlocking(fd, true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 899,22 ***</span>
  
                      // no longer connected
                      remoteAddress = null;
                      state = ST_UNCONNECTED;
  
<span class="line-modified">!                     // refresh local address</span>
                      localAddress = Net.localAddress(fd);
                  }
              } finally {
                  writeLock.unlock();
              }
          } finally {
              readLock.unlock();
          }
          return this;
      }
  
      /**
       * Joins channel&#39;s socket to the given group/interface and
       * optional source address.
       */
      private MembershipKey innerJoin(InetAddress group,
<span class="line-new-header">--- 1290,161 ---</span>
  
                      // no longer connected
                      remoteAddress = null;
                      state = ST_UNCONNECTED;
  
<span class="line-modified">!                     // refresh localAddress, should be same as it was prior to connect</span>
                      localAddress = Net.localAddress(fd);
<span class="line-added">+                     try {</span>
<span class="line-added">+                         if (!localAddress.equals(initialLocalAddress)) {</span>
<span class="line-added">+                             // Workaround connect(2) issues on Linux and macOS</span>
<span class="line-added">+                             repairSocket(initialLocalAddress);</span>
<span class="line-added">+                             assert (localAddress != null)</span>
<span class="line-added">+                                     &amp;&amp; localAddress.equals(Net.localAddress(fd))</span>
<span class="line-added">+                                     &amp;&amp; localAddress.equals(initialLocalAddress);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         initialLocalAddress = null;</span>
<span class="line-added">+                     }</span>
                  }
              } finally {
                  writeLock.unlock();
              }
          } finally {
              readLock.unlock();
          }
          return this;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * &quot;Repair&quot; the channel&#39;s socket after a disconnect that didn&#39;t restore the</span>
<span class="line-added">+      * local address.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * On Linux, connect(2) dissolves the association but changes the local port</span>
<span class="line-added">+      * to 0 when it was initially bound to an ephemeral port. The workaround here</span>
<span class="line-added">+      * is to rebind to the original port.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * On macOS, connect(2) dissolves the association but rebinds the socket to</span>
<span class="line-added">+      * the wildcard address when it was initially bound to a specific address.</span>
<span class="line-added">+      * The workaround here is to re-create the socket.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void repairSocket(InetSocketAddress target)</span>
<span class="line-added">+         throws IOException</span>
<span class="line-added">+     {</span>
<span class="line-added">+         assert Thread.holdsLock(stateLock);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Linux: try to bind the socket to the original address/port</span>
<span class="line-added">+         if (localAddress.getPort() == 0) {</span>
<span class="line-added">+             assert localAddress.getAddress().equals(target.getAddress());</span>
<span class="line-added">+             Net.bind(family, fd, target.getAddress(), target.getPort());</span>
<span class="line-added">+             localAddress = Net.localAddress(fd);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // capture the value of all existing socket options</span>
<span class="line-added">+         Map&lt;SocketOption&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="line-added">+         for (SocketOption&lt;?&gt; option : supportedOptions()) {</span>
<span class="line-added">+             Object value = getOption(option);</span>
<span class="line-added">+             if (value != null) {</span>
<span class="line-added">+                 map.put(option, value);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // macOS: re-create the socket.</span>
<span class="line-added">+         FileDescriptor newfd = Net.socket(family, false);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             // copy the socket options that are protocol family agnostic</span>
<span class="line-added">+             for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {</span>
<span class="line-added">+                 SocketOption&lt;?&gt; option = e.getKey();</span>
<span class="line-added">+                 if (SocketOptionRegistry.findOption(option, Net.UNSPEC) != null) {</span>
<span class="line-added">+                     Object value = e.getValue();</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         Net.setSocketOption(newfd, Net.UNSPEC, option, value);</span>
<span class="line-added">+                     } catch (IOException ignore) { }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // copy the blocking mode</span>
<span class="line-added">+             if (!isBlocking()) {</span>
<span class="line-added">+                 IOUtil.configureBlocking(newfd, false);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // dup this channel&#39;s socket to the new socket. If this succeeds then</span>
<span class="line-added">+             // fd will reference the new socket. If it fails then it will still</span>
<span class="line-added">+             // reference the old socket.</span>
<span class="line-added">+             nd.dup(newfd, fd);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             // release the file descriptor</span>
<span class="line-added">+             nd.close(newfd);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // bind to the original local address</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             Net.bind(family, fd, target.getAddress(), target.getPort());</span>
<span class="line-added">+         } catch (IOException ioe) {</span>
<span class="line-added">+             // bind failed, socket is left unbound</span>
<span class="line-added">+             localAddress = null;</span>
<span class="line-added">+             throw ioe;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // restore local address</span>
<span class="line-added">+         localAddress = Net.localAddress(fd);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // restore all socket options (including those set in first pass)</span>
<span class="line-added">+         for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {</span>
<span class="line-added">+             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+             SocketOption&lt;Object&gt; option = (SocketOption&lt;Object&gt;) e.getKey();</span>
<span class="line-added">+             Object value = e.getValue();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 setOption(option, value);</span>
<span class="line-added">+             } catch (IOException ignore) { }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // restore multicast group membership</span>
<span class="line-added">+         MembershipRegistry registry = this.registry;</span>
<span class="line-added">+         if (registry != null) {</span>
<span class="line-added">+             registry.forEach(k -&gt; {</span>
<span class="line-added">+                 if (k instanceof MembershipKeyImpl.Type6) {</span>
<span class="line-added">+                     MembershipKeyImpl.Type6 key6 = (MembershipKeyImpl.Type6) k;</span>
<span class="line-added">+                     Net.join6(fd, key6.groupAddress(), key6.index(), key6.source());</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4) k;</span>
<span class="line-added">+                     Net.join4(fd, key4.groupAddress(), key4.interfaceAddress(), key4.source());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             });</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // reset registration in all Selectors that this channel is registered with</span>
<span class="line-added">+         AbstractSelectableChannels.forEach(this, SelectionKeyImpl::reset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Defines static methods to access AbstractSelectableChannel non-public members.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class AbstractSelectableChannels {</span>
<span class="line-added">+         private static final Method FOREACH;</span>
<span class="line-added">+         static {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 PrivilegedExceptionAction&lt;Method&gt; pae = () -&gt; {</span>
<span class="line-added">+                     Method m = AbstractSelectableChannel.class.getDeclaredMethod(&quot;forEach&quot;, Consumer.class);</span>
<span class="line-added">+                     m.setAccessible(true);</span>
<span class="line-added">+                     return m;</span>
<span class="line-added">+                 };</span>
<span class="line-added">+                 FOREACH = AccessController.doPrivileged(pae);</span>
<span class="line-added">+             } catch (Exception e) {</span>
<span class="line-added">+                 throw new InternalError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         static void forEach(AbstractSelectableChannel ch, Consumer&lt;SelectionKeyImpl&gt; action) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 FOREACH.invoke(ch, action);</span>
<span class="line-added">+             } catch (Exception e) {</span>
<span class="line-added">+                 throw new InternalError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Joins channel&#39;s socket to the given group/interface and
       * optional source address.
       */
      private MembershipKey innerJoin(InetAddress group,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,12 ***</span>
              registry.remove(key);
          }
      }
  
      /**
<span class="line-modified">!      * Block datagrams from given source if a memory to receive all</span>
<span class="line-modified">!      * datagrams.</span>
       */
      void block(MembershipKeyImpl key, InetAddress source)
          throws IOException
      {
          assert key.channel() == this;
<span class="line-new-header">--- 1583,27 ---</span>
              registry.remove(key);
          }
      }
  
      /**
<span class="line-modified">!      * Finds an existing membership of a multicast group. Returns null if this</span>
<span class="line-modified">!      * channel&#39;s socket is not a member of the group.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote This method is for use by the socket adaptor</span>
<span class="line-added">+      */</span>
<span class="line-added">+     MembershipKey findMembership(InetAddress group, NetworkInterface interf) {</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             if (registry != null) {</span>
<span class="line-added">+                 return registry.checkMembership(group, interf, null);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return null;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Block datagrams from the given source.</span>
       */
      void block(MembershipKeyImpl key, InetAddress source)
          throws IOException
      {
          assert key.channel() == this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1092,11 ***</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Unblock given source.</span>
       */
      void unblock(MembershipKeyImpl key, InetAddress source) {
          assert key.channel() == this;
          assert key.sourceAddress() == null;
  
<span class="line-new-header">--- 1637,11 ---</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Unblock the given source.</span>
       */
      void unblock(MembershipKeyImpl key, InetAddress source) {
          assert key.channel() == this;
          assert key.sourceAddress() == null;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,112 ***</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">!      *</span>
<span class="line-removed">-      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-removed">-      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-removed">-      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-removed">-      * complete quickly.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * The socket is closed by this method when it is not registered with a</span>
<span class="line-removed">-      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-removed">-      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed">-      * to blocking mode before the key is flushed from the Selector.</span>
       */
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">!         assert !isOpen();</span>
  
<span class="line-modified">!         boolean blocking;</span>
<span class="line-modified">!         boolean interrupted = false;</span>
  
<span class="line-modified">!         // set state to ST_CLOSING and invalid membership keys</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
<span class="line-removed">-             blocking = isBlocking();</span>
              state = ST_CLOSING;
  
              // if member of any multicast groups then invalidate the keys
              if (registry != null)
                  registry.invalidateAll();
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         // wait for any outstanding I/O operations to complete</span>
<span class="line-removed">-         if (blocking) {</span>
<span class="line-removed">-             synchronized (stateLock) {</span>
<span class="line-removed">-                 assert state == ST_CLOSING;</span>
                  long reader = readerThread;
                  long writer = writerThread;
                  if (reader != 0 || writer != 0) {
                      nd.preClose(fd);
<span class="line-removed">- </span>
                      if (reader != 0)
                          NativeThread.signal(reader);
                      if (writer != 0)
                          NativeThread.signal(writer);
<span class="line-removed">- </span>
<span class="line-removed">-                     // wait for blocking I/O operations to end</span>
<span class="line-removed">-                     while (readerThread != 0 || writerThread != 0) {</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             stateLock.wait();</span>
<span class="line-removed">-                         } catch (InterruptedException e) {</span>
<span class="line-removed">-                             interrupted = true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
                  }
              }
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // non-blocking mode: wait for read/write to complete</span>
<span class="line-removed">-             readLock.lock();</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 writeLock.lock();</span>
<span class="line-removed">-                 writeLock.unlock();</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 readLock.unlock();</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         // set state to ST_KILLPENDING</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert state == ST_CLOSING;</span>
<span class="line-modified">!             state = ST_KILLPENDING;</span>
          }
  
<span class="line-modified">!         // close socket if not registered with Selector</span>
<span class="line-modified">!         if (!isRegistered())</span>
<span class="line-modified">!             kill();</span>
  
<span class="line-modified">!         // restore interrupt status</span>
<span class="line-modified">!         if (interrupted)</span>
<span class="line-modified">!             Thread.currentThread().interrupt();</span>
      }
  
      @Override
<span class="line-modified">!     public void kill() throws IOException {</span>
          synchronized (stateLock) {
<span class="line-modified">!             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">!                 state = ST_KILLED;</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     nd.close(fd);</span>
<span class="line-removed">-                 } finally {</span>
<span class="line-removed">-                     // notify resource manager</span>
<span class="line-removed">-                     ResourceManager.afterUdpClose();</span>
<span class="line-removed">-                 }</span>
              }
          }
      }
  
<span class="line-removed">-     @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-removed">-     protected void finalize() throws IOException {</span>
<span class="line-removed">-         // fd is null if constructor threw exception</span>
<span class="line-removed">-         if (fd != null)</span>
<span class="line-removed">-             close();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Translates native poll revent set into a ready operation set
       */
      public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
          int intOps = ski.nioInterestOps();
<span class="line-new-header">--- 1667,120 ---</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Closes the socket if there are no I/O operations in progress and the</span>
<span class="line-modified">!      * channel is not registered with a Selector.</span>
       */
<span class="line-modified">!     private boolean tryClose() throws IOException {</span>
<span class="line-modified">!         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-modified">!         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added">+             state = ST_CLOSED;</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 // close socket</span>
<span class="line-added">+                 cleaner.clean();</span>
<span class="line-added">+             } catch (UncheckedIOException ioe) {</span>
<span class="line-added">+                 throw ioe.getCause();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Invokes tryClose to attempt to close the socket.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void tryFinishClose() {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             tryClose();</span>
<span class="line-added">+         } catch (IOException ignore) { }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If there is an I/O operation in progress then the socket is pre-closed</span>
<span class="line-added">+      * and the I/O threads signalled, in which case the final close is deferred</span>
<span class="line-added">+      * until all I/O operations complete.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void implCloseBlockingMode() throws IOException {</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
              state = ST_CLOSING;
  
              // if member of any multicast groups then invalidate the keys
              if (registry != null)
                  registry.invalidateAll();
  
<span class="line-modified">!             if (!tryClose()) {</span>
                  long reader = readerThread;
                  long writer = writerThread;
                  if (reader != 0 || writer != 0) {
                      nd.preClose(fd);
                      if (reader != 0)
                          NativeThread.signal(reader);
                      if (writer != 0)
                          NativeThread.signal(writer);
                  }
              }
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">+      * until the channel is flushed from all Selectors.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void implCloseNonBlockingMode() throws IOException {</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert state &lt; ST_CLOSING;</span>
<span class="line-modified">!             state = ST_CLOSING;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // if member of any multicast groups then invalidate the keys</span>
<span class="line-added">+             if (registry != null)</span>
<span class="line-added">+                 registry.invalidateAll();</span>
          }
  
<span class="line-modified">!         // wait for any read/write operations to complete before trying to close</span>
<span class="line-modified">!         readLock.lock();</span>
<span class="line-modified">!         readLock.unlock();</span>
<span class="line-added">+         writeLock.lock();</span>
<span class="line-added">+         writeLock.unlock();</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             if (state == ST_CLOSING) {</span>
<span class="line-added">+                 tryClose();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">!      */</span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">+         assert !isOpen();</span>
<span class="line-added">+         if (isBlocking()) {</span>
<span class="line-added">+             implCloseBlockingMode();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             implCloseNonBlockingMode();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void kill() {</span>
          synchronized (stateLock) {
<span class="line-modified">!             if (state == ST_CLOSING) {</span>
<span class="line-modified">!                 tryFinishClose();</span>
              }
          }
      }
  
      /**
       * Translates native poll revent set into a ready operation set
       */
      public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
          int intOps = ski.nioInterestOps();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1265,34 ***</span>
  
      public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
          return translateReadyOps(ops, 0, ski);
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Poll this channel&#39;s socket for reading up to the given timeout.</span>
<span class="line-removed">-      * @return {@code true} if the socket is polled</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     boolean pollRead(long timeout) throws IOException {</span>
<span class="line-removed">-         boolean blocking = isBlocking();</span>
<span class="line-removed">-         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         readLock.lock();</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             boolean polled = false;</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 beginRead(blocking, false);</span>
<span class="line-removed">-                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-removed">-                 polled = (events != 0);</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 endRead(blocking, polled);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return polled;</span>
<span class="line-removed">-         } finally {</span>
<span class="line-removed">-             readLock.unlock();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Translates an interest operation set into a native poll event set
       */
      public int translateInterestOps(int ops) {
          int newOps = 0;
<span class="line-new-header">--- 1818,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,26 ***</span>
  
      public int getFDVal() {
          return fdVal;
      }
  
  
      // -- Native methods --
  
<span class="line-removed">-     private static native void initIDs();</span>
<span class="line-removed">- </span>
      private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
          throws IOException;
  
<span class="line-modified">!     private native int receive0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">!                                 boolean connected)</span>
          throws IOException;
  
<span class="line-modified">!     private native int send0(boolean preferIPv6, FileDescriptor fd, long address,</span>
<span class="line-modified">!                              int len, InetAddress addr, int port)</span>
          throws IOException;
  
      static {
          IOUtil.load();
<span class="line-removed">-         initIDs();</span>
      }
  }
<span class="line-new-header">--- 1840,39 ---</span>
  
      public int getFDVal() {
          return fdVal;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns an action to release the given file descriptor and socket addresses.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static Runnable releaserFor(FileDescriptor fd, NativeSocketAddress... sockAddrs) {</span>
<span class="line-added">+         return () -&gt; {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 nd.close(fd);</span>
<span class="line-added">+             } catch (IOException ioe) {</span>
<span class="line-added">+                 throw new UncheckedIOException(ioe);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 // decrement socket count and release memory</span>
<span class="line-added">+                 ResourceManager.afterUdpClose();</span>
<span class="line-added">+                 NativeSocketAddress.freeAll(sockAddrs);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+     }</span>
  
      // -- Native methods --
  
      private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
          throws IOException;
  
<span class="line-modified">!     private static native int receive0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">!                                        long senderAddress, boolean connected)</span>
          throws IOException;
  
<span class="line-modified">!     private static native int send0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">!                                     long targetAddress, int targetAddressLen)</span>
          throws IOException;
  
      static {
          IOUtil.load();
      }
  }
</pre>
<center><a href="ChannelInputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketAdaptor.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
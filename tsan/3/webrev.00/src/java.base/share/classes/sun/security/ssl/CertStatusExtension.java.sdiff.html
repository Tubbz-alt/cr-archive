<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BaseSSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateMessage.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.io.ByteArrayInputStream;
  30 import java.nio.ByteBuffer;
  31 import java.security.cert.Extension;
  32 import java.security.cert.CertificateFactory;
  33 import java.security.cert.CertificateException;
  34 import java.security.cert.X509Certificate;
  35 import java.text.MessageFormat;
  36 import java.util.ArrayList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import javax.net.ssl.SSLProtocolException;
  40 import sun.security.provider.certpath.OCSPResponse;
  41 import sun.security.provider.certpath.ResponderId;
<span class="line-removed">  42 import static sun.security.ssl.SSLExtension.CH_STATUS_REQUEST;</span>
<span class="line-removed">  43 import static sun.security.ssl.SSLExtension.CH_STATUS_REQUEST_V2;</span>
  44 import sun.security.ssl.SSLExtension.ExtensionConsumer;
<span class="line-removed">  45 import static sun.security.ssl.SSLExtension.SH_STATUS_REQUEST;</span>
<span class="line-removed">  46 import static sun.security.ssl.SSLExtension.SH_STATUS_REQUEST_V2;</span>
  47 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  49 import sun.security.util.DerInputStream;
  50 import sun.security.util.DerValue;
  51 import sun.security.util.HexDumpEncoder;
  52 
  53 /**
  54  * Pack of &quot;status_request&quot; and &quot;status_request_v2&quot; extensions.
  55  */
  56 final class CertStatusExtension {
  57     static final HandshakeProducer chNetworkProducer =
  58             new CHCertStatusReqProducer();
  59     static final ExtensionConsumer chOnLoadConsumer =
  60             new CHCertStatusReqConsumer();
  61 
  62     static final HandshakeProducer shNetworkProducer =
  63             new SHCertStatusReqProducer();
  64     static final ExtensionConsumer shOnLoadConsumer =
  65             new SHCertStatusReqConsumer();
  66 
</pre>
<hr />
<pre>
 417                 &quot;\&quot;request extensions\&quot;: &#39;{&#39;\n&quot; +
 418                 &quot;{1}\n&quot; +
 419                 &quot;&#39;}&#39;&quot;,
 420                 Locale.ENGLISH);
 421 
 422             String ridStr = &quot;&lt;empty&gt;&quot;;
 423             if (!responderIds.isEmpty()) {
 424                 ridStr = responderIds.toString();
 425             }
 426 
 427             String extsStr = &quot;&lt;empty&gt;&quot;;
 428             if (!extensions.isEmpty()) {
 429                 StringBuilder extBuilder = new StringBuilder(512);
 430                 boolean isFirst = true;
 431                 for (Extension ext : this.extensions) {
 432                     if (isFirst) {
 433                         isFirst = false;
 434                     } else {
 435                         extBuilder.append(&quot;,\n&quot;);
 436                     }
<span class="line-modified"> 437                     extBuilder.append(</span>
<span class="line-modified"> 438                             &quot;{\n&quot; + Utilities.indent(ext.toString()) + &quot;}&quot;);</span>

 439                 }
 440 
 441                 extsStr = extBuilder.toString();
 442             }
 443 
 444             Object[] requestFields = {
 445                     ridStr,
 446                     Utilities.indent(extsStr)
 447                 };
 448             String ocspStatusRequest = requestFormat.format(requestFields);
 449 
 450             Object[] messageFields = {
 451                     CertStatusRequestType.nameOf(statusType),
 452                     Utilities.indent(ocspStatusRequest)
 453                 };
 454 
 455             return messageFormat.format(messageFields);
 456         }
 457     }
 458 
</pre>
<hr />
<pre>
 535      * Network data producer of a &quot;status_request&quot; extension in the
 536      * ClientHello handshake message.
 537      */
 538     private static final
 539             class CHCertStatusReqProducer implements HandshakeProducer {
 540         // Prevent instantiation of this class.
 541         private CHCertStatusReqProducer() {
 542             // blank
 543         }
 544 
 545         @Override
 546         public byte[] produce(ConnectionContext context,
 547                 HandshakeMessage message) throws IOException {
 548             // The producing happens in client side only.
 549             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 550 
 551             if (!chc.sslContext.isStaplingEnabled(true)) {
 552                 return null;
 553             }
 554 
<span class="line-modified"> 555             if (!chc.sslConfig.isAvailable(CH_STATUS_REQUEST)) {</span>
 556                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 557                     SSLLogger.fine(
 558                         &quot;Ignore unavailable extension: &quot; +
<span class="line-modified"> 559                         CH_STATUS_REQUEST.name);</span>
 560                 }
 561                 return null;
 562             }
 563 
 564             // Produce the extension.
 565             //
 566             // We are using empty OCSPStatusRequest at present. May extend to
 567             // support specific responder or extensions later.
 568             byte[] extData = new byte[] {0x01, 0x00, 0x00, 0x00, 0x00};
 569 
 570             // Update the context.
<span class="line-modified"> 571             chc.handshakeExtensions.put(</span>
<span class="line-modified"> 572                     CH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);</span>
 573 
 574             return extData;
 575         }
 576     }
 577 
 578     /**
 579      * Network data consumer of a &quot;status_request&quot; extension in the
 580      * ClientHello handshake message.
 581      */
 582     private static final
 583             class CHCertStatusReqConsumer implements ExtensionConsumer {
 584         // Prevent instantiation of this class.
 585         private CHCertStatusReqConsumer() {
 586             // blank
 587         }
 588 
 589         @Override
 590         public void consume(ConnectionContext context,
 591             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 592 
 593             // The consuming happens in server side only.
 594             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 595 
<span class="line-modified"> 596             if (!shc.sslConfig.isAvailable(CH_STATUS_REQUEST)) {</span>
 597                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 598                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
<span class="line-modified"> 599                         CH_STATUS_REQUEST.name);</span>
 600                 }
 601                 return;     // ignore the extension
 602             }
 603 
 604             // Parse the extension.
 605             CertStatusRequestSpec spec;
 606             try {
 607                 spec = new CertStatusRequestSpec(buffer);
 608             } catch (IOException ioe) {
 609                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 610             }
 611 
 612             // Update the context.
<span class="line-modified"> 613             shc.handshakeExtensions.put(CH_STATUS_REQUEST, spec);</span>
 614             if (!shc.isResumption &amp;&amp;
 615                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
 616                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 617                     SSLHandshake.CERTIFICATE_STATUS);
 618             }   // Otherwise, the certificate status presents in server cert.
 619 
 620             // No impact on session resumption.
 621         }
 622     }
 623 
 624     /**
 625      * Network data producer of a &quot;status_request&quot; extension in the
 626      * ServerHello handshake message.
 627      */
 628     private static final
 629             class SHCertStatusReqProducer implements HandshakeProducer {
 630         // Prevent instantiation of this class.
 631         private SHCertStatusReqProducer() {
 632             // blank
 633         }
</pre>
<hr />
<pre>
 637                 HandshakeMessage message) throws IOException {
 638             // The producing happens in client side only.
 639             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 640 
 641             // The StaplingParameters in the ServerHandshakeContext will
 642             // contain the info about what kind of stapling (if any) to
 643             // perform and whether this status_request extension should be
 644             // produced or the status_request_v2 (found in a different producer)
 645             // No explicit check is required for isStaplingEnabled here.  If
 646             // it is false then stapleParams will be null.  If it is true
 647             // then stapleParams may or may not be false and the check below
 648             // is sufficient.
 649             if ((shc.stapleParams == null) ||
 650                     (shc.stapleParams.statusRespExt !=
 651                     SSLExtension.CH_STATUS_REQUEST)) {
 652                 return null;    // Do not produce status_request in ServerHello
 653             }
 654 
 655             // In response to &quot;status_request&quot; extension request only.
 656             CertStatusRequestSpec spec = (CertStatusRequestSpec)
<span class="line-modified"> 657                     shc.handshakeExtensions.get(CH_STATUS_REQUEST);</span>
 658             if (spec == null) {
 659                 // Ignore, no status_request extension requested.
 660                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
<span class="line-modified"> 661                     SSLLogger.finest(</span>
<span class="line-modified"> 662                         &quot;Ignore unavailable extension: &quot; +</span>
<span class="line-removed"> 663                         CH_STATUS_REQUEST.name);</span>
 664                 }
 665 
 666                 return null;        // ignore the extension
 667             }
 668 
 669             // Is it a session resuming?
 670             if (shc.isResumption) {
 671                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 672                     SSLLogger.finest(
 673                         &quot;No status_request response for session resuming&quot;);
 674                 }
 675 
 676                 return null;        // ignore the extension
 677             }
 678 
 679             // The &quot;extension_data&quot; in the extended ServerHello handshake
 680             // message MUST be empty.
 681             byte[] extData = new byte[0];
 682 
 683             // Update the context.
<span class="line-modified"> 684             shc.handshakeExtensions.put(</span>
<span class="line-modified"> 685                     SH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);</span>
 686 
 687             return extData;
 688         }
 689     }
 690 
 691     /**
 692      * Network data consumer of a &quot;status_request&quot; extension in the
 693      * ServerHello handshake message.
 694      */
 695     private static final
 696             class SHCertStatusReqConsumer implements ExtensionConsumer {
 697         // Prevent instantiation of this class.
 698         private SHCertStatusReqConsumer() {
 699             // blank
 700         }
 701 
 702         @Override
 703         public void consume(ConnectionContext context,
 704             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 705 
 706             // The producing happens in client side only.
 707             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 708 
 709             // In response to &quot;status_request&quot; extension request only.
 710             CertStatusRequestSpec requestedCsr = (CertStatusRequestSpec)
<span class="line-modified"> 711                     chc.handshakeExtensions.get(CH_STATUS_REQUEST);</span>
 712             if (requestedCsr == null) {
 713                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 714                     &quot;Unexpected status_request extension in ServerHello&quot;);
 715             }
 716 
 717             // Parse the extension.
 718             if (buffer.hasRemaining()) {
 719                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 720                   &quot;Invalid status_request extension in ServerHello message: &quot; +
 721                   &quot;the extension data must be empty&quot;);
 722             }
 723 
 724             // Update the context.
<span class="line-modified"> 725             chc.handshakeExtensions.put(</span>
<span class="line-modified"> 726                     SH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);</span>
<span class="line-removed"> 727             chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,</span>
<span class="line-removed"> 728                     SSLHandshake.CERTIFICATE_STATUS);</span>
 729 
 730             // Since we&#39;ve received a legitimate status_request in the
 731             // ServerHello, stapling is active if it&#39;s been enabled.
 732             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);




 733 
 734             // No impact on session resumption.
 735         }
 736     }
 737 
 738     /**
 739      * The &quot;status_request_v2&quot; extension.
 740      *
 741      * RFC6961 defines the TLS extension,&quot;status_request_v2&quot; (type 0x5),
 742      * which allows the client to request that the server perform OCSP
 743      * on the client&#39;s behalf.
 744      *
 745      * The RFC defines an CertStatusReqItemV2 structure:
 746      *
 747      *      struct {
 748      *          CertificateStatusType status_type;
 749      *          uint16 request_length;
 750      *          select (status_type) {
 751      *              case ocsp: OCSPStatusRequest;
 752      *              case ocsp_multi: OCSPStatusRequest;
</pre>
<hr />
<pre>
 890      * Network data producer of a &quot;status_request_v2&quot; extension in the
 891      * ClientHello handshake message.
 892      */
 893     private static final
 894             class CHCertStatusReqV2Producer implements HandshakeProducer {
 895         // Prevent instantiation of this class.
 896         private CHCertStatusReqV2Producer() {
 897             // blank
 898         }
 899 
 900         @Override
 901         public byte[] produce(ConnectionContext context,
 902                 HandshakeMessage message) throws IOException {
 903             // The producing happens in client side only.
 904             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 905 
 906             if (!chc.sslContext.isStaplingEnabled(true)) {
 907                 return null;
 908             }
 909 
<span class="line-modified"> 910             if (!chc.sslConfig.isAvailable(CH_STATUS_REQUEST_V2)) {</span>
 911                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 912                     SSLLogger.finest(
 913                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 914                 }
 915 
 916                 return null;
 917             }
 918 
 919             // Produce the extension.
 920             //
 921             // We are using empty OCSPStatusRequest at present. May extend to
 922             // support specific responder or extensions later.
 923             byte[] extData = new byte[] {
 924                 0x00, 0x07, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00};
 925 
 926             // Update the context.
<span class="line-modified"> 927             chc.handshakeExtensions.put(</span>
<span class="line-modified"> 928                     CH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);</span>
 929 
 930             return extData;
 931         }
 932     }
 933 
 934     /**
 935      * Network data consumer of a &quot;status_request_v2&quot; extension in the
 936      * ClientHello handshake message.
 937      */
 938     private static final
 939             class CHCertStatusReqV2Consumer implements ExtensionConsumer {
 940         // Prevent instantiation of this class.
 941         private CHCertStatusReqV2Consumer() {
 942             // blank
 943         }
 944 
 945         @Override
 946         public void consume(ConnectionContext context,
 947             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 948 
 949             // The consuming happens in server side only.
 950             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 951 
<span class="line-modified"> 952             if (!shc.sslConfig.isAvailable(CH_STATUS_REQUEST_V2)) {</span>
 953                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 954                     SSLLogger.finest(
 955                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 956                 }
 957 
 958                 return;     // ignore the extension
 959             }
 960 
 961             // Parse the extension.
 962             CertStatusRequestV2Spec spec;
 963             try {
 964                 spec = new CertStatusRequestV2Spec(buffer);
 965             } catch (IOException ioe) {
 966                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 967             }
 968 
 969             // Update the context.
<span class="line-modified"> 970             shc.handshakeExtensions.put(CH_STATUS_REQUEST_V2, spec);</span>

 971             if (!shc.isResumption) {
 972                 shc.handshakeProducers.putIfAbsent(
 973                         SSLHandshake.CERTIFICATE_STATUS.id,
 974                         SSLHandshake.CERTIFICATE_STATUS);
 975             }
 976 
 977             // No impact on session resumption.
 978         }
 979     }
 980 
 981     /**
 982      * Network data producer of a &quot;status_request_v2&quot; extension in the
 983      * ServerHello handshake message.
 984      */
 985     private static final
 986             class SHCertStatusReqV2Producer implements HandshakeProducer {
 987         // Prevent instantiation of this class.
 988         private SHCertStatusReqV2Producer() {
 989             // blank
 990         }
</pre>
<hr />
<pre>
 994                 HandshakeMessage message) throws IOException {
 995             // The producing happens in client side only.
 996 
 997             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 998             // The StaplingParameters in the ServerHandshakeContext will
 999             // contain the info about what kind of stapling (if any) to
1000             // perform and whether this status_request extension should be
1001             // produced or the status_request_v2 (found in a different producer)
1002             // No explicit check is required for isStaplingEnabled here.  If
1003             // it is false then stapleParams will be null.  If it is true
1004             // then stapleParams may or may not be false and the check below
1005             // is sufficient.
1006             if ((shc.stapleParams == null) ||
1007                     (shc.stapleParams.statusRespExt !=
1008                     SSLExtension.CH_STATUS_REQUEST_V2)) {
1009                 return null;    // Do not produce status_request_v2 in SH
1010             }
1011 
1012             // In response to &quot;status_request_v2&quot; extension request only
1013             CertStatusRequestV2Spec spec = (CertStatusRequestV2Spec)
<span class="line-modified">1014                     shc.handshakeExtensions.get(CH_STATUS_REQUEST_V2);</span>
1015             if (spec == null) {
1016                 // Ignore, no status_request_v2 extension requested.
1017                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1018                     SSLLogger.finest(
1019                         &quot;Ignore unavailable status_request_v2 extension&quot;);
1020                 }
1021 
1022                 return null;        // ignore the extension
1023             }
1024 
1025             // Is it a session resuming?
1026             if (shc.isResumption) {
1027                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1028                     SSLLogger.finest(
1029                         &quot;No status_request_v2 response for session resumption&quot;);
1030                 }
1031                 return null;        // ignore the extension
1032             }
1033 
1034             // The &quot;extension_data&quot; in the extended ServerHello handshake
1035             // message MUST be empty.
1036             byte[] extData = new byte[0];
1037 
1038             // Update the context.
<span class="line-modified">1039             shc.handshakeExtensions.put(</span>
<span class="line-modified">1040                     SH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);</span>
1041 
1042             return extData;
1043         }
1044     }
1045 
1046     /**
1047      * Network data consumer of a &quot;status_request_v2&quot; extension in the
1048      * ServerHello handshake message.
1049      */
1050     private static final
1051             class SHCertStatusReqV2Consumer implements ExtensionConsumer {
1052         // Prevent instantiation of this class.
1053         private SHCertStatusReqV2Consumer() {
1054             // blank
1055         }
1056 
1057         @Override
1058         public void consume(ConnectionContext context,
1059             HandshakeMessage message, ByteBuffer buffer) throws IOException {
1060 
1061             // The consumption happens in client side only.
1062             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1063 
1064             // In response to &quot;status_request&quot; extension request only
1065             CertStatusRequestV2Spec requestedCsr = (CertStatusRequestV2Spec)
<span class="line-modified">1066                     chc.handshakeExtensions.get(CH_STATUS_REQUEST_V2);</span>
1067             if (requestedCsr == null) {
1068                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1069                     &quot;Unexpected status_request_v2 extension in ServerHello&quot;);
1070             }
1071 
1072             // Parse the extension.
1073             if (buffer.hasRemaining()) {
1074                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1075                   &quot;Invalid status_request_v2 extension in ServerHello: &quot; +
1076                   &quot;the extension data must be empty&quot;);
1077             }
1078 
1079             // Update the context.
<span class="line-modified">1080             chc.handshakeExtensions.put(</span>
<span class="line-modified">1081                     SH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);</span>
<span class="line-removed">1082             chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,</span>
<span class="line-removed">1083                     SSLHandshake.CERTIFICATE_STATUS);</span>
1084 
1085             // Since we&#39;ve received a legitimate status_request in the
<span class="line-modified">1086             // ServerHello, stapling is active if it&#39;s been enabled.</span>


1087             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);




1088 
1089             // No impact on session resumption.
1090         }
1091     }
1092 
1093     private static final
1094             class CTCertStatusResponseProducer implements HandshakeProducer {
1095         // Prevent instantiation of this class.
1096         private CTCertStatusResponseProducer() {
1097             // blank
1098         }
1099 
1100         @Override
1101         public byte[] produce(ConnectionContext context,
1102                 HandshakeMessage message) throws IOException {
1103             ServerHandshakeContext shc = (ServerHandshakeContext)context;
1104             byte[] producedData = null;
1105 
1106             // Stapling needs to be active and have valid data to proceed
1107             if (shc.stapleParams == null) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.io.ByteArrayInputStream;
  30 import java.nio.ByteBuffer;
  31 import java.security.cert.Extension;
  32 import java.security.cert.CertificateFactory;
  33 import java.security.cert.CertificateException;
  34 import java.security.cert.X509Certificate;
  35 import java.text.MessageFormat;
  36 import java.util.ArrayList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import javax.net.ssl.SSLProtocolException;
  40 import sun.security.provider.certpath.OCSPResponse;
  41 import sun.security.provider.certpath.ResponderId;


  42 import sun.security.ssl.SSLExtension.ExtensionConsumer;


  43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  45 import sun.security.util.DerInputStream;
  46 import sun.security.util.DerValue;
  47 import sun.security.util.HexDumpEncoder;
  48 
  49 /**
  50  * Pack of &quot;status_request&quot; and &quot;status_request_v2&quot; extensions.
  51  */
  52 final class CertStatusExtension {
  53     static final HandshakeProducer chNetworkProducer =
  54             new CHCertStatusReqProducer();
  55     static final ExtensionConsumer chOnLoadConsumer =
  56             new CHCertStatusReqConsumer();
  57 
  58     static final HandshakeProducer shNetworkProducer =
  59             new SHCertStatusReqProducer();
  60     static final ExtensionConsumer shOnLoadConsumer =
  61             new SHCertStatusReqConsumer();
  62 
</pre>
<hr />
<pre>
 413                 &quot;\&quot;request extensions\&quot;: &#39;{&#39;\n&quot; +
 414                 &quot;{1}\n&quot; +
 415                 &quot;&#39;}&#39;&quot;,
 416                 Locale.ENGLISH);
 417 
 418             String ridStr = &quot;&lt;empty&gt;&quot;;
 419             if (!responderIds.isEmpty()) {
 420                 ridStr = responderIds.toString();
 421             }
 422 
 423             String extsStr = &quot;&lt;empty&gt;&quot;;
 424             if (!extensions.isEmpty()) {
 425                 StringBuilder extBuilder = new StringBuilder(512);
 426                 boolean isFirst = true;
 427                 for (Extension ext : this.extensions) {
 428                     if (isFirst) {
 429                         isFirst = false;
 430                     } else {
 431                         extBuilder.append(&quot;,\n&quot;);
 432                     }
<span class="line-modified"> 433                     extBuilder.append(&quot;{\n&quot;).</span>
<span class="line-modified"> 434                             append(Utilities.indent(ext.toString())).</span>
<span class="line-added"> 435                             append(&quot;}&quot;);</span>
 436                 }
 437 
 438                 extsStr = extBuilder.toString();
 439             }
 440 
 441             Object[] requestFields = {
 442                     ridStr,
 443                     Utilities.indent(extsStr)
 444                 };
 445             String ocspStatusRequest = requestFormat.format(requestFields);
 446 
 447             Object[] messageFields = {
 448                     CertStatusRequestType.nameOf(statusType),
 449                     Utilities.indent(ocspStatusRequest)
 450                 };
 451 
 452             return messageFormat.format(messageFields);
 453         }
 454     }
 455 
</pre>
<hr />
<pre>
 532      * Network data producer of a &quot;status_request&quot; extension in the
 533      * ClientHello handshake message.
 534      */
 535     private static final
 536             class CHCertStatusReqProducer implements HandshakeProducer {
 537         // Prevent instantiation of this class.
 538         private CHCertStatusReqProducer() {
 539             // blank
 540         }
 541 
 542         @Override
 543         public byte[] produce(ConnectionContext context,
 544                 HandshakeMessage message) throws IOException {
 545             // The producing happens in client side only.
 546             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 547 
 548             if (!chc.sslContext.isStaplingEnabled(true)) {
 549                 return null;
 550             }
 551 
<span class="line-modified"> 552             if (!chc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {</span>
 553                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 554                     SSLLogger.fine(
 555                         &quot;Ignore unavailable extension: &quot; +
<span class="line-modified"> 556                         SSLExtension.CH_STATUS_REQUEST.name);</span>
 557                 }
 558                 return null;
 559             }
 560 
 561             // Produce the extension.
 562             //
 563             // We are using empty OCSPStatusRequest at present. May extend to
 564             // support specific responder or extensions later.
 565             byte[] extData = new byte[] {0x01, 0x00, 0x00, 0x00, 0x00};
 566 
 567             // Update the context.
<span class="line-modified"> 568             chc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST,</span>
<span class="line-modified"> 569                     CertStatusRequestSpec.DEFAULT);</span>
 570 
 571             return extData;
 572         }
 573     }
 574 
 575     /**
 576      * Network data consumer of a &quot;status_request&quot; extension in the
 577      * ClientHello handshake message.
 578      */
 579     private static final
 580             class CHCertStatusReqConsumer implements ExtensionConsumer {
 581         // Prevent instantiation of this class.
 582         private CHCertStatusReqConsumer() {
 583             // blank
 584         }
 585 
 586         @Override
 587         public void consume(ConnectionContext context,
 588             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 589 
 590             // The consuming happens in server side only.
 591             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 592 
<span class="line-modified"> 593             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {</span>
 594                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 595                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
<span class="line-modified"> 596                         SSLExtension.CH_STATUS_REQUEST.name);</span>
 597                 }
 598                 return;     // ignore the extension
 599             }
 600 
 601             // Parse the extension.
 602             CertStatusRequestSpec spec;
 603             try {
 604                 spec = new CertStatusRequestSpec(buffer);
 605             } catch (IOException ioe) {
 606                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 607             }
 608 
 609             // Update the context.
<span class="line-modified"> 610             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST, spec);</span>
 611             if (!shc.isResumption &amp;&amp;
 612                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
 613                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 614                     SSLHandshake.CERTIFICATE_STATUS);
 615             }   // Otherwise, the certificate status presents in server cert.
 616 
 617             // No impact on session resumption.
 618         }
 619     }
 620 
 621     /**
 622      * Network data producer of a &quot;status_request&quot; extension in the
 623      * ServerHello handshake message.
 624      */
 625     private static final
 626             class SHCertStatusReqProducer implements HandshakeProducer {
 627         // Prevent instantiation of this class.
 628         private SHCertStatusReqProducer() {
 629             // blank
 630         }
</pre>
<hr />
<pre>
 634                 HandshakeMessage message) throws IOException {
 635             // The producing happens in client side only.
 636             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 637 
 638             // The StaplingParameters in the ServerHandshakeContext will
 639             // contain the info about what kind of stapling (if any) to
 640             // perform and whether this status_request extension should be
 641             // produced or the status_request_v2 (found in a different producer)
 642             // No explicit check is required for isStaplingEnabled here.  If
 643             // it is false then stapleParams will be null.  If it is true
 644             // then stapleParams may or may not be false and the check below
 645             // is sufficient.
 646             if ((shc.stapleParams == null) ||
 647                     (shc.stapleParams.statusRespExt !=
 648                     SSLExtension.CH_STATUS_REQUEST)) {
 649                 return null;    // Do not produce status_request in ServerHello
 650             }
 651 
 652             // In response to &quot;status_request&quot; extension request only.
 653             CertStatusRequestSpec spec = (CertStatusRequestSpec)
<span class="line-modified"> 654                     shc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST);</span>
 655             if (spec == null) {
 656                 // Ignore, no status_request extension requested.
 657                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
<span class="line-modified"> 658                     SSLLogger.finest(&quot;Ignore unavailable extension: &quot; +</span>
<span class="line-modified"> 659                         SSLExtension.CH_STATUS_REQUEST.name);</span>

 660                 }
 661 
 662                 return null;        // ignore the extension
 663             }
 664 
 665             // Is it a session resuming?
 666             if (shc.isResumption) {
 667                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 668                     SSLLogger.finest(
 669                         &quot;No status_request response for session resuming&quot;);
 670                 }
 671 
 672                 return null;        // ignore the extension
 673             }
 674 
 675             // The &quot;extension_data&quot; in the extended ServerHello handshake
 676             // message MUST be empty.
 677             byte[] extData = new byte[0];
 678 
 679             // Update the context.
<span class="line-modified"> 680             shc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST,</span>
<span class="line-modified"> 681                     CertStatusRequestSpec.DEFAULT);</span>
 682 
 683             return extData;
 684         }
 685     }
 686 
 687     /**
 688      * Network data consumer of a &quot;status_request&quot; extension in the
 689      * ServerHello handshake message.
 690      */
 691     private static final
 692             class SHCertStatusReqConsumer implements ExtensionConsumer {
 693         // Prevent instantiation of this class.
 694         private SHCertStatusReqConsumer() {
 695             // blank
 696         }
 697 
 698         @Override
 699         public void consume(ConnectionContext context,
 700             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 701 
 702             // The producing happens in client side only.
 703             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 704 
 705             // In response to &quot;status_request&quot; extension request only.
 706             CertStatusRequestSpec requestedCsr = (CertStatusRequestSpec)
<span class="line-modified"> 707                     chc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST);</span>
 708             if (requestedCsr == null) {
 709                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 710                     &quot;Unexpected status_request extension in ServerHello&quot;);
 711             }
 712 
 713             // Parse the extension.
 714             if (buffer.hasRemaining()) {
 715                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 716                   &quot;Invalid status_request extension in ServerHello message: &quot; +
 717                   &quot;the extension data must be empty&quot;);
 718             }
 719 
 720             // Update the context.
<span class="line-modified"> 721             chc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST,</span>
<span class="line-modified"> 722                     CertStatusRequestSpec.DEFAULT);</span>


 723 
 724             // Since we&#39;ve received a legitimate status_request in the
 725             // ServerHello, stapling is active if it&#39;s been enabled.
 726             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
<span class="line-added"> 727             if (chc.staplingActive) {</span>
<span class="line-added"> 728                 chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,</span>
<span class="line-added"> 729                     SSLHandshake.CERTIFICATE_STATUS);</span>
<span class="line-added"> 730             }</span>
 731 
 732             // No impact on session resumption.
 733         }
 734     }
 735 
 736     /**
 737      * The &quot;status_request_v2&quot; extension.
 738      *
 739      * RFC6961 defines the TLS extension,&quot;status_request_v2&quot; (type 0x5),
 740      * which allows the client to request that the server perform OCSP
 741      * on the client&#39;s behalf.
 742      *
 743      * The RFC defines an CertStatusReqItemV2 structure:
 744      *
 745      *      struct {
 746      *          CertificateStatusType status_type;
 747      *          uint16 request_length;
 748      *          select (status_type) {
 749      *              case ocsp: OCSPStatusRequest;
 750      *              case ocsp_multi: OCSPStatusRequest;
</pre>
<hr />
<pre>
 888      * Network data producer of a &quot;status_request_v2&quot; extension in the
 889      * ClientHello handshake message.
 890      */
 891     private static final
 892             class CHCertStatusReqV2Producer implements HandshakeProducer {
 893         // Prevent instantiation of this class.
 894         private CHCertStatusReqV2Producer() {
 895             // blank
 896         }
 897 
 898         @Override
 899         public byte[] produce(ConnectionContext context,
 900                 HandshakeMessage message) throws IOException {
 901             // The producing happens in client side only.
 902             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 903 
 904             if (!chc.sslContext.isStaplingEnabled(true)) {
 905                 return null;
 906             }
 907 
<span class="line-modified"> 908             if (!chc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {</span>
 909                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 910                     SSLLogger.finest(
 911                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 912                 }
 913 
 914                 return null;
 915             }
 916 
 917             // Produce the extension.
 918             //
 919             // We are using empty OCSPStatusRequest at present. May extend to
 920             // support specific responder or extensions later.
 921             byte[] extData = new byte[] {
 922                 0x00, 0x07, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00};
 923 
 924             // Update the context.
<span class="line-modified"> 925             chc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,</span>
<span class="line-modified"> 926                     CertStatusRequestV2Spec.DEFAULT);</span>
 927 
 928             return extData;
 929         }
 930     }
 931 
 932     /**
 933      * Network data consumer of a &quot;status_request_v2&quot; extension in the
 934      * ClientHello handshake message.
 935      */
 936     private static final
 937             class CHCertStatusReqV2Consumer implements ExtensionConsumer {
 938         // Prevent instantiation of this class.
 939         private CHCertStatusReqV2Consumer() {
 940             // blank
 941         }
 942 
 943         @Override
 944         public void consume(ConnectionContext context,
 945             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 946 
 947             // The consuming happens in server side only.
 948             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 949 
<span class="line-modified"> 950             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {</span>
 951                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 952                     SSLLogger.finest(
 953                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 954                 }
 955 
 956                 return;     // ignore the extension
 957             }
 958 
 959             // Parse the extension.
 960             CertStatusRequestV2Spec spec;
 961             try {
 962                 spec = new CertStatusRequestV2Spec(buffer);
 963             } catch (IOException ioe) {
 964                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 965             }
 966 
 967             // Update the context.
<span class="line-modified"> 968             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,</span>
<span class="line-added"> 969                     spec);</span>
 970             if (!shc.isResumption) {
 971                 shc.handshakeProducers.putIfAbsent(
 972                         SSLHandshake.CERTIFICATE_STATUS.id,
 973                         SSLHandshake.CERTIFICATE_STATUS);
 974             }
 975 
 976             // No impact on session resumption.
 977         }
 978     }
 979 
 980     /**
 981      * Network data producer of a &quot;status_request_v2&quot; extension in the
 982      * ServerHello handshake message.
 983      */
 984     private static final
 985             class SHCertStatusReqV2Producer implements HandshakeProducer {
 986         // Prevent instantiation of this class.
 987         private SHCertStatusReqV2Producer() {
 988             // blank
 989         }
</pre>
<hr />
<pre>
 993                 HandshakeMessage message) throws IOException {
 994             // The producing happens in client side only.
 995 
 996             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 997             // The StaplingParameters in the ServerHandshakeContext will
 998             // contain the info about what kind of stapling (if any) to
 999             // perform and whether this status_request extension should be
1000             // produced or the status_request_v2 (found in a different producer)
1001             // No explicit check is required for isStaplingEnabled here.  If
1002             // it is false then stapleParams will be null.  If it is true
1003             // then stapleParams may or may not be false and the check below
1004             // is sufficient.
1005             if ((shc.stapleParams == null) ||
1006                     (shc.stapleParams.statusRespExt !=
1007                     SSLExtension.CH_STATUS_REQUEST_V2)) {
1008                 return null;    // Do not produce status_request_v2 in SH
1009             }
1010 
1011             // In response to &quot;status_request_v2&quot; extension request only
1012             CertStatusRequestV2Spec spec = (CertStatusRequestV2Spec)
<span class="line-modified">1013                 shc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST_V2);</span>
1014             if (spec == null) {
1015                 // Ignore, no status_request_v2 extension requested.
1016                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1017                     SSLLogger.finest(
1018                         &quot;Ignore unavailable status_request_v2 extension&quot;);
1019                 }
1020 
1021                 return null;        // ignore the extension
1022             }
1023 
1024             // Is it a session resuming?
1025             if (shc.isResumption) {
1026                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1027                     SSLLogger.finest(
1028                         &quot;No status_request_v2 response for session resumption&quot;);
1029                 }
1030                 return null;        // ignore the extension
1031             }
1032 
1033             // The &quot;extension_data&quot; in the extended ServerHello handshake
1034             // message MUST be empty.
1035             byte[] extData = new byte[0];
1036 
1037             // Update the context.
<span class="line-modified">1038             shc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST_V2,</span>
<span class="line-modified">1039                     CertStatusRequestV2Spec.DEFAULT);</span>
1040 
1041             return extData;
1042         }
1043     }
1044 
1045     /**
1046      * Network data consumer of a &quot;status_request_v2&quot; extension in the
1047      * ServerHello handshake message.
1048      */
1049     private static final
1050             class SHCertStatusReqV2Consumer implements ExtensionConsumer {
1051         // Prevent instantiation of this class.
1052         private SHCertStatusReqV2Consumer() {
1053             // blank
1054         }
1055 
1056         @Override
1057         public void consume(ConnectionContext context,
1058             HandshakeMessage message, ByteBuffer buffer) throws IOException {
1059 
1060             // The consumption happens in client side only.
1061             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1062 
1063             // In response to &quot;status_request&quot; extension request only
1064             CertStatusRequestV2Spec requestedCsr = (CertStatusRequestV2Spec)
<span class="line-modified">1065                 chc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST_V2);</span>
1066             if (requestedCsr == null) {
1067                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1068                     &quot;Unexpected status_request_v2 extension in ServerHello&quot;);
1069             }
1070 
1071             // Parse the extension.
1072             if (buffer.hasRemaining()) {
1073                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1074                   &quot;Invalid status_request_v2 extension in ServerHello: &quot; +
1075                   &quot;the extension data must be empty&quot;);
1076             }
1077 
1078             // Update the context.
<span class="line-modified">1079             chc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST_V2,</span>
<span class="line-modified">1080                     CertStatusRequestV2Spec.DEFAULT);</span>


1081 
1082             // Since we&#39;ve received a legitimate status_request in the
<span class="line-modified">1083             // ServerHello, stapling is active if it&#39;s been enabled.  If it</span>
<span class="line-added">1084             // is active, make sure we add the CertificateStatus message</span>
<span class="line-added">1085             // consumer.</span>
1086             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
<span class="line-added">1087             if (chc.staplingActive) {</span>
<span class="line-added">1088                 chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,</span>
<span class="line-added">1089                     SSLHandshake.CERTIFICATE_STATUS);</span>
<span class="line-added">1090             }</span>
1091 
1092             // No impact on session resumption.
1093         }
1094     }
1095 
1096     private static final
1097             class CTCertStatusResponseProducer implements HandshakeProducer {
1098         // Prevent instantiation of this class.
1099         private CTCertStatusResponseProducer() {
1100             // blank
1101         }
1102 
1103         @Override
1104         public byte[] produce(ConnectionContext context,
1105                 HandshakeMessage message) throws IOException {
1106             ServerHandshakeContext shc = (ServerHandshakeContext)context;
1107             byte[] producedData = null;
1108 
1109             // Stapling needs to be active and have valid data to proceed
1110             if (shc.stapleParams == null) {
</pre>
</td>
</tr>
</table>
<center><a href="BaseSSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateMessage.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/ECDHServerKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ECDHKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECPointFormatsExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ECDHServerKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<span class="line-modified"> 30 import java.security.CryptoPrimitive;</span>
 31 import java.security.InvalidAlgorithmParameterException;
 32 import java.security.InvalidKeyException;
 33 import java.security.Key;
<span class="line-removed"> 34 import java.security.KeyFactory;</span>
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.PrivateKey;
 37 import java.security.PublicKey;
 38 import java.security.Signature;
 39 import java.security.SignatureException;
<span class="line-removed"> 40 import java.security.interfaces.ECPublicKey;</span>
<span class="line-removed"> 41 import java.security.spec.ECParameterSpec;</span>
<span class="line-removed"> 42 import java.security.spec.ECPoint;</span>
<span class="line-removed"> 43 import java.security.spec.ECPublicKeySpec;</span>
<span class="line-removed"> 44 import java.security.spec.InvalidKeySpecException;</span>
 45 import java.text.MessageFormat;
<span class="line-removed"> 46 import java.util.EnumSet;</span>
 47 import java.util.Locale;
<span class="line-modified"> 48 import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;</span>
<span class="line-removed"> 49 import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;</span>
 50 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-removed"> 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
 52 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 53 import sun.security.ssl.X509Authentication.X509Credentials;
 54 import sun.security.ssl.X509Authentication.X509Possession;
<span class="line-removed"> 55 import sun.security.util.ECUtil;</span>
 56 import sun.security.util.HexDumpEncoder;
 57 
 58 /**
 59  * Pack of the ServerKeyExchange handshake message.
 60  */
 61 final class ECDHServerKeyExchange {
 62     static final SSLConsumer ecdheHandshakeConsumer =
 63             new ECDHServerKeyExchangeConsumer();
 64     static final HandshakeProducer ecdheHandshakeProducer =
 65             new ECDHServerKeyExchangeProducer();
 66 
 67     /**
 68      * The ECDH ServerKeyExchange handshake message.
 69      */
 70     private static final
 71             class ECDHServerKeyExchangeMessage extends HandshakeMessage {
 72         private static final byte CURVE_NAMED_CURVE = (byte)0x03;
 73 
 74         // id of the named curve
 75         private final NamedGroup namedGroup;
 76 
 77         // encoded public point
 78         private final byte[] publicPoint;
 79 
 80         // signature bytes, or null if anonymous
 81         private final byte[] paramsSignature;
 82 
<span class="line-removed"> 83         // public key object encapsulated in this message</span>
<span class="line-removed"> 84         private final ECPublicKey publicKey;</span>
<span class="line-removed"> 85 </span>
 86         private final boolean useExplicitSigAlgorithm;
 87 
 88         // the signature algorithm used by this ServerKeyExchange message
 89         private final SignatureScheme signatureScheme;
 90 



 91         ECDHServerKeyExchangeMessage(
 92                 HandshakeContext handshakeContext) throws IOException {
 93             super(handshakeContext);
 94 
 95             // This happens in server side only.
 96             ServerHandshakeContext shc =
 97                     (ServerHandshakeContext)handshakeContext;
 98 
<span class="line-modified"> 99             ECDHEPossession ecdhePossession = null;</span>

100             X509Possession x509Possession = null;
101             for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">102                 if (possession instanceof ECDHEPossession) {</span>
<span class="line-modified">103                     ecdhePossession = (ECDHEPossession)possession;</span>
104                     if (x509Possession != null) {
105                         break;
106                     }
107                 } else if (possession instanceof X509Possession) {
108                     x509Possession = (X509Possession)possession;
<span class="line-modified">109                     if (ecdhePossession != null) {</span>
110                         break;
111                     }
112                 }
113             }
114 
<span class="line-modified">115             if (ecdhePossession == null) {</span>
116                 // unlikely
117                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
118                     &quot;No ECDHE credentials negotiated for server key exchange&quot;);
119             }
120 
<span class="line-modified">121             publicKey = ecdhePossession.publicKey;</span>
<span class="line-modified">122             ECParameterSpec params = publicKey.getParams();</span>
<span class="line-modified">123             ECPoint point = publicKey.getW();</span>
<span class="line-modified">124             publicPoint = ECUtil.encodePoint(point, params.getCurve());</span>



125 
<span class="line-modified">126             this.namedGroup = NamedGroup.valueOf(params);</span>
<span class="line-modified">127             if ((namedGroup == null) || (namedGroup.oid == null) ) {</span>

128                 // unlikely
129                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">130                     &quot;Unnamed EC parameter spec: &quot; + params);</span>
131             }
132 
133             if (x509Possession == null) {
134                 // anonymous, no authentication, no signature
135                 paramsSignature = null;
136                 signatureScheme = null;
137                 useExplicitSigAlgorithm = false;
138             } else {
139                 useExplicitSigAlgorithm =
140                         shc.negotiatedProtocol.useTLS12PlusSpec();
141                 Signature signer = null;
142                 if (useExplicitSigAlgorithm) {
<span class="line-modified">143                     signatureScheme = SignatureScheme.getPreferableAlgorithm(</span>
<span class="line-modified">144                             shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">145                             x509Possession.popPrivateKey,</span>
<span class="line-modified">146                             shc.negotiatedProtocol);</span>
<span class="line-modified">147                     if (signatureScheme == null) {</span>


148                         // Unlikely, the credentials generator should have
149                         // selected the preferable signature algorithm properly.
150                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified">151                                 &quot;No preferred signature algorithm for &quot; +</span>
152                                 x509Possession.popPrivateKey.getAlgorithm() +
153                                 &quot;  key&quot;);
<span class="line-modified">154                     }</span>
<span class="line-modified">155                     try {</span>
<span class="line-modified">156                         signer = signatureScheme.getSignature(</span>
<span class="line-removed">157                                 x509Possession.popPrivateKey);</span>
<span class="line-removed">158                     } catch (NoSuchAlgorithmException | InvalidKeyException |</span>
<span class="line-removed">159                             InvalidAlgorithmParameterException nsae) {</span>
<span class="line-removed">160                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-removed">161                             &quot;Unsupported signature algorithm: &quot; +</span>
<span class="line-removed">162                             signatureScheme.name, nsae);</span>
163                     }
164                 } else {
165                     signatureScheme = null;
166                     try {
167                         signer = getSignature(
168                                 x509Possession.popPrivateKey.getAlgorithm(),
169                                 x509Possession.popPrivateKey);
170                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
171                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
172                             &quot;Unsupported signature algorithm: &quot; +
173                             x509Possession.popPrivateKey.getAlgorithm(), e);
174                     }
175                 }
176 
177                 byte[] signature = null;
178                 try {
179                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
180                             shc.serverHelloRandom.randomBytes,
181                             namedGroup.id, publicPoint);
182                     signature = signer.sign();
</pre>
<hr />
<pre>
199 
200             byte curveType = (byte)Record.getInt8(m);
201             if (curveType != CURVE_NAMED_CURVE) {
202                 // Unlikely as only the named curves should be negotiated.
203                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
204                     &quot;Unsupported ECCurveType: &quot; + curveType);
205             }
206 
207             int namedGroupId = Record.getInt16(m);
208             this.namedGroup = NamedGroup.valueOf(namedGroupId);
209             if (namedGroup == null) {
210                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
211                     &quot;Unknown named group ID: &quot; + namedGroupId);
212             }
213 
214             if (!SupportedGroups.isSupported(namedGroup)) {
215                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
216                     &quot;Unsupported named group: &quot; + namedGroup);
217             }
218 
<span class="line-removed">219             if (namedGroup.oid == null) {</span>
<span class="line-removed">220                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-removed">221                     &quot;Unknown named EC curve: &quot; + namedGroup);</span>
<span class="line-removed">222             }</span>
<span class="line-removed">223 </span>
<span class="line-removed">224             ECParameterSpec parameters =</span>
<span class="line-removed">225                     ECUtil.getECParameterSpec(null, namedGroup.oid);</span>
<span class="line-removed">226             if (parameters == null) {</span>
<span class="line-removed">227                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-removed">228                     &quot;No supported EC parameter: &quot; + namedGroup);</span>
<span class="line-removed">229             }</span>
<span class="line-removed">230 </span>
231             publicPoint = Record.getBytes8(m);
232             if (publicPoint.length == 0) {
233                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">234                     &quot;Insufficient ECPoint data: &quot; + namedGroup);</span>
235             }
236 
<span class="line-removed">237             ECPublicKey ecPublicKey = null;</span>
238             try {
<span class="line-modified">239                 ECPoint point =</span>
<span class="line-modified">240                         ECUtil.decodePoint(publicPoint, parameters.getCurve());</span>
<span class="line-modified">241                 KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">242                 ecPublicKey = (ECPublicKey)factory.generatePublic(</span>
<span class="line-modified">243                     new ECPublicKeySpec(point, parameters));</span>
<span class="line-modified">244             } catch (NoSuchAlgorithmException |</span>
<span class="line-modified">245                     InvalidKeySpecException | IOException ex) {</span>
<span class="line-modified">246                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-removed">247                     &quot;Invalid ECPoint: &quot; + namedGroup, ex);</span>
248             }
249 
<span class="line-removed">250             publicKey = ecPublicKey;</span>
<span class="line-removed">251 </span>
252             X509Credentials x509Credentials = null;
253             for (SSLCredentials cd : chc.handshakeCredentials) {
254                 if (cd instanceof X509Credentials) {
255                     x509Credentials = (X509Credentials)cd;
256                     break;
257                 }
258             }
259 
260             if (x509Credentials == null) {
261                 // anonymous, no authentication, no signature
262                 if (m.hasRemaining()) {
263                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
264                         &quot;Invalid DH ServerKeyExchange: unknown extra data&quot;);
265                 }
266                 this.signatureScheme = null;
267                 this.paramsSignature = null;
268                 this.useExplicitSigAlgorithm = false;
269 
270                 return;
271             }
</pre>
<hr />
<pre>
279                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
280                         &quot;Invalid signature algorithm (&quot; + ssid +
281                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
282                 }
283 
284                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
285                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
286                         &quot;Unsupported signature algorithm (&quot; +
287                         signatureScheme.name +
288                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
289                 }
290             } else {
291                 signatureScheme = null;
292             }
293 
294             // read and verify the signature
295             paramsSignature = Record.getBytes16(m);
296             Signature signer;
297             if (useExplicitSigAlgorithm) {
298                 try {
<span class="line-modified">299                     signer = signatureScheme.getSignature(</span>
300                             x509Credentials.popPublicKey);
301                 } catch (NoSuchAlgorithmException | InvalidKeyException |
302                         InvalidAlgorithmParameterException nsae) {
303                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
304                         &quot;Unsupported signature algorithm: &quot; +
305                         signatureScheme.name, nsae);
306                 }
307             } else {
308                 try {
309                     signer = getSignature(
310                             x509Credentials.popPublicKey.getAlgorithm(),
311                             x509Credentials.popPublicKey);
312                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
313                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
314                         &quot;Unsupported signature algorithm: &quot; +
315                         x509Credentials.popPublicKey.getAlgorithm(), e);
316                 }
317             }
318 
319             try {
</pre>
<hr />
<pre>
512             return null;
513         }
514     }
515 
516     /**
517      * The ECDH &quot;ServerKeyExchange&quot; handshake message consumer.
518      */
519     private static final
520             class ECDHServerKeyExchangeConsumer implements SSLConsumer {
521         // Prevent instantiation of this class.
522         private ECDHServerKeyExchangeConsumer() {
523             // blank
524         }
525 
526         @Override
527         public void consume(ConnectionContext context,
528                 ByteBuffer message) throws IOException {
529             // The consuming happens in client side only.
530             ClientHandshakeContext chc = (ClientHandshakeContext)context;
531 

532             ECDHServerKeyExchangeMessage skem =
533                     new ECDHServerKeyExchangeMessage(chc, message);
534             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
535                 SSLLogger.fine(
536                     &quot;Consuming ECDH ServerKeyExchange handshake message&quot;, skem);
537             }
538 
<span class="line-removed">539             //</span>
<span class="line-removed">540             // validate</span>
<span class="line-removed">541             //</span>
<span class="line-removed">542             // check constraints of EC PublicKey</span>
<span class="line-removed">543             if (!chc.algorithmConstraints.permits(</span>
<span class="line-removed">544                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">545                     skem.publicKey)) {</span>
<span class="line-removed">546                 throw chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-removed">547                         &quot;ECDH ServerKeyExchange does not comply &quot; +</span>
<span class="line-removed">548                         &quot;to algorithm constraints&quot;);</span>
<span class="line-removed">549             }</span>
<span class="line-removed">550 </span>
551             //
552             // update
553             //
<span class="line-modified">554             chc.handshakeCredentials.add(</span>
<span class="line-removed">555                     new ECDHECredentials(skem.publicKey, skem.namedGroup));</span>
556 
557             //
558             // produce
559             //
560             // Need no new handshake message producers here.
561         }
562     }
563 }
564 
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<span class="line-modified"> 30 import java.security.GeneralSecurityException;</span>
 31 import java.security.InvalidAlgorithmParameterException;
 32 import java.security.InvalidKeyException;
 33 import java.security.Key;

 34 import java.security.NoSuchAlgorithmException;
 35 import java.security.PrivateKey;
 36 import java.security.PublicKey;
 37 import java.security.Signature;
 38 import java.security.SignatureException;





 39 import java.text.MessageFormat;

 40 import java.util.Locale;
<span class="line-modified"> 41 import java.util.Map;</span>

 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;

 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.ssl.X509Authentication.X509Credentials;
 45 import sun.security.ssl.X509Authentication.X509Possession;

 46 import sun.security.util.HexDumpEncoder;
 47 
 48 /**
 49  * Pack of the ServerKeyExchange handshake message.
 50  */
 51 final class ECDHServerKeyExchange {
 52     static final SSLConsumer ecdheHandshakeConsumer =
 53             new ECDHServerKeyExchangeConsumer();
 54     static final HandshakeProducer ecdheHandshakeProducer =
 55             new ECDHServerKeyExchangeProducer();
 56 
 57     /**
 58      * The ECDH ServerKeyExchange handshake message.
 59      */
 60     private static final
 61             class ECDHServerKeyExchangeMessage extends HandshakeMessage {
 62         private static final byte CURVE_NAMED_CURVE = (byte)0x03;
 63 
 64         // id of the named curve
 65         private final NamedGroup namedGroup;
 66 
 67         // encoded public point
 68         private final byte[] publicPoint;
 69 
 70         // signature bytes, or null if anonymous
 71         private final byte[] paramsSignature;
 72 



 73         private final boolean useExplicitSigAlgorithm;
 74 
 75         // the signature algorithm used by this ServerKeyExchange message
 76         private final SignatureScheme signatureScheme;
 77 
<span class="line-added"> 78         // the parsed credential object</span>
<span class="line-added"> 79         private SSLCredentials sslCredentials;</span>
<span class="line-added"> 80 </span>
 81         ECDHServerKeyExchangeMessage(
 82                 HandshakeContext handshakeContext) throws IOException {
 83             super(handshakeContext);
 84 
 85             // This happens in server side only.
 86             ServerHandshakeContext shc =
 87                     (ServerHandshakeContext)handshakeContext;
 88 
<span class="line-modified"> 89             // Find the Possessions needed</span>
<span class="line-added"> 90             NamedGroupPossession namedGroupPossession = null;</span>
 91             X509Possession x509Possession = null;
 92             for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified"> 93                 if (possession instanceof NamedGroupPossession) {</span>
<span class="line-modified"> 94                     namedGroupPossession = (NamedGroupPossession)possession;</span>
 95                     if (x509Possession != null) {
 96                         break;
 97                     }
 98                 } else if (possession instanceof X509Possession) {
 99                     x509Possession = (X509Possession)possession;
<span class="line-modified">100                     if (namedGroupPossession != null) {</span>
101                         break;
102                     }
103                 }
104             }
105 
<span class="line-modified">106             if (namedGroupPossession == null) {</span>
107                 // unlikely
108                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
109                     &quot;No ECDHE credentials negotiated for server key exchange&quot;);
110             }
111 
<span class="line-modified">112             // Find the NamedGroup used for the ephemeral keys.</span>
<span class="line-modified">113             namedGroup = namedGroupPossession.getNamedGroup();</span>
<span class="line-modified">114             if ((namedGroup == null) || (!namedGroup.isAvailable)) {</span>
<span class="line-modified">115                 // unlikely</span>
<span class="line-added">116                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">117                     &quot;Missing or improper named group: &quot; + namedGroup);</span>
<span class="line-added">118             }</span>
119 
<span class="line-modified">120             publicPoint = namedGroup.encodePossessionPublicKey(</span>
<span class="line-modified">121                     namedGroupPossession);</span>
<span class="line-added">122             if (publicPoint == null) {</span>
123                 // unlikely
124                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">125                     &quot;Missing public point for named group: &quot; + namedGroup);</span>
126             }
127 
128             if (x509Possession == null) {
129                 // anonymous, no authentication, no signature
130                 paramsSignature = null;
131                 signatureScheme = null;
132                 useExplicitSigAlgorithm = false;
133             } else {
134                 useExplicitSigAlgorithm =
135                         shc.negotiatedProtocol.useTLS12PlusSpec();
136                 Signature signer = null;
137                 if (useExplicitSigAlgorithm) {
<span class="line-modified">138                     Map.Entry&lt;SignatureScheme, Signature&gt; schemeAndSigner =</span>
<span class="line-modified">139                             SignatureScheme.getSignerOfPreferableAlgorithm(</span>
<span class="line-modified">140                                 shc.algorithmConstraints,</span>
<span class="line-modified">141                                 shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">142                                 x509Possession,</span>
<span class="line-added">143                                 shc.negotiatedProtocol);</span>
<span class="line-added">144                     if (schemeAndSigner == null) {</span>
145                         // Unlikely, the credentials generator should have
146                         // selected the preferable signature algorithm properly.
147                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified">148                                 &quot;No supported signature algorithm for &quot; +</span>
149                                 x509Possession.popPrivateKey.getAlgorithm() +
150                                 &quot;  key&quot;);
<span class="line-modified">151                     } else {</span>
<span class="line-modified">152                         signatureScheme = schemeAndSigner.getKey();</span>
<span class="line-modified">153                         signer = schemeAndSigner.getValue();</span>






154                     }
155                 } else {
156                     signatureScheme = null;
157                     try {
158                         signer = getSignature(
159                                 x509Possession.popPrivateKey.getAlgorithm(),
160                                 x509Possession.popPrivateKey);
161                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
162                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
163                             &quot;Unsupported signature algorithm: &quot; +
164                             x509Possession.popPrivateKey.getAlgorithm(), e);
165                     }
166                 }
167 
168                 byte[] signature = null;
169                 try {
170                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
171                             shc.serverHelloRandom.randomBytes,
172                             namedGroup.id, publicPoint);
173                     signature = signer.sign();
</pre>
<hr />
<pre>
190 
191             byte curveType = (byte)Record.getInt8(m);
192             if (curveType != CURVE_NAMED_CURVE) {
193                 // Unlikely as only the named curves should be negotiated.
194                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
195                     &quot;Unsupported ECCurveType: &quot; + curveType);
196             }
197 
198             int namedGroupId = Record.getInt16(m);
199             this.namedGroup = NamedGroup.valueOf(namedGroupId);
200             if (namedGroup == null) {
201                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
202                     &quot;Unknown named group ID: &quot; + namedGroupId);
203             }
204 
205             if (!SupportedGroups.isSupported(namedGroup)) {
206                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
207                     &quot;Unsupported named group: &quot; + namedGroup);
208             }
209 












210             publicPoint = Record.getBytes8(m);
211             if (publicPoint.length == 0) {
212                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">213                     &quot;Insufficient Point data: &quot; + namedGroup);</span>
214             }
215 

216             try {
<span class="line-modified">217                 sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">218                     publicPoint, handshakeContext.algorithmConstraints,</span>
<span class="line-modified">219                      s -&gt; chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">220                      &quot;ServerKeyExchange &quot; + namedGroup + &quot;: &quot; + (s)));</span>
<span class="line-modified">221             } catch (GeneralSecurityException ex) {</span>
<span class="line-modified">222                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">223                         &quot;Cannot decode named group: &quot; +</span>
<span class="line-modified">224                         NamedGroup.nameOf(namedGroupId));</span>

225             }
226 


227             X509Credentials x509Credentials = null;
228             for (SSLCredentials cd : chc.handshakeCredentials) {
229                 if (cd instanceof X509Credentials) {
230                     x509Credentials = (X509Credentials)cd;
231                     break;
232                 }
233             }
234 
235             if (x509Credentials == null) {
236                 // anonymous, no authentication, no signature
237                 if (m.hasRemaining()) {
238                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
239                         &quot;Invalid DH ServerKeyExchange: unknown extra data&quot;);
240                 }
241                 this.signatureScheme = null;
242                 this.paramsSignature = null;
243                 this.useExplicitSigAlgorithm = false;
244 
245                 return;
246             }
</pre>
<hr />
<pre>
254                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
255                         &quot;Invalid signature algorithm (&quot; + ssid +
256                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
257                 }
258 
259                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
260                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
261                         &quot;Unsupported signature algorithm (&quot; +
262                         signatureScheme.name +
263                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
264                 }
265             } else {
266                 signatureScheme = null;
267             }
268 
269             // read and verify the signature
270             paramsSignature = Record.getBytes16(m);
271             Signature signer;
272             if (useExplicitSigAlgorithm) {
273                 try {
<span class="line-modified">274                     signer = signatureScheme.getVerifier(</span>
275                             x509Credentials.popPublicKey);
276                 } catch (NoSuchAlgorithmException | InvalidKeyException |
277                         InvalidAlgorithmParameterException nsae) {
278                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
279                         &quot;Unsupported signature algorithm: &quot; +
280                         signatureScheme.name, nsae);
281                 }
282             } else {
283                 try {
284                     signer = getSignature(
285                             x509Credentials.popPublicKey.getAlgorithm(),
286                             x509Credentials.popPublicKey);
287                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
288                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
289                         &quot;Unsupported signature algorithm: &quot; +
290                         x509Credentials.popPublicKey.getAlgorithm(), e);
291                 }
292             }
293 
294             try {
</pre>
<hr />
<pre>
487             return null;
488         }
489     }
490 
491     /**
492      * The ECDH &quot;ServerKeyExchange&quot; handshake message consumer.
493      */
494     private static final
495             class ECDHServerKeyExchangeConsumer implements SSLConsumer {
496         // Prevent instantiation of this class.
497         private ECDHServerKeyExchangeConsumer() {
498             // blank
499         }
500 
501         @Override
502         public void consume(ConnectionContext context,
503                 ByteBuffer message) throws IOException {
504             // The consuming happens in client side only.
505             ClientHandshakeContext chc = (ClientHandshakeContext)context;
506 
<span class="line-added">507             // AlgorithmConstraints are checked during decoding</span>
508             ECDHServerKeyExchangeMessage skem =
509                     new ECDHServerKeyExchangeMessage(chc, message);
510             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
511                 SSLLogger.fine(
512                     &quot;Consuming ECDH ServerKeyExchange handshake message&quot;, skem);
513             }
514 












515             //
516             // update
517             //
<span class="line-modified">518             chc.handshakeCredentials.add(skem.sslCredentials);</span>

519 
520             //
521             // produce
522             //
523             // Need no new handshake message producers here.
524         }
525     }
526 }
527 
</pre>
</td>
</tr>
</table>
<center><a href="ECDHKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECPointFormatsExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
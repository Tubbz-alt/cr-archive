<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/ECDHServerKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<a name="1" id="anc1"></a><span class="line-modified"> 30 import java.security.GeneralSecurityException;</span>
 31 import java.security.InvalidAlgorithmParameterException;
 32 import java.security.InvalidKeyException;
 33 import java.security.Key;
<a name="2" id="anc2"></a>
 34 import java.security.NoSuchAlgorithmException;
 35 import java.security.PrivateKey;
 36 import java.security.PublicKey;
 37 import java.security.Signature;
 38 import java.security.SignatureException;
<a name="3" id="anc3"></a>




 39 import java.text.MessageFormat;
<a name="4" id="anc4"></a>
 40 import java.util.Locale;
<a name="5" id="anc5"></a><span class="line-modified"> 41 import java.util.Map;</span>

 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<a name="6" id="anc6"></a>
 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.ssl.X509Authentication.X509Credentials;
 45 import sun.security.ssl.X509Authentication.X509Possession;
<a name="7" id="anc7"></a>
 46 import sun.security.util.HexDumpEncoder;
 47 
 48 /**
 49  * Pack of the ServerKeyExchange handshake message.
 50  */
 51 final class ECDHServerKeyExchange {
 52     static final SSLConsumer ecdheHandshakeConsumer =
 53             new ECDHServerKeyExchangeConsumer();
 54     static final HandshakeProducer ecdheHandshakeProducer =
 55             new ECDHServerKeyExchangeProducer();
 56 
 57     /**
 58      * The ECDH ServerKeyExchange handshake message.
 59      */
 60     private static final
 61             class ECDHServerKeyExchangeMessage extends HandshakeMessage {
 62         private static final byte CURVE_NAMED_CURVE = (byte)0x03;
 63 
 64         // id of the named curve
 65         private final NamedGroup namedGroup;
 66 
 67         // encoded public point
 68         private final byte[] publicPoint;
 69 
 70         // signature bytes, or null if anonymous
 71         private final byte[] paramsSignature;
 72 
<a name="8" id="anc8"></a>


 73         private final boolean useExplicitSigAlgorithm;
 74 
 75         // the signature algorithm used by this ServerKeyExchange message
 76         private final SignatureScheme signatureScheme;
 77 
<a name="9" id="anc9"></a><span class="line-added"> 78         // the parsed credential object</span>
<span class="line-added"> 79         private SSLCredentials sslCredentials;</span>
<span class="line-added"> 80 </span>
 81         ECDHServerKeyExchangeMessage(
 82                 HandshakeContext handshakeContext) throws IOException {
 83             super(handshakeContext);
 84 
 85             // This happens in server side only.
 86             ServerHandshakeContext shc =
 87                     (ServerHandshakeContext)handshakeContext;
 88 
<a name="10" id="anc10"></a><span class="line-modified"> 89             // Find the Possessions needed</span>
<span class="line-added"> 90             NamedGroupPossession namedGroupPossession = null;</span>
 91             X509Possession x509Possession = null;
 92             for (SSLPossession possession : shc.handshakePossessions) {
<a name="11" id="anc11"></a><span class="line-modified"> 93                 if (possession instanceof NamedGroupPossession) {</span>
<span class="line-modified"> 94                     namedGroupPossession = (NamedGroupPossession)possession;</span>
 95                     if (x509Possession != null) {
 96                         break;
 97                     }
 98                 } else if (possession instanceof X509Possession) {
 99                     x509Possession = (X509Possession)possession;
<a name="12" id="anc12"></a><span class="line-modified">100                     if (namedGroupPossession != null) {</span>
101                         break;
102                     }
103                 }
104             }
105 
<a name="13" id="anc13"></a><span class="line-modified">106             if (namedGroupPossession == null) {</span>
107                 // unlikely
108                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
109                     &quot;No ECDHE credentials negotiated for server key exchange&quot;);
110             }
111 
<a name="14" id="anc14"></a><span class="line-modified">112             // Find the NamedGroup used for the ephemeral keys.</span>
<span class="line-modified">113             namedGroup = namedGroupPossession.getNamedGroup();</span>
<span class="line-modified">114             if ((namedGroup == null) || (!namedGroup.isAvailable)) {</span>
<span class="line-modified">115                 // unlikely</span>
<span class="line-added">116                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">117                     &quot;Missing or improper named group: &quot; + namedGroup);</span>
<span class="line-added">118             }</span>
119 
<a name="15" id="anc15"></a><span class="line-modified">120             publicPoint = namedGroup.encodePossessionPublicKey(</span>
<span class="line-modified">121                     namedGroupPossession);</span>
<span class="line-added">122             if (publicPoint == null) {</span>
123                 // unlikely
124                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="16" id="anc16"></a><span class="line-modified">125                     &quot;Missing public point for named group: &quot; + namedGroup);</span>
126             }
127 
128             if (x509Possession == null) {
129                 // anonymous, no authentication, no signature
130                 paramsSignature = null;
131                 signatureScheme = null;
132                 useExplicitSigAlgorithm = false;
133             } else {
134                 useExplicitSigAlgorithm =
135                         shc.negotiatedProtocol.useTLS12PlusSpec();
136                 Signature signer = null;
137                 if (useExplicitSigAlgorithm) {
<a name="17" id="anc17"></a><span class="line-modified">138                     Map.Entry&lt;SignatureScheme, Signature&gt; schemeAndSigner =</span>
<span class="line-modified">139                             SignatureScheme.getSignerOfPreferableAlgorithm(</span>
<span class="line-modified">140                                 shc.algorithmConstraints,</span>
<span class="line-modified">141                                 shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">142                                 x509Possession,</span>
<span class="line-added">143                                 shc.negotiatedProtocol);</span>
<span class="line-added">144                     if (schemeAndSigner == null) {</span>
145                         // Unlikely, the credentials generator should have
146                         // selected the preferable signature algorithm properly.
147                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<a name="18" id="anc18"></a><span class="line-modified">148                                 &quot;No supported signature algorithm for &quot; +</span>
149                                 x509Possession.popPrivateKey.getAlgorithm() +
150                                 &quot;  key&quot;);
<a name="19" id="anc19"></a><span class="line-modified">151                     } else {</span>
<span class="line-modified">152                         signatureScheme = schemeAndSigner.getKey();</span>
<span class="line-modified">153                         signer = schemeAndSigner.getValue();</span>






154                     }
155                 } else {
156                     signatureScheme = null;
157                     try {
158                         signer = getSignature(
159                                 x509Possession.popPrivateKey.getAlgorithm(),
160                                 x509Possession.popPrivateKey);
161                     } catch (NoSuchAlgorithmException | InvalidKeyException e) {
162                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
163                             &quot;Unsupported signature algorithm: &quot; +
164                             x509Possession.popPrivateKey.getAlgorithm(), e);
165                     }
166                 }
167 
168                 byte[] signature = null;
169                 try {
170                     updateSignature(signer, shc.clientHelloRandom.randomBytes,
171                             shc.serverHelloRandom.randomBytes,
172                             namedGroup.id, publicPoint);
173                     signature = signer.sign();
174                 } catch (SignatureException ex) {
175                     throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
176                         &quot;Failed to sign ecdhe parameters: &quot; +
177                         x509Possession.popPrivateKey.getAlgorithm(), ex);
178                 }
179                 paramsSignature = signature;
180             }
181         }
182 
183         ECDHServerKeyExchangeMessage(HandshakeContext handshakeContext,
184                 ByteBuffer m) throws IOException {
185             super(handshakeContext);
186 
187             // This happens in client side only.
188             ClientHandshakeContext chc =
189                     (ClientHandshakeContext)handshakeContext;
190 
191             byte curveType = (byte)Record.getInt8(m);
192             if (curveType != CURVE_NAMED_CURVE) {
193                 // Unlikely as only the named curves should be negotiated.
194                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
195                     &quot;Unsupported ECCurveType: &quot; + curveType);
196             }
197 
198             int namedGroupId = Record.getInt16(m);
199             this.namedGroup = NamedGroup.valueOf(namedGroupId);
200             if (namedGroup == null) {
201                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
202                     &quot;Unknown named group ID: &quot; + namedGroupId);
203             }
204 
205             if (!SupportedGroups.isSupported(namedGroup)) {
206                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
207                     &quot;Unsupported named group: &quot; + namedGroup);
208             }
209 
<a name="20" id="anc20"></a>











210             publicPoint = Record.getBytes8(m);
211             if (publicPoint.length == 0) {
212                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="21" id="anc21"></a><span class="line-modified">213                     &quot;Insufficient Point data: &quot; + namedGroup);</span>
214             }
215 
<a name="22" id="anc22"></a>
216             try {
<a name="23" id="anc23"></a><span class="line-modified">217                 sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">218                     publicPoint, handshakeContext.algorithmConstraints,</span>
<span class="line-modified">219                      s -&gt; chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">220                      &quot;ServerKeyExchange &quot; + namedGroup + &quot;: &quot; + (s)));</span>
<span class="line-modified">221             } catch (GeneralSecurityException ex) {</span>
<span class="line-modified">222                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">223                         &quot;Cannot decode named group: &quot; +</span>
<span class="line-modified">224                         NamedGroup.nameOf(namedGroupId));</span>

225             }
226 
<a name="24" id="anc24"></a>

227             X509Credentials x509Credentials = null;
228             for (SSLCredentials cd : chc.handshakeCredentials) {
229                 if (cd instanceof X509Credentials) {
230                     x509Credentials = (X509Credentials)cd;
231                     break;
232                 }
233             }
234 
235             if (x509Credentials == null) {
236                 // anonymous, no authentication, no signature
237                 if (m.hasRemaining()) {
238                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
239                         &quot;Invalid DH ServerKeyExchange: unknown extra data&quot;);
240                 }
241                 this.signatureScheme = null;
242                 this.paramsSignature = null;
243                 this.useExplicitSigAlgorithm = false;
244 
245                 return;
246             }
247 
248             this.useExplicitSigAlgorithm =
249                     chc.negotiatedProtocol.useTLS12PlusSpec();
250             if (useExplicitSigAlgorithm) {
251                 int ssid = Record.getInt16(m);
252                 signatureScheme = SignatureScheme.valueOf(ssid);
253                 if (signatureScheme == null) {
254                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
255                         &quot;Invalid signature algorithm (&quot; + ssid +
256                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
257                 }
258 
259                 if (!chc.localSupportedSignAlgs.contains(signatureScheme)) {
260                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
261                         &quot;Unsupported signature algorithm (&quot; +
262                         signatureScheme.name +
263                         &quot;) used in ECDH ServerKeyExchange handshake message&quot;);
264                 }
265             } else {
266                 signatureScheme = null;
267             }
268 
269             // read and verify the signature
270             paramsSignature = Record.getBytes16(m);
271             Signature signer;
272             if (useExplicitSigAlgorithm) {
273                 try {
<a name="25" id="anc25"></a><span class="line-modified">274                     signer = signatureScheme.getVerifier(</span>
275                             x509Credentials.popPublicKey);
276                 } catch (NoSuchAlgorithmException | InvalidKeyException |
277                         InvalidAlgorithmParameterException nsae) {
278                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
279                         &quot;Unsupported signature algorithm: &quot; +
280                         signatureScheme.name, nsae);
281                 }
282             } else {
283                 try {
284                     signer = getSignature(
285                             x509Credentials.popPublicKey.getAlgorithm(),
286                             x509Credentials.popPublicKey);
287                 } catch (NoSuchAlgorithmException | InvalidKeyException e) {
288                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
289                         &quot;Unsupported signature algorithm: &quot; +
290                         x509Credentials.popPublicKey.getAlgorithm(), e);
291                 }
292             }
293 
294             try {
295                 updateSignature(signer,
296                         chc.clientHelloRandom.randomBytes,
297                         chc.serverHelloRandom.randomBytes,
298                         namedGroup.id, publicPoint);
299 
300                 if (!signer.verify(paramsSignature)) {
301                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
302                         &quot;Invalid ECDH ServerKeyExchange signature&quot;);
303                 }
304             } catch (SignatureException ex) {
305                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
306                         &quot;Cannot verify ECDH ServerKeyExchange signature&quot;, ex);
307             }
308         }
309 
310         @Override
311         public SSLHandshake handshakeType() {
312             return SSLHandshake.SERVER_KEY_EXCHANGE;
313         }
314 
315         @Override
316         public int messageLength() {
317             int sigLen = 0;
318             if (paramsSignature != null) {
319                 sigLen = 2 + paramsSignature.length;
320                 if (useExplicitSigAlgorithm) {
321                     sigLen += SignatureScheme.sizeInRecord();
322                 }
323             }
324 
325             return 4 + publicPoint.length + sigLen;
326         }
327 
328         @Override
329         public void send(HandshakeOutStream hos) throws IOException {
330             hos.putInt8(CURVE_NAMED_CURVE);
331             hos.putInt16(namedGroup.id);
332             hos.putBytes8(publicPoint);
333             if (paramsSignature != null) {
334                 if (useExplicitSigAlgorithm) {
335                     hos.putInt16(signatureScheme.id);
336                 }
337 
338                 hos.putBytes16(paramsSignature);
339             }
340         }
341 
342         @Override
343         public String toString() {
344             if (useExplicitSigAlgorithm) {
345                 MessageFormat messageFormat = new MessageFormat(
346                     &quot;\&quot;ECDH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
347                     &quot;  \&quot;parameters\&quot;: &#39;{&#39;\n&quot; +
348                     &quot;    \&quot;named group\&quot;: \&quot;{0}\&quot;\n&quot; +
349                     &quot;    \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
350                     &quot;{1}\n&quot; +
351                     &quot;    &#39;}&#39;,\n&quot; +
352                     &quot;  &#39;}&#39;,\n&quot; +
353                     &quot;  \&quot;digital signature\&quot;:  &#39;{&#39;\n&quot; +
354                     &quot;    \&quot;signature algorithm\&quot;: \&quot;{2}\&quot;\n&quot; +
355                     &quot;    \&quot;signature\&quot;: &#39;{&#39;\n&quot; +
356                     &quot;{3}\n&quot; +
357                     &quot;    &#39;}&#39;,\n&quot; +
358                     &quot;  &#39;}&#39;\n&quot; +
359                     &quot;&#39;}&#39;&quot;,
360                     Locale.ENGLISH);
361 
362                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
363                 Object[] messageFields = {
364                     namedGroup.name,
365                     Utilities.indent(
366                             hexEncoder.encodeBuffer(publicPoint), &quot;      &quot;),
367                     signatureScheme.name,
368                     Utilities.indent(
369                             hexEncoder.encodeBuffer(paramsSignature), &quot;      &quot;)
370                 };
371                 return messageFormat.format(messageFields);
372             } else if (paramsSignature != null) {
373                 MessageFormat messageFormat = new MessageFormat(
374                     &quot;\&quot;ECDH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
375                     &quot;  \&quot;parameters\&quot;:  &#39;{&#39;\n&quot; +
376                     &quot;    \&quot;named group\&quot;: \&quot;{0}\&quot;\n&quot; +
377                     &quot;    \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
378                     &quot;{1}\n&quot; +
379                     &quot;    &#39;}&#39;,\n&quot; +
380                     &quot;  &#39;}&#39;,\n&quot; +
381                     &quot;  \&quot;signature\&quot;: &#39;{&#39;\n&quot; +
382                     &quot;{2}\n&quot; +
383                     &quot;  &#39;}&#39;\n&quot; +
384                     &quot;&#39;}&#39;&quot;,
385                     Locale.ENGLISH);
386 
387                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
388                 Object[] messageFields = {
389                     namedGroup.name,
390                     Utilities.indent(
391                             hexEncoder.encodeBuffer(publicPoint), &quot;      &quot;),
392                     Utilities.indent(
393                             hexEncoder.encodeBuffer(paramsSignature), &quot;    &quot;)
394                 };
395 
396                 return messageFormat.format(messageFields);
397             } else {    // anonymous
398                 MessageFormat messageFormat = new MessageFormat(
399                     &quot;\&quot;ECDH ServerKeyExchange\&quot;: &#39;{&#39;\n&quot; +
400                     &quot;  \&quot;parameters\&quot;:  &#39;{&#39;\n&quot; +
401                     &quot;    \&quot;named group\&quot;: \&quot;{0}\&quot;\n&quot; +
402                     &quot;    \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
403                     &quot;{1}\n&quot; +
404                     &quot;    &#39;}&#39;,\n&quot; +
405                     &quot;  &#39;}&#39;\n&quot; +
406                     &quot;&#39;}&#39;&quot;,
407                     Locale.ENGLISH);
408 
409                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
410                 Object[] messageFields = {
411                     namedGroup.name,
412                     Utilities.indent(
413                             hexEncoder.encodeBuffer(publicPoint), &quot;      &quot;),
414                 };
415 
416                 return messageFormat.format(messageFields);
417             }
418         }
419 
420         private static Signature getSignature(String keyAlgorithm,
421                 Key key) throws NoSuchAlgorithmException, InvalidKeyException {
422             Signature signer = null;
423             switch (keyAlgorithm) {
424                 case &quot;EC&quot;:
425                     signer = Signature.getInstance(JsseJce.SIGNATURE_ECDSA);
426                     break;
427                 case &quot;RSA&quot;:
428                     signer = RSASignature.getInstance();
429                     break;
430                 default:
431                     throw new NoSuchAlgorithmException(
432                         &quot;neither an RSA or a EC key : &quot; + keyAlgorithm);
433             }
434 
435             if (signer != null) {
436                 if (key instanceof PublicKey) {
437                     signer.initVerify((PublicKey)(key));
438                 } else {
439                     signer.initSign((PrivateKey)key);
440                 }
441             }
442 
443             return signer;
444         }
445 
446         private static void updateSignature(Signature sig,
447                 byte[] clntNonce, byte[] svrNonce, int namedGroupId,
448                 byte[] publicPoint) throws SignatureException {
449             sig.update(clntNonce);
450             sig.update(svrNonce);
451 
452             sig.update(CURVE_NAMED_CURVE);
453             sig.update((byte)((namedGroupId &gt;&gt; 8) &amp; 0xFF));
454             sig.update((byte)(namedGroupId &amp; 0xFF));
455             sig.update((byte)publicPoint.length);
456             sig.update(publicPoint);
457         }
458     }
459 
460     /**
461      * The ECDH &quot;ServerKeyExchange&quot; handshake message producer.
462      */
463     private static final
464             class ECDHServerKeyExchangeProducer implements HandshakeProducer {
465         // Prevent instantiation of this class.
466         private ECDHServerKeyExchangeProducer() {
467             // blank
468         }
469 
470         @Override
471         public byte[] produce(ConnectionContext context,
472                 HandshakeMessage message) throws IOException {
473             // The producing happens in server side only.
474             ServerHandshakeContext shc = (ServerHandshakeContext)context;
475             ECDHServerKeyExchangeMessage skem =
476                     new ECDHServerKeyExchangeMessage(shc);
477             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
478                 SSLLogger.fine(
479                     &quot;Produced ECDH ServerKeyExchange handshake message&quot;, skem);
480             }
481 
482             // Output the handshake message.
483             skem.write(shc.handshakeOutput);
484             shc.handshakeOutput.flush();
485 
486             // The handshake message has been delivered.
487             return null;
488         }
489     }
490 
491     /**
492      * The ECDH &quot;ServerKeyExchange&quot; handshake message consumer.
493      */
494     private static final
495             class ECDHServerKeyExchangeConsumer implements SSLConsumer {
496         // Prevent instantiation of this class.
497         private ECDHServerKeyExchangeConsumer() {
498             // blank
499         }
500 
501         @Override
502         public void consume(ConnectionContext context,
503                 ByteBuffer message) throws IOException {
504             // The consuming happens in client side only.
505             ClientHandshakeContext chc = (ClientHandshakeContext)context;
506 
<a name="26" id="anc26"></a><span class="line-added">507             // AlgorithmConstraints are checked during decoding</span>
508             ECDHServerKeyExchangeMessage skem =
509                     new ECDHServerKeyExchangeMessage(chc, message);
510             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
511                 SSLLogger.fine(
512                     &quot;Consuming ECDH ServerKeyExchange handshake message&quot;, skem);
513             }
514 
<a name="27" id="anc27"></a>











515             //
516             // update
517             //
<a name="28" id="anc28"></a><span class="line-modified">518             chc.handshakeCredentials.add(skem.sslCredentials);</span>

519 
520             //
521             // produce
522             //
523             // Need no new handshake message producers here.
524         }
525     }
526 }
527 
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
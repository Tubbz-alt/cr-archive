<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/DTLSInputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DHServerKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DTLSOutputRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/DTLSInputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
<span class="line-modified">  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 9406+5 USA</span>
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.GeneralSecurityException;
  31 import java.util.Collections;
  32 import java.util.HashMap;
  33 import java.util.Iterator;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Set;
  37 import java.util.TreeSet;
  38 import javax.crypto.BadPaddingException;
  39 import javax.net.ssl.SSLException;
  40 import sun.security.ssl.SSLCipher.SSLReadCipher;
  41 
  42 /**
  43  * DTLS {@code InputRecord} implementation for {@code SSLEngine}.
  44  */
  45 final class DTLSInputRecord extends InputRecord implements DTLSRecord {
  46     private DTLSReassembler reassembler = null;
  47     private int             readEpoch;
  48 
  49     DTLSInputRecord(HandshakeHash handshakeHash) {
  50         super(handshakeHash, SSLReadCipher.nullDTlsReadCipher());
  51         this.readEpoch = 0;
  52     }
  53 
  54     @Override
  55     void changeReadCiphers(SSLReadCipher readCipher) {
  56         this.readCipher = readCipher;
  57         this.readEpoch++;
  58     }
  59 
  60     @Override
<span class="line-modified">  61     public synchronized void close() throws IOException {</span>
  62         if (!isClosed) {
  63             super.close();
  64         }
  65     }
  66 
  67     @Override
  68     boolean isEmpty() {
  69         return ((reassembler == null) || reassembler.isEmpty());
  70     }
  71 
  72     @Override
  73     int estimateFragmentSize(int packetSize) {
  74         if (packetSize &gt; 0) {
  75             return readCipher.estimateFragmentSize(packetSize, headerSize);
  76         } else {
  77             return Record.maxDataSize;
  78         }
  79     }
  80 
  81     @Override
</pre>
<hr />
<pre>
 342 
 343         return fragLen;
 344     }
 345 
 346     private static HandshakeFragment parseHandshakeMessage(
 347             byte contentType, byte majorVersion, byte minorVersion,
 348             byte[] recordEnS, int recordEpoch, long recordSeq,
 349             ByteBuffer plaintextFragment) {
 350 
 351         int remaining = plaintextFragment.remaining();
 352         if (remaining &lt; handshakeHeaderSize) {
 353             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 354                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 355                         &quot;too small record to hold a handshake fragment&quot;);
 356             }
 357 
 358             // invalid, discard this record [section 4.1.2.7, RFC 6347]
 359             return null;
 360         }
 361 

 362         byte handshakeType = plaintextFragment.get();       // pos: 0











 363         int messageLength =
 364                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 365                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 366                  (plaintextFragment.get() &amp; 0xFF);          // pos: 1-3
 367         int messageSeq =
 368                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 369                  (plaintextFragment.get() &amp; 0xFF);          // pos: 4/5
 370         int fragmentOffset =
 371                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 372                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 373                  (plaintextFragment.get() &amp; 0xFF);          // pos: 6-8
 374         int fragmentLength =
 375                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 376                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 377                  (plaintextFragment.get() &amp; 0xFF);          // pos: 9-11
 378         if ((remaining - handshakeHeaderSize) &lt; fragmentLength) {
 379             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 380                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 381                         &quot;not a complete handshake fragment in the record&quot;);
 382             }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
<span class="line-modified">  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</span>
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.GeneralSecurityException;
  31 import java.util.Collections;
  32 import java.util.HashMap;
  33 import java.util.Iterator;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Set;
  37 import java.util.TreeSet;
  38 import javax.crypto.BadPaddingException;
  39 import javax.net.ssl.SSLException;
  40 import sun.security.ssl.SSLCipher.SSLReadCipher;
  41 
  42 /**
  43  * DTLS {@code InputRecord} implementation for {@code SSLEngine}.
  44  */
  45 final class DTLSInputRecord extends InputRecord implements DTLSRecord {
  46     private DTLSReassembler reassembler = null;
  47     private int             readEpoch;
  48 
  49     DTLSInputRecord(HandshakeHash handshakeHash) {
  50         super(handshakeHash, SSLReadCipher.nullDTlsReadCipher());
  51         this.readEpoch = 0;
  52     }
  53 
  54     @Override
  55     void changeReadCiphers(SSLReadCipher readCipher) {
  56         this.readCipher = readCipher;
  57         this.readEpoch++;
  58     }
  59 
  60     @Override
<span class="line-modified">  61     public void close() throws IOException {</span>
  62         if (!isClosed) {
  63             super.close();
  64         }
  65     }
  66 
  67     @Override
  68     boolean isEmpty() {
  69         return ((reassembler == null) || reassembler.isEmpty());
  70     }
  71 
  72     @Override
  73     int estimateFragmentSize(int packetSize) {
  74         if (packetSize &gt; 0) {
  75             return readCipher.estimateFragmentSize(packetSize, headerSize);
  76         } else {
  77             return Record.maxDataSize;
  78         }
  79     }
  80 
  81     @Override
</pre>
<hr />
<pre>
 342 
 343         return fragLen;
 344     }
 345 
 346     private static HandshakeFragment parseHandshakeMessage(
 347             byte contentType, byte majorVersion, byte minorVersion,
 348             byte[] recordEnS, int recordEpoch, long recordSeq,
 349             ByteBuffer plaintextFragment) {
 350 
 351         int remaining = plaintextFragment.remaining();
 352         if (remaining &lt; handshakeHeaderSize) {
 353             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 354                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 355                         &quot;too small record to hold a handshake fragment&quot;);
 356             }
 357 
 358             // invalid, discard this record [section 4.1.2.7, RFC 6347]
 359             return null;
 360         }
 361 
<span class="line-added"> 362         // Fail fast for unknown handshake message.</span>
 363         byte handshakeType = plaintextFragment.get();       // pos: 0
<span class="line-added"> 364         if (!SSLHandshake.isKnown(handshakeType)) {</span>
<span class="line-added"> 365             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added"> 366                 SSLLogger.fine(&quot;Discard invalid record: &quot; +</span>
<span class="line-added"> 367                         &quot;unknown handshake type size, Handshake.msg_type = &quot; +</span>
<span class="line-added"> 368                         (handshakeType &amp; 0xFF));</span>
<span class="line-added"> 369             }</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371             // invalid, discard this record [section 4.1.2.7, RFC 6347]</span>
<span class="line-added"> 372             return null;</span>
<span class="line-added"> 373         }</span>
<span class="line-added"> 374 </span>
 375         int messageLength =
 376                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 377                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 378                  (plaintextFragment.get() &amp; 0xFF);          // pos: 1-3
 379         int messageSeq =
 380                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 381                  (plaintextFragment.get() &amp; 0xFF);          // pos: 4/5
 382         int fragmentOffset =
 383                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 384                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 385                  (plaintextFragment.get() &amp; 0xFF);          // pos: 6-8
 386         int fragmentLength =
 387                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 16) |
 388                 ((plaintextFragment.get() &amp; 0xFF) &lt;&lt; 8) |
 389                  (plaintextFragment.get() &amp; 0xFF);          // pos: 9-11
 390         if ((remaining - handshakeHeaderSize) &lt; fragmentLength) {
 391             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 392                 SSLLogger.fine(&quot;Discard invalid record: &quot; +
 393                         &quot;not a complete handshake fragment in the record&quot;);
 394             }
</pre>
</td>
</tr>
</table>
<center><a href="DHServerKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DTLSOutputRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
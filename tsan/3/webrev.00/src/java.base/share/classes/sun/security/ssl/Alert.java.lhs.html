<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/Alert.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.text.MessageFormat;
 31 import java.util.Locale;
 32 import javax.net.ssl.SSLException;
 33 import javax.net.ssl.SSLHandshakeException;
 34 import javax.net.ssl.SSLProtocolException;
 35 
 36 /**
 37  * SSL/(D)TLS Alter description
 38  */
 39 enum Alert {
 40     // Please refer to TLS Alert Registry for the latest (D)TLS Alert values:
 41     //     https://www.iana.org/assignments/tls-parameters/
 42     CLOSE_NOTIFY            ((byte)0,   &quot;close_notify&quot;, false),
 43     UNEXPECTED_MESSAGE      ((byte)10,  &quot;unexpected_message&quot;, false),
 44     BAD_RECORD_MAC          ((byte)20,  &quot;bad_record_mac&quot;, false),
 45     DECRYPTION_FAILED       ((byte)21,  &quot;decryption_failed&quot;, false),
 46     RECORD_OVERFLOW         ((byte)22,  &quot;record_overflow&quot;, false),
 47     DECOMPRESSION_FAILURE   ((byte)30,  &quot;decompression_failure&quot;, false),
 48     HANDSHAKE_FAILURE       ((byte)40,  &quot;handshake_failure&quot;, true),
 49     NO_CERTIFICATE          ((byte)41,  &quot;no_certificate&quot;, true),
 50     BAD_CERTIFICATE         ((byte)42,  &quot;bad_certificate&quot;, true),
 51     UNSUPPORTED_CERTIFICATE ((byte)43,  &quot;unsupported_certificate&quot;, true),
 52     CERTIFICATE_REVOKED     ((byte)44,  &quot;certificate_revoked&quot;, true),
 53     CERTIFICATE_EXPIRED     ((byte)45,  &quot;certificate_expired&quot;, true),
 54     CERTIFICATE_UNKNOWN     ((byte)46,  &quot;certificate_unknown&quot;, true),
 55     ILLEGAL_PARAMETER       ((byte)47,  &quot;illegal_parameter&quot;, true),
 56     UNKNOWN_CA              ((byte)48,  &quot;unknown_ca&quot;, true),
 57     ACCESS_DENIED           ((byte)49,  &quot;access_denied&quot;, true),
 58     DECODE_ERROR            ((byte)50,  &quot;decode_error&quot;, true),
 59     DECRYPT_ERROR           ((byte)51,  &quot;decrypt_error&quot;, true),
 60     EXPORT_RESTRICTION      ((byte)60,  &quot;export_restriction&quot;, true),
 61     PROTOCOL_VERSION        ((byte)70,  &quot;protocol_version&quot;, true),
 62     INSUFFICIENT_SECURITY   ((byte)71,  &quot;insufficient_security&quot;, true),
 63     INTERNAL_ERROR          ((byte)80,  &quot;internal_error&quot;, false),
 64     INAPPROPRIATE_FALLBACK  ((byte)86,  &quot;inappropriate_fallback&quot;, false),
 65     USER_CANCELED           ((byte)90,  &quot;user_canceled&quot;, false),
 66     NO_RENEGOTIATION        ((byte)100, &quot;no_renegotiation&quot;, true),
 67     MISSING_EXTENSION       ((byte)109, &quot;missing_extension&quot;, true),
 68     UNSUPPORTED_EXTENSION   ((byte)110, &quot;unsupported_extension&quot;, true),
 69     CERT_UNOBTAINABLE       ((byte)111, &quot;certificate_unobtainable&quot;, true),
 70     UNRECOGNIZED_NAME       ((byte)112, &quot;unrecognized_name&quot;, true),
 71     BAD_CERT_STATUS_RESPONSE((byte)113,
 72                                     &quot;bad_certificate_status_response&quot;, true),
 73     BAD_CERT_HASH_VALUE     ((byte)114, &quot;bad_certificate_hash_value&quot;, true),
 74     UNKNOWN_PSK_IDENTITY    ((byte)115, &quot;unknown_psk_identity&quot;, true),
 75     CERTIFICATE_REQUIRED    ((byte)116, &quot;certificate_required&quot;, true),
 76     NO_APPLICATION_PROTOCOL ((byte)120, &quot;no_application_protocol&quot;, true);
 77 
 78     // ordinal value of the Alert
 79     final byte id;
 80 
 81     // description of the Alert
 82     final String description;
 83 
 84     // Does tha alert happen during handshake only?
 85     final boolean handshakeOnly;
 86 
 87     // Alert message consumer
 88     static final SSLConsumer alertConsumer = new AlertConsumer();
 89 
 90     private Alert(byte id, String description, boolean handshakeOnly) {
 91         this.id = id;
 92         this.description = description;
 93         this.handshakeOnly = handshakeOnly;
 94     }
 95 
 96     static Alert valueOf(byte id) {
 97         for (Alert al : Alert.values()) {
 98             if (al.id == id) {
 99                 return al;
100             }
101         }
102 
103         return null;
104     }
105 
106     static String nameOf(byte id) {
107         for (Alert al : Alert.values()) {
108             if (al.id == id) {
109                 return al.description;
110             }
111         }
112 
113         return &quot;UNKNOWN ALERT (&quot; + (id &amp; 0x0FF) + &quot;)&quot;;
114     }
115 
116     SSLException createSSLException(String reason) {
117         return createSSLException(reason, null);
118     }
119 
120     SSLException createSSLException(String reason, Throwable cause) {
121         if (reason == null) {
122             reason = (cause != null) ? cause.getMessage() : &quot;&quot;;
123         }
124 
125         SSLException ssle;
126         if ((cause != null) &amp;&amp; (cause instanceof IOException)) {
127             ssle = new SSLException(reason);
128         } else if ((this == UNEXPECTED_MESSAGE)) {
129             ssle = new SSLProtocolException(reason);
130         } else if (handshakeOnly) {
131             ssle = new SSLHandshakeException(reason);
132         } else {
133             ssle = new SSLException(reason);
134         }
135 
136         if (cause != null) {
137             ssle.initCause(cause);
138         }
139 
140         return ssle;
141     }
142 
143     /**
144      * SSL/(D)TLS Alert level.
145      */
146     enum Level {
147         WARNING ((byte)1, &quot;warning&quot;),
148         FATAL   ((byte)2, &quot;fatal&quot;);
149 
150         // ordinal value of the Alert level
151         final byte level;
152 
153         // description of the Alert level
154         final String description;
155 
156         private Level(byte level, String description) {
157             this.level = level;
158             this.description = description;
159         }
160 
161         static Level valueOf(byte level) {
162             for (Level lv : Level.values()) {
163                 if (lv.level == level) {
164                     return lv;
165                 }
166             }
167 
168             return null;
169         }
170 
171         static String nameOf(byte level) {
172             for (Level lv : Level.values()) {
173                 if (lv.level == level) {
174                     return lv.description;
175                 }
176             }
177 
178             return &quot;UNKNOWN ALERT LEVEL (&quot; + (level &amp; 0x0FF) + &quot;)&quot;;
179         }
180     }
181 
182     /**
183      * The Alert message.
184      */
185     private static final class AlertMessage {
186         private final byte level;       // level
187         private final byte id;          // description
188 
189         AlertMessage(TransportContext context,
190                 ByteBuffer m) throws IOException {
191             //  struct {
192             //      AlertLevel level;
193             //      AlertDescription description;
194             //  } Alert;
195             if (m.remaining() != 2) {
196                 throw context.fatal(Alert.ILLEGAL_PARAMETER,
197                     &quot;Invalid Alert message: no sufficient data&quot;);
198             }
199 
200             this.level = m.get();   // level
201             this.id = m.get();      // description
202         }
203 
204         @Override
205         public String toString() {
206             MessageFormat messageFormat = new MessageFormat(
207                     &quot;\&quot;Alert\&quot;: &#39;{&#39;\n&quot; +
208                     &quot;  \&quot;level\&quot;      : \&quot;{0}\&quot;,\n&quot; +
209                     &quot;  \&quot;description\&quot;: \&quot;{1}\&quot;\n&quot; +
210                     &quot;&#39;}&#39;&quot;,
211                     Locale.ENGLISH);
212 
213             Object[] messageFields = {
214                 Level.nameOf(level),
215                 Alert.nameOf(id)
216             };
217 
218             return messageFormat.format(messageFields);
219         }
220     }
221 
222     /**
223      * Consumer of alert messages
224      */
225     private static final class AlertConsumer implements SSLConsumer {
226         // Prevent instantiation of this class.
227         private AlertConsumer() {
228             // blank
229         }
230 
231         @Override
232         public void consume(ConnectionContext context,
233                 ByteBuffer m) throws IOException {
234             TransportContext tc = (TransportContext)context;
235 
236             AlertMessage am = new AlertMessage(tc, m);
237             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
238                 SSLLogger.fine(&quot;Received alert message&quot;, am);
239             }
240 
241             Level level = Level.valueOf(am.level);
242             Alert alert = Alert.valueOf(am.id);
243             if (alert == Alert.CLOSE_NOTIFY) {
244                 tc.isInputCloseNotified = true;
245                 tc.closeInbound();
246 
247                 if (tc.peerUserCanceled) {
248                     tc.closeOutbound();
249                 } else if (tc.handshakeContext != null) {
250                     throw tc.fatal(Alert.UNEXPECTED_MESSAGE,
251                             &quot;Received close_notify during handshake&quot;);
252                 }
253             } else if (alert == Alert.USER_CANCELED) {
254                 if (level == Level.WARNING) {
255                     tc.peerUserCanceled = true;
256                 } else {
257                     throw tc.fatal(alert,
258                             &quot;Received fatal close_notify alert&quot;, true, null);
259                 }
260             } else if ((level == Level.WARNING) &amp;&amp; (alert != null)) {
261                 // Terminate the connection if an alert with a level of warning
262                 // is received during handshaking, except the no_certificate
263                 // warning.
264                 if (alert.handshakeOnly &amp;&amp; (tc.handshakeContext != null)) {
265                     // It&#39;s OK to get a no_certificate alert from a client of
266                     // which we requested client authentication.  However,
267                     // if we required it, then this is not acceptable.
268                      if (tc.sslConfig.isClientMode ||
269                             alert != Alert.NO_CERTIFICATE ||
270                             (tc.sslConfig.clientAuthType !=
271                                     ClientAuthType.CLIENT_AUTH_REQUESTED)) {
272                         throw tc.fatal(Alert.HANDSHAKE_FAILURE,
273                             &quot;received handshake warning: &quot; + alert.description);
<a name="1" id="anc1"></a><span class="line-modified">274                     }  // Otherwise, ignore the warning</span>
<span class="line-modified">275                 }   // Otherwise, ignore the warning.</span>






276             } else {    // fatal or unknown
277                 String diagnostic;
278                 if (alert == null) {
279                     alert = Alert.UNEXPECTED_MESSAGE;
280                     diagnostic = &quot;Unknown alert description (&quot; + am.id + &quot;)&quot;;
281                 } else {
282                     diagnostic = &quot;Received fatal alert: &quot; + alert.description;
283                 }
284 
285                 throw tc.fatal(alert, diagnostic, true, null);
286             }
287         }
288     }
289 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
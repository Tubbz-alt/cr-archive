<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/net/www/http/ChunkedOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.net.www.http;
 26 
 27 import java.io.*;
 28 
 29 import sun.nio.cs.US_ASCII;
 30 
 31 /**
 32  * OutputStream that sends the output to the underlying stream using chunked
 33  * encoding as specified in RFC 2068.
 34  */
 35 public class ChunkedOutputStream extends PrintStream {
 36 
 37     /* Default chunk size (including chunk header) if not specified */
 38     static final int DEFAULT_CHUNK_SIZE = 4096;
 39     private static final byte[] CRLF = {&#39;\r&#39;, &#39;\n&#39;};
 40     private static final int CRLF_SIZE = CRLF.length;
 41     private static final byte[] FOOTER = CRLF;
 42     private static final int FOOTER_SIZE = CRLF_SIZE;
 43     private static final byte[] EMPTY_CHUNK_HEADER = getHeader(0);
 44     private static final int EMPTY_CHUNK_HEADER_SIZE = getHeaderSize(0);
 45 
 46     /* internal buffer */
 47     private byte buf[];
 48     /* size of data (excluding footers and headers) already stored in buf */
 49     private int size;
 50     /* current index in buf (i.e. buf[count] */
 51     private int count;
 52     /* number of bytes to be filled up to complete a data chunk
 53      * currently being built */
 54     private int spaceInCurrentChunk;
 55 
 56     /* underlying stream */
 57     private PrintStream out;
 58 
 59     /* the chunk size we use */
 60     private int preferredChunkDataSize;
 61     private int preferedHeaderSize;
 62     private int preferredChunkGrossSize;
 63     /* header for a complete Chunk */
 64     private byte[] completeHeader;
 65 
 66     /* return the size of the header for a particular chunk size */
 67     private static int getHeaderSize(int size) {
 68         return (Integer.toHexString(size)).length() + CRLF_SIZE;
 69     }
 70 
 71     /* return a header for a particular chunk size */
 72     private static byte[] getHeader(int size) {
 73         String hexStr = Integer.toHexString(size);
 74         byte[] hexBytes = hexStr.getBytes(US_ASCII.INSTANCE);
 75         byte[] header = new byte[getHeaderSize(size)];
 76         for (int i=0; i&lt;hexBytes.length; i++)
 77             header[i] = hexBytes[i];
 78         header[hexBytes.length] = CRLF[0];
 79         header[hexBytes.length+1] = CRLF[1];
 80         return header;
 81     }
 82 
 83     public ChunkedOutputStream(PrintStream o) {
 84         this(o, DEFAULT_CHUNK_SIZE);
 85     }
 86 
 87     public ChunkedOutputStream(PrintStream o, int size) {
 88         super(o);
 89         out = o;
 90 
 91         if (size &lt;= 0) {
 92             size = DEFAULT_CHUNK_SIZE;
 93         }
 94 
 95         /* Adjust the size to cater for the chunk header - eg: if the
 96          * preferred chunk size is 1k this means the chunk size should
 97          * be 1017 bytes (differs by 7 from preferred size because of
 98          * 3 bytes for chunk size in hex and CRLF (header) and CRLF (footer)).
 99          *
100          * If headerSize(adjusted_size) is shorter then headerSize(size)
101          * then try to use the extra byte unless headerSize(adjusted_size+1)
102          * increases back to headerSize(size)
103          */
104         if (size &gt; 0) {
105             int adjusted_size = size - getHeaderSize(size) - FOOTER_SIZE;
106             if (getHeaderSize(adjusted_size+1) &lt; getHeaderSize(size)){
107                 adjusted_size++;
108             }
109             size = adjusted_size;
110         }
111 
112         if (size &gt; 0) {
113             preferredChunkDataSize = size;
114         } else {
115             preferredChunkDataSize = DEFAULT_CHUNK_SIZE -
116                     getHeaderSize(DEFAULT_CHUNK_SIZE) - FOOTER_SIZE;
117         }
118 
119         preferedHeaderSize = getHeaderSize(preferredChunkDataSize);
120         preferredChunkGrossSize = preferedHeaderSize + preferredChunkDataSize
121                 + FOOTER_SIZE;
122         completeHeader = getHeader(preferredChunkDataSize);
123 
124         /* start with an initial buffer */
125         buf = new byte[preferredChunkGrossSize];
126         reset();
127     }
128 
129     /*
130      * Flush a buffered, completed chunk to an underlying stream. If the data in
131      * the buffer is insufficient to build up a chunk of &quot;preferredChunkSize&quot;
132      * then the data do not get flushed unless flushAll is true. If flushAll is
133      * true then the remaining data builds up a last chunk which size is smaller
134      * than preferredChunkSize, and then the last chunk gets flushed to
135      * underlying stream. If flushAll is true and there is no data in a buffer
136      * at all then an empty chunk (containing a header only) gets flushed to
137      * underlying stream.
138      */
139      private void flush(boolean flushAll) {
140         if (spaceInCurrentChunk == 0) {
141             /* flush a completed chunk to underlying stream */
142             out.write(buf, 0, preferredChunkGrossSize);
143             out.flush();
144             reset();
145         } else if (flushAll){
146             /* complete the last chunk and flush it to underlying stream */
147             if (size &gt; 0){
148                 /* adjust a header start index in case the header of the last
149                  * chunk is shorter then preferedHeaderSize */
150 
151                 int adjustedHeaderStartIndex = preferedHeaderSize -
152                         getHeaderSize(size);
153 
154                 /* write header */
155                 System.arraycopy(getHeader(size), 0, buf,
156                         adjustedHeaderStartIndex, getHeaderSize(size));
157 
158                 /* write footer */
159                 buf[count++] = FOOTER[0];
160                 buf[count++] = FOOTER[1];
161 
162                 //send the last chunk to underlying stream
163                 out.write(buf, adjustedHeaderStartIndex, count - adjustedHeaderStartIndex);
164             } else {
165                 //send an empty chunk (containing just a header) to underlying stream
166                 out.write(EMPTY_CHUNK_HEADER, 0, EMPTY_CHUNK_HEADER_SIZE);
167             }
168 
169             out.flush();
170             reset();
171          }
172     }
173 
174     @Override
175     public boolean checkError() {
176         return out.checkError();
177     }
178 
179     /* Check that the output stream is still open */
180     private void ensureOpen() {
181         if (out == null)
182             setError();
183     }
184 
185    /*
186     * Writes data from b[] to an internal buffer and stores the data as data
187     * chunks of a following format: {Data length in Hex}{CRLF}{data}{CRLF}
188     * The size of the data is preferredChunkSize. As soon as a completed chunk
189     * is read from b[] a process of reading from b[] suspends, the chunk gets
190     * flushed to the underlying stream and then the reading process from b[]
191     * continues. When there is no more sufficient data in b[] to build up a
192     * chunk of preferredChunkSize size the data get stored as an incomplete
193     * chunk of a following format: {space for data length}{CRLF}{data}
194     * The size of the data is of course smaller than preferredChunkSize.
195     */
196     @Override
197     public synchronized void write(byte b[], int off, int len) {
198         ensureOpen();
199         if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||
200             ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
201             throw new IndexOutOfBoundsException();
202         } else if (len == 0) {
203             return;
204         }
205 
206         /* if b[] contains enough data then one loop cycle creates one complete
207          * data chunk with a header, body and a footer, and then flushes the
208          * chunk to the underlying stream. Otherwise, the last loop cycle
209          * creates incomplete data chunk with empty header and with no footer
210          * and stores this incomplete chunk in an internal buffer buf[]
211          */
212         int bytesToWrite = len;
213         int inputIndex = off;  /* the index of the byte[] currently being written */
214 
215         do {
216             /* enough data to complete a chunk */
217             if (bytesToWrite &gt;= spaceInCurrentChunk) {
218 
219                 /* header */
220                 for (int i=0; i&lt;completeHeader.length; i++)
221                     buf[i] = completeHeader[i];
222 
223                 /* data */
224                 System.arraycopy(b, inputIndex, buf, count, spaceInCurrentChunk);
225                 inputIndex += spaceInCurrentChunk;
226                 bytesToWrite -= spaceInCurrentChunk;
227                 count += spaceInCurrentChunk;
228 
229                 /* footer */
230                 buf[count++] = FOOTER[0];
231                 buf[count++] = FOOTER[1];
232                 spaceInCurrentChunk = 0; //chunk is complete
233 
234                 flush(false);
235                 if (checkError()){
236                     break;
237                 }
238             }
239 
240             /* not enough data to build a chunk */
241             else {
242                 /* header */
243                 /* do not write header if not enough bytes to build a chunk yet */
244 
245                 /* data */
246                 System.arraycopy(b, inputIndex, buf, count, bytesToWrite);
247                 count += bytesToWrite;
248                 size += bytesToWrite;
249                 spaceInCurrentChunk -= bytesToWrite;
250                 bytesToWrite = 0;
251 
252                 /* footer */
253                 /* do not write header if not enough bytes to build a chunk yet */
254             }
255         } while (bytesToWrite &gt; 0);
256     }
257 
258     @Override
259     public synchronized void write(int _b) {
260         byte b[] = {(byte)_b};
261         write(b, 0, 1);
262     }
263 
264     public synchronized void reset() {
265         count = preferedHeaderSize;
266         size = 0;
267         spaceInCurrentChunk = preferredChunkDataSize;
268     }
269 
270     public int size() {
271         return size;
272     }
273 
274     @Override
275     public synchronized void close() {
276         ensureOpen();
277 
278         /* if we have buffer a chunked send it */
279         if (size &gt; 0) {
280             flush(true);
281         }
282 
283         /* send a zero length chunk */
284         flush(true);
285 
286         /* don&#39;t close the underlying stream */
287         out = null;
288     }
289 
290     @Override
291     public synchronized void flush() {
292         ensureOpen();
293         if (size &gt; 0) {
294             flush(true);
295         }
296     }
297 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PostHandshakeContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLCipher.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,21 +30,22 @@</span>
  import java.text.MessageFormat;
  import java.util.List;
  import java.util.ArrayList;
  import java.util.Locale;
  import java.util.Arrays;
<span class="udiff-line-removed">- import java.util.Objects;</span>
<span class="udiff-line-removed">- import java.util.Optional;</span>
  import java.util.Collection;
  import javax.crypto.Mac;
  import javax.crypto.SecretKey;
  import javax.net.ssl.SSLPeerUnverifiedException;
  import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
  import sun.security.ssl.ClientHello.ClientHelloMessage;
  import sun.security.ssl.SSLExtension.ExtensionConsumer;
  import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="udiff-line-added">+ import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;</span>
<span class="udiff-line-added">+ import sun.security.util.HexDumpEncoder;</span>
<span class="udiff-line-added">+ </span>
  import static sun.security.ssl.SSLExtension.*;
  
  /**
   * Pack of the &quot;pre_shared_key&quot; extension.
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,11 +88,11 @@</span>
              Record.putInt32(m, obfuscatedAge);
          }
  
          @Override
          public String toString() {
<span class="udiff-line-modified-removed">-             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;,&quot; +</span>
<span class="udiff-line-modified-added">+             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +</span>
                  obfuscatedAge + &quot;}&quot;;
          }
      }
  
      private static final
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -207,12 +208,14 @@</span>
  
          @Override
          public String toString() {
              MessageFormat messageFormat = new MessageFormat(
                  &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
<span class="udiff-line-modified-removed">-                 &quot;  \&quot;identities\&quot;    : \&quot;{0}\&quot;,\n&quot; +</span>
<span class="udiff-line-modified-removed">-                 &quot;  \&quot;binders\&quot;       : \&quot;{1}\&quot;,\n&quot; +</span>
<span class="udiff-line-modified-added">+                 &quot;  \&quot;identities\&quot;: &#39;{&#39;\n&quot; +</span>
<span class="udiff-line-modified-added">+                 &quot;{0}\n&quot; +</span>
<span class="udiff-line-added">+                 &quot;  &#39;}&#39;&quot; +</span>
<span class="udiff-line-added">+                 &quot;  \&quot;binders\&quot;: \&quot;{1}\&quot;,\n&quot; +</span>
                  &quot;&#39;}&#39;&quot;,
                  Locale.ENGLISH);
  
              Object[] messageFields = {
                  Utilities.indent(identitiesString()),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,13 +224,17 @@</span>
  
              return messageFormat.format(messageFields);
          }
  
          String identitiesString() {
<span class="udiff-line-added">+             HexDumpEncoder hexEncoder = new HexDumpEncoder();</span>
<span class="udiff-line-added">+ </span>
              StringBuilder result = new StringBuilder();
              for (PskIdentity curId : identities) {
<span class="udiff-line-modified-removed">-                 result.append(curId.toString() + &quot;\n&quot;);</span>
<span class="udiff-line-modified-added">+                 result.append(&quot;  {\n&quot;+ Utilities.indent(</span>
<span class="udiff-line-added">+                         hexEncoder.encode(curId.identity), &quot;    &quot;) +</span>
<span class="udiff-line-added">+                         &quot;\n  }\n&quot;);</span>
              }
  
              return result.toString();
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,11 +284,11 @@</span>
                          m.remaining() + &quot;)&quot;);
              }
              this.selectedIdentity = Record.getInt16(m);
          }
  
<span class="udiff-line-modified-removed">-         byte[] getEncoded() throws IOException {</span>
<span class="udiff-line-modified-added">+         byte[] getEncoded() {</span>
              return new byte[] {
                  (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
                  (byte)(selectedIdentity &amp; 0xFF)
              };
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,12 +374,40 @@</span>
  
              if (shc.isResumption) {     // resumingSession may not be set
                  SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
                          shc.sslContext.engineGetServerSessionContext();
                  int idIndex = 0;
<span class="udiff-line-added">+                 SSLSessionImpl s = null;</span>
<span class="udiff-line-added">+ </span>
                  for (PskIdentity requestedId : pskSpec.identities) {
<span class="udiff-line-modified-removed">-                     SSLSessionImpl s = sessionCache.get(requestedId.identity);</span>
<span class="udiff-line-modified-added">+                     // If we are keeping state, see if the identity is in the cache</span>
<span class="udiff-line-added">+                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {</span>
<span class="udiff-line-added">+                         s = sessionCache.get(requestedId.identity);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     // See if the identity is a stateless ticket</span>
<span class="udiff-line-added">+                     if (s == null &amp;&amp;</span>
<span class="udiff-line-added">+                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;</span>
<span class="udiff-line-added">+                             sessionCache.statelessEnabled()) {</span>
<span class="udiff-line-added">+                         ByteBuffer b =</span>
<span class="udiff-line-added">+                                 new SessionTicketSpec(requestedId.identity).</span>
<span class="udiff-line-added">+                                         decrypt(shc);</span>
<span class="udiff-line-added">+                         if (b != null) {</span>
<span class="udiff-line-added">+                             try {</span>
<span class="udiff-line-added">+                                 s = new SSLSessionImpl(shc, b);</span>
<span class="udiff-line-added">+                             } catch (IOException | RuntimeException e) {</span>
<span class="udiff-line-added">+                                 s = null;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         if (b == null || s == null) {</span>
<span class="udiff-line-added">+                             if (SSLLogger.isOn &amp;&amp;</span>
<span class="udiff-line-added">+                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                                 SSLLogger.fine(</span>
<span class="udiff-line-added">+                                         &quot;Stateless session ticket invalid&quot;);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
                      if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
                          if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                              SSLLogger.fine(&quot;Resuming session: &quot;, s);
                          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -390,21 +425,20 @@</span>
                      // no resumable session
                      shc.isResumption = false;
                      shc.resumingSession = null;
                  }
              }
<span class="udiff-line-removed">- </span>
              // update the context
              shc.handshakeExtensions.put(
                  SSLExtension.CH_PRE_SHARED_KEY, pskSpec);
          }
      }
  
      private static boolean canRejoin(ClientHelloMessage clientHello,
          ServerHandshakeContext shc, SSLSessionImpl s) {
  
<span class="udiff-line-modified-removed">-         boolean result = s.isRejoinable() &amp;&amp; s.getPreSharedKey().isPresent();</span>
<span class="udiff-line-modified-added">+         boolean result = s.isRejoinable() &amp;&amp; (s.getPreSharedKey() != null);</span>
  
          // Check protocol version
          if (result &amp;&amp; s.getProtocolVersion() != shc.negotiatedProtocol) {
              if (SSLLogger.isOn &amp;&amp;
                  SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -528,16 +562,15 @@</span>
      }
  
      private static void checkBinder(ServerHandshakeContext shc,
              SSLSessionImpl session,
              HandshakeHash pskBinderHash, byte[] binder) throws IOException {
<span class="udiff-line-modified-removed">-         Optional&lt;SecretKey&gt; pskOpt = session.getPreSharedKey();</span>
<span class="udiff-line-modified-removed">-         if (!pskOpt.isPresent()) {</span>
<span class="udiff-line-modified-added">+         SecretKey psk = session.getPreSharedKey();</span>
<span class="udiff-line-modified-added">+         if (psk == null) {</span>
              throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;Session has no PSK&quot;);
          }
<span class="udiff-line-removed">-         SecretKey psk = pskOpt.get();</span>
  
          SecretKey binderKey = deriveBinderKey(shc, psk, session);
          byte[] computedBinder =
                  computeBinder(shc, binderKey, session, pskBinderHash);
          if (!Arrays.equals(binder, computedBinder)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -645,31 +678,32 @@</span>
                  }
                  return null;
              }
  
              // The session must have a pre-shared key
<span class="udiff-line-modified-removed">-             Optional&lt;SecretKey&gt; pskOpt = chc.resumingSession.getPreSharedKey();</span>
<span class="udiff-line-modified-removed">-             if (!pskOpt.isPresent()) {</span>
<span class="udiff-line-modified-added">+             SecretKey psk = chc.resumingSession.getPreSharedKey();</span>
<span class="udiff-line-modified-added">+             if (psk == null) {</span>
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(&quot;Existing session has no PSK.&quot;);
                  }
                  return null;
              }
<span class="udiff-line-modified-removed">-             SecretKey psk = pskOpt.get();</span>
<span class="udiff-line-modified-added">+ </span>
              // The PSK ID can only be used in one connections, but this method
              // may be called twice in a connection if the server sends HRR.
              // ID is saved in the context so it can be used in the second call.
<span class="udiff-line-modified-removed">-             Optional&lt;byte[]&gt; pskIdOpt = Optional.ofNullable(chc.pskIdentity)</span>
<span class="udiff-line-modified-removed">-                 .or(chc.resumingSession::consumePskIdentity);</span>
<span class="udiff-line-modified-removed">-             if (!pskIdOpt.isPresent()) {</span>
<span class="udiff-line-modified-added">+             if (chc.pskIdentity == null) {</span>
<span class="udiff-line-modified-added">+                 chc.pskIdentity = chc.resumingSession.consumePskIdentity();</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (chc.pskIdentity == null) {</span>
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
                          &quot;PSK has no identity, or identity was already used&quot;);
                  }
                  return null;
              }
<span class="udiff-line-removed">-             chc.pskIdentity = pskIdOpt.get();</span>
  
              //The session cannot be used again. Remove it from the cache.
              SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
                  chc.sslContext.engineGetClientSessionContext();
              sessionCache.remove(chc.resumingSession.getSessionId());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -707,11 +741,12 @@</span>
  
          private CHPreSharedKeySpec createPskPrototype(
                  int hashLength, List&lt;PskIdentity&gt; identities) {
              List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
              byte[] binderProto = new byte[hashLength];
<span class="udiff-line-modified-removed">-             for (PskIdentity curId : identities) {</span>
<span class="udiff-line-modified-added">+             int i = identities.size();</span>
<span class="udiff-line-added">+             while (i-- &gt; 0) {</span>
                  binders.add(binderProto);
              }
  
              return new CHPreSharedKeySpec(identities, binders);
          }
</pre>
<center><a href="PostHandshakeContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLCipher.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
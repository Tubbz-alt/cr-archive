<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;
<a name="1" id="anc1"></a>
 34 import java.net.StandardSocketOptions;
 35 import java.nio.channels.AlreadyBoundException;
 36 import java.nio.channels.AsynchronousCloseException;
 37 import java.nio.channels.ClosedChannelException;
<a name="2" id="anc2"></a>
 38 import java.nio.channels.NotYetBoundException;
 39 import java.nio.channels.SelectionKey;
 40 import java.nio.channels.ServerSocketChannel;
 41 import java.nio.channels.SocketChannel;
 42 import java.nio.channels.spi.SelectorProvider;
 43 import java.util.Collections;
 44 import java.util.HashSet;
 45 import java.util.Objects;
 46 import java.util.Set;
 47 import java.util.concurrent.locks.ReentrantLock;
 48 
 49 import sun.net.NetHooks;
 50 import sun.net.ext.ExtendedSocketOptions;
 51 
 52 /**
 53  * An implementation of ServerSocketChannels
 54  */
 55 
 56 class ServerSocketChannelImpl
 57     extends ServerSocketChannel
 58     implements SelChImpl
 59 {
 60     // Used to make native close and configure calls
<a name="3" id="anc3"></a><span class="line-modified"> 61     private static NativeDispatcher nd;</span>
 62 
 63     // Our file descriptor
 64     private final FileDescriptor fd;
 65     private final int fdVal;
 66 
 67     // Lock held by thread currently blocked on this channel
 68     private final ReentrantLock acceptLock = new ReentrantLock();
 69 
 70     // Lock held by any thread that modifies the state fields declared below
 71     // DO NOT invoke a blocking I/O operation while holding this lock!
 72     private final Object stateLock = new Object();
 73 
 74     // -- The following fields are protected by stateLock
 75 
 76     // Channel state, increases monotonically
 77     private static final int ST_INUSE = 0;
 78     private static final int ST_CLOSING = 1;
<a name="4" id="anc4"></a><span class="line-modified"> 79     private static final int ST_KILLPENDING = 2;</span>
<span class="line-removed"> 80     private static final int ST_KILLED = 3;</span>
 81     private int state;
 82 
 83     // ID of native thread currently blocked in this channel, for signalling
 84     private long thread;
 85 
 86     // Binding
 87     private InetSocketAddress localAddress; // null =&gt; unbound
 88 
 89     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 90     private boolean isReuseAddress;
 91 
 92     // Our socket adaptor, if any
 93     private ServerSocket socket;
 94 
 95     // -- End of fields protected by stateLock
 96 
 97 
<a name="5" id="anc5"></a><span class="line-modified"> 98     ServerSocketChannelImpl(SelectorProvider sp) throws IOException {</span>
 99         super(sp);
<a name="6" id="anc6"></a><span class="line-modified">100         this.fd =  Net.serverSocket(true);</span>
101         this.fdVal = IOUtil.fdVal(fd);
102     }
103 
104     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
105         throws IOException
106     {
107         super(sp);
108         this.fd =  fd;
109         this.fdVal = IOUtil.fdVal(fd);
110         if (bound) {
111             synchronized (stateLock) {
112                 localAddress = Net.localAddress(fd);
113             }
114         }
115     }
116 
117     // @throws ClosedChannelException if channel is closed
118     private void ensureOpen() throws ClosedChannelException {
119         if (!isOpen())
120             throw new ClosedChannelException();
121     }
122 
123     @Override
124     public ServerSocket socket() {
125         synchronized (stateLock) {
126             if (socket == null)
127                 socket = ServerSocketAdaptor.create(this);
128             return socket;
129         }
130     }
131 
132     @Override
133     public SocketAddress getLocalAddress() throws IOException {
134         synchronized (stateLock) {
135             ensureOpen();
136             return (localAddress == null)
137                     ? null
138                     : Net.getRevealedLocalAddress(localAddress);
139         }
140     }
141 
142     @Override
143     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
144         throws IOException
145     {
146         Objects.requireNonNull(name);
147         if (!supportedOptions().contains(name))
148             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<a name="7" id="anc7"></a>


149         synchronized (stateLock) {
150             ensureOpen();
151 
152             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
153                 // SO_REUSEADDR emulated when using exclusive bind
154                 isReuseAddress = (Boolean)value;
155             } else {
156                 // no options that require special handling
157                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
158             }
159             return this;
160         }
161     }
162 
163     @Override
164     @SuppressWarnings(&quot;unchecked&quot;)
165     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
166         throws IOException
167     {
168         Objects.requireNonNull(name);
169         if (!supportedOptions().contains(name))
170             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
171 
172         synchronized (stateLock) {
173             ensureOpen();
174             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
175                 // SO_REUSEADDR emulated when using exclusive bind
176                 return (T)Boolean.valueOf(isReuseAddress);
177             }
178             // no options that require special handling
179             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
180         }
181     }
182 
183     private static class DefaultOptionsHolder {
184         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
185 
186         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
187             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
188             set.add(StandardSocketOptions.SO_RCVBUF);
189             set.add(StandardSocketOptions.SO_REUSEADDR);
190             if (Net.isReusePortAvailable()) {
191                 set.add(StandardSocketOptions.SO_REUSEPORT);
192             }
193             set.addAll(ExtendedSocketOptions.serverSocketOptions());
194             return Collections.unmodifiableSet(set);
195         }
196     }
197 
198     @Override
199     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
200         return DefaultOptionsHolder.defaultOptions;
201     }
202 
203     @Override
204     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
205         synchronized (stateLock) {
206             ensureOpen();
207             if (localAddress != null)
208                 throw new AlreadyBoundException();
209             InetSocketAddress isa = (local == null)
210                                     ? new InetSocketAddress(0)
211                                     : Net.checkAddress(local);
212             SecurityManager sm = System.getSecurityManager();
213             if (sm != null)
214                 sm.checkListen(isa.getPort());
215             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
216             Net.bind(fd, isa.getAddress(), isa.getPort());
217             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
218             localAddress = Net.localAddress(fd);
219         }
220         return this;
221     }
222 
223     /**
224      * Marks the beginning of an I/O operation that might block.
225      *
226      * @throws ClosedChannelException if the channel is closed
227      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
228      */
229     private void begin(boolean blocking) throws ClosedChannelException {
230         if (blocking)
231             begin();  // set blocker to close channel if interrupted
232         synchronized (stateLock) {
233             ensureOpen();
234             if (localAddress == null)
235                 throw new NotYetBoundException();
236             if (blocking)
237                 thread = NativeThread.current();
238         }
239     }
240 
241     /**
242      * Marks the end of an I/O operation that may have blocked.
243      *
244      * @throws AsynchronousCloseException if the channel was closed due to this
245      * thread being interrupted on a blocking I/O operation.
246      */
247     private void end(boolean blocking, boolean completed)
248         throws AsynchronousCloseException
249     {
250         if (blocking) {
251             synchronized (stateLock) {
252                 thread = 0;
<a name="8" id="anc8"></a><span class="line-removed">253                 // notify any thread waiting in implCloseSelectableChannel</span>
254                 if (state == ST_CLOSING) {
<a name="9" id="anc9"></a><span class="line-modified">255                     stateLock.notifyAll();</span>
256                 }
257             }
258             end(completed);
259         }
260     }
261 
262     @Override
263     public SocketChannel accept() throws IOException {
<a name="10" id="anc10"></a>



264         acceptLock.lock();
265         try {
<a name="11" id="anc11"></a><span class="line-removed">266             int n = 0;</span>
<span class="line-removed">267             FileDescriptor newfd = new FileDescriptor();</span>
<span class="line-removed">268             InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
<span class="line-removed">269 </span>
270             boolean blocking = isBlocking();
271             try {
272                 begin(blocking);
<a name="12" id="anc12"></a><span class="line-modified">273                 do {</span>
<span class="line-modified">274                     n = accept(this.fd, newfd, isaa);</span>
<span class="line-modified">275                 } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>




276             } finally {
277                 end(blocking, n &gt; 0);
278                 assert IOStatus.check(n);
279             }
<a name="13" id="anc13"></a>


280 
<a name="14" id="anc14"></a><span class="line-modified">281             if (n &lt; 1)</span>
<span class="line-modified">282                 return null;</span>




283 
<a name="15" id="anc15"></a><span class="line-modified">284             // newly accepted socket is initially in blocking mode</span>
<span class="line-modified">285             IOUtil.configureBlocking(newfd, true);</span>












286 
<a name="16" id="anc16"></a><span class="line-modified">287             InetSocketAddress isa = isaa[0];</span>
<span class="line-modified">288             SocketChannel sc = new SocketChannelImpl(provider(), newfd, isa);</span>



289 
<a name="17" id="anc17"></a><span class="line-modified">290             // check permitted to accept connections from the remote address</span>
<span class="line-modified">291             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-modified">292             if (sm != null) {</span>

293                 try {
<a name="18" id="anc18"></a><span class="line-modified">294                     sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-modified">295                 } catch (SecurityException x) {</span>
<span class="line-modified">296                     sc.close();</span>
<span class="line-modified">297                     throw x;</span>









298                 }
<a name="19" id="anc19"></a>

299             }
<a name="20" id="anc20"></a><span class="line-removed">300             return sc;</span>
<span class="line-removed">301 </span>
302         } finally {
303             acceptLock.unlock();
304         }
<a name="21" id="anc21"></a>





















305     }
306 
307     @Override
308     protected void implConfigureBlocking(boolean block) throws IOException {
309         acceptLock.lock();
310         try {
<a name="22" id="anc22"></a><span class="line-modified">311             synchronized (stateLock) {</span>
<span class="line-removed">312                 ensureOpen();</span>
<span class="line-removed">313                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed">314             }</span>
315         } finally {
316             acceptLock.unlock();
317         }
318     }
319 
320     /**
<a name="23" id="anc23"></a><span class="line-modified">321      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">322      *</span>
<span class="line-modified">323      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-modified">324      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-modified">325      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-modified">326      * complete quickly.</span>







327      *
<a name="24" id="anc24"></a><span class="line-modified">328      * The socket is closed by this method when it is not registered with a</span>
<span class="line-modified">329      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-removed">330      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed">331      * to blocking mode before the key is flushed from the Selector.</span>
332      */
<a name="25" id="anc25"></a><span class="line-modified">333     @Override</span>
<span class="line-modified">334     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">335         assert !isOpen();</span>








336 
<a name="26" id="anc26"></a><span class="line-modified">337         boolean interrupted = false;</span>
<span class="line-modified">338         boolean blocking;</span>












339 
<a name="27" id="anc27"></a><span class="line-modified">340         // set state to ST_CLOSING</span>


















341         synchronized (stateLock) {
342             assert state &lt; ST_CLOSING;
343             state = ST_CLOSING;
<a name="28" id="anc28"></a><span class="line-modified">344             blocking = isBlocking();</span>
<span class="line-removed">345         }</span>
<span class="line-removed">346 </span>
<span class="line-removed">347         // wait for any outstanding accept to complete</span>
<span class="line-removed">348         if (blocking) {</span>
<span class="line-removed">349             synchronized (stateLock) {</span>
<span class="line-removed">350                 assert state == ST_CLOSING;</span>
351                 long th = thread;
352                 if (th != 0) {
353                     nd.preClose(fd);
354                     NativeThread.signal(th);
<a name="29" id="anc29"></a><span class="line-removed">355 </span>
<span class="line-removed">356                     // wait for accept operation to end</span>
<span class="line-removed">357                     while (thread != 0) {</span>
<span class="line-removed">358                         try {</span>
<span class="line-removed">359                             stateLock.wait();</span>
<span class="line-removed">360                         } catch (InterruptedException e) {</span>
<span class="line-removed">361                             interrupted = true;</span>
<span class="line-removed">362                         }</span>
<span class="line-removed">363                     }</span>
364                 }
365             }
<a name="30" id="anc30"></a><span class="line-removed">366         } else {</span>
<span class="line-removed">367             // non-blocking mode: wait for accept to complete</span>
<span class="line-removed">368             acceptLock.lock();</span>
<span class="line-removed">369             acceptLock.unlock();</span>
370         }
<a name="31" id="anc31"></a>
371 
<a name="32" id="anc32"></a><span class="line-modified">372         // set state to ST_KILLPENDING</span>













373         synchronized (stateLock) {
<a name="33" id="anc33"></a><span class="line-modified">374             assert state == ST_CLOSING;</span>
<span class="line-modified">375             state = ST_KILLPENDING;</span>

376         }
<a name="34" id="anc34"></a>
377 
<a name="35" id="anc35"></a><span class="line-modified">378         // close socket if not registered with Selector</span>
<span class="line-modified">379         if (!isRegistered())</span>
<span class="line-modified">380             kill();</span>
<span class="line-modified">381 </span>
<span class="line-modified">382         // restore interrupt status</span>
<span class="line-modified">383         if (interrupted)</span>
<span class="line-modified">384             Thread.currentThread().interrupt();</span>




385     }
386 
387     @Override
<a name="36" id="anc36"></a><span class="line-modified">388     public void kill() throws IOException {</span>
389         synchronized (stateLock) {
<a name="37" id="anc37"></a><span class="line-modified">390             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">391                 state = ST_KILLED;</span>
<span class="line-removed">392                 nd.close(fd);</span>
393             }
394         }
395     }
396 
397     /**
398      * Returns true if channel&#39;s socket is bound
399      */
400     boolean isBound() {
401         synchronized (stateLock) {
402             return localAddress != null;
403         }
404     }
405 
406     /**
407      * Returns the local address, or null if not bound
408      */
409     InetSocketAddress localAddress() {
410         synchronized (stateLock) {
411             return localAddress;
412         }
413     }
414 
<a name="38" id="anc38"></a><span class="line-removed">415     /**</span>
<span class="line-removed">416      * Poll this channel&#39;s socket for a new connection up to the given timeout.</span>
<span class="line-removed">417      * @return {@code true} if there is a connection to accept</span>
<span class="line-removed">418      */</span>
<span class="line-removed">419     boolean pollAccept(long timeout) throws IOException {</span>
<span class="line-removed">420         assert Thread.holdsLock(blockingLock()) &amp;&amp; isBlocking();</span>
<span class="line-removed">421         acceptLock.lock();</span>
<span class="line-removed">422         try {</span>
<span class="line-removed">423             boolean polled = false;</span>
<span class="line-removed">424             try {</span>
<span class="line-removed">425                 begin(true);</span>
<span class="line-removed">426                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-removed">427                 polled = (events != 0);</span>
<span class="line-removed">428             } finally {</span>
<span class="line-removed">429                 end(true, polled);</span>
<span class="line-removed">430             }</span>
<span class="line-removed">431             return polled;</span>
<span class="line-removed">432         } finally {</span>
<span class="line-removed">433             acceptLock.unlock();</span>
<span class="line-removed">434         }</span>
<span class="line-removed">435     }</span>
<span class="line-removed">436 </span>
437     /**
438      * Translates native poll revent set into a ready operation set
439      */
440     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
441         int intOps = ski.nioInterestOps();
442         int oldOps = ski.nioReadyOps();
443         int newOps = initialOps;
444 
445         if ((ops &amp; Net.POLLNVAL) != 0) {
446             // This should only happen if this channel is pre-closed while a
447             // selection operation is in progress
448             // ## Throw an error if this channel has not been pre-closed
449             return false;
450         }
451 
452         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
453             newOps = intOps;
454             ski.nioReadyOps(newOps);
455             return (newOps &amp; ~oldOps) != 0;
456         }
457 
458         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
459             ((intOps &amp; SelectionKey.OP_ACCEPT) != 0))
460                 newOps |= SelectionKey.OP_ACCEPT;
461 
462         ski.nioReadyOps(newOps);
463         return (newOps &amp; ~oldOps) != 0;
464     }
465 
466     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
467         return translateReadyOps(ops, ski.nioReadyOps(), ski);
468     }
469 
470     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
471         return translateReadyOps(ops, 0, ski);
472     }
473 
474     /**
475      * Translates an interest operation set into a native poll event set
476      */
477     public int translateInterestOps(int ops) {
478         int newOps = 0;
479         if ((ops &amp; SelectionKey.OP_ACCEPT) != 0)
480             newOps |= Net.POLLIN;
481         return newOps;
482     }
483 
484     public FileDescriptor getFD() {
485         return fd;
486     }
487 
488     public int getFDVal() {
489         return fdVal;
490     }
491 
492     public String toString() {
493         StringBuilder sb = new StringBuilder();
494         sb.append(this.getClass().getName());
495         sb.append(&#39;[&#39;);
496         if (!isOpen()) {
497             sb.append(&quot;closed&quot;);
498         } else {
499             synchronized (stateLock) {
500                 InetSocketAddress addr = localAddress;
501                 if (addr == null) {
502                     sb.append(&quot;unbound&quot;);
503                 } else {
504                     sb.append(Net.getRevealedLocalAddressAsString(addr));
505                 }
506             }
507         }
508         sb.append(&#39;]&#39;);
509         return sb.toString();
510     }
<a name="39" id="anc39"></a><span class="line-removed">511 </span>
<span class="line-removed">512     /**</span>
<span class="line-removed">513      * Accept a connection on a socket.</span>
<span class="line-removed">514      *</span>
<span class="line-removed">515      * @implNote Wrap native call to allow instrumentation.</span>
<span class="line-removed">516      */</span>
<span class="line-removed">517     private int accept(FileDescriptor ssfd,</span>
<span class="line-removed">518                        FileDescriptor newfd,</span>
<span class="line-removed">519                        InetSocketAddress[] isaa)</span>
<span class="line-removed">520         throws IOException</span>
<span class="line-removed">521     {</span>
<span class="line-removed">522         return accept0(ssfd, newfd, isaa);</span>
<span class="line-removed">523     }</span>
<span class="line-removed">524 </span>
<span class="line-removed">525     // -- Native methods --</span>
<span class="line-removed">526 </span>
<span class="line-removed">527     // Accepts a new connection, setting the given file descriptor to refer to</span>
<span class="line-removed">528     // the new socket and setting isaa[0] to the socket&#39;s remote address.</span>
<span class="line-removed">529     // Returns 1 on success, or IOStatus.UNAVAILABLE (if non-blocking and no</span>
<span class="line-removed">530     // connections are pending) or IOStatus.INTERRUPTED.</span>
<span class="line-removed">531     //</span>
<span class="line-removed">532     private native int accept0(FileDescriptor ssfd,</span>
<span class="line-removed">533                                FileDescriptor newfd,</span>
<span class="line-removed">534                                InetSocketAddress[] isaa)</span>
<span class="line-removed">535         throws IOException;</span>
<span class="line-removed">536 </span>
<span class="line-removed">537     private static native void initIDs();</span>
<span class="line-removed">538 </span>
<span class="line-removed">539     static {</span>
<span class="line-removed">540         IOUtil.load();</span>
<span class="line-removed">541         initIDs();</span>
<span class="line-removed">542         nd = new SocketDispatcher();</span>
<span class="line-removed">543     }</span>
<span class="line-removed">544 </span>
545 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
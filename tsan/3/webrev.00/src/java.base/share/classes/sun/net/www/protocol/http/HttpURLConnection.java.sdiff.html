<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DigestAuthentication.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NegotiateAuthentication.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  51 import java.net.Authenticator.RequestorType;
  52 import java.security.AccessController;
  53 import java.security.PrivilegedExceptionAction;
  54 import java.security.PrivilegedActionException;
  55 import java.io.*;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Date;
  59 import java.util.Map;
  60 import java.util.List;
  61 import java.util.Locale;
  62 import java.util.StringTokenizer;
  63 import java.util.Iterator;
  64 import java.util.HashSet;
  65 import java.util.HashMap;
  66 import java.util.Set;
  67 import java.util.StringJoiner;
  68 import jdk.internal.access.JavaNetHttpCookieAccess;
  69 import jdk.internal.access.SharedSecrets;
  70 import sun.net.*;

  71 import sun.net.www.*;
  72 import sun.net.www.http.HttpClient;
  73 import sun.net.www.http.PosterOutputStream;
  74 import sun.net.www.http.ChunkedInputStream;
  75 import sun.net.www.http.ChunkedOutputStream;
  76 import sun.util.logging.PlatformLogger;
  77 import java.text.SimpleDateFormat;
  78 import java.util.TimeZone;
  79 import java.net.MalformedURLException;
  80 import java.nio.ByteBuffer;
  81 import java.util.Objects;
  82 import java.util.Properties;
  83 import static sun.net.www.protocol.http.AuthScheme.BASIC;
  84 import static sun.net.www.protocol.http.AuthScheme.DIGEST;
  85 import static sun.net.www.protocol.http.AuthScheme.NTLM;
  86 import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
  87 import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
  88 import static sun.net.www.protocol.http.AuthScheme.UNKNOWN;
  89 import sun.security.action.GetIntegerAction;
  90 import sun.security.action.GetPropertyAction;
</pre>
<hr />
<pre>
 294             &quot;Authorization&quot;
 295     };
 296 
 297     // also exclude system cookies when any might be set
 298     private static final String[] EXCLUDE_HEADERS2= {
 299             &quot;Proxy-Authorization&quot;,
 300             &quot;Authorization&quot;,
 301             &quot;Cookie&quot;,
 302             &quot;Cookie2&quot;
 303     };
 304 
 305     protected HttpClient http;
 306     protected Handler handler;
 307     protected Proxy instProxy;
 308     protected volatile Authenticator authenticator;
 309     protected volatile String authenticatorKey;
 310 
 311     private CookieHandler cookieHandler;
 312     private final ResponseCache cacheHandler;
 313 


 314     // the cached response, and cached response headers and body
 315     protected CacheResponse cachedResponse;
 316     private MessageHeader cachedHeaders;
 317     private InputStream cachedInputStream;
 318 
 319     /* output stream to server */
 320     protected PrintStream ps = null;
 321 
<span class="line-removed"> 322 </span>
 323     /* buffered error stream */
 324     private InputStream errorStream = null;
 325 
 326     /* User set Cookies */
 327     private boolean setUserCookies = true;
 328     private String userCookies = null;
 329     private String userCookies2 = null;
 330 
 331     /* We only have a single static authenticator for now.
 332      * REMIND:  backwards compatibility with JDK 1.1.  Should be
 333      * eliminated for JDK 2.0.
 334      */
 335     @Deprecated
 336     private static HttpAuthenticator defaultAuth;
 337 
 338     /* all the headers we send
 339      * NOTE: do *NOT* dump out the content of &#39;requests&#39; in the
 340      * output or stacktrace since it may contain security-sensitive
 341      * headers such as those defined in EXCLUDE_HEADERS.
 342      */
</pre>
<hr />
<pre>
 851         }
 852         return h;
 853     }
 854     public HttpURLConnection(URL u, String host, int port) throws IOException {
 855         this(u, new Proxy(Proxy.Type.HTTP,
 856                 InetSocketAddress.createUnresolved(checkHost(host), port)));
 857     }
 858 
 859     /** this constructor is used by other protocol handlers such as ftp
 860         that want to use http to fetch urls on their behalf.*/
 861     public HttpURLConnection(URL u, Proxy p) throws IOException {
 862         this(u, p, new Handler());
 863     }
 864 
 865     private static URL checkURL(URL u) throws IOException {
 866         if (u != null) {
 867             if (u.toExternalForm().indexOf(&#39;\n&#39;) &gt; -1) {
 868                 throw new MalformedURLException(&quot;Illegal character in URL&quot;);
 869             }
 870         }




 871         return u;
 872     }

 873     protected HttpURLConnection(URL u, Proxy p, Handler handler)
 874             throws IOException {
 875         super(checkURL(u));
 876         requests = new MessageHeader();
 877         responses = new MessageHeader();
 878         userHeaders = new MessageHeader();
 879         this.handler = handler;
 880         instProxy = p;
 881         if (instProxy instanceof sun.net.ApplicationProxy) {
 882             /* Application set Proxies should not have access to cookies
 883              * in a secure environment unless explicitly allowed. */
 884             try {
 885                 cookieHandler = CookieHandler.getDefault();
 886             } catch (SecurityException se) { /* swallow exception */ }
 887         } else {
 888             cookieHandler = java.security.AccessController.doPrivileged(
 889                 new java.security.PrivilegedAction&lt;&gt;() {
 890                 public CookieHandler run() {
 891                     return CookieHandler.getDefault();
 892                 }
</pre>
<hr />
<pre>
1155              * 2) else use system default ProxySelector
1156              * 3) else make a direct connection if ProxySelector is not present
1157              */
1158 
1159             if (instProxy == null) { // no instance Proxy is set
1160                 /**
1161                  * Do we have to use a proxy?
1162                  */
1163                 ProxySelector sel =
1164                     java.security.AccessController.doPrivileged(
1165                         new java.security.PrivilegedAction&lt;&gt;() {
1166                             public ProxySelector run() {
1167                                      return ProxySelector.getDefault();
1168                                  }
1169                              });
1170                 if (sel != null) {
1171                     URI uri = sun.net.www.ParseUtil.toURI(url);
1172                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1173                         logger.finest(&quot;ProxySelector Request for &quot; + uri);
1174                     }
<span class="line-modified">1175                     Iterator&lt;Proxy&gt; it = sel.select(uri).iterator();</span>






1176                     Proxy p;
1177                     while (it.hasNext()) {
1178                         p = it.next();
1179                         try {
1180                             if (!failedOnce) {
1181                                 http = getNewHttpClient(url, p, connectTimeout);
1182                                 http.setReadTimeout(readTimeout);
1183                             } else {
1184                                 // make sure to construct new connection if first
1185                                 // attempt failed
1186                                 http = getNewHttpClient(url, p, connectTimeout, false);
1187                                 http.setReadTimeout(readTimeout);
1188                             }
1189                             if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1190                                 if (p != null) {
1191                                     logger.finest(&quot;Proxy used: &quot; + p.toString());
1192                                 }
1193                             }
1194                             break;
1195                         } catch (IOException ioex) {
</pre>
<hr />
<pre>
1211                         http.setReadTimeout(readTimeout);
1212                     } else {
1213                         // make sure to construct new connection if first
1214                         // attempt failed
1215                         http = getNewHttpClient(url, null, connectTimeout, false);
1216                         http.setReadTimeout(readTimeout);
1217                     }
1218                 }
1219             } else {
1220                 if (!failedOnce) {
1221                     http = getNewHttpClient(url, instProxy, connectTimeout);
1222                     http.setReadTimeout(readTimeout);
1223                 } else {
1224                     // make sure to construct new connection if first
1225                     // attempt failed
1226                     http = getNewHttpClient(url, instProxy, connectTimeout, false);
1227                     http.setReadTimeout(readTimeout);
1228                 }
1229             }
1230 

1231             ps = (PrintStream)http.getOutputStream();
1232         } catch (IOException e) {
1233             throw e;
1234         }
1235         // constructor to HTTP client calls openserver
1236         connected = true;
1237     }
1238 
1239     // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
1240     protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout)
1241         throws IOException {
1242         return HttpClient.New(url, p, connectTimeout, this);
1243     }
1244 
1245     // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
1246     protected HttpClient getNewHttpClient(URL url, Proxy p,
1247                                           int connectTimeout, boolean useCache)
1248         throws IOException {
1249         return HttpClient.New(url, p, connectTimeout, useCache, this);
1250     }
</pre>
<hr />
<pre>
2142                     }
2143                 }
2144                 // cache proxy authentication info
2145                 if (proxyAuthentication != null) {
2146                     // cache auth info on success, domain header not relevant.
2147                     proxyAuthentication.addToCache();
2148                 }
2149 
2150                 if (respCode == HTTP_OK) {
2151                     setTunnelState(TunnelState.TUNNELING);
2152                     break;
2153                 }
2154                 // we don&#39;t know how to deal with other response code
2155                 // so disconnect and report error
2156                 disconnectInternal();
2157                 setTunnelState(TunnelState.NONE);
2158                 break;
2159             } while (retryTunnel &lt; maxRedirects);
2160 
2161             if (retryTunnel &gt;= maxRedirects || (respCode != HTTP_OK)) {




2162                 throw new IOException(&quot;Unable to tunnel through proxy.&quot;+
2163                                       &quot; Proxy returns \&quot;&quot; +
2164                                       statusLine + &quot;\&quot;&quot;);
2165             }
2166         } finally  {
2167             if (proxyAuthKey != null) {
2168                 AuthenticationInfo.endAuthRequest(proxyAuthKey);
2169             }
2170         }
2171 
2172         // restore original request headers
2173         requests = savedRequests;
2174 
2175         // reset responses
2176         responses.reset();
2177     }
2178 
2179     static String connectRequestURI(URL url) {
2180         String host = url.getHost();
2181         int port = url.getPort();
</pre>
<hr />
<pre>
2242             // Sets &quot;Proxy-authorization&quot;
2243             requests.set(pauth.getHeaderName(), value);
2244             currentProxyCredentials = pauth;
2245         }
2246     }
2247 
2248     /**
2249      * Gets the authentication for an HTTP proxy, and applies it to
2250      * the connection.
2251      */
2252     @SuppressWarnings(&quot;fallthrough&quot;)
2253     private AuthenticationInfo getHttpProxyAuthentication (AuthenticationHeader authhdr) {
2254         /* get authorization from authenticator */
2255         AuthenticationInfo ret = null;
2256         String raw = authhdr.raw();
2257         String host = http.getProxyHostUsed();
2258         int port = http.getProxyPortUsed();
2259         if (host != null &amp;&amp; authhdr.isPresent()) {
2260             HeaderParser p = authhdr.headerParser();
2261             String realm = p.findValue(&quot;realm&quot;);


2262             String scheme = authhdr.scheme();
2263             AuthScheme authScheme = UNKNOWN;
2264             if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {
2265                 authScheme = BASIC;
2266             } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {
2267                 authScheme = DIGEST;
2268             } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {
2269                 authScheme = NTLM;
2270                 doingNTLMp2ndStage = true;
2271             } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {
2272                 authScheme = KERBEROS;
2273                 doingNTLMp2ndStage = true;
2274             } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {
2275                 authScheme = NEGOTIATE;
2276                 doingNTLMp2ndStage = true;
2277             }
2278 
2279             if (realm == null)
2280                 realm = &quot;&quot;;
2281             proxyAuthKey = AuthenticationInfo.getProxyAuthKey(host, port, realm,
</pre>
<hr />
<pre>
2287                     InetAddress addr = null;
2288                     try {
2289                         final String finalHost = host;
2290                         addr = java.security.AccessController.doPrivileged(
2291                             new java.security.PrivilegedExceptionAction&lt;&gt;() {
2292                                 public InetAddress run()
2293                                     throws java.net.UnknownHostException {
2294                                     return InetAddress.getByName(finalHost);
2295                                 }
2296                             });
2297                     } catch (java.security.PrivilegedActionException ignored) {
2298                         // User will have an unknown host.
2299                     }
2300                     PasswordAuthentication a =
2301                         privilegedRequestPasswordAuthentication(
2302                                     authenticator,
2303                                     host, addr, port, &quot;http&quot;,
2304                                     realm, scheme, url, RequestorType.PROXY);
2305                     if (a != null) {
2306                         ret = new BasicAuthentication(true, host, port, realm, a,
<span class="line-modified">2307                                              getAuthenticatorKey());</span>
2308                     }
2309                     break;
2310                 case DIGEST:
2311                     a = privilegedRequestPasswordAuthentication(
2312                                     authenticator,
2313                                     host, null, port, url.getProtocol(),
2314                                     realm, scheme, url, RequestorType.PROXY);
2315                     if (a != null) {
2316                         DigestAuthentication.Parameters params =
2317                             new DigestAuthentication.Parameters();
2318                         ret = new DigestAuthentication(true, host, port, realm,
2319                                              scheme, a, params,
2320                                              getAuthenticatorKey());
2321                     }
2322                     break;
2323                 case NTLM:
2324                     if (NTLMAuthenticationProxy.supported) {
2325                         /* tryTransparentNTLMProxy will always be true the first
2326                          * time around, but verify that the platform supports it
2327                          * otherwise don&#39;t try. */
</pre>
<hr />
<pre>
2405         }
2406         return ret;
2407     }
2408 
2409     /**
2410      * Gets the authentication for an HTTP server, and applies it to
2411      * the connection.
2412      * @param authHdr the AuthenticationHeader which tells what auth scheme is
2413      * preferred.
2414      */
2415     @SuppressWarnings(&quot;fallthrough&quot;)
2416     private AuthenticationInfo getServerAuthentication (AuthenticationHeader authhdr) {
2417         /* get authorization from authenticator */
2418         AuthenticationInfo ret = null;
2419         String raw = authhdr.raw();
2420         /* When we get an NTLM auth from cache, don&#39;t set any special headers */
2421         if (authhdr.isPresent()) {
2422             HeaderParser p = authhdr.headerParser();
2423             String realm = p.findValue(&quot;realm&quot;);
2424             String scheme = authhdr.scheme();


2425             AuthScheme authScheme = UNKNOWN;
2426             if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {
2427                 authScheme = BASIC;
2428             } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {
2429                 authScheme = DIGEST;
2430             } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {
2431                 authScheme = NTLM;
2432                 doingNTLM2ndStage = true;
2433             } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {
2434                 authScheme = KERBEROS;
2435                 doingNTLM2ndStage = true;
2436             } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {
2437                 authScheme = NEGOTIATE;
2438                 doingNTLM2ndStage = true;
2439             }
2440 
2441             domain = p.findValue (&quot;domain&quot;);
2442             if (realm == null)
2443                 realm = &quot;&quot;;
2444             serverAuthKey = AuthenticationInfo.getServerAuthKey(url, realm, authScheme,
</pre>
<hr />
<pre>
2456             int port = url.getPort();
2457             if (port == -1) {
2458                 port = url.getDefaultPort();
2459             }
2460             if (ret == null) {
2461                 switch(authScheme) {
2462                 case KERBEROS:
2463                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Kerberos&quot;));
2464                     break;
2465                 case NEGOTIATE:
2466                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Negotiate&quot;));
2467                     break;
2468                 case BASIC:
2469                     PasswordAuthentication a =
2470                         privilegedRequestPasswordAuthentication(
2471                             authenticator,
2472                             url.getHost(), addr, port, url.getProtocol(),
2473                             realm, scheme, url, RequestorType.SERVER);
2474                     if (a != null) {
2475                         ret = new BasicAuthentication(false, url, realm, a,
<span class="line-modified">2476                                     getAuthenticatorKey());</span>
2477                     }
2478                     break;
2479                 case DIGEST:
2480                     a = privilegedRequestPasswordAuthentication(
2481                             authenticator,
2482                             url.getHost(), addr, port, url.getProtocol(),
2483                             realm, scheme, url, RequestorType.SERVER);
2484                     if (a != null) {
2485                         digestparams = new DigestAuthentication.Parameters();
2486                         ret = new DigestAuthentication(false, url, realm, scheme,
2487                                     a, digestparams,
2488                                     getAuthenticatorKey());
2489                     }
2490                     break;
2491                 case NTLM:
2492                     if (NTLMAuthenticationProxy.supported) {
2493                         URL url1;
2494                         try {
2495                             url1 = new URL (url, &quot;/&quot;); /* truncate the path */
2496                         } catch (Exception e) {
</pre>
<hr />
<pre>
2880                 disconnectInternal();
2881                 return;
2882             }
2883             try {
2884                 if (is instanceof MeteredStream) {
2885                     is.close();
2886                 }
2887             } catch (IOException e) { }
2888         }
2889         responseCode = -1;
2890         responses = new MessageHeader();
2891         connected = false;
2892     }
2893 
2894     /**
2895      * Disconnect from the web server at the first 401 error. Do not
2896      * disconnect when using a proxy, a good proxy should have already
2897      * closed the connection to the web server.
2898      */
2899     private void disconnectWeb() throws IOException {
<span class="line-modified">2900         if (usingProxy() &amp;&amp; http.isKeepingAlive()) {</span>
2901             responseCode = -1;
2902             // clean up, particularly, skip the content part
2903             // of a 401 error response
2904             reset();
2905         } else {
2906             disconnectInternal();
2907         }
2908     }
2909 
2910     /**
2911      * Disconnect from the server (for internal use)
2912      */
2913     private void disconnectInternal() {
2914         responseCode = -1;
2915         inputStream = null;
2916         if (pi != null) {
2917             pi.finishTracking();
2918             pi = null;
2919         }
2920         if (http != null) {
</pre>
<hr />
<pre>
2983 
2984             } else {
2985                 // We are deliberatly being disconnected so HttpClient
2986                 // should not try to resend the request no matter what stage
2987                 // of the connection we are in.
2988                 http.setDoNotRetry(true);
2989 
2990                 http.closeServer();
2991             }
2992 
2993             //      poster = null;
2994             http = null;
2995             connected = false;
2996         }
2997         cachedInputStream = null;
2998         if (cachedHeaders != null) {
2999             cachedHeaders.reset();
3000         }
3001     }
3002 
<span class="line-modified">3003     public boolean usingProxy() {</span>



3004         if (http != null) {
3005             return (http.getProxyHostUsed() != null);
3006         }
3007         return false;
3008     }
3009 















3010     // constant strings represent set-cookie header names
3011     private static final String SET_COOKIE = &quot;set-cookie&quot;;
3012     private static final String SET_COOKIE2 = &quot;set-cookie2&quot;;
3013 
3014     /**
3015      * Returns a filtered version of the given headers value.
3016      *
3017      * Note: The implementation currently only filters out HttpOnly cookies
3018      *       from Set-Cookie and Set-Cookie2 headers.
3019      */
3020     private String filterHeaderField(String name, String value) {
3021         if (value == null)
3022             return null;
3023 
3024         if (SET_COOKIE.equalsIgnoreCase(name) ||
3025             SET_COOKIE2.equalsIgnoreCase(name)) {
3026 
3027             // Filtering only if there is a cookie handler. [Assumption: the
3028             // cookie handler will store/retrieve the HttpOnly cookies]
3029             if (cookieHandler == null || value.isEmpty())
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  51 import java.net.Authenticator.RequestorType;
  52 import java.security.AccessController;
  53 import java.security.PrivilegedExceptionAction;
  54 import java.security.PrivilegedActionException;
  55 import java.io.*;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Date;
  59 import java.util.Map;
  60 import java.util.List;
  61 import java.util.Locale;
  62 import java.util.StringTokenizer;
  63 import java.util.Iterator;
  64 import java.util.HashSet;
  65 import java.util.HashMap;
  66 import java.util.Set;
  67 import java.util.StringJoiner;
  68 import jdk.internal.access.JavaNetHttpCookieAccess;
  69 import jdk.internal.access.SharedSecrets;
  70 import sun.net.*;
<span class="line-added">  71 import sun.net.util.IPAddressUtil;</span>
  72 import sun.net.www.*;
  73 import sun.net.www.http.HttpClient;
  74 import sun.net.www.http.PosterOutputStream;
  75 import sun.net.www.http.ChunkedInputStream;
  76 import sun.net.www.http.ChunkedOutputStream;
  77 import sun.util.logging.PlatformLogger;
  78 import java.text.SimpleDateFormat;
  79 import java.util.TimeZone;
  80 import java.net.MalformedURLException;
  81 import java.nio.ByteBuffer;
  82 import java.util.Objects;
  83 import java.util.Properties;
  84 import static sun.net.www.protocol.http.AuthScheme.BASIC;
  85 import static sun.net.www.protocol.http.AuthScheme.DIGEST;
  86 import static sun.net.www.protocol.http.AuthScheme.NTLM;
  87 import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
  88 import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
  89 import static sun.net.www.protocol.http.AuthScheme.UNKNOWN;
  90 import sun.security.action.GetIntegerAction;
  91 import sun.security.action.GetPropertyAction;
</pre>
<hr />
<pre>
 295             &quot;Authorization&quot;
 296     };
 297 
 298     // also exclude system cookies when any might be set
 299     private static final String[] EXCLUDE_HEADERS2= {
 300             &quot;Proxy-Authorization&quot;,
 301             &quot;Authorization&quot;,
 302             &quot;Cookie&quot;,
 303             &quot;Cookie2&quot;
 304     };
 305 
 306     protected HttpClient http;
 307     protected Handler handler;
 308     protected Proxy instProxy;
 309     protected volatile Authenticator authenticator;
 310     protected volatile String authenticatorKey;
 311 
 312     private CookieHandler cookieHandler;
 313     private final ResponseCache cacheHandler;
 314 
<span class="line-added"> 315     private volatile boolean usingProxy;</span>
<span class="line-added"> 316 </span>
 317     // the cached response, and cached response headers and body
 318     protected CacheResponse cachedResponse;
 319     private MessageHeader cachedHeaders;
 320     private InputStream cachedInputStream;
 321 
 322     /* output stream to server */
 323     protected PrintStream ps = null;
 324 

 325     /* buffered error stream */
 326     private InputStream errorStream = null;
 327 
 328     /* User set Cookies */
 329     private boolean setUserCookies = true;
 330     private String userCookies = null;
 331     private String userCookies2 = null;
 332 
 333     /* We only have a single static authenticator for now.
 334      * REMIND:  backwards compatibility with JDK 1.1.  Should be
 335      * eliminated for JDK 2.0.
 336      */
 337     @Deprecated
 338     private static HttpAuthenticator defaultAuth;
 339 
 340     /* all the headers we send
 341      * NOTE: do *NOT* dump out the content of &#39;requests&#39; in the
 342      * output or stacktrace since it may contain security-sensitive
 343      * headers such as those defined in EXCLUDE_HEADERS.
 344      */
</pre>
<hr />
<pre>
 853         }
 854         return h;
 855     }
 856     public HttpURLConnection(URL u, String host, int port) throws IOException {
 857         this(u, new Proxy(Proxy.Type.HTTP,
 858                 InetSocketAddress.createUnresolved(checkHost(host), port)));
 859     }
 860 
 861     /** this constructor is used by other protocol handlers such as ftp
 862         that want to use http to fetch urls on their behalf.*/
 863     public HttpURLConnection(URL u, Proxy p) throws IOException {
 864         this(u, p, new Handler());
 865     }
 866 
 867     private static URL checkURL(URL u) throws IOException {
 868         if (u != null) {
 869             if (u.toExternalForm().indexOf(&#39;\n&#39;) &gt; -1) {
 870                 throw new MalformedURLException(&quot;Illegal character in URL&quot;);
 871             }
 872         }
<span class="line-added"> 873         String s = IPAddressUtil.checkAuthority(u);</span>
<span class="line-added"> 874         if (s != null) {</span>
<span class="line-added"> 875             throw new MalformedURLException(s);</span>
<span class="line-added"> 876         }</span>
 877         return u;
 878     }
<span class="line-added"> 879 </span>
 880     protected HttpURLConnection(URL u, Proxy p, Handler handler)
 881             throws IOException {
 882         super(checkURL(u));
 883         requests = new MessageHeader();
 884         responses = new MessageHeader();
 885         userHeaders = new MessageHeader();
 886         this.handler = handler;
 887         instProxy = p;
 888         if (instProxy instanceof sun.net.ApplicationProxy) {
 889             /* Application set Proxies should not have access to cookies
 890              * in a secure environment unless explicitly allowed. */
 891             try {
 892                 cookieHandler = CookieHandler.getDefault();
 893             } catch (SecurityException se) { /* swallow exception */ }
 894         } else {
 895             cookieHandler = java.security.AccessController.doPrivileged(
 896                 new java.security.PrivilegedAction&lt;&gt;() {
 897                 public CookieHandler run() {
 898                     return CookieHandler.getDefault();
 899                 }
</pre>
<hr />
<pre>
1162              * 2) else use system default ProxySelector
1163              * 3) else make a direct connection if ProxySelector is not present
1164              */
1165 
1166             if (instProxy == null) { // no instance Proxy is set
1167                 /**
1168                  * Do we have to use a proxy?
1169                  */
1170                 ProxySelector sel =
1171                     java.security.AccessController.doPrivileged(
1172                         new java.security.PrivilegedAction&lt;&gt;() {
1173                             public ProxySelector run() {
1174                                      return ProxySelector.getDefault();
1175                                  }
1176                              });
1177                 if (sel != null) {
1178                     URI uri = sun.net.www.ParseUtil.toURI(url);
1179                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1180                         logger.finest(&quot;ProxySelector Request for &quot; + uri);
1181                     }
<span class="line-modified">1182                     final List&lt;Proxy&gt; proxies;</span>
<span class="line-added">1183                     try {</span>
<span class="line-added">1184                         proxies = sel.select(uri);</span>
<span class="line-added">1185                     } catch (IllegalArgumentException iae) {</span>
<span class="line-added">1186                         throw new IOException(&quot;Failed to select a proxy&quot;, iae);</span>
<span class="line-added">1187                     }</span>
<span class="line-added">1188                     final Iterator&lt;Proxy&gt; it = proxies.iterator();</span>
1189                     Proxy p;
1190                     while (it.hasNext()) {
1191                         p = it.next();
1192                         try {
1193                             if (!failedOnce) {
1194                                 http = getNewHttpClient(url, p, connectTimeout);
1195                                 http.setReadTimeout(readTimeout);
1196                             } else {
1197                                 // make sure to construct new connection if first
1198                                 // attempt failed
1199                                 http = getNewHttpClient(url, p, connectTimeout, false);
1200                                 http.setReadTimeout(readTimeout);
1201                             }
1202                             if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1203                                 if (p != null) {
1204                                     logger.finest(&quot;Proxy used: &quot; + p.toString());
1205                                 }
1206                             }
1207                             break;
1208                         } catch (IOException ioex) {
</pre>
<hr />
<pre>
1224                         http.setReadTimeout(readTimeout);
1225                     } else {
1226                         // make sure to construct new connection if first
1227                         // attempt failed
1228                         http = getNewHttpClient(url, null, connectTimeout, false);
1229                         http.setReadTimeout(readTimeout);
1230                     }
1231                 }
1232             } else {
1233                 if (!failedOnce) {
1234                     http = getNewHttpClient(url, instProxy, connectTimeout);
1235                     http.setReadTimeout(readTimeout);
1236                 } else {
1237                     // make sure to construct new connection if first
1238                     // attempt failed
1239                     http = getNewHttpClient(url, instProxy, connectTimeout, false);
1240                     http.setReadTimeout(readTimeout);
1241                 }
1242             }
1243 
<span class="line-added">1244             usingProxy = usingProxy || usingProxyInternal();</span>
1245             ps = (PrintStream)http.getOutputStream();
1246         } catch (IOException e) {
1247             throw e;
1248         }
1249         // constructor to HTTP client calls openserver
1250         connected = true;
1251     }
1252 
1253     // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
1254     protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout)
1255         throws IOException {
1256         return HttpClient.New(url, p, connectTimeout, this);
1257     }
1258 
1259     // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
1260     protected HttpClient getNewHttpClient(URL url, Proxy p,
1261                                           int connectTimeout, boolean useCache)
1262         throws IOException {
1263         return HttpClient.New(url, p, connectTimeout, useCache, this);
1264     }
</pre>
<hr />
<pre>
2156                     }
2157                 }
2158                 // cache proxy authentication info
2159                 if (proxyAuthentication != null) {
2160                     // cache auth info on success, domain header not relevant.
2161                     proxyAuthentication.addToCache();
2162                 }
2163 
2164                 if (respCode == HTTP_OK) {
2165                     setTunnelState(TunnelState.TUNNELING);
2166                     break;
2167                 }
2168                 // we don&#39;t know how to deal with other response code
2169                 // so disconnect and report error
2170                 disconnectInternal();
2171                 setTunnelState(TunnelState.NONE);
2172                 break;
2173             } while (retryTunnel &lt; maxRedirects);
2174 
2175             if (retryTunnel &gt;= maxRedirects || (respCode != HTTP_OK)) {
<span class="line-added">2176                 if (respCode != HTTP_PROXY_AUTH) {</span>
<span class="line-added">2177                     // remove all but authenticate responses</span>
<span class="line-added">2178                     responses.reset();</span>
<span class="line-added">2179                 }</span>
2180                 throw new IOException(&quot;Unable to tunnel through proxy.&quot;+
2181                                       &quot; Proxy returns \&quot;&quot; +
2182                                       statusLine + &quot;\&quot;&quot;);
2183             }
2184         } finally  {
2185             if (proxyAuthKey != null) {
2186                 AuthenticationInfo.endAuthRequest(proxyAuthKey);
2187             }
2188         }
2189 
2190         // restore original request headers
2191         requests = savedRequests;
2192 
2193         // reset responses
2194         responses.reset();
2195     }
2196 
2197     static String connectRequestURI(URL url) {
2198         String host = url.getHost();
2199         int port = url.getPort();
</pre>
<hr />
<pre>
2260             // Sets &quot;Proxy-authorization&quot;
2261             requests.set(pauth.getHeaderName(), value);
2262             currentProxyCredentials = pauth;
2263         }
2264     }
2265 
2266     /**
2267      * Gets the authentication for an HTTP proxy, and applies it to
2268      * the connection.
2269      */
2270     @SuppressWarnings(&quot;fallthrough&quot;)
2271     private AuthenticationInfo getHttpProxyAuthentication (AuthenticationHeader authhdr) {
2272         /* get authorization from authenticator */
2273         AuthenticationInfo ret = null;
2274         String raw = authhdr.raw();
2275         String host = http.getProxyHostUsed();
2276         int port = http.getProxyPortUsed();
2277         if (host != null &amp;&amp; authhdr.isPresent()) {
2278             HeaderParser p = authhdr.headerParser();
2279             String realm = p.findValue(&quot;realm&quot;);
<span class="line-added">2280             String charset = p.findValue(&quot;charset&quot;);</span>
<span class="line-added">2281             boolean isUTF8 = (charset != null &amp;&amp; charset.equalsIgnoreCase(&quot;UTF-8&quot;));</span>
2282             String scheme = authhdr.scheme();
2283             AuthScheme authScheme = UNKNOWN;
2284             if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {
2285                 authScheme = BASIC;
2286             } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {
2287                 authScheme = DIGEST;
2288             } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {
2289                 authScheme = NTLM;
2290                 doingNTLMp2ndStage = true;
2291             } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {
2292                 authScheme = KERBEROS;
2293                 doingNTLMp2ndStage = true;
2294             } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {
2295                 authScheme = NEGOTIATE;
2296                 doingNTLMp2ndStage = true;
2297             }
2298 
2299             if (realm == null)
2300                 realm = &quot;&quot;;
2301             proxyAuthKey = AuthenticationInfo.getProxyAuthKey(host, port, realm,
</pre>
<hr />
<pre>
2307                     InetAddress addr = null;
2308                     try {
2309                         final String finalHost = host;
2310                         addr = java.security.AccessController.doPrivileged(
2311                             new java.security.PrivilegedExceptionAction&lt;&gt;() {
2312                                 public InetAddress run()
2313                                     throws java.net.UnknownHostException {
2314                                     return InetAddress.getByName(finalHost);
2315                                 }
2316                             });
2317                     } catch (java.security.PrivilegedActionException ignored) {
2318                         // User will have an unknown host.
2319                     }
2320                     PasswordAuthentication a =
2321                         privilegedRequestPasswordAuthentication(
2322                                     authenticator,
2323                                     host, addr, port, &quot;http&quot;,
2324                                     realm, scheme, url, RequestorType.PROXY);
2325                     if (a != null) {
2326                         ret = new BasicAuthentication(true, host, port, realm, a,
<span class="line-modified">2327                                              isUTF8, getAuthenticatorKey());</span>
2328                     }
2329                     break;
2330                 case DIGEST:
2331                     a = privilegedRequestPasswordAuthentication(
2332                                     authenticator,
2333                                     host, null, port, url.getProtocol(),
2334                                     realm, scheme, url, RequestorType.PROXY);
2335                     if (a != null) {
2336                         DigestAuthentication.Parameters params =
2337                             new DigestAuthentication.Parameters();
2338                         ret = new DigestAuthentication(true, host, port, realm,
2339                                              scheme, a, params,
2340                                              getAuthenticatorKey());
2341                     }
2342                     break;
2343                 case NTLM:
2344                     if (NTLMAuthenticationProxy.supported) {
2345                         /* tryTransparentNTLMProxy will always be true the first
2346                          * time around, but verify that the platform supports it
2347                          * otherwise don&#39;t try. */
</pre>
<hr />
<pre>
2425         }
2426         return ret;
2427     }
2428 
2429     /**
2430      * Gets the authentication for an HTTP server, and applies it to
2431      * the connection.
2432      * @param authHdr the AuthenticationHeader which tells what auth scheme is
2433      * preferred.
2434      */
2435     @SuppressWarnings(&quot;fallthrough&quot;)
2436     private AuthenticationInfo getServerAuthentication (AuthenticationHeader authhdr) {
2437         /* get authorization from authenticator */
2438         AuthenticationInfo ret = null;
2439         String raw = authhdr.raw();
2440         /* When we get an NTLM auth from cache, don&#39;t set any special headers */
2441         if (authhdr.isPresent()) {
2442             HeaderParser p = authhdr.headerParser();
2443             String realm = p.findValue(&quot;realm&quot;);
2444             String scheme = authhdr.scheme();
<span class="line-added">2445             String charset = p.findValue(&quot;charset&quot;);</span>
<span class="line-added">2446             boolean isUTF8 = (charset != null &amp;&amp; charset.equalsIgnoreCase(&quot;UTF-8&quot;));</span>
2447             AuthScheme authScheme = UNKNOWN;
2448             if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {
2449                 authScheme = BASIC;
2450             } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {
2451                 authScheme = DIGEST;
2452             } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {
2453                 authScheme = NTLM;
2454                 doingNTLM2ndStage = true;
2455             } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {
2456                 authScheme = KERBEROS;
2457                 doingNTLM2ndStage = true;
2458             } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {
2459                 authScheme = NEGOTIATE;
2460                 doingNTLM2ndStage = true;
2461             }
2462 
2463             domain = p.findValue (&quot;domain&quot;);
2464             if (realm == null)
2465                 realm = &quot;&quot;;
2466             serverAuthKey = AuthenticationInfo.getServerAuthKey(url, realm, authScheme,
</pre>
<hr />
<pre>
2478             int port = url.getPort();
2479             if (port == -1) {
2480                 port = url.getDefaultPort();
2481             }
2482             if (ret == null) {
2483                 switch(authScheme) {
2484                 case KERBEROS:
2485                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Kerberos&quot;));
2486                     break;
2487                 case NEGOTIATE:
2488                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Negotiate&quot;));
2489                     break;
2490                 case BASIC:
2491                     PasswordAuthentication a =
2492                         privilegedRequestPasswordAuthentication(
2493                             authenticator,
2494                             url.getHost(), addr, port, url.getProtocol(),
2495                             realm, scheme, url, RequestorType.SERVER);
2496                     if (a != null) {
2497                         ret = new BasicAuthentication(false, url, realm, a,
<span class="line-modified">2498                                     isUTF8, getAuthenticatorKey());</span>
2499                     }
2500                     break;
2501                 case DIGEST:
2502                     a = privilegedRequestPasswordAuthentication(
2503                             authenticator,
2504                             url.getHost(), addr, port, url.getProtocol(),
2505                             realm, scheme, url, RequestorType.SERVER);
2506                     if (a != null) {
2507                         digestparams = new DigestAuthentication.Parameters();
2508                         ret = new DigestAuthentication(false, url, realm, scheme,
2509                                     a, digestparams,
2510                                     getAuthenticatorKey());
2511                     }
2512                     break;
2513                 case NTLM:
2514                     if (NTLMAuthenticationProxy.supported) {
2515                         URL url1;
2516                         try {
2517                             url1 = new URL (url, &quot;/&quot;); /* truncate the path */
2518                         } catch (Exception e) {
</pre>
<hr />
<pre>
2902                 disconnectInternal();
2903                 return;
2904             }
2905             try {
2906                 if (is instanceof MeteredStream) {
2907                     is.close();
2908                 }
2909             } catch (IOException e) { }
2910         }
2911         responseCode = -1;
2912         responses = new MessageHeader();
2913         connected = false;
2914     }
2915 
2916     /**
2917      * Disconnect from the web server at the first 401 error. Do not
2918      * disconnect when using a proxy, a good proxy should have already
2919      * closed the connection to the web server.
2920      */
2921     private void disconnectWeb() throws IOException {
<span class="line-modified">2922         if (usingProxyInternal() &amp;&amp; http.isKeepingAlive()) {</span>
2923             responseCode = -1;
2924             // clean up, particularly, skip the content part
2925             // of a 401 error response
2926             reset();
2927         } else {
2928             disconnectInternal();
2929         }
2930     }
2931 
2932     /**
2933      * Disconnect from the server (for internal use)
2934      */
2935     private void disconnectInternal() {
2936         responseCode = -1;
2937         inputStream = null;
2938         if (pi != null) {
2939             pi.finishTracking();
2940             pi = null;
2941         }
2942         if (http != null) {
</pre>
<hr />
<pre>
3005 
3006             } else {
3007                 // We are deliberatly being disconnected so HttpClient
3008                 // should not try to resend the request no matter what stage
3009                 // of the connection we are in.
3010                 http.setDoNotRetry(true);
3011 
3012                 http.closeServer();
3013             }
3014 
3015             //      poster = null;
3016             http = null;
3017             connected = false;
3018         }
3019         cachedInputStream = null;
3020         if (cachedHeaders != null) {
3021             cachedHeaders.reset();
3022         }
3023     }
3024 
<span class="line-modified">3025     /**</span>
<span class="line-added">3026      * Returns true only if the established connection is using a proxy</span>
<span class="line-added">3027      */</span>
<span class="line-added">3028     boolean usingProxyInternal() {</span>
3029         if (http != null) {
3030             return (http.getProxyHostUsed() != null);
3031         }
3032         return false;
3033     }
3034 
<span class="line-added">3035     /**</span>
<span class="line-added">3036      * Returns true if the established connection is using a proxy</span>
<span class="line-added">3037      * or if a proxy is specified for the inactive connection</span>
<span class="line-added">3038      */</span>
<span class="line-added">3039     @Override</span>
<span class="line-added">3040     public boolean usingProxy() {</span>
<span class="line-added">3041         if (usingProxy || usingProxyInternal())</span>
<span class="line-added">3042             return true;</span>
<span class="line-added">3043 </span>
<span class="line-added">3044         if (instProxy != null)</span>
<span class="line-added">3045             return instProxy.type().equals(Proxy.Type.HTTP);</span>
<span class="line-added">3046 </span>
<span class="line-added">3047         return false;</span>
<span class="line-added">3048     }</span>
<span class="line-added">3049 </span>
3050     // constant strings represent set-cookie header names
3051     private static final String SET_COOKIE = &quot;set-cookie&quot;;
3052     private static final String SET_COOKIE2 = &quot;set-cookie2&quot;;
3053 
3054     /**
3055      * Returns a filtered version of the given headers value.
3056      *
3057      * Note: The implementation currently only filters out HttpOnly cookies
3058      *       from Set-Cookie and Set-Cookie2 headers.
3059      */
3060     private String filterHeaderField(String name, String value) {
3061         if (value == null)
3062             return null;
3063 
3064         if (SET_COOKIE.equalsIgnoreCase(name) ||
3065             SET_COOKIE2.equalsIgnoreCase(name)) {
3066 
3067             // Filtering only if there is a cookie handler. [Assumption: the
3068             // cookie handler will store/retrieve the HttpOnly cookies]
3069             if (cookieHandler == null || value.isEmpty())
</pre>
</td>
</tr>
</table>
<center><a href="DigestAuthentication.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NegotiateAuthentication.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
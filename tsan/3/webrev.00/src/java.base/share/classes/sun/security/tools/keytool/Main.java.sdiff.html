<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/tools/keytool/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertAndKeyGen.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Resources.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/tools/keytool/Main.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.keytool;
  27 
  28 import java.io.*;
  29 import java.nio.file.Files;
  30 import java.nio.file.Path;
  31 import java.security.AlgorithmParameters;
  32 import java.security.CodeSigner;
  33 import java.security.CryptoPrimitive;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreException;
  36 import java.security.MessageDigest;
  37 import java.security.Key;
  38 import java.security.PublicKey;
  39 import java.security.PrivateKey;

  40 import java.security.Signature;
  41 import java.security.Timestamp;
  42 import java.security.UnrecoverableEntryException;
  43 import java.security.UnrecoverableKeyException;
  44 import java.security.Principal;
  45 import java.security.cert.Certificate;
  46 import java.security.cert.CertificateFactory;
  47 import java.security.cert.CertStoreException;
  48 import java.security.cert.CRL;
  49 import java.security.cert.X509Certificate;
  50 import java.security.cert.CertificateException;
  51 import java.security.cert.URICertStoreParameters;
  52 
  53 
  54 import java.security.interfaces.ECKey;
  55 import java.security.spec.AlgorithmParameterSpec;
  56 import java.security.spec.ECParameterSpec;
  57 import java.text.Collator;
  58 import java.text.MessageFormat;
  59 import java.util.*;

  60 import java.util.jar.JarEntry;
  61 import java.util.jar.JarFile;
  62 import java.math.BigInteger;
  63 import java.net.URI;
  64 import java.net.URL;
  65 import java.net.URLClassLoader;
  66 import java.security.cert.CertStore;
  67 
  68 import java.security.cert.X509CRL;
  69 import java.security.cert.X509CRLEntry;
  70 import java.security.cert.X509CRLSelector;
  71 import javax.security.auth.x500.X500Principal;
  72 import java.util.Base64;
  73 
  74 import sun.security.pkcs12.PKCS12KeyStore;
  75 import sun.security.util.ECKeySizeParameterSpec;
  76 import sun.security.util.KeyUtil;
  77 import sun.security.util.NamedCurve;
  78 import sun.security.util.ObjectIdentifier;
  79 import sun.security.pkcs10.PKCS10;
  80 import sun.security.pkcs10.PKCS10Attribute;
  81 import sun.security.provider.X509Factory;
  82 import sun.security.provider.certpath.ssl.SSLServerCertStore;
  83 import sun.security.util.Password;
  84 import sun.security.util.SecurityProperties;
  85 import sun.security.util.SecurityProviderConstants;

  86 import javax.crypto.KeyGenerator;
  87 import javax.crypto.SecretKey;
  88 import javax.crypto.SecretKeyFactory;
  89 import javax.crypto.spec.PBEKeySpec;
  90 
  91 import sun.security.pkcs.PKCS9Attribute;
  92 import sun.security.tools.KeyStoreUtil;
  93 import sun.security.tools.PathList;
  94 import sun.security.util.DerValue;
  95 import sun.security.util.Pem;
  96 import sun.security.x509.*;
  97 
  98 import static java.security.KeyStore.*;
  99 import java.security.Security;
 100 import static sun.security.tools.keytool.Main.Command.*;
 101 import static sun.security.tools.keytool.Main.Option.*;
 102 import sun.security.util.DisabledAlgorithmConstraints;
 103 
 104 /**
 105  * This tool manages keystores.
</pre>
<hr />
<pre>
 157     private File ksfile = null;
 158     private InputStream ksStream = null; // keystore stream
 159     private String sslserver = null;
 160     private String jarfile = null;
 161     private KeyStore keyStore = null;
 162     private boolean token = false;
 163     private boolean nullStream = false;
 164     private boolean kssave = false;
 165     private boolean noprompt = false;
 166     private boolean trustcacerts = false;
 167     private boolean protectedPath = false;
 168     private boolean srcprotectedPath = false;
 169     private boolean cacerts = false;
 170     private boolean nowarn = false;
 171     private KeyStore caks = null; // &quot;cacerts&quot; keystore
 172     private char[] srcstorePass = null;
 173     private String srcstoretype = null;
 174     private Set&lt;char[]&gt; passwords = new HashSet&lt;&gt;();
 175     private String startDate = null;
 176 


 177     private List&lt;String&gt; ids = new ArrayList&lt;&gt;();   // used in GENCRL
 178     private List&lt;String&gt; v3ext = new ArrayList&lt;&gt;();
 179 
 180     // In-place importkeystore is special.
 181     // A backup is needed, and no need to prompt for deststorepass.
 182     private boolean inplaceImport = false;
 183     private String inplaceBackupName = null;
 184 
 185     // Warnings on weak algorithms etc
 186     private List&lt;String&gt; weakWarnings = new ArrayList&lt;&gt;();
 187 
 188     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 189             new DisabledAlgorithmConstraints(
 190                     DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);
 191 
 192     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 193             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 194     private boolean isPasswordlessKeyStore = false;
 195 
 196     enum Command {
</pre>
<hr />
<pre>
 242             V),
 243         KEYPASSWD(&quot;Changes.the.key.password.of.an.entry&quot;,
 244             ALIAS, KEYPASS, NEW, KEYSTORE, STOREPASS,
 245             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 246             PROVIDERPATH, V),
 247         LIST(&quot;Lists.entries.in.a.keystore&quot;,
 248             RFC, ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 249             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 250             PROVIDERPATH, V, PROTECTED),
 251         PRINTCERT(&quot;Prints.the.content.of.a.certificate&quot;,
 252             RFC, FILEIN, SSLSERVER, JARFILE,
 253             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 254             PROVIDERPATH, V),
 255         PRINTCERTREQ(&quot;Prints.the.content.of.a.certificate.request&quot;,
 256             FILEIN, V),
 257         PRINTCRL(&quot;Prints.the.content.of.a.CRL.file&quot;,
 258             FILEIN, V),
 259         STOREPASSWD(&quot;Changes.the.store.password.of.a.keystore&quot;,
 260             NEW, KEYSTORE, CACERTS, STOREPASS, STORETYPE, PROVIDERNAME,
 261             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),


 262 
 263         // Undocumented start here, KEYCLONE is used a marker in -help;
 264 
 265         KEYCLONE(&quot;Clones.a.key.entry&quot;,
 266             ALIAS, DESTALIAS, KEYPASS, NEW, STORETYPE,
 267             KEYSTORE, STOREPASS, PROVIDERNAME, ADDPROVIDER,
 268             PROVIDERCLASS, PROVIDERPATH, V),
 269         SELFCERT(&quot;Generates.a.self.signed.certificate&quot;,
 270             ALIAS, SIGALG, DNAME, STARTDATE, EXT, VALIDITY, KEYPASS,
 271             STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 272             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 273         GENCRL(&quot;Generates.CRL&quot;,
 274             RFC, FILEOUT, ID,
 275             ALIAS, SIGALG, KEYPASS, KEYSTORE,
 276             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 277             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 278         IDENTITYDB(&quot;Imports.entries.from.a.JDK.1.1.x.style.identity.database&quot;,
 279             FILEIN, STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 280             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V);
 281 
</pre>
<hr />
<pre>
 347         OUTFILE(&quot;outfile&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 348         PROTECTED(&quot;protected&quot;, null, &quot;password.through.protected.mechanism&quot;),
 349         PROVIDERCLASS(&quot;providerclass&quot;, &quot;&lt;class&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;provider.class.option&quot;),
 350         ADDPROVIDER(&quot;addprovider&quot;, &quot;&lt;name&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;addprovider.option&quot;),
 351         PROVIDERNAME(&quot;providername&quot;, &quot;&lt;name&gt;&quot;, &quot;provider.name&quot;),
 352         PROVIDERPATH(&quot;providerpath&quot;, &quot;&lt;list&gt;&quot;, &quot;provider.classpath&quot;),
 353         RFC(&quot;rfc&quot;, null, &quot;output.in.RFC.style&quot;),
 354         SIGALG(&quot;sigalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;signature.algorithm.name&quot;),
 355         SRCALIAS(&quot;srcalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;source.alias&quot;),
 356         SRCKEYPASS(&quot;srckeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.key.password&quot;),
 357         SRCKEYSTORE(&quot;srckeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;source.keystore.name&quot;),
 358         SRCPROTECTED(&quot;srcprotected&quot;, null, &quot;source.keystore.password.protected&quot;),
 359         SRCPROVIDERNAME(&quot;srcprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;source.keystore.provider.name&quot;),
 360         SRCSTOREPASS(&quot;srcstorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.keystore.password&quot;),
 361         SRCSTORETYPE(&quot;srcstoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;source.keystore.type&quot;),
 362         SSLSERVER(&quot;sslserver&quot;, &quot;&lt;server[:port]&gt;&quot;, &quot;SSL.server.host.and.port&quot;),
 363         JARFILE(&quot;jarfile&quot;, &quot;&lt;file&gt;&quot;, &quot;signed.jar.file&quot;),
 364         STARTDATE(&quot;startdate&quot;, &quot;&lt;date&gt;&quot;, &quot;certificate.validity.start.date.time&quot;),
 365         STOREPASS(&quot;storepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;keystore.password&quot;),
 366         STORETYPE(&quot;storetype&quot;, &quot;&lt;type&gt;&quot;, &quot;keystore.type&quot;),

 367         TRUSTCACERTS(&quot;trustcacerts&quot;, null, &quot;trust.certificates.from.cacerts&quot;),
 368         V(&quot;v&quot;, null, &quot;verbose.output&quot;),
 369         VALIDITY(&quot;validity&quot;, &quot;&lt;days&gt;&quot;, &quot;validity.number.of.days&quot;);
 370 
 371         final String name, arg, description;
 372         Option(String name, String arg, String description) {
 373             this.name = name;
 374             this.arg = arg;
 375             this.description = description;
 376         }
 377         @Override
 378         public String toString() {
 379             return &quot;-&quot; + name;
 380         }
 381     };
 382 
 383     private static final String NONE = &quot;NONE&quot;;
 384     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 385     private static final String P12KEYSTORE = &quot;PKCS12&quot;;
 386     private static final String keyAlias = &quot;mykey&quot;;
</pre>
<hr />
<pre>
 660             }
 661 
 662             /*
 663              * options
 664              */
 665             else if (collator.compare(flags, &quot;-v&quot;) == 0) {
 666                 verbose = true;
 667             } else if (collator.compare(flags, &quot;-debug&quot;) == 0) {
 668                 // Already processed
 669             } else if (collator.compare(flags, &quot;-rfc&quot;) == 0) {
 670                 rfc = true;
 671             } else if (collator.compare(flags, &quot;-noprompt&quot;) == 0) {
 672                 noprompt = true;
 673             } else if (collator.compare(flags, &quot;-trustcacerts&quot;) == 0) {
 674                 trustcacerts = true;
 675             } else if (collator.compare(flags, &quot;-protected&quot;) == 0 ||
 676                     collator.compare(flags, &quot;-destprotected&quot;) == 0) {
 677                 protectedPath = true;
 678             } else if (collator.compare(flags, &quot;-srcprotected&quot;) == 0) {
 679                 srcprotectedPath = true;


 680             } else  {
 681                 System.err.println(rb.getString(&quot;Illegal.option.&quot;) + flags);
 682                 tinyHelp();
 683             }
 684         }
 685 
 686         if (i&lt;args.length) {
 687             System.err.println(rb.getString(&quot;Illegal.option.&quot;) + args[i]);
 688             tinyHelp();
 689         }
 690 
 691         if (command == null) {
 692             if (help) {
 693                 usage();
 694             } else {
 695                 System.err.println(rb.getString(&quot;Usage.error.no.command.provided&quot;));
 696                 tinyHelp();
 697             }
 698         } else if (help) {
 699             usage();
 700             command = null;
 701         }
 702 
 703         return args;
 704     }
 705 
 706     boolean isKeyStoreRelated(Command cmd) {
<span class="line-modified"> 707         return cmd != PRINTCERT &amp;&amp; cmd != PRINTCERTREQ;</span>
 708     }
 709 
 710     /**
 711      * Execute the commands.
 712      */
 713     void doCommands(PrintStream out) throws Exception {
 714 
 715         if (cacerts) {
 716             if (ksfname != null || storetype != null) {
 717                 throw new IllegalArgumentException(rb.getString
 718                         (&quot;the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option&quot;));
 719             }
 720             ksfname = KeyStoreUtil.getCacerts();
 721         }
 722 
 723         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 724                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 725             token = true;
 726             if (ksfname == null) {
 727                 ksfname = NONE;
</pre>
<hr />
<pre>
 856             ksfname = System.getProperty(&quot;user.home&quot;) + File.separator
 857                     + &quot;.keystore&quot;;
 858         }
 859 
 860         KeyStore srcKeyStore = null;
 861         if (command == IMPORTKEYSTORE) {
 862             inplaceImport = inplaceImportCheck();
 863             if (inplaceImport) {
 864                 // We load srckeystore first so we have srcstorePass that
 865                 // can be assigned to storePass
 866                 srcKeyStore = loadSourceKeyStore();
 867                 if (storePass == null) {
 868                     storePass = srcstorePass;
 869                 }
 870             }
 871         }
 872 
 873         // Check if keystore exists.
 874         // If no keystore has been specified at the command line, try to use
 875         // the default, which is located in $HOME/.keystore.
<span class="line-modified"> 876         // If the command is &quot;genkey&quot;, &quot;identitydb&quot;, &quot;import&quot;, or &quot;printcert&quot;,</span>
<span class="line-removed"> 877         // it is OK not to have a keystore.</span>
 878 
 879         // DO NOT open the existing keystore if this is an in-place import.
 880         // The keystore should be created as brand new.
 881         if (isKeyStoreRelated(command) &amp;&amp; !nullStream &amp;&amp; !inplaceImport) {
 882             try {
 883                 ksfile = new File(ksfname);
 884                 // Check if keystore file is empty
 885                 if (ksfile.exists() &amp;&amp; ksfile.length() == 0) {
 886                     throw new Exception(rb.getString
 887                             (&quot;Keystore.file.exists.but.is.empty.&quot;) + ksfname);
 888                 }
 889                 ksStream = new FileInputStream(ksfile);
 890             } catch (FileNotFoundException e) {



 891                 if (command != GENKEYPAIR &amp;&amp;
 892                         command != GENSECKEY &amp;&amp;
 893                         command != IDENTITYDB &amp;&amp;
 894                         command != IMPORTCERT &amp;&amp;
 895                         command != IMPORTPASS &amp;&amp;
 896                         command != IMPORTKEYSTORE &amp;&amp;
 897                         command != PRINTCRL) {
 898                     throw new Exception(rb.getString
 899                             (&quot;Keystore.file.does.not.exist.&quot;) + ksfname);
 900                 }
 901             }
 902         }
 903 
 904         if ((command == KEYCLONE || command == CHANGEALIAS)
 905                 &amp;&amp; dest == null) {
 906             dest = getAlias(&quot;destination&quot;);
 907             if (&quot;&quot;.equals(dest)) {
 908                 throw new Exception(rb.getString
 909                         (&quot;Must.specify.destination.alias&quot;));
 910             }
</pre>
<hr />
<pre>
1122         } else if (command == DELETE) {
1123             doDeleteEntry(alias);
1124             kssave = true;
1125         } else if (command == EXPORTCERT) {
1126             if (filename != null) {
1127                 try (PrintStream ps = new PrintStream(new FileOutputStream
1128                                                    (filename))) {
1129                     doExportCert(alias, ps);
1130                 }
1131             } else {
1132                 doExportCert(alias, out);
1133             }
1134             if (filename != null) {
1135                 MessageFormat form = new MessageFormat(rb.getString
1136                         (&quot;Certificate.stored.in.file.filename.&quot;));
1137                 Object[] source = {filename};
1138                 System.err.println(form.format(source));
1139             }
1140         } else if (command == GENKEYPAIR) {
1141             if (keyAlgName == null) {
<span class="line-modified">1142                 keyAlgName = &quot;DSA&quot;;</span>
<span class="line-modified">1143                 weakWarnings.add(String.format(rb.getString(</span>
<span class="line-removed">1144                         &quot;keyalg.option.1.missing.warning&quot;), keyAlgName));</span>
1145             }
1146             doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName);
1147             kssave = true;
1148         } else if (command == GENSECKEY) {
1149             if (keyAlgName == null) {
<span class="line-modified">1150                 keyAlgName = &quot;DES&quot;;</span>
<span class="line-modified">1151                 weakWarnings.add(String.format(rb.getString(</span>
<span class="line-removed">1152                         &quot;keyalg.option.1.missing.warning&quot;), keyAlgName));</span>
1153             }
1154             doGenSecretKey(alias, keyAlgName, keysize);
1155             kssave = true;
1156         } else if (command == IMPORTPASS) {
1157             if (keyAlgName == null) {
1158                 keyAlgName = &quot;PBE&quot;;
1159             }
1160             // password is stored as a secret key
1161             doGenSecretKey(alias, keyAlgName, keysize);
1162             kssave = true;
1163         } else if (command == IDENTITYDB) {
1164             if (filename != null) {
1165                 try (InputStream inStream = new FileInputStream(filename)) {
1166                     doImportIdentityDatabase(inStream);
1167                 }
1168             } else {
1169                 doImportIdentityDatabase(System.in);
1170             }
1171         } else if (command == IMPORTCERT) {
1172             InputStream inStream = System.in;
</pre>
<hr />
<pre>
1293                 alias = keyAlias;
1294             }
1295             if (filename != null) {
1296                 try (PrintStream ps =
1297                          new PrintStream(new FileOutputStream(filename))) {
1298                     doGenCRL(ps);
1299                 }
1300             } else {
1301                 doGenCRL(out);
1302             }
1303         } else if (command == PRINTCERTREQ) {
1304             if (filename != null) {
1305                 try (InputStream inStream = new FileInputStream(filename)) {
1306                     doPrintCertReq(inStream, out);
1307                 }
1308             } else {
1309                 doPrintCertReq(System.in, out);
1310             }
1311         } else if (command == PRINTCRL) {
1312             doPrintCRL(filename, out);


1313         }
1314 
1315         // If we need to save the keystore, do so.
1316         if (kssave) {
1317             if (verbose) {
1318                 MessageFormat form = new MessageFormat
1319                         (rb.getString(&quot;.Storing.ksfname.&quot;));
1320                 Object[] source = {nullStream ? &quot;keystore&quot; : ksfname};
1321                 System.err.println(form.format(source));
1322             }
1323 
1324             if (token) {
1325                 keyStore.store(null, null);
1326             } else {
1327                 char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1328                 if (nullStream) {
1329                     keyStore.store(null, pass);
1330                 } else {
1331                     ByteArrayOutputStream bout = new ByteArrayOutputStream();
1332                     keyStore.store(bout, pass);
</pre>
<hr />
<pre>
1412         Certificate signerCert = keyStore.getCertificate(alias);
1413         byte[] encoded = signerCert.getEncoded();
1414         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1415         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1416                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1417         X500Name issuer = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1418                                            X509CertInfo.DN_NAME);
1419 
1420         Date firstDate = getStartDate(startDate);
1421         Date lastDate = new Date();
1422         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
1423         CertificateValidity interval = new CertificateValidity(firstDate,
1424                                                                lastDate);
1425 
1426         PrivateKey privateKey =
1427                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1428         if (sigAlgName == null) {
1429             sigAlgName = getCompatibleSigAlgName(privateKey);
1430         }
1431         Signature signature = Signature.getInstance(sigAlgName);
<span class="line-removed">1432         signature.initSign(privateKey);</span>
<span class="line-removed">1433 </span>
<span class="line-removed">1434         X509CertInfo info = new X509CertInfo();</span>
1435         AlgorithmParameterSpec params = AlgorithmId
1436                 .getDefaultAlgorithmParameterSpec(sigAlgName, privateKey);




1437         AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlgName, params);
1438         info.set(X509CertInfo.VALIDITY, interval);
<span class="line-modified">1439         info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(</span>
<span class="line-modified">1440                     new java.util.Random().nextInt() &amp; 0x7fffffff));</span>
1441         info.set(X509CertInfo.VERSION,
1442                     new CertificateVersion(CertificateVersion.V3));
1443         info.set(X509CertInfo.ALGORITHM_ID,
1444                     new CertificateAlgorithmId(algID));
1445         info.set(X509CertInfo.ISSUER, issuer);
1446 
1447         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1448         boolean canRead = false;
1449         StringBuffer sb = new StringBuffer();
1450         while (true) {
1451             String s = reader.readLine();
1452             if (s == null) break;
1453             // OpenSSL does not use NEW
1454             //if (s.startsWith(&quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;)) {
1455             if (s.startsWith(&quot;-----BEGIN&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1456                 canRead = true;
1457             //} else if (s.startsWith(&quot;-----END NEW CERTIFICATE REQUEST-----&quot;)) {
1458             } else if (s.startsWith(&quot;-----END&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1459                 break;
1460             } else if (canRead) {
</pre>
<hr />
<pre>
1570 
1571         Certificate cert = keyStore.getCertificate(alias);
1572         if (cert == null) {
1573             MessageFormat form = new MessageFormat
1574                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
1575             Object[] source = {alias};
1576             throw new Exception(form.format(source));
1577         }
1578         PKCS10 request = new PKCS10(cert.getPublicKey());
1579         CertificateExtensions ext = createV3Extensions(null, null, v3ext, cert.getPublicKey(), null);
1580         // Attribute name is not significant
1581         request.getAttributes().setAttribute(X509CertInfo.EXTENSIONS,
1582                 new PKCS10Attribute(PKCS9Attribute.EXTENSION_REQUEST_OID, ext));
1583 
1584         // Construct a Signature object, so that we can sign the request
1585         if (sigAlgName == null) {
1586             sigAlgName = getCompatibleSigAlgName(privKey);
1587         }
1588 
1589         Signature signature = Signature.getInstance(sigAlgName);
<span class="line-removed">1590         signature.initSign(privKey);</span>
1591         AlgorithmParameterSpec params = AlgorithmId
1592                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
<span class="line-modified">1593         if (params != null) {</span>
<span class="line-removed">1594             signature.setParameter(params);</span>
<span class="line-removed">1595         }</span>
1596 
1597         X500Name subject = dname == null?
1598                 new X500Name(((X509Certificate)cert).getSubjectDN().toString()):
1599                 new X500Name(dname);
1600 
1601         // Sign the request and base-64 encode it
1602         request.encodeAndSign(subject, signature);
1603         request.print(out);
1604 
1605         checkWeak(rb.getString(&quot;the.generated.certificate.request&quot;), request);
1606     }
1607 
1608     /**
1609      * Deletes an entry from the keystore.
1610      */
1611     private void doDeleteEntry(String alias) throws Exception {
1612         if (keyStore.containsAlias(alias) == false) {
1613             MessageFormat form = new MessageFormat
1614                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1615             Object[] source = {alias};
</pre>
<hr />
<pre>
2390      * Prints all keystore entries.
2391      */
2392     private void doPrintEntries(PrintStream out)
2393         throws Exception
2394     {
2395         out.println(rb.getString(&quot;Keystore.type.&quot;) + keyStore.getType());
2396         out.println(rb.getString(&quot;Keystore.provider.&quot;) +
2397                 keyStore.getProvider().getName());
2398         out.println();
2399 
2400         MessageFormat form;
2401         form = (keyStore.size() == 1) ?
2402                 new MessageFormat(rb.getString
2403                         (&quot;Your.keystore.contains.keyStore.size.entry&quot;)) :
2404                 new MessageFormat(rb.getString
2405                         (&quot;Your.keystore.contains.keyStore.size.entries&quot;));
2406         Object[] source = {keyStore.size()};
2407         out.println(form.format(source));
2408         out.println();
2409 
<span class="line-modified">2410         for (Enumeration&lt;String&gt; e = keyStore.aliases();</span>
<span class="line-modified">2411                                         e.hasMoreElements(); ) {</span>
<span class="line-modified">2412             String alias = e.nextElement();</span>
2413             doPrintEntry(&quot;&lt;&quot; + alias + &quot;&gt;&quot;, alias, out);
2414             if (verbose || rfc) {
2415                 out.println(rb.getString(&quot;NEWLINE&quot;));
2416                 out.println(rb.getString
2417                         (&quot;STAR&quot;));
2418                 out.println(rb.getString
2419                         (&quot;STARNN&quot;));
2420             }
2421         }
2422     }
2423 
2424     private static &lt;T&gt; Iterable&lt;T&gt; e2i(final Enumeration&lt;T&gt; e) {
2425         return new Iterable&lt;T&gt;() {
2426             @Override
2427             public Iterator&lt;T&gt; iterator() {
2428                 return new Iterator&lt;T&gt;() {
2429                     @Override
2430                     public boolean hasNext() {
2431                         return e.hasMoreElements();
2432                     }
</pre>
<hr />
<pre>
2689             } catch (ClassCastException cce) {
2690                 throw new Exception(rb.getString(&quot;Not.X.509.certificate&quot;));
2691             }
2692             if (certs.length &gt; 1) {
2693                 MessageFormat form = new MessageFormat
2694                         (rb.getString(&quot;Certificate.i.1.&quot;));
2695                 Object[] source = {i + 1};
2696                 out.println(form.format(source));
2697             }
2698             if (rfc)
2699                 dumpCert(x509Cert, out);
2700             else
2701                 printX509Cert(x509Cert, out);
2702             if (i &lt; (certs.length-1)) {
2703                 out.println();
2704             }
2705             checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i, certs.length), x509Cert);
2706         }
2707     }
2708 








2709     private Collection&lt;? extends Certificate&gt; generateCertificates(InputStream in)
2710             throws CertificateException, IOException {
2711         byte[] data = in.readAllBytes();
2712         try {
2713             return CertificateFactory.getInstance(&quot;X.509&quot;)
2714                     .generateCertificates(new ByteArrayInputStream(data));
2715         } catch (CertificateException e) {
2716             if (providerName != null) {
2717                 try {
2718                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2719                             .generateCertificates(new ByteArrayInputStream(data));
2720                 } catch (Exception e2) {
2721                     e.addSuppressed(e2);
2722                 }
2723             }
2724             throw e;
2725         }
2726     }
2727 
2728     private Certificate generateCertificate(InputStream in)
</pre>
<hr />
<pre>
2930             throw new Exception(form.format(source));
2931         }
2932 
2933         // convert to X509CertImpl, so that we can modify selected fields
2934         // (no public APIs available yet)
2935         byte[] encoded = oldCert.getEncoded();
2936         X509CertImpl certImpl = new X509CertImpl(encoded);
2937         X509CertInfo certInfo = (X509CertInfo)certImpl.get(X509CertImpl.NAME
2938                                                            + &quot;.&quot; +
2939                                                            X509CertImpl.INFO);
2940 
2941         // Extend its validity
2942         Date firstDate = getStartDate(startDate);
2943         Date lastDate = new Date();
2944         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
2945         CertificateValidity interval = new CertificateValidity(firstDate,
2946                                                                lastDate);
2947         certInfo.set(X509CertInfo.VALIDITY, interval);
2948 
2949         // Make new serial number
<span class="line-modified">2950         certInfo.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(</span>
<span class="line-modified">2951                     new java.util.Random().nextInt() &amp; 0x7fffffff));</span>
2952 
2953         // Set owner and issuer fields
2954         X500Name owner;
2955         if (dname == null) {
2956             // Get the owner name from the certificate
2957             owner = (X500Name)certInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
2958                                            X509CertInfo.DN_NAME);
2959         } else {
2960             // Use the owner name specified at the command line
2961             owner = new X500Name(dname);
2962             certInfo.set(X509CertInfo.SUBJECT + &quot;.&quot; +
2963                          X509CertInfo.DN_NAME, owner);
2964         }
2965         // Make issuer same as owner (self-signed!)
2966         certInfo.set(X509CertInfo.ISSUER + &quot;.&quot; +
2967                      X509CertInfo.DN_NAME, owner);
2968 
2969         // The inner and outer signature algorithms have to match.
2970         // The way we achieve that is really ugly, but there seems to be no
2971         // other solution: We first sign the cert, then retrieve the
</pre>
<hr />
<pre>
3542              if (i &lt; len-1) {
3543                  buf.append(&quot;:&quot;);
3544              }
3545         }
3546         return buf.toString();
3547     }
3548 
3549     /**
3550      * Recovers (private) key associated with given alias.
3551      *
3552      * @return an array of objects, where the 1st element in the array is the
3553      * recovered private key, and the 2nd element is the password used to
3554      * recover it.
3555      */
3556     private Pair&lt;Key,char[]&gt; recoverKey(String alias, char[] storePass,
3557                                        char[] keyPass)
3558         throws Exception
3559     {
3560         Key key = null;
3561 





3562         if (keyStore.containsAlias(alias) == false) {
3563             MessageFormat form = new MessageFormat
3564                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3565             Object[] source = {alias};
3566             throw new Exception(form.format(source));
3567         }
3568         if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class) &amp;&amp;
3569                 !keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
3570             MessageFormat form = new MessageFormat
3571                 (rb.getString(&quot;Alias.alias.has.no.key&quot;));
3572             Object[] source = {alias};
3573             throw new Exception(form.format(source));
3574         }
3575 
3576         if (keyPass == null) {
3577             // Try to recover the key using the keystore password
3578             if (storePass != null) {
3579                 try {
3580                     key = keyStore.getKey(alias, storePass);
3581                     passwords.add(storePass);
</pre>
<hr />
<pre>
4068                     } else {
4069                         throw ioe;
4070                     }
4071                 }
4072                 if (time != null) {
4073                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4074                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4075                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4076                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4077                         c.set(Calendar.MILLISECOND, 0);
4078                     } else {
4079                         throw ioe;
4080                     }
4081                 }
4082             }
4083         }
4084         return c.getTime();
4085     }
4086 
4087     /**
<span class="line-modified">4088      * Match a command (may be abbreviated) with a command set.</span>
<span class="line-modified">4089      * @param s the command provided</span>


4090      * @param list the legal command set. If there is a null, commands after it
<span class="line-modified">4091      * are regarded experimental, which means they are supported but their</span>
<span class="line-modified">4092      * existence should not be revealed to user.</span>
4093      * @return the position of a single match, or -1 if none matched
4094      * @throws Exception if s is ambiguous
4095      */
4096     private static int oneOf(String s, String... list) throws Exception {


































4097         int[] match = new int[list.length];
4098         int nmatch = 0;
4099         int experiment = Integer.MAX_VALUE;
4100         for (int i = 0; i&lt;list.length; i++) {
4101             String one = list[i];
4102             if (one == null) {
4103                 experiment = i;
4104                 continue;
4105             }
<span class="line-modified">4106             if (one.toLowerCase(Locale.ENGLISH)</span>
<span class="line-removed">4107                     .startsWith(s.toLowerCase(Locale.ENGLISH))) {</span>
4108                 match[nmatch++] = i;
<span class="line-removed">4109             } else {</span>
<span class="line-removed">4110                 StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">4111                 boolean first = true;</span>
<span class="line-removed">4112                 for (char c: one.toCharArray()) {</span>
<span class="line-removed">4113                     if (first) {</span>
<span class="line-removed">4114                         sb.append(c);</span>
<span class="line-removed">4115                         first = false;</span>
<span class="line-removed">4116                     } else {</span>
<span class="line-removed">4117                         if (!Character.isLowerCase(c)) {</span>
<span class="line-removed">4118                             sb.append(c);</span>
<span class="line-removed">4119                         }</span>
<span class="line-removed">4120                     }</span>
<span class="line-removed">4121                 }</span>
<span class="line-removed">4122                 if (sb.toString().equalsIgnoreCase(s)) {</span>
<span class="line-removed">4123                     match[nmatch++] = i;</span>
<span class="line-removed">4124                 }</span>
4125             }
4126         }
4127         if (nmatch == 0) {
4128             return -1;
4129         } else if (nmatch == 1) {
4130             return match[0];
4131         } else {
4132             // If multiple matches is in experimental commands, ignore them
4133             if (match[1] &gt; experiment) {
4134                 return match[0];
4135             }
4136             StringBuilder sb = new StringBuilder();
4137             MessageFormat form = new MessageFormat(rb.getString
<span class="line-modified">4138                 (&quot;command.{0}.is.ambiguous.&quot;));</span>
4139             Object[] source = {s};
4140             sb.append(form.format(source));
4141             sb.append(&quot;\n    &quot;);
4142             for (int i=0; i&lt;nmatch &amp;&amp; match[i]&lt;experiment; i++) {
4143                 sb.append(&#39; &#39;);
4144                 sb.append(list[match[i]]);
4145             }
4146             throw new Exception(sb.toString());
4147         }
4148     }
4149 
4150     /**
4151      * Create a GeneralName object from known types
4152      * @param t one of 5 known types
4153      * @param v value
4154      * @return which one
4155      */
4156     private GeneralName createGeneralName(String t, String v)
4157             throws Exception {
4158         GeneralNameInterface gn;
</pre>
<hr />
<pre>
4595         if (caks != null &amp;&amp; caks.getCertificateAlias(cert) != null) {
4596             return true;
4597         } else {
4598             String inKS = keyStore.getCertificateAlias(cert);
4599             return inKS != null &amp;&amp; keyStore.isCertificateEntry(inKS);
4600         }
4601     }
4602 
4603     private void checkWeak(String label, String sigAlg, Key key) {
4604 
4605         if (sigAlg != null &amp;&amp; !DISABLED_CHECK.permits(
4606                 SIG_PRIMITIVE_SET, sigAlg, null)) {
4607             weakWarnings.add(String.format(
4608                     rb.getString(&quot;whose.sigalg.risk&quot;), label, sigAlg));
4609         }
4610         if (key != null &amp;&amp; !DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
4611             weakWarnings.add(String.format(
4612                     rb.getString(&quot;whose.key.risk&quot;),
4613                     label,
4614                     String.format(rb.getString(&quot;key.bit&quot;),
<span class="line-modified">4615                             KeyUtil.getKeySize(key), key.getAlgorithm())));</span>
4616         }
4617     }
4618 
4619     private void checkWeak(String label, Certificate[] certs)
4620             throws KeyStoreException {
4621         for (int i = 0; i &lt; certs.length; i++) {
4622             Certificate cert = certs[i];
4623             if (cert instanceof X509Certificate) {
4624                 X509Certificate xc = (X509Certificate)cert;
4625                 String fullLabel = label;
4626                 if (certs.length &gt; 1) {
4627                     fullLabel = oneInMany(label, i, certs.length);
4628                 }
4629                 checkWeak(fullLabel, xc);
4630             }
4631         }
4632     }
4633 
4634     private void checkWeak(String label, Certificate cert)
4635             throws KeyStoreException {
</pre>
</td>
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.keytool;
  27 
  28 import java.io.*;
  29 import java.nio.file.Files;
  30 import java.nio.file.Path;
  31 import java.security.AlgorithmParameters;
  32 import java.security.CodeSigner;
  33 import java.security.CryptoPrimitive;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreException;
  36 import java.security.MessageDigest;
  37 import java.security.Key;
  38 import java.security.PublicKey;
  39 import java.security.PrivateKey;
<span class="line-added">  40 import java.security.SecureRandom;</span>
  41 import java.security.Signature;
  42 import java.security.Timestamp;
  43 import java.security.UnrecoverableEntryException;
  44 import java.security.UnrecoverableKeyException;
  45 import java.security.Principal;
  46 import java.security.cert.Certificate;
  47 import java.security.cert.CertificateFactory;
  48 import java.security.cert.CertStoreException;
  49 import java.security.cert.CRL;
  50 import java.security.cert.X509Certificate;
  51 import java.security.cert.CertificateException;
  52 import java.security.cert.URICertStoreParameters;
  53 
  54 
  55 import java.security.interfaces.ECKey;
  56 import java.security.spec.AlgorithmParameterSpec;
  57 import java.security.spec.ECParameterSpec;
  58 import java.text.Collator;
  59 import java.text.MessageFormat;
  60 import java.util.*;
<span class="line-added">  61 import java.util.function.BiFunction;</span>
  62 import java.util.jar.JarEntry;
  63 import java.util.jar.JarFile;
  64 import java.math.BigInteger;
  65 import java.net.URI;
  66 import java.net.URL;
  67 import java.net.URLClassLoader;
  68 import java.security.cert.CertStore;
  69 
  70 import java.security.cert.X509CRL;
  71 import java.security.cert.X509CRLEntry;
  72 import java.security.cert.X509CRLSelector;
  73 import javax.security.auth.x500.X500Principal;
  74 import java.util.Base64;
  75 
  76 import sun.security.pkcs12.PKCS12KeyStore;
  77 import sun.security.util.ECKeySizeParameterSpec;
  78 import sun.security.util.KeyUtil;
  79 import sun.security.util.NamedCurve;
  80 import sun.security.util.ObjectIdentifier;
  81 import sun.security.pkcs10.PKCS10;
  82 import sun.security.pkcs10.PKCS10Attribute;
  83 import sun.security.provider.X509Factory;
  84 import sun.security.provider.certpath.ssl.SSLServerCertStore;
  85 import sun.security.util.Password;
  86 import sun.security.util.SecurityProperties;
  87 import sun.security.util.SecurityProviderConstants;
<span class="line-added">  88 import sun.security.util.SignatureUtil;</span>
  89 import javax.crypto.KeyGenerator;
  90 import javax.crypto.SecretKey;
  91 import javax.crypto.SecretKeyFactory;
  92 import javax.crypto.spec.PBEKeySpec;
  93 
  94 import sun.security.pkcs.PKCS9Attribute;
  95 import sun.security.tools.KeyStoreUtil;
  96 import sun.security.tools.PathList;
  97 import sun.security.util.DerValue;
  98 import sun.security.util.Pem;
  99 import sun.security.x509.*;
 100 
 101 import static java.security.KeyStore.*;
 102 import java.security.Security;
 103 import static sun.security.tools.keytool.Main.Command.*;
 104 import static sun.security.tools.keytool.Main.Option.*;
 105 import sun.security.util.DisabledAlgorithmConstraints;
 106 
 107 /**
 108  * This tool manages keystores.
</pre>
<hr />
<pre>
 160     private File ksfile = null;
 161     private InputStream ksStream = null; // keystore stream
 162     private String sslserver = null;
 163     private String jarfile = null;
 164     private KeyStore keyStore = null;
 165     private boolean token = false;
 166     private boolean nullStream = false;
 167     private boolean kssave = false;
 168     private boolean noprompt = false;
 169     private boolean trustcacerts = false;
 170     private boolean protectedPath = false;
 171     private boolean srcprotectedPath = false;
 172     private boolean cacerts = false;
 173     private boolean nowarn = false;
 174     private KeyStore caks = null; // &quot;cacerts&quot; keystore
 175     private char[] srcstorePass = null;
 176     private String srcstoretype = null;
 177     private Set&lt;char[]&gt; passwords = new HashSet&lt;&gt;();
 178     private String startDate = null;
 179 
<span class="line-added"> 180     private boolean tlsInfo = false;</span>
<span class="line-added"> 181 </span>
 182     private List&lt;String&gt; ids = new ArrayList&lt;&gt;();   // used in GENCRL
 183     private List&lt;String&gt; v3ext = new ArrayList&lt;&gt;();
 184 
 185     // In-place importkeystore is special.
 186     // A backup is needed, and no need to prompt for deststorepass.
 187     private boolean inplaceImport = false;
 188     private String inplaceBackupName = null;
 189 
 190     // Warnings on weak algorithms etc
 191     private List&lt;String&gt; weakWarnings = new ArrayList&lt;&gt;();
 192 
 193     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 194             new DisabledAlgorithmConstraints(
 195                     DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);
 196 
 197     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 198             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 199     private boolean isPasswordlessKeyStore = false;
 200 
 201     enum Command {
</pre>
<hr />
<pre>
 247             V),
 248         KEYPASSWD(&quot;Changes.the.key.password.of.an.entry&quot;,
 249             ALIAS, KEYPASS, NEW, KEYSTORE, STOREPASS,
 250             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 251             PROVIDERPATH, V),
 252         LIST(&quot;Lists.entries.in.a.keystore&quot;,
 253             RFC, ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 254             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 255             PROVIDERPATH, V, PROTECTED),
 256         PRINTCERT(&quot;Prints.the.content.of.a.certificate&quot;,
 257             RFC, FILEIN, SSLSERVER, JARFILE,
 258             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 259             PROVIDERPATH, V),
 260         PRINTCERTREQ(&quot;Prints.the.content.of.a.certificate.request&quot;,
 261             FILEIN, V),
 262         PRINTCRL(&quot;Prints.the.content.of.a.CRL.file&quot;,
 263             FILEIN, V),
 264         STOREPASSWD(&quot;Changes.the.store.password.of.a.keystore&quot;,
 265             NEW, KEYSTORE, CACERTS, STOREPASS, STORETYPE, PROVIDERNAME,
 266             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
<span class="line-added"> 267         SHOWINFO(&quot;showinfo.command.help&quot;,</span>
<span class="line-added"> 268             TLS, V),</span>
 269 
 270         // Undocumented start here, KEYCLONE is used a marker in -help;
 271 
 272         KEYCLONE(&quot;Clones.a.key.entry&quot;,
 273             ALIAS, DESTALIAS, KEYPASS, NEW, STORETYPE,
 274             KEYSTORE, STOREPASS, PROVIDERNAME, ADDPROVIDER,
 275             PROVIDERCLASS, PROVIDERPATH, V),
 276         SELFCERT(&quot;Generates.a.self.signed.certificate&quot;,
 277             ALIAS, SIGALG, DNAME, STARTDATE, EXT, VALIDITY, KEYPASS,
 278             STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 279             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 280         GENCRL(&quot;Generates.CRL&quot;,
 281             RFC, FILEOUT, ID,
 282             ALIAS, SIGALG, KEYPASS, KEYSTORE,
 283             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 284             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 285         IDENTITYDB(&quot;Imports.entries.from.a.JDK.1.1.x.style.identity.database&quot;,
 286             FILEIN, STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 287             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V);
 288 
</pre>
<hr />
<pre>
 354         OUTFILE(&quot;outfile&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 355         PROTECTED(&quot;protected&quot;, null, &quot;password.through.protected.mechanism&quot;),
 356         PROVIDERCLASS(&quot;providerclass&quot;, &quot;&lt;class&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;provider.class.option&quot;),
 357         ADDPROVIDER(&quot;addprovider&quot;, &quot;&lt;name&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;addprovider.option&quot;),
 358         PROVIDERNAME(&quot;providername&quot;, &quot;&lt;name&gt;&quot;, &quot;provider.name&quot;),
 359         PROVIDERPATH(&quot;providerpath&quot;, &quot;&lt;list&gt;&quot;, &quot;provider.classpath&quot;),
 360         RFC(&quot;rfc&quot;, null, &quot;output.in.RFC.style&quot;),
 361         SIGALG(&quot;sigalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;signature.algorithm.name&quot;),
 362         SRCALIAS(&quot;srcalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;source.alias&quot;),
 363         SRCKEYPASS(&quot;srckeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.key.password&quot;),
 364         SRCKEYSTORE(&quot;srckeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;source.keystore.name&quot;),
 365         SRCPROTECTED(&quot;srcprotected&quot;, null, &quot;source.keystore.password.protected&quot;),
 366         SRCPROVIDERNAME(&quot;srcprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;source.keystore.provider.name&quot;),
 367         SRCSTOREPASS(&quot;srcstorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.keystore.password&quot;),
 368         SRCSTORETYPE(&quot;srcstoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;source.keystore.type&quot;),
 369         SSLSERVER(&quot;sslserver&quot;, &quot;&lt;server[:port]&gt;&quot;, &quot;SSL.server.host.and.port&quot;),
 370         JARFILE(&quot;jarfile&quot;, &quot;&lt;file&gt;&quot;, &quot;signed.jar.file&quot;),
 371         STARTDATE(&quot;startdate&quot;, &quot;&lt;date&gt;&quot;, &quot;certificate.validity.start.date.time&quot;),
 372         STOREPASS(&quot;storepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;keystore.password&quot;),
 373         STORETYPE(&quot;storetype&quot;, &quot;&lt;type&gt;&quot;, &quot;keystore.type&quot;),
<span class="line-added"> 374         TLS(&quot;tls&quot;, null, &quot;tls.option.help&quot;),</span>
 375         TRUSTCACERTS(&quot;trustcacerts&quot;, null, &quot;trust.certificates.from.cacerts&quot;),
 376         V(&quot;v&quot;, null, &quot;verbose.output&quot;),
 377         VALIDITY(&quot;validity&quot;, &quot;&lt;days&gt;&quot;, &quot;validity.number.of.days&quot;);
 378 
 379         final String name, arg, description;
 380         Option(String name, String arg, String description) {
 381             this.name = name;
 382             this.arg = arg;
 383             this.description = description;
 384         }
 385         @Override
 386         public String toString() {
 387             return &quot;-&quot; + name;
 388         }
 389     };
 390 
 391     private static final String NONE = &quot;NONE&quot;;
 392     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 393     private static final String P12KEYSTORE = &quot;PKCS12&quot;;
 394     private static final String keyAlias = &quot;mykey&quot;;
</pre>
<hr />
<pre>
 668             }
 669 
 670             /*
 671              * options
 672              */
 673             else if (collator.compare(flags, &quot;-v&quot;) == 0) {
 674                 verbose = true;
 675             } else if (collator.compare(flags, &quot;-debug&quot;) == 0) {
 676                 // Already processed
 677             } else if (collator.compare(flags, &quot;-rfc&quot;) == 0) {
 678                 rfc = true;
 679             } else if (collator.compare(flags, &quot;-noprompt&quot;) == 0) {
 680                 noprompt = true;
 681             } else if (collator.compare(flags, &quot;-trustcacerts&quot;) == 0) {
 682                 trustcacerts = true;
 683             } else if (collator.compare(flags, &quot;-protected&quot;) == 0 ||
 684                     collator.compare(flags, &quot;-destprotected&quot;) == 0) {
 685                 protectedPath = true;
 686             } else if (collator.compare(flags, &quot;-srcprotected&quot;) == 0) {
 687                 srcprotectedPath = true;
<span class="line-added"> 688             } else if (collator.compare(flags, &quot;-tls&quot;) == 0) {</span>
<span class="line-added"> 689                 tlsInfo = true;</span>
 690             } else  {
 691                 System.err.println(rb.getString(&quot;Illegal.option.&quot;) + flags);
 692                 tinyHelp();
 693             }
 694         }
 695 
 696         if (i&lt;args.length) {
 697             System.err.println(rb.getString(&quot;Illegal.option.&quot;) + args[i]);
 698             tinyHelp();
 699         }
 700 
 701         if (command == null) {
 702             if (help) {
 703                 usage();
 704             } else {
 705                 System.err.println(rb.getString(&quot;Usage.error.no.command.provided&quot;));
 706                 tinyHelp();
 707             }
 708         } else if (help) {
 709             usage();
 710             command = null;
 711         }
 712 
 713         return args;
 714     }
 715 
 716     boolean isKeyStoreRelated(Command cmd) {
<span class="line-modified"> 717         return cmd != PRINTCERT &amp;&amp; cmd != PRINTCERTREQ &amp;&amp; cmd != SHOWINFO;</span>
 718     }
 719 
 720     /**
 721      * Execute the commands.
 722      */
 723     void doCommands(PrintStream out) throws Exception {
 724 
 725         if (cacerts) {
 726             if (ksfname != null || storetype != null) {
 727                 throw new IllegalArgumentException(rb.getString
 728                         (&quot;the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option&quot;));
 729             }
 730             ksfname = KeyStoreUtil.getCacerts();
 731         }
 732 
 733         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 734                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 735             token = true;
 736             if (ksfname == null) {
 737                 ksfname = NONE;
</pre>
<hr />
<pre>
 866             ksfname = System.getProperty(&quot;user.home&quot;) + File.separator
 867                     + &quot;.keystore&quot;;
 868         }
 869 
 870         KeyStore srcKeyStore = null;
 871         if (command == IMPORTKEYSTORE) {
 872             inplaceImport = inplaceImportCheck();
 873             if (inplaceImport) {
 874                 // We load srckeystore first so we have srcstorePass that
 875                 // can be assigned to storePass
 876                 srcKeyStore = loadSourceKeyStore();
 877                 if (storePass == null) {
 878                     storePass = srcstorePass;
 879                 }
 880             }
 881         }
 882 
 883         // Check if keystore exists.
 884         // If no keystore has been specified at the command line, try to use
 885         // the default, which is located in $HOME/.keystore.
<span class="line-modified"> 886         // No need to check if isKeyStoreRelated(command) is false.</span>

 887 
 888         // DO NOT open the existing keystore if this is an in-place import.
 889         // The keystore should be created as brand new.
 890         if (isKeyStoreRelated(command) &amp;&amp; !nullStream &amp;&amp; !inplaceImport) {
 891             try {
 892                 ksfile = new File(ksfname);
 893                 // Check if keystore file is empty
 894                 if (ksfile.exists() &amp;&amp; ksfile.length() == 0) {
 895                     throw new Exception(rb.getString
 896                             (&quot;Keystore.file.exists.but.is.empty.&quot;) + ksfname);
 897                 }
 898                 ksStream = new FileInputStream(ksfile);
 899             } catch (FileNotFoundException e) {
<span class="line-added"> 900                 // These commands do not need the keystore to be existing.</span>
<span class="line-added"> 901                 // Either it will create a new one or the keystore is</span>
<span class="line-added"> 902                 // optional (i.e. PRINTCRL).</span>
 903                 if (command != GENKEYPAIR &amp;&amp;
 904                         command != GENSECKEY &amp;&amp;
 905                         command != IDENTITYDB &amp;&amp;
 906                         command != IMPORTCERT &amp;&amp;
 907                         command != IMPORTPASS &amp;&amp;
 908                         command != IMPORTKEYSTORE &amp;&amp;
 909                         command != PRINTCRL) {
 910                     throw new Exception(rb.getString
 911                             (&quot;Keystore.file.does.not.exist.&quot;) + ksfname);
 912                 }
 913             }
 914         }
 915 
 916         if ((command == KEYCLONE || command == CHANGEALIAS)
 917                 &amp;&amp; dest == null) {
 918             dest = getAlias(&quot;destination&quot;);
 919             if (&quot;&quot;.equals(dest)) {
 920                 throw new Exception(rb.getString
 921                         (&quot;Must.specify.destination.alias&quot;));
 922             }
</pre>
<hr />
<pre>
1134         } else if (command == DELETE) {
1135             doDeleteEntry(alias);
1136             kssave = true;
1137         } else if (command == EXPORTCERT) {
1138             if (filename != null) {
1139                 try (PrintStream ps = new PrintStream(new FileOutputStream
1140                                                    (filename))) {
1141                     doExportCert(alias, ps);
1142                 }
1143             } else {
1144                 doExportCert(alias, out);
1145             }
1146             if (filename != null) {
1147                 MessageFormat form = new MessageFormat(rb.getString
1148                         (&quot;Certificate.stored.in.file.filename.&quot;));
1149                 Object[] source = {filename};
1150                 System.err.println(form.format(source));
1151             }
1152         } else if (command == GENKEYPAIR) {
1153             if (keyAlgName == null) {
<span class="line-modified">1154                 throw new Exception(rb.getString(</span>
<span class="line-modified">1155                         &quot;keyalg.option.missing.error&quot;));</span>

1156             }
1157             doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName);
1158             kssave = true;
1159         } else if (command == GENSECKEY) {
1160             if (keyAlgName == null) {
<span class="line-modified">1161                 throw new Exception(rb.getString(</span>
<span class="line-modified">1162                         &quot;keyalg.option.missing.error&quot;));</span>

1163             }
1164             doGenSecretKey(alias, keyAlgName, keysize);
1165             kssave = true;
1166         } else if (command == IMPORTPASS) {
1167             if (keyAlgName == null) {
1168                 keyAlgName = &quot;PBE&quot;;
1169             }
1170             // password is stored as a secret key
1171             doGenSecretKey(alias, keyAlgName, keysize);
1172             kssave = true;
1173         } else if (command == IDENTITYDB) {
1174             if (filename != null) {
1175                 try (InputStream inStream = new FileInputStream(filename)) {
1176                     doImportIdentityDatabase(inStream);
1177                 }
1178             } else {
1179                 doImportIdentityDatabase(System.in);
1180             }
1181         } else if (command == IMPORTCERT) {
1182             InputStream inStream = System.in;
</pre>
<hr />
<pre>
1303                 alias = keyAlias;
1304             }
1305             if (filename != null) {
1306                 try (PrintStream ps =
1307                          new PrintStream(new FileOutputStream(filename))) {
1308                     doGenCRL(ps);
1309                 }
1310             } else {
1311                 doGenCRL(out);
1312             }
1313         } else if (command == PRINTCERTREQ) {
1314             if (filename != null) {
1315                 try (InputStream inStream = new FileInputStream(filename)) {
1316                     doPrintCertReq(inStream, out);
1317                 }
1318             } else {
1319                 doPrintCertReq(System.in, out);
1320             }
1321         } else if (command == PRINTCRL) {
1322             doPrintCRL(filename, out);
<span class="line-added">1323         } else if (command == SHOWINFO) {</span>
<span class="line-added">1324             doShowInfo();</span>
1325         }
1326 
1327         // If we need to save the keystore, do so.
1328         if (kssave) {
1329             if (verbose) {
1330                 MessageFormat form = new MessageFormat
1331                         (rb.getString(&quot;.Storing.ksfname.&quot;));
1332                 Object[] source = {nullStream ? &quot;keystore&quot; : ksfname};
1333                 System.err.println(form.format(source));
1334             }
1335 
1336             if (token) {
1337                 keyStore.store(null, null);
1338             } else {
1339                 char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1340                 if (nullStream) {
1341                     keyStore.store(null, pass);
1342                 } else {
1343                     ByteArrayOutputStream bout = new ByteArrayOutputStream();
1344                     keyStore.store(bout, pass);
</pre>
<hr />
<pre>
1424         Certificate signerCert = keyStore.getCertificate(alias);
1425         byte[] encoded = signerCert.getEncoded();
1426         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1427         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1428                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1429         X500Name issuer = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1430                                            X509CertInfo.DN_NAME);
1431 
1432         Date firstDate = getStartDate(startDate);
1433         Date lastDate = new Date();
1434         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
1435         CertificateValidity interval = new CertificateValidity(firstDate,
1436                                                                lastDate);
1437 
1438         PrivateKey privateKey =
1439                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1440         if (sigAlgName == null) {
1441             sigAlgName = getCompatibleSigAlgName(privateKey);
1442         }
1443         Signature signature = Signature.getInstance(sigAlgName);



1444         AlgorithmParameterSpec params = AlgorithmId
1445                 .getDefaultAlgorithmParameterSpec(sigAlgName, privateKey);
<span class="line-added">1446 </span>
<span class="line-added">1447         SignatureUtil.initSignWithParam(signature, privateKey, params, null);</span>
<span class="line-added">1448 </span>
<span class="line-added">1449         X509CertInfo info = new X509CertInfo();</span>
1450         AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlgName, params);
1451         info.set(X509CertInfo.VALIDITY, interval);
<span class="line-modified">1452         info.set(X509CertInfo.SERIAL_NUMBER,</span>
<span class="line-modified">1453                 CertificateSerialNumber.newRandom64bit(new SecureRandom()));</span>
1454         info.set(X509CertInfo.VERSION,
1455                     new CertificateVersion(CertificateVersion.V3));
1456         info.set(X509CertInfo.ALGORITHM_ID,
1457                     new CertificateAlgorithmId(algID));
1458         info.set(X509CertInfo.ISSUER, issuer);
1459 
1460         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1461         boolean canRead = false;
1462         StringBuffer sb = new StringBuffer();
1463         while (true) {
1464             String s = reader.readLine();
1465             if (s == null) break;
1466             // OpenSSL does not use NEW
1467             //if (s.startsWith(&quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;)) {
1468             if (s.startsWith(&quot;-----BEGIN&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1469                 canRead = true;
1470             //} else if (s.startsWith(&quot;-----END NEW CERTIFICATE REQUEST-----&quot;)) {
1471             } else if (s.startsWith(&quot;-----END&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1472                 break;
1473             } else if (canRead) {
</pre>
<hr />
<pre>
1583 
1584         Certificate cert = keyStore.getCertificate(alias);
1585         if (cert == null) {
1586             MessageFormat form = new MessageFormat
1587                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
1588             Object[] source = {alias};
1589             throw new Exception(form.format(source));
1590         }
1591         PKCS10 request = new PKCS10(cert.getPublicKey());
1592         CertificateExtensions ext = createV3Extensions(null, null, v3ext, cert.getPublicKey(), null);
1593         // Attribute name is not significant
1594         request.getAttributes().setAttribute(X509CertInfo.EXTENSIONS,
1595                 new PKCS10Attribute(PKCS9Attribute.EXTENSION_REQUEST_OID, ext));
1596 
1597         // Construct a Signature object, so that we can sign the request
1598         if (sigAlgName == null) {
1599             sigAlgName = getCompatibleSigAlgName(privKey);
1600         }
1601 
1602         Signature signature = Signature.getInstance(sigAlgName);

1603         AlgorithmParameterSpec params = AlgorithmId
1604                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
<span class="line-modified">1605         SignatureUtil.initSignWithParam(signature, privKey, params, null);</span>


1606 
1607         X500Name subject = dname == null?
1608                 new X500Name(((X509Certificate)cert).getSubjectDN().toString()):
1609                 new X500Name(dname);
1610 
1611         // Sign the request and base-64 encode it
1612         request.encodeAndSign(subject, signature);
1613         request.print(out);
1614 
1615         checkWeak(rb.getString(&quot;the.generated.certificate.request&quot;), request);
1616     }
1617 
1618     /**
1619      * Deletes an entry from the keystore.
1620      */
1621     private void doDeleteEntry(String alias) throws Exception {
1622         if (keyStore.containsAlias(alias) == false) {
1623             MessageFormat form = new MessageFormat
1624                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1625             Object[] source = {alias};
</pre>
<hr />
<pre>
2400      * Prints all keystore entries.
2401      */
2402     private void doPrintEntries(PrintStream out)
2403         throws Exception
2404     {
2405         out.println(rb.getString(&quot;Keystore.type.&quot;) + keyStore.getType());
2406         out.println(rb.getString(&quot;Keystore.provider.&quot;) +
2407                 keyStore.getProvider().getName());
2408         out.println();
2409 
2410         MessageFormat form;
2411         form = (keyStore.size() == 1) ?
2412                 new MessageFormat(rb.getString
2413                         (&quot;Your.keystore.contains.keyStore.size.entry&quot;)) :
2414                 new MessageFormat(rb.getString
2415                         (&quot;Your.keystore.contains.keyStore.size.entries&quot;));
2416         Object[] source = {keyStore.size()};
2417         out.println(form.format(source));
2418         out.println();
2419 
<span class="line-modified">2420         List&lt;String&gt; aliases = Collections.list(keyStore.aliases());</span>
<span class="line-modified">2421         aliases.sort(String::compareTo);</span>
<span class="line-modified">2422         for (String alias : aliases) {</span>
2423             doPrintEntry(&quot;&lt;&quot; + alias + &quot;&gt;&quot;, alias, out);
2424             if (verbose || rfc) {
2425                 out.println(rb.getString(&quot;NEWLINE&quot;));
2426                 out.println(rb.getString
2427                         (&quot;STAR&quot;));
2428                 out.println(rb.getString
2429                         (&quot;STARNN&quot;));
2430             }
2431         }
2432     }
2433 
2434     private static &lt;T&gt; Iterable&lt;T&gt; e2i(final Enumeration&lt;T&gt; e) {
2435         return new Iterable&lt;T&gt;() {
2436             @Override
2437             public Iterator&lt;T&gt; iterator() {
2438                 return new Iterator&lt;T&gt;() {
2439                     @Override
2440                     public boolean hasNext() {
2441                         return e.hasMoreElements();
2442                     }
</pre>
<hr />
<pre>
2699             } catch (ClassCastException cce) {
2700                 throw new Exception(rb.getString(&quot;Not.X.509.certificate&quot;));
2701             }
2702             if (certs.length &gt; 1) {
2703                 MessageFormat form = new MessageFormat
2704                         (rb.getString(&quot;Certificate.i.1.&quot;));
2705                 Object[] source = {i + 1};
2706                 out.println(form.format(source));
2707             }
2708             if (rfc)
2709                 dumpCert(x509Cert, out);
2710             else
2711                 printX509Cert(x509Cert, out);
2712             if (i &lt; (certs.length-1)) {
2713                 out.println();
2714             }
2715             checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i, certs.length), x509Cert);
2716         }
2717     }
2718 
<span class="line-added">2719     private void doShowInfo() throws Exception {</span>
<span class="line-added">2720         if (tlsInfo) {</span>
<span class="line-added">2721             ShowInfo.tls(verbose);</span>
<span class="line-added">2722         } else {</span>
<span class="line-added">2723             System.out.println(rb.getString(&quot;showinfo.no.option&quot;));</span>
<span class="line-added">2724         }</span>
<span class="line-added">2725     }</span>
<span class="line-added">2726 </span>
2727     private Collection&lt;? extends Certificate&gt; generateCertificates(InputStream in)
2728             throws CertificateException, IOException {
2729         byte[] data = in.readAllBytes();
2730         try {
2731             return CertificateFactory.getInstance(&quot;X.509&quot;)
2732                     .generateCertificates(new ByteArrayInputStream(data));
2733         } catch (CertificateException e) {
2734             if (providerName != null) {
2735                 try {
2736                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2737                             .generateCertificates(new ByteArrayInputStream(data));
2738                 } catch (Exception e2) {
2739                     e.addSuppressed(e2);
2740                 }
2741             }
2742             throw e;
2743         }
2744     }
2745 
2746     private Certificate generateCertificate(InputStream in)
</pre>
<hr />
<pre>
2948             throw new Exception(form.format(source));
2949         }
2950 
2951         // convert to X509CertImpl, so that we can modify selected fields
2952         // (no public APIs available yet)
2953         byte[] encoded = oldCert.getEncoded();
2954         X509CertImpl certImpl = new X509CertImpl(encoded);
2955         X509CertInfo certInfo = (X509CertInfo)certImpl.get(X509CertImpl.NAME
2956                                                            + &quot;.&quot; +
2957                                                            X509CertImpl.INFO);
2958 
2959         // Extend its validity
2960         Date firstDate = getStartDate(startDate);
2961         Date lastDate = new Date();
2962         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
2963         CertificateValidity interval = new CertificateValidity(firstDate,
2964                                                                lastDate);
2965         certInfo.set(X509CertInfo.VALIDITY, interval);
2966 
2967         // Make new serial number
<span class="line-modified">2968         certInfo.set(X509CertInfo.SERIAL_NUMBER,</span>
<span class="line-modified">2969                 CertificateSerialNumber.newRandom64bit(new SecureRandom()));</span>
2970 
2971         // Set owner and issuer fields
2972         X500Name owner;
2973         if (dname == null) {
2974             // Get the owner name from the certificate
2975             owner = (X500Name)certInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
2976                                            X509CertInfo.DN_NAME);
2977         } else {
2978             // Use the owner name specified at the command line
2979             owner = new X500Name(dname);
2980             certInfo.set(X509CertInfo.SUBJECT + &quot;.&quot; +
2981                          X509CertInfo.DN_NAME, owner);
2982         }
2983         // Make issuer same as owner (self-signed!)
2984         certInfo.set(X509CertInfo.ISSUER + &quot;.&quot; +
2985                      X509CertInfo.DN_NAME, owner);
2986 
2987         // The inner and outer signature algorithms have to match.
2988         // The way we achieve that is really ugly, but there seems to be no
2989         // other solution: We first sign the cert, then retrieve the
</pre>
<hr />
<pre>
3560              if (i &lt; len-1) {
3561                  buf.append(&quot;:&quot;);
3562              }
3563         }
3564         return buf.toString();
3565     }
3566 
3567     /**
3568      * Recovers (private) key associated with given alias.
3569      *
3570      * @return an array of objects, where the 1st element in the array is the
3571      * recovered private key, and the 2nd element is the password used to
3572      * recover it.
3573      */
3574     private Pair&lt;Key,char[]&gt; recoverKey(String alias, char[] storePass,
3575                                        char[] keyPass)
3576         throws Exception
3577     {
3578         Key key = null;
3579 
<span class="line-added">3580         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {</span>
<span class="line-added">3581             key = keyStore.getKey(alias, null);</span>
<span class="line-added">3582             return Pair.of(key, null);</span>
<span class="line-added">3583         }</span>
<span class="line-added">3584 </span>
3585         if (keyStore.containsAlias(alias) == false) {
3586             MessageFormat form = new MessageFormat
3587                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3588             Object[] source = {alias};
3589             throw new Exception(form.format(source));
3590         }
3591         if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class) &amp;&amp;
3592                 !keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
3593             MessageFormat form = new MessageFormat
3594                 (rb.getString(&quot;Alias.alias.has.no.key&quot;));
3595             Object[] source = {alias};
3596             throw new Exception(form.format(source));
3597         }
3598 
3599         if (keyPass == null) {
3600             // Try to recover the key using the keystore password
3601             if (storePass != null) {
3602                 try {
3603                     key = keyStore.getKey(alias, storePass);
3604                     passwords.add(storePass);
</pre>
<hr />
<pre>
4091                     } else {
4092                         throw ioe;
4093                     }
4094                 }
4095                 if (time != null) {
4096                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4097                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4098                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4099                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4100                         c.set(Calendar.MILLISECOND, 0);
4101                     } else {
4102                         throw ioe;
4103                     }
4104                 }
4105             }
4106         }
4107         return c.getTime();
4108     }
4109 
4110     /**
<span class="line-modified">4111      * Match a command with a command set. The match can be exact, or</span>
<span class="line-modified">4112      * partial, or case-insensitive.</span>
<span class="line-added">4113      *</span>
<span class="line-added">4114      * @param s the command provided by user</span>
4115      * @param list the legal command set. If there is a null, commands after it
<span class="line-modified">4116      *      are regarded experimental, which means they are supported but their</span>
<span class="line-modified">4117      *      existence should not be revealed to user.</span>
4118      * @return the position of a single match, or -1 if none matched
4119      * @throws Exception if s is ambiguous
4120      */
4121     private static int oneOf(String s, String... list) throws Exception {
<span class="line-added">4122 </span>
<span class="line-added">4123         // First, if there is an exact match, returns it.</span>
<span class="line-added">4124         int res = oneOfMatch((a,b) -&gt; a.equals(b), s, list);</span>
<span class="line-added">4125         if (res &gt;= 0) {</span>
<span class="line-added">4126             return res;</span>
<span class="line-added">4127         }</span>
<span class="line-added">4128 </span>
<span class="line-added">4129         // Second, if there is one single camelCase or prefix match, returns it.</span>
<span class="line-added">4130         // This regex substitution removes all lowercase letters not at the</span>
<span class="line-added">4131         // beginning, so &quot;keyCertSign&quot; becomes &quot;kCS&quot;.</span>
<span class="line-added">4132         res = oneOfMatch((a,b) -&gt; a.equals(b.replaceAll(&quot;(?&lt;!^)[a-z]&quot;, &quot;&quot;))</span>
<span class="line-added">4133                 || b.startsWith(a), s, list);</span>
<span class="line-added">4134         if (res &gt;= 0) {</span>
<span class="line-added">4135             return res;</span>
<span class="line-added">4136         }</span>
<span class="line-added">4137 </span>
<span class="line-added">4138         // Finally, retry the 2nd step ignoring case</span>
<span class="line-added">4139         return oneOfMatch((a,b) -&gt; a.equalsIgnoreCase(b.replaceAll(&quot;(?&lt;!^)[a-z]&quot;, &quot;&quot;))</span>
<span class="line-added">4140                 || b.toUpperCase(Locale.ROOT).startsWith(a.toUpperCase(Locale.ROOT)),</span>
<span class="line-added">4141                 s, list);</span>
<span class="line-added">4142     }</span>
<span class="line-added">4143 </span>
<span class="line-added">4144     /**</span>
<span class="line-added">4145      * Match a command with a command set.</span>
<span class="line-added">4146      *</span>
<span class="line-added">4147      * @param matcher a BiFunction which returns {@code true} if the 1st</span>
<span class="line-added">4148      *               argument (user input) matches the 2nd one (full command)</span>
<span class="line-added">4149      * @param s the command provided by user</span>
<span class="line-added">4150      * @param list the legal command set</span>
<span class="line-added">4151      * @return the position of a single match, or -1 if none matched</span>
<span class="line-added">4152      * @throws Exception if s is ambiguous</span>
<span class="line-added">4153      */</span>
<span class="line-added">4154     private static int oneOfMatch(BiFunction&lt;String,String,Boolean&gt; matcher,</span>
<span class="line-added">4155             String s, String... list) throws Exception {</span>
4156         int[] match = new int[list.length];
4157         int nmatch = 0;
4158         int experiment = Integer.MAX_VALUE;
4159         for (int i = 0; i&lt;list.length; i++) {
4160             String one = list[i];
4161             if (one == null) {
4162                 experiment = i;
4163                 continue;
4164             }
<span class="line-modified">4165             if (matcher.apply(s, one)) {</span>

4166                 match[nmatch++] = i;
















4167             }
4168         }
4169         if (nmatch == 0) {
4170             return -1;
4171         } else if (nmatch == 1) {
4172             return match[0];
4173         } else {
4174             // If multiple matches is in experimental commands, ignore them
4175             if (match[1] &gt; experiment) {
4176                 return match[0];
4177             }
4178             StringBuilder sb = new StringBuilder();
4179             MessageFormat form = new MessageFormat(rb.getString
<span class="line-modified">4180                     (&quot;command.{0}.is.ambiguous.&quot;));</span>
4181             Object[] source = {s};
4182             sb.append(form.format(source));
4183             sb.append(&quot;\n    &quot;);
4184             for (int i=0; i&lt;nmatch &amp;&amp; match[i]&lt;experiment; i++) {
4185                 sb.append(&#39; &#39;);
4186                 sb.append(list[match[i]]);
4187             }
4188             throw new Exception(sb.toString());
4189         }
4190     }
4191 
4192     /**
4193      * Create a GeneralName object from known types
4194      * @param t one of 5 known types
4195      * @param v value
4196      * @return which one
4197      */
4198     private GeneralName createGeneralName(String t, String v)
4199             throws Exception {
4200         GeneralNameInterface gn;
</pre>
<hr />
<pre>
4637         if (caks != null &amp;&amp; caks.getCertificateAlias(cert) != null) {
4638             return true;
4639         } else {
4640             String inKS = keyStore.getCertificateAlias(cert);
4641             return inKS != null &amp;&amp; keyStore.isCertificateEntry(inKS);
4642         }
4643     }
4644 
4645     private void checkWeak(String label, String sigAlg, Key key) {
4646 
4647         if (sigAlg != null &amp;&amp; !DISABLED_CHECK.permits(
4648                 SIG_PRIMITIVE_SET, sigAlg, null)) {
4649             weakWarnings.add(String.format(
4650                     rb.getString(&quot;whose.sigalg.risk&quot;), label, sigAlg));
4651         }
4652         if (key != null &amp;&amp; !DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
4653             weakWarnings.add(String.format(
4654                     rb.getString(&quot;whose.key.risk&quot;),
4655                     label,
4656                     String.format(rb.getString(&quot;key.bit&quot;),
<span class="line-modified">4657                             KeyUtil.getKeySize(key), fullDisplayAlgName(key))));</span>
4658         }
4659     }
4660 
4661     private void checkWeak(String label, Certificate[] certs)
4662             throws KeyStoreException {
4663         for (int i = 0; i &lt; certs.length; i++) {
4664             Certificate cert = certs[i];
4665             if (cert instanceof X509Certificate) {
4666                 X509Certificate xc = (X509Certificate)cert;
4667                 String fullLabel = label;
4668                 if (certs.length &gt; 1) {
4669                     fullLabel = oneInMany(label, i, certs.length);
4670                 }
4671                 checkWeak(fullLabel, xc);
4672             }
4673         }
4674     }
4675 
4676     private void checkWeak(String label, Certificate cert)
4677             throws KeyStoreException {
</pre>
</td>
</tr>
</table>
<center><a href="CertAndKeyGen.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Resources.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
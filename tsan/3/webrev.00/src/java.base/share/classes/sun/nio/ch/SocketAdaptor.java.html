<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/nio/ch/SocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.net.Socket;
 34 import java.net.SocketAddress;
 35 import java.net.SocketException;
 36 import java.net.SocketOption;
 37 import java.net.StandardSocketOptions;
 38 import java.nio.channels.SocketChannel;
 39 import java.security.AccessController;
 40 import java.security.PrivilegedActionException;
 41 import java.security.PrivilegedExceptionAction;
 42 import java.util.Set;
 43 
 44 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 45 
 46 // Make a socket channel look like a socket.
 47 //
 48 // The methods in this class are defined in exactly the same order as in
 49 // java.net.Socket so as to simplify tracking future changes to that class.
 50 //
 51 
 52 class SocketAdaptor
 53     extends Socket
 54 {
 55     // The channel being adapted
 56     private final SocketChannelImpl sc;
 57 
 58     // Timeout &quot;option&quot; value for reads
 59     private volatile int timeout;
 60 
 61     private SocketAdaptor(SocketChannelImpl sc) throws SocketException {
 62         super(DummySocketImpl.create());
 63         this.sc = sc;
 64     }
 65 
 66     static Socket create(SocketChannelImpl sc) {
 67         PrivilegedExceptionAction&lt;Socket&gt; pa = () -&gt; new SocketAdaptor(sc);
 68         try {
 69             return AccessController.doPrivileged(pa);
 70         } catch (PrivilegedActionException pae) {
 71             throw new InternalError(&quot;Should not reach here&quot;, pae);
 72         }
 73     }
 74 
 75     @Override
 76     public void connect(SocketAddress remote) throws IOException {
 77         connect(remote, 0);
 78     }
 79 
 80     @Override
 81     public void connect(SocketAddress remote, int timeout) throws IOException {
 82         if (remote == null)
 83             throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
 84         if (timeout &lt; 0)
 85             throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
 86         try {
 87             if (timeout &gt; 0) {
 88                 long nanos = MILLISECONDS.toNanos(timeout);
 89                 sc.blockingConnect(remote, nanos);
 90             } else {
 91                 sc.blockingConnect(remote, Long.MAX_VALUE);
 92             }
 93         } catch (Exception e) {
 94             Net.translateException(e, true);
 95         }
 96     }
 97 
 98     @Override
 99     public void bind(SocketAddress local) throws IOException {
100         try {
101             sc.bind(local);
102         } catch (Exception x) {
103             Net.translateException(x);
104         }
105     }
106 
107     @Override
108     public InetAddress getInetAddress() {
109         InetSocketAddress remote = sc.remoteAddress();
110         if (remote == null) {
111             return null;
112         } else {
113             return remote.getAddress();
114         }
115     }
116 
117     @Override
118     public InetAddress getLocalAddress() {
119         if (sc.isOpen()) {
120             InetSocketAddress local = sc.localAddress();
121             if (local != null) {
122                 return Net.getRevealedLocalAddress(local).getAddress();
123             }
124         }
125         return new InetSocketAddress(0).getAddress();
126     }
127 
128     @Override
129     public int getPort() {
130         InetSocketAddress remote = sc.remoteAddress();
131         if (remote == null) {
132             return 0;
133         } else {
134             return remote.getPort();
135         }
136     }
137 
138     @Override
139     public int getLocalPort() {
140         InetSocketAddress local = sc.localAddress();
141         if (local == null) {
142             return -1;
143         } else {
144             return local.getPort();
145         }
146     }
147 
148     @Override
149     public SocketAddress getRemoteSocketAddress() {
150         return sc.remoteAddress();
151     }
152 
153     @Override
154     public SocketAddress getLocalSocketAddress() {
155         InetSocketAddress local = sc.localAddress();
156         if (local != null) {
157             return Net.getRevealedLocalAddress(local);
158         } else {
159             return null;
160         }
161     }
162 
163     @Override
164     public SocketChannel getChannel() {
165         return sc;
166     }
167 
168     @Override
169     public InputStream getInputStream() throws IOException {
170         if (!sc.isOpen())
171             throw new SocketException(&quot;Socket is closed&quot;);
172         if (!sc.isConnected())
173             throw new SocketException(&quot;Socket is not connected&quot;);
174         if (!sc.isInputOpen())
175             throw new SocketException(&quot;Socket input is shutdown&quot;);
176         return new InputStream() {
177             @Override
178             public int read() throws IOException {
179                 byte[] a = new byte[1];
180                 int n = read(a, 0, 1);
181                 return (n &gt; 0) ? (a[0] &amp; 0xff) : -1;
182             }
183             @Override
184             public int read(byte[] b, int off, int len) throws IOException {
185                 int timeout = SocketAdaptor.this.timeout;
186                 if (timeout &gt; 0) {
187                     long nanos = MILLISECONDS.toNanos(timeout);
188                     return sc.blockingRead(b, off, len, nanos);
189                 } else {
190                     return sc.blockingRead(b, off, len, 0);
191                 }
192             }
193             @Override
194             public int available() throws IOException {
195                 return sc.available();
196             }
197             @Override
198             public void close() throws IOException {
199                 sc.close();
200             }
201         };
202     }
203 
204     @Override
205     public OutputStream getOutputStream() throws IOException {
206         if (!sc.isOpen())
207             throw new SocketException(&quot;Socket is closed&quot;);
208         if (!sc.isConnected())
209             throw new SocketException(&quot;Socket is not connected&quot;);
210         if (!sc.isOutputOpen())
211             throw new SocketException(&quot;Socket output is shutdown&quot;);
212         return new OutputStream() {
213             @Override
214             public void write(int b) throws IOException {
215                 byte[] a = new byte[]{(byte) b};
216                 write(a, 0, 1);
217             }
218             @Override
219             public void write(byte[] b, int off, int len) throws IOException {
220                 sc.blockingWriteFully(b, off, len);
221             }
222             @Override
223             public void close() throws IOException {
224                 sc.close();
225             }
226         };
227     }
228 
229     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
230         throws SocketException
231     {
232         try {
233             sc.setOption(name, value);
234         } catch (IOException x) {
235             Net.translateToSocketException(x);
236         }
237     }
238 
239     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
240         throws SocketException
241     {
242         try {
243             sc.setOption(name, value);
244         } catch (IOException x) {
245             Net.translateToSocketException(x);
246         }
247     }
248 
249     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
250         try {
251             return sc.getOption(name).booleanValue();
252         } catch (IOException x) {
253             Net.translateToSocketException(x);
254             return false;       // keep compiler happy
255         }
256     }
257 
258     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
259         try {
260             return sc.getOption(name).intValue();
261         } catch (IOException x) {
262             Net.translateToSocketException(x);
263             return -1;          // keep compiler happy
264         }
265     }
266 
267     @Override
268     public void setTcpNoDelay(boolean on) throws SocketException {
269         setBooleanOption(StandardSocketOptions.TCP_NODELAY, on);
270     }
271 
272     @Override
273     public boolean getTcpNoDelay() throws SocketException {
274         return getBooleanOption(StandardSocketOptions.TCP_NODELAY);
275     }
276 
277     @Override
278     public void setSoLinger(boolean on, int linger) throws SocketException {
279         if (!on)
280             linger = -1;
281         setIntOption(StandardSocketOptions.SO_LINGER, linger);
282     }
283 
284     @Override
285     public int getSoLinger() throws SocketException {
286         return getIntOption(StandardSocketOptions.SO_LINGER);
287     }
288 
289     @Override
290     public void sendUrgentData(int data) throws IOException {
291         int n = sc.sendOutOfBandData((byte) data);
292         if (n == 0)
293             throw new IOException(&quot;Socket buffer full&quot;);
294     }
295 
296     @Override
297     public void setOOBInline(boolean on) throws SocketException {
298         setBooleanOption(ExtendedSocketOption.SO_OOBINLINE, on);
299     }
300 
301     @Override
302     public boolean getOOBInline() throws SocketException {
303         return getBooleanOption(ExtendedSocketOption.SO_OOBINLINE);
304     }
305 
306     @Override
307     public void setSoTimeout(int timeout) throws SocketException {
308         if (!sc.isOpen())
309             throw new SocketException(&quot;Socket is closed&quot;);
310         if (timeout &lt; 0)
311             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
312         this.timeout = timeout;
313     }
314 
315     @Override
316     public int getSoTimeout() throws SocketException {
317         if (!sc.isOpen())
318             throw new SocketException(&quot;Socket is closed&quot;);
319         return timeout;
320     }
321 
322     @Override
323     public void setSendBufferSize(int size) throws SocketException {
324         // size 0 valid for SocketChannel, invalid for Socket
325         if (size &lt;= 0)
326             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
327         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
328     }
329 
330     @Override
331     public int getSendBufferSize() throws SocketException {
332         return getIntOption(StandardSocketOptions.SO_SNDBUF);
333     }
334 
335     @Override
336     public void setReceiveBufferSize(int size) throws SocketException {
337         // size 0 valid for SocketChannel, invalid for Socket
338         if (size &lt;= 0)
339             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
340         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
341     }
342 
343     @Override
344     public int getReceiveBufferSize() throws SocketException {
345         return getIntOption(StandardSocketOptions.SO_RCVBUF);
346     }
347 
348     @Override
349     public void setKeepAlive(boolean on) throws SocketException {
350         setBooleanOption(StandardSocketOptions.SO_KEEPALIVE, on);
351     }
352 
353     @Override
354     public boolean getKeepAlive() throws SocketException {
355         return getBooleanOption(StandardSocketOptions.SO_KEEPALIVE);
356     }
357 
358     @Override
359     public void setTrafficClass(int tc) throws SocketException {
360         setIntOption(StandardSocketOptions.IP_TOS, tc);
361     }
362 
363     @Override
364     public int getTrafficClass() throws SocketException {
365         return getIntOption(StandardSocketOptions.IP_TOS);
366     }
367 
368     @Override
369     public void setReuseAddress(boolean on) throws SocketException {
370         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
371     }
372 
373     @Override
374     public boolean getReuseAddress() throws SocketException {
375         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
376     }
377 
378     @Override
379     public void close() throws IOException {
380         sc.close();
381     }
382 
383     @Override
384     public void shutdownInput() throws IOException {
385         try {
386             sc.shutdownInput();
387         } catch (Exception x) {
388             Net.translateException(x);
389         }
390     }
391 
392     @Override
393     public void shutdownOutput() throws IOException {
394         try {
395             sc.shutdownOutput();
396         } catch (Exception x) {
397             Net.translateException(x);
398         }
399     }
400 
401     @Override
402     public String toString() {
403         if (sc.isConnected())
404             return &quot;Socket[addr=&quot; + getInetAddress() +
405                 &quot;,port=&quot; + getPort() +
406                 &quot;,localport=&quot; + getLocalPort() + &quot;]&quot;;
407         return &quot;Socket[unconnected]&quot;;
408     }
409 
410     @Override
411     public boolean isConnected() {
412         return sc.isConnected();
413     }
414 
415     @Override
416     public boolean isBound() {
417         return sc.localAddress() != null;
418     }
419 
420     @Override
421     public boolean isClosed() {
422         return !sc.isOpen();
423     }
424 
425     @Override
426     public boolean isInputShutdown() {
427         return !sc.isInputOpen();
428     }
429 
430     @Override
431     public boolean isOutputShutdown() {
432         return !sc.isOutputOpen();
433     }
434 
435     @Override
436     public &lt;T&gt; Socket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
437         sc.setOption(name, value);
438         return this;
439     }
440 
441     @Override
442     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
443         return sc.getOption(name);
444     }
445 
446     @Override
447     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
448         return sc.supportedOptions();
449     }
450 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLEngineOutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLEngineInputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLEngineOutputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLEngine}.
 37  */
 38 final class SSLEngineOutputRecord extends OutputRecord implements SSLRecord {
 39 
 40     private HandshakeFragment fragmenter = null;
 41     private boolean isTalkingToV2 = false;      // SSLv2Hello
 42     private ByteBuffer v2ClientHello = null;    // SSLv2Hello
 43 
 44     private volatile boolean isCloseWaiting = false;
 45 
 46     SSLEngineOutputRecord(HandshakeHash handshakeHash) {
 47         super(handshakeHash, SSLWriteCipher.nullTlsWriteCipher());
 48 
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
<span class="line-modified"> 54     public synchronized void close() throws IOException {</span>
<span class="line-modified"> 55         if (!isClosed) {</span>
<span class="line-modified"> 56             if (fragmenter != null &amp;&amp; fragmenter.hasAlert()) {</span>
<span class="line-modified"> 57                 isCloseWaiting = true;</span>
<span class="line-modified"> 58             } else {</span>
<span class="line-modified"> 59                 super.close();</span>



 60             }


 61         }
 62     }
 63 
 64     boolean isClosed() {
 65         return isClosed || isCloseWaiting;
 66     }
 67 
 68     @Override
 69     void encodeAlert(byte level, byte description) throws IOException {
 70         if (isClosed()) {
 71             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 72                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +
 73                     &quot;alert message: &quot; + Alert.nameOf(description));
 74             }
 75             return;
 76         }
 77 
 78         if (fragmenter == null) {
 79            fragmenter = new HandshakeFragment();
 80         }
</pre>
<hr />
<pre>
215         long recordSN = 0L;
216         while (needMorePayload) {
217             int fragLen;
218             if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {
219                 needMorePayload = true;
220 
221                 fragLen = 1;
222                 isFirstRecordOfThePayload = false;
223             } else {
224                 needMorePayload = false;
225 
226                 if (packetLeftSize &gt; 0) {
227                     fragLen = writeCipher.calculateFragmentSize(
228                             packetLeftSize, headerSize);
229 
230                     fragLen = Math.min(fragLen, Record.maxDataSize);
231                 } else {
232                     fragLen = Record.maxDataSize;
233                 }
234 
<span class="line-modified">235                 if (fragmentSize &gt; 0) {</span>
<span class="line-modified">236                     fragLen = Math.min(fragLen, fragmentSize);</span>
<span class="line-removed">237                 }</span>
238             }
239 
240             int dstPos = destination.position();
241             int dstContent = dstPos + headerSize +
242                                 writeCipher.getExplicitNonceSize();
243             destination.position(dstContent);
244 
245             int remains = Math.min(fragLen, destination.remaining());
246             fragLen = 0;
247             int srcsLen = offset + length;
248             for (int i = offset; (i &lt; srcsLen) &amp;&amp; (remains &gt; 0); i++) {
249                 int amount = Math.min(sources[i].remaining(), remains);
250                 int srcLimit = sources[i].limit();
251                 sources[i].limit(sources[i].position() + amount);
252                 destination.put(sources[i]);
253                 sources[i].limit(srcLimit);         // restore the limit
254                 remains -= amount;
255                 fragLen += amount;
256 
257                 if (remains &gt; 0) {
</pre>
<hr />
<pre>
422                 return null;
423             }
424 
425             RecordMemo memo = handshakeMemos.getFirst();
426             HandshakeMemo hsMemo = null;
427             if (memo.contentType == ContentType.HANDSHAKE.id) {
428                 hsMemo = (HandshakeMemo)memo;
429             }
430 
431             // ChangeCipherSpec message is pretty small.  Don&#39;t worry about
432             // the fragmentation of ChangeCipherSpec record.
433             int fragLen;
434             if (packetSize &gt; 0) {
435                 fragLen = Math.min(maxRecordSize, packetSize);
436                 fragLen = memo.encodeCipher.calculateFragmentSize(
437                         fragLen, headerSize);
438             } else {
439                 fragLen = Record.maxDataSize;
440             }
441 
<span class="line-modified">442             if (fragmentSize &gt; 0) {</span>
<span class="line-modified">443                 fragLen = Math.min(fragLen, fragmentSize);</span>
<span class="line-removed">444             }</span>
445 
446             int dstPos = dstBuf.position();
447             int dstLim = dstBuf.limit();
448             int dstContent = dstPos + headerSize +
449                                     memo.encodeCipher.getExplicitNonceSize();
450             dstBuf.position(dstContent);
451 
452             if (hsMemo != null) {
453                 int remainingFragLen = fragLen;
454                 while ((remainingFragLen &gt; 0) &amp;&amp; !handshakeMemos.isEmpty()) {
455                     int memoFragLen = hsMemo.fragment.length;
456                     if (hsMemo.acquireOffset == 0) {
457                         // Don&#39;t fragment handshake message header
458                         if (remainingFragLen &lt;= 4) {
459                             break;
460                         }
461 
462                         dstBuf.put(hsMemo.handshakeType);
463                         dstBuf.put((byte)((memoFragLen &gt;&gt; 16) &amp; 0xFF));
464                         dstBuf.put((byte)((memoFragLen &gt;&gt; 8) &amp; 0xFF));
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLEngine}.
 37  */
 38 final class SSLEngineOutputRecord extends OutputRecord implements SSLRecord {
 39 
 40     private HandshakeFragment fragmenter = null;
 41     private boolean isTalkingToV2 = false;      // SSLv2Hello
 42     private ByteBuffer v2ClientHello = null;    // SSLv2Hello
 43 
 44     private volatile boolean isCloseWaiting = false;
 45 
 46     SSLEngineOutputRecord(HandshakeHash handshakeHash) {
 47         super(handshakeHash, SSLWriteCipher.nullTlsWriteCipher());
 48 
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
<span class="line-modified"> 54     public void close() throws IOException {</span>
<span class="line-modified"> 55         recordLock.lock();</span>
<span class="line-modified"> 56         try {</span>
<span class="line-modified"> 57             if (!isClosed) {</span>
<span class="line-modified"> 58                 if (fragmenter != null &amp;&amp; fragmenter.hasAlert()) {</span>
<span class="line-modified"> 59                     isCloseWaiting = true;</span>
<span class="line-added"> 60                 } else {</span>
<span class="line-added"> 61                     super.close();</span>
<span class="line-added"> 62                 }</span>
 63             }
<span class="line-added"> 64         } finally {</span>
<span class="line-added"> 65             recordLock.unlock();</span>
 66         }
 67     }
 68 
 69     boolean isClosed() {
 70         return isClosed || isCloseWaiting;
 71     }
 72 
 73     @Override
 74     void encodeAlert(byte level, byte description) throws IOException {
 75         if (isClosed()) {
 76             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 77                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +
 78                     &quot;alert message: &quot; + Alert.nameOf(description));
 79             }
 80             return;
 81         }
 82 
 83         if (fragmenter == null) {
 84            fragmenter = new HandshakeFragment();
 85         }
</pre>
<hr />
<pre>
220         long recordSN = 0L;
221         while (needMorePayload) {
222             int fragLen;
223             if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {
224                 needMorePayload = true;
225 
226                 fragLen = 1;
227                 isFirstRecordOfThePayload = false;
228             } else {
229                 needMorePayload = false;
230 
231                 if (packetLeftSize &gt; 0) {
232                     fragLen = writeCipher.calculateFragmentSize(
233                             packetLeftSize, headerSize);
234 
235                     fragLen = Math.min(fragLen, Record.maxDataSize);
236                 } else {
237                     fragLen = Record.maxDataSize;
238                 }
239 
<span class="line-modified">240                 // Calculate more impact, for example TLS 1.3 padding.</span>
<span class="line-modified">241                 fragLen = calculateFragmentSize(fragLen);</span>

242             }
243 
244             int dstPos = destination.position();
245             int dstContent = dstPos + headerSize +
246                                 writeCipher.getExplicitNonceSize();
247             destination.position(dstContent);
248 
249             int remains = Math.min(fragLen, destination.remaining());
250             fragLen = 0;
251             int srcsLen = offset + length;
252             for (int i = offset; (i &lt; srcsLen) &amp;&amp; (remains &gt; 0); i++) {
253                 int amount = Math.min(sources[i].remaining(), remains);
254                 int srcLimit = sources[i].limit();
255                 sources[i].limit(sources[i].position() + amount);
256                 destination.put(sources[i]);
257                 sources[i].limit(srcLimit);         // restore the limit
258                 remains -= amount;
259                 fragLen += amount;
260 
261                 if (remains &gt; 0) {
</pre>
<hr />
<pre>
426                 return null;
427             }
428 
429             RecordMemo memo = handshakeMemos.getFirst();
430             HandshakeMemo hsMemo = null;
431             if (memo.contentType == ContentType.HANDSHAKE.id) {
432                 hsMemo = (HandshakeMemo)memo;
433             }
434 
435             // ChangeCipherSpec message is pretty small.  Don&#39;t worry about
436             // the fragmentation of ChangeCipherSpec record.
437             int fragLen;
438             if (packetSize &gt; 0) {
439                 fragLen = Math.min(maxRecordSize, packetSize);
440                 fragLen = memo.encodeCipher.calculateFragmentSize(
441                         fragLen, headerSize);
442             } else {
443                 fragLen = Record.maxDataSize;
444             }
445 
<span class="line-modified">446             // Calculate more impact, for example TLS 1.3 padding.</span>
<span class="line-modified">447             fragLen = calculateFragmentSize(fragLen);</span>

448 
449             int dstPos = dstBuf.position();
450             int dstLim = dstBuf.limit();
451             int dstContent = dstPos + headerSize +
452                                     memo.encodeCipher.getExplicitNonceSize();
453             dstBuf.position(dstContent);
454 
455             if (hsMemo != null) {
456                 int remainingFragLen = fragLen;
457                 while ((remainingFragLen &gt; 0) &amp;&amp; !handshakeMemos.isEmpty()) {
458                     int memoFragLen = hsMemo.fragment.length;
459                     if (hsMemo.acquireOffset == 0) {
460                         // Don&#39;t fragment handshake message header
461                         if (remainingFragLen &lt;= 4) {
462                             break;
463                         }
464 
465                         dstBuf.put(hsMemo.handshakeType);
466                         dstBuf.put((byte)((memoFragLen &gt;&gt; 16) &amp; 0xFF));
467                         dstBuf.put((byte)((memoFragLen &gt;&gt; 8) &amp; 0xFF));
</pre>
</td>
</tr>
</table>
<center><a href="SSLEngineInputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CurveDB.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.IOException;

 29 import java.util.ArrayList;

 30 
 31 /**
 32  * A package private utility class to convert indefinite length DER
 33  * encoded byte arrays to definite length DER encoded byte arrays.
 34  *
 35  * This assumes that the basic data structure is &quot;tag, length, value&quot;
 36  * triplet. In the case where the length is &quot;indefinite&quot;, terminating
 37  * end-of-contents bytes are expected.
 38  *
 39  * @author Hemma Prafullchandra
 40  */
 41 class DerIndefLenConverter {
 42 
 43     private static final int TAG_MASK            = 0x1f; // bits 5-1
 44     private static final int FORM_MASK           = 0x20; // bits 6
 45     private static final int CLASS_MASK          = 0xC0; // bits 8 and 7
 46 
 47     private static final int LEN_LONG            = 0x80; // bit 8 set
 48     private static final int LEN_MASK            = 0x7f; // bits 7 - 1
 49     private static final int SKIP_EOC_BYTES      = 2;
</pre>
<hr />
<pre>
 73     DerIndefLenConverter() { }
 74 
 75     /**
 76      * Checks whether the given length byte is of the form
 77      * &lt;em&gt;Indefinite&lt;/em&gt;.
 78      *
 79      * @param lengthByte the length byte from a DER encoded
 80      *        object.
 81      * @return true if the byte is of Indefinite form otherwise
 82      *         returns false.
 83      */
 84     static boolean isIndefinite(int lengthByte) {
 85         return (isLongForm(lengthByte) &amp;&amp; ((lengthByte &amp; LEN_MASK) == 0));
 86     }
 87 
 88     /**
 89      * Parse the tag and if it is an end-of-contents tag then
 90      * add the current position to the &lt;code&gt;eocList&lt;/code&gt; vector.
 91      */
 92     private void parseTag() throws IOException {
<span class="line-removed"> 93         if (dataPos == dataSize)</span>
<span class="line-removed"> 94             return;</span>
 95         if (isEOC(data[dataPos]) &amp;&amp; (data[dataPos + 1] == 0)) {
 96             int numOfEncapsulatedLenBytes = 0;
 97             Object elem = null;
 98             int index;
 99             for (index = ndefsList.size()-1; index &gt;= 0; index--) {
100                 // Determine the first element in the vector that does not
101                 // have a matching EOC
102                 elem = ndefsList.get(index);
103                 if (elem instanceof Integer) {
104                     break;
105                 } else {
106                     numOfEncapsulatedLenBytes += ((byte[])elem).length - 3;
107                 }
108             }
109             if (index &lt; 0) {
110                 throw new IOException(&quot;EOC does not have matching &quot; +
111                                       &quot;indefinite-length tag&quot;);
112             }
113             int sectionLen = dataPos - ((Integer)elem).intValue() +
114                              numOfEncapsulatedLenBytes;
</pre>
<hr />
<pre>
126     }
127 
128     /**
129      * Write the tag and if it is an end-of-contents tag
130      * then skip the tag and its 1 byte length of zero.
131      */
132     private void writeTag() {
133         if (dataPos == dataSize)
134             return;
135         int tag = data[dataPos++];
136         if (isEOC(tag) &amp;&amp; (data[dataPos] == 0)) {
137             dataPos++;  // skip length
138             writeTag();
139         } else
140             newData[newDataPos++] = (byte)tag;
141     }
142 
143     /**
144      * Parse the length and if it is an indefinite length then add
145      * the current position to the &lt;code&gt;ndefsList&lt;/code&gt; vector.




146      */
147     private int parseLength() throws IOException {
148         int curLen = 0;
149         if (dataPos == dataSize)
150             return curLen;
151         int lenByte = data[dataPos++] &amp; 0xff;
152         if (isIndefinite(lenByte)) {
153             ndefsList.add(dataPos);
154             unresolved++;
155             return curLen;
156         }
157         if (isLongForm(lenByte)) {
158             lenByte &amp;= LEN_MASK;
159             if (lenByte &gt; 4) {
160                 throw new IOException(&quot;Too much data&quot;);
161             }
162             if ((dataSize - dataPos) &lt; (lenByte + 1)) {
<span class="line-modified">163                 throw new IOException(&quot;Too little data&quot;);</span>
164             }
165             for (int i = 0; i &lt; lenByte; i++) {
166                 curLen = (curLen &lt;&lt; 8) + (data[dataPos++] &amp; 0xff);
167             }
168             if (curLen &lt; 0) {
169                 throw new IOException(&quot;Invalid length bytes&quot;);
170             }
171         } else {
172            curLen = (lenByte &amp; LEN_MASK);
173         }
174         return curLen;
175     }
176 
177     /**
178      * Write the length and if it is an indefinite length
179      * then calculate the definite length from the positions
180      * of the indefinite length and its matching EOC terminator.
181      * Then, write the value.
182      */
183     private void writeLengthAndValue() throws IOException {
</pre>
<hr />
<pre>
297      */
298     private void parseValue(int curLen) {
299         dataPos += curLen;
300     }
301 
302     /**
303      * Write the value;
304      */
305     private void writeValue(int curLen) {
306         for (int i=0; i &lt; curLen; i++)
307             newData[newDataPos++] = data[dataPos++];
308     }
309 
310     /**
311      * Converts a indefinite length DER encoded byte array to
312      * a definte length DER encoding.
313      *
314      * @param indefData the byte array holding the indefinite
315      *        length encoding.
316      * @return the byte array containing the definite length
<span class="line-modified">317      *         DER encoding.</span>
318      * @exception IOException on parsing or re-writing errors.
319      */
<span class="line-modified">320     byte[] convert(byte[] indefData) throws IOException {</span>
321         data = indefData;
322         dataPos=0; index=0;
323         dataSize = data.length;
324         int len=0;
325         int unused = 0;
326 
327         // parse and set up the vectors of all the indefinite-lengths
328         while (dataPos &lt; dataSize) {




329             parseTag();
330             len = parseLength();



331             parseValue(len);
332             if (unresolved == 0) {
333                 unused = dataSize - dataPos;
334                 dataSize = dataPos;
335                 break;
336             }
337         }
338 
339         if (unresolved != 0) {
<span class="line-modified">340             throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
341         }
342 
343         newData = new byte[dataSize + numOfTotalLenBytes + unused];
344         dataPos=0; newDataPos=0; index=0;
345 
346         // write out the new byte array replacing all the indefinite-lengths
347         // and EOCs
348         while (dataPos &lt; dataSize) {
349            writeTag();
350            writeLengthAndValue();
351         }
352         System.arraycopy(indefData, dataSize,
353                          newData, dataSize + numOfTotalLenBytes, unused);
354 
355         return newData;
356     }












































357 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.IOException;
<span class="line-added"> 29 import java.io.InputStream;</span>
 30 import java.util.ArrayList;
<span class="line-added"> 31 import java.util.Arrays;</span>
 32 
 33 /**
 34  * A package private utility class to convert indefinite length DER
 35  * encoded byte arrays to definite length DER encoded byte arrays.
 36  *
 37  * This assumes that the basic data structure is &quot;tag, length, value&quot;
 38  * triplet. In the case where the length is &quot;indefinite&quot;, terminating
 39  * end-of-contents bytes are expected.
 40  *
 41  * @author Hemma Prafullchandra
 42  */
 43 class DerIndefLenConverter {
 44 
 45     private static final int TAG_MASK            = 0x1f; // bits 5-1
 46     private static final int FORM_MASK           = 0x20; // bits 6
 47     private static final int CLASS_MASK          = 0xC0; // bits 8 and 7
 48 
 49     private static final int LEN_LONG            = 0x80; // bit 8 set
 50     private static final int LEN_MASK            = 0x7f; // bits 7 - 1
 51     private static final int SKIP_EOC_BYTES      = 2;
</pre>
<hr />
<pre>
 75     DerIndefLenConverter() { }
 76 
 77     /**
 78      * Checks whether the given length byte is of the form
 79      * &lt;em&gt;Indefinite&lt;/em&gt;.
 80      *
 81      * @param lengthByte the length byte from a DER encoded
 82      *        object.
 83      * @return true if the byte is of Indefinite form otherwise
 84      *         returns false.
 85      */
 86     static boolean isIndefinite(int lengthByte) {
 87         return (isLongForm(lengthByte) &amp;&amp; ((lengthByte &amp; LEN_MASK) == 0));
 88     }
 89 
 90     /**
 91      * Parse the tag and if it is an end-of-contents tag then
 92      * add the current position to the &lt;code&gt;eocList&lt;/code&gt; vector.
 93      */
 94     private void parseTag() throws IOException {


 95         if (isEOC(data[dataPos]) &amp;&amp; (data[dataPos + 1] == 0)) {
 96             int numOfEncapsulatedLenBytes = 0;
 97             Object elem = null;
 98             int index;
 99             for (index = ndefsList.size()-1; index &gt;= 0; index--) {
100                 // Determine the first element in the vector that does not
101                 // have a matching EOC
102                 elem = ndefsList.get(index);
103                 if (elem instanceof Integer) {
104                     break;
105                 } else {
106                     numOfEncapsulatedLenBytes += ((byte[])elem).length - 3;
107                 }
108             }
109             if (index &lt; 0) {
110                 throw new IOException(&quot;EOC does not have matching &quot; +
111                                       &quot;indefinite-length tag&quot;);
112             }
113             int sectionLen = dataPos - ((Integer)elem).intValue() +
114                              numOfEncapsulatedLenBytes;
</pre>
<hr />
<pre>
126     }
127 
128     /**
129      * Write the tag and if it is an end-of-contents tag
130      * then skip the tag and its 1 byte length of zero.
131      */
132     private void writeTag() {
133         if (dataPos == dataSize)
134             return;
135         int tag = data[dataPos++];
136         if (isEOC(tag) &amp;&amp; (data[dataPos] == 0)) {
137             dataPos++;  // skip length
138             writeTag();
139         } else
140             newData[newDataPos++] = (byte)tag;
141     }
142 
143     /**
144      * Parse the length and if it is an indefinite length then add
145      * the current position to the &lt;code&gt;ndefsList&lt;/code&gt; vector.
<span class="line-added">146      *</span>
<span class="line-added">147      * @return the length of definite length data next, or -1 if there is</span>
<span class="line-added">148      *         not enough bytes to determine it</span>
<span class="line-added">149      * @throws IOException if invalid data is read</span>
150      */
151     private int parseLength() throws IOException {
152         int curLen = 0;
153         if (dataPos == dataSize)
154             return curLen;
155         int lenByte = data[dataPos++] &amp; 0xff;
156         if (isIndefinite(lenByte)) {
157             ndefsList.add(dataPos);
158             unresolved++;
159             return curLen;
160         }
161         if (isLongForm(lenByte)) {
162             lenByte &amp;= LEN_MASK;
163             if (lenByte &gt; 4) {
164                 throw new IOException(&quot;Too much data&quot;);
165             }
166             if ((dataSize - dataPos) &lt; (lenByte + 1)) {
<span class="line-modified">167                 return -1;</span>
168             }
169             for (int i = 0; i &lt; lenByte; i++) {
170                 curLen = (curLen &lt;&lt; 8) + (data[dataPos++] &amp; 0xff);
171             }
172             if (curLen &lt; 0) {
173                 throw new IOException(&quot;Invalid length bytes&quot;);
174             }
175         } else {
176            curLen = (lenByte &amp; LEN_MASK);
177         }
178         return curLen;
179     }
180 
181     /**
182      * Write the length and if it is an indefinite length
183      * then calculate the definite length from the positions
184      * of the indefinite length and its matching EOC terminator.
185      * Then, write the value.
186      */
187     private void writeLengthAndValue() throws IOException {
</pre>
<hr />
<pre>
301      */
302     private void parseValue(int curLen) {
303         dataPos += curLen;
304     }
305 
306     /**
307      * Write the value;
308      */
309     private void writeValue(int curLen) {
310         for (int i=0; i &lt; curLen; i++)
311             newData[newDataPos++] = data[dataPos++];
312     }
313 
314     /**
315      * Converts a indefinite length DER encoded byte array to
316      * a definte length DER encoding.
317      *
318      * @param indefData the byte array holding the indefinite
319      *        length encoding.
320      * @return the byte array containing the definite length
<span class="line-modified">321      *         DER encoding, or null if there is not enough data.</span>
322      * @exception IOException on parsing or re-writing errors.
323      */
<span class="line-modified">324     byte[] convertBytes(byte[] indefData) throws IOException {</span>
325         data = indefData;
326         dataPos=0; index=0;
327         dataSize = data.length;
328         int len=0;
329         int unused = 0;
330 
331         // parse and set up the vectors of all the indefinite-lengths
332         while (dataPos &lt; dataSize) {
<span class="line-added">333             if (dataPos + 2 &gt; dataSize) {</span>
<span class="line-added">334                 // There should be at least one tag and one length</span>
<span class="line-added">335                 return null;</span>
<span class="line-added">336             }</span>
337             parseTag();
338             len = parseLength();
<span class="line-added">339             if (len &lt; 0) {</span>
<span class="line-added">340                 return null;</span>
<span class="line-added">341             }</span>
342             parseValue(len);
343             if (unresolved == 0) {
344                 unused = dataSize - dataPos;
345                 dataSize = dataPos;
346                 break;
347             }
348         }
349 
350         if (unresolved != 0) {
<span class="line-modified">351             return null;</span>
352         }
353 
354         newData = new byte[dataSize + numOfTotalLenBytes + unused];
355         dataPos=0; newDataPos=0; index=0;
356 
357         // write out the new byte array replacing all the indefinite-lengths
358         // and EOCs
359         while (dataPos &lt; dataSize) {
360            writeTag();
361            writeLengthAndValue();
362         }
363         System.arraycopy(indefData, dataSize,
364                          newData, dataSize + numOfTotalLenBytes, unused);
365 
366         return newData;
367     }
<span class="line-added">368 </span>
<span class="line-added">369     /**</span>
<span class="line-added">370      * Read the input stream into a DER byte array. If an indef len BER is</span>
<span class="line-added">371      * not resolved this method will try to read more data until EOF is reached.</span>
<span class="line-added">372      * This may block.</span>
<span class="line-added">373      *</span>
<span class="line-added">374      * @param in the input stream with tag and lenByte already read</span>
<span class="line-added">375      * @param lenByte the length of the length field to remember</span>
<span class="line-added">376      * @param tag the tag to remember</span>
<span class="line-added">377      * @return a DER byte array</span>
<span class="line-added">378      * @throws IOException if not all indef len BER</span>
<span class="line-added">379      *         can be resolved or another I/O error happens</span>
<span class="line-added">380      */</span>
<span class="line-added">381     public static byte[] convertStream(InputStream in, byte lenByte, byte tag)</span>
<span class="line-added">382             throws IOException {</span>
<span class="line-added">383         int offset = 2;     // for tag and length bytes</span>
<span class="line-added">384         int readLen = in.available();</span>
<span class="line-added">385         byte[] indefData = new byte[readLen + offset];</span>
<span class="line-added">386         indefData[0] = tag;</span>
<span class="line-added">387         indefData[1] = lenByte;</span>
<span class="line-added">388         while (true) {</span>
<span class="line-added">389             int bytesRead = in.readNBytes(indefData, offset, readLen);</span>
<span class="line-added">390             if (bytesRead != readLen) {</span>
<span class="line-added">391                 readLen = bytesRead;</span>
<span class="line-added">392                 indefData = Arrays.copyOf(indefData, offset + bytesRead);</span>
<span class="line-added">393             }</span>
<span class="line-added">394             DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-added">395             byte[] result = derIn.convertBytes(indefData);</span>
<span class="line-added">396             if (result == null) {</span>
<span class="line-added">397                 int next = in.read(); // This could block, but we need more</span>
<span class="line-added">398                 if (next == -1) {</span>
<span class="line-added">399                     throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="line-added">400                 }</span>
<span class="line-added">401                 int more = in.available();</span>
<span class="line-added">402                 // expand array to include next and more</span>
<span class="line-added">403                 indefData = Arrays.copyOf(indefData, offset + readLen + 1 + more);</span>
<span class="line-added">404                 indefData[offset + readLen] = (byte)next;</span>
<span class="line-added">405                 offset = offset + readLen + 1;</span>
<span class="line-added">406                 readLen = more;</span>
<span class="line-added">407             } else {</span>
<span class="line-added">408                 return result;</span>
<span class="line-added">409             }</span>
<span class="line-added">410         }</span>
<span class="line-added">411     }</span>
412 }
</pre>
</td>
</tr>
</table>
<center><a href="CurveDB.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
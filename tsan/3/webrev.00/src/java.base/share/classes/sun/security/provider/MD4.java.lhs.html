<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/provider/MD4.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.security.*;
 29 import java.util.Arrays;
 30 
 31 import static sun.security.provider.ByteArrayAccess.*;
 32 import static sun.security.util.SecurityConstants.PROVIDER_VER;
 33 
 34 /**
 35  * The MD4 class is used to compute an MD4 message digest over a given
 36  * buffer of bytes. It is an implementation of the RSA Data Security Inc
 37  * MD4 algorithim as described in internet RFC 1320.
 38  *
 39  * &lt;p&gt;The MD4 algorithm is very weak and should not be used unless it is
 40  * unavoidable. Therefore, it is not registered in our standard providers. To
 41  * obtain an implementation, call the static getInstance() method in this
 42  * class.
 43  *
 44  * @author      Andreas Sterbenz
 45  */
 46 public final class MD4 extends DigestBase {
 47 
 48     // state of this object
 49     private int[] state;
 50     // temporary buffer, used by implCompress()
 51     private int[] x;
 52 
 53     // rotation constants
 54     private static final int S11 = 3;
 55     private static final int S12 = 7;
 56     private static final int S13 = 11;
 57     private static final int S14 = 19;
 58     private static final int S21 = 3;
 59     private static final int S22 = 5;
 60     private static final int S23 = 9;
 61     private static final int S24 = 13;
 62     private static final int S31 = 3;
 63     private static final int S32 = 9;
 64     private static final int S33 = 11;
 65     private static final int S34 = 15;
 66 
 67     private static final Provider md4Provider;
 68 
 69     static {
 70         md4Provider = new Provider(&quot;MD4Provider&quot;, PROVIDER_VER,
 71             &quot;MD4 MessageDigest&quot;) {
<a name="2" id="anc2"></a>
 72             private static final long serialVersionUID = -8850464997518327965L;
 73         };
 74         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 75             public Void run() {
 76                 md4Provider.put(&quot;MessageDigest.MD4&quot;, &quot;sun.security.provider.MD4&quot;);
 77                 return null;
 78             }
 79         });
 80     }
 81 
 82     public static MessageDigest getInstance() {
 83         try {
 84             return MessageDigest.getInstance(&quot;MD4&quot;, md4Provider);
 85         } catch (NoSuchAlgorithmException e) {
 86             // should never occur
 87             throw new ProviderException(e);
 88         }
 89     }
 90 
 91     // Standard constructor, creates a new MD4 instance.
 92     public MD4() {
 93         super(&quot;MD4&quot;, 16, 64);
 94         state = new int[4];
 95         x = new int[16];
 96         resetHashes();
 97     }
 98 
 99     // clone this object
100     public Object clone() throws CloneNotSupportedException {
101         MD4 copy = (MD4) super.clone();
102         copy.state = copy.state.clone();
103         copy.x = new int[16];
104         return copy;
105     }
106 
107     /**
108      * Reset the state of this object.
109      */
110     void implReset() {
111         // Load magic initialization constants.
112         resetHashes();
113         // clear out old data
114         Arrays.fill(x, 0);
115     }
116 
117     private void resetHashes() {
118         state[0] = 0x67452301;
119         state[1] = 0xefcdab89;
120         state[2] = 0x98badcfe;
121         state[3] = 0x10325476;
122     }
123 
124     /**
125      * Perform the final computations, any buffered bytes are added
126      * to the digest, the count is added to the digest, and the resulting
127      * digest is stored.
128      */
129     void implDigest(byte[] out, int ofs) {
130         long bitsProcessed = bytesProcessed &lt;&lt; 3;
131 
132         int index = (int)bytesProcessed &amp; 0x3f;
133         int padLen = (index &lt; 56) ? (56 - index) : (120 - index);
134         engineUpdate(padding, 0, padLen);
135 
136         i2bLittle4((int)bitsProcessed, buffer, 56);
137         i2bLittle4((int)(bitsProcessed &gt;&gt;&gt; 32), buffer, 60);
138         implCompress(buffer, 0);
139 
140         i2bLittle(state, 0, out, ofs, 16);
141     }
142 
143     private static int FF(int a, int b, int c, int d, int x, int s) {
144         a += ((b &amp; c) | ((~b) &amp; d)) + x;
145         return ((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)));
146     }
147 
148     private static int GG(int a, int b, int c, int d, int x, int s) {
149         a += ((b &amp; c) | (b &amp; d) | (c &amp; d)) + x + 0x5a827999;
150         return ((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)));
151     }
152 
153     private static int HH(int a, int b, int c, int d, int x, int s) {
154         a += ((b ^ c) ^ d) + x + 0x6ed9eba1;
155         return ((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)));
156     }
157 
158     /**
159      * This is where the functions come together as the generic MD4
160      * transformation operation. It consumes sixteen
161      * bytes from the buffer, beginning at the specified offset.
162      */
163     void implCompress(byte[] buf, int ofs) {
164         b2iLittle64(buf, ofs, x);
165 
166         int a = state[0];
167         int b = state[1];
168         int c = state[2];
169         int d = state[3];
170 
171         /* Round 1 */
172         a = FF (a, b, c, d, x[ 0], S11); /* 1 */
173         d = FF (d, a, b, c, x[ 1], S12); /* 2 */
174         c = FF (c, d, a, b, x[ 2], S13); /* 3 */
175         b = FF (b, c, d, a, x[ 3], S14); /* 4 */
176         a = FF (a, b, c, d, x[ 4], S11); /* 5 */
177         d = FF (d, a, b, c, x[ 5], S12); /* 6 */
178         c = FF (c, d, a, b, x[ 6], S13); /* 7 */
179         b = FF (b, c, d, a, x[ 7], S14); /* 8 */
180         a = FF (a, b, c, d, x[ 8], S11); /* 9 */
181         d = FF (d, a, b, c, x[ 9], S12); /* 10 */
182         c = FF (c, d, a, b, x[10], S13); /* 11 */
183         b = FF (b, c, d, a, x[11], S14); /* 12 */
184         a = FF (a, b, c, d, x[12], S11); /* 13 */
185         d = FF (d, a, b, c, x[13], S12); /* 14 */
186         c = FF (c, d, a, b, x[14], S13); /* 15 */
187         b = FF (b, c, d, a, x[15], S14); /* 16 */
188 
189         /* Round 2 */
190         a = GG (a, b, c, d, x[ 0], S21); /* 17 */
191         d = GG (d, a, b, c, x[ 4], S22); /* 18 */
192         c = GG (c, d, a, b, x[ 8], S23); /* 19 */
193         b = GG (b, c, d, a, x[12], S24); /* 20 */
194         a = GG (a, b, c, d, x[ 1], S21); /* 21 */
195         d = GG (d, a, b, c, x[ 5], S22); /* 22 */
196         c = GG (c, d, a, b, x[ 9], S23); /* 23 */
197         b = GG (b, c, d, a, x[13], S24); /* 24 */
198         a = GG (a, b, c, d, x[ 2], S21); /* 25 */
199         d = GG (d, a, b, c, x[ 6], S22); /* 26 */
200         c = GG (c, d, a, b, x[10], S23); /* 27 */
201         b = GG (b, c, d, a, x[14], S24); /* 28 */
202         a = GG (a, b, c, d, x[ 3], S21); /* 29 */
203         d = GG (d, a, b, c, x[ 7], S22); /* 30 */
204         c = GG (c, d, a, b, x[11], S23); /* 31 */
205         b = GG (b, c, d, a, x[15], S24); /* 32 */
206 
207         /* Round 3 */
208         a = HH (a, b, c, d, x[ 0], S31); /* 33 */
209         d = HH (d, a, b, c, x[ 8], S32); /* 34 */
210         c = HH (c, d, a, b, x[ 4], S33); /* 35 */
211         b = HH (b, c, d, a, x[12], S34); /* 36 */
212         a = HH (a, b, c, d, x[ 2], S31); /* 37 */
213         d = HH (d, a, b, c, x[10], S32); /* 38 */
214         c = HH (c, d, a, b, x[ 6], S33); /* 39 */
215         b = HH (b, c, d, a, x[14], S34); /* 40 */
216         a = HH (a, b, c, d, x[ 1], S31); /* 41 */
217         d = HH (d, a, b, c, x[ 9], S32); /* 42 */
218         c = HH (c, d, a, b, x[ 5], S33); /* 43 */
219         b = HH (b, c, d, a, x[13], S34); /* 44 */
220         a = HH (a, b, c, d, x[ 3], S31); /* 45 */
221         d = HH (d, a, b, c, x[11], S32); /* 46 */
222         c = HH (c, d, a, b, x[ 7], S33); /* 47 */
223         b = HH (b, c, d, a, x[15], S34); /* 48 */
224 
225         state[0] += a;
226         state[1] += b;
227         state[2] += c;
228         state[3] += d;
229     }
230 
231 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
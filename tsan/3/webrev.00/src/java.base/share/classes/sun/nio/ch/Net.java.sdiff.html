<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/Net.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NativeDispatcher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Reflect.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/Net.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 import java.net.InetSocketAddress;
 34 import java.net.NetworkInterface;
 35 import java.net.ProtocolFamily;
 36 import java.net.SocketAddress;
 37 import java.net.SocketException;
 38 import java.net.SocketOption;
 39 import java.net.StandardProtocolFamily;
 40 import java.net.StandardSocketOptions;
 41 import java.net.UnknownHostException;
 42 import java.nio.channels.AlreadyBoundException;
 43 import java.nio.channels.ClosedChannelException;
 44 import java.nio.channels.NotYetBoundException;
 45 import java.nio.channels.NotYetConnectedException;
 46 import java.nio.channels.UnresolvedAddressException;
 47 import java.nio.channels.UnsupportedAddressTypeException;
 48 import java.security.AccessController;
 49 import java.security.PrivilegedAction;
 50 import java.util.Enumeration;
 51 
 52 import sun.net.ext.ExtendedSocketOptions;

 53 import sun.security.action.GetPropertyAction;
 54 
 55 public class Net {
 56 
 57     private Net() { }
 58 
 59     // unspecified protocol family
 60     static final ProtocolFamily UNSPEC = new ProtocolFamily() {
 61         public String name() {
 62             return &quot;UNSPEC&quot;;
 63         }
 64     };
 65 
 66     // set to true if exclusive binding is on for Windows
 67     private static final boolean exclusiveBind;
 68 
 69     // set to true if the fast tcp loopback should be enabled on Windows
 70     private static final boolean fastLoopback;
 71 
 72     // -- Miscellaneous utilities --
</pre>
<hr />
<pre>
 88     }
 89 
 90     /**
 91      * Tells whether SO_REUSEPORT is supported.
 92      */
 93     static boolean isReusePortAvailable() {
 94         if (!checkedReusePort) {
 95             isReusePortAvailable = isReusePortAvailable0();
 96             checkedReusePort = true;
 97         }
 98         return isReusePortAvailable;
 99     }
100 
101     /**
102      * Returns true if exclusive binding is on
103      */
104     static boolean useExclusiveBind() {
105         return exclusiveBind;
106     }
107 










108     /**
109      * Tells whether IPv6 sockets can join IPv4 multicast groups
110      */
111     static boolean canIPv6SocketJoinIPv4Group() {
112         return canIPv6SocketJoinIPv4Group0();
113     }
114 
115     /**
116      * Tells whether {@link #join6} can be used to join an IPv4
117      * multicast group (IPv4 group as IPv4-mapped IPv6 address)
118      */
119     static boolean canJoin6WithIPv4Group() {
120         return canJoin6WithIPv4Group0();
121     }
122 








123     public static InetSocketAddress checkAddress(SocketAddress sa) {
124         if (sa == null)
125             throw new NullPointerException();
126         if (!(sa instanceof InetSocketAddress))
127             throw new UnsupportedAddressTypeException(); // ## needs arg
128         InetSocketAddress isa = (InetSocketAddress)sa;
129         if (isa.isUnresolved())
130             throw new UnresolvedAddressException(); // ## needs arg
131         InetAddress addr = isa.getAddress();
132         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address))
133             throw new IllegalArgumentException(&quot;Invalid address type&quot;);
134         return isa;
135     }
136 
137     static InetSocketAddress checkAddress(SocketAddress sa, ProtocolFamily family) {
138         InetSocketAddress isa = checkAddress(sa);
139         if (family == StandardProtocolFamily.INET) {
140             InetAddress addr = isa.getAddress();
141             if (!(addr instanceof Inet4Address))
142                 throw new UnsupportedAddressTypeException();
</pre>
<hr />
<pre>
293         if (ia instanceof Inet4Address) {
294             byte[] ip4address = ia.getAddress();
295             byte[] address = new byte[16];
296             address[10] = (byte)0xff;
297             address[11] = (byte)0xff;
298             address[12] = ip4address[0];
299             address[13] = ip4address[1];
300             address[14] = ip4address[2];
301             address[15] = ip4address[3];
302             return address;
303         }
304 
305         throw new AssertionError(&quot;Should not reach here&quot;);
306     }
307 
308     // -- Socket options
309 
310     static final ExtendedSocketOptions extendedOptions =
311             ExtendedSocketOptions.getInstance();
312 






313     static void setSocketOption(FileDescriptor fd, ProtocolFamily family,
314                                 SocketOption&lt;?&gt; name, Object value)
315         throws IOException
316     {
317         if (value == null)
318             throw new IllegalArgumentException(&quot;Invalid option value&quot;);
319 
320         // only simple values supported by this method
321         Class&lt;?&gt; type = name.type();
322 
323         if (extendedOptions.isOptionSupported(name)) {
324             extendedOptions.setOption(fd, name, value);
325             return;
326         }
327 
328         if (type != Integer.class &amp;&amp; type != Boolean.class)
329             throw new AssertionError(&quot;Should not reach here&quot;);
330 
331         // special handling
332         if (name == StandardSocketOptions.SO_RCVBUF ||
</pre>
<hr />
<pre>
355         }
356 
357         // map option name to platform level/name
358         OptionKey key = SocketOptionRegistry.findOption(name, family);
359         if (key == null)
360             throw new AssertionError(&quot;Option not found&quot;);
361 
362         int arg;
363         if (type == Integer.class) {
364             arg = ((Integer)value).intValue();
365         } else {
366             boolean b = ((Boolean)value).booleanValue();
367             arg = (b) ? 1 : 0;
368         }
369 
370         boolean mayNeedConversion = (family == UNSPEC);
371         boolean isIPv6 = (family == StandardProtocolFamily.INET6);
372         setIntOption0(fd, mayNeedConversion, key.level(), key.name(), arg, isIPv6);
373     }
374 
<span class="line-modified">375     static Object getSocketOption(FileDescriptor fd, ProtocolFamily family,</span>
<span class="line-modified">376                                   SocketOption&lt;?&gt; name)</span>





377         throws IOException
378     {
379         Class&lt;?&gt; type = name.type();
380 
381         if (extendedOptions.isOptionSupported(name)) {
382             return extendedOptions.getOption(fd, name);
383         }
384 
385         // only simple values supported by this method
386         if (type != Integer.class &amp;&amp; type != Boolean.class)
387             throw new AssertionError(&quot;Should not reach here&quot;);
388 
389         // map option name to platform level/name
390         OptionKey key = SocketOptionRegistry.findOption(name, family);
391         if (key == null)
392             throw new AssertionError(&quot;Option not found&quot;);
393 
394         boolean mayNeedConversion = (family == UNSPEC);
395         int value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());
396 
</pre>
<hr />
<pre>
401         }
402     }
403 
404     public static boolean isFastTcpLoopbackRequested() {
405         String loopbackProp = GetPropertyAction
406                 .privilegedGetProperty(&quot;jdk.net.useFastTcpLoopback&quot;, &quot;false&quot;);
407         return loopbackProp.isEmpty() ? true : Boolean.parseBoolean(loopbackProp);
408     }
409 
410     // -- Socket operations --
411 
412     private static native boolean isIPv6Available0();
413 
414     private static native boolean isReusePortAvailable0();
415 
416     /*
417      * Returns 1 for Windows and -1 for Solaris/Linux/Mac OS
418      */
419     private static native int isExclusiveBindAvailable();
420 


421     private static native boolean canIPv6SocketJoinIPv4Group0();
422 
423     private static native boolean canJoin6WithIPv4Group0();
424 


425     static FileDescriptor socket(boolean stream) throws IOException {
426         return socket(UNSPEC, stream);
427     }
428 
<span class="line-modified">429     static FileDescriptor socket(ProtocolFamily family, boolean stream)</span>
<span class="line-removed">430         throws IOException {</span>
431         boolean preferIPv6 = isIPv6Available() &amp;&amp;
432             (family != StandardProtocolFamily.INET);
433         return IOUtil.newFD(socket0(preferIPv6, stream, false, fastLoopback));
434     }
435 
436     static FileDescriptor serverSocket(boolean stream) {
437         return IOUtil.newFD(socket0(isIPv6Available(), stream, true, fastLoopback));
438     }
439 
440     // Due to oddities SO_REUSEADDR on windows reuse is ignored
441     private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse,
442                                       boolean fastLoopback);
443 
444     public static void bind(FileDescriptor fd, InetAddress addr, int port)
445         throws IOException
446     {
447         bind(UNSPEC, fd, addr, port);
448     }
449 
450     static void bind(ProtocolFamily family, FileDescriptor fd,
451                      InetAddress addr, int port) throws IOException
452     {
453         boolean preferIPv6 = isIPv6Available() &amp;&amp;
454             (family != StandardProtocolFamily.INET);



455         bind0(fd, preferIPv6, exclusiveBind, addr, port);
456     }
457 
458     private static native void bind0(FileDescriptor fd, boolean preferIPv6,
459                                      boolean useExclBind, InetAddress addr,
460                                      int port)
461         throws IOException;
462 
463     static native void listen(FileDescriptor fd, int backlog) throws IOException;
464 
465     static int connect(FileDescriptor fd, InetAddress remote, int remotePort)
466         throws IOException
467     {
468         return connect(UNSPEC, fd, remote, remotePort);
469     }
470 
471     static int connect(ProtocolFamily family, FileDescriptor fd, InetAddress remote, int remotePort)
472         throws IOException
473     {



474         boolean preferIPv6 = isIPv6Available() &amp;&amp;
475             (family != StandardProtocolFamily.INET);
476         return connect0(preferIPv6, fd, remote, remotePort);
477     }
478 
479     private static native int connect0(boolean preferIPv6,
480                                        FileDescriptor fd,
481                                        InetAddress remote,
482                                        int remotePort)
483         throws IOException;
484 




485 
486     public static final int SHUT_RD = 0;
487     public static final int SHUT_WR = 1;
488     public static final int SHUT_RDWR = 2;
489 
490     static native void shutdown(FileDescriptor fd, int how) throws IOException;
491 
492     private static native int localPort(FileDescriptor fd)
493         throws IOException;
494 
495     private static native InetAddress localInetAddress(FileDescriptor fd)
496         throws IOException;
497 
498     public static InetSocketAddress localAddress(FileDescriptor fd)
499         throws IOException
500     {
501         return new InetSocketAddress(localInetAddress(fd), localPort(fd));
502     }
503 
504     private static native int remotePort(FileDescriptor fd)
505         throws IOException;
506 
507     private static native InetAddress remoteInetAddress(FileDescriptor fd)
508         throws IOException;
509 
510     static InetSocketAddress remoteAddress(FileDescriptor fd)
511         throws IOException
512     {
513         return new InetSocketAddress(remoteInetAddress(fd), remotePort(fd));
514     }
515 
516     private static native int getIntOption0(FileDescriptor fd, boolean mayNeedConversion,
517                                             int level, int opt)
518         throws IOException;
519 
520     private static native void setIntOption0(FileDescriptor fd, boolean mayNeedConversion,
521                                              int level, int opt, int arg, boolean isIPv6)
522         throws IOException;
523 





524     static native int poll(FileDescriptor fd, int events, long timeout)
525         throws IOException;
526 








527     /**
528      * Polls a connecting socket to test if the connection has been established.
529      *
530      * @apiNote This method is public to allow it be used by code in jdk.sctp.
531      *
532      * @param timeout the timeout to wait; 0 to not wait, -1 to wait indefinitely
<span class="line-modified">533      * @return 1 if connected, 0 if not connected, or IOS_INTERRUPTED</span>
534      */
<span class="line-modified">535     public static native int pollConnect(FileDescriptor fd, long timeout)</span>
536         throws IOException;
537 










538     /**
539      * Return the number of bytes in the socket input buffer.
540      */
541     static native int available(FileDescriptor fd) throws IOException;
542 
543     /**
544      * Send one byte of urgent data (MSG_OOB) on the socket.
545      */
546     static native int sendOOB(FileDescriptor fd, byte data) throws IOException;
547 
548 
549     // -- Multicast support --
550 
551     /**
552      * Join IPv4 multicast group
553      */
554     static int join4(FileDescriptor fd, int group, int interf, int source)
555         throws IOException
556     {
557         return joinOrDrop4(true, fd, group, interf, source);
</pre>
</td>
<td>
<hr />
<pre>
 33 import java.net.InetSocketAddress;
 34 import java.net.NetworkInterface;
 35 import java.net.ProtocolFamily;
 36 import java.net.SocketAddress;
 37 import java.net.SocketException;
 38 import java.net.SocketOption;
 39 import java.net.StandardProtocolFamily;
 40 import java.net.StandardSocketOptions;
 41 import java.net.UnknownHostException;
 42 import java.nio.channels.AlreadyBoundException;
 43 import java.nio.channels.ClosedChannelException;
 44 import java.nio.channels.NotYetBoundException;
 45 import java.nio.channels.NotYetConnectedException;
 46 import java.nio.channels.UnresolvedAddressException;
 47 import java.nio.channels.UnsupportedAddressTypeException;
 48 import java.security.AccessController;
 49 import java.security.PrivilegedAction;
 50 import java.util.Enumeration;
 51 
 52 import sun.net.ext.ExtendedSocketOptions;
<span class="line-added"> 53 import sun.net.util.IPAddressUtil;</span>
 54 import sun.security.action.GetPropertyAction;
 55 
 56 public class Net {
 57 
 58     private Net() { }
 59 
 60     // unspecified protocol family
 61     static final ProtocolFamily UNSPEC = new ProtocolFamily() {
 62         public String name() {
 63             return &quot;UNSPEC&quot;;
 64         }
 65     };
 66 
 67     // set to true if exclusive binding is on for Windows
 68     private static final boolean exclusiveBind;
 69 
 70     // set to true if the fast tcp loopback should be enabled on Windows
 71     private static final boolean fastLoopback;
 72 
 73     // -- Miscellaneous utilities --
</pre>
<hr />
<pre>
 89     }
 90 
 91     /**
 92      * Tells whether SO_REUSEPORT is supported.
 93      */
 94     static boolean isReusePortAvailable() {
 95         if (!checkedReusePort) {
 96             isReusePortAvailable = isReusePortAvailable0();
 97             checkedReusePort = true;
 98         }
 99         return isReusePortAvailable;
100     }
101 
102     /**
103      * Returns true if exclusive binding is on
104      */
105     static boolean useExclusiveBind() {
106         return exclusiveBind;
107     }
108 
<span class="line-added">109     /**</span>
<span class="line-added">110      * Tells whether both IPV6_XXX and IP_XXX socket options should be set on</span>
<span class="line-added">111      * IPv6 sockets. On some kernels, both IPV6_XXX and IP_XXX socket options</span>
<span class="line-added">112      * need to be set so that the settings are effective for IPv4 multicast</span>
<span class="line-added">113      * datagrams sent using the socket.</span>
<span class="line-added">114      */</span>
<span class="line-added">115     static boolean shouldSetBothIPv4AndIPv6Options() {</span>
<span class="line-added">116         return shouldSetBothIPv4AndIPv6Options0();</span>
<span class="line-added">117     }</span>
<span class="line-added">118 </span>
119     /**
120      * Tells whether IPv6 sockets can join IPv4 multicast groups
121      */
122     static boolean canIPv6SocketJoinIPv4Group() {
123         return canIPv6SocketJoinIPv4Group0();
124     }
125 
126     /**
127      * Tells whether {@link #join6} can be used to join an IPv4
128      * multicast group (IPv4 group as IPv4-mapped IPv6 address)
129      */
130     static boolean canJoin6WithIPv4Group() {
131         return canJoin6WithIPv4Group0();
132     }
133 
<span class="line-added">134     /**</span>
<span class="line-added">135      * Tells whether IPV6_XXX socket options should be used on an IPv6 socket</span>
<span class="line-added">136      * that is bound to an IPv4 address.</span>
<span class="line-added">137      */</span>
<span class="line-added">138     static boolean canUseIPv6OptionsWithIPv4LocalAddress() {</span>
<span class="line-added">139         return canUseIPv6OptionsWithIPv4LocalAddress0();</span>
<span class="line-added">140     }</span>
<span class="line-added">141 </span>
142     public static InetSocketAddress checkAddress(SocketAddress sa) {
143         if (sa == null)
144             throw new NullPointerException();
145         if (!(sa instanceof InetSocketAddress))
146             throw new UnsupportedAddressTypeException(); // ## needs arg
147         InetSocketAddress isa = (InetSocketAddress)sa;
148         if (isa.isUnresolved())
149             throw new UnresolvedAddressException(); // ## needs arg
150         InetAddress addr = isa.getAddress();
151         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address))
152             throw new IllegalArgumentException(&quot;Invalid address type&quot;);
153         return isa;
154     }
155 
156     static InetSocketAddress checkAddress(SocketAddress sa, ProtocolFamily family) {
157         InetSocketAddress isa = checkAddress(sa);
158         if (family == StandardProtocolFamily.INET) {
159             InetAddress addr = isa.getAddress();
160             if (!(addr instanceof Inet4Address))
161                 throw new UnsupportedAddressTypeException();
</pre>
<hr />
<pre>
312         if (ia instanceof Inet4Address) {
313             byte[] ip4address = ia.getAddress();
314             byte[] address = new byte[16];
315             address[10] = (byte)0xff;
316             address[11] = (byte)0xff;
317             address[12] = ip4address[0];
318             address[13] = ip4address[1];
319             address[14] = ip4address[2];
320             address[15] = ip4address[3];
321             return address;
322         }
323 
324         throw new AssertionError(&quot;Should not reach here&quot;);
325     }
326 
327     // -- Socket options
328 
329     static final ExtendedSocketOptions extendedOptions =
330             ExtendedSocketOptions.getInstance();
331 
<span class="line-added">332     static void setSocketOption(FileDescriptor fd, SocketOption&lt;?&gt; name, Object value)</span>
<span class="line-added">333         throws IOException</span>
<span class="line-added">334     {</span>
<span class="line-added">335         setSocketOption(fd, Net.UNSPEC, name, value);</span>
<span class="line-added">336     }</span>
<span class="line-added">337 </span>
338     static void setSocketOption(FileDescriptor fd, ProtocolFamily family,
339                                 SocketOption&lt;?&gt; name, Object value)
340         throws IOException
341     {
342         if (value == null)
343             throw new IllegalArgumentException(&quot;Invalid option value&quot;);
344 
345         // only simple values supported by this method
346         Class&lt;?&gt; type = name.type();
347 
348         if (extendedOptions.isOptionSupported(name)) {
349             extendedOptions.setOption(fd, name, value);
350             return;
351         }
352 
353         if (type != Integer.class &amp;&amp; type != Boolean.class)
354             throw new AssertionError(&quot;Should not reach here&quot;);
355 
356         // special handling
357         if (name == StandardSocketOptions.SO_RCVBUF ||
</pre>
<hr />
<pre>
380         }
381 
382         // map option name to platform level/name
383         OptionKey key = SocketOptionRegistry.findOption(name, family);
384         if (key == null)
385             throw new AssertionError(&quot;Option not found&quot;);
386 
387         int arg;
388         if (type == Integer.class) {
389             arg = ((Integer)value).intValue();
390         } else {
391             boolean b = ((Boolean)value).booleanValue();
392             arg = (b) ? 1 : 0;
393         }
394 
395         boolean mayNeedConversion = (family == UNSPEC);
396         boolean isIPv6 = (family == StandardProtocolFamily.INET6);
397         setIntOption0(fd, mayNeedConversion, key.level(), key.name(), arg, isIPv6);
398     }
399 
<span class="line-modified">400     static Object getSocketOption(FileDescriptor fd, SocketOption&lt;?&gt; name)</span>
<span class="line-modified">401         throws IOException</span>
<span class="line-added">402     {</span>
<span class="line-added">403         return getSocketOption(fd, Net.UNSPEC, name);</span>
<span class="line-added">404     }</span>
<span class="line-added">405 </span>
<span class="line-added">406     static Object getSocketOption(FileDescriptor fd, ProtocolFamily family, SocketOption&lt;?&gt; name)</span>
407         throws IOException
408     {
409         Class&lt;?&gt; type = name.type();
410 
411         if (extendedOptions.isOptionSupported(name)) {
412             return extendedOptions.getOption(fd, name);
413         }
414 
415         // only simple values supported by this method
416         if (type != Integer.class &amp;&amp; type != Boolean.class)
417             throw new AssertionError(&quot;Should not reach here&quot;);
418 
419         // map option name to platform level/name
420         OptionKey key = SocketOptionRegistry.findOption(name, family);
421         if (key == null)
422             throw new AssertionError(&quot;Option not found&quot;);
423 
424         boolean mayNeedConversion = (family == UNSPEC);
425         int value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());
426 
</pre>
<hr />
<pre>
431         }
432     }
433 
434     public static boolean isFastTcpLoopbackRequested() {
435         String loopbackProp = GetPropertyAction
436                 .privilegedGetProperty(&quot;jdk.net.useFastTcpLoopback&quot;, &quot;false&quot;);
437         return loopbackProp.isEmpty() ? true : Boolean.parseBoolean(loopbackProp);
438     }
439 
440     // -- Socket operations --
441 
442     private static native boolean isIPv6Available0();
443 
444     private static native boolean isReusePortAvailable0();
445 
446     /*
447      * Returns 1 for Windows and -1 for Solaris/Linux/Mac OS
448      */
449     private static native int isExclusiveBindAvailable();
450 
<span class="line-added">451     private static native boolean shouldSetBothIPv4AndIPv6Options0();</span>
<span class="line-added">452 </span>
453     private static native boolean canIPv6SocketJoinIPv4Group0();
454 
455     private static native boolean canJoin6WithIPv4Group0();
456 
<span class="line-added">457     private static native boolean canUseIPv6OptionsWithIPv4LocalAddress0();</span>
<span class="line-added">458 </span>
459     static FileDescriptor socket(boolean stream) throws IOException {
460         return socket(UNSPEC, stream);
461     }
462 
<span class="line-modified">463     static FileDescriptor socket(ProtocolFamily family, boolean stream) throws IOException {</span>

464         boolean preferIPv6 = isIPv6Available() &amp;&amp;
465             (family != StandardProtocolFamily.INET);
466         return IOUtil.newFD(socket0(preferIPv6, stream, false, fastLoopback));
467     }
468 
469     static FileDescriptor serverSocket(boolean stream) {
470         return IOUtil.newFD(socket0(isIPv6Available(), stream, true, fastLoopback));
471     }
472 
473     // Due to oddities SO_REUSEADDR on windows reuse is ignored
474     private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse,
475                                       boolean fastLoopback);
476 
477     public static void bind(FileDescriptor fd, InetAddress addr, int port)
478         throws IOException
479     {
480         bind(UNSPEC, fd, addr, port);
481     }
482 
483     static void bind(ProtocolFamily family, FileDescriptor fd,
484                      InetAddress addr, int port) throws IOException
485     {
486         boolean preferIPv6 = isIPv6Available() &amp;&amp;
487             (family != StandardProtocolFamily.INET);
<span class="line-added">488         if (addr.isLinkLocalAddress()) {</span>
<span class="line-added">489             addr = IPAddressUtil.toScopedAddress(addr);</span>
<span class="line-added">490         }</span>
491         bind0(fd, preferIPv6, exclusiveBind, addr, port);
492     }
493 
494     private static native void bind0(FileDescriptor fd, boolean preferIPv6,
495                                      boolean useExclBind, InetAddress addr,
496                                      int port)
497         throws IOException;
498 
499     static native void listen(FileDescriptor fd, int backlog) throws IOException;
500 
501     static int connect(FileDescriptor fd, InetAddress remote, int remotePort)
502         throws IOException
503     {
504         return connect(UNSPEC, fd, remote, remotePort);
505     }
506 
507     static int connect(ProtocolFamily family, FileDescriptor fd, InetAddress remote, int remotePort)
508         throws IOException
509     {
<span class="line-added">510         if (remote.isLinkLocalAddress()) {</span>
<span class="line-added">511             remote = IPAddressUtil.toScopedAddress(remote);</span>
<span class="line-added">512         }</span>
513         boolean preferIPv6 = isIPv6Available() &amp;&amp;
514             (family != StandardProtocolFamily.INET);
515         return connect0(preferIPv6, fd, remote, remotePort);
516     }
517 
518     private static native int connect0(boolean preferIPv6,
519                                        FileDescriptor fd,
520                                        InetAddress remote,
521                                        int remotePort)
522         throws IOException;
523 
<span class="line-added">524     public static native int accept(FileDescriptor fd,</span>
<span class="line-added">525                                     FileDescriptor newfd,</span>
<span class="line-added">526                                     InetSocketAddress[] isaa)</span>
<span class="line-added">527         throws IOException;</span>
528 
529     public static final int SHUT_RD = 0;
530     public static final int SHUT_WR = 1;
531     public static final int SHUT_RDWR = 2;
532 
533     static native void shutdown(FileDescriptor fd, int how) throws IOException;
534 
535     private static native int localPort(FileDescriptor fd)
536         throws IOException;
537 
538     private static native InetAddress localInetAddress(FileDescriptor fd)
539         throws IOException;
540 
541     public static InetSocketAddress localAddress(FileDescriptor fd)
542         throws IOException
543     {
544         return new InetSocketAddress(localInetAddress(fd), localPort(fd));
545     }
546 
547     private static native int remotePort(FileDescriptor fd)
548         throws IOException;
549 
550     private static native InetAddress remoteInetAddress(FileDescriptor fd)
551         throws IOException;
552 
553     static InetSocketAddress remoteAddress(FileDescriptor fd)
554         throws IOException
555     {
556         return new InetSocketAddress(remoteInetAddress(fd), remotePort(fd));
557     }
558 
559     private static native int getIntOption0(FileDescriptor fd, boolean mayNeedConversion,
560                                             int level, int opt)
561         throws IOException;
562 
563     private static native void setIntOption0(FileDescriptor fd, boolean mayNeedConversion,
564                                              int level, int opt, int arg, boolean isIPv6)
565         throws IOException;
566 
<span class="line-added">567     /**</span>
<span class="line-added">568      * Polls a file descriptor for events.</span>
<span class="line-added">569      * @param timeout the timeout to wait; 0 to not wait, -1 to wait indefinitely</span>
<span class="line-added">570      * @return the polled events or 0 if no events are polled</span>
<span class="line-added">571      */</span>
572     static native int poll(FileDescriptor fd, int events, long timeout)
573         throws IOException;
574 
<span class="line-added">575     /**</span>
<span class="line-added">576      * Performs a non-blocking poll of a file descriptor.</span>
<span class="line-added">577      * @return the polled events or 0 if no events are polled</span>
<span class="line-added">578      */</span>
<span class="line-added">579     static int pollNow(FileDescriptor fd, int events) throws IOException {</span>
<span class="line-added">580         return poll(fd, events, 0);</span>
<span class="line-added">581     }</span>
<span class="line-added">582 </span>
583     /**
584      * Polls a connecting socket to test if the connection has been established.
585      *
586      * @apiNote This method is public to allow it be used by code in jdk.sctp.
587      *
588      * @param timeout the timeout to wait; 0 to not wait, -1 to wait indefinitely
<span class="line-modified">589      * @return true if connected</span>
590      */
<span class="line-modified">591     public static native boolean pollConnect(FileDescriptor fd, long timeout)</span>
592         throws IOException;
593 
<span class="line-added">594     /**</span>
<span class="line-added">595      * Performs a non-blocking poll of a connecting socket to test if the</span>
<span class="line-added">596      * connection has been established.</span>
<span class="line-added">597      *</span>
<span class="line-added">598      * @return true if connected</span>
<span class="line-added">599      */</span>
<span class="line-added">600     static boolean pollConnectNow(FileDescriptor fd) throws IOException {</span>
<span class="line-added">601         return pollConnect(fd, 0);</span>
<span class="line-added">602     }</span>
<span class="line-added">603 </span>
604     /**
605      * Return the number of bytes in the socket input buffer.
606      */
607     static native int available(FileDescriptor fd) throws IOException;
608 
609     /**
610      * Send one byte of urgent data (MSG_OOB) on the socket.
611      */
612     static native int sendOOB(FileDescriptor fd, byte data) throws IOException;
613 
614 
615     // -- Multicast support --
616 
617     /**
618      * Join IPv4 multicast group
619      */
620     static int join4(FileDescriptor fd, int group, int interf, int source)
621         throws IOException
622     {
623         return joinOrDrop4(true, fd, group, interf, source);
</pre>
</td>
</tr>
</table>
<center><a href="NativeDispatcher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Reflect.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
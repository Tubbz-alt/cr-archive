<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DisabledAlgorithmConstraints.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import sun.security.validator.Validator;
 29 
<a name="2" id="anc2"></a>

 30 import java.security.CryptoPrimitive;
 31 import java.security.AlgorithmParameters;
 32 import java.security.Key;
 33 import java.security.cert.CertPathValidatorException;
 34 import java.security.cert.CertPathValidatorException.BasicReason;
 35 import java.security.cert.X509Certificate;
 36 import java.text.SimpleDateFormat;
 37 import java.util.ArrayList;
<a name="3" id="anc3"></a><span class="line-added"> 38 import java.util.Arrays;</span>
 39 import java.util.Calendar;
 40 import java.util.Date;
 41 import java.util.HashMap;
 42 import java.util.HashSet;
 43 import java.util.List;
 44 import java.util.Locale;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.Collection;
 48 import java.util.StringTokenizer;
 49 import java.util.TimeZone;
 50 import java.util.regex.Pattern;
 51 import java.util.regex.Matcher;
 52 
 53 /**
 54  * Algorithm constraints for disabled algorithms property
 55  *
 56  * See the &quot;jdk.certpath.disabledAlgorithms&quot; specification in java.security
 57  * for the syntax of the disabled algorithm string.
 58  */
 59 public class DisabledAlgorithmConstraints extends AbstractAlgorithmConstraints {
 60     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 61 
<a name="4" id="anc4"></a><span class="line-modified"> 62     // Disabled algorithm security property for certificate path</span>
 63     public static final String PROPERTY_CERTPATH_DISABLED_ALGS =
 64             &quot;jdk.certpath.disabledAlgorithms&quot;;
 65 
<a name="5" id="anc5"></a><span class="line-modified"> 66     // Disabled algorithm security property for TLS</span>
 67     public static final String PROPERTY_TLS_DISABLED_ALGS =
 68             &quot;jdk.tls.disabledAlgorithms&quot;;
 69 
<a name="6" id="anc6"></a><span class="line-modified"> 70     // Disabled algorithm security property for jar</span>
 71     public static final String PROPERTY_JAR_DISABLED_ALGS =
 72             &quot;jdk.jar.disabledAlgorithms&quot;;
 73 
<a name="7" id="anc7"></a><span class="line-modified"> 74     // Property for disabled EC named curves</span>
<span class="line-added"> 75     private static final String PROPERTY_DISABLED_EC_CURVES =</span>
<span class="line-added"> 76             &quot;jdk.disabled.namedCurves&quot;;</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     private final List&lt;String&gt; disabledAlgorithms;</span>
 79     private final Constraints algorithmConstraints;
 80 
 81     /**
 82      * Initialize algorithm constraints with the specified security property.
 83      *
 84      * @param propertyName the security property name that define the disabled
 85      *        algorithm constraints
 86      */
 87     public DisabledAlgorithmConstraints(String propertyName) {
 88         this(propertyName, new AlgorithmDecomposer());
 89     }
 90 
 91     /**
 92      * Initialize algorithm constraints with the specified security property
 93      * for a specific usage type.
 94      *
 95      * @param propertyName the security property name that define the disabled
 96      *        algorithm constraints
 97      * @param decomposer an alternate AlgorithmDecomposer.
 98      */
 99     public DisabledAlgorithmConstraints(String propertyName,
100             AlgorithmDecomposer decomposer) {
101         super(decomposer);
102         disabledAlgorithms = getAlgorithms(propertyName);
<a name="8" id="anc8"></a><span class="line-added">103 </span>
<span class="line-added">104         // Check for alias</span>
<span class="line-added">105         int ecindex = -1, i = 0;</span>
<span class="line-added">106         for (String s : disabledAlgorithms) {</span>
<span class="line-added">107             if (s.regionMatches(true, 0,&quot;include &quot;, 0, 8)) {</span>
<span class="line-added">108                 if (s.regionMatches(true, 8, PROPERTY_DISABLED_EC_CURVES, 0,</span>
<span class="line-added">109                         PROPERTY_DISABLED_EC_CURVES.length())) {</span>
<span class="line-added">110                     ecindex = i;</span>
<span class="line-added">111                     break;</span>
<span class="line-added">112                 }</span>
<span class="line-added">113             }</span>
<span class="line-added">114             i++;</span>
<span class="line-added">115         }</span>
<span class="line-added">116         if (ecindex &gt; -1) {</span>
<span class="line-added">117             disabledAlgorithms.remove(ecindex);</span>
<span class="line-added">118             disabledAlgorithms.addAll(ecindex,</span>
<span class="line-added">119                     getAlgorithms(PROPERTY_DISABLED_EC_CURVES));</span>
<span class="line-added">120         }</span>
121         algorithmConstraints = new Constraints(disabledAlgorithms);
122     }
123 
124     /*
125      * This only checks if the algorithm has been completely disabled.  If
126      * there are keysize or other limit, this method allow the algorithm.
127      */
128     @Override
129     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
130             String algorithm, AlgorithmParameters parameters) {
<a name="9" id="anc9"></a><span class="line-added">131         if (primitives == null || primitives.isEmpty()) {</span>
<span class="line-added">132             throw new IllegalArgumentException(&quot;The primitives cannot be null&quot; +</span>
<span class="line-added">133                     &quot; or empty.&quot;);</span>
<span class="line-added">134         }</span>
<span class="line-added">135 </span>
136         if (!checkAlgorithm(disabledAlgorithms, algorithm, decomposer)) {
137             return false;
138         }
139 
140         if (parameters != null) {
141             return algorithmConstraints.permits(algorithm, parameters);
142         }
143 
144         return true;
145     }
146 
147     /*
148      * Checks if the key algorithm has been disabled or constraints have been
149      * placed on the key.
150      */
151     @Override
152     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
153         return checkConstraints(primitives, &quot;&quot;, key, null);
154     }
155 
156     /*
157      * Checks if the key algorithm has been disabled or if constraints have
158      * been placed on the key.
159      */
160     @Override
161     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
162             String algorithm, Key key, AlgorithmParameters parameters) {
163 
164         if (algorithm == null || algorithm.isEmpty()) {
165             throw new IllegalArgumentException(&quot;No algorithm name specified&quot;);
166         }
167 
168         return checkConstraints(primitives, algorithm, key, parameters);
169     }
170 
171     public final void permits(ConstraintsParameters cp)
172             throws CertPathValidatorException {
173         permits(cp.getAlgorithm(), cp);
174     }
175 
176     public final void permits(String algorithm, Key key,
177             AlgorithmParameters params, String variant)
178             throws CertPathValidatorException {
179         permits(algorithm, new ConstraintsParameters(algorithm, params, key,
180                 (variant == null) ? Validator.VAR_GENERIC : variant));
181     }
182 
183     /*
184      * Check if a x509Certificate object is permitted.  Check if all
185      * algorithms are allowed, certificate constraints, and the
186      * public key against key constraints.
187      *
188      * Uses new style permit() which throws exceptions.
189      */
190 
191     public final void permits(String algorithm, ConstraintsParameters cp)
192             throws CertPathValidatorException {
<a name="10" id="anc10"></a><span class="line-added">193 </span>
<span class="line-added">194         // Check if named curves in the ConstraintParameters are disabled.</span>
<span class="line-added">195         if (cp.getNamedCurve() != null) {</span>
<span class="line-added">196             for (String curve : cp.getNamedCurve()) {</span>
<span class="line-added">197                 if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {</span>
<span class="line-added">198                     throw new CertPathValidatorException(</span>
<span class="line-added">199                             &quot;Algorithm constraints check failed on disabled &quot; +</span>
<span class="line-added">200                                     &quot;algorithm: &quot; + curve,</span>
<span class="line-added">201                             null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);</span>
<span class="line-added">202                 }</span>
<span class="line-added">203             }</span>
<span class="line-added">204         }</span>
<span class="line-added">205 </span>
206         algorithmConstraints.permits(algorithm, cp);
207     }
208 
209     // Check if a string is contained inside the property
210     public boolean checkProperty(String param) {
211         param = param.toLowerCase(Locale.ENGLISH);
212         for (String block : disabledAlgorithms) {
213             if (block.toLowerCase(Locale.ENGLISH).indexOf(param) &gt;= 0) {
214                 return true;
215             }
216         }
217         return false;
218     }
219 
220     // Check algorithm constraints with key and algorithm
221     private boolean checkConstraints(Set&lt;CryptoPrimitive&gt; primitives,
222             String algorithm, Key key, AlgorithmParameters parameters) {
223 
<a name="11" id="anc11"></a><span class="line-modified">224         if (primitives == null || primitives.isEmpty()) {</span>
<span class="line-added">225             throw new IllegalArgumentException(&quot;The primitives cannot be null&quot; +</span>
<span class="line-added">226                     &quot; or empty.&quot;);</span>
<span class="line-added">227         }</span>
<span class="line-added">228 </span>
229         if (key == null) {
230             throw new IllegalArgumentException(&quot;The key cannot be null&quot;);
231         }
232 
233         // check the signature algorithm with parameters
234         if (algorithm != null &amp;&amp; !algorithm.isEmpty()) {
235             if (!permits(primitives, algorithm, parameters)) {
236                 return false;
237             }
238         }
239 
240         // check the key algorithm
241         if (!permits(primitives, key.getAlgorithm(), null)) {
242             return false;
243         }
244 
<a name="12" id="anc12"></a><span class="line-added">245         // If this is an elliptic curve, check disabled the named curve.</span>
<span class="line-added">246         for (String curve : ConstraintsParameters.getNamedCurveFromKey(key)) {</span>
<span class="line-added">247             if (!permits(primitives, curve, null)) {</span>
<span class="line-added">248                 return false;</span>
<span class="line-added">249             }</span>
<span class="line-added">250         }</span>
<span class="line-added">251 </span>
252         // check the key constraints
253         return algorithmConstraints.permits(key);
254     }
255 
256 
257     /**
258      * Key and Certificate Constraints
259      *
260      * The complete disabling of an algorithm is not handled by Constraints or
261      * Constraint classes.  That is addressed with
262      *   permit(Set&lt;CryptoPrimitive&gt;, String, AlgorithmParameters)
263      *
264      * When passing a Key to permit(), the boolean return values follow the
265      * same as the interface class AlgorithmConstraints.permit().  This is to
266      * maintain compatibility:
267      * &#39;true&#39; means the operation is allowed.
268      * &#39;false&#39; means it failed the constraints and is disallowed.
269      *
270      * When passing ConstraintsParameters through permit(), an exception
271      * will be thrown on a failure to better identify why the operation was
272      * disallowed.
273      */
274 
275     private static class Constraints {
276         private Map&lt;String, List&lt;Constraint&gt;&gt; constraintsMap = new HashMap&lt;&gt;();
277 
278         private static class Holder {
279             private static final Pattern DENY_AFTER_PATTERN = Pattern.compile(
280                     &quot;denyAfter\\s+(\\d{4})-(\\d{2})-(\\d{2})&quot;);
281         }
282 
<a name="13" id="anc13"></a><span class="line-modified">283         public Constraints(List&lt;String&gt; constraintArray) {</span>
284             for (String constraintEntry : constraintArray) {
285                 if (constraintEntry == null || constraintEntry.isEmpty()) {
286                     continue;
287                 }
288 
289                 constraintEntry = constraintEntry.trim();
290                 if (debug != null) {
291                     debug.println(&quot;Constraints: &quot; + constraintEntry);
292                 }
293 
294                 // Check if constraint is a complete disabling of an
295                 // algorithm or has conditions.
296                 int space = constraintEntry.indexOf(&#39; &#39;);
297                 String algorithm = AlgorithmDecomposer.hashName(
298                         ((space &gt; 0 ? constraintEntry.substring(0, space) :
299                                 constraintEntry).
300                                 toUpperCase(Locale.ENGLISH)));
301                 List&lt;Constraint&gt; constraintList =
302                         constraintsMap.getOrDefault(algorithm,
303                                 new ArrayList&lt;&gt;(1));
304 
305                 // Consider the impact of algorithm aliases.
306                 for (String alias : AlgorithmDecomposer.getAliases(algorithm)) {
307                     constraintsMap.putIfAbsent(alias, constraintList);
308                 }
309 
<a name="14" id="anc14"></a><span class="line-modified">310                 // If there is no whitespace, it is a algorithm name; however,</span>
<span class="line-added">311                 // if there is a whitespace, could be a multi-word EC curve too.</span>
<span class="line-added">312                 if (space &lt;= 0 || CurveDB.lookup(constraintEntry) != null) {</span>
313                     constraintList.add(new DisabledConstraint(algorithm));
314                     continue;
315                 }
316 
317                 String policy = constraintEntry.substring(space + 1);
318 
319                 // Convert constraint conditions into Constraint classes
320                 Constraint c, lastConstraint = null;
321                 // Allow only one jdkCA entry per constraint entry
322                 boolean jdkCALimit = false;
323                 // Allow only one denyAfter entry per constraint entry
324                 boolean denyAfterLimit = false;
325 
326                 for (String entry : policy.split(&quot;&amp;&quot;)) {
327                     entry = entry.trim();
328 
329                     Matcher matcher;
330                     if (entry.startsWith(&quot;keySize&quot;)) {
331                         if (debug != null) {
332                             debug.println(&quot;Constraints set to keySize: &quot; +
333                                     entry);
334                         }
335                         StringTokenizer tokens = new StringTokenizer(entry);
336                         if (!&quot;keySize&quot;.equals(tokens.nextToken())) {
337                             throw new IllegalArgumentException(&quot;Error in &quot; +
338                                     &quot;security property. Constraint unknown: &quot; +
339                                     entry);
340                         }
341                         c = new KeySizeConstraint(algorithm,
342                                 KeySizeConstraint.Operator.of(tokens.nextToken()),
343                                 Integer.parseInt(tokens.nextToken()));
344 
345                     } else if (entry.equalsIgnoreCase(&quot;jdkCA&quot;)) {
346                         if (debug != null) {
347                             debug.println(&quot;Constraints set to jdkCA.&quot;);
348                         }
349                         if (jdkCALimit) {
350                             throw new IllegalArgumentException(&quot;Only one &quot; +
351                                     &quot;jdkCA entry allowed in property. &quot; +
352                                     &quot;Constraint: &quot; + constraintEntry);
353                         }
354                         c = new jdkCAConstraint(algorithm);
355                         jdkCALimit = true;
356 
357                     } else if (entry.startsWith(&quot;denyAfter&quot;) &amp;&amp;
358                             (matcher = Holder.DENY_AFTER_PATTERN.matcher(entry))
359                                     .matches()) {
360                         if (debug != null) {
361                             debug.println(&quot;Constraints set to denyAfter&quot;);
362                         }
363                         if (denyAfterLimit) {
364                             throw new IllegalArgumentException(&quot;Only one &quot; +
365                                     &quot;denyAfter entry allowed in property. &quot; +
366                                     &quot;Constraint: &quot; + constraintEntry);
367                         }
368                         int year = Integer.parseInt(matcher.group(1));
369                         int month = Integer.parseInt(matcher.group(2));
370                         int day = Integer.parseInt(matcher.group(3));
371                         c = new DenyAfterConstraint(algorithm, year, month,
372                                 day);
373                         denyAfterLimit = true;
374                     } else if (entry.startsWith(&quot;usage&quot;)) {
375                         String s[] = (entry.substring(5)).trim().split(&quot; &quot;);
376                         c = new UsageConstraint(algorithm, s);
377                         if (debug != null) {
378                             debug.println(&quot;Constraints usage length is &quot; + s.length);
379                         }
380                     } else {
381                         throw new IllegalArgumentException(&quot;Error in security&quot; +
382                                 &quot; property. Constraint unknown: &quot; + entry);
383                     }
384 
385                     // Link multiple conditions for a single constraint
386                     // into a linked list.
387                     if (lastConstraint == null) {
388                         constraintList.add(c);
389                     } else {
390                         lastConstraint.nextConstraint = c;
391                     }
392                     lastConstraint = c;
393                 }
394             }
395         }
396 
397         // Get applicable constraints based off the signature algorithm
398         private List&lt;Constraint&gt; getConstraints(String algorithm) {
399             return constraintsMap.get(algorithm);
400         }
401 
402         // Check if KeySizeConstraints permit the specified key
403         public boolean permits(Key key) {
404             List&lt;Constraint&gt; list = getConstraints(key.getAlgorithm());
405             if (list == null) {
406                 return true;
407             }
408             for (Constraint constraint : list) {
409                 if (!constraint.permits(key)) {
410                     if (debug != null) {
<a name="15" id="anc15"></a><span class="line-modified">411                         debug.println(&quot;Constraints: failed key size&quot; +</span>
412                                 &quot;constraint check &quot; + KeyUtil.getKeySize(key));
413                     }
414                     return false;
415                 }
416             }
417             return true;
418         }
419 
420         // Check if constraints permit this AlgorithmParameters.
421         public boolean permits(String algorithm, AlgorithmParameters aps) {
422             List&lt;Constraint&gt; list = getConstraints(algorithm);
423             if (list == null) {
424                 return true;
425             }
426 
427             for (Constraint constraint : list) {
428                 if (!constraint.permits(aps)) {
429                     if (debug != null) {
<a name="16" id="anc16"></a><span class="line-modified">430                         debug.println(&quot;Constraints: failed algorithm &quot; +</span>
431                                 &quot;parameters constraint check &quot; + aps);
432                     }
433 
434                     return false;
435                 }
436             }
437 
438             return true;
439         }
440 
441         // Check if constraints permit this cert.
442         public void permits(String algorithm, ConstraintsParameters cp)
443                 throws CertPathValidatorException {
444             X509Certificate cert = cp.getCertificate();
445 
446             if (debug != null) {
<a name="17" id="anc17"></a><span class="line-modified">447                 debug.println(&quot;Constraints.permits(): &quot; + cp.toString());</span>

448             }
449 
450             // Get all signature algorithms to check for constraints
451             Set&lt;String&gt; algorithms = new HashSet&lt;&gt;();
452             if (algorithm != null) {
453                 algorithms.addAll(AlgorithmDecomposer.decomposeOneHash(algorithm));
454             }
455 
456             // Attempt to add the public key algorithm if cert provided
457             if (cert != null) {
458                 algorithms.add(cert.getPublicKey().getAlgorithm());
459             }
<a name="18" id="anc18"></a><span class="line-modified">460             if (cp.getKey() != null) {</span>
<span class="line-modified">461                 algorithms.add(cp.getKey().getAlgorithm());</span>
462             }
463             // Check all applicable constraints
464             for (String alg : algorithms) {
465                 List&lt;Constraint&gt; list = getConstraints(alg);
466                 if (list == null) {
467                     continue;
468                 }
469                 for (Constraint constraint : list) {
470                     constraint.permits(cp);
471                 }
472             }
473         }
474     }
475 
476     /**
477      * This abstract Constraint class for algorithm-based checking
478      * may contain one or more constraints.  If the &#39;&amp;&#39; on the {@Security}
479      * property is used, multiple constraints have been grouped together
480      * requiring all the constraints to fail for the check to be disallowed.
481      *
482      * If the class contains multiple constraints, the next constraint
483      * is stored in {@code nextConstraint} in linked-list fashion.
484      */
485     private abstract static class Constraint {
486         String algorithm;
487         Constraint nextConstraint = null;
488 
489         // operator
490         enum Operator {
491             EQ,         // &quot;==&quot;
492             NE,         // &quot;!=&quot;
493             LT,         // &quot;&lt;&quot;
494             LE,         // &quot;&lt;=&quot;
495             GT,         // &quot;&gt;&quot;
496             GE;         // &quot;&gt;=&quot;
497 
498             static Operator of(String s) {
499                 switch (s) {
500                     case &quot;==&quot;:
501                         return EQ;
502                     case &quot;!=&quot;:
503                         return NE;
504                     case &quot;&lt;&quot;:
505                         return LT;
506                     case &quot;&lt;=&quot;:
507                         return LE;
508                     case &quot;&gt;&quot;:
509                         return GT;
510                     case &quot;&gt;=&quot;:
511                         return GE;
512                 }
513 
514                 throw new IllegalArgumentException(&quot;Error in security &quot; +
515                         &quot;property. &quot; + s + &quot; is not a legal Operator&quot;);
516             }
517         }
518 
519         /**
520          * Check if an algorithm constraint is permitted with a given key.
521          *
522          * If the check inside of {@code permit()} fails, it must call
523          * {@code next()} with the same {@code Key} parameter passed if
524          * multiple constraints need to be checked.
525          *
526          * @param key Public key
527          * @return &#39;true&#39; if constraint is allowed, &#39;false&#39; if disallowed.
528          */
529         public boolean permits(Key key) {
530             return true;
531         }
532 
533         /**
534          * Check if the algorithm constraint permits a given cryptographic
535          * parameters.
536          *
537          * @param parameters the cryptographic parameters
538          * @return &#39;true&#39; if the cryptographic parameters is allowed,
539          *         &#39;false&#39; ortherwise.
540          */
541         public boolean permits(AlgorithmParameters parameters) {
542             return true;
543         }
544 
545         /**
546          * Check if an algorithm constraint is permitted with a given
547          * ConstraintsParameters.
548          *
549          * If the check inside of {@code permits()} fails, it must call
550          * {@code next()} with the same {@code ConstraintsParameters}
551          * parameter passed if multiple constraints need to be checked.
552          *
553          * @param cp CertConstraintParameter containing certificate info
554          * @throws CertPathValidatorException if constraint disallows.
555          *
556          */
557         public abstract void permits(ConstraintsParameters cp)
558                 throws CertPathValidatorException;
559 
560         /**
561          * Recursively check if the constraints are allowed.
562          *
563          * If {@code nextConstraint} is non-null, this method will
564          * call {@code nextConstraint}&#39;s {@code permits()} to check if the
565          * constraint is allowed or denied.  If the constraint&#39;s
566          * {@code permits()} is allowed, this method will exit this and any
567          * recursive next() calls, returning &#39;true&#39;.  If the constraints called
568          * were disallowed, the last constraint will throw
569          * {@code CertPathValidatorException}.
570          *
571          * @param cp ConstraintsParameters
572          * @return &#39;true&#39; if constraint allows the operation, &#39;false&#39; if
573          * we are at the end of the constraint list or,
574          * {@code nextConstraint} is null.
575          */
576         boolean next(ConstraintsParameters cp)
577                 throws CertPathValidatorException {
578             if (nextConstraint != null) {
579                 nextConstraint.permits(cp);
580                 return true;
581             }
582             return false;
583         }
584 
585         /**
586          * Recursively check if this constraint is allowed,
587          *
588          * If {@code nextConstraint} is non-null, this method will
589          * call {@code nextConstraint}&#39;s {@code permit()} to check if the
590          * constraint is allowed or denied.  If the constraint&#39;s
591          * {@code permit()} is allowed, this method will exit this and any
592          * recursive next() calls, returning &#39;true&#39;.  If the constraints
593          * called were disallowed the check will exit with &#39;false&#39;.
594          *
595          * @param key Public key
596          * @return &#39;true&#39; if constraint allows the operation, &#39;false&#39; if
597          * the constraint denies the operation.
598          */
599         boolean next(Key key) {
<a name="19" id="anc19"></a><span class="line-modified">600             return nextConstraint != null &amp;&amp; nextConstraint.permits(key);</span>



601         }
602 
603         String extendedMsg(ConstraintsParameters cp) {
604             return (cp.getCertificate() == null ? &quot;.&quot; :
605                     &quot; used with certificate: &quot; +
606                             cp.getCertificate().getSubjectX500Principal() +
607                     (cp.getVariant() != Validator.VAR_GENERIC ?
608                             &quot;.  Usage was &quot; + cp.getVariant() : &quot;.&quot;));
609         }
610     }
611 
612     /*
613      * This class contains constraints dealing with the certificate chain
614      * of the certificate.
615      */
616     private static class jdkCAConstraint extends Constraint {
617         jdkCAConstraint(String algo) {
618             algorithm = algo;
619         }
620 
621         /*
622          * Check if ConstraintsParameters has a trusted match, if it does
623          * call next() for any following constraints. If it does not, exit
624          * as this constraint(s) does not restrict the operation.
625          */
626         @Override
627         public void permits(ConstraintsParameters cp)
628                 throws CertPathValidatorException {
629             if (debug != null) {
630                 debug.println(&quot;jdkCAConstraints.permits(): &quot; + algorithm);
631             }
632 
633             // Check chain has a trust anchor in cacerts
634             if (cp.isTrustedMatch()) {
635                 if (next(cp)) {
636                     return;
637                 }
638                 throw new CertPathValidatorException(
639                         &quot;Algorithm constraints check failed on certificate &quot; +
640                         &quot;anchor limits. &quot; + algorithm + extendedMsg(cp),
641                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
642             }
643         }
644     }
645 
646     /*
647      * This class handles the denyAfter constraint.  The date is in the UTC/GMT
648      * timezone.
649      */
650     private static class DenyAfterConstraint extends Constraint {
651         private Date denyAfterDate;
652         private static final SimpleDateFormat dateFormat =
653                 new SimpleDateFormat(&quot;EEE, MMM d HH:mm:ss z yyyy&quot;);
654 
655         DenyAfterConstraint(String algo, int year, int month, int day) {
656             Calendar c;
657 
658             algorithm = algo;
659 
660             if (debug != null) {
661                 debug.println(&quot;DenyAfterConstraint read in as:  year &quot; +
662                         year + &quot;, month = &quot; + month + &quot;, day = &quot; + day);
663             }
664 
665             c = new Calendar.Builder().setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;))
666                     .setDate(year, month - 1, day).build();
667 
668             if (year &gt; c.getActualMaximum(Calendar.YEAR) ||
669                     year &lt; c.getActualMinimum(Calendar.YEAR)) {
670                 throw new IllegalArgumentException(
671                         &quot;Invalid year given in constraint: &quot; + year);
672             }
673             if ((month - 1) &gt; c.getActualMaximum(Calendar.MONTH) ||
674                     (month - 1) &lt; c.getActualMinimum(Calendar.MONTH)) {
675                 throw new IllegalArgumentException(
676                         &quot;Invalid month given in constraint: &quot; + month);
677             }
678             if (day &gt; c.getActualMaximum(Calendar.DAY_OF_MONTH) ||
679                     day &lt; c.getActualMinimum(Calendar.DAY_OF_MONTH)) {
680                 throw new IllegalArgumentException(
681                         &quot;Invalid Day of Month given in constraint: &quot; + day);
682             }
683 
684             denyAfterDate = c.getTime();
685             if (debug != null) {
686                 debug.println(&quot;DenyAfterConstraint date set to: &quot; +
687                         dateFormat.format(denyAfterDate));
688             }
689         }
690 
691         /*
692          * Checking that the provided date is not beyond the constraint date.
693          * The provided date can be the PKIXParameter date if given,
694          * otherwise it is the current date.
695          *
696          * If the constraint disallows, call next() for any following
697          * constraints. Throw an exception if this is the last constraint.
698          */
699         @Override
700         public void permits(ConstraintsParameters cp)
701                 throws CertPathValidatorException {
702             Date currentDate;
703             String errmsg;
704 
705             if (cp.getJARTimestamp() != null) {
706                 currentDate = cp.getJARTimestamp().getTimestamp();
707                 errmsg = &quot;JAR Timestamp date: &quot;;
708             } else if (cp.getPKIXParamDate() != null) {
709                 currentDate = cp.getPKIXParamDate();
710                 errmsg = &quot;PKIXParameter date: &quot;;
711             } else {
712                 currentDate = new Date();
713                 errmsg = &quot;Current date: &quot;;
714             }
715 
716             if (!denyAfterDate.after(currentDate)) {
717                 if (next(cp)) {
718                     return;
719                 }
720                 throw new CertPathValidatorException(
721                         &quot;denyAfter constraint check failed: &quot; + algorithm +
722                         &quot; used with Constraint date: &quot; +
723                         dateFormat.format(denyAfterDate) + &quot;; &quot; + errmsg +
724                         dateFormat.format(currentDate) + extendedMsg(cp),
725                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
726             }
727         }
728 
729         /*
730          * Return result if the constraint&#39;s date is beyond the current date
731          * in UTC timezone.
732          */
733         @Override
734         public boolean permits(Key key) {
735             if (next(key)) {
736                 return true;
737             }
738             if (debug != null) {
739                 debug.println(&quot;DenyAfterConstraints.permits(): &quot; + algorithm);
740             }
741 
742             return denyAfterDate.after(new Date());
743         }
744     }
745 
746     /*
747      * The usage constraint is for the &quot;usage&quot; keyword.  It checks against the
748      * variant value in ConstraintsParameters.
749      */
750     private static class UsageConstraint extends Constraint {
751         String[] usages;
752 
753         UsageConstraint(String algorithm, String[] usages) {
754             this.algorithm = algorithm;
755             this.usages = usages;
756         }
757 
758         @Override
759         public void permits(ConstraintsParameters cp)
760                 throws CertPathValidatorException {
761             for (String usage : usages) {
762 
763                 String v = null;
764                 if (usage.compareToIgnoreCase(&quot;TLSServer&quot;) == 0) {
765                     v = Validator.VAR_TLS_SERVER;
766                 } else if (usage.compareToIgnoreCase(&quot;TLSClient&quot;) == 0) {
767                     v = Validator.VAR_TLS_CLIENT;
768                 } else if (usage.compareToIgnoreCase(&quot;SignedJAR&quot;) == 0) {
769                     v = Validator.VAR_PLUGIN_CODE_SIGNING;
770                 }
771 
772                 if (debug != null) {
773                     debug.println(&quot;Checking if usage constraint \&quot;&quot; + v +
774                             &quot;\&quot; matches \&quot;&quot; + cp.getVariant() + &quot;\&quot;&quot;);
775                     if (Debug.isVerbose()) {
776                         // Because usage checking can come from many places
777                         // a stack trace is very helpful.
778                         (new Exception()).printStackTrace(debug.getPrintStream());
779                     }
780                 }
781                 if (cp.getVariant().compareTo(v) == 0) {
782                     if (next(cp)) {
783                         return;
784                     }
785                     throw new CertPathValidatorException(&quot;Usage constraint &quot; +
786                             usage + &quot; check failed: &quot; + algorithm +
787                             extendedMsg(cp),
788                             null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
789                 }
790             }
791         }
792     }
793 
794     /*
795      * This class contains constraints dealing with the key size
796      * support limits per algorithm.   e.g.  &quot;keySize &lt;= 1024&quot;
797      */
798     private static class KeySizeConstraint extends Constraint {
799 
800         private int minSize;            // the minimal available key size
801         private int maxSize;            // the maximal available key size
802         private int prohibitedSize = -1;    // unavailable key sizes
803 
804         public KeySizeConstraint(String algo, Operator operator, int length) {
805             algorithm = algo;
806             switch (operator) {
807                 case EQ:      // an unavailable key size
808                     this.minSize = 0;
809                     this.maxSize = Integer.MAX_VALUE;
810                     prohibitedSize = length;
811                     break;
812                 case NE:
813                     this.minSize = length;
814                     this.maxSize = length;
815                     break;
816                 case LT:
817                     this.minSize = length;
818                     this.maxSize = Integer.MAX_VALUE;
819                     break;
820                 case LE:
821                     this.minSize = length + 1;
822                     this.maxSize = Integer.MAX_VALUE;
823                     break;
824                 case GT:
825                     this.minSize = 0;
826                     this.maxSize = length;
827                     break;
828                 case GE:
829                     this.minSize = 0;
830                     this.maxSize = length &gt; 1 ? (length - 1) : 0;
831                     break;
832                 default:
833                     // unlikely to happen
834                     this.minSize = Integer.MAX_VALUE;
835                     this.maxSize = -1;
836             }
837         }
838 
839         /*
840          * If we are passed a certificate, extract the public key and use it.
841          *
842          * Check if each constraint fails and check if there is a linked
843          * constraint  Any permitted constraint will exit the linked list
844          * to allow the operation.
845          */
846         @Override
847         public void permits(ConstraintsParameters cp)
848                 throws CertPathValidatorException {
849             Key key = null;
<a name="20" id="anc20"></a><span class="line-modified">850             if (cp.getKey() != null) {</span>
<span class="line-modified">851                 key = cp.getKey();</span>
852             } else if (cp.getCertificate() != null) {
853                 key = cp.getCertificate().getPublicKey();
854             }
855             if (key != null &amp;&amp; !permitsImpl(key)) {
856                 if (nextConstraint != null) {
857                     nextConstraint.permits(cp);
858                     return;
859                 }
860                 throw new CertPathValidatorException(
861                         &quot;Algorithm constraints check failed on keysize limits. &quot; +
862                         algorithm + &quot; &quot; + KeyUtil.getKeySize(key) + &quot;bit key&quot; +
863                         extendedMsg(cp),
864                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
865             }
866         }
867 
868 
869         // Check if key constraint disable the specified key
870         // Uses old style permit()
871         @Override
872         public boolean permits(Key key) {
873             // If we recursively find a constraint that permits us to use
874             // this key, return true and skip any other constraint checks.
875             if (nextConstraint != null &amp;&amp; nextConstraint.permits(key)) {
876                 return true;
877             }
878             if (debug != null) {
879                 debug.println(&quot;KeySizeConstraints.permits(): &quot; + algorithm);
880             }
881 
882             return permitsImpl(key);
883         }
884 
885         @Override
886         public boolean permits(AlgorithmParameters parameters) {
887             String paramAlg = parameters.getAlgorithm();
888             if (!algorithm.equalsIgnoreCase(parameters.getAlgorithm())) {
889                 // Consider the impact of the algorithm aliases.
890                 Collection&lt;String&gt; aliases =
891                         AlgorithmDecomposer.getAliases(algorithm);
892                 if (!aliases.contains(paramAlg)) {
893                     return true;
894                 }
895             }
896 
897             int keySize = KeyUtil.getKeySize(parameters);
898             if (keySize == 0) {
899                 return false;
900             } else if (keySize &gt; 0) {
901                 return !((keySize &lt; minSize) || (keySize &gt; maxSize) ||
902                     (prohibitedSize == keySize));
903             }   // Otherwise, the key size is not accessible or determined.
904                 // Conservatively, please don&#39;t disable such keys.
905 
906             return true;
907         }
908 
909         private boolean permitsImpl(Key key) {
910             // Verify this constraint is for this public key algorithm
911             if (algorithm.compareToIgnoreCase(key.getAlgorithm()) != 0) {
912                 return true;
913             }
914 
915             int size = KeyUtil.getKeySize(key);
916             if (size == 0) {
917                 return false;    // we don&#39;t allow any key of size 0.
918             } else if (size &gt; 0) {
919                 return !((size &lt; minSize) || (size &gt; maxSize) ||
920                     (prohibitedSize == size));
921             }   // Otherwise, the key size is not accessible. Conservatively,
922                 // please don&#39;t disable such keys.
923 
924             return true;
925         }
926     }
927 
928     /*
929      * This constraint is used for the complete disabling of the algorithm.
930      */
931     private static class DisabledConstraint extends Constraint {
932         DisabledConstraint(String algo) {
933             algorithm = algo;
934         }
935 
936         @Override
937         public void permits(ConstraintsParameters cp)
938                 throws CertPathValidatorException {
939             throw new CertPathValidatorException(
940                     &quot;Algorithm constraints check failed on disabled &quot; +
941                             &quot;algorithm: &quot; + algorithm + extendedMsg(cp),
942                     null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
943         }
944 
945         @Override
946         public boolean permits(Key key) {
947             return false;
948         }
949     }
950 }
951 
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
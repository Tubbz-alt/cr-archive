<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/Utilities.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.math.BigInteger;
 29 import java.util.*;
 30 import java.util.regex.Pattern;
 31 import javax.net.ssl.*;
 32 import sun.net.util.IPAddressUtil;
 33 import sun.security.action.GetPropertyAction;
 34 
 35 /**
 36  * A utility class to share the static methods.
 37  */
 38 final class Utilities {
 39     static final char[] hexDigits = &quot;0123456789ABCDEF&quot;.toCharArray();
 40     private static final String indent = &quot;  &quot;;
 41     private static final Pattern lineBreakPatern =
 42                 Pattern.compile(&quot;\\r\\n|\\n|\\r&quot;);
 43 
 44     /**
 45      * Puts {@code hostname} into the {@code serverNames} list.
 46      * &lt;P&gt;
 47      * If the {@code serverNames} does not look like a legal FQDN, it will
 48      * not be put into the returned list.
 49      * &lt;P&gt;
 50      * Note that the returned list does not allow duplicated name type.
 51      *
 52      * @return a list of {@link SNIServerName}
 53      */
 54     static List&lt;SNIServerName&gt; addToSNIServerNameList(
 55             List&lt;SNIServerName&gt; serverNames, String hostname) {
 56 
 57         SNIHostName sniHostName = rawToSNIHostName(hostname);
 58         if (sniHostName == null) {
 59             return serverNames;
 60         }
 61 
 62         int size = serverNames.size();
 63         List&lt;SNIServerName&gt; sniList = (size != 0) ?
 64                 new ArrayList&lt;SNIServerName&gt;(serverNames) :
 65                 new ArrayList&lt;SNIServerName&gt;(1);
 66 
 67         boolean reset = false;
 68         for (int i = 0; i &lt; size; i++) {
 69             SNIServerName serverName = sniList.get(i);
 70             if (serverName.getType() == StandardConstants.SNI_HOST_NAME) {
 71                 sniList.set(i, sniHostName);
 72                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 73                      SSLLogger.fine(
 74                         &quot;the previous server name in SNI (&quot; + serverName +
 75                         &quot;) was replaced with (&quot; + sniHostName + &quot;)&quot;);
 76                 }
 77                 reset = true;
 78                 break;
 79             }
 80         }
 81 
 82         if (!reset) {
 83             sniList.add(sniHostName);
 84         }
 85 
 86         return Collections.&lt;SNIServerName&gt;unmodifiableList(sniList);
 87     }
 88 
 89     /**
 90      * Converts string hostname to {@code SNIHostName}.
 91      * &lt;P&gt;
 92      * Note that to check whether a hostname is a valid domain name, we cannot
 93      * use the hostname resolved from name services.  For virtual hosting,
 94      * multiple hostnames may be bound to the same IP address, so the hostname
 95      * resolved from name services is not always reliable.
 96      *
 97      * @param  hostname
 98      *         the raw hostname
 99      * @return an instance of {@link SNIHostName}, or null if the hostname does
100      *         not look like a FQDN
101      */
102     private static SNIHostName rawToSNIHostName(String hostname) {
103         SNIHostName sniHostName = null;
104         if (hostname != null &amp;&amp; hostname.indexOf(&#39;.&#39;) &gt; 0 &amp;&amp;
105                 !hostname.endsWith(&quot;.&quot;) &amp;&amp;
106                 !IPAddressUtil.isIPv4LiteralAddress(hostname) &amp;&amp;
107                 !IPAddressUtil.isIPv6LiteralAddress(hostname)) {
108 
109             try {
110                 sniHostName = new SNIHostName(hostname);
111             } catch (IllegalArgumentException iae) {
112                 // don&#39;t bother to handle illegal host_name
113                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
114                      SSLLogger.fine(hostname + &quot;\&quot; &quot; +
115                         &quot;is not a legal HostName for  server name indication&quot;);
116                 }
117             }
118         }
119 
120         return sniHostName;
121     }
122 
123     /**
124      * Return the value of the boolean System property propName.
125      *
126      * Note use of privileged action. Do NOT make accessible to applications.
127      */
128     static boolean getBooleanProperty(String propName, boolean defaultValue) {
129         // if set, require value of either true or false
130         String b = GetPropertyAction.privilegedGetProperty(propName);
131         if (b == null) {
132             return defaultValue;
133         } else if (b.equalsIgnoreCase(&quot;false&quot;)) {
134             return false;
135         } else if (b.equalsIgnoreCase(&quot;true&quot;)) {
136             return true;
137         } else {
138             throw new RuntimeException(&quot;Value of &quot; + propName
139                 + &quot; must either be &#39;true&#39; or &#39;false&#39;&quot;);
140         }
141     }
142 
143     static String indent(String source) {
144         return Utilities.indent(source, indent);
145     }
146 
147     static String indent(String source, String prefix) {
148         StringBuilder builder = new StringBuilder();
149         if (source == null) {
150              builder.append(&quot;\n&quot; + prefix + &quot;&lt;blank message&gt;&quot;);
151         } else {
152             String[] lines = lineBreakPatern.split(source);
153             boolean isFirst = true;
154             for (String line : lines) {
155                 if (isFirst) {
156                     isFirst = false;
157                 } else {
158                     builder.append(&quot;\n&quot;);
159                 }
160                 builder.append(prefix).append(line);
161             }
162         }
163 
164         return builder.toString();
165     }
166 
167     static String toHexString(byte b) {
168         return String.valueOf(hexDigits[(b &gt;&gt; 4) &amp; 0x0F]) +
169                 String.valueOf(hexDigits[b &amp; 0x0F]);
170     }
171 
172     static String byte16HexString(int id) {
173         return &quot;0x&quot; +
174                 hexDigits[(id &gt;&gt; 12) &amp; 0x0F] + hexDigits[(id &gt;&gt; 8) &amp; 0x0F] +
175                 hexDigits[(id &gt;&gt; 4) &amp; 0x0F] + hexDigits[id &amp; 0x0F];
176     }
177 
178     static String toHexString(byte[] bytes) {
179         if (bytes == null || bytes.length == 0) {
180             return &quot;&quot;;
181         }
182 
183         StringBuilder builder = new StringBuilder(bytes.length * 3);
184         boolean isFirst = true;
185         for (byte b : bytes) {
186             if (isFirst) {
187                 isFirst = false;
188             } else {
189                 builder.append(&#39; &#39;);
190             }
191 
192             builder.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0F]);
193             builder.append(hexDigits[b &amp; 0x0F]);
194         }
195         return builder.toString();
196     }
197 
198     static String toHexString(long lv) {
199         StringBuilder builder = new StringBuilder(128);
200 
201         boolean isFirst = true;
202         do {
203             if (isFirst) {
204                 isFirst = false;
205             } else {
206                 builder.append(&#39; &#39;);
207             }
208 
209             builder.append(hexDigits[(int)(lv &amp; 0x0F)]);
210             lv &gt;&gt;&gt;= 4;
211             builder.append(hexDigits[(int)(lv &amp; 0x0F)]);
212             lv &gt;&gt;&gt;= 4;
213         } while (lv != 0);
214         builder.reverse();
215 
216         return builder.toString();
217     }
218 
219     /**
220      * Utility method to convert a BigInteger to a byte array in unsigned
221      * format as needed in the handshake messages. BigInteger uses
222      * 2&#39;s complement format, i.e. it prepends an extra zero if the MSB
223      * is set. We remove that.
224      */
225     static byte[] toByteArray(BigInteger bi) {
226         byte[] b = bi.toByteArray();
227         if ((b.length &gt; 1) &amp;&amp; (b[0] == 0)) {
228             int n = b.length - 1;
229             byte[] newarray = new byte[n];
230             System.arraycopy(b, 1, newarray, 0, n);
231             b = newarray;
232         }
233         return b;
234     }
235 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-added"> 29 import java.io.InputStream;</span>
 30 import java.util.ArrayList;
<a name="3" id="anc3"></a><span class="line-added"> 31 import java.util.Arrays;</span>
 32 
 33 /**
 34  * A package private utility class to convert indefinite length DER
 35  * encoded byte arrays to definite length DER encoded byte arrays.
 36  *
 37  * This assumes that the basic data structure is &quot;tag, length, value&quot;
 38  * triplet. In the case where the length is &quot;indefinite&quot;, terminating
 39  * end-of-contents bytes are expected.
 40  *
 41  * @author Hemma Prafullchandra
 42  */
 43 class DerIndefLenConverter {
 44 
 45     private static final int TAG_MASK            = 0x1f; // bits 5-1
 46     private static final int FORM_MASK           = 0x20; // bits 6
 47     private static final int CLASS_MASK          = 0xC0; // bits 8 and 7
 48 
 49     private static final int LEN_LONG            = 0x80; // bit 8 set
 50     private static final int LEN_MASK            = 0x7f; // bits 7 - 1
 51     private static final int SKIP_EOC_BYTES      = 2;
 52 
 53     private byte[] data, newData;
 54     private int newDataPos, dataPos, dataSize, index;
 55     private int unresolved = 0;
 56 
 57     private ArrayList&lt;Object&gt; ndefsList = new ArrayList&lt;Object&gt;();
 58 
 59     private int numOfTotalLenBytes = 0;
 60 
 61     private boolean isEOC(int tag) {
 62         return (((tag &amp; TAG_MASK) == 0x00) &amp;&amp;  // EOC
 63                 ((tag &amp; FORM_MASK) == 0x00) &amp;&amp; // primitive
 64                 ((tag &amp; CLASS_MASK) == 0x00)); // universal
 65     }
 66 
 67     // if bit 8 is set then it implies either indefinite length or long form
 68     static boolean isLongForm(int lengthByte) {
 69         return ((lengthByte &amp; LEN_LONG) == LEN_LONG);
 70     }
 71 
 72     /*
 73      * Default package private constructor
 74      */
 75     DerIndefLenConverter() { }
 76 
 77     /**
 78      * Checks whether the given length byte is of the form
 79      * &lt;em&gt;Indefinite&lt;/em&gt;.
 80      *
 81      * @param lengthByte the length byte from a DER encoded
 82      *        object.
 83      * @return true if the byte is of Indefinite form otherwise
 84      *         returns false.
 85      */
 86     static boolean isIndefinite(int lengthByte) {
 87         return (isLongForm(lengthByte) &amp;&amp; ((lengthByte &amp; LEN_MASK) == 0));
 88     }
 89 
 90     /**
 91      * Parse the tag and if it is an end-of-contents tag then
 92      * add the current position to the &lt;code&gt;eocList&lt;/code&gt; vector.
 93      */
 94     private void parseTag() throws IOException {
<a name="4" id="anc4"></a>

 95         if (isEOC(data[dataPos]) &amp;&amp; (data[dataPos + 1] == 0)) {
 96             int numOfEncapsulatedLenBytes = 0;
 97             Object elem = null;
 98             int index;
 99             for (index = ndefsList.size()-1; index &gt;= 0; index--) {
100                 // Determine the first element in the vector that does not
101                 // have a matching EOC
102                 elem = ndefsList.get(index);
103                 if (elem instanceof Integer) {
104                     break;
105                 } else {
106                     numOfEncapsulatedLenBytes += ((byte[])elem).length - 3;
107                 }
108             }
109             if (index &lt; 0) {
110                 throw new IOException(&quot;EOC does not have matching &quot; +
111                                       &quot;indefinite-length tag&quot;);
112             }
113             int sectionLen = dataPos - ((Integer)elem).intValue() +
114                              numOfEncapsulatedLenBytes;
115             byte[] sectionLenBytes = getLengthBytes(sectionLen);
116             ndefsList.set(index, sectionLenBytes);
117             unresolved--;
118 
119             // Add the number of bytes required to represent this section
120             // to the total number of length bytes,
121             // and subtract the indefinite-length tag (1 byte) and
122             // EOC bytes (2 bytes) for this section
123             numOfTotalLenBytes += (sectionLenBytes.length - 3);
124         }
125         dataPos++;
126     }
127 
128     /**
129      * Write the tag and if it is an end-of-contents tag
130      * then skip the tag and its 1 byte length of zero.
131      */
132     private void writeTag() {
133         if (dataPos == dataSize)
134             return;
135         int tag = data[dataPos++];
136         if (isEOC(tag) &amp;&amp; (data[dataPos] == 0)) {
137             dataPos++;  // skip length
138             writeTag();
139         } else
140             newData[newDataPos++] = (byte)tag;
141     }
142 
143     /**
144      * Parse the length and if it is an indefinite length then add
145      * the current position to the &lt;code&gt;ndefsList&lt;/code&gt; vector.
<a name="5" id="anc5"></a><span class="line-added">146      *</span>
<span class="line-added">147      * @return the length of definite length data next, or -1 if there is</span>
<span class="line-added">148      *         not enough bytes to determine it</span>
<span class="line-added">149      * @throws IOException if invalid data is read</span>
150      */
151     private int parseLength() throws IOException {
152         int curLen = 0;
153         if (dataPos == dataSize)
154             return curLen;
155         int lenByte = data[dataPos++] &amp; 0xff;
156         if (isIndefinite(lenByte)) {
157             ndefsList.add(dataPos);
158             unresolved++;
159             return curLen;
160         }
161         if (isLongForm(lenByte)) {
162             lenByte &amp;= LEN_MASK;
163             if (lenByte &gt; 4) {
164                 throw new IOException(&quot;Too much data&quot;);
165             }
166             if ((dataSize - dataPos) &lt; (lenByte + 1)) {
<a name="6" id="anc6"></a><span class="line-modified">167                 return -1;</span>
168             }
169             for (int i = 0; i &lt; lenByte; i++) {
170                 curLen = (curLen &lt;&lt; 8) + (data[dataPos++] &amp; 0xff);
171             }
172             if (curLen &lt; 0) {
173                 throw new IOException(&quot;Invalid length bytes&quot;);
174             }
175         } else {
176            curLen = (lenByte &amp; LEN_MASK);
177         }
178         return curLen;
179     }
180 
181     /**
182      * Write the length and if it is an indefinite length
183      * then calculate the definite length from the positions
184      * of the indefinite length and its matching EOC terminator.
185      * Then, write the value.
186      */
187     private void writeLengthAndValue() throws IOException {
188         if (dataPos == dataSize)
189            return;
190         int curLen = 0;
191         int lenByte = data[dataPos++] &amp; 0xff;
192         if (isIndefinite(lenByte)) {
193             byte[] lenBytes = (byte[])ndefsList.get(index++);
194             System.arraycopy(lenBytes, 0, newData, newDataPos,
195                              lenBytes.length);
196             newDataPos += lenBytes.length;
197             return;
198         }
199         if (isLongForm(lenByte)) {
200             lenByte &amp;= LEN_MASK;
201             for (int i = 0; i &lt; lenByte; i++) {
202                 curLen = (curLen &lt;&lt; 8) + (data[dataPos++] &amp; 0xff);
203             }
204             if (curLen &lt; 0) {
205                 throw new IOException(&quot;Invalid length bytes&quot;);
206             }
207         } else {
208             curLen = (lenByte &amp; LEN_MASK);
209         }
210         writeLength(curLen);
211         writeValue(curLen);
212     }
213 
214     private void writeLength(int curLen) {
215         if (curLen &lt; 128) {
216             newData[newDataPos++] = (byte)curLen;
217 
218         } else if (curLen &lt; (1 &lt;&lt; 8)) {
219             newData[newDataPos++] = (byte)0x81;
220             newData[newDataPos++] = (byte)curLen;
221 
222         } else if (curLen &lt; (1 &lt;&lt; 16)) {
223             newData[newDataPos++] = (byte)0x82;
224             newData[newDataPos++] = (byte)(curLen &gt;&gt; 8);
225             newData[newDataPos++] = (byte)curLen;
226 
227         } else if (curLen &lt; (1 &lt;&lt; 24)) {
228             newData[newDataPos++] = (byte)0x83;
229             newData[newDataPos++] = (byte)(curLen &gt;&gt; 16);
230             newData[newDataPos++] = (byte)(curLen &gt;&gt; 8);
231             newData[newDataPos++] = (byte)curLen;
232 
233         } else {
234             newData[newDataPos++] = (byte)0x84;
235             newData[newDataPos++] = (byte)(curLen &gt;&gt; 24);
236             newData[newDataPos++] = (byte)(curLen &gt;&gt; 16);
237             newData[newDataPos++] = (byte)(curLen &gt;&gt; 8);
238             newData[newDataPos++] = (byte)curLen;
239         }
240     }
241 
242     private byte[] getLengthBytes(int curLen) {
243         byte[] lenBytes;
244         int index = 0;
245 
246         if (curLen &lt; 128) {
247             lenBytes = new byte[1];
248             lenBytes[index++] = (byte)curLen;
249 
250         } else if (curLen &lt; (1 &lt;&lt; 8)) {
251             lenBytes = new byte[2];
252             lenBytes[index++] = (byte)0x81;
253             lenBytes[index++] = (byte)curLen;
254 
255         } else if (curLen &lt; (1 &lt;&lt; 16)) {
256             lenBytes = new byte[3];
257             lenBytes[index++] = (byte)0x82;
258             lenBytes[index++] = (byte)(curLen &gt;&gt; 8);
259             lenBytes[index++] = (byte)curLen;
260 
261         } else if (curLen &lt; (1 &lt;&lt; 24)) {
262             lenBytes = new byte[4];
263             lenBytes[index++] = (byte)0x83;
264             lenBytes[index++] = (byte)(curLen &gt;&gt; 16);
265             lenBytes[index++] = (byte)(curLen &gt;&gt; 8);
266             lenBytes[index++] = (byte)curLen;
267 
268         } else {
269             lenBytes = new byte[5];
270             lenBytes[index++] = (byte)0x84;
271             lenBytes[index++] = (byte)(curLen &gt;&gt; 24);
272             lenBytes[index++] = (byte)(curLen &gt;&gt; 16);
273             lenBytes[index++] = (byte)(curLen &gt;&gt; 8);
274             lenBytes[index++] = (byte)curLen;
275         }
276 
277         return lenBytes;
278     }
279 
280     // Returns the number of bytes needed to represent the given length
281     // in ASN.1 notation
282     private int getNumOfLenBytes(int len) {
283         int numOfLenBytes = 0;
284 
285         if (len &lt; 128) {
286             numOfLenBytes = 1;
287         } else if (len &lt; (1 &lt;&lt; 8)) {
288             numOfLenBytes = 2;
289         } else if (len &lt; (1 &lt;&lt; 16)) {
290             numOfLenBytes = 3;
291         } else if (len &lt; (1 &lt;&lt; 24)) {
292             numOfLenBytes = 4;
293         } else {
294             numOfLenBytes = 5;
295         }
296         return numOfLenBytes;
297     }
298 
299     /**
300      * Parse the value;
301      */
302     private void parseValue(int curLen) {
303         dataPos += curLen;
304     }
305 
306     /**
307      * Write the value;
308      */
309     private void writeValue(int curLen) {
310         for (int i=0; i &lt; curLen; i++)
311             newData[newDataPos++] = data[dataPos++];
312     }
313 
314     /**
315      * Converts a indefinite length DER encoded byte array to
316      * a definte length DER encoding.
317      *
318      * @param indefData the byte array holding the indefinite
319      *        length encoding.
320      * @return the byte array containing the definite length
<a name="7" id="anc7"></a><span class="line-modified">321      *         DER encoding, or null if there is not enough data.</span>
322      * @exception IOException on parsing or re-writing errors.
323      */
<a name="8" id="anc8"></a><span class="line-modified">324     byte[] convertBytes(byte[] indefData) throws IOException {</span>
325         data = indefData;
326         dataPos=0; index=0;
327         dataSize = data.length;
328         int len=0;
329         int unused = 0;
330 
331         // parse and set up the vectors of all the indefinite-lengths
332         while (dataPos &lt; dataSize) {
<a name="9" id="anc9"></a><span class="line-added">333             if (dataPos + 2 &gt; dataSize) {</span>
<span class="line-added">334                 // There should be at least one tag and one length</span>
<span class="line-added">335                 return null;</span>
<span class="line-added">336             }</span>
337             parseTag();
338             len = parseLength();
<a name="10" id="anc10"></a><span class="line-added">339             if (len &lt; 0) {</span>
<span class="line-added">340                 return null;</span>
<span class="line-added">341             }</span>
342             parseValue(len);
343             if (unresolved == 0) {
344                 unused = dataSize - dataPos;
345                 dataSize = dataPos;
346                 break;
347             }
348         }
349 
350         if (unresolved != 0) {
<a name="11" id="anc11"></a><span class="line-modified">351             return null;</span>
352         }
353 
354         newData = new byte[dataSize + numOfTotalLenBytes + unused];
355         dataPos=0; newDataPos=0; index=0;
356 
357         // write out the new byte array replacing all the indefinite-lengths
358         // and EOCs
359         while (dataPos &lt; dataSize) {
360            writeTag();
361            writeLengthAndValue();
362         }
363         System.arraycopy(indefData, dataSize,
364                          newData, dataSize + numOfTotalLenBytes, unused);
365 
366         return newData;
367     }
<a name="12" id="anc12"></a><span class="line-added">368 </span>
<span class="line-added">369     /**</span>
<span class="line-added">370      * Read the input stream into a DER byte array. If an indef len BER is</span>
<span class="line-added">371      * not resolved this method will try to read more data until EOF is reached.</span>
<span class="line-added">372      * This may block.</span>
<span class="line-added">373      *</span>
<span class="line-added">374      * @param in the input stream with tag and lenByte already read</span>
<span class="line-added">375      * @param lenByte the length of the length field to remember</span>
<span class="line-added">376      * @param tag the tag to remember</span>
<span class="line-added">377      * @return a DER byte array</span>
<span class="line-added">378      * @throws IOException if not all indef len BER</span>
<span class="line-added">379      *         can be resolved or another I/O error happens</span>
<span class="line-added">380      */</span>
<span class="line-added">381     public static byte[] convertStream(InputStream in, byte lenByte, byte tag)</span>
<span class="line-added">382             throws IOException {</span>
<span class="line-added">383         int offset = 2;     // for tag and length bytes</span>
<span class="line-added">384         int readLen = in.available();</span>
<span class="line-added">385         byte[] indefData = new byte[readLen + offset];</span>
<span class="line-added">386         indefData[0] = tag;</span>
<span class="line-added">387         indefData[1] = lenByte;</span>
<span class="line-added">388         while (true) {</span>
<span class="line-added">389             int bytesRead = in.readNBytes(indefData, offset, readLen);</span>
<span class="line-added">390             if (bytesRead != readLen) {</span>
<span class="line-added">391                 readLen = bytesRead;</span>
<span class="line-added">392                 indefData = Arrays.copyOf(indefData, offset + bytesRead);</span>
<span class="line-added">393             }</span>
<span class="line-added">394             DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-added">395             byte[] result = derIn.convertBytes(indefData);</span>
<span class="line-added">396             if (result == null) {</span>
<span class="line-added">397                 int next = in.read(); // This could block, but we need more</span>
<span class="line-added">398                 if (next == -1) {</span>
<span class="line-added">399                     throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="line-added">400                 }</span>
<span class="line-added">401                 int more = in.available();</span>
<span class="line-added">402                 // expand array to include next and more</span>
<span class="line-added">403                 indefData = Arrays.copyOf(indefData, offset + readLen + 1 + more);</span>
<span class="line-added">404                 indefData[offset + readLen] = (byte)next;</span>
<span class="line-added">405                 offset = offset + readLen + 1;</span>
<span class="line-added">406                 readLen = more;</span>
<span class="line-added">407             } else {</span>
<span class="line-added">408                 return result;</span>
<span class="line-added">409             }</span>
<span class="line-added">410         }</span>
<span class="line-added">411     }</span>
412 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
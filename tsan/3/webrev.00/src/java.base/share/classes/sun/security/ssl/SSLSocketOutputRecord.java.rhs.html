<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLSocketOutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.ByteArrayInputStream;
 29 import java.io.IOException;
 30 import java.io.OutputStream;
 31 import java.net.SocketException;
 32 import java.nio.ByteBuffer;
 33 import javax.net.ssl.SSLHandshakeException;
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLSocket}.
 37  */
 38 final class SSLSocketOutputRecord extends OutputRecord implements SSLRecord {
 39     private OutputStream deliverStream = null;
 40 
 41     SSLSocketOutputRecord(HandshakeHash handshakeHash) {
 42         this(handshakeHash, null);
 43     }
 44 
 45     SSLSocketOutputRecord(HandshakeHash handshakeHash,
 46             TransportContext tc) {
 47         super(handshakeHash, SSLCipher.SSLWriteCipher.nullTlsWriteCipher());
 48         this.tc = tc;
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
<a name="2" id="anc2"></a><span class="line-modified"> 54     void encodeAlert(byte level, byte description) throws IOException {</span>
<span class="line-modified"> 55         recordLock.lock();</span>
<span class="line-modified"> 56         try {</span>
<span class="line-modified"> 57             if (isClosed()) {</span>
<span class="line-modified"> 58                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 59                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added"> 60                         &quot;alert message: &quot; + Alert.nameOf(description));</span>
<span class="line-added"> 61                 }</span>
<span class="line-added"> 62                 return;</span>
 63             }
<a name="3" id="anc3"></a>

 64 
<a name="4" id="anc4"></a><span class="line-modified"> 65             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified"> 66             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified"> 67             count = position;</span>
<span class="line-modified"> 68 </span>
<span class="line-modified"> 69             write(level);</span>
<span class="line-modified"> 70             write(description);</span>
<span class="line-modified"> 71             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified"> 72                 SSLLogger.fine(&quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified"> 73                         &quot; &quot; + ContentType.ALERT.name +</span>
<span class="line-modified"> 74                         &quot;(&quot; + Alert.nameOf(description) + &quot;)&quot; +</span>
<span class="line-modified"> 75                         &quot;, length = &quot; + (count - headerSize));</span>
<span class="line-modified"> 76             }</span>
 77 
<a name="5" id="anc5"></a><span class="line-modified"> 78             // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified"> 79             encrypt(writeCipher, ContentType.ALERT.id, headerSize);</span>
 80 
<a name="6" id="anc6"></a><span class="line-modified"> 81             // deliver this message</span>
<span class="line-modified"> 82             deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified"> 83             deliverStream.flush();                 // may throw IOException</span>
 84 
<a name="7" id="anc7"></a><span class="line-modified"> 85             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified"> 86                 SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified"> 87                         (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-modified"> 88             }</span>
 89 
<a name="8" id="anc8"></a><span class="line-modified"> 90             // reset the internal buffer</span>
<span class="line-modified"> 91             count = 0;</span>
<span class="line-added"> 92         } finally {</span>
<span class="line-added"> 93             recordLock.unlock();</span>
<span class="line-added"> 94         }</span>
 95     }
 96 
 97     @Override
<a name="9" id="anc9"></a><span class="line-modified"> 98     void encodeHandshake(byte[] source,</span>
 99             int offset, int length) throws IOException {
<a name="10" id="anc10"></a><span class="line-modified">100         recordLock.lock();</span>
<span class="line-modified">101         try {</span>
<span class="line-modified">102             if (isClosed()) {</span>
<span class="line-modified">103                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">104                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">105                             &quot;handshake message&quot;,</span>
<span class="line-added">106                             ByteBuffer.wrap(source, offset, length));</span>
<span class="line-added">107                 }</span>
<span class="line-added">108                 return;</span>
109             }
<a name="11" id="anc11"></a>

110 
<a name="12" id="anc12"></a><span class="line-modified">111             if (firstMessage) {</span>
<span class="line-modified">112                 firstMessage = false;</span>
113 
<a name="13" id="anc13"></a><span class="line-modified">114                 if ((helloVersion == ProtocolVersion.SSL20Hello) &amp;&amp;</span>
<span class="line-modified">115                     (source[offset] == SSLHandshake.CLIENT_HELLO.id) &amp;&amp;</span>
116                                             //  5: recode header size
<a name="14" id="anc14"></a><span class="line-modified">117                     (source[offset + 4 + 2 + 32] == 0)) {</span>
118                                             // V3 session ID is empty
119                                             //  4: handshake header size
120                                             //  2: client_version in ClientHello
121                                             // 32: random in ClientHello
122 
<a name="15" id="anc15"></a><span class="line-modified">123                     ByteBuffer v2ClientHello = encodeV2ClientHello(</span>
<span class="line-modified">124                             source, (offset + 4), (length - 4));</span>
<span class="line-added">125 </span>
<span class="line-added">126                     // array offset is zero</span>
<span class="line-added">127                     byte[] record = v2ClientHello.array();</span>
<span class="line-added">128                     int limit = v2ClientHello.limit();</span>
<span class="line-added">129                     handshakeHash.deliver(record, 2, (limit - 2));</span>
<span class="line-added">130 </span>
<span class="line-added">131                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-added">132                         SSLLogger.fine(</span>
<span class="line-added">133                                 &quot;WRITE: SSLv2 ClientHello message&quot; +</span>
<span class="line-added">134                                 &quot;, length = &quot; + limit);</span>
<span class="line-added">135                     }</span>
<span class="line-added">136 </span>
<span class="line-added">137                     // deliver this message</span>
<span class="line-added">138                     //</span>
<span class="line-added">139                     // Version 2 ClientHello message should be plaintext.</span>
<span class="line-added">140                     //</span>
<span class="line-added">141                     // No max fragment length negotiation.</span>
<span class="line-added">142                     deliverStream.write(record, 0, limit);</span>
<span class="line-added">143                     deliverStream.flush();</span>
<span class="line-added">144 </span>
<span class="line-added">145                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-added">146                         SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-added">147                                 (new ByteArrayInputStream(record, 0, limit)));</span>
<span class="line-added">148                     }</span>
<span class="line-added">149 </span>
<span class="line-added">150                     return;</span>
<span class="line-added">151                 }</span>
<span class="line-added">152             }</span>
<span class="line-added">153 </span>
<span class="line-added">154             byte handshakeType = source[0];</span>
<span class="line-added">155             if (handshakeHash.isHashable(handshakeType)) {</span>
<span class="line-added">156                 handshakeHash.deliver(source, offset, length);</span>
<span class="line-added">157             }</span>
<span class="line-added">158 </span>
<span class="line-added">159             int fragLimit = getFragLimit();</span>
<span class="line-added">160             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-added">161             if (count == 0) {</span>
<span class="line-added">162                 count = position;</span>
<span class="line-added">163             }</span>
<span class="line-added">164 </span>
<span class="line-added">165             if ((count - position) &lt; (fragLimit - length)) {</span>
<span class="line-added">166                 write(source, offset, length);</span>
<span class="line-added">167                 return;</span>
<span class="line-added">168             }</span>
<span class="line-added">169 </span>
<span class="line-added">170             for (int limit = (offset + length); offset &lt; limit;) {</span>
<span class="line-added">171 </span>
<span class="line-added">172                 int remains = (limit - offset) + (count - position);</span>
<span class="line-added">173                 int fragLen = Math.min(fragLimit, remains);</span>
174 
<a name="16" id="anc16"></a><span class="line-modified">175                 // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">176                 write(source, offset, fragLen);</span>
<span class="line-modified">177                 if (remains &lt; fragLimit) {</span>
<span class="line-added">178                     return;</span>
<span class="line-added">179                 }</span>
180 
181                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
182                     SSLLogger.fine(
<a name="17" id="anc17"></a><span class="line-modified">183                             &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified">184                             &quot; &quot; + ContentType.HANDSHAKE.name +</span>
<span class="line-added">185                             &quot;, length = &quot; + (count - headerSize));</span>
186                 }
187 
<a name="18" id="anc18"></a><span class="line-added">188                 // Encrypt the fragment and wrap up a record.</span>
<span class="line-added">189                 encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);</span>
<span class="line-added">190 </span>
191                 // deliver this message
<a name="19" id="anc19"></a><span class="line-modified">192                 deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified">193                 deliverStream.flush();                 // may throw IOException</span>




194 
195                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
196                     SSLLogger.fine(&quot;Raw write&quot;,
<a name="20" id="anc20"></a><span class="line-modified">197                             (new ByteArrayInputStream(buf, 0, count)));</span>
198                 }
199 
<a name="21" id="anc21"></a><span class="line-modified">200                 // reset the offset</span>
<span class="line-added">201                 offset += fragLen;</span>
<span class="line-added">202 </span>
<span class="line-added">203                 // reset the internal buffer</span>
<span class="line-added">204                 count = position;</span>
205             }
<a name="22" id="anc22"></a><span class="line-added">206         } finally {</span>
<span class="line-added">207             recordLock.unlock();</span>
208         }
<a name="23" id="anc23"></a><span class="line-added">209     }</span>
210 
<a name="24" id="anc24"></a><span class="line-modified">211     @Override</span>
<span class="line-modified">212     void encodeChangeCipherSpec() throws IOException {</span>
<span class="line-modified">213         recordLock.lock();</span>
<span class="line-modified">214         try {</span>
<span class="line-added">215             if (isClosed()) {</span>
<span class="line-added">216                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">217                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">218                         &quot;change_cipher_spec message&quot;);</span>
<span class="line-added">219                 }</span>
<span class="line-added">220                 return;</span>
<span class="line-added">221             }</span>
222 
<a name="25" id="anc25"></a><span class="line-modified">223             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">224             int position = headerSize + writeCipher.getExplicitNonceSize();</span>

225             count = position;
<a name="26" id="anc26"></a>
226 
<a name="27" id="anc27"></a><span class="line-modified">227             write((byte)1);         // byte 1: change_cipher_spec(</span>



228 
<a name="28" id="anc28"></a><span class="line-modified">229             // Encrypt the fragment and wrap up a record.</span>
<span class="line-added">230             encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);</span>
231 
<a name="29" id="anc29"></a><span class="line-modified">232             // deliver this message</span>
<span class="line-modified">233             deliverStream.write(buf, 0, count);        // may throw IOException</span>
<span class="line-added">234             // deliverStream.flush();                  // flush in Finished</span>
235 
<a name="30" id="anc30"></a><span class="line-modified">236             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified">237                 SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified">238                         (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-added">239             }</span>
<span class="line-added">240 </span>
<span class="line-added">241             // reset the internal buffer</span>
<span class="line-added">242             count = 0;</span>
<span class="line-added">243         } finally {</span>
<span class="line-added">244             recordLock.unlock();</span>
<span class="line-added">245         }</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     @Override</span>
<span class="line-added">249     public void flush() throws IOException {</span>
<span class="line-added">250         recordLock.lock();</span>
<span class="line-added">251         try {</span>
<span class="line-added">252             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-added">253             if (count &lt;= position) {</span>
254                 return;
255             }
256 
257             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
258                 SSLLogger.fine(
259                         &quot;WRITE: &quot; + protocolVersion +
260                         &quot; &quot; + ContentType.HANDSHAKE.name +
261                         &quot;, length = &quot; + (count - headerSize));
262             }
263 
264             // Encrypt the fragment and wrap up a record.
265             encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);
266 
267             // deliver this message
268             deliverStream.write(buf, 0, count);    // may throw IOException
269             deliverStream.flush();                 // may throw IOException
270 
271             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
272                 SSLLogger.fine(&quot;Raw write&quot;,
273                         (new ByteArrayInputStream(buf, 0, count)));
274             }
275 
<a name="31" id="anc31"></a>


276             // reset the internal buffer
<a name="32" id="anc32"></a><span class="line-modified">277             count = 0;      // DON&#39;T use position</span>
<span class="line-added">278         } finally {</span>
<span class="line-added">279             recordLock.unlock();</span>
280         }
281     }
282 
283     @Override
<a name="33" id="anc33"></a><span class="line-modified">284     void deliver(byte[] source, int offset, int length) throws IOException {</span>
<span class="line-modified">285         recordLock.lock();</span>
<span class="line-modified">286         try {</span>
<span class="line-modified">287             if (isClosed()) {</span>
<span class="line-modified">288                 throw new SocketException(</span>
<span class="line-added">289                         &quot;Connection or outbound has been closed&quot;);</span>
290             }
<a name="34" id="anc34"></a>





















































291 
<a name="35" id="anc35"></a><span class="line-modified">292             if (writeCipher.authenticator.seqNumOverflow()) {</span>
<span class="line-modified">293                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">294                     SSLLogger.fine(</span>
<span class="line-modified">295                         &quot;sequence number extremely close to overflow &quot; +</span>
<span class="line-modified">296                         &quot;(2^64-1 packets). Closing connection.&quot;);</span>
<span class="line-modified">297                 }</span>
298 
<a name="36" id="anc36"></a><span class="line-modified">299                 throw new SSLHandshakeException(&quot;sequence number overflow&quot;);</span>




300             }
301 
<a name="37" id="anc37"></a><span class="line-modified">302             boolean isFirstRecordOfThePayload = true;</span>
<span class="line-modified">303             for (int limit = (offset + length); offset &lt; limit;) {</span>
<span class="line-added">304                 int fragLen;</span>
<span class="line-added">305                 if (packetSize &gt; 0) {</span>
<span class="line-added">306                     fragLen = Math.min(maxRecordSize, packetSize);</span>
<span class="line-added">307                     fragLen = writeCipher.calculateFragmentSize(</span>
<span class="line-added">308                             fragLen, headerSize);</span>
<span class="line-added">309 </span>
<span class="line-added">310                     fragLen = Math.min(fragLen, Record.maxDataSize);</span>
<span class="line-added">311                 } else {</span>
<span class="line-added">312                     fragLen = Record.maxDataSize;</span>
<span class="line-added">313                 }</span>
314 
<a name="38" id="anc38"></a><span class="line-modified">315                 // Calculate more impact, for example TLS 1.3 padding.</span>
<span class="line-modified">316                 fragLen = calculateFragmentSize(fragLen);</span>










317 
<a name="39" id="anc39"></a><span class="line-modified">318                 if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {</span>
<span class="line-modified">319                     fragLen = 1;</span>
<span class="line-modified">320                     isFirstRecordOfThePayload = false;</span>
<span class="line-added">321                 } else {</span>
<span class="line-added">322                     fragLen = Math.min(fragLen, (limit - offset));</span>
<span class="line-added">323                 }</span>
324 
<a name="40" id="anc40"></a><span class="line-modified">325                 // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">326                 int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified">327                 count = position;</span>
<span class="line-modified">328                 write(source, offset, fragLen);</span>


329 
<a name="41" id="anc41"></a><span class="line-modified">330                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified">331                     SSLLogger.fine(</span>
<span class="line-modified">332                             &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified">333                             &quot; &quot; + ContentType.APPLICATION_DATA.name +</span>
<span class="line-added">334                             &quot;, length = &quot; + (count - position));</span>
<span class="line-added">335                 }</span>
336 
<a name="42" id="anc42"></a><span class="line-modified">337                 // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified">338                 encrypt(writeCipher,</span>
<span class="line-modified">339                         ContentType.APPLICATION_DATA.id, headerSize);</span>



340 
<a name="43" id="anc43"></a><span class="line-modified">341                 // deliver this message</span>
<span class="line-modified">342                 deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-added">343                 deliverStream.flush();                 // may throw IOException</span>
344 
<a name="44" id="anc44"></a><span class="line-modified">345                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified">346                     SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified">347                             (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-added">348                 }</span>
349 
<a name="45" id="anc45"></a><span class="line-modified">350                 // reset the internal buffer</span>
<span class="line-modified">351                 count = 0;</span>


352 
<a name="46" id="anc46"></a><span class="line-modified">353                 if (isFirstAppOutputRecord) {</span>
<span class="line-modified">354                     isFirstAppOutputRecord = false;</span>
<span class="line-added">355                 }</span>
356 
<a name="47" id="anc47"></a><span class="line-modified">357                 offset += fragLen;</span>

358             }
<a name="48" id="anc48"></a><span class="line-modified">359         } finally {</span>
<span class="line-modified">360             recordLock.unlock();</span>
361         }
362     }
363 
364     @Override
<a name="49" id="anc49"></a><span class="line-modified">365     void setDeliverStream(OutputStream outputStream) {</span>
<span class="line-modified">366         recordLock.lock();</span>
<span class="line-added">367         try {</span>
<span class="line-added">368             this.deliverStream = outputStream;</span>
<span class="line-added">369         } finally {</span>
<span class="line-added">370             recordLock.unlock();</span>
<span class="line-added">371         }</span>
372     }
373 
374     /*
375      * Need to split the payload except the following cases:
376      *
377      * 1. protocol version is TLS 1.1 or later;
378      * 2. bulk cipher does not use CBC mode, including null bulk cipher suites.
379      * 3. the payload is the first application record of a freshly
380      *    negotiated TLS session.
381      * 4. the CBC protection is disabled;
382      *
383      * By default, we counter chosen plaintext issues on CBC mode
384      * ciphersuites in SSLv3/TLS1.0 by sending one byte of application
385      * data in the first record of every payload, and the rest in
386      * subsequent record(s). Note that the issues have been solved in
387      * TLS 1.1 or later.
388      *
389      * It is not necessary to split the very first application record of
390      * a freshly negotiated TLS session, as there is no previous
391      * application data to guess.  To improve compatibility, we will not
392      * split such records.
393      *
394      * This avoids issues in the outbound direction.  For a full fix,
395      * the peer must have similar protections.
396      */
397     private boolean needToSplitPayload() {
398         return (!protocolVersion.useTLS11PlusSpec()) &amp;&amp;
399                 writeCipher.isCBCMode() &amp;&amp; !isFirstAppOutputRecord &amp;&amp;
400                 Record.enableCBCProtection;
401     }
402 
403     private int getFragLimit() {
404         int fragLimit;
405         if (packetSize &gt; 0) {
406             fragLimit = Math.min(maxRecordSize, packetSize);
407             fragLimit =
408                     writeCipher.calculateFragmentSize(fragLimit, headerSize);
409 
410             fragLimit = Math.min(fragLimit, Record.maxDataSize);
411         } else {
412             fragLimit = Record.maxDataSize;
413         }
414 
<a name="50" id="anc50"></a><span class="line-modified">415         // Calculate more impact, for example TLS 1.3 padding.</span>
<span class="line-modified">416         fragLimit = calculateFragmentSize(fragLimit);</span>

417 
418         return fragLimit;
419     }
420 }
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>
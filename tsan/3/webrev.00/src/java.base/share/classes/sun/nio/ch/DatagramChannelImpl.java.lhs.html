<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
<a name="2" id="anc2"></a>




  30 import java.net.DatagramSocket;
  31 import java.net.Inet4Address;
  32 import java.net.Inet6Address;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.NetworkInterface;
  36 import java.net.PortUnreachableException;
  37 import java.net.ProtocolFamily;
  38 import java.net.SocketAddress;
  39 import java.net.SocketOption;
<a name="3" id="anc3"></a>
  40 import java.net.StandardProtocolFamily;
  41 import java.net.StandardSocketOptions;
  42 import java.nio.ByteBuffer;
  43 import java.nio.channels.AlreadyBoundException;
  44 import java.nio.channels.AlreadyConnectedException;
  45 import java.nio.channels.AsynchronousCloseException;
  46 import java.nio.channels.ClosedChannelException;
  47 import java.nio.channels.DatagramChannel;
<a name="4" id="anc4"></a>
  48 import java.nio.channels.MembershipKey;
  49 import java.nio.channels.NotYetConnectedException;
  50 import java.nio.channels.SelectionKey;
<a name="5" id="anc5"></a>
  51 import java.nio.channels.spi.SelectorProvider;
<a name="6" id="anc6"></a>

  52 import java.util.Collections;
<a name="7" id="anc7"></a>
  53 import java.util.HashSet;
<a name="8" id="anc8"></a>
  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;
<a name="9" id="anc9"></a>
  57 
<a name="10" id="anc10"></a>
  58 import sun.net.ResourceManager;
  59 import sun.net.ext.ExtendedSocketOptions;
<a name="11" id="anc11"></a>
  60 
  61 /**
  62  * An implementation of DatagramChannels.
  63  */
  64 
  65 class DatagramChannelImpl
  66     extends DatagramChannel
  67     implements SelChImpl
  68 {
  69     // Used to make native read and write calls
<a name="12" id="anc12"></a><span class="line-modified">  70     private static NativeDispatcher nd = new DatagramDispatcher();</span>



  71 
  72     // The protocol family of the socket
  73     private final ProtocolFamily family;
  74 
  75     // Our file descriptor
  76     private final FileDescriptor fd;
  77     private final int fdVal;
  78 
<a name="13" id="anc13"></a><span class="line-modified">  79     // Cached InetAddress and port for unconnected DatagramChannels</span>
<span class="line-modified">  80     // used by receive0</span>
<span class="line-modified">  81     private InetAddress cachedSenderInetAddress;</span>
<span class="line-modified">  82     private int cachedSenderPort;</span>








  83 
  84     // Lock held by current reading or connecting thread
  85     private final ReentrantLock readLock = new ReentrantLock();
  86 
  87     // Lock held by current writing or connecting thread
  88     private final ReentrantLock writeLock = new ReentrantLock();
  89 
  90     // Lock held by any thread that modifies the state fields declared below
  91     // DO NOT invoke a blocking I/O operation while holding this lock!
  92     private final Object stateLock = new Object();
  93 
  94     // -- The following fields are protected by stateLock
  95 
  96     // State (does not necessarily increase monotonically)
  97     private static final int ST_UNCONNECTED = 0;
  98     private static final int ST_CONNECTED = 1;
  99     private static final int ST_CLOSING = 2;
<a name="14" id="anc14"></a><span class="line-modified"> 100     private static final int ST_KILLPENDING = 3;</span>
<span class="line-removed"> 101     private static final int ST_KILLED = 4;</span>
 102     private int state;
 103 
 104     // IDs of native threads doing reads and writes, for signalling
 105     private long readerThread;
 106     private long writerThread;
 107 
<a name="15" id="anc15"></a><span class="line-modified"> 108     // Binding and remote address (when connected)</span>
 109     private InetSocketAddress localAddress;
 110     private InetSocketAddress remoteAddress;
 111 
<a name="16" id="anc16"></a><span class="line-modified"> 112     // Our socket adaptor, if any</span>
<span class="line-modified"> 113     private DatagramSocket socket;</span>












 114 
 115     // Multicast support
 116     private MembershipRegistry registry;
 117 
 118     // set true when socket is bound and SO_REUSEADDRESS is emulated
 119     private boolean reuseAddressEmulated;
 120 
 121     // set true/false when socket is already bound and SO_REUSEADDR is emulated
 122     private boolean isReuseAddress;
 123 
 124     // -- End of fields protected by stateLock
 125 
<a name="17" id="anc17"></a><span class="line-modified"> 126     public DatagramChannelImpl(SelectorProvider sp)</span>
<span class="line-modified"> 127         throws IOException</span>
<span class="line-modified"> 128     {</span>
<span class="line-modified"> 129         super(sp);</span>
<span class="line-modified"> 130         ResourceManager.beforeUdpCreate();</span>
<span class="line-modified"> 131         try {</span>
<span class="line-removed"> 132             this.family = Net.isIPv6Available()</span>
<span class="line-removed"> 133                     ? StandardProtocolFamily.INET6</span>
<span class="line-removed"> 134                     : StandardProtocolFamily.INET;</span>
<span class="line-removed"> 135             this.fd = Net.socket(family, false);</span>
<span class="line-removed"> 136             this.fdVal = IOUtil.fdVal(fd);</span>
<span class="line-removed"> 137         } catch (IOException ioe) {</span>
<span class="line-removed"> 138             ResourceManager.afterUdpClose();</span>
<span class="line-removed"> 139             throw ioe;</span>
<span class="line-removed"> 140         }</span>
 141     }
 142 
<a name="18" id="anc18"></a><span class="line-modified"> 143     public DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family)</span>
 144         throws IOException
 145     {
 146         super(sp);
<a name="19" id="anc19"></a>
 147         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
 148         if ((family != StandardProtocolFamily.INET) &amp;&amp;
<a name="20" id="anc20"></a><span class="line-modified"> 149             (family != StandardProtocolFamily.INET6)) {</span>
 150             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
 151         }
<a name="21" id="anc21"></a><span class="line-modified"> 152         if (family == StandardProtocolFamily.INET6) {</span>
<span class="line-modified"> 153             if (!Net.isIPv6Available()) {</span>
<span class="line-removed"> 154                 throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);</span>
<span class="line-removed"> 155             }</span>
 156         }
 157 
<a name="22" id="anc22"></a>


 158         ResourceManager.beforeUdpCreate();
<a name="23" id="anc23"></a>
 159         try {
<a name="24" id="anc24"></a>
 160             this.family = family;
<a name="25" id="anc25"></a><span class="line-modified"> 161             this.fd = Net.socket(family, false);</span>
 162             this.fdVal = IOUtil.fdVal(fd);
<a name="26" id="anc26"></a><span class="line-modified"> 163         } catch (IOException ioe) {</span>
<span class="line-modified"> 164             ResourceManager.afterUdpClose();</span>
<span class="line-modified"> 165             throw ioe;</span>















 166         }
<a name="27" id="anc27"></a>


 167     }
 168 
<a name="28" id="anc28"></a><span class="line-modified"> 169     public DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)</span>
 170         throws IOException
 171     {
 172         super(sp);
 173 
<a name="29" id="anc29"></a><span class="line-modified"> 174         // increment UDP count to match decrement when closing</span>

 175         ResourceManager.beforeUdpCreate();
<a name="30" id="anc30"></a>





























 176 
<a name="31" id="anc31"></a><span class="line-removed"> 177         this.family = Net.isIPv6Available()</span>
<span class="line-removed"> 178                 ? StandardProtocolFamily.INET6</span>
<span class="line-removed"> 179                 : StandardProtocolFamily.INET;</span>
<span class="line-removed"> 180         this.fd = fd;</span>
<span class="line-removed"> 181         this.fdVal = IOUtil.fdVal(fd);</span>
 182         synchronized (stateLock) {
 183             this.localAddress = Net.localAddress(fd);
 184         }
 185     }
 186 
 187     // @throws ClosedChannelException if channel is closed
 188     private void ensureOpen() throws ClosedChannelException {
 189         if (!isOpen())
 190             throw new ClosedChannelException();
 191     }
 192 
 193     @Override
 194     public DatagramSocket socket() {
<a name="32" id="anc32"></a><span class="line-modified"> 195         synchronized (stateLock) {</span>
<span class="line-modified"> 196             if (socket == null)</span>
<span class="line-modified"> 197                 socket = DatagramSocketAdaptor.create(this);</span>
<span class="line-modified"> 198             return socket;</span>


 199         }
<a name="33" id="anc33"></a>
 200     }
 201 
 202     @Override
 203     public SocketAddress getLocalAddress() throws IOException {
 204         synchronized (stateLock) {
 205             ensureOpen();
 206             // Perform security check before returning address
 207             return Net.getRevealedLocalAddress(localAddress);
 208         }
 209     }
 210 
 211     @Override
 212     public SocketAddress getRemoteAddress() throws IOException {
 213         synchronized (stateLock) {
 214             ensureOpen();
 215             return remoteAddress;
 216         }
 217     }
 218 
<a name="34" id="anc34"></a>

































 219     @Override
 220     public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
 221         throws IOException
 222     {
 223         Objects.requireNonNull(name);
 224         if (!supportedOptions().contains(name))
 225             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<a name="35" id="anc35"></a>

 226 
 227         synchronized (stateLock) {
 228             ensureOpen();
 229 
<a name="36" id="anc36"></a><span class="line-modified"> 230             if (name == StandardSocketOptions.IP_TOS ||</span>
<span class="line-modified"> 231                 name == StandardSocketOptions.IP_MULTICAST_TTL ||</span>
<span class="line-modified"> 232                 name == StandardSocketOptions.IP_MULTICAST_LOOP)</span>
<span class="line-modified"> 233             {</span>
<span class="line-modified"> 234                 // options are protocol dependent</span>
<span class="line-modified"> 235                 Net.setSocketOption(fd, family, name, value);</span>
<span class="line-modified"> 236                 return this;</span>
<span class="line-modified"> 237             }</span>

 238 
<a name="37" id="anc37"></a>
 239             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
<a name="38" id="anc38"></a><span class="line-modified"> 240                 if (value == null)</span>
<span class="line-modified"> 241                     throw new IllegalArgumentException(&quot;Cannot set IP_MULTICAST_IF to &#39;null&#39;&quot;);</span>
<span class="line-removed"> 242                 NetworkInterface interf = (NetworkInterface)value;</span>
 243                 if (family == StandardProtocolFamily.INET6) {
 244                     int index = interf.getIndex();
 245                     if (index == -1)
 246                         throw new IOException(&quot;Network interface cannot be identified&quot;);
 247                     Net.setInterface6(fd, index);
<a name="39" id="anc39"></a><span class="line-modified"> 248                 } else {</span>

 249                     // need IPv4 address to identify interface
 250                     Inet4Address target = Net.anyInet4Address(interf);
<a name="40" id="anc40"></a><span class="line-modified"> 251                     if (target == null)</span>






 252                         throw new IOException(&quot;Network interface not configured for IPv4&quot;);
<a name="41" id="anc41"></a><span class="line-modified"> 253                     int targetAddress = Net.inet4AsInt(target);</span>
<span class="line-removed"> 254                     Net.setInterface4(fd, targetAddress);</span>
 255                 }
 256                 return this;
 257             }
<a name="42" id="anc42"></a>

 258             if (name == StandardSocketOptions.SO_REUSEADDR
 259                 &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
 260                 reuseAddressEmulated = true;
 261                 this.isReuseAddress = (Boolean)value;
 262             }
 263 
 264             // remaining options don&#39;t need any special handling
<a name="43" id="anc43"></a><span class="line-modified"> 265             Net.setSocketOption(fd, Net.UNSPEC, name, value);</span>






 266             return this;
 267         }
 268     }
 269 
 270     @Override
 271     @SuppressWarnings(&quot;unchecked&quot;)
 272     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 273         throws IOException
 274     {
 275         Objects.requireNonNull(name);
 276         if (!supportedOptions().contains(name))
 277             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 278 
 279         synchronized (stateLock) {
 280             ensureOpen();
 281 
<a name="44" id="anc44"></a><span class="line-modified"> 282             if (name == StandardSocketOptions.IP_TOS ||</span>
<span class="line-removed"> 283                 name == StandardSocketOptions.IP_MULTICAST_TTL ||</span>
<span class="line-removed"> 284                 name == StandardSocketOptions.IP_MULTICAST_LOOP)</span>
<span class="line-removed"> 285             {</span>
<span class="line-removed"> 286                 return (T) Net.getSocketOption(fd, family, name);</span>
<span class="line-removed"> 287             }</span>
 288 
 289             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 290                 if (family == StandardProtocolFamily.INET) {
 291                     int address = Net.getInterface4(fd);
 292                     if (address == 0)
 293                         return null;    // default interface
 294 
 295                     InetAddress ia = Net.inet4FromInt(address);
 296                     NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 297                     if (ni == null)
 298                         throw new IOException(&quot;Unable to map address to interface&quot;);
 299                     return (T) ni;
 300                 } else {
 301                     int index = Net.getInterface6(fd);
 302                     if (index == 0)
 303                         return null;    // default interface
 304 
 305                     NetworkInterface ni = NetworkInterface.getByIndex(index);
 306                     if (ni == null)
 307                         throw new IOException(&quot;Unable to map index to interface&quot;);
 308                     return (T) ni;
 309                 }
 310             }
 311 
 312             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
<a name="45" id="anc45"></a><span class="line-modified"> 313                 return (T)Boolean.valueOf(isReuseAddress);</span>
 314             }
 315 
 316             // no special handling
<a name="46" id="anc46"></a><span class="line-modified"> 317             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span>
 318         }
 319     }
 320 
 321     private static class DefaultOptionsHolder {
 322         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 323 
 324         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 325             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 326             set.add(StandardSocketOptions.SO_SNDBUF);
 327             set.add(StandardSocketOptions.SO_RCVBUF);
 328             set.add(StandardSocketOptions.SO_REUSEADDR);
 329             if (Net.isReusePortAvailable()) {
 330                 set.add(StandardSocketOptions.SO_REUSEPORT);
 331             }
 332             set.add(StandardSocketOptions.SO_BROADCAST);
 333             set.add(StandardSocketOptions.IP_TOS);
 334             set.add(StandardSocketOptions.IP_MULTICAST_IF);
 335             set.add(StandardSocketOptions.IP_MULTICAST_TTL);
 336             set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
 337             set.addAll(ExtendedSocketOptions.datagramSocketOptions());
 338             return Collections.unmodifiableSet(set);
 339         }
 340     }
 341 
 342     @Override
 343     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 344         return DefaultOptionsHolder.defaultOptions;
 345     }
 346 
 347     /**
 348      * Marks the beginning of a read operation that might block.
 349      *
 350      * @param blocking true if configured blocking
 351      * @param mustBeConnected true if the socket must be connected
 352      * @return remote address if connected
 353      * @throws ClosedChannelException if the channel is closed
 354      * @throws NotYetConnectedException if mustBeConnected and not connected
 355      * @throws IOException if socket not bound and cannot be bound
 356      */
 357     private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
 358         throws IOException
 359     {
<a name="47" id="anc47"></a><span class="line-modified"> 360         if (blocking) {</span>
 361             // set hook for Thread.interrupt
 362             begin();
 363         }
 364         SocketAddress remote;
 365         synchronized (stateLock) {
 366             ensureOpen();
 367             remote = remoteAddress;
 368             if ((remote == null) &amp;&amp; mustBeConnected)
 369                 throw new NotYetConnectedException();
 370             if (localAddress == null)
 371                 bindInternal(null);
 372             if (blocking)
 373                 readerThread = NativeThread.current();
 374         }
 375         return remote;
 376     }
 377 
 378     /**
 379      * Marks the end of a read operation that may have blocked.
 380      *
 381      * @throws AsynchronousCloseException if the channel was closed asynchronously
 382      */
 383     private void endRead(boolean blocking, boolean completed)
 384         throws AsynchronousCloseException
 385     {
 386         if (blocking) {
 387             synchronized (stateLock) {
 388                 readerThread = 0;
<a name="48" id="anc48"></a><span class="line-removed"> 389                 // notify any thread waiting in implCloseSelectableChannel</span>
 390                 if (state == ST_CLOSING) {
<a name="49" id="anc49"></a><span class="line-modified"> 391                     stateLock.notifyAll();</span>
 392                 }
 393             }
<a name="50" id="anc50"></a><span class="line-modified"> 394             // remove hook for Thread.interrupt</span>
<span class="line-modified"> 395             end(completed);</span>




 396         }
 397     }
 398 
<a name="51" id="anc51"></a><span class="line-removed"> 399     private SocketAddress sender;       // Set by receive0 (## ugh)</span>
<span class="line-removed"> 400 </span>
 401     @Override
 402     public SocketAddress receive(ByteBuffer dst) throws IOException {
 403         if (dst.isReadOnly())
 404             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
<a name="52" id="anc52"></a><span class="line-removed"> 405 </span>
 406         readLock.lock();
 407         try {
 408             boolean blocking = isBlocking();
<a name="53" id="anc53"></a><span class="line-modified"> 409             int n = 0;</span>
<span class="line-removed"> 410             ByteBuffer bb = null;</span>
 411             try {
 412                 SocketAddress remote = beginRead(blocking, false);
 413                 boolean connected = (remote != null);
 414                 SecurityManager sm = System.getSecurityManager();
 415                 if (connected || (sm == null)) {
 416                     // connected or no security manager
<a name="54" id="anc54"></a><span class="line-modified"> 417                     do {</span>
<span class="line-modified"> 418                         n = receive(fd, dst, connected);</span>
<span class="line-modified"> 419                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 420                     if (n == IOStatus.UNAVAILABLE)</span>
<span class="line-modified"> 421                         return null;</span>
<span class="line-removed"> 422                 } else {</span>
<span class="line-removed"> 423                     // Cannot receive into user&#39;s buffer when running with a</span>
<span class="line-removed"> 424                     // security manager and not connected</span>
<span class="line-removed"> 425                     bb = Util.getTemporaryDirectBuffer(dst.remaining());</span>
<span class="line-removed"> 426                     for (;;) {</span>
<span class="line-removed"> 427                         do {</span>
<span class="line-removed"> 428                             n = receive(fd, bb, connected);</span>
<span class="line-removed"> 429                         } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-removed"> 430                         if (n == IOStatus.UNAVAILABLE)</span>
<span class="line-removed"> 431                             return null;</span>
<span class="line-removed"> 432                         InetSocketAddress isa = (InetSocketAddress)sender;</span>
<span class="line-removed"> 433                         try {</span>
<span class="line-removed"> 434                             sm.checkAccept(isa.getAddress().getHostAddress(),</span>
<span class="line-removed"> 435                                            isa.getPort());</span>
<span class="line-removed"> 436                         } catch (SecurityException se) {</span>
<span class="line-removed"> 437                             // Ignore packet</span>
<span class="line-removed"> 438                             bb.clear();</span>
<span class="line-removed"> 439                             n = 0;</span>
<span class="line-removed"> 440                             continue;</span>
 441                         }
<a name="55" id="anc55"></a><span class="line-removed"> 442                         bb.flip();</span>
<span class="line-removed"> 443                         dst.put(bb);</span>
<span class="line-removed"> 444                         break;</span>
 445                     }
<a name="56" id="anc56"></a>






 446                 }
<a name="57" id="anc57"></a><span class="line-removed"> 447                 assert sender != null;</span>
 448                 return sender;
 449             } finally {
<a name="58" id="anc58"></a><span class="line-modified"> 450                 if (bb != null)</span>
<span class="line-modified"> 451                     Util.releaseTemporaryDirectBuffer(bb);</span>
<span class="line-modified"> 452                 endRead(blocking, n &gt; 0);</span>
<span class="line-modified"> 453                 assert IOStatus.check(n);</span>









































 454             }
<a name="59" id="anc59"></a>







































 455         } finally {
 456             readLock.unlock();
 457         }
 458     }
 459 
<a name="60" id="anc60"></a><span class="line-modified"> 460     private int receive(FileDescriptor fd, ByteBuffer dst, boolean connected)</span>





 461         throws IOException
 462     {
<a name="61" id="anc61"></a>





























































 463         int pos = dst.position();
 464         int lim = dst.limit();
 465         assert (pos &lt;= lim);
 466         int rem = (pos &lt;= lim ? lim - pos : 0);
 467         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
<a name="62" id="anc62"></a><span class="line-modified"> 468             return receiveIntoNativeBuffer(fd, dst, rem, pos, connected);</span>
 469 
 470         // Substitute a native buffer. If the supplied buffer is empty
 471         // we must instead use a nonempty buffer, otherwise the call
 472         // will not block waiting for a datagram on some platforms.
 473         int newSize = Math.max(rem, 1);
 474         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 475         try {
<a name="63" id="anc63"></a><span class="line-modified"> 476             int n = receiveIntoNativeBuffer(fd, bb, newSize, 0, connected);</span>
 477             bb.flip();
 478             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 479                 dst.put(bb);
 480             return n;
 481         } finally {
 482             Util.releaseTemporaryDirectBuffer(bb);
 483         }
 484     }
 485 
<a name="64" id="anc64"></a><span class="line-modified"> 486     private int receiveIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb,</span>
<span class="line-modified"> 487                                         int rem, int pos, boolean connected)</span>
 488         throws IOException
 489     {
<a name="65" id="anc65"></a><span class="line-modified"> 490         int n = receive0(fd, ((DirectBuffer)bb).address() + pos, rem, connected);</span>



 491         if (n &gt; 0)
 492             bb.position(pos + n);
 493         return n;
 494     }
 495 
<a name="66" id="anc66"></a>



















 496     public int send(ByteBuffer src, SocketAddress target)
 497         throws IOException
 498     {
 499         Objects.requireNonNull(src);
 500         InetSocketAddress isa = Net.checkAddress(target, family);
 501 
 502         writeLock.lock();
 503         try {
 504             boolean blocking = isBlocking();
<a name="67" id="anc67"></a><span class="line-modified"> 505             int n = 0;</span>

 506             try {
 507                 SocketAddress remote = beginWrite(blocking, false);
 508                 if (remote != null) {
 509                     // connected
 510                     if (!target.equals(remote)) {
 511                         throw new AlreadyConnectedException();
 512                     }
<a name="68" id="anc68"></a><span class="line-modified"> 513                     do {</span>
<span class="line-modified"> 514                         n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified"> 515                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>





 516                 } else {
 517                     // not connected
 518                     SecurityManager sm = System.getSecurityManager();
<a name="69" id="anc69"></a>
 519                     if (sm != null) {
<a name="70" id="anc70"></a><span class="line-removed"> 520                         InetAddress ia = isa.getAddress();</span>
 521                         if (ia.isMulticastAddress()) {
 522                             sm.checkMulticast(ia);
 523                         } else {
 524                             sm.checkConnect(ia.getHostAddress(), isa.getPort());
 525                         }
 526                     }
<a name="71" id="anc71"></a><span class="line-modified"> 527                     do {</span>
<span class="line-modified"> 528                         n = send(fd, src, isa);</span>
<span class="line-modified"> 529                     } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>







 530                 }
 531             } finally {
<a name="72" id="anc72"></a><span class="line-modified"> 532                 endWrite(blocking, n &gt; 0);</span>
<span class="line-removed"> 533                 assert IOStatus.check(n);</span>
 534             }
<a name="73" id="anc73"></a>
 535             return IOStatus.normalize(n);
 536         } finally {
 537             writeLock.unlock();
 538         }
 539     }
 540 
<a name="74" id="anc74"></a>


















 541     private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
 542         throws IOException
 543     {
 544         if (src instanceof DirectBuffer)
 545             return sendFromNativeBuffer(fd, src, target);
 546 
 547         // Substitute a native buffer
 548         int pos = src.position();
 549         int lim = src.limit();
 550         assert (pos &lt;= lim);
 551         int rem = (pos &lt;= lim ? lim - pos : 0);
 552 
 553         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 554         try {
 555             bb.put(src);
 556             bb.flip();
 557             // Do not update src until we see how many bytes were written
 558             src.position(pos);
 559 
 560             int n = sendFromNativeBuffer(fd, bb, target);
 561             if (n &gt; 0) {
 562                 // now update src
 563                 src.position(pos + n);
 564             }
 565             return n;
 566         } finally {
 567             Util.releaseTemporaryDirectBuffer(bb);
 568         }
 569     }
 570 
 571     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 572                                      InetSocketAddress target)
 573         throws IOException
 574     {
 575         int pos = bb.position();
 576         int lim = bb.limit();
 577         assert (pos &lt;= lim);
 578         int rem = (pos &lt;= lim ? lim - pos : 0);
 579 
<a name="75" id="anc75"></a><span class="line-removed"> 580         boolean preferIPv6 = (family != StandardProtocolFamily.INET);</span>
 581         int written;
 582         try {
<a name="76" id="anc76"></a><span class="line-modified"> 583             written = send0(preferIPv6, fd, ((DirectBuffer)bb).address() + pos,</span>
<span class="line-modified"> 584                             rem, target.getAddress(), target.getPort());</span>

 585         } catch (PortUnreachableException pue) {
 586             if (isConnected())
 587                 throw pue;
 588             written = rem;
 589         }
 590         if (written &gt; 0)
 591             bb.position(pos + written);
 592         return written;
 593     }
 594 
<a name="77" id="anc77"></a>
















 595     @Override
 596     public int read(ByteBuffer buf) throws IOException {
 597         Objects.requireNonNull(buf);
 598 
 599         readLock.lock();
 600         try {
 601             boolean blocking = isBlocking();
 602             int n = 0;
 603             try {
 604                 beginRead(blocking, true);
<a name="78" id="anc78"></a><span class="line-modified"> 605                 do {</span>
<span class="line-modified"> 606                     n = IOUtil.read(fd, buf, -1, nd);</span>
<span class="line-modified"> 607                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 608 </span>



 609             } finally {
 610                 endRead(blocking, n &gt; 0);
 611                 assert IOStatus.check(n);
 612             }
 613             return IOStatus.normalize(n);
 614         } finally {
 615             readLock.unlock();
 616         }
 617     }
 618 
 619     @Override
 620     public long read(ByteBuffer[] dsts, int offset, int length)
 621         throws IOException
 622     {
 623         Objects.checkFromIndexSize(offset, length, dsts.length);
 624 
 625         readLock.lock();
 626         try {
 627             boolean blocking = isBlocking();
 628             long n = 0;
 629             try {
 630                 beginRead(blocking, true);
<a name="79" id="anc79"></a><span class="line-modified"> 631                 do {</span>
<span class="line-modified"> 632                     n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified"> 633                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified"> 634 </span>



 635             } finally {
 636                 endRead(blocking, n &gt; 0);
 637                 assert IOStatus.check(n);
 638             }
 639             return IOStatus.normalize(n);
 640         } finally {
 641             readLock.unlock();
 642         }
 643     }
 644 
 645     /**
 646      * Marks the beginning of a write operation that might block.
 647      * @param blocking true if configured blocking
 648      * @param mustBeConnected true if the socket must be connected
 649      * @return remote address if connected
 650      * @throws ClosedChannelException if the channel is closed
 651      * @throws NotYetConnectedException if mustBeConnected and not connected
 652      * @throws IOException if socket not bound and cannot be bound
 653      */
 654     private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
 655         throws IOException
 656     {
<a name="80" id="anc80"></a><span class="line-modified"> 657         if (blocking) {</span>
 658             // set hook for Thread.interrupt
 659             begin();
 660         }
 661         SocketAddress remote;
 662         synchronized (stateLock) {
 663             ensureOpen();
 664             remote = remoteAddress;
 665             if ((remote == null) &amp;&amp; mustBeConnected)
 666                 throw new NotYetConnectedException();
 667             if (localAddress == null)
 668                 bindInternal(null);
 669             if (blocking)
 670                 writerThread = NativeThread.current();
 671         }
 672         return remote;
 673     }
 674 
 675     /**
 676      * Marks the end of a write operation that may have blocked.
 677      *
 678      * @throws AsynchronousCloseException if the channel was closed asynchronously
 679      */
 680     private void endWrite(boolean blocking, boolean completed)
 681         throws AsynchronousCloseException
 682     {
 683         if (blocking) {
 684             synchronized (stateLock) {
 685                 writerThread = 0;
<a name="81" id="anc81"></a><span class="line-removed"> 686                 // notify any thread waiting in implCloseSelectableChannel</span>
 687                 if (state == ST_CLOSING) {
<a name="82" id="anc82"></a><span class="line-modified"> 688                     stateLock.notifyAll();</span>
 689                 }
 690             }
<a name="83" id="anc83"></a><span class="line-modified"> 691             // remove hook for Thread.interrupt</span>
<span class="line-modified"> 692             end(completed);</span>





 693         }
 694     }
 695 
 696     @Override
 697     public int write(ByteBuffer buf) throws IOException {
 698         Objects.requireNonNull(buf);
 699 
 700         writeLock.lock();
 701         try {
 702             boolean blocking = isBlocking();
 703             int n = 0;
 704             try {
 705                 beginWrite(blocking, true);
<a name="84" id="anc84"></a><span class="line-modified"> 706                 do {</span>
<span class="line-modified"> 707                     n = IOUtil.write(fd, buf, -1, nd);</span>
<span class="line-modified"> 708                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>




 709             } finally {
 710                 endWrite(blocking, n &gt; 0);
 711                 assert IOStatus.check(n);
 712             }
 713             return IOStatus.normalize(n);
 714         } finally {
 715             writeLock.unlock();
 716         }
 717     }
 718 
 719     @Override
 720     public long write(ByteBuffer[] srcs, int offset, int length)
 721         throws IOException
 722     {
 723         Objects.checkFromIndexSize(offset, length, srcs.length);
 724 
 725         writeLock.lock();
 726         try {
 727             boolean blocking = isBlocking();
 728             long n = 0;
 729             try {
 730                 beginWrite(blocking, true);
<a name="85" id="anc85"></a><span class="line-modified"> 731                 do {</span>
<span class="line-modified"> 732                     n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified"> 733                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>




 734             } finally {
 735                 endWrite(blocking, n &gt; 0);
 736                 assert IOStatus.check(n);
 737             }
 738             return IOStatus.normalize(n);
 739         } finally {
 740             writeLock.unlock();
 741         }
 742     }
 743 
 744     @Override
 745     protected void implConfigureBlocking(boolean block) throws IOException {
 746         readLock.lock();
 747         try {
 748             writeLock.lock();
 749             try {
<a name="86" id="anc86"></a><span class="line-modified"> 750                 synchronized (stateLock) {</span>
<span class="line-removed"> 751                     ensureOpen();</span>
<span class="line-removed"> 752                     IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed"> 753                 }</span>
 754             } finally {
 755                 writeLock.unlock();
 756             }
 757         } finally {
 758             readLock.unlock();
 759         }
 760     }
 761 
<a name="87" id="anc87"></a>





























 762     InetSocketAddress localAddress() {
 763         synchronized (stateLock) {
 764             return localAddress;
 765         }
 766     }
 767 
 768     InetSocketAddress remoteAddress() {
 769         synchronized (stateLock) {
 770             return remoteAddress;
 771         }
 772     }
 773 
 774     @Override
 775     public DatagramChannel bind(SocketAddress local) throws IOException {
 776         readLock.lock();
 777         try {
 778             writeLock.lock();
 779             try {
 780                 synchronized (stateLock) {
 781                     ensureOpen();
 782                     if (localAddress != null)
 783                         throw new AlreadyBoundException();
 784                     bindInternal(local);
 785                 }
 786             } finally {
 787                 writeLock.unlock();
 788             }
 789         } finally {
 790             readLock.unlock();
 791         }
 792         return this;
 793     }
 794 
 795     private void bindInternal(SocketAddress local) throws IOException {
<a name="88" id="anc88"></a><span class="line-modified"> 796         assert Thread.holdsLock(stateLock) &amp;&amp; (localAddress == null);</span>
 797 
 798         InetSocketAddress isa;
 799         if (local == null) {
 800             // only Inet4Address allowed with IPv4 socket
 801             if (family == StandardProtocolFamily.INET) {
 802                 isa = new InetSocketAddress(InetAddress.getByName(&quot;0.0.0.0&quot;), 0);
 803             } else {
 804                 isa = new InetSocketAddress(0);
 805             }
 806         } else {
 807             isa = Net.checkAddress(local, family);
 808         }
 809         SecurityManager sm = System.getSecurityManager();
 810         if (sm != null)
 811             sm.checkListen(isa.getPort());
 812 
 813         Net.bind(family, fd, isa.getAddress(), isa.getPort());
 814         localAddress = Net.localAddress(fd);
 815     }
 816 
 817     @Override
 818     public boolean isConnected() {
 819         synchronized (stateLock) {
 820             return (state == ST_CONNECTED);
 821         }
 822     }
 823 
 824     @Override
 825     public DatagramChannel connect(SocketAddress sa) throws IOException {
<a name="89" id="anc89"></a>









 826         InetSocketAddress isa = Net.checkAddress(sa, family);
 827         SecurityManager sm = System.getSecurityManager();
 828         if (sm != null) {
 829             InetAddress ia = isa.getAddress();
 830             if (ia.isMulticastAddress()) {
 831                 sm.checkMulticast(ia);
 832             } else {
 833                 sm.checkConnect(ia.getHostAddress(), isa.getPort());
 834                 sm.checkAccept(ia.getHostAddress(), isa.getPort());
 835             }
 836         }
 837 
 838         readLock.lock();
 839         try {
 840             writeLock.lock();
 841             try {
 842                 synchronized (stateLock) {
 843                     ensureOpen();
<a name="90" id="anc90"></a><span class="line-modified"> 844                     if (state == ST_CONNECTED)</span>
 845                         throw new AlreadyConnectedException();
 846 
<a name="91" id="anc91"></a>







 847                     int n = Net.connect(family,
 848                                         fd,
 849                                         isa.getAddress(),
 850                                         isa.getPort());
 851                     if (n &lt;= 0)
 852                         throw new Error();      // Can&#39;t happen
 853 
 854                     // connected
 855                     remoteAddress = isa;
 856                     state = ST_CONNECTED;
 857 
 858                     // refresh local address
 859                     localAddress = Net.localAddress(fd);
 860 
 861                     // flush any packets already received.
 862                     boolean blocking = isBlocking();
 863                     if (blocking) {
 864                         IOUtil.configureBlocking(fd, false);
 865                     }
 866                     try {
 867                         ByteBuffer buf = ByteBuffer.allocate(100);
<a name="92" id="anc92"></a><span class="line-modified"> 868                         while (receive(buf) != null) {</span>
 869                             buf.clear();
 870                         }
 871                     } finally {
 872                         if (blocking) {
 873                             IOUtil.configureBlocking(fd, true);
 874                         }
 875                     }
 876                 }
 877             } finally {
 878                 writeLock.unlock();
 879             }
 880         } finally {
 881             readLock.unlock();
 882         }
 883         return this;
 884     }
 885 
 886     @Override
 887     public DatagramChannel disconnect() throws IOException {
 888         readLock.lock();
 889         try {
 890             writeLock.lock();
 891             try {
 892                 synchronized (stateLock) {
 893                     if (!isOpen() || (state != ST_CONNECTED))
 894                         return this;
 895 
 896                     // disconnect socket
 897                     boolean isIPv6 = (family == StandardProtocolFamily.INET6);
 898                     disconnect0(fd, isIPv6);
 899 
 900                     // no longer connected
 901                     remoteAddress = null;
 902                     state = ST_UNCONNECTED;
 903 
<a name="93" id="anc93"></a><span class="line-modified"> 904                     // refresh local address</span>
 905                     localAddress = Net.localAddress(fd);
<a name="94" id="anc94"></a>










 906                 }
 907             } finally {
 908                 writeLock.unlock();
 909             }
 910         } finally {
 911             readLock.unlock();
 912         }
 913         return this;
 914     }
 915 
<a name="95" id="anc95"></a>































































































































 916     /**
 917      * Joins channel&#39;s socket to the given group/interface and
 918      * optional source address.
 919      */
 920     private MembershipKey innerJoin(InetAddress group,
 921                                     NetworkInterface interf,
 922                                     InetAddress source)
 923         throws IOException
 924     {
 925         if (!group.isMulticastAddress())
 926             throw new IllegalArgumentException(&quot;Group not a multicast address&quot;);
 927 
 928         // check multicast address is compatible with this socket
 929         if (group instanceof Inet4Address) {
 930             if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.canIPv6SocketJoinIPv4Group())
 931                 throw new IllegalArgumentException(&quot;IPv6 socket cannot join IPv4 multicast group&quot;);
 932         } else if (group instanceof Inet6Address) {
 933             if (family != StandardProtocolFamily.INET6)
 934                 throw new IllegalArgumentException(&quot;Only IPv6 sockets can join IPv6 multicast group&quot;);
 935         } else {
 936             throw new IllegalArgumentException(&quot;Address type not supported&quot;);
 937         }
 938 
 939         // check source address
 940         if (source != null) {
 941             if (source.isAnyLocalAddress())
 942                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
 943             if (source.isMulticastAddress())
 944                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
 945             if (source.getClass() != group.getClass())
 946                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
 947         }
 948 
 949         SecurityManager sm = System.getSecurityManager();
 950         if (sm != null)
 951             sm.checkMulticast(group);
 952 
 953         synchronized (stateLock) {
 954             ensureOpen();
 955 
 956             // check the registry to see if we are already a member of the group
 957             if (registry == null) {
 958                 registry = new MembershipRegistry();
 959             } else {
 960                 // return existing membership key
 961                 MembershipKey key = registry.checkMembership(group, interf, source);
 962                 if (key != null)
 963                     return key;
 964             }
 965 
 966             MembershipKeyImpl key;
 967             if ((family == StandardProtocolFamily.INET6) &amp;&amp;
 968                 ((group instanceof Inet6Address) || Net.canJoin6WithIPv4Group()))
 969             {
 970                 int index = interf.getIndex();
 971                 if (index == -1)
 972                     throw new IOException(&quot;Network interface cannot be identified&quot;);
 973 
 974                 // need multicast and source address as byte arrays
 975                 byte[] groupAddress = Net.inet6AsByteArray(group);
 976                 byte[] sourceAddress = (source == null) ? null :
 977                     Net.inet6AsByteArray(source);
 978 
 979                 // join the group
 980                 int n = Net.join6(fd, groupAddress, index, sourceAddress);
 981                 if (n == IOStatus.UNAVAILABLE)
 982                     throw new UnsupportedOperationException();
 983 
 984                 key = new MembershipKeyImpl.Type6(this, group, interf, source,
 985                                                   groupAddress, index, sourceAddress);
 986 
 987             } else {
 988                 // need IPv4 address to identify interface
 989                 Inet4Address target = Net.anyInet4Address(interf);
 990                 if (target == null)
 991                     throw new IOException(&quot;Network interface not configured for IPv4&quot;);
 992 
 993                 int groupAddress = Net.inet4AsInt(group);
 994                 int targetAddress = Net.inet4AsInt(target);
 995                 int sourceAddress = (source == null) ? 0 : Net.inet4AsInt(source);
 996 
 997                 // join the group
 998                 int n = Net.join4(fd, groupAddress, targetAddress, sourceAddress);
 999                 if (n == IOStatus.UNAVAILABLE)
1000                     throw new UnsupportedOperationException();
1001 
1002                 key = new MembershipKeyImpl.Type4(this, group, interf, source,
1003                                                   groupAddress, targetAddress, sourceAddress);
1004             }
1005 
1006             registry.add(key);
1007             return key;
1008         }
1009     }
1010 
1011     @Override
1012     public MembershipKey join(InetAddress group,
1013                               NetworkInterface interf)
1014         throws IOException
1015     {
1016         return innerJoin(group, interf, null);
1017     }
1018 
1019     @Override
1020     public MembershipKey join(InetAddress group,
1021                               NetworkInterface interf,
1022                               InetAddress source)
1023         throws IOException
1024     {
1025         Objects.requireNonNull(source);
1026         return innerJoin(group, interf, source);
1027     }
1028 
1029     // package-private
1030     void drop(MembershipKeyImpl key) {
1031         assert key.channel() == this;
1032 
1033         synchronized (stateLock) {
1034             if (!key.isValid())
1035                 return;
1036 
1037             try {
1038                 if (key instanceof MembershipKeyImpl.Type6) {
1039                     MembershipKeyImpl.Type6 key6 =
1040                         (MembershipKeyImpl.Type6)key;
1041                     Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
1042                 } else {
1043                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
1044                     Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
1045                         key4.source());
1046                 }
1047             } catch (IOException ioe) {
1048                 // should not happen
1049                 throw new AssertionError(ioe);
1050             }
1051 
1052             key.invalidate();
1053             registry.remove(key);
1054         }
1055     }
1056 
1057     /**
<a name="96" id="anc96"></a><span class="line-modified">1058      * Block datagrams from given source if a memory to receive all</span>
<span class="line-modified">1059      * datagrams.</span>















1060      */
1061     void block(MembershipKeyImpl key, InetAddress source)
1062         throws IOException
1063     {
1064         assert key.channel() == this;
1065         assert key.sourceAddress() == null;
1066 
1067         synchronized (stateLock) {
1068             if (!key.isValid())
1069                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1070             if (source.isAnyLocalAddress())
1071                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1072             if (source.isMulticastAddress())
1073                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1074             if (source.getClass() != key.group().getClass())
1075                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1076 
1077             int n;
1078             if (key instanceof MembershipKeyImpl.Type6) {
1079                  MembershipKeyImpl.Type6 key6 =
1080                     (MembershipKeyImpl.Type6)key;
1081                 n = Net.block6(fd, key6.groupAddress(), key6.index(),
1082                                Net.inet6AsByteArray(source));
1083             } else {
1084                 MembershipKeyImpl.Type4 key4 =
1085                     (MembershipKeyImpl.Type4)key;
1086                 n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
1087                                Net.inet4AsInt(source));
1088             }
1089             if (n == IOStatus.UNAVAILABLE) {
1090                 // ancient kernel
1091                 throw new UnsupportedOperationException();
1092             }
1093         }
1094     }
1095 
1096     /**
<a name="97" id="anc97"></a><span class="line-modified">1097      * Unblock given source.</span>
1098      */
1099     void unblock(MembershipKeyImpl key, InetAddress source) {
1100         assert key.channel() == this;
1101         assert key.sourceAddress() == null;
1102 
1103         synchronized (stateLock) {
1104             if (!key.isValid())
1105                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1106 
1107             try {
1108                 if (key instanceof MembershipKeyImpl.Type6) {
1109                     MembershipKeyImpl.Type6 key6 =
1110                         (MembershipKeyImpl.Type6)key;
1111                     Net.unblock6(fd, key6.groupAddress(), key6.index(),
1112                                  Net.inet6AsByteArray(source));
1113                 } else {
1114                     MembershipKeyImpl.Type4 key4 =
1115                         (MembershipKeyImpl.Type4)key;
1116                     Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
1117                                  Net.inet4AsInt(source));
1118                 }
1119             } catch (IOException ioe) {
1120                 // should not happen
1121                 throw new AssertionError(ioe);
1122             }
1123         }
1124     }
1125 
1126     /**
<a name="98" id="anc98"></a><span class="line-modified">1127      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">1128      *</span>
<span class="line-removed">1129      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-removed">1130      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-removed">1131      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-removed">1132      * complete quickly.</span>
<span class="line-removed">1133      *</span>
<span class="line-removed">1134      * The socket is closed by this method when it is not registered with a</span>
<span class="line-removed">1135      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-removed">1136      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed">1137      * to blocking mode before the key is flushed from the Selector.</span>
1138      */
<a name="99" id="anc99"></a><span class="line-modified">1139     @Override</span>
<span class="line-modified">1140     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">1141         assert !isOpen();</span>












1142 
<a name="100" id="anc100"></a><span class="line-modified">1143         boolean blocking;</span>
<span class="line-modified">1144         boolean interrupted = false;</span>








1145 
<a name="101" id="anc101"></a><span class="line-modified">1146         // set state to ST_CLOSING and invalid membership keys</span>







1147         synchronized (stateLock) {
1148             assert state &lt; ST_CLOSING;
<a name="102" id="anc102"></a><span class="line-removed">1149             blocking = isBlocking();</span>
1150             state = ST_CLOSING;
1151 
1152             // if member of any multicast groups then invalidate the keys
1153             if (registry != null)
1154                 registry.invalidateAll();
<a name="103" id="anc103"></a><span class="line-removed">1155         }</span>
1156 
<a name="104" id="anc104"></a><span class="line-modified">1157         // wait for any outstanding I/O operations to complete</span>
<span class="line-removed">1158         if (blocking) {</span>
<span class="line-removed">1159             synchronized (stateLock) {</span>
<span class="line-removed">1160                 assert state == ST_CLOSING;</span>
1161                 long reader = readerThread;
1162                 long writer = writerThread;
1163                 if (reader != 0 || writer != 0) {
1164                     nd.preClose(fd);
<a name="105" id="anc105"></a><span class="line-removed">1165 </span>
1166                     if (reader != 0)
1167                         NativeThread.signal(reader);
1168                     if (writer != 0)
1169                         NativeThread.signal(writer);
<a name="106" id="anc106"></a><span class="line-removed">1170 </span>
<span class="line-removed">1171                     // wait for blocking I/O operations to end</span>
<span class="line-removed">1172                     while (readerThread != 0 || writerThread != 0) {</span>
<span class="line-removed">1173                         try {</span>
<span class="line-removed">1174                             stateLock.wait();</span>
<span class="line-removed">1175                         } catch (InterruptedException e) {</span>
<span class="line-removed">1176                             interrupted = true;</span>
<span class="line-removed">1177                         }</span>
<span class="line-removed">1178                     }</span>
1179                 }
1180             }
<a name="107" id="anc107"></a><span class="line-removed">1181         } else {</span>
<span class="line-removed">1182             // non-blocking mode: wait for read/write to complete</span>
<span class="line-removed">1183             readLock.lock();</span>
<span class="line-removed">1184             try {</span>
<span class="line-removed">1185                 writeLock.lock();</span>
<span class="line-removed">1186                 writeLock.unlock();</span>
<span class="line-removed">1187             } finally {</span>
<span class="line-removed">1188                 readLock.unlock();</span>
<span class="line-removed">1189             }</span>
1190         }
<a name="108" id="anc108"></a>
1191 
<a name="109" id="anc109"></a><span class="line-modified">1192         // set state to ST_KILLPENDING</span>






1193         synchronized (stateLock) {
<a name="110" id="anc110"></a><span class="line-modified">1194             assert state == ST_CLOSING;</span>
<span class="line-modified">1195             state = ST_KILLPENDING;</span>




1196         }
1197 
<a name="111" id="anc111"></a><span class="line-modified">1198         // close socket if not registered with Selector</span>
<span class="line-modified">1199         if (!isRegistered())</span>
<span class="line-modified">1200             kill();</span>








1201 
<a name="112" id="anc112"></a><span class="line-modified">1202         // restore interrupt status</span>
<span class="line-modified">1203         if (interrupted)</span>
<span class="line-modified">1204             Thread.currentThread().interrupt();</span>








1205     }
1206 
1207     @Override
<a name="113" id="anc113"></a><span class="line-modified">1208     public void kill() throws IOException {</span>
1209         synchronized (stateLock) {
<a name="114" id="anc114"></a><span class="line-modified">1210             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">1211                 state = ST_KILLED;</span>
<span class="line-removed">1212                 try {</span>
<span class="line-removed">1213                     nd.close(fd);</span>
<span class="line-removed">1214                 } finally {</span>
<span class="line-removed">1215                     // notify resource manager</span>
<span class="line-removed">1216                     ResourceManager.afterUdpClose();</span>
<span class="line-removed">1217                 }</span>
1218             }
1219         }
1220     }
1221 
<a name="115" id="anc115"></a><span class="line-removed">1222     @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-removed">1223     protected void finalize() throws IOException {</span>
<span class="line-removed">1224         // fd is null if constructor threw exception</span>
<span class="line-removed">1225         if (fd != null)</span>
<span class="line-removed">1226             close();</span>
<span class="line-removed">1227     }</span>
<span class="line-removed">1228 </span>
1229     /**
1230      * Translates native poll revent set into a ready operation set
1231      */
1232     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1233         int intOps = ski.nioInterestOps();
1234         int oldOps = ski.nioReadyOps();
1235         int newOps = initialOps;
1236 
1237         if ((ops &amp; Net.POLLNVAL) != 0) {
1238             // This should only happen if this channel is pre-closed while a
1239             // selection operation is in progress
1240             // ## Throw an error if this channel has not been pre-closed
1241             return false;
1242         }
1243 
1244         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1245             newOps = intOps;
1246             ski.nioReadyOps(newOps);
1247             return (newOps &amp; ~oldOps) != 0;
1248         }
1249 
1250         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1251             ((intOps &amp; SelectionKey.OP_READ) != 0))
1252             newOps |= SelectionKey.OP_READ;
1253 
1254         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1255             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
1256             newOps |= SelectionKey.OP_WRITE;
1257 
1258         ski.nioReadyOps(newOps);
1259         return (newOps &amp; ~oldOps) != 0;
1260     }
1261 
1262     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1263         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1264     }
1265 
1266     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1267         return translateReadyOps(ops, 0, ski);
1268     }
1269 
<a name="116" id="anc116"></a><span class="line-removed">1270     /**</span>
<span class="line-removed">1271      * Poll this channel&#39;s socket for reading up to the given timeout.</span>
<span class="line-removed">1272      * @return {@code true} if the socket is polled</span>
<span class="line-removed">1273      */</span>
<span class="line-removed">1274     boolean pollRead(long timeout) throws IOException {</span>
<span class="line-removed">1275         boolean blocking = isBlocking();</span>
<span class="line-removed">1276         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>
<span class="line-removed">1277 </span>
<span class="line-removed">1278         readLock.lock();</span>
<span class="line-removed">1279         try {</span>
<span class="line-removed">1280             boolean polled = false;</span>
<span class="line-removed">1281             try {</span>
<span class="line-removed">1282                 beginRead(blocking, false);</span>
<span class="line-removed">1283                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-removed">1284                 polled = (events != 0);</span>
<span class="line-removed">1285             } finally {</span>
<span class="line-removed">1286                 endRead(blocking, polled);</span>
<span class="line-removed">1287             }</span>
<span class="line-removed">1288             return polled;</span>
<span class="line-removed">1289         } finally {</span>
<span class="line-removed">1290             readLock.unlock();</span>
<span class="line-removed">1291         }</span>
<span class="line-removed">1292     }</span>
<span class="line-removed">1293 </span>
1294     /**
1295      * Translates an interest operation set into a native poll event set
1296      */
1297     public int translateInterestOps(int ops) {
1298         int newOps = 0;
1299         if ((ops &amp; SelectionKey.OP_READ) != 0)
1300             newOps |= Net.POLLIN;
1301         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1302             newOps |= Net.POLLOUT;
1303         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1304             newOps |= Net.POLLIN;
1305         return newOps;
1306     }
1307 
1308     public FileDescriptor getFD() {
1309         return fd;
1310     }
1311 
1312     public int getFDVal() {
1313         return fdVal;
1314     }
1315 
<a name="117" id="anc117"></a>















1316 
1317     // -- Native methods --
1318 
<a name="118" id="anc118"></a><span class="line-removed">1319     private static native void initIDs();</span>
<span class="line-removed">1320 </span>
1321     private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
1322         throws IOException;
1323 
<a name="119" id="anc119"></a><span class="line-modified">1324     private native int receive0(FileDescriptor fd, long address, int len,</span>
<span class="line-modified">1325                                 boolean connected)</span>
1326         throws IOException;
1327 
<a name="120" id="anc120"></a><span class="line-modified">1328     private native int send0(boolean preferIPv6, FileDescriptor fd, long address,</span>
<span class="line-modified">1329                              int len, InetAddress addr, int port)</span>
1330         throws IOException;
1331 
1332     static {
1333         IOUtil.load();
<a name="121" id="anc121"></a><span class="line-removed">1334         initIDs();</span>
1335     }
1336 }
<a name="122" id="anc122"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="122" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.net.InetAddress;
  31 import java.net.InetSocketAddress;
  32 import java.net.ProtocolFamily;
  33 import java.net.Socket;
  34 import java.net.SocketAddress;
<a name="1" id="anc1"></a><span class="line-added">  35 import java.net.SocketException;</span>
  36 import java.net.SocketOption;
<a name="2" id="anc2"></a><span class="line-added">  37 import java.net.SocketTimeoutException;</span>
  38 import java.net.StandardProtocolFamily;
  39 import java.net.StandardSocketOptions;
  40 import java.nio.ByteBuffer;
  41 import java.nio.channels.AlreadyBoundException;
  42 import java.nio.channels.AlreadyConnectedException;
  43 import java.nio.channels.AsynchronousCloseException;
  44 import java.nio.channels.ClosedChannelException;
  45 import java.nio.channels.ConnectionPendingException;
<a name="3" id="anc3"></a><span class="line-added">  46 import java.nio.channels.IllegalBlockingModeException;</span>
  47 import java.nio.channels.NoConnectionPendingException;
  48 import java.nio.channels.NotYetConnectedException;
  49 import java.nio.channels.SelectionKey;
  50 import java.nio.channels.SocketChannel;
  51 import java.nio.channels.spi.SelectorProvider;
  52 import java.util.Collections;
  53 import java.util.HashSet;
  54 import java.util.Objects;
  55 import java.util.Set;
  56 import java.util.concurrent.locks.ReentrantLock;
  57 
<a name="4" id="anc4"></a><span class="line-added">  58 import sun.net.ConnectionResetException;</span>
  59 import sun.net.NetHooks;
  60 import sun.net.ext.ExtendedSocketOptions;
  61 import sun.net.util.SocketExceptions;
  62 
  63 /**
  64  * An implementation of SocketChannels
  65  */
  66 
  67 class SocketChannelImpl
  68     extends SocketChannel
  69     implements SelChImpl
  70 {
  71     // Used to make native read and write calls
  72     private static final NativeDispatcher nd = new SocketDispatcher();
  73 
  74     // Our file descriptor object
  75     private final FileDescriptor fd;
  76     private final int fdVal;
  77 
  78     // Lock held by current reading or connecting thread
  79     private final ReentrantLock readLock = new ReentrantLock();
  80 
  81     // Lock held by current writing or connecting thread
  82     private final ReentrantLock writeLock = new ReentrantLock();
  83 
  84     // Lock held by any thread that modifies the state fields declared below
  85     // DO NOT invoke a blocking I/O operation while holding this lock!
  86     private final Object stateLock = new Object();
  87 
  88     // Input/Output closed
  89     private volatile boolean isInputClosed;
  90     private volatile boolean isOutputClosed;
  91 
<a name="5" id="anc5"></a><span class="line-added">  92     // Connection reset protected by readLock</span>
<span class="line-added">  93     private boolean connectionReset;</span>
<span class="line-added">  94 </span>
  95     // -- The following fields are protected by stateLock
  96 
  97     // set true when exclusive binding is on and SO_REUSEADDR is emulated
  98     private boolean isReuseAddress;
  99 
 100     // State, increases monotonically
 101     private static final int ST_UNCONNECTED = 0;
 102     private static final int ST_CONNECTIONPENDING = 1;
 103     private static final int ST_CONNECTED = 2;
 104     private static final int ST_CLOSING = 3;
<a name="6" id="anc6"></a><span class="line-modified"> 105     private static final int ST_CLOSED = 4;</span>

 106     private volatile int state;  // need stateLock to change
 107 
 108     // IDs of native threads doing reads and writes, for signalling
 109     private long readerThread;
 110     private long writerThread;
 111 
 112     // Binding
 113     private InetSocketAddress localAddress;
 114     private InetSocketAddress remoteAddress;
 115 
 116     // Socket adaptor, created on demand
 117     private Socket socket;
 118 
 119     // -- End of fields protected by stateLock
 120 
 121 
 122     // Constructor for normal connecting sockets
 123     //
 124     SocketChannelImpl(SelectorProvider sp) throws IOException {
 125         super(sp);
 126         this.fd = Net.socket(true);
 127         this.fdVal = IOUtil.fdVal(fd);
 128     }
 129 
 130     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
 131         throws IOException
 132     {
 133         super(sp);
 134         this.fd = fd;
 135         this.fdVal = IOUtil.fdVal(fd);
 136         if (bound) {
 137             synchronized (stateLock) {
 138                 this.localAddress = Net.localAddress(fd);
 139             }
 140         }
 141     }
 142 
 143     // Constructor for sockets obtained from server sockets
 144     //
 145     SocketChannelImpl(SelectorProvider sp, FileDescriptor fd, InetSocketAddress isa)
 146         throws IOException
 147     {
 148         super(sp);
 149         this.fd = fd;
 150         this.fdVal = IOUtil.fdVal(fd);
 151         synchronized (stateLock) {
 152             this.localAddress = Net.localAddress(fd);
 153             this.remoteAddress = isa;
 154             this.state = ST_CONNECTED;
 155         }
 156     }
 157 
 158     /**
 159      * Checks that the channel is open.
 160      *
 161      * @throws ClosedChannelException if channel is closed (or closing)
 162      */
 163     private void ensureOpen() throws ClosedChannelException {
 164         if (!isOpen())
 165             throw new ClosedChannelException();
 166     }
 167 
 168     /**
 169      * Checks that the channel is open and connected.
 170      *
 171      * @apiNote This method uses the &quot;state&quot; field to check if the channel is
 172      * open. It should never be used in conjuncion with isOpen or ensureOpen
 173      * as these methods check AbstractInterruptibleChannel&#39;s closed field - that
 174      * field is set before implCloseSelectableChannel is called and so before
 175      * the state is changed.
 176      *
 177      * @throws ClosedChannelException if channel is closed (or closing)
 178      * @throws NotYetConnectedException if open and not connected
 179      */
 180     private void ensureOpenAndConnected() throws ClosedChannelException {
 181         int state = this.state;
 182         if (state &lt; ST_CONNECTED) {
 183             throw new NotYetConnectedException();
 184         } else if (state &gt; ST_CONNECTED) {
 185             throw new ClosedChannelException();
 186         }
 187     }
 188 
 189     @Override
 190     public Socket socket() {
 191         synchronized (stateLock) {
 192             if (socket == null)
 193                 socket = SocketAdaptor.create(this);
 194             return socket;
 195         }
 196     }
 197 
 198     @Override
 199     public SocketAddress getLocalAddress() throws IOException {
 200         synchronized (stateLock) {
 201             ensureOpen();
 202             return Net.getRevealedLocalAddress(localAddress);
 203         }
 204     }
 205 
 206     @Override
 207     public SocketAddress getRemoteAddress() throws IOException {
 208         synchronized (stateLock) {
 209             ensureOpen();
 210             return remoteAddress;
 211         }
 212     }
 213 
 214     @Override
 215     public &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value)
 216         throws IOException
 217     {
 218         Objects.requireNonNull(name);
 219         if (!supportedOptions().contains(name))
 220             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<a name="7" id="anc7"></a><span class="line-added"> 221         if (!name.type().isInstance(value))</span>
<span class="line-added"> 222             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
 223 
 224         synchronized (stateLock) {
 225             ensureOpen();
 226 
 227             if (name == StandardSocketOptions.IP_TOS) {
 228                 ProtocolFamily family = Net.isIPv6Available() ?
 229                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 230                 Net.setSocketOption(fd, family, name, value);
 231                 return this;
 232             }
 233 
 234             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 235                 // SO_REUSEADDR emulated when using exclusive bind
 236                 isReuseAddress = (Boolean)value;
 237                 return this;
 238             }
 239 
 240             // no options that require special handling
<a name="8" id="anc8"></a><span class="line-modified"> 241             Net.setSocketOption(fd, name, value);</span>
 242             return this;
 243         }
 244     }
 245 
 246     @Override
 247     @SuppressWarnings(&quot;unchecked&quot;)
 248     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 249         throws IOException
 250     {
 251         Objects.requireNonNull(name);
 252         if (!supportedOptions().contains(name))
 253             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 254 
 255         synchronized (stateLock) {
 256             ensureOpen();
 257 
 258             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
 259                 // SO_REUSEADDR emulated when using exclusive bind
 260                 return (T)Boolean.valueOf(isReuseAddress);
 261             }
 262 
 263             // special handling for IP_TOS: always return 0 when IPv6
 264             if (name == StandardSocketOptions.IP_TOS) {
 265                 ProtocolFamily family = Net.isIPv6Available() ?
 266                     StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 267                 return (T) Net.getSocketOption(fd, family, name);
 268             }
 269 
 270             // no options that require special handling
<a name="9" id="anc9"></a><span class="line-modified"> 271             return (T) Net.getSocketOption(fd, name);</span>
 272         }
 273     }
 274 
 275     private static class DefaultOptionsHolder {
 276         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 277 
 278         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 279             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 280             set.add(StandardSocketOptions.SO_SNDBUF);
 281             set.add(StandardSocketOptions.SO_RCVBUF);
 282             set.add(StandardSocketOptions.SO_KEEPALIVE);
 283             set.add(StandardSocketOptions.SO_REUSEADDR);
 284             if (Net.isReusePortAvailable()) {
 285                 set.add(StandardSocketOptions.SO_REUSEPORT);
 286             }
 287             set.add(StandardSocketOptions.SO_LINGER);
 288             set.add(StandardSocketOptions.TCP_NODELAY);
 289             // additional options required by socket adaptor
 290             set.add(StandardSocketOptions.IP_TOS);
 291             set.add(ExtendedSocketOption.SO_OOBINLINE);
 292             set.addAll(ExtendedSocketOptions.clientSocketOptions());
 293             return Collections.unmodifiableSet(set);
 294         }
 295     }
 296 
 297     @Override
 298     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 299         return DefaultOptionsHolder.defaultOptions;
 300     }
 301 
 302     /**
 303      * Marks the beginning of a read operation that might block.
 304      *
 305      * @throws ClosedChannelException if the channel is closed
 306      * @throws NotYetConnectedException if the channel is not yet connected
 307      */
 308     private void beginRead(boolean blocking) throws ClosedChannelException {
 309         if (blocking) {
 310             // set hook for Thread.interrupt
 311             begin();
 312 
 313             synchronized (stateLock) {
 314                 ensureOpenAndConnected();
 315                 // record thread so it can be signalled if needed
 316                 readerThread = NativeThread.current();
 317             }
 318         } else {
 319             ensureOpenAndConnected();
 320         }
 321     }
 322 
 323     /**
 324      * Marks the end of a read operation that may have blocked.
 325      *
 326      * @throws AsynchronousCloseException if the channel was closed due to this
 327      * thread being interrupted on a blocking read operation.
 328      */
 329     private void endRead(boolean blocking, boolean completed)
 330         throws AsynchronousCloseException
 331     {
 332         if (blocking) {
 333             synchronized (stateLock) {
 334                 readerThread = 0;
<a name="10" id="anc10"></a>
 335                 if (state == ST_CLOSING) {
<a name="11" id="anc11"></a><span class="line-modified"> 336                     tryFinishClose();</span>
 337                 }
 338             }
 339             // remove hook for Thread.interrupt
 340             end(completed);
 341         }
 342     }
 343 
<a name="12" id="anc12"></a><span class="line-added"> 344     private void throwConnectionReset() throws SocketException {</span>
<span class="line-added"> 345         throw new SocketException(&quot;Connection reset&quot;);</span>
<span class="line-added"> 346     }</span>
<span class="line-added"> 347 </span>
 348     @Override
 349     public int read(ByteBuffer buf) throws IOException {
 350         Objects.requireNonNull(buf);
 351 
 352         readLock.lock();
 353         try {
 354             boolean blocking = isBlocking();
 355             int n = 0;
 356             try {
 357                 beginRead(blocking);
 358 
<a name="13" id="anc13"></a><span class="line-added"> 359                 // check if connection has been reset</span>
<span class="line-added"> 360                 if (connectionReset)</span>
<span class="line-added"> 361                     throwConnectionReset();</span>
<span class="line-added"> 362 </span>
 363                 // check if input is shutdown
 364                 if (isInputClosed)
 365                     return IOStatus.EOF;
 366 
<a name="14" id="anc14"></a><span class="line-added"> 367                 n = IOUtil.read(fd, buf, -1, nd);</span>
 368                 if (blocking) {
<a name="15" id="anc15"></a><span class="line-modified"> 369                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 370                         park(Net.POLLIN);</span>
 371                         n = IOUtil.read(fd, buf, -1, nd);
<a name="16" id="anc16"></a><span class="line-modified"> 372                     }</span>


 373                 }
<a name="17" id="anc17"></a><span class="line-added"> 374             } catch (ConnectionResetException e) {</span>
<span class="line-added"> 375                 connectionReset = true;</span>
<span class="line-added"> 376                 throwConnectionReset();</span>
 377             } finally {
 378                 endRead(blocking, n &gt; 0);
 379                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 380                     return IOStatus.EOF;
 381             }
 382             return IOStatus.normalize(n);
 383         } finally {
 384             readLock.unlock();
 385         }
 386     }
 387 
 388     @Override
 389     public long read(ByteBuffer[] dsts, int offset, int length)
 390         throws IOException
 391     {
 392         Objects.checkFromIndexSize(offset, length, dsts.length);
 393 
 394         readLock.lock();
 395         try {
 396             boolean blocking = isBlocking();
 397             long n = 0;
 398             try {
 399                 beginRead(blocking);
 400 
<a name="18" id="anc18"></a><span class="line-added"> 401                 // check if connection has been reset</span>
<span class="line-added"> 402                 if (connectionReset)</span>
<span class="line-added"> 403                     throwConnectionReset();</span>
<span class="line-added"> 404 </span>
 405                 // check if input is shutdown
 406                 if (isInputClosed)
 407                     return IOStatus.EOF;
 408 
<a name="19" id="anc19"></a><span class="line-added"> 409                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
 410                 if (blocking) {
<a name="20" id="anc20"></a><span class="line-modified"> 411                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 412                         park(Net.POLLIN);</span>
 413                         n = IOUtil.read(fd, dsts, offset, length, nd);
<a name="21" id="anc21"></a><span class="line-modified"> 414                     }</span>


 415                 }
<a name="22" id="anc22"></a><span class="line-added"> 416             } catch (ConnectionResetException e) {</span>
<span class="line-added"> 417                 connectionReset = true;</span>
<span class="line-added"> 418                 throwConnectionReset();</span>
 419             } finally {
 420                 endRead(blocking, n &gt; 0);
 421                 if (n &lt;= 0 &amp;&amp; isInputClosed)
 422                     return IOStatus.EOF;
 423             }
 424             return IOStatus.normalize(n);
 425         } finally {
 426             readLock.unlock();
 427         }
 428     }
 429 
 430     /**
 431      * Marks the beginning of a write operation that might block.
 432      *
 433      * @throws ClosedChannelException if the channel is closed or output shutdown
 434      * @throws NotYetConnectedException if the channel is not yet connected
 435      */
 436     private void beginWrite(boolean blocking) throws ClosedChannelException {
 437         if (blocking) {
 438             // set hook for Thread.interrupt
 439             begin();
 440 
 441             synchronized (stateLock) {
 442                 ensureOpenAndConnected();
 443                 if (isOutputClosed)
 444                     throw new ClosedChannelException();
 445                 // record thread so it can be signalled if needed
 446                 writerThread = NativeThread.current();
 447             }
 448         } else {
 449             ensureOpenAndConnected();
 450         }
 451     }
 452 
 453     /**
 454      * Marks the end of a write operation that may have blocked.
 455      *
 456      * @throws AsynchronousCloseException if the channel was closed due to this
 457      * thread being interrupted on a blocking write operation.
 458      */
 459     private void endWrite(boolean blocking, boolean completed)
 460         throws AsynchronousCloseException
 461     {
 462         if (blocking) {
 463             synchronized (stateLock) {
 464                 writerThread = 0;
<a name="23" id="anc23"></a>
 465                 if (state == ST_CLOSING) {
<a name="24" id="anc24"></a><span class="line-modified"> 466                     tryFinishClose();</span>
 467                 }
 468             }
 469             // remove hook for Thread.interrupt
 470             end(completed);
 471         }
 472     }
 473 
 474     @Override
 475     public int write(ByteBuffer buf) throws IOException {
 476         Objects.requireNonNull(buf);
 477 
 478         writeLock.lock();
 479         try {
 480             boolean blocking = isBlocking();
 481             int n = 0;
 482             try {
 483                 beginWrite(blocking);
<a name="25" id="anc25"></a><span class="line-added"> 484                 n = IOUtil.write(fd, buf, -1, nd);</span>
 485                 if (blocking) {
<a name="26" id="anc26"></a><span class="line-modified"> 486                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 487                         park(Net.POLLOUT);</span>
 488                         n = IOUtil.write(fd, buf, -1, nd);
<a name="27" id="anc27"></a><span class="line-modified"> 489                     }</span>


 490                 }
 491             } finally {
 492                 endWrite(blocking, n &gt; 0);
 493                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 494                     throw new AsynchronousCloseException();
 495             }
 496             return IOStatus.normalize(n);
 497         } finally {
 498             writeLock.unlock();
 499         }
 500     }
 501 
 502     @Override
 503     public long write(ByteBuffer[] srcs, int offset, int length)
 504         throws IOException
 505     {
 506         Objects.checkFromIndexSize(offset, length, srcs.length);
 507 
 508         writeLock.lock();
 509         try {
 510             boolean blocking = isBlocking();
 511             long n = 0;
 512             try {
 513                 beginWrite(blocking);
<a name="28" id="anc28"></a><span class="line-added"> 514                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
 515                 if (blocking) {
<a name="29" id="anc29"></a><span class="line-modified"> 516                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added"> 517                         park(Net.POLLOUT);</span>
 518                         n = IOUtil.write(fd, srcs, offset, length, nd);
<a name="30" id="anc30"></a><span class="line-modified"> 519                     }</span>


 520                 }
 521             } finally {
 522                 endWrite(blocking, n &gt; 0);
 523                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 524                     throw new AsynchronousCloseException();
 525             }
 526             return IOStatus.normalize(n);
 527         } finally {
 528             writeLock.unlock();
 529         }
 530     }
 531 
 532     /**
 533      * Writes a byte of out of band data.
 534      */
 535     int sendOutOfBandData(byte b) throws IOException {
 536         writeLock.lock();
 537         try {
 538             boolean blocking = isBlocking();
 539             int n = 0;
 540             try {
 541                 beginWrite(blocking);
 542                 if (blocking) {
 543                     do {
 544                         n = Net.sendOOB(fd, b);
 545                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
 546                 } else {
 547                     n = Net.sendOOB(fd, b);
 548                 }
 549             } finally {
 550                 endWrite(blocking, n &gt; 0);
 551                 if (n &lt;= 0 &amp;&amp; isOutputClosed)
 552                     throw new AsynchronousCloseException();
 553             }
 554             return IOStatus.normalize(n);
 555         } finally {
 556             writeLock.unlock();
 557         }
 558     }
 559 
 560     @Override
 561     protected void implConfigureBlocking(boolean block) throws IOException {
 562         readLock.lock();
 563         try {
 564             writeLock.lock();
 565             try {
<a name="31" id="anc31"></a><span class="line-modified"> 566                 lockedConfigureBlocking(block);</span>



 567             } finally {
 568                 writeLock.unlock();
 569             }
 570         } finally {
 571             readLock.unlock();
 572         }
 573     }
 574 
<a name="32" id="anc32"></a><span class="line-added"> 575     /**</span>
<span class="line-added"> 576      * Adjusts the blocking mode. readLock or writeLock must already be held.</span>
<span class="line-added"> 577      */</span>
<span class="line-added"> 578     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added"> 579         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added"> 580         synchronized (stateLock) {</span>
<span class="line-added"> 581             ensureOpen();</span>
<span class="line-added"> 582             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added"> 583         }</span>
<span class="line-added"> 584     }</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     /**</span>
<span class="line-added"> 587      * Adjusts the blocking mode if the channel is open. readLock or writeLock</span>
<span class="line-added"> 588      * must already be held.</span>
<span class="line-added"> 589      *</span>
<span class="line-added"> 590      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-added"> 591      *         the blocking mode was not adjusted because the channel is closed</span>
<span class="line-added"> 592      */</span>
<span class="line-added"> 593     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added"> 594         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added"> 595         synchronized (stateLock) {</span>
<span class="line-added"> 596             if (isOpen()) {</span>
<span class="line-added"> 597                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added"> 598                 return true;</span>
<span class="line-added"> 599             } else {</span>
<span class="line-added"> 600                 return false;</span>
<span class="line-added"> 601             }</span>
<span class="line-added"> 602         }</span>
<span class="line-added"> 603     }</span>
<span class="line-added"> 604 </span>
 605     /**
 606      * Returns the local address, or null if not bound
 607      */
 608     InetSocketAddress localAddress() {
 609         synchronized (stateLock) {
 610             return localAddress;
 611         }
 612     }
 613 
 614     /**
 615      * Returns the remote address, or null if not connected
 616      */
 617     InetSocketAddress remoteAddress() {
 618         synchronized (stateLock) {
 619             return remoteAddress;
 620         }
 621     }
 622 
 623     @Override
 624     public SocketChannel bind(SocketAddress local) throws IOException {
 625         readLock.lock();
 626         try {
 627             writeLock.lock();
 628             try {
 629                 synchronized (stateLock) {
 630                     ensureOpen();
 631                     if (state == ST_CONNECTIONPENDING)
 632                         throw new ConnectionPendingException();
 633                     if (localAddress != null)
 634                         throw new AlreadyBoundException();
 635                     InetSocketAddress isa = (local == null) ?
 636                         new InetSocketAddress(0) : Net.checkAddress(local);
 637                     SecurityManager sm = System.getSecurityManager();
 638                     if (sm != null) {
 639                         sm.checkListen(isa.getPort());
 640                     }
 641                     NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
 642                     Net.bind(fd, isa.getAddress(), isa.getPort());
 643                     localAddress = Net.localAddress(fd);
 644                 }
 645             } finally {
 646                 writeLock.unlock();
 647             }
 648         } finally {
 649             readLock.unlock();
 650         }
 651         return this;
 652     }
 653 
 654     @Override
 655     public boolean isConnected() {
 656         return (state == ST_CONNECTED);
 657     }
 658 
 659     @Override
 660     public boolean isConnectionPending() {
 661         return (state == ST_CONNECTIONPENDING);
 662     }
 663 
 664     /**
 665      * Marks the beginning of a connect operation that might block.
 666      * @param blocking true if configured blocking
 667      * @param isa the remote address
 668      * @throws ClosedChannelException if the channel is closed
 669      * @throws AlreadyConnectedException if already connected
 670      * @throws ConnectionPendingException is a connection is pending
 671      * @throws IOException if the pre-connect hook fails
 672      */
 673     private void beginConnect(boolean blocking, InetSocketAddress isa)
 674         throws IOException
 675     {
 676         if (blocking) {
 677             // set hook for Thread.interrupt
 678             begin();
 679         }
 680         synchronized (stateLock) {
 681             ensureOpen();
 682             int state = this.state;
 683             if (state == ST_CONNECTED)
 684                 throw new AlreadyConnectedException();
 685             if (state == ST_CONNECTIONPENDING)
 686                 throw new ConnectionPendingException();
 687             assert state == ST_UNCONNECTED;
 688             this.state = ST_CONNECTIONPENDING;
 689 
 690             if (localAddress == null)
 691                 NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());
 692             remoteAddress = isa;
 693 
 694             if (blocking) {
 695                 // record thread so it can be signalled if needed
 696                 readerThread = NativeThread.current();
 697             }
 698         }
 699     }
 700 
 701     /**
 702      * Marks the end of a connect operation that may have blocked.
 703      *
 704      * @throws AsynchronousCloseException if the channel was closed due to this
 705      * thread being interrupted on a blocking connect operation.
 706      * @throws IOException if completed and unable to obtain the local address
 707      */
 708     private void endConnect(boolean blocking, boolean completed)
 709         throws IOException
 710     {
 711         endRead(blocking, completed);
 712 
 713         if (completed) {
 714             synchronized (stateLock) {
 715                 if (state == ST_CONNECTIONPENDING) {
 716                     localAddress = Net.localAddress(fd);
 717                     state = ST_CONNECTED;
 718                 }
 719             }
 720         }
 721     }
 722 
<a name="33" id="anc33"></a><span class="line-modified"> 723     /**</span>
<span class="line-modified"> 724      * Checks the remote address to which this channel is to be connected.</span>
<span class="line-added"> 725      */</span>
<span class="line-added"> 726     private InetSocketAddress checkRemote(SocketAddress sa) throws IOException {</span>
 727         InetSocketAddress isa = Net.checkAddress(sa);
 728         SecurityManager sm = System.getSecurityManager();
<a name="34" id="anc34"></a><span class="line-modified"> 729         if (sm != null) {</span>
 730             sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
<a name="35" id="anc35"></a><span class="line-added"> 731         }</span>
<span class="line-added"> 732         if (isa.getAddress().isAnyLocalAddress()) {</span>
<span class="line-added"> 733             return new InetSocketAddress(InetAddress.getLocalHost(), isa.getPort());</span>
<span class="line-added"> 734         } else {</span>
<span class="line-added"> 735             return isa;</span>
<span class="line-added"> 736         }</span>
<span class="line-added"> 737     }</span>
 738 
<a name="36" id="anc36"></a><span class="line-modified"> 739     @Override</span>
<span class="line-modified"> 740     public boolean connect(SocketAddress remote) throws IOException {</span>
<span class="line-modified"> 741         InetSocketAddress isa = checkRemote(remote);</span>

 742         try {
 743             readLock.lock();
 744             try {
 745                 writeLock.lock();
 746                 try {
<a name="37" id="anc37"></a>
 747                     boolean blocking = isBlocking();
<a name="38" id="anc38"></a><span class="line-added"> 748                     boolean connected = false;</span>
 749                     try {
 750                         beginConnect(blocking, isa);
<a name="39" id="anc39"></a><span class="line-modified"> 751                         int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>
<span class="line-modified"> 752                         if (n &gt; 0) {</span>
<span class="line-modified"> 753                             connected = true;</span>
<span class="line-added"> 754                         } else if (blocking) {</span>
<span class="line-added"> 755                             assert IOStatus.okayToRetry(n);</span>
<span class="line-added"> 756                             boolean polled = false;</span>
<span class="line-added"> 757                             while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-added"> 758                                 park(Net.POLLOUT);</span>
<span class="line-added"> 759                                 polled = Net.pollConnectNow(fd);</span>
<span class="line-added"> 760                             }</span>
<span class="line-added"> 761                             connected = polled &amp;&amp; isOpen();</span>
<span class="line-added"> 762                         }</span>
 763                     } finally {
<a name="40" id="anc40"></a><span class="line-modified"> 764                         endConnect(blocking, connected);</span>
 765                     }
<a name="41" id="anc41"></a><span class="line-modified"> 766                     return connected;</span>

 767                 } finally {
 768                     writeLock.unlock();
 769                 }
 770             } finally {
 771                 readLock.unlock();
 772             }
 773         } catch (IOException ioe) {
 774             // connect failed, close the channel
 775             close();
 776             throw SocketExceptions.of(ioe, isa);
 777         }
 778     }
 779 
 780     /**
 781      * Marks the beginning of a finishConnect operation that might block.
 782      *
 783      * @throws ClosedChannelException if the channel is closed
 784      * @throws NoConnectionPendingException if no connection is pending
 785      */
 786     private void beginFinishConnect(boolean blocking) throws ClosedChannelException {
 787         if (blocking) {
 788             // set hook for Thread.interrupt
 789             begin();
 790         }
 791         synchronized (stateLock) {
 792             ensureOpen();
 793             if (state != ST_CONNECTIONPENDING)
 794                 throw new NoConnectionPendingException();
 795             if (blocking) {
 796                 // record thread so it can be signalled if needed
 797                 readerThread = NativeThread.current();
 798             }
 799         }
 800     }
 801 
 802     /**
 803      * Marks the end of a finishConnect operation that may have blocked.
 804      *
 805      * @throws AsynchronousCloseException if the channel was closed due to this
 806      * thread being interrupted on a blocking connect operation.
 807      * @throws IOException if completed and unable to obtain the local address
 808      */
 809     private void endFinishConnect(boolean blocking, boolean completed)
 810         throws IOException
 811     {
 812         endRead(blocking, completed);
 813 
 814         if (completed) {
 815             synchronized (stateLock) {
 816                 if (state == ST_CONNECTIONPENDING) {
 817                     localAddress = Net.localAddress(fd);
 818                     state = ST_CONNECTED;
 819                 }
 820             }
 821         }
 822     }
 823 
 824     @Override
 825     public boolean finishConnect() throws IOException {
 826         try {
 827             readLock.lock();
 828             try {
 829                 writeLock.lock();
 830                 try {
 831                     // no-op if already connected
 832                     if (isConnected())
 833                         return true;
 834 
 835                     boolean blocking = isBlocking();
 836                     boolean connected = false;
 837                     try {
 838                         beginFinishConnect(blocking);
<a name="42" id="anc42"></a><span class="line-modified"> 839                         boolean polled = Net.pollConnectNow(fd);</span>
 840                         if (blocking) {
<a name="43" id="anc43"></a><span class="line-modified"> 841                             while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-modified"> 842                                 park(Net.POLLOUT);</span>
<span class="line-modified"> 843                                 polled = Net.pollConnectNow(fd);</span>
<span class="line-modified"> 844                             }</span>

 845                         }
<a name="44" id="anc44"></a><span class="line-modified"> 846                         connected = polled &amp;&amp; isOpen();</span>
 847                     } finally {
 848                         endFinishConnect(blocking, connected);
 849                     }
 850                     assert (blocking &amp;&amp; connected) ^ !blocking;
 851                     return connected;
 852                 } finally {
 853                     writeLock.unlock();
 854                 }
 855             } finally {
 856                 readLock.unlock();
 857             }
 858         } catch (IOException ioe) {
 859             // connect failed, close the channel
 860             close();
 861             throw SocketExceptions.of(ioe, remoteAddress);
 862         }
 863     }
 864 
 865     /**
<a name="45" id="anc45"></a><span class="line-modified"> 866      * Closes the socket if there are no I/O operations in progress and the</span>
<span class="line-added"> 867      * channel is not registered with a Selector.</span>
<span class="line-added"> 868      */</span>
<span class="line-added"> 869     private boolean tryClose() throws IOException {</span>
<span class="line-added"> 870         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-added"> 871         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added"> 872             state = ST_CLOSED;</span>
<span class="line-added"> 873             nd.close(fd);</span>
<span class="line-added"> 874             return true;</span>
<span class="line-added"> 875         } else {</span>
<span class="line-added"> 876             return false;</span>
<span class="line-added"> 877         }</span>
<span class="line-added"> 878     }</span>
<span class="line-added"> 879 </span>
<span class="line-added"> 880     /**</span>
<span class="line-added"> 881      * Invokes tryClose to attempt to close the socket.</span>
 882      *
<a name="46" id="anc46"></a><span class="line-modified"> 883      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-modified"> 884      */</span>
<span class="line-modified"> 885     private void tryFinishClose() {</span>
<span class="line-modified"> 886         try {</span>
<span class="line-added"> 887             tryClose();</span>
<span class="line-added"> 888         } catch (IOException ignore) { }</span>
<span class="line-added"> 889     }</span>
<span class="line-added"> 890 </span>
<span class="line-added"> 891     /**</span>
<span class="line-added"> 892      * Closes this channel when configured in blocking mode.</span>
 893      *
<a name="47" id="anc47"></a><span class="line-modified"> 894      * If there is an I/O operation in progress then the socket is pre-closed</span>
<span class="line-modified"> 895      * and the I/O threads signalled, in which case the final close is deferred</span>
<span class="line-modified"> 896      * until all I/O operations complete.</span>
 897      *
<a name="48" id="anc48"></a><span class="line-modified"> 898      * Note that a channel configured blocking may be registered with a Selector</span>
<span class="line-modified"> 899      * This arises when a key is canceled and the channel configured to blocking</span>
<span class="line-modified"> 900      * mode before the key is flushed from the Selector.</span>

 901      */
<a name="49" id="anc49"></a><span class="line-modified"> 902     private void implCloseBlockingMode() throws IOException {</span>








 903         synchronized (stateLock) {
 904             assert state &lt; ST_CLOSING;
<a name="50" id="anc50"></a>

 905             state = ST_CLOSING;
<a name="51" id="anc51"></a><span class="line-modified"> 906             if (!tryClose()) {</span>





 907                 long reader = readerThread;
 908                 long writer = writerThread;
 909                 if (reader != 0 || writer != 0) {
 910                     nd.preClose(fd);
<a name="52" id="anc52"></a>

 911                     if (reader != 0)
 912                         NativeThread.signal(reader);
 913                     if (writer != 0)
 914                         NativeThread.signal(writer);
<a name="53" id="anc53"></a>








 915                 }
 916             }
<a name="54" id="anc54"></a>








 917         }
<a name="55" id="anc55"></a><span class="line-added"> 918     }</span>
 919 
<a name="56" id="anc56"></a><span class="line-modified"> 920     /**</span>
<span class="line-added"> 921      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added"> 922      *</span>
<span class="line-added"> 923      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added"> 924      * until the channel is flushed from all Selectors.</span>
<span class="line-added"> 925      *</span>
<span class="line-added"> 926      * If the socket is connected and the channel is registered with a Selector</span>
<span class="line-added"> 927      * then the socket is shutdown for writing so that the peer reads EOF. In</span>
<span class="line-added"> 928      * addition, if SO_LINGER is set to a non-zero value then it is disabled so</span>
<span class="line-added"> 929      * that the deferred close does not wait.</span>
<span class="line-added"> 930      */</span>
<span class="line-added"> 931     private void implCloseNonBlockingMode() throws IOException {</span>
<span class="line-added"> 932         boolean connected;</span>
<span class="line-added"> 933         synchronized (stateLock) {</span>
<span class="line-added"> 934             assert state &lt; ST_CLOSING;</span>
<span class="line-added"> 935             connected = (state == ST_CONNECTED);</span>
<span class="line-added"> 936             state = ST_CLOSING;</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         // wait for any read/write operations to complete</span>
<span class="line-added"> 940         readLock.lock();</span>
<span class="line-added"> 941         readLock.unlock();</span>
<span class="line-added"> 942         writeLock.lock();</span>
<span class="line-added"> 943         writeLock.unlock();</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945         // if the socket cannot be closed because it&#39;s registered with a Selector</span>
<span class="line-added"> 946         // then shutdown the socket for writing.</span>
 947         synchronized (stateLock) {
<a name="57" id="anc57"></a><span class="line-modified"> 948             if (state == ST_CLOSING &amp;&amp; !tryClose() &amp;&amp; connected &amp;&amp; isRegistered()) {</span>






 949                 try {
 950                     SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
 951                     int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
 952                     if (interval != 0) {
 953                         if (interval &gt; 0) {
 954                             // disable SO_LINGER
 955                             Net.setSocketOption(fd, Net.UNSPEC, opt, -1);
 956                         }
 957                         Net.shutdown(fd, Net.SHUT_WR);
 958                     }
 959                 } catch (IOException ignore) { }
 960             }
<a name="58" id="anc58"></a>
 961         }
<a name="59" id="anc59"></a><span class="line-added"> 962     }</span>
 963 
<a name="60" id="anc60"></a><span class="line-modified"> 964     /**</span>
<span class="line-modified"> 965      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified"> 966      */</span>
<span class="line-modified"> 967     @Override</span>
<span class="line-modified"> 968     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified"> 969         assert !isOpen();</span>
<span class="line-modified"> 970         if (isBlocking()) {</span>
<span class="line-added"> 971             implCloseBlockingMode();</span>
<span class="line-added"> 972         } else {</span>
<span class="line-added"> 973             implCloseNonBlockingMode();</span>
<span class="line-added"> 974         }</span>
 975     }
 976 
 977     @Override
<a name="61" id="anc61"></a><span class="line-modified"> 978     public void kill() {</span>
 979         synchronized (stateLock) {
<a name="62" id="anc62"></a><span class="line-modified"> 980             if (state == ST_CLOSING) {</span>
<span class="line-modified"> 981                 tryFinishClose();</span>

 982             }
 983         }
 984     }
 985 
 986     @Override
 987     public SocketChannel shutdownInput() throws IOException {
 988         synchronized (stateLock) {
 989             ensureOpen();
 990             if (!isConnected())
 991                 throw new NotYetConnectedException();
 992             if (!isInputClosed) {
 993                 Net.shutdown(fd, Net.SHUT_RD);
 994                 long thread = readerThread;
 995                 if (thread != 0)
 996                     NativeThread.signal(thread);
 997                 isInputClosed = true;
 998             }
 999             return this;
1000         }
1001     }
1002 
1003     @Override
1004     public SocketChannel shutdownOutput() throws IOException {
1005         synchronized (stateLock) {
1006             ensureOpen();
1007             if (!isConnected())
1008                 throw new NotYetConnectedException();
1009             if (!isOutputClosed) {
1010                 Net.shutdown(fd, Net.SHUT_WR);
1011                 long thread = writerThread;
1012                 if (thread != 0)
1013                     NativeThread.signal(thread);
1014                 isOutputClosed = true;
1015             }
1016             return this;
1017         }
1018     }
1019 
1020     boolean isInputOpen() {
1021         return !isInputClosed;
1022     }
1023 
1024     boolean isOutputOpen() {
1025         return !isOutputClosed;
1026     }
1027 
1028     /**
<a name="63" id="anc63"></a><span class="line-modified">1029      * Waits for a connection attempt to finish with a timeout</span>
<span class="line-modified">1030      * @throws SocketTimeoutException if the connect timeout elapses</span>
<span class="line-added">1031      */</span>
<span class="line-added">1032     private boolean finishTimedConnect(long nanos) throws IOException {</span>
<span class="line-added">1033         long startNanos = System.nanoTime();</span>
<span class="line-added">1034         boolean polled = Net.pollConnectNow(fd);</span>
<span class="line-added">1035         while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-added">1036             long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">1037             if (remainingNanos &lt;= 0) {</span>
<span class="line-added">1038                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>
<span class="line-added">1039             }</span>
<span class="line-added">1040             park(Net.POLLOUT, remainingNanos);</span>
<span class="line-added">1041             polled = Net.pollConnectNow(fd);</span>
<span class="line-added">1042         }</span>
<span class="line-added">1043         return polled &amp;&amp; isOpen();</span>
<span class="line-added">1044     }</span>
<span class="line-added">1045 </span>
<span class="line-added">1046     /**</span>
<span class="line-added">1047      * Attempts to establish a connection to the given socket address with a</span>
<span class="line-added">1048      * timeout. Closes the socket if connection cannot be established.</span>
<span class="line-added">1049      *</span>
<span class="line-added">1050      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">1051      *</span>
<span class="line-added">1052      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">1053      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">1054      */</span>
<span class="line-added">1055     void blockingConnect(SocketAddress remote, long nanos) throws IOException {</span>
<span class="line-added">1056         InetSocketAddress isa = checkRemote(remote);</span>
<span class="line-added">1057         try {</span>
<span class="line-added">1058             readLock.lock();</span>
<span class="line-added">1059             try {</span>
<span class="line-added">1060                 writeLock.lock();</span>
<span class="line-added">1061                 try {</span>
<span class="line-added">1062                     if (!isBlocking())</span>
<span class="line-added">1063                         throw new IllegalBlockingModeException();</span>
<span class="line-added">1064                     boolean connected = false;</span>
<span class="line-added">1065                     try {</span>
<span class="line-added">1066                         beginConnect(true, isa);</span>
<span class="line-added">1067                         // change socket to non-blocking</span>
<span class="line-added">1068                         lockedConfigureBlocking(false);</span>
<span class="line-added">1069                         try {</span>
<span class="line-added">1070                             int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>
<span class="line-added">1071                             connected = (n &gt; 0) ? true : finishTimedConnect(nanos);</span>
<span class="line-added">1072                         } finally {</span>
<span class="line-added">1073                             // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">1074                             tryLockedConfigureBlocking(true);</span>
<span class="line-added">1075                         }</span>
<span class="line-added">1076                     } finally {</span>
<span class="line-added">1077                         endConnect(true, connected);</span>
<span class="line-added">1078                     }</span>
<span class="line-added">1079                 } finally {</span>
<span class="line-added">1080                     writeLock.unlock();</span>
<span class="line-added">1081                 }</span>
<span class="line-added">1082             } finally {</span>
<span class="line-added">1083                 readLock.unlock();</span>
<span class="line-added">1084             }</span>
<span class="line-added">1085         } catch (IOException ioe) {</span>
<span class="line-added">1086             // connect failed, close the channel</span>
<span class="line-added">1087             close();</span>
<span class="line-added">1088             throw SocketExceptions.of(ioe, isa);</span>
<span class="line-added">1089         }</span>
<span class="line-added">1090     }</span>
<span class="line-added">1091 </span>
<span class="line-added">1092     /**</span>
<span class="line-added">1093      * Attempts to read bytes from the socket into the given byte array.</span>
1094      */
<a name="64" id="anc64"></a><span class="line-modified">1095     private int tryRead(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">1096         ByteBuffer dst = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">1097         assert dst.position() == 0;</span>
<span class="line-added">1098         try {</span>
<span class="line-added">1099             int n = nd.read(fd, ((DirectBuffer)dst).address(), len);</span>
<span class="line-added">1100             if (n &gt; 0) {</span>
<span class="line-added">1101                 dst.get(b, off, n);</span>
<span class="line-added">1102             }</span>
<span class="line-added">1103             return n;</span>
<span class="line-added">1104         } finally{</span>
<span class="line-added">1105             Util.offerFirstTemporaryDirectBuffer(dst);</span>
<span class="line-added">1106         }</span>
<span class="line-added">1107     }</span>
<span class="line-added">1108 </span>
<span class="line-added">1109     /**</span>
<span class="line-added">1110      * Reads bytes from the socket into the given byte array with a timeout.</span>
<span class="line-added">1111      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">1112      */</span>
<span class="line-added">1113     private int timedRead(byte[] b, int off, int len, long nanos) throws IOException {</span>
<span class="line-added">1114         long startNanos = System.nanoTime();</span>
<span class="line-added">1115         int n = tryRead(b, off, len);</span>
<span class="line-added">1116         while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-added">1117             long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">1118             if (remainingNanos &lt;= 0) {</span>
<span class="line-added">1119                 throw new SocketTimeoutException(&quot;Read timed out&quot;);</span>
<span class="line-added">1120             }</span>
<span class="line-added">1121             park(Net.POLLIN, remainingNanos);</span>
<span class="line-added">1122             n = tryRead(b, off, len);</span>
<span class="line-added">1123         }</span>
<span class="line-added">1124         return n;</span>
<span class="line-added">1125     }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127     /**</span>
<span class="line-added">1128      * Reads bytes from the socket into the given byte array.</span>
<span class="line-added">1129      *</span>
<span class="line-added">1130      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">1131      *</span>
<span class="line-added">1132      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">1133      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">1134      */</span>
<span class="line-added">1135     int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {</span>
<span class="line-added">1136         Objects.checkFromIndexSize(off, len, b.length);</span>
<span class="line-added">1137         if (len == 0) {</span>
<span class="line-added">1138             // nothing to do</span>
<span class="line-added">1139             return 0;</span>
<span class="line-added">1140         }</span>
1141 
1142         readLock.lock();
1143         try {
<a name="65" id="anc65"></a><span class="line-modified">1144             // check that channel is configured blocking</span>
<span class="line-added">1145             if (!isBlocking())</span>
<span class="line-added">1146                 throw new IllegalBlockingModeException();</span>
<span class="line-added">1147 </span>
<span class="line-added">1148             int n = 0;</span>
1149             try {
<a name="66" id="anc66"></a><span class="line-modified">1150                 beginRead(true);</span>
<span class="line-modified">1151 </span>
<span class="line-modified">1152                 // check if connection has been reset</span>
<span class="line-added">1153                 if (connectionReset)</span>
<span class="line-added">1154                     throwConnectionReset();</span>
<span class="line-added">1155 </span>
<span class="line-added">1156                 // check if input is shutdown</span>
<span class="line-added">1157                 if (isInputClosed)</span>
<span class="line-added">1158                     return IOStatus.EOF;</span>
<span class="line-added">1159 </span>
<span class="line-added">1160                 if (nanos &gt; 0) {</span>
<span class="line-added">1161                     // change socket to non-blocking</span>
<span class="line-added">1162                     lockedConfigureBlocking(false);</span>
<span class="line-added">1163                     try {</span>
<span class="line-added">1164                         n = timedRead(b, off, len, nanos);</span>
<span class="line-added">1165                     } finally {</span>
<span class="line-added">1166                         // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">1167                         tryLockedConfigureBlocking(true);</span>
<span class="line-added">1168                     }</span>
<span class="line-added">1169                 } else {</span>
<span class="line-added">1170                     // read, no timeout</span>
<span class="line-added">1171                     n = tryRead(b, off, len);</span>
<span class="line-added">1172                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">1173                         park(Net.POLLIN);</span>
<span class="line-added">1174                         n = tryRead(b, off, len);</span>
<span class="line-added">1175                     }</span>
<span class="line-added">1176                 }</span>
<span class="line-added">1177             } catch (ConnectionResetException e) {</span>
<span class="line-added">1178                 connectionReset = true;</span>
<span class="line-added">1179                 throwConnectionReset();</span>
1180             } finally {
<a name="67" id="anc67"></a><span class="line-modified">1181                 endRead(true, n &gt; 0);</span>
<span class="line-added">1182                 if (n &lt;= 0 &amp;&amp; isInputClosed)</span>
<span class="line-added">1183                     return IOStatus.EOF;</span>
1184             }
<a name="68" id="anc68"></a><span class="line-modified">1185             assert n &gt; 0 || n == -1;</span>
<span class="line-added">1186             return n;</span>
1187         } finally {
1188             readLock.unlock();
1189         }
1190     }
1191 
1192     /**
<a name="69" id="anc69"></a><span class="line-modified">1193      * Attempts to write a sequence of bytes to the socket from the given</span>
<span class="line-modified">1194      * byte array.</span>
1195      */
<a name="70" id="anc70"></a><span class="line-modified">1196     private int tryWrite(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">1197         ByteBuffer src = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">1198         assert src.position() == 0;</span>
<span class="line-added">1199         try {</span>
<span class="line-added">1200             src.put(b, off, len);</span>
<span class="line-added">1201             return nd.write(fd, ((DirectBuffer)src).address(), len);</span>
<span class="line-added">1202         } finally {</span>
<span class="line-added">1203             Util.offerFirstTemporaryDirectBuffer(src);</span>
<span class="line-added">1204         }</span>
<span class="line-added">1205     }</span>
1206 
<a name="71" id="anc71"></a><span class="line-modified">1207     /**</span>
<span class="line-added">1208      * Writes a sequence of bytes to the socket from the given byte array.</span>
<span class="line-added">1209      *</span>
<span class="line-added">1210      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">1211      */</span>
<span class="line-added">1212     void blockingWriteFully(byte[] b, int off, int len) throws IOException {</span>
<span class="line-added">1213         Objects.checkFromIndexSize(off, len, b.length);</span>
<span class="line-added">1214         if (len == 0) {</span>
<span class="line-added">1215             // nothing to do</span>
<span class="line-added">1216             return;</span>
<span class="line-added">1217         }</span>
<span class="line-added">1218 </span>
<span class="line-added">1219         writeLock.lock();</span>
1220         try {
<a name="72" id="anc72"></a><span class="line-modified">1221             // check that channel is configured blocking</span>
<span class="line-added">1222             if (!isBlocking())</span>
<span class="line-added">1223                 throw new IllegalBlockingModeException();</span>
<span class="line-added">1224 </span>
<span class="line-added">1225             // loop until all bytes have been written</span>
<span class="line-added">1226             int pos = off;</span>
<span class="line-added">1227             int end = off + len;</span>
<span class="line-added">1228             beginWrite(true);</span>
1229             try {
<a name="73" id="anc73"></a><span class="line-modified">1230                 while (pos &lt; end &amp;&amp; isOpen()) {</span>
<span class="line-modified">1231                     int size = end - pos;</span>
<span class="line-modified">1232                     int n = tryWrite(b, pos, size);</span>
<span class="line-modified">1233                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified">1234                         park(Net.POLLOUT);</span>
<span class="line-modified">1235                         n = tryWrite(b, pos, size);</span>
<span class="line-modified">1236                     }</span>
<span class="line-modified">1237                     if (n &gt; 0) {</span>
<span class="line-modified">1238                         pos += n;</span>
<span class="line-modified">1239                     }</span>
1240                 }
<a name="74" id="anc74"></a>
1241             } finally {
<a name="75" id="anc75"></a><span class="line-modified">1242                 endWrite(true, pos &gt;= end);</span>
1243             }
1244         } finally {
<a name="76" id="anc76"></a><span class="line-modified">1245             writeLock.unlock();</span>
<span class="line-added">1246         }</span>
<span class="line-added">1247     }</span>
<span class="line-added">1248 </span>
<span class="line-added">1249     /**</span>
<span class="line-added">1250      * Return the number of bytes in the socket input buffer.</span>
<span class="line-added">1251      */</span>
<span class="line-added">1252     int available() throws IOException {</span>
<span class="line-added">1253         synchronized (stateLock) {</span>
<span class="line-added">1254             ensureOpenAndConnected();</span>
<span class="line-added">1255             if (isInputClosed) {</span>
<span class="line-added">1256                 return 0;</span>
<span class="line-added">1257             } else {</span>
<span class="line-added">1258                 return Net.available(fd);</span>
<span class="line-added">1259             }</span>
1260         }
1261     }
1262 
1263     /**
1264      * Translates native poll revent ops into a ready operation ops
1265      */
1266     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1267         int intOps = ski.nioInterestOps();
1268         int oldOps = ski.nioReadyOps();
1269         int newOps = initialOps;
1270 
1271         if ((ops &amp; Net.POLLNVAL) != 0) {
1272             // This should only happen if this channel is pre-closed while a
1273             // selection operation is in progress
1274             // ## Throw an error if this channel has not been pre-closed
1275             return false;
1276         }
1277 
1278         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1279             newOps = intOps;
1280             ski.nioReadyOps(newOps);
1281             return (newOps &amp; ~oldOps) != 0;
1282         }
1283 
1284         boolean connected = isConnected();
1285         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1286             ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp; connected)
1287             newOps |= SelectionKey.OP_READ;
1288 
1289         if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp;
1290             ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp; isConnectionPending())
1291             newOps |= SelectionKey.OP_CONNECT;
1292 
1293         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1294             ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp; connected)
1295             newOps |= SelectionKey.OP_WRITE;
1296 
1297         ski.nioReadyOps(newOps);
1298         return (newOps &amp; ~oldOps) != 0;
1299     }
1300 
1301     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1302         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1303     }
1304 
1305     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1306         return translateReadyOps(ops, 0, ski);
1307     }
1308 
1309     /**
1310      * Translates an interest operation set into a native poll event set
1311      */
1312     public int translateInterestOps(int ops) {
1313         int newOps = 0;
1314         if ((ops &amp; SelectionKey.OP_READ) != 0)
1315             newOps |= Net.POLLIN;
1316         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1317             newOps |= Net.POLLOUT;
1318         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1319             newOps |= Net.POLLCONN;
1320         return newOps;
1321     }
1322 
1323     public FileDescriptor getFD() {
1324         return fd;
1325     }
1326 
1327     public int getFDVal() {
1328         return fdVal;
1329     }
1330 
1331     @Override
1332     public String toString() {
1333         StringBuilder sb = new StringBuilder();
1334         sb.append(this.getClass().getSuperclass().getName());
1335         sb.append(&#39;[&#39;);
1336         if (!isOpen())
1337             sb.append(&quot;closed&quot;);
1338         else {
1339             synchronized (stateLock) {
1340                 switch (state) {
1341                 case ST_UNCONNECTED:
1342                     sb.append(&quot;unconnected&quot;);
1343                     break;
1344                 case ST_CONNECTIONPENDING:
1345                     sb.append(&quot;connection-pending&quot;);
1346                     break;
1347                 case ST_CONNECTED:
1348                     sb.append(&quot;connected&quot;);
1349                     if (isInputClosed)
1350                         sb.append(&quot; ishut&quot;);
1351                     if (isOutputClosed)
1352                         sb.append(&quot; oshut&quot;);
1353                     break;
1354                 }
1355                 InetSocketAddress addr = localAddress();
1356                 if (addr != null) {
1357                     sb.append(&quot; local=&quot;);
1358                     sb.append(Net.getRevealedLocalAddressAsString(addr));
1359                 }
1360                 if (remoteAddress() != null) {
1361                     sb.append(&quot; remote=&quot;);
1362                     sb.append(remoteAddress().toString());
1363                 }
1364             }
1365         }
1366         sb.append(&#39;]&#39;);
1367         return sb.toString();
1368     }
1369 }
<a name="77" id="anc77"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="77" type="hidden" />
</body>
</html>
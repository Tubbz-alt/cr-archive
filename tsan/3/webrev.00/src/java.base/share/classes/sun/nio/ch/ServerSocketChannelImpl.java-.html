<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;
 34 import java.net.StandardSocketOptions;
 35 import java.nio.channels.AlreadyBoundException;
 36 import java.nio.channels.AsynchronousCloseException;
 37 import java.nio.channels.ClosedChannelException;
 38 import java.nio.channels.NotYetBoundException;
 39 import java.nio.channels.SelectionKey;
 40 import java.nio.channels.ServerSocketChannel;
 41 import java.nio.channels.SocketChannel;
 42 import java.nio.channels.spi.SelectorProvider;
 43 import java.util.Collections;
 44 import java.util.HashSet;
 45 import java.util.Objects;
 46 import java.util.Set;
 47 import java.util.concurrent.locks.ReentrantLock;
 48 
 49 import sun.net.NetHooks;
 50 import sun.net.ext.ExtendedSocketOptions;
 51 
 52 /**
 53  * An implementation of ServerSocketChannels
 54  */
 55 
 56 class ServerSocketChannelImpl
 57     extends ServerSocketChannel
 58     implements SelChImpl
 59 {
 60     // Used to make native close and configure calls
 61     private static NativeDispatcher nd;
 62 
 63     // Our file descriptor
 64     private final FileDescriptor fd;
 65     private final int fdVal;
 66 
 67     // Lock held by thread currently blocked on this channel
 68     private final ReentrantLock acceptLock = new ReentrantLock();
 69 
 70     // Lock held by any thread that modifies the state fields declared below
 71     // DO NOT invoke a blocking I/O operation while holding this lock!
 72     private final Object stateLock = new Object();
 73 
 74     // -- The following fields are protected by stateLock
 75 
 76     // Channel state, increases monotonically
 77     private static final int ST_INUSE = 0;
 78     private static final int ST_CLOSING = 1;
 79     private static final int ST_KILLPENDING = 2;
 80     private static final int ST_KILLED = 3;
 81     private int state;
 82 
 83     // ID of native thread currently blocked in this channel, for signalling
 84     private long thread;
 85 
 86     // Binding
 87     private InetSocketAddress localAddress; // null =&gt; unbound
 88 
 89     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 90     private boolean isReuseAddress;
 91 
 92     // Our socket adaptor, if any
 93     private ServerSocket socket;
 94 
 95     // -- End of fields protected by stateLock
 96 
 97 
 98     ServerSocketChannelImpl(SelectorProvider sp) throws IOException {
 99         super(sp);
100         this.fd =  Net.serverSocket(true);
101         this.fdVal = IOUtil.fdVal(fd);
102     }
103 
104     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
105         throws IOException
106     {
107         super(sp);
108         this.fd =  fd;
109         this.fdVal = IOUtil.fdVal(fd);
110         if (bound) {
111             synchronized (stateLock) {
112                 localAddress = Net.localAddress(fd);
113             }
114         }
115     }
116 
117     // @throws ClosedChannelException if channel is closed
118     private void ensureOpen() throws ClosedChannelException {
119         if (!isOpen())
120             throw new ClosedChannelException();
121     }
122 
123     @Override
124     public ServerSocket socket() {
125         synchronized (stateLock) {
126             if (socket == null)
127                 socket = ServerSocketAdaptor.create(this);
128             return socket;
129         }
130     }
131 
132     @Override
133     public SocketAddress getLocalAddress() throws IOException {
134         synchronized (stateLock) {
135             ensureOpen();
136             return (localAddress == null)
137                     ? null
138                     : Net.getRevealedLocalAddress(localAddress);
139         }
140     }
141 
142     @Override
143     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
144         throws IOException
145     {
146         Objects.requireNonNull(name);
147         if (!supportedOptions().contains(name))
148             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
149         synchronized (stateLock) {
150             ensureOpen();
151 
152             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
153                 // SO_REUSEADDR emulated when using exclusive bind
154                 isReuseAddress = (Boolean)value;
155             } else {
156                 // no options that require special handling
157                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
158             }
159             return this;
160         }
161     }
162 
163     @Override
164     @SuppressWarnings(&quot;unchecked&quot;)
165     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
166         throws IOException
167     {
168         Objects.requireNonNull(name);
169         if (!supportedOptions().contains(name))
170             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
171 
172         synchronized (stateLock) {
173             ensureOpen();
174             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
175                 // SO_REUSEADDR emulated when using exclusive bind
176                 return (T)Boolean.valueOf(isReuseAddress);
177             }
178             // no options that require special handling
179             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
180         }
181     }
182 
183     private static class DefaultOptionsHolder {
184         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
185 
186         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
187             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
188             set.add(StandardSocketOptions.SO_RCVBUF);
189             set.add(StandardSocketOptions.SO_REUSEADDR);
190             if (Net.isReusePortAvailable()) {
191                 set.add(StandardSocketOptions.SO_REUSEPORT);
192             }
193             set.addAll(ExtendedSocketOptions.serverSocketOptions());
194             return Collections.unmodifiableSet(set);
195         }
196     }
197 
198     @Override
199     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
200         return DefaultOptionsHolder.defaultOptions;
201     }
202 
203     @Override
204     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
205         synchronized (stateLock) {
206             ensureOpen();
207             if (localAddress != null)
208                 throw new AlreadyBoundException();
209             InetSocketAddress isa = (local == null)
210                                     ? new InetSocketAddress(0)
211                                     : Net.checkAddress(local);
212             SecurityManager sm = System.getSecurityManager();
213             if (sm != null)
214                 sm.checkListen(isa.getPort());
215             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
216             Net.bind(fd, isa.getAddress(), isa.getPort());
217             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
218             localAddress = Net.localAddress(fd);
219         }
220         return this;
221     }
222 
223     /**
224      * Marks the beginning of an I/O operation that might block.
225      *
226      * @throws ClosedChannelException if the channel is closed
227      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
228      */
229     private void begin(boolean blocking) throws ClosedChannelException {
230         if (blocking)
231             begin();  // set blocker to close channel if interrupted
232         synchronized (stateLock) {
233             ensureOpen();
234             if (localAddress == null)
235                 throw new NotYetBoundException();
236             if (blocking)
237                 thread = NativeThread.current();
238         }
239     }
240 
241     /**
242      * Marks the end of an I/O operation that may have blocked.
243      *
244      * @throws AsynchronousCloseException if the channel was closed due to this
245      * thread being interrupted on a blocking I/O operation.
246      */
247     private void end(boolean blocking, boolean completed)
248         throws AsynchronousCloseException
249     {
250         if (blocking) {
251             synchronized (stateLock) {
252                 thread = 0;
253                 // notify any thread waiting in implCloseSelectableChannel
254                 if (state == ST_CLOSING) {
255                     stateLock.notifyAll();
256                 }
257             }
258             end(completed);
259         }
260     }
261 
262     @Override
263     public SocketChannel accept() throws IOException {
264         acceptLock.lock();
265         try {
266             int n = 0;
267             FileDescriptor newfd = new FileDescriptor();
268             InetSocketAddress[] isaa = new InetSocketAddress[1];
269 
270             boolean blocking = isBlocking();
271             try {
272                 begin(blocking);
273                 do {
274                     n = accept(this.fd, newfd, isaa);
275                 } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());
276             } finally {
277                 end(blocking, n &gt; 0);
278                 assert IOStatus.check(n);
279             }
280 
281             if (n &lt; 1)
282                 return null;
283 
284             // newly accepted socket is initially in blocking mode
285             IOUtil.configureBlocking(newfd, true);
286 
287             InetSocketAddress isa = isaa[0];
288             SocketChannel sc = new SocketChannelImpl(provider(), newfd, isa);
289 
290             // check permitted to accept connections from the remote address
291             SecurityManager sm = System.getSecurityManager();
292             if (sm != null) {
293                 try {
294                     sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
295                 } catch (SecurityException x) {
296                     sc.close();
297                     throw x;
298                 }
299             }
300             return sc;
301 
302         } finally {
303             acceptLock.unlock();
304         }
305     }
306 
307     @Override
308     protected void implConfigureBlocking(boolean block) throws IOException {
309         acceptLock.lock();
310         try {
311             synchronized (stateLock) {
312                 ensureOpen();
313                 IOUtil.configureBlocking(fd, block);
314             }
315         } finally {
316             acceptLock.unlock();
317         }
318     }
319 
320     /**
321      * Invoked by implCloseChannel to close the channel.
322      *
323      * This method waits for outstanding I/O operations to complete. When in
324      * blocking mode, the socket is pre-closed and the threads in blocking I/O
325      * operations are signalled to ensure that the outstanding I/O operations
326      * complete quickly.
327      *
328      * The socket is closed by this method when it is not registered with a
329      * Selector. Note that a channel configured blocking may be registered with
330      * a Selector. This arises when a key is canceled and the channel configured
331      * to blocking mode before the key is flushed from the Selector.
332      */
333     @Override
334     protected void implCloseSelectableChannel() throws IOException {
335         assert !isOpen();
336 
337         boolean interrupted = false;
338         boolean blocking;
339 
340         // set state to ST_CLOSING
341         synchronized (stateLock) {
342             assert state &lt; ST_CLOSING;
343             state = ST_CLOSING;
344             blocking = isBlocking();
345         }
346 
347         // wait for any outstanding accept to complete
348         if (blocking) {
349             synchronized (stateLock) {
350                 assert state == ST_CLOSING;
351                 long th = thread;
352                 if (th != 0) {
353                     nd.preClose(fd);
354                     NativeThread.signal(th);
355 
356                     // wait for accept operation to end
357                     while (thread != 0) {
358                         try {
359                             stateLock.wait();
360                         } catch (InterruptedException e) {
361                             interrupted = true;
362                         }
363                     }
364                 }
365             }
366         } else {
367             // non-blocking mode: wait for accept to complete
368             acceptLock.lock();
369             acceptLock.unlock();
370         }
371 
372         // set state to ST_KILLPENDING
373         synchronized (stateLock) {
374             assert state == ST_CLOSING;
375             state = ST_KILLPENDING;
376         }
377 
378         // close socket if not registered with Selector
379         if (!isRegistered())
380             kill();
381 
382         // restore interrupt status
383         if (interrupted)
384             Thread.currentThread().interrupt();
385     }
386 
387     @Override
388     public void kill() throws IOException {
389         synchronized (stateLock) {
390             if (state == ST_KILLPENDING) {
391                 state = ST_KILLED;
392                 nd.close(fd);
393             }
394         }
395     }
396 
397     /**
398      * Returns true if channel&#39;s socket is bound
399      */
400     boolean isBound() {
401         synchronized (stateLock) {
402             return localAddress != null;
403         }
404     }
405 
406     /**
407      * Returns the local address, or null if not bound
408      */
409     InetSocketAddress localAddress() {
410         synchronized (stateLock) {
411             return localAddress;
412         }
413     }
414 
415     /**
416      * Poll this channel&#39;s socket for a new connection up to the given timeout.
417      * @return {@code true} if there is a connection to accept
418      */
419     boolean pollAccept(long timeout) throws IOException {
420         assert Thread.holdsLock(blockingLock()) &amp;&amp; isBlocking();
421         acceptLock.lock();
422         try {
423             boolean polled = false;
424             try {
425                 begin(true);
426                 int events = Net.poll(fd, Net.POLLIN, timeout);
427                 polled = (events != 0);
428             } finally {
429                 end(true, polled);
430             }
431             return polled;
432         } finally {
433             acceptLock.unlock();
434         }
435     }
436 
437     /**
438      * Translates native poll revent set into a ready operation set
439      */
440     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
441         int intOps = ski.nioInterestOps();
442         int oldOps = ski.nioReadyOps();
443         int newOps = initialOps;
444 
445         if ((ops &amp; Net.POLLNVAL) != 0) {
446             // This should only happen if this channel is pre-closed while a
447             // selection operation is in progress
448             // ## Throw an error if this channel has not been pre-closed
449             return false;
450         }
451 
452         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
453             newOps = intOps;
454             ski.nioReadyOps(newOps);
455             return (newOps &amp; ~oldOps) != 0;
456         }
457 
458         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
459             ((intOps &amp; SelectionKey.OP_ACCEPT) != 0))
460                 newOps |= SelectionKey.OP_ACCEPT;
461 
462         ski.nioReadyOps(newOps);
463         return (newOps &amp; ~oldOps) != 0;
464     }
465 
466     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
467         return translateReadyOps(ops, ski.nioReadyOps(), ski);
468     }
469 
470     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
471         return translateReadyOps(ops, 0, ski);
472     }
473 
474     /**
475      * Translates an interest operation set into a native poll event set
476      */
477     public int translateInterestOps(int ops) {
478         int newOps = 0;
479         if ((ops &amp; SelectionKey.OP_ACCEPT) != 0)
480             newOps |= Net.POLLIN;
481         return newOps;
482     }
483 
484     public FileDescriptor getFD() {
485         return fd;
486     }
487 
488     public int getFDVal() {
489         return fdVal;
490     }
491 
492     public String toString() {
493         StringBuilder sb = new StringBuilder();
494         sb.append(this.getClass().getName());
495         sb.append(&#39;[&#39;);
496         if (!isOpen()) {
497             sb.append(&quot;closed&quot;);
498         } else {
499             synchronized (stateLock) {
500                 InetSocketAddress addr = localAddress;
501                 if (addr == null) {
502                     sb.append(&quot;unbound&quot;);
503                 } else {
504                     sb.append(Net.getRevealedLocalAddressAsString(addr));
505                 }
506             }
507         }
508         sb.append(&#39;]&#39;);
509         return sb.toString();
510     }
511 
512     /**
513      * Accept a connection on a socket.
514      *
515      * @implNote Wrap native call to allow instrumentation.
516      */
517     private int accept(FileDescriptor ssfd,
518                        FileDescriptor newfd,
519                        InetSocketAddress[] isaa)
520         throws IOException
521     {
522         return accept0(ssfd, newfd, isaa);
523     }
524 
525     // -- Native methods --
526 
527     // Accepts a new connection, setting the given file descriptor to refer to
528     // the new socket and setting isaa[0] to the socket&#39;s remote address.
529     // Returns 1 on success, or IOStatus.UNAVAILABLE (if non-blocking and no
530     // connections are pending) or IOStatus.INTERRUPTED.
531     //
532     private native int accept0(FileDescriptor ssfd,
533                                FileDescriptor newfd,
534                                InetSocketAddress[] isaa)
535         throws IOException;
536 
537     private static native void initIDs();
538 
539     static {
540         IOUtil.load();
541         initIDs();
542         nd = new SocketDispatcher();
543     }
544 
545 }
    </pre>
  </body>
</html>
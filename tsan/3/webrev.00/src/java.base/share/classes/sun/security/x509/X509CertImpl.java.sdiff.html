<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/x509/X509CertImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X509CRLImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509Key.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/x509/X509CertImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 import java.io.BufferedReader;
  29 import java.io.BufferedInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.InputStreamReader;
  34 import java.io.OutputStream;
  35 import java.math.BigInteger;
  36 import java.security.*;
  37 import java.security.spec.AlgorithmParameterSpec;
  38 import java.security.cert.*;
  39 import java.security.cert.Certificate;
  40 import java.util.*;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 
  43 import javax.security.auth.x500.X500Principal;
  44 
  45 import sun.security.util.*;
  46 import sun.security.provider.X509Factory;
  47 


  48 /**
  49  * The X509CertImpl class represents an X.509 certificate. These certificates
  50  * are widely used to support authentication and other functionality in
  51  * Internet security systems.  Common applications include Privacy Enhanced
  52  * Mail (PEM), Transport Layer Security (SSL), code signing for trusted
  53  * software distribution, and Secure Electronic Transactions (SET).  There
  54  * is a commercial infrastructure ready to manage large scale deployments
  55  * of X.509 identity certificates.
  56  *
  57  * &lt;P&gt;These certificates are managed and vouched for by &lt;em&gt;Certificate
  58  * Authorities&lt;/em&gt; (CAs).  CAs are services which create certificates by
  59  * placing data in the X.509 standard format and then digitally signing
  60  * that data.  Such signatures are quite difficult to forge.  CAs act as
  61  * trusted third parties, making introductions between agents who have no
  62  * direct knowledge of each other.  CA certificates are either signed by
  63  * themselves, or by some other CA such as a &quot;root&quot; CA.
  64  *
  65  * &lt;P&gt; Standards relating to X.509 Public Key Infrastructure for the Internet
  66  * can be referenced in RFC 5280.
  67  *
  68  * @author Dave Brownell
  69  * @author Amit Kapoor
  70  * @author Hemma Prafullchandra
  71  * @see X509CertInfo
  72  */

  73 public class X509CertImpl extends X509Certificate implements DerEncoder {
  74 

  75     private static final long serialVersionUID = -3457612960190864406L;
  76 
  77     private static final char DOT = &#39;.&#39;;
  78     /**
  79      * Public attribute names.
  80      */
  81     public static final String NAME = &quot;x509&quot;;
  82     public static final String INFO = X509CertInfo.NAME;
  83     public static final String ALG_ID = &quot;algorithm&quot;;
  84     public static final String SIGNATURE = &quot;signature&quot;;
  85     public static final String SIGNED_CERT = &quot;signed_cert&quot;;
  86 
  87     /**
  88      * The following are defined for ease-of-use. These
  89      * are the most frequently retrieved attributes.
  90      */
  91     // x509.info.subject.dname
  92     public static final String SUBJECT_DN = NAME + DOT + INFO + DOT +
  93                                X509CertInfo.SUBJECT + DOT + X509CertInfo.DN_NAME;
  94     // x509.info.issuer.dname
</pre>
<hr />
<pre>
 231             parse(der);
 232         } catch (IOException ioe) {
 233             signedCert = null;
 234             throw new CertificateException(&quot;Unable to parse DER value of &quot; +
 235                                            &quot;certificate, &quot; + ioe, ioe);
 236         }
 237     }
 238 
 239     /**
 240      * read input stream as HEX-encoded DER-encoded bytes
 241      *
 242      * @param in InputStream to read
 243      * @return DerValue corresponding to decoded HEX-encoded bytes
 244      * @throws IOException if stream can not be interpreted as RFC1421
 245      *                     encoded bytes
 246      */
 247     private DerValue readRFC1421Cert(InputStream in) throws IOException {
 248         DerValue der = null;
 249         String line = null;
 250         BufferedReader certBufferedReader =
<span class="line-modified"> 251             new BufferedReader(new InputStreamReader(in, &quot;ASCII&quot;));</span>
 252         try {
 253             line = certBufferedReader.readLine();
 254         } catch (IOException ioe1) {
 255             throw new IOException(&quot;Unable to read InputStream: &quot; +
 256                                   ioe1.getMessage());
 257         }
 258         if (line.equals(X509Factory.BEGIN_CERT)) {
 259             /* stream appears to be hex-encoded bytes */
 260             ByteArrayOutputStream decstream = new ByteArrayOutputStream();
 261             try {
 262                 while ((line = certBufferedReader.readLine()) != null) {
 263                     if (line.equals(X509Factory.END_CERT)) {
 264                         der = new DerValue(decstream.toByteArray());
 265                         break;
 266                     } else {
 267                         decstream.write(Pem.decode(line));
 268                     }
 269                 }
 270             } catch (IOException ioe2) {
 271                 throw new IOException(&quot;Unable to read InputStream: &quot;
</pre>
<hr />
<pre>
 405             InvalidKeyException, NoSuchProviderException, SignatureException {
 406         if (sigProvider == null) {
 407             sigProvider = &quot;&quot;;
 408         }
 409         if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
 410             // this certificate has already been verified using
 411             // this public key. Make sure providers match, too.
 412             if (sigProvider.equals(verifiedProvider)) {
 413                 if (verificationResult) {
 414                     return;
 415                 } else {
 416                     throw new SignatureException(&quot;Signature does not match.&quot;);
 417                 }
 418             }
 419         }
 420         if (signedCert == null) {
 421             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 422         }
 423         // Verify the signature ...
 424         Signature sigVerf = null;

 425         if (sigProvider.isEmpty()) {
<span class="line-modified"> 426             sigVerf = Signature.getInstance(algId.getName());</span>
 427         } else {
<span class="line-modified"> 428             sigVerf = Signature.getInstance(algId.getName(), sigProvider);</span>
 429         }
 430 
<span class="line-removed"> 431         sigVerf.initVerify(key);</span>
<span class="line-removed"> 432 </span>
<span class="line-removed"> 433         // set parameters after Signature.initSign/initVerify call,</span>
<span class="line-removed"> 434         // so the deferred provider selection happens when key is set</span>
 435         try {
<span class="line-modified"> 436             SignatureUtil.specialSetParameter(sigVerf, getSigAlgParams());</span>

 437         } catch (ProviderException e) {
 438             throw new CertificateException(e.getMessage(), e.getCause());
 439         } catch (InvalidAlgorithmParameterException e) {
 440             throw new CertificateException(e);
 441         }
 442 
 443         byte[] rawCert = info.getEncodedInfo();
 444         sigVerf.update(rawCert, 0, rawCert.length);
 445 
 446         // verify may throw SignatureException for invalid encodings, etc.
 447         verificationResult = sigVerf.verify(signature);
 448         verifiedPublicKey = key;
 449         verifiedProvider = sigProvider;
 450 
 451         if (verificationResult == false) {
 452             throw new SignatureException(&quot;Signature does not match.&quot;);
 453         }
 454     }
 455 
 456     /**
</pre>
<hr />
<pre>
 461      * Successfully verifying a certificate does &lt;em&gt;not&lt;/em&gt; indicate that one
 462      * should trust the entity which it represents.
 463      *
 464      * @param key the public key used for verification.
 465      * @param sigProvider the provider.
 466      *
 467      * @exception NoSuchAlgorithmException on unsupported signature
 468      * algorithms.
 469      * @exception InvalidKeyException on incorrect key.
 470      * @exception SignatureException on signature errors.
 471      * @exception CertificateException on encoding errors.
 472      */
 473     public synchronized void verify(PublicKey key, Provider sigProvider)
 474             throws CertificateException, NoSuchAlgorithmException,
 475             InvalidKeyException, SignatureException {
 476         if (signedCert == null) {
 477             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 478         }
 479         // Verify the signature ...
 480         Signature sigVerf = null;

 481         if (sigProvider == null) {
<span class="line-modified"> 482             sigVerf = Signature.getInstance(algId.getName());</span>
 483         } else {
<span class="line-modified"> 484             sigVerf = Signature.getInstance(algId.getName(), sigProvider);</span>
 485         }
 486 
<span class="line-removed"> 487         sigVerf.initVerify(key);</span>
<span class="line-removed"> 488 </span>
<span class="line-removed"> 489         // set parameters after Signature.initSign/initVerify call,</span>
<span class="line-removed"> 490         // so the deferred provider selection happens when key is set</span>
 491         try {
<span class="line-modified"> 492             SignatureUtil.specialSetParameter(sigVerf, getSigAlgParams());</span>

 493         } catch (ProviderException e) {
 494             throw new CertificateException(e.getMessage(), e.getCause());
 495         } catch (InvalidAlgorithmParameterException e) {
 496             throw new CertificateException(e);
 497         }
 498 
 499         byte[] rawCert = info.getEncodedInfo();
 500         sigVerf.update(rawCert, 0, rawCert.length);
 501 
 502         // verify may throw SignatureException for invalid encodings, etc.
 503         verificationResult = sigVerf.verify(signature);
 504         verifiedPublicKey = key;
 505 
 506         if (verificationResult == false) {
 507             throw new SignatureException(&quot;Signature does not match.&quot;);
 508         }
 509     }
 510 
 511     /**
 512      * Creates an X.509 certificate, and signs it using the given key
</pre>
<hr />
<pre>
 570      * @param key the private key used for signing
 571      * @param signingParams the parameters used for signing
 572      * @param algorithm the name of the signature algorithm used
 573      * @param provider the name of the provider, may be null
 574      *
 575      * @exception NoSuchAlgorithmException on unsupported signature
 576      *            algorithms
 577      * @exception InvalidKeyException on incorrect key
 578      * @exception InvalidAlgorithmParameterException on invalid signature
 579      *            parameters
 580      * @exception NoSuchProviderException on incorrect provider
 581      * @exception SignatureException on signature errors
 582      * @exception CertificateException on encoding errors
 583      */
 584     public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,
 585             String algorithm, String provider)
 586             throws CertificateException, NoSuchAlgorithmException,
 587             InvalidKeyException, InvalidAlgorithmParameterException,
 588             NoSuchProviderException, SignatureException {
 589         try {
<span class="line-modified"> 590             if (readOnly)</span>
 591                 throw new CertificateEncodingException(
<span class="line-modified"> 592                               &quot;cannot over-write existing certificate&quot;);</span>

 593             Signature sigEngine = null;
<span class="line-modified"> 594             if (provider == null || provider.isEmpty())</span>
 595                 sigEngine = Signature.getInstance(algorithm);
<span class="line-modified"> 596             else</span>
 597                 sigEngine = Signature.getInstance(algorithm, provider);
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599             sigEngine.initSign(key);</span>
<span class="line-removed"> 600 </span>
<span class="line-removed"> 601             if (signingParams != null) {</span>
<span class="line-removed"> 602                 // set parameters after Signature.initSign/initVerify call, so</span>
<span class="line-removed"> 603                 // the deferred provider selection happens when the key is set</span>
<span class="line-removed"> 604                 sigEngine.setParameter(signingParams);</span>
 605             }
 606 



 607             // in case the name is reset
 608             if (signingParams != null) {
 609                 algId = AlgorithmId.get(sigEngine.getParameters());
 610             } else {
 611                 algId = AlgorithmId.get(algorithm);
 612             }
 613             DerOutputStream out = new DerOutputStream();
 614             DerOutputStream tmp = new DerOutputStream();
 615 
 616             // encode certificate info
 617             info.encode(tmp);
 618             byte[] rawCert = tmp.toByteArray();
 619 
 620             // encode algorithm identifier
 621             algId.encode(tmp);
 622 
 623             // Create and encode the signature itself.
 624             sigEngine.update(rawCert, 0, rawCert.length);
 625             signature = sigEngine.sign();
 626             tmp.putBitString(signature);
</pre>
</td>
<td>
<hr />
<pre>
  28 import java.io.BufferedReader;
  29 import java.io.BufferedInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.InputStreamReader;
  34 import java.io.OutputStream;
  35 import java.math.BigInteger;
  36 import java.security.*;
  37 import java.security.spec.AlgorithmParameterSpec;
  38 import java.security.cert.*;
  39 import java.security.cert.Certificate;
  40 import java.util.*;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 
  43 import javax.security.auth.x500.X500Principal;
  44 
  45 import sun.security.util.*;
  46 import sun.security.provider.X509Factory;
  47 
<span class="line-added">  48 import static java.nio.charset.StandardCharsets.US_ASCII;</span>
<span class="line-added">  49 </span>
  50 /**
  51  * The X509CertImpl class represents an X.509 certificate. These certificates
  52  * are widely used to support authentication and other functionality in
  53  * Internet security systems.  Common applications include Privacy Enhanced
  54  * Mail (PEM), Transport Layer Security (SSL), code signing for trusted
  55  * software distribution, and Secure Electronic Transactions (SET).  There
  56  * is a commercial infrastructure ready to manage large scale deployments
  57  * of X.509 identity certificates.
  58  *
  59  * &lt;P&gt;These certificates are managed and vouched for by &lt;em&gt;Certificate
  60  * Authorities&lt;/em&gt; (CAs).  CAs are services which create certificates by
  61  * placing data in the X.509 standard format and then digitally signing
  62  * that data.  Such signatures are quite difficult to forge.  CAs act as
  63  * trusted third parties, making introductions between agents who have no
  64  * direct knowledge of each other.  CA certificates are either signed by
  65  * themselves, or by some other CA such as a &quot;root&quot; CA.
  66  *
  67  * &lt;P&gt; Standards relating to X.509 Public Key Infrastructure for the Internet
  68  * can be referenced in RFC 5280.
  69  *
  70  * @author Dave Brownell
  71  * @author Amit Kapoor
  72  * @author Hemma Prafullchandra
  73  * @see X509CertInfo
  74  */
<span class="line-added">  75 @SuppressWarnings(&quot;serial&quot;) // See writeReplace method in Certificate</span>
  76 public class X509CertImpl extends X509Certificate implements DerEncoder {
  77 
<span class="line-added">  78     @java.io.Serial</span>
  79     private static final long serialVersionUID = -3457612960190864406L;
  80 
  81     private static final char DOT = &#39;.&#39;;
  82     /**
  83      * Public attribute names.
  84      */
  85     public static final String NAME = &quot;x509&quot;;
  86     public static final String INFO = X509CertInfo.NAME;
  87     public static final String ALG_ID = &quot;algorithm&quot;;
  88     public static final String SIGNATURE = &quot;signature&quot;;
  89     public static final String SIGNED_CERT = &quot;signed_cert&quot;;
  90 
  91     /**
  92      * The following are defined for ease-of-use. These
  93      * are the most frequently retrieved attributes.
  94      */
  95     // x509.info.subject.dname
  96     public static final String SUBJECT_DN = NAME + DOT + INFO + DOT +
  97                                X509CertInfo.SUBJECT + DOT + X509CertInfo.DN_NAME;
  98     // x509.info.issuer.dname
</pre>
<hr />
<pre>
 235             parse(der);
 236         } catch (IOException ioe) {
 237             signedCert = null;
 238             throw new CertificateException(&quot;Unable to parse DER value of &quot; +
 239                                            &quot;certificate, &quot; + ioe, ioe);
 240         }
 241     }
 242 
 243     /**
 244      * read input stream as HEX-encoded DER-encoded bytes
 245      *
 246      * @param in InputStream to read
 247      * @return DerValue corresponding to decoded HEX-encoded bytes
 248      * @throws IOException if stream can not be interpreted as RFC1421
 249      *                     encoded bytes
 250      */
 251     private DerValue readRFC1421Cert(InputStream in) throws IOException {
 252         DerValue der = null;
 253         String line = null;
 254         BufferedReader certBufferedReader =
<span class="line-modified"> 255             new BufferedReader(new InputStreamReader(in, US_ASCII));</span>
 256         try {
 257             line = certBufferedReader.readLine();
 258         } catch (IOException ioe1) {
 259             throw new IOException(&quot;Unable to read InputStream: &quot; +
 260                                   ioe1.getMessage());
 261         }
 262         if (line.equals(X509Factory.BEGIN_CERT)) {
 263             /* stream appears to be hex-encoded bytes */
 264             ByteArrayOutputStream decstream = new ByteArrayOutputStream();
 265             try {
 266                 while ((line = certBufferedReader.readLine()) != null) {
 267                     if (line.equals(X509Factory.END_CERT)) {
 268                         der = new DerValue(decstream.toByteArray());
 269                         break;
 270                     } else {
 271                         decstream.write(Pem.decode(line));
 272                     }
 273                 }
 274             } catch (IOException ioe2) {
 275                 throw new IOException(&quot;Unable to read InputStream: &quot;
</pre>
<hr />
<pre>
 409             InvalidKeyException, NoSuchProviderException, SignatureException {
 410         if (sigProvider == null) {
 411             sigProvider = &quot;&quot;;
 412         }
 413         if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
 414             // this certificate has already been verified using
 415             // this public key. Make sure providers match, too.
 416             if (sigProvider.equals(verifiedProvider)) {
 417                 if (verificationResult) {
 418                     return;
 419                 } else {
 420                     throw new SignatureException(&quot;Signature does not match.&quot;);
 421                 }
 422             }
 423         }
 424         if (signedCert == null) {
 425             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 426         }
 427         // Verify the signature ...
 428         Signature sigVerf = null;
<span class="line-added"> 429         String sigName = algId.getName();</span>
 430         if (sigProvider.isEmpty()) {
<span class="line-modified"> 431             sigVerf = Signature.getInstance(sigName);</span>
 432         } else {
<span class="line-modified"> 433             sigVerf = Signature.getInstance(sigName, sigProvider);</span>
 434         }
 435 




 436         try {
<span class="line-modified"> 437             SignatureUtil.initVerifyWithParam(sigVerf, key,</span>
<span class="line-added"> 438                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));</span>
 439         } catch (ProviderException e) {
 440             throw new CertificateException(e.getMessage(), e.getCause());
 441         } catch (InvalidAlgorithmParameterException e) {
 442             throw new CertificateException(e);
 443         }
 444 
 445         byte[] rawCert = info.getEncodedInfo();
 446         sigVerf.update(rawCert, 0, rawCert.length);
 447 
 448         // verify may throw SignatureException for invalid encodings, etc.
 449         verificationResult = sigVerf.verify(signature);
 450         verifiedPublicKey = key;
 451         verifiedProvider = sigProvider;
 452 
 453         if (verificationResult == false) {
 454             throw new SignatureException(&quot;Signature does not match.&quot;);
 455         }
 456     }
 457 
 458     /**
</pre>
<hr />
<pre>
 463      * Successfully verifying a certificate does &lt;em&gt;not&lt;/em&gt; indicate that one
 464      * should trust the entity which it represents.
 465      *
 466      * @param key the public key used for verification.
 467      * @param sigProvider the provider.
 468      *
 469      * @exception NoSuchAlgorithmException on unsupported signature
 470      * algorithms.
 471      * @exception InvalidKeyException on incorrect key.
 472      * @exception SignatureException on signature errors.
 473      * @exception CertificateException on encoding errors.
 474      */
 475     public synchronized void verify(PublicKey key, Provider sigProvider)
 476             throws CertificateException, NoSuchAlgorithmException,
 477             InvalidKeyException, SignatureException {
 478         if (signedCert == null) {
 479             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 480         }
 481         // Verify the signature ...
 482         Signature sigVerf = null;
<span class="line-added"> 483         String sigName = algId.getName();</span>
 484         if (sigProvider == null) {
<span class="line-modified"> 485             sigVerf = Signature.getInstance(sigName);</span>
 486         } else {
<span class="line-modified"> 487             sigVerf = Signature.getInstance(sigName, sigProvider);</span>
 488         }
 489 




 490         try {
<span class="line-modified"> 491             SignatureUtil.initVerifyWithParam(sigVerf, key,</span>
<span class="line-added"> 492                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));</span>
 493         } catch (ProviderException e) {
 494             throw new CertificateException(e.getMessage(), e.getCause());
 495         } catch (InvalidAlgorithmParameterException e) {
 496             throw new CertificateException(e);
 497         }
 498 
 499         byte[] rawCert = info.getEncodedInfo();
 500         sigVerf.update(rawCert, 0, rawCert.length);
 501 
 502         // verify may throw SignatureException for invalid encodings, etc.
 503         verificationResult = sigVerf.verify(signature);
 504         verifiedPublicKey = key;
 505 
 506         if (verificationResult == false) {
 507             throw new SignatureException(&quot;Signature does not match.&quot;);
 508         }
 509     }
 510 
 511     /**
 512      * Creates an X.509 certificate, and signs it using the given key
</pre>
<hr />
<pre>
 570      * @param key the private key used for signing
 571      * @param signingParams the parameters used for signing
 572      * @param algorithm the name of the signature algorithm used
 573      * @param provider the name of the provider, may be null
 574      *
 575      * @exception NoSuchAlgorithmException on unsupported signature
 576      *            algorithms
 577      * @exception InvalidKeyException on incorrect key
 578      * @exception InvalidAlgorithmParameterException on invalid signature
 579      *            parameters
 580      * @exception NoSuchProviderException on incorrect provider
 581      * @exception SignatureException on signature errors
 582      * @exception CertificateException on encoding errors
 583      */
 584     public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,
 585             String algorithm, String provider)
 586             throws CertificateException, NoSuchAlgorithmException,
 587             InvalidKeyException, InvalidAlgorithmParameterException,
 588             NoSuchProviderException, SignatureException {
 589         try {
<span class="line-modified"> 590             if (readOnly) {</span>
 591                 throw new CertificateEncodingException(
<span class="line-modified"> 592                         &quot;cannot over-write existing certificate&quot;);</span>
<span class="line-added"> 593             }</span>
 594             Signature sigEngine = null;
<span class="line-modified"> 595             if (provider == null || provider.isEmpty()) {</span>
 596                 sigEngine = Signature.getInstance(algorithm);
<span class="line-modified"> 597             } else {</span>
 598                 sigEngine = Signature.getInstance(algorithm, provider);







 599             }
 600 
<span class="line-added"> 601             SignatureUtil.initSignWithParam(sigEngine, key, signingParams,</span>
<span class="line-added"> 602                     null);</span>
<span class="line-added"> 603 </span>
 604             // in case the name is reset
 605             if (signingParams != null) {
 606                 algId = AlgorithmId.get(sigEngine.getParameters());
 607             } else {
 608                 algId = AlgorithmId.get(algorithm);
 609             }
 610             DerOutputStream out = new DerOutputStream();
 611             DerOutputStream tmp = new DerOutputStream();
 612 
 613             // encode certificate info
 614             info.encode(tmp);
 615             byte[] rawCert = tmp.toByteArray();
 616 
 617             // encode algorithm identifier
 618             algId.encode(tmp);
 619 
 620             // Create and encode the signature itself.
 621             sigEngine.update(rawCert, 0, rawCert.length);
 622             signature = sigEngine.sign();
 623             tmp.putBitString(signature);
</pre>
</td>
</tr>
</table>
<center><a href="X509CRLImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509Key.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
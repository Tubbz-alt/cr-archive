<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SignatureScheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SessionId.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SunJSSE.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SignatureScheme.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.*;
<span class="line-removed"> 29 import java.security.interfaces.ECPrivateKey;</span>
 30 import java.security.spec.AlgorithmParameterSpec;
 31 import java.security.spec.ECParameterSpec;
 32 import java.security.spec.MGF1ParameterSpec;
 33 import java.security.spec.PSSParameterSpec;

 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.Collection;
 37 import java.util.Collections;
 38 import java.util.EnumSet;
 39 import java.util.LinkedList;
 40 import java.util.List;

 41 import java.util.Set;
<span class="line-modified"> 42 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-modified"> 43 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>

 44 import sun.security.util.KeyUtil;

 45 
 46 enum SignatureScheme {
 47     // EdDSA algorithms
 48     ED25519                 (0x0807, &quot;ed25519&quot;, &quot;ed25519&quot;,
 49                                     &quot;ed25519&quot;,
 50                                     ProtocolVersion.PROTOCOLS_OF_13),
 51     ED448                   (0x0808, &quot;ed448&quot;, &quot;ed448&quot;,
 52                                     &quot;ed448&quot;,
 53                                     ProtocolVersion.PROTOCOLS_OF_13),
 54 
 55     // ECDSA algorithms
 56     ECDSA_SECP256R1_SHA256  (0x0403, &quot;ecdsa_secp256r1_sha256&quot;,
 57                                     &quot;SHA256withECDSA&quot;,
 58                                     &quot;EC&quot;,
 59                                     NamedGroup.SECP256_R1,
 60                                     ProtocolVersion.PROTOCOLS_TO_13),
 61     ECDSA_SECP384R1_SHA384  (0x0503, &quot;ecdsa_secp384r1_sha384&quot;,
 62                                     &quot;SHA384withECDSA&quot;,
 63                                     &quot;EC&quot;,
 64                                     NamedGroup.SECP384_R1,
</pre>
<hr />
<pre>
131                                     &quot;DSA&quot;,
132                                     ProtocolVersion.PROTOCOLS_TO_12),
133     ECDSA_SHA1              (0x0203, &quot;ecdsa_sha1&quot;, &quot;SHA1withECDSA&quot;,
134                                     &quot;EC&quot;,
135                                     ProtocolVersion.PROTOCOLS_TO_13),
136     RSA_PKCS1_SHA1          (0x0201, &quot;rsa_pkcs1_sha1&quot;, &quot;SHA1withRSA&quot;,
137                                     &quot;RSA&quot;, null, null, 511,
138                                     ProtocolVersion.PROTOCOLS_TO_13,
139                                     ProtocolVersion.PROTOCOLS_TO_12),
140     DSA_SHA1                (0x0202, &quot;dsa_sha1&quot;, &quot;SHA1withDSA&quot;,
141                                     &quot;DSA&quot;,
142                                     ProtocolVersion.PROTOCOLS_TO_12),
143     RSA_MD5                 (0x0101, &quot;rsa_md5&quot;, &quot;MD5withRSA&quot;,
144                                     &quot;RSA&quot;, 511,
145                                     ProtocolVersion.PROTOCOLS_TO_12);
146 
147     final int id;                       // hash + signature
148     final String name;                  // literal name
149     private final String algorithm;     // signature algorithm
150     final String keyAlgorithm;          // signature key algorithm
<span class="line-modified">151     private final AlgorithmParameterSpec signAlgParameter;</span>
152     private final NamedGroup namedGroup;    // associated named group
153 
154     // The minimal required key size in bits.
155     //
156     // Only need to check RSA algorithm at present. RSA keys of 512 bits
157     // have been shown to be practically breakable, it does not make much
158     // sense to use the strong hash algorithm for keys whose key size less
159     // than 512 bits.  So it is not necessary to calculate the minimal
160     // required key size exactly for a hash algorithm.
161     //
162     // Note that some provider may use 511 bits for 512-bit strength RSA keys.
163     final int minimalKeySize;
164     final List&lt;ProtocolVersion&gt; supportedProtocols;
165 
166     // Some signature schemes are supported in different versions for handshake
167     // messages and certificates. This field holds the supported protocols
168     // for handshake messages.
169     final List&lt;ProtocolVersion&gt; handshakeSupportedProtocols;
170     final boolean isAvailable;
171 
172     private static final String[] hashAlgorithms = new String[] {
173             &quot;none&quot;,         &quot;md5&quot;,      &quot;sha1&quot;,     &quot;sha224&quot;,
174             &quot;sha256&quot;,       &quot;sha384&quot;,   &quot;sha512&quot;
175         };
176 
177     private static final String[] signatureAlgorithms = new String[] {
178             &quot;anonymous&quot;,    &quot;rsa&quot;,      &quot;dsa&quot;,      &quot;ecdsa&quot;,
179         };
180 
181     static enum SigAlgParamSpec {   // support RSASSA-PSS only now
182         RSA_PSS_SHA256 (&quot;SHA-256&quot;, 32),
183         RSA_PSS_SHA384 (&quot;SHA-384&quot;, 48),
184         RSA_PSS_SHA512 (&quot;SHA-512&quot;, 64);
185 
<span class="line-modified">186         final private AlgorithmParameterSpec parameterSpec;</span>
<span class="line-modified">187         final boolean isAvailable;</span>

188 
189         SigAlgParamSpec(String hash, int saltLength) {
190             // See RFC 8017
191             PSSParameterSpec pssParamSpec =
192                     new PSSParameterSpec(hash, &quot;MGF1&quot;,
193                             new MGF1ParameterSpec(hash), saltLength, 1);

194 
195             boolean mediator = true;
196             try {
197                 Signature signer = Signature.getInstance(&quot;RSASSA-PSS&quot;);
198                 signer.setParameter(pssParamSpec);

199             } catch (InvalidAlgorithmParameterException |
<span class="line-modified">200                     NoSuchAlgorithmException exp) {</span>

201                 mediator = false;
202                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
203                     SSLLogger.warning(
204                         &quot;RSASSA-PSS signature with &quot; + hash +
205                         &quot; is not supported by the underlying providers&quot;, exp);
206                 }
207             }
208 
209             this.isAvailable = mediator;
210             this.parameterSpec = mediator ? pssParamSpec : null;
<span class="line-modified">211         }</span>
<span class="line-removed">212 </span>
<span class="line-removed">213         AlgorithmParameterSpec getParameterSpec() {</span>
<span class="line-removed">214             return parameterSpec;</span>
215         }
216     }
217 
218     // performance optimization
219     private static final Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
220         Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
221 
222 
223     private SignatureScheme(int id, String name,
224             String algorithm, String keyAlgorithm,
225             ProtocolVersion[] supportedProtocols) {
226         this(id, name, algorithm, keyAlgorithm, -1, supportedProtocols);
227     }
228 
229     private SignatureScheme(int id, String name,
230             String algorithm, String keyAlgorithm,
231             int minimalKeySize,
232             ProtocolVersion[] supportedProtocols) {
233         this(id, name, algorithm, keyAlgorithm,
234                 null, minimalKeySize, supportedProtocols);
</pre>
<hr />
<pre>
237     private SignatureScheme(int id, String name,
238             String algorithm, String keyAlgorithm,
239             SigAlgParamSpec signAlgParamSpec, int minimalKeySize,
240             ProtocolVersion[] supportedProtocols) {
241         this(id, name, algorithm, keyAlgorithm,
242                 signAlgParamSpec, null, minimalKeySize,
243                 supportedProtocols, supportedProtocols);
244     }
245 
246     private SignatureScheme(int id, String name,
247             String algorithm, String keyAlgorithm,
248             NamedGroup namedGroup,
249             ProtocolVersion[] supportedProtocols) {
250         this(id, name, algorithm, keyAlgorithm,
251                 null, namedGroup, -1,
252                 supportedProtocols, supportedProtocols);
253     }
254 
255     private SignatureScheme(int id, String name,
256             String algorithm, String keyAlgorithm,
<span class="line-modified">257             SigAlgParamSpec signAlgParamSpec,</span>
258             NamedGroup namedGroup, int minimalKeySize,
259             ProtocolVersion[] supportedProtocols,
260             ProtocolVersion[] handshakeSupportedProtocols) {
261         this.id = id;
262         this.name = name;
263         this.algorithm = algorithm;
264         this.keyAlgorithm = keyAlgorithm;
<span class="line-modified">265         this.signAlgParameter =</span>
<span class="line-removed">266             signAlgParamSpec != null ? signAlgParamSpec.parameterSpec : null;</span>
267         this.namedGroup = namedGroup;
268         this.minimalKeySize = minimalKeySize;
269         this.supportedProtocols = Arrays.asList(supportedProtocols);
270         this.handshakeSupportedProtocols =
271                 Arrays.asList(handshakeSupportedProtocols);
272 
273         boolean mediator = true;
<span class="line-modified">274         if (signAlgParamSpec != null) {</span>
<span class="line-modified">275             mediator = signAlgParamSpec.isAvailable;</span>
<span class="line-modified">276         } else {</span>
<span class="line-modified">277             try {</span>
<span class="line-modified">278                 Signature.getInstance(algorithm);</span>
<span class="line-modified">279             } catch (Exception e) {</span>
<span class="line-modified">280                 mediator = false;</span>
<span class="line-modified">281                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">282                     SSLLogger.warning(</span>
<span class="line-modified">283                         &quot;Signature algorithm, &quot; + algorithm +</span>
<span class="line-modified">284                         &quot;, is not supported by the underlying providers&quot;);</span>











285                 }
286             }
287         }
288 
289         if (mediator &amp;&amp; ((id &gt;&gt; 8) &amp; 0xFF) == 0x03) {   // SHA224
290             // There are some problems to use SHA224 on Windows.
291             if (Security.getProvider(&quot;SunMSCAPI&quot;) != null) {
292                 mediator = false;
293             }
294         }
295 
296         this.isAvailable = mediator;
297     }
298 
299     static SignatureScheme valueOf(int id) {
300         for (SignatureScheme ss: SignatureScheme.values()) {
301             if (ss.id == id) {
302                 return ss;
303             }
304         }
</pre>
<hr />
<pre>
313             }
314         }
315 
316         // Use TLS 1.2 style name for unknown signature scheme.
317         int hashId = ((id &gt;&gt; 8) &amp; 0xFF);
318         int signId = (id &amp; 0xFF);
319         String hashName = (hashId &gt;= hashAlgorithms.length) ?
320             &quot;UNDEFINED-HASH(&quot; + hashId + &quot;)&quot; : hashAlgorithms[hashId];
321         String signName = (signId &gt;= signatureAlgorithms.length) ?
322             &quot;UNDEFINED-SIGNATURE(&quot; + signId + &quot;)&quot; :
323             signatureAlgorithms[signId];
324 
325         return signName + &quot;_&quot; + hashName;
326     }
327 
328     // Return the size of a SignatureScheme structure in TLS record
329     static int sizeInRecord() {
330         return 2;
331     }
332 












333     // Get local supported algorithm collection complying to algorithm
334     // constraints.
335     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
336             AlgorithmConstraints constraints,
337             List&lt;ProtocolVersion&gt; activeProtocols) {
338         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
339         for (SignatureScheme ss: SignatureScheme.values()) {
340             if (!ss.isAvailable) {
341                 continue;
342             }
343 
344             boolean isMatch = false;
345             for (ProtocolVersion pv : activeProtocols) {
346                 if (ss.supportedProtocols.contains(pv)) {
347                     isMatch = true;
348                     break;
349                 }
350             }
351 
352             if (isMatch) {
<span class="line-modified">353                 if (constraints.permits(</span>
<span class="line-removed">354                         SIGNATURE_PRIMITIVE_SET, ss.algorithm, null)) {</span>
355                     supported.add(ss);
356                 } else if (SSLLogger.isOn &amp;&amp;
357                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
358                     SSLLogger.finest(
359                         &quot;Ignore disabled signature scheme: &quot; + ss.name);
360                 }
361             } else if (SSLLogger.isOn &amp;&amp;
362                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
363                 SSLLogger.finest(
364                     &quot;Ignore inactive signature scheme: &quot; + ss.name);
365             }
366         }
367 
368         return supported;
369     }
370 
371     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
372             AlgorithmConstraints constraints,
373             ProtocolVersion protocolVersion, int[] algorithmIds) {
374         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
375         for (int ssid : algorithmIds) {
376             SignatureScheme ss = SignatureScheme.valueOf(ssid);
377             if (ss == null) {
378                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
379                     SSLLogger.warning(
380                             &quot;Unsupported signature scheme: &quot; +
381                             SignatureScheme.nameOf(ssid));
382                 }
383             } else if (ss.isAvailable &amp;&amp;
384                     ss.supportedProtocols.contains(protocolVersion) &amp;&amp;
<span class="line-modified">385                     constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-removed">386                            ss.algorithm, null)) {</span>
387                 supported.add(ss);
388             } else {
389                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
390                     SSLLogger.warning(
391                             &quot;Unsupported signature scheme: &quot; + ss.name);
392                 }
393             }
394         }
395 
396         return supported;
397     }
398 
399     static SignatureScheme getPreferableAlgorithm(

400             List&lt;SignatureScheme&gt; schemes,
401             SignatureScheme certScheme,
402             ProtocolVersion version) {
403 
404         for (SignatureScheme ss : schemes) {
405             if (ss.isAvailable &amp;&amp;
406                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
<span class="line-modified">407                     certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm)) {</span>
<span class="line-modified">408 </span>
409                 return ss;
410             }
411         }
412 
413         return null;
414     }
415 
<span class="line-modified">416     static SignatureScheme getPreferableAlgorithm(</span>

417             List&lt;SignatureScheme&gt; schemes,
<span class="line-modified">418             PrivateKey signingKey,</span>
419             ProtocolVersion version) {
420 

421         String keyAlgorithm = signingKey.getAlgorithm();
422         int keySize;
423         // Only need to check RSA algorithm at present.
424         if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;) ||
425                 keyAlgorithm.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
426             keySize = KeyUtil.getKeySize(signingKey);
427         } else {
428             keySize = Integer.MAX_VALUE;
429         }
430         for (SignatureScheme ss : schemes) {
431             if (ss.isAvailable &amp;&amp; (keySize &gt;= ss.minimalKeySize) &amp;&amp;
<span class="line-modified">432                 ss.handshakeSupportedProtocols.contains(version) &amp;&amp;</span>
<span class="line-modified">433                 keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm)) {</span>
<span class="line-modified">434                 if (ss.namedGroup != null &amp;&amp;</span>
<span class="line-modified">435                     ss.namedGroup.type == NamedGroupType.NAMED_GROUP_ECDHE) {</span>

436                     ECParameterSpec params =
<span class="line-modified">437                                 ((ECPrivateKey)signingKey).getParams();</span>
<span class="line-modified">438                     if (ss.namedGroup == NamedGroup.valueOf(params)) {</span>
<span class="line-modified">439                         return ss;</span>








































440                     }
441                 } else {
<span class="line-modified">442                     return ss;</span>



443                 }
444             }
445         }
446 
447         return null;
448     }
449 
450     static String[] getAlgorithmNames(Collection&lt;SignatureScheme&gt; schemes) {
451         if (schemes != null) {
452             ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(schemes.size());
453             for (SignatureScheme scheme : schemes) {
454                 names.add(scheme.algorithm);
455             }
456 
457             return names.toArray(new String[0]);
458         }
459 
460         return new String[0];
461     }
462 
<span class="line-modified">463     Signature getSignature(Key key) throws NoSuchAlgorithmException,</span>





464             InvalidAlgorithmParameterException, InvalidKeyException {
465         if (!isAvailable) {
466             return null;
467         }
468 
<span class="line-modified">469         Signature signer = Signature.getInstance(algorithm);</span>
<span class="line-modified">470         if (key instanceof PublicKey) {</span>
<span class="line-modified">471             signer.initVerify((PublicKey)(key));</span>
<span class="line-modified">472         } else {</span>
<span class="line-modified">473             signer.initSign((PrivateKey)key);</span>









474         }
475 
<span class="line-modified">476         // Important note:  Please don&#39;t set the parameters before signature</span>
<span class="line-modified">477         // or verification initialization, so that the crypto provider can</span>
<span class="line-modified">478         // be selected properly.</span>
<span class="line-modified">479         if (signAlgParameter != null) {</span>
<span class="line-modified">480             signer.setParameter(signAlgParameter);</span>









481         }
482 
<span class="line-modified">483         return signer;</span>
484     }
485 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.*;

 29 import java.security.spec.AlgorithmParameterSpec;
 30 import java.security.spec.ECParameterSpec;
 31 import java.security.spec.MGF1ParameterSpec;
 32 import java.security.spec.PSSParameterSpec;
<span class="line-added"> 33 import java.util.AbstractMap.SimpleImmutableEntry;</span>
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.Collection;
 37 import java.util.Collections;
 38 import java.util.EnumSet;
 39 import java.util.LinkedList;
 40 import java.util.List;
<span class="line-added"> 41 import java.util.Map;</span>
 42 import java.util.Set;
<span class="line-modified"> 43 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
<span class="line-modified"> 44 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;</span>
<span class="line-added"> 45 import sun.security.ssl.X509Authentication.X509Possession;</span>
 46 import sun.security.util.KeyUtil;
<span class="line-added"> 47 import sun.security.util.SignatureUtil;</span>
 48 
 49 enum SignatureScheme {
 50     // EdDSA algorithms
 51     ED25519                 (0x0807, &quot;ed25519&quot;, &quot;ed25519&quot;,
 52                                     &quot;ed25519&quot;,
 53                                     ProtocolVersion.PROTOCOLS_OF_13),
 54     ED448                   (0x0808, &quot;ed448&quot;, &quot;ed448&quot;,
 55                                     &quot;ed448&quot;,
 56                                     ProtocolVersion.PROTOCOLS_OF_13),
 57 
 58     // ECDSA algorithms
 59     ECDSA_SECP256R1_SHA256  (0x0403, &quot;ecdsa_secp256r1_sha256&quot;,
 60                                     &quot;SHA256withECDSA&quot;,
 61                                     &quot;EC&quot;,
 62                                     NamedGroup.SECP256_R1,
 63                                     ProtocolVersion.PROTOCOLS_TO_13),
 64     ECDSA_SECP384R1_SHA384  (0x0503, &quot;ecdsa_secp384r1_sha384&quot;,
 65                                     &quot;SHA384withECDSA&quot;,
 66                                     &quot;EC&quot;,
 67                                     NamedGroup.SECP384_R1,
</pre>
<hr />
<pre>
134                                     &quot;DSA&quot;,
135                                     ProtocolVersion.PROTOCOLS_TO_12),
136     ECDSA_SHA1              (0x0203, &quot;ecdsa_sha1&quot;, &quot;SHA1withECDSA&quot;,
137                                     &quot;EC&quot;,
138                                     ProtocolVersion.PROTOCOLS_TO_13),
139     RSA_PKCS1_SHA1          (0x0201, &quot;rsa_pkcs1_sha1&quot;, &quot;SHA1withRSA&quot;,
140                                     &quot;RSA&quot;, null, null, 511,
141                                     ProtocolVersion.PROTOCOLS_TO_13,
142                                     ProtocolVersion.PROTOCOLS_TO_12),
143     DSA_SHA1                (0x0202, &quot;dsa_sha1&quot;, &quot;SHA1withDSA&quot;,
144                                     &quot;DSA&quot;,
145                                     ProtocolVersion.PROTOCOLS_TO_12),
146     RSA_MD5                 (0x0101, &quot;rsa_md5&quot;, &quot;MD5withRSA&quot;,
147                                     &quot;RSA&quot;, 511,
148                                     ProtocolVersion.PROTOCOLS_TO_12);
149 
150     final int id;                       // hash + signature
151     final String name;                  // literal name
152     private final String algorithm;     // signature algorithm
153     final String keyAlgorithm;          // signature key algorithm
<span class="line-modified">154     private final SigAlgParamSpec signAlgParams;    // signature parameters</span>
155     private final NamedGroup namedGroup;    // associated named group
156 
157     // The minimal required key size in bits.
158     //
159     // Only need to check RSA algorithm at present. RSA keys of 512 bits
160     // have been shown to be practically breakable, it does not make much
161     // sense to use the strong hash algorithm for keys whose key size less
162     // than 512 bits.  So it is not necessary to calculate the minimal
163     // required key size exactly for a hash algorithm.
164     //
165     // Note that some provider may use 511 bits for 512-bit strength RSA keys.
166     final int minimalKeySize;
167     final List&lt;ProtocolVersion&gt; supportedProtocols;
168 
169     // Some signature schemes are supported in different versions for handshake
170     // messages and certificates. This field holds the supported protocols
171     // for handshake messages.
172     final List&lt;ProtocolVersion&gt; handshakeSupportedProtocols;
173     final boolean isAvailable;
174 
175     private static final String[] hashAlgorithms = new String[] {
176             &quot;none&quot;,         &quot;md5&quot;,      &quot;sha1&quot;,     &quot;sha224&quot;,
177             &quot;sha256&quot;,       &quot;sha384&quot;,   &quot;sha512&quot;
178         };
179 
180     private static final String[] signatureAlgorithms = new String[] {
181             &quot;anonymous&quot;,    &quot;rsa&quot;,      &quot;dsa&quot;,      &quot;ecdsa&quot;,
182         };
183 
184     static enum SigAlgParamSpec {   // support RSASSA-PSS only now
185         RSA_PSS_SHA256 (&quot;SHA-256&quot;, 32),
186         RSA_PSS_SHA384 (&quot;SHA-384&quot;, 48),
187         RSA_PSS_SHA512 (&quot;SHA-512&quot;, 64);
188 
<span class="line-modified">189         private final AlgorithmParameterSpec parameterSpec;</span>
<span class="line-modified">190         private final AlgorithmParameters parameters;</span>
<span class="line-added">191         private final boolean isAvailable;</span>
192 
193         SigAlgParamSpec(String hash, int saltLength) {
194             // See RFC 8017
195             PSSParameterSpec pssParamSpec =
196                     new PSSParameterSpec(hash, &quot;MGF1&quot;,
197                             new MGF1ParameterSpec(hash), saltLength, 1);
<span class="line-added">198             AlgorithmParameters pssParams = null;</span>
199 
200             boolean mediator = true;
201             try {
202                 Signature signer = Signature.getInstance(&quot;RSASSA-PSS&quot;);
203                 signer.setParameter(pssParamSpec);
<span class="line-added">204                 pssParams = signer.getParameters();</span>
205             } catch (InvalidAlgorithmParameterException |
<span class="line-modified">206                     NoSuchAlgorithmException | RuntimeException exp) {</span>
<span class="line-added">207                 // Signature.getParameters() may throw RuntimeException.</span>
208                 mediator = false;
209                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
210                     SSLLogger.warning(
211                         &quot;RSASSA-PSS signature with &quot; + hash +
212                         &quot; is not supported by the underlying providers&quot;, exp);
213                 }
214             }
215 
216             this.isAvailable = mediator;
217             this.parameterSpec = mediator ? pssParamSpec : null;
<span class="line-modified">218             this.parameters = mediator ? pssParams : null;</span>



219         }
220     }
221 
222     // performance optimization
223     private static final Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
224         Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
225 
226 
227     private SignatureScheme(int id, String name,
228             String algorithm, String keyAlgorithm,
229             ProtocolVersion[] supportedProtocols) {
230         this(id, name, algorithm, keyAlgorithm, -1, supportedProtocols);
231     }
232 
233     private SignatureScheme(int id, String name,
234             String algorithm, String keyAlgorithm,
235             int minimalKeySize,
236             ProtocolVersion[] supportedProtocols) {
237         this(id, name, algorithm, keyAlgorithm,
238                 null, minimalKeySize, supportedProtocols);
</pre>
<hr />
<pre>
241     private SignatureScheme(int id, String name,
242             String algorithm, String keyAlgorithm,
243             SigAlgParamSpec signAlgParamSpec, int minimalKeySize,
244             ProtocolVersion[] supportedProtocols) {
245         this(id, name, algorithm, keyAlgorithm,
246                 signAlgParamSpec, null, minimalKeySize,
247                 supportedProtocols, supportedProtocols);
248     }
249 
250     private SignatureScheme(int id, String name,
251             String algorithm, String keyAlgorithm,
252             NamedGroup namedGroup,
253             ProtocolVersion[] supportedProtocols) {
254         this(id, name, algorithm, keyAlgorithm,
255                 null, namedGroup, -1,
256                 supportedProtocols, supportedProtocols);
257     }
258 
259     private SignatureScheme(int id, String name,
260             String algorithm, String keyAlgorithm,
<span class="line-modified">261             SigAlgParamSpec signAlgParams,</span>
262             NamedGroup namedGroup, int minimalKeySize,
263             ProtocolVersion[] supportedProtocols,
264             ProtocolVersion[] handshakeSupportedProtocols) {
265         this.id = id;
266         this.name = name;
267         this.algorithm = algorithm;
268         this.keyAlgorithm = keyAlgorithm;
<span class="line-modified">269         this.signAlgParams = signAlgParams;</span>

270         this.namedGroup = namedGroup;
271         this.minimalKeySize = minimalKeySize;
272         this.supportedProtocols = Arrays.asList(supportedProtocols);
273         this.handshakeSupportedProtocols =
274                 Arrays.asList(handshakeSupportedProtocols);
275 
276         boolean mediator = true;
<span class="line-modified">277         // An EC provider, for example the SunEC provider, may support</span>
<span class="line-modified">278         // AlgorithmParameters but not KeyPairGenerator or Signature.</span>
<span class="line-modified">279         //</span>
<span class="line-modified">280         // Note: Please be careful if removing this block!</span>
<span class="line-modified">281         if (&quot;EC&quot;.equals(keyAlgorithm)) {</span>
<span class="line-modified">282             mediator = JsseJce.isEcAvailable();</span>
<span class="line-modified">283         }</span>
<span class="line-modified">284 </span>
<span class="line-modified">285         // Check the specific algorithm and parameters.</span>
<span class="line-modified">286         if (mediator) {</span>
<span class="line-modified">287             if (signAlgParams != null) {</span>
<span class="line-added">288                 mediator = signAlgParams.isAvailable;</span>
<span class="line-added">289             } else {</span>
<span class="line-added">290                 try {</span>
<span class="line-added">291                     Signature.getInstance(algorithm);</span>
<span class="line-added">292                 } catch (Exception e) {</span>
<span class="line-added">293                     mediator = false;</span>
<span class="line-added">294                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">295                         SSLLogger.warning(</span>
<span class="line-added">296                             &quot;Signature algorithm, &quot; + algorithm +</span>
<span class="line-added">297                             &quot;, is not supported by the underlying providers&quot;);</span>
<span class="line-added">298                     }</span>
299                 }
300             }
301         }
302 
303         if (mediator &amp;&amp; ((id &gt;&gt; 8) &amp; 0xFF) == 0x03) {   // SHA224
304             // There are some problems to use SHA224 on Windows.
305             if (Security.getProvider(&quot;SunMSCAPI&quot;) != null) {
306                 mediator = false;
307             }
308         }
309 
310         this.isAvailable = mediator;
311     }
312 
313     static SignatureScheme valueOf(int id) {
314         for (SignatureScheme ss: SignatureScheme.values()) {
315             if (ss.id == id) {
316                 return ss;
317             }
318         }
</pre>
<hr />
<pre>
327             }
328         }
329 
330         // Use TLS 1.2 style name for unknown signature scheme.
331         int hashId = ((id &gt;&gt; 8) &amp; 0xFF);
332         int signId = (id &amp; 0xFF);
333         String hashName = (hashId &gt;= hashAlgorithms.length) ?
334             &quot;UNDEFINED-HASH(&quot; + hashId + &quot;)&quot; : hashAlgorithms[hashId];
335         String signName = (signId &gt;= signatureAlgorithms.length) ?
336             &quot;UNDEFINED-SIGNATURE(&quot; + signId + &quot;)&quot; :
337             signatureAlgorithms[signId];
338 
339         return signName + &quot;_&quot; + hashName;
340     }
341 
342     // Return the size of a SignatureScheme structure in TLS record
343     static int sizeInRecord() {
344         return 2;
345     }
346 
<span class="line-added">347     private boolean isPermitted(AlgorithmConstraints constraints) {</span>
<span class="line-added">348         return constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">349                         this.name, null) &amp;&amp;</span>
<span class="line-added">350                constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">351                         this.keyAlgorithm, null) &amp;&amp;</span>
<span class="line-added">352                constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">353                         this.algorithm, (signAlgParams != null ?</span>
<span class="line-added">354                                 signAlgParams.parameters : null)) &amp;&amp;</span>
<span class="line-added">355                (namedGroup != null ?</span>
<span class="line-added">356                         namedGroup.isPermitted(constraints) : true);</span>
<span class="line-added">357     }</span>
<span class="line-added">358 </span>
359     // Get local supported algorithm collection complying to algorithm
360     // constraints.
361     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
362             AlgorithmConstraints constraints,
363             List&lt;ProtocolVersion&gt; activeProtocols) {
364         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
365         for (SignatureScheme ss: SignatureScheme.values()) {
366             if (!ss.isAvailable) {
367                 continue;
368             }
369 
370             boolean isMatch = false;
371             for (ProtocolVersion pv : activeProtocols) {
372                 if (ss.supportedProtocols.contains(pv)) {
373                     isMatch = true;
374                     break;
375                 }
376             }
377 
378             if (isMatch) {
<span class="line-modified">379                 if (ss.isPermitted(constraints)) {</span>

380                     supported.add(ss);
381                 } else if (SSLLogger.isOn &amp;&amp;
382                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
383                     SSLLogger.finest(
384                         &quot;Ignore disabled signature scheme: &quot; + ss.name);
385                 }
386             } else if (SSLLogger.isOn &amp;&amp;
387                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
388                 SSLLogger.finest(
389                     &quot;Ignore inactive signature scheme: &quot; + ss.name);
390             }
391         }
392 
393         return supported;
394     }
395 
396     static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
397             AlgorithmConstraints constraints,
398             ProtocolVersion protocolVersion, int[] algorithmIds) {
399         List&lt;SignatureScheme&gt; supported = new LinkedList&lt;&gt;();
400         for (int ssid : algorithmIds) {
401             SignatureScheme ss = SignatureScheme.valueOf(ssid);
402             if (ss == null) {
403                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
404                     SSLLogger.warning(
405                             &quot;Unsupported signature scheme: &quot; +
406                             SignatureScheme.nameOf(ssid));
407                 }
408             } else if (ss.isAvailable &amp;&amp;
409                     ss.supportedProtocols.contains(protocolVersion) &amp;&amp;
<span class="line-modified">410                     ss.isPermitted(constraints)) {</span>

411                 supported.add(ss);
412             } else {
413                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
414                     SSLLogger.warning(
415                             &quot;Unsupported signature scheme: &quot; + ss.name);
416                 }
417             }
418         }
419 
420         return supported;
421     }
422 
423     static SignatureScheme getPreferableAlgorithm(
<span class="line-added">424             AlgorithmConstraints constraints,</span>
425             List&lt;SignatureScheme&gt; schemes,
426             SignatureScheme certScheme,
427             ProtocolVersion version) {
428 
429         for (SignatureScheme ss : schemes) {
430             if (ss.isAvailable &amp;&amp;
431                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
<span class="line-modified">432                     certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;</span>
<span class="line-modified">433                     ss.isPermitted(constraints)) {</span>
434                 return ss;
435             }
436         }
437 
438         return null;
439     }
440 
<span class="line-modified">441     static Map.Entry&lt;SignatureScheme, Signature&gt; getSignerOfPreferableAlgorithm(</span>
<span class="line-added">442             AlgorithmConstraints constraints,</span>
443             List&lt;SignatureScheme&gt; schemes,
<span class="line-modified">444             X509Possession x509Possession,</span>
445             ProtocolVersion version) {
446 
<span class="line-added">447         PrivateKey signingKey = x509Possession.popPrivateKey;</span>
448         String keyAlgorithm = signingKey.getAlgorithm();
449         int keySize;
450         // Only need to check RSA algorithm at present.
451         if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;) ||
452                 keyAlgorithm.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
453             keySize = KeyUtil.getKeySize(signingKey);
454         } else {
455             keySize = Integer.MAX_VALUE;
456         }
457         for (SignatureScheme ss : schemes) {
458             if (ss.isAvailable &amp;&amp; (keySize &gt;= ss.minimalKeySize) &amp;&amp;
<span class="line-modified">459                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;</span>
<span class="line-modified">460                     keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;</span>
<span class="line-modified">461                     ss.isPermitted(constraints)) {</span>
<span class="line-modified">462                 if ((ss.namedGroup != null) &amp;&amp; (ss.namedGroup.spec ==</span>
<span class="line-added">463                         NamedGroupSpec.NAMED_GROUP_ECDHE)) {</span>
464                     ECParameterSpec params =
<span class="line-modified">465                             x509Possession.getECParameterSpec();</span>
<span class="line-modified">466                     if (params != null &amp;&amp;</span>
<span class="line-modified">467                             ss.namedGroup == NamedGroup.valueOf(params)) {</span>
<span class="line-added">468                         Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">469                         if (signer != null) {</span>
<span class="line-added">470                             return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">471                         }</span>
<span class="line-added">472                     }</span>
<span class="line-added">473 </span>
<span class="line-added">474                     if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">475                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">476                         SSLLogger.finest(</span>
<span class="line-added">477                             &quot;Ignore the signature algorithm (&quot; + ss +</span>
<span class="line-added">478                             &quot;), unsupported EC parameter spec: &quot; + params);</span>
<span class="line-added">479                     }</span>
<span class="line-added">480                 } else if (&quot;EC&quot;.equals(ss.keyAlgorithm)) {</span>
<span class="line-added">481                     // Must be a legacy signature algorithm, which does not</span>
<span class="line-added">482                     // specify the associated named groups.  The connection</span>
<span class="line-added">483                     // cannot be established if the peer cannot recognize</span>
<span class="line-added">484                     // the named group used for the signature.  RFC 8446</span>
<span class="line-added">485                     // does not define countermeasures for the corner cases.</span>
<span class="line-added">486                     // In order to mitigate the impact, we choose to check</span>
<span class="line-added">487                     // against the local supported named groups.  The risk</span>
<span class="line-added">488                     // should be minimal as applications should not use</span>
<span class="line-added">489                     // unsupported named groups for its certificates.</span>
<span class="line-added">490                     ECParameterSpec params =</span>
<span class="line-added">491                             x509Possession.getECParameterSpec();</span>
<span class="line-added">492                     if (params != null) {</span>
<span class="line-added">493                         NamedGroup keyGroup = NamedGroup.valueOf(params);</span>
<span class="line-added">494                         if (keyGroup != null &amp;&amp;</span>
<span class="line-added">495                                 SupportedGroups.isSupported(keyGroup)) {</span>
<span class="line-added">496                             Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">497                             if (signer != null) {</span>
<span class="line-added">498                                 return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">499                             }</span>
<span class="line-added">500                         }</span>
<span class="line-added">501                     }</span>
<span class="line-added">502 </span>
<span class="line-added">503                     if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">504                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">505                         SSLLogger.finest(</span>
<span class="line-added">506                             &quot;Ignore the legacy signature algorithm (&quot; + ss +</span>
<span class="line-added">507                             &quot;), unsupported EC parameter spec: &quot; + params);</span>
508                     }
509                 } else {
<span class="line-modified">510                     Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">511                     if (signer != null) {</span>
<span class="line-added">512                         return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">513                     }</span>
514                 }
515             }
516         }
517 
518         return null;
519     }
520 
521     static String[] getAlgorithmNames(Collection&lt;SignatureScheme&gt; schemes) {
522         if (schemes != null) {
523             ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(schemes.size());
524             for (SignatureScheme scheme : schemes) {
525                 names.add(scheme.algorithm);
526             }
527 
528             return names.toArray(new String[0]);
529         }
530 
531         return new String[0];
532     }
533 
<span class="line-modified">534     // This method is used to get the signature instance of this signature</span>
<span class="line-added">535     // scheme for the specific public key.  Unlike getSigner(), the exception</span>
<span class="line-added">536     // is bubbled up.  If the public key does not support this signature</span>
<span class="line-added">537     // scheme, it normally means the TLS handshaking cannot continue and</span>
<span class="line-added">538     // the connection should be terminated.</span>
<span class="line-added">539     Signature getVerifier(PublicKey publicKey) throws NoSuchAlgorithmException,</span>
540             InvalidAlgorithmParameterException, InvalidKeyException {
541         if (!isAvailable) {
542             return null;
543         }
544 
<span class="line-modified">545         Signature verifier = Signature.getInstance(algorithm);</span>
<span class="line-modified">546         SignatureUtil.initVerifyWithParam(verifier, publicKey,</span>
<span class="line-modified">547                 (signAlgParams != null ? signAlgParams.parameterSpec : null));</span>
<span class="line-modified">548 </span>
<span class="line-modified">549         return verifier;</span>
<span class="line-added">550     }</span>
<span class="line-added">551 </span>
<span class="line-added">552     // This method is also used to choose preferable signature scheme for the</span>
<span class="line-added">553     // specific private key.  If the private key does not support the signature</span>
<span class="line-added">554     // scheme, {@code null} is returned, and the caller may fail back to next</span>
<span class="line-added">555     // available signature scheme.</span>
<span class="line-added">556     private Signature getSigner(PrivateKey privateKey) {</span>
<span class="line-added">557         if (!isAvailable) {</span>
<span class="line-added">558             return null;</span>
559         }
560 
<span class="line-modified">561         try {</span>
<span class="line-modified">562             Signature signer = Signature.getInstance(algorithm);</span>
<span class="line-modified">563             SignatureUtil.initSignWithParam(signer, privateKey,</span>
<span class="line-modified">564                 (signAlgParams != null ? signAlgParams.parameterSpec : null),</span>
<span class="line-modified">565                 null);</span>
<span class="line-added">566             return signer;</span>
<span class="line-added">567         } catch (NoSuchAlgorithmException | InvalidKeyException |</span>
<span class="line-added">568                 InvalidAlgorithmParameterException nsae) {</span>
<span class="line-added">569             if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">570                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">571                 SSLLogger.finest(</span>
<span class="line-added">572                     &quot;Ignore unsupported signature algorithm (&quot; +</span>
<span class="line-added">573                     this.name + &quot;)&quot;, nsae);</span>
<span class="line-added">574             }</span>
575         }
576 
<span class="line-modified">577         return null;</span>
578     }
579 }
</pre>
</td>
</tr>
</table>
<center><a href="SessionId.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SunJSSE.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
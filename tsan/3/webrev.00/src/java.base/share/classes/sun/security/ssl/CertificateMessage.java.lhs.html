<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/CertificateMessage.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.ByteArrayInputStream;
  29 import java.io.IOException;
  30 import java.nio.ByteBuffer;
  31 import java.security.PublicKey;
  32 import java.security.cert.CertPathValidatorException;
  33 import java.security.cert.CertPathValidatorException.BasicReason;
  34 import java.security.cert.CertPathValidatorException.Reason;
  35 import java.security.cert.CertificateEncodingException;
  36 import java.security.cert.CertificateException;
  37 import java.security.cert.CertificateFactory;
  38 import java.security.cert.CertificateParsingException;
  39 import java.security.cert.X509Certificate;
  40 import java.text.MessageFormat;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collection;
  44 import java.util.Collections;
  45 import java.util.HashSet;
  46 import java.util.LinkedList;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import javax.net.ssl.SSLEngine;
  50 import javax.net.ssl.SSLException;
  51 import javax.net.ssl.SSLProtocolException;
  52 import javax.net.ssl.SSLSocket;
  53 import javax.net.ssl.X509ExtendedTrustManager;
  54 import javax.net.ssl.X509TrustManager;
  55 import javax.security.auth.x500.X500Principal;
  56 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
  57 import sun.security.ssl.ClientHello.ClientHelloMessage;
  58 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  59 import sun.security.ssl.X509Authentication.X509Credentials;
  60 import sun.security.ssl.X509Authentication.X509Possession;
  61 
  62 /**
  63  * Pack of the CertificateMessage handshake message.
  64  */
  65 final class CertificateMessage {
  66     static final SSLConsumer t12HandshakeConsumer =
  67         new T12CertificateConsumer();
  68     static final HandshakeProducer t12HandshakeProducer =
  69         new T12CertificateProducer();
  70 
  71     static final SSLConsumer t13HandshakeConsumer =
  72         new T13CertificateConsumer();
  73     static final HandshakeProducer t13HandshakeProducer =
  74         new T13CertificateProducer();
  75 
  76     /**
  77      * The Certificate handshake message for TLS 1.2 and previous
  78      * SSL/TLS protocol versions.
  79      *
  80      * In server mode, the certificate handshake message is sent whenever the
  81      * agreed-upon key exchange method uses certificates for authentication.
  82      * In client mode, this message is only sent if the server requests a
  83      * certificate for client authentication.
  84      *
  85      *       opaque ASN.1Cert&lt;1..2^24-1&gt;;
  86      *
  87      * SSL 3.0:
  88      *       struct {
  89      *           ASN.1Cert certificate_list&lt;1..2^24-1&gt;;
  90      *       } Certificate;
  91      * Note: For SSL 3.0 client authentication, if no suitable certificate
  92      * is available, the client should send a no_certificate alert instead.
  93      * This alert is only a warning; however, the server may respond with
  94      * a fatal handshake failure alert if client authentication is required.
  95      *
  96      * TLS 1.0/1.1/1.2:
  97      *       struct {
  98      *           ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
  99      *       } Certificate;
 100      */
 101     static final class T12CertificateMessage extends HandshakeMessage {
 102         final List&lt;byte[]&gt; encodedCertChain;
 103 
 104         T12CertificateMessage(HandshakeContext handshakeContext,
 105                 X509Certificate[] certChain) throws SSLException {
 106             super(handshakeContext);
 107 
 108             List&lt;byte[]&gt; encodedCerts = new ArrayList&lt;&gt;(certChain.length);
 109             for (X509Certificate cert : certChain) {
 110                 try {
 111                     encodedCerts.add(cert.getEncoded());
 112                 } catch (CertificateEncodingException cee) {
 113                     // unlikely
 114                     throw handshakeContext.conContext.fatal(
 115                             Alert.INTERNAL_ERROR,
 116                             &quot;Could not encode certificate (&quot; +
 117                             cert.getSubjectX500Principal() + &quot;)&quot;, cee);
 118                 }
 119             }
 120 
 121             this.encodedCertChain = encodedCerts;
 122         }
 123 
 124         T12CertificateMessage(HandshakeContext handshakeContext,
 125                 ByteBuffer m) throws IOException {
 126             super(handshakeContext);
 127 
 128             int listLen = Record.getInt24(m);
 129             if (listLen &gt; m.remaining()) {
 130                 throw handshakeContext.conContext.fatal(
 131                     Alert.ILLEGAL_PARAMETER,
 132                     &quot;Error parsing certificate message:no sufficient data&quot;);
 133             }
 134             if (listLen &gt; 0) {
 135                 List&lt;byte[]&gt; encodedCerts = new LinkedList&lt;&gt;();
 136                 while (listLen &gt; 0) {
 137                     byte[] encodedCert = Record.getBytes24(m);
 138                     listLen -= (3 + encodedCert.length);
 139                     encodedCerts.add(encodedCert);
 140                 }
 141                 this.encodedCertChain = encodedCerts;
 142             } else {
 143                 this.encodedCertChain = Collections.emptyList();
 144             }
 145         }
 146 
 147         @Override
 148         public SSLHandshake handshakeType() {
 149             return SSLHandshake.CERTIFICATE;
 150         }
 151 
 152         @Override
 153         public int messageLength() {
 154             int msgLen = 3;
 155             for (byte[] encodedCert : encodedCertChain) {
 156                 msgLen += (encodedCert.length + 3);
 157             }
 158 
 159             return msgLen;
 160         }
 161 
 162         @Override
 163         public void send(HandshakeOutStream hos) throws IOException {
 164             int listLen = 0;
 165             for (byte[] encodedCert : encodedCertChain) {
 166                 listLen += (encodedCert.length + 3);
 167             }
 168 
 169             hos.putInt24(listLen);
 170             for (byte[] encodedCert : encodedCertChain) {
 171                 hos.putBytes24(encodedCert);
 172             }
 173         }
 174 
 175         @Override
 176         public String toString() {
 177             if (encodedCertChain.isEmpty()) {
 178                 return &quot;\&quot;Certificates\&quot;: &lt;empty list&gt;&quot;;
 179             }
 180 
 181             Object[] x509Certs = new Object[encodedCertChain.size()];
 182             try {
 183                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 184                 int i = 0;
 185                 for (byte[] encodedCert : encodedCertChain) {
 186                     Object obj;
 187                     try {
 188                         obj = (X509Certificate)cf.generateCertificate(
 189                                     new ByteArrayInputStream(encodedCert));
 190                     } catch (CertificateException ce) {
 191                         obj = encodedCert;
 192                     }
 193                     x509Certs[i++] = obj;
 194                 }
 195             } catch (CertificateException ce) {
 196                 // no X.509 certificate factory service
 197                 int i = 0;
 198                 for (byte[] encodedCert : encodedCertChain) {
 199                     x509Certs[i++] = encodedCert;
 200                 }
 201             }
 202 
 203             MessageFormat messageFormat = new MessageFormat(
 204                     &quot;\&quot;Certificates\&quot;: [\n&quot; +
 205                     &quot;{0}\n&quot; +
 206                     &quot;]&quot;,
 207                     Locale.ENGLISH);
 208             Object[] messageFields = {
 209                 SSLLogger.toString(x509Certs)
 210             };
 211 
 212             return messageFormat.format(messageFields);
 213         }
 214     }
 215 
 216     /**
 217      * The &quot;Certificate&quot; handshake message producer for TLS 1.2 and
 218      * previous SSL/TLS protocol versions.
 219      */
 220     private static final
 221             class T12CertificateProducer implements HandshakeProducer {
 222         // Prevent instantiation of this class.
 223         private T12CertificateProducer() {
 224             // blank
 225         }
 226 
 227         @Override
 228         public byte[] produce(ConnectionContext context,
 229                 HandshakeMessage message) throws IOException {
 230             // The producing happens in handshake context only.
 231             HandshakeContext hc = (HandshakeContext)context;
 232             if (hc.sslConfig.isClientMode) {
 233                 return onProduceCertificate(
 234                         (ClientHandshakeContext)context, message);
 235             } else {
 236                 return onProduceCertificate(
 237                         (ServerHandshakeContext)context, message);
 238             }
 239         }
 240 
 241         private byte[] onProduceCertificate(ServerHandshakeContext shc,
 242                 SSLHandshake.HandshakeMessage message) throws IOException {
 243             X509Possession x509Possession = null;
 244             for (SSLPossession possession : shc.handshakePossessions) {
 245                 if (possession instanceof X509Possession) {
 246                     x509Possession = (X509Possession)possession;
 247                     break;
 248                 }
 249             }
 250 
 251             if (x509Possession == null) {       // unlikely
 252                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 253                     &quot;No expected X.509 certificate for server authentication&quot;);
 254             }
 255 
 256             shc.handshakeSession.setLocalPrivateKey(
 257                     x509Possession.popPrivateKey);
 258             shc.handshakeSession.setLocalCertificates(x509Possession.popCerts);
 259             T12CertificateMessage cm =
 260                     new T12CertificateMessage(shc, x509Possession.popCerts);
 261             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 262                 SSLLogger.fine(
 263                     &quot;Produced server Certificate handshake message&quot;, cm);
 264             }
 265 
 266             // Output the handshake message.
 267             cm.write(shc.handshakeOutput);
 268             shc.handshakeOutput.flush();
 269 
 270             // The handshake message has been delivered.
 271             return null;
 272         }
 273 
 274         private byte[] onProduceCertificate(ClientHandshakeContext chc,
 275                 SSLHandshake.HandshakeMessage message) throws IOException {
 276             X509Possession x509Possession = null;
 277             for (SSLPossession possession : chc.handshakePossessions) {
 278                 if (possession instanceof X509Possession) {
 279                     x509Possession = (X509Possession)possession;
 280                     break;
 281                 }
 282             }
 283 
 284             // Report to the server if no appropriate cert was found.  For
 285             // SSL 3.0, send a no_certificate alert;  TLS 1.0/1.1/1.2 uses
 286             // an empty cert chain instead.
 287             if (x509Possession == null) {
 288                 if (chc.negotiatedProtocol.useTLS10PlusSpec()) {
 289                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 290                         SSLLogger.fine(
 291                             &quot;No X.509 certificate for client authentication, &quot; +
 292                             &quot;use empty Certificate message instead&quot;);
 293                     }
 294 
 295                     x509Possession =
 296                             new X509Possession(null, new X509Certificate[0]);
 297                 } else {
 298                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 299                         SSLLogger.fine(
 300                             &quot;No X.509 certificate for client authentication, &quot; +
 301                             &quot;send a no_certificate alert&quot;);
 302                     }
 303 
 304                     chc.conContext.warning(Alert.NO_CERTIFICATE);
 305                     return null;
 306                 }
 307             }
 308 
 309             chc.handshakeSession.setLocalPrivateKey(
 310                     x509Possession.popPrivateKey);
 311             if (x509Possession.popCerts != null &amp;&amp;
 312                     x509Possession.popCerts.length != 0) {
 313                 chc.handshakeSession.setLocalCertificates(
 314                         x509Possession.popCerts);
 315             } else {
 316                 chc.handshakeSession.setLocalCertificates(null);
 317             }
 318             T12CertificateMessage cm =
 319                     new T12CertificateMessage(chc, x509Possession.popCerts);
 320             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 321                 SSLLogger.fine(
 322                     &quot;Produced client Certificate handshake message&quot;, cm);
 323             }
 324 
 325             // Output the handshake message.
 326             cm.write(chc.handshakeOutput);
 327             chc.handshakeOutput.flush();
 328 
 329             // The handshake message has been delivered.
 330             return null;
 331         }
 332     }
 333 
 334     /**
 335      * The &quot;Certificate&quot; handshake message consumer for TLS 1.2 and
 336      * previous SSL/TLS protocol versions.
 337      */
 338     static final
 339             class T12CertificateConsumer implements SSLConsumer {
 340         // Prevent instantiation of this class.
 341         private T12CertificateConsumer() {
 342             // blank
 343         }
 344 
 345         @Override
 346         public void consume(ConnectionContext context,
 347                 ByteBuffer message) throws IOException {
 348             // The consuming happens in handshake context only.
 349             HandshakeContext hc = (HandshakeContext)context;
 350 
 351             // clean up this consumer
 352             hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE.id);
 353 
 354             T12CertificateMessage cm = new T12CertificateMessage(hc, message);
 355             if (hc.sslConfig.isClientMode) {
 356                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 357                     SSLLogger.fine(
 358                         &quot;Consuming server Certificate handshake message&quot;, cm);
 359                 }
 360                 onCertificate((ClientHandshakeContext)context, cm);
 361             } else {
 362                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 363                     SSLLogger.fine(
 364                         &quot;Consuming client Certificate handshake message&quot;, cm);
 365                 }
 366                 onCertificate((ServerHandshakeContext)context, cm);
 367             }
 368         }
 369 
 370         private void onCertificate(ServerHandshakeContext shc,
 371                 T12CertificateMessage certificateMessage )throws IOException {
 372             List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
 373             if (encodedCerts == null || encodedCerts.isEmpty()) {
<a name="1" id="anc1"></a>



 374                 if (shc.sslConfig.clientAuthType !=
 375                         ClientAuthType.CLIENT_AUTH_REQUESTED) {
 376                     // unexpected or require client authentication
 377                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
 378                         &quot;Empty server certificate chain&quot;);
 379                 } else {
 380                     return;
 381                 }
 382             }
 383 
 384             X509Certificate[] x509Certs =
 385                     new X509Certificate[encodedCerts.size()];
 386             try {
 387                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 388                 int i = 0;
 389                 for (byte[] encodedCert : encodedCerts) {
 390                     x509Certs[i++] = (X509Certificate)cf.generateCertificate(
 391                                     new ByteArrayInputStream(encodedCert));
 392                 }
 393             } catch (CertificateException ce) {
 394                 throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
 395                     &quot;Failed to parse server certificates&quot;, ce);
 396             }
 397 
 398             checkClientCerts(shc, x509Certs);
 399 
 400             //
 401             // update
 402             //
 403             shc.handshakeCredentials.add(
 404                 new X509Credentials(x509Certs[0].getPublicKey(), x509Certs));
 405             shc.handshakeSession.setPeerCertificates(x509Certs);
 406         }
 407 
 408         private void onCertificate(ClientHandshakeContext chc,
 409                 T12CertificateMessage certificateMessage) throws IOException {
 410             List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
 411             if (encodedCerts == null || encodedCerts.isEmpty()) {
 412                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
 413                     &quot;Empty server certificate chain&quot;);
 414             }
 415 
 416             X509Certificate[] x509Certs =
 417                     new X509Certificate[encodedCerts.size()];
 418             try {
 419                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 420                 int i = 0;
 421                 for (byte[] encodedCert : encodedCerts) {
 422                     x509Certs[i++] = (X509Certificate)cf.generateCertificate(
 423                                     new ByteArrayInputStream(encodedCert));
 424                 }
 425             } catch (CertificateException ce) {
 426                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
 427                     &quot;Failed to parse server certificates&quot;, ce);
 428             }
 429 
 430             // Allow server certificate change in client side during
 431             // renegotiation after a session-resumption abbreviated
 432             // initial handshake?
 433             //
 434             // DO NOT need to check allowUnsafeServerCertChange here. We only
 435             // reserve server certificates when allowUnsafeServerCertChange is
 436             // false.
 437             if (chc.reservedServerCerts != null &amp;&amp;
 438                     !chc.handshakeSession.useExtendedMasterSecret) {
 439                 // It is not necessary to check the certificate update if
 440                 // endpoint identification is enabled.
 441                 String identityAlg = chc.sslConfig.identificationProtocol;
 442                 if ((identityAlg == null || identityAlg.isEmpty()) &amp;&amp;
 443                         !isIdentityEquivalent(x509Certs[0],
 444                                 chc.reservedServerCerts[0])) {
 445                     throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
 446                             &quot;server certificate change is restricted &quot; +
 447                             &quot;during renegotiation&quot;);
 448                 }
 449             }
 450 
 451             // ask the trust manager to verify the chain
 452             if (chc.staplingActive) {
 453                 // Defer the certificate check until after we&#39;ve received the
 454                 // CertificateStatus message.  If that message doesn&#39;t come in
 455                 // immediately following this message we will execute the
 456                 // check from CertificateStatus&#39; absent handler.
 457                 chc.deferredCerts = x509Certs;
 458             } else {
 459                 // We&#39;re not doing stapling, so perform the check right now
 460                 checkServerCerts(chc, x509Certs);
 461             }
 462 
 463             //
 464             // update
 465             //
 466             chc.handshakeCredentials.add(
 467                 new X509Credentials(x509Certs[0].getPublicKey(), x509Certs));
 468             chc.handshakeSession.setPeerCertificates(x509Certs);
 469         }
 470 
 471         /*
 472          * Whether the certificates can represent the same identity?
 473          *
 474          * The certificates can be used to represent the same identity:
 475          *     1. If the subject alternative names of IP address are present
 476          *        in both certificates, they should be identical; otherwise,
 477          *     2. if the subject alternative names of DNS name are present in
 478          *        both certificates, they should be identical; otherwise,
 479          *     3. if the subject fields are present in both certificates, the
 480          *        certificate subjects and issuers should be identical.
 481          */
 482         private static boolean isIdentityEquivalent(X509Certificate thisCert,
 483                 X509Certificate prevCert) {
 484             if (thisCert.equals(prevCert)) {
 485                 return true;
 486             }
 487 
 488             // check subject alternative names
 489             Collection&lt;List&lt;?&gt;&gt; thisSubjectAltNames = null;
 490             try {
 491                 thisSubjectAltNames = thisCert.getSubjectAlternativeNames();
 492             } catch (CertificateParsingException cpe) {
 493                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 494                     SSLLogger.fine(
 495                         &quot;Attempt to obtain subjectAltNames extension failed!&quot;);
 496                 }
 497             }
 498 
 499             Collection&lt;List&lt;?&gt;&gt; prevSubjectAltNames = null;
 500             try {
 501                 prevSubjectAltNames = prevCert.getSubjectAlternativeNames();
 502             } catch (CertificateParsingException cpe) {
 503                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 504                     SSLLogger.fine(
 505                         &quot;Attempt to obtain subjectAltNames extension failed!&quot;);
 506                 }
 507             }
 508 
 509             if (thisSubjectAltNames != null &amp;&amp; prevSubjectAltNames != null) {
 510                 // check the iPAddress field in subjectAltName extension
 511                 //
 512                 // 7: subject alternative name of type IP.
 513                 Collection&lt;String&gt; thisSubAltIPAddrs =
 514                             getSubjectAltNames(thisSubjectAltNames, 7);
 515                 Collection&lt;String&gt; prevSubAltIPAddrs =
 516                             getSubjectAltNames(prevSubjectAltNames, 7);
 517                 if (thisSubAltIPAddrs != null &amp;&amp; prevSubAltIPAddrs != null &amp;&amp;
 518                     isEquivalent(thisSubAltIPAddrs, prevSubAltIPAddrs)) {
 519                     return true;
 520                 }
 521 
 522                 // check the dNSName field in subjectAltName extension
 523                 // 2: subject alternative name of type IP.
 524                 Collection&lt;String&gt; thisSubAltDnsNames =
 525                             getSubjectAltNames(thisSubjectAltNames, 2);
 526                 Collection&lt;String&gt; prevSubAltDnsNames =
 527                             getSubjectAltNames(prevSubjectAltNames, 2);
 528                 if (thisSubAltDnsNames != null &amp;&amp; prevSubAltDnsNames != null &amp;&amp;
 529                     isEquivalent(thisSubAltDnsNames, prevSubAltDnsNames)) {
 530                     return true;
 531                 }
 532             }
 533 
 534             // check the certificate subject and issuer
 535             X500Principal thisSubject = thisCert.getSubjectX500Principal();
 536             X500Principal prevSubject = prevCert.getSubjectX500Principal();
 537             X500Principal thisIssuer = thisCert.getIssuerX500Principal();
 538             X500Principal prevIssuer = prevCert.getIssuerX500Principal();
 539 
 540             return (!thisSubject.getName().isEmpty() &amp;&amp;
 541                     !prevSubject.getName().isEmpty() &amp;&amp;
 542                     thisSubject.equals(prevSubject) &amp;&amp;
 543                     thisIssuer.equals(prevIssuer));
 544         }
 545 
 546         /*
 547          * Returns the subject alternative name of the specified type in the
 548          * subjectAltNames extension of a certificate.
 549          *
 550          * Note that only those subjectAltName types that use String data
 551          * should be passed into this function.
 552          */
 553         private static Collection&lt;String&gt; getSubjectAltNames(
 554                 Collection&lt;List&lt;?&gt;&gt; subjectAltNames, int type) {
 555             HashSet&lt;String&gt; subAltDnsNames = null;
 556             for (List&lt;?&gt; subjectAltName : subjectAltNames) {
 557                 int subjectAltNameType = (Integer)subjectAltName.get(0);
 558                 if (subjectAltNameType == type) {
 559                     String subAltDnsName = (String)subjectAltName.get(1);
 560                     if ((subAltDnsName != null) &amp;&amp; !subAltDnsName.isEmpty()) {
 561                         if (subAltDnsNames == null) {
 562                             subAltDnsNames =
 563                                     new HashSet&lt;&gt;(subjectAltNames.size());
 564                         }
 565                         subAltDnsNames.add(subAltDnsName);
 566                     }
 567                 }
 568             }
 569 
 570             return subAltDnsNames;
 571         }
 572 
 573         private static boolean isEquivalent(Collection&lt;String&gt; thisSubAltNames,
 574                 Collection&lt;String&gt; prevSubAltNames) {
 575             for (String thisSubAltName : thisSubAltNames) {
 576                 for (String prevSubAltName : prevSubAltNames) {
 577                     // Only allow the exactly match.  No wildcard character
 578                     // checking.
 579                     if (thisSubAltName.equalsIgnoreCase(prevSubAltName)) {
 580                         return true;
 581                     }
 582                 }
 583             }
 584 
 585             return false;
 586         }
 587 
 588         /**
 589          * Perform client-side checking of server certificates.
 590          *
 591          * @param certs an array of {@code X509Certificate} objects presented
 592          *      by the server in the ServerCertificate message.
 593          *
 594          * @throws IOException if a failure occurs during validation or
 595          *      the trust manager associated with the {@code SSLContext} is not
 596          *      an {@code X509ExtendedTrustManager}.
 597          */
 598         static void checkServerCerts(ClientHandshakeContext chc,
 599                 X509Certificate[] certs) throws IOException {
 600 
 601             X509TrustManager tm = chc.sslContext.getX509TrustManager();
 602 
 603             // find out the key exchange algorithm used
 604             // use &quot;RSA&quot; for non-ephemeral &quot;RSA_EXPORT&quot;
 605             String keyExchangeString;
 606             if (chc.negotiatedCipherSuite.keyExchange ==
 607                     CipherSuite.KeyExchange.K_RSA_EXPORT ||
 608                     chc.negotiatedCipherSuite.keyExchange ==
 609                             CipherSuite.KeyExchange.K_DHE_RSA_EXPORT) {
 610                 keyExchangeString = CipherSuite.KeyExchange.K_RSA.name;
 611             } else {
 612                 keyExchangeString = chc.negotiatedCipherSuite.keyExchange.name;
 613             }
 614 
 615             try {
 616                 if (tm instanceof X509ExtendedTrustManager) {
 617                     if (chc.conContext.transport instanceof SSLEngine) {
 618                         SSLEngine engine = (SSLEngine)chc.conContext.transport;
 619                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
 620                             certs.clone(),
 621                             keyExchangeString,
 622                             engine);
 623                     } else {
 624                         SSLSocket socket = (SSLSocket)chc.conContext.transport;
 625                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
 626                             certs.clone(),
 627                             keyExchangeString,
 628                             socket);
 629                     }
 630                 } else {
 631                     // Unlikely to happen, because we have wrapped the old
 632                     // X509TrustManager with the new X509ExtendedTrustManager.
 633                     throw new CertificateException(
 634                             &quot;Improper X509TrustManager implementation&quot;);
 635                 }
 636 
 637                 // Once the server certificate chain has been validated, set
 638                 // the certificate chain in the TLS session.
 639                 chc.handshakeSession.setPeerCertificates(certs);
 640             } catch (CertificateException ce) {
 641                 throw chc.conContext.fatal(getCertificateAlert(chc, ce), ce);
 642             }
 643         }
 644 
 645         private static void checkClientCerts(ServerHandshakeContext shc,
 646                 X509Certificate[] certs) throws IOException {
 647             X509TrustManager tm = shc.sslContext.getX509TrustManager();
 648 
 649             // find out the types of client authentication used
 650             PublicKey key = certs[0].getPublicKey();
 651             String keyAlgorithm = key.getAlgorithm();
 652             String authType;
 653             switch (keyAlgorithm) {
 654                 case &quot;RSA&quot;:
 655                 case &quot;DSA&quot;:
 656                 case &quot;EC&quot;:
 657                 case &quot;RSASSA-PSS&quot;:
 658                     authType = keyAlgorithm;
 659                     break;
 660                 default:
 661                     // unknown public key type
 662                     authType = &quot;UNKNOWN&quot;;
 663             }
 664 
 665             try {
 666                 if (tm instanceof X509ExtendedTrustManager) {
 667                     if (shc.conContext.transport instanceof SSLEngine) {
 668                         SSLEngine engine = (SSLEngine)shc.conContext.transport;
 669                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
 670                             certs.clone(),
 671                             authType,
 672                             engine);
 673                     } else {
 674                         SSLSocket socket = (SSLSocket)shc.conContext.transport;
 675                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
 676                             certs.clone(),
 677                             authType,
 678                             socket);
 679                     }
 680                 } else {
 681                     // Unlikely to happen, because we have wrapped the old
 682                     // X509TrustManager with the new X509ExtendedTrustManager.
 683                     throw new CertificateException(
 684                             &quot;Improper X509TrustManager implementation&quot;);
 685                 }
 686             } catch (CertificateException ce) {
 687                 throw shc.conContext.fatal(Alert.CERTIFICATE_UNKNOWN, ce);
 688             }
 689         }
 690 
 691         /**
 692          * When a failure happens during certificate checking from an
 693          * {@link X509TrustManager}, determine what TLS alert description
 694          * to use.
 695          *
 696          * @param cexc The exception thrown by the {@link X509TrustManager}
 697          *
 698          * @return A byte value corresponding to a TLS alert description number.
 699          */
 700         private static Alert getCertificateAlert(
 701                 ClientHandshakeContext chc, CertificateException cexc) {
 702             // The specific reason for the failure will determine how to
 703             // set the alert description value
 704             Alert alert = Alert.CERTIFICATE_UNKNOWN;
 705 
 706             Throwable baseCause = cexc.getCause();
 707             if (baseCause instanceof CertPathValidatorException) {
 708                 CertPathValidatorException cpve =
 709                         (CertPathValidatorException)baseCause;
 710                 Reason reason = cpve.getReason();
 711                 if (reason == BasicReason.REVOKED) {
 712                     alert = chc.staplingActive ?
 713                             Alert.BAD_CERT_STATUS_RESPONSE :
 714                             Alert.CERTIFICATE_REVOKED;
 715                 } else if (
 716                         reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {
 717                     alert = chc.staplingActive ?
 718                             Alert.BAD_CERT_STATUS_RESPONSE :
 719                             Alert.CERTIFICATE_UNKNOWN;
 720                 } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {
 721                     alert = Alert.UNSUPPORTED_CERTIFICATE;
 722                 } else if (reason == BasicReason.EXPIRED) {
 723                     alert = Alert.CERTIFICATE_EXPIRED;
 724                 } else if (reason == BasicReason.INVALID_SIGNATURE ||
 725                         reason == BasicReason.NOT_YET_VALID) {
 726                     alert = Alert.BAD_CERTIFICATE;
 727                 }
 728             }
 729 
 730             return alert;
 731         }
 732 
 733     }
 734 
 735     /**
 736      * The certificate entry used in Certificate handshake message for TLS 1.3.
 737      */
 738     static final class CertificateEntry {
 739         final byte[] encoded;       // encoded cert or public key
 740         private final SSLExtensions extensions;
 741 
 742         CertificateEntry(byte[] encoded, SSLExtensions extensions) {
 743             this.encoded = encoded;
 744             this.extensions = extensions;
 745         }
 746 
 747         private int getEncodedSize() {
 748             int extLen = extensions.length();
 749             if (extLen == 0) {
 750                 extLen = 2;     // empty extensions
 751             }
 752             return 3 + encoded.length + extLen;
 753         }
 754 
 755         @Override
 756         public String toString() {
 757             MessageFormat messageFormat = new MessageFormat(
 758                 &quot;\n&#39;{&#39;\n&quot; +
 759                 &quot;{0}\n&quot; +                       // X.509 certificate
 760                 &quot;  \&quot;extensions\&quot;: &#39;{&#39;\n&quot; +
 761                 &quot;{1}\n&quot; +
 762                 &quot;  &#39;}&#39;\n&quot; +
 763                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
 764 
 765             Object x509Certs;
 766             try {
 767                 // Don&#39;t support certificate type extension (RawPublicKey) yet.
 768                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 769                 x509Certs =
 770                     cf.generateCertificate(new ByteArrayInputStream(encoded));
 771             } catch (CertificateException ce) {
 772                 // no X.509 certificate factory service
 773                 x509Certs = encoded;
 774             }
 775 
 776             Object[] messageFields = {
 777                 SSLLogger.toString(x509Certs),
 778                 Utilities.indent(extensions.toString(), &quot;    &quot;)
 779             };
 780 
 781             return messageFormat.format(messageFields);
 782         }
 783     }
 784 
 785     /**
 786      * The Certificate handshake message for TLS 1.3.
 787      */
 788     static final class T13CertificateMessage extends HandshakeMessage {
 789         private final byte[] requestContext;
 790         private final List&lt;CertificateEntry&gt; certEntries;
 791 
 792         T13CertificateMessage(HandshakeContext context,
 793                 byte[] requestContext, X509Certificate[] certificates)
 794                 throws SSLException, CertificateException  {
 795             super(context);
 796 
 797             this.requestContext = requestContext.clone();
 798             this.certEntries = new LinkedList&lt;&gt;();
 799             for (X509Certificate cert : certificates) {
 800                 byte[] encoded = cert.getEncoded();
 801                 SSLExtensions extensions = new SSLExtensions(this);
 802                 certEntries.add(new CertificateEntry(encoded, extensions));
 803             }
 804         }
 805 
 806         T13CertificateMessage(HandshakeContext handshakeContext,
 807                 byte[] requestContext, List&lt;CertificateEntry&gt; certificates) {
 808             super(handshakeContext);
 809 
 810             this.requestContext = requestContext.clone();
 811             this.certEntries = certificates;
 812         }
 813 
 814         T13CertificateMessage(HandshakeContext handshakeContext,
 815                 ByteBuffer m) throws IOException {
 816             super(handshakeContext);
 817 
 818             // struct {
 819             //      opaque certificate_request_context&lt;0..2^8-1&gt;;
 820             //      CertificateEntry certificate_list&lt;0..2^24-1&gt;;
 821             //  } Certificate;
 822             if (m.remaining() &lt; 4) {
 823                 throw new SSLProtocolException(
 824                         &quot;Invalid Certificate message: &quot; +
 825                         &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;);
 826             }
 827             this.requestContext = Record.getBytes8(m);
 828 
 829             if (m.remaining() &lt; 3) {
 830                 throw new SSLProtocolException(
 831                         &quot;Invalid Certificate message: &quot; +
 832                         &quot;insufficient certificate entries data (length=&quot; +
 833                         m.remaining() + &quot;)&quot;);
 834             }
 835 
 836             int listLen = Record.getInt24(m);
 837             if (listLen != m.remaining()) {
 838                 throw new SSLProtocolException(
 839                     &quot;Invalid Certificate message: &quot; +
 840                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;);
 841             }
 842 
 843             SSLExtension[] enabledExtensions =
 844                 handshakeContext.sslConfig.getEnabledExtensions(
 845                         SSLHandshake.CERTIFICATE);
 846             List&lt;CertificateEntry&gt; certList = new LinkedList&lt;&gt;();
 847             while (m.hasRemaining()) {
 848                 // Note: support only X509 CertificateType right now.
 849                 byte[] encodedCert = Record.getBytes24(m);
 850                 if (encodedCert.length == 0) {
 851                     throw new SSLProtocolException(
 852                         &quot;Invalid Certificate message: empty cert_data&quot;);
 853                 }
 854 
 855                 SSLExtensions extensions =
 856                         new SSLExtensions(this, m, enabledExtensions);
 857                 certList.add(new CertificateEntry(encodedCert, extensions));
 858             }
 859 
 860             this.certEntries = Collections.unmodifiableList(certList);
 861         }
 862 
 863         @Override
 864         public SSLHandshake handshakeType() {
 865             return SSLHandshake.CERTIFICATE;
 866         }
 867 
 868         @Override
 869         public int messageLength() {
 870             int msgLen = 4 + requestContext.length;
 871             for (CertificateEntry entry : certEntries) {
 872                 msgLen += entry.getEncodedSize();
 873             }
 874 
 875             return msgLen;
 876         }
 877 
 878         @Override
 879         public void send(HandshakeOutStream hos) throws IOException {
 880             int entryListLen = 0;
 881             for (CertificateEntry entry : certEntries) {
 882                 entryListLen += entry.getEncodedSize();
 883             }
 884 
 885             hos.putBytes8(requestContext);
 886             hos.putInt24(entryListLen);
 887             for (CertificateEntry entry : certEntries) {
 888                 hos.putBytes24(entry.encoded);
 889                 // Is it an empty extensions?
 890                 if (entry.extensions.length() == 0) {
 891                     hos.putInt16(0);
 892                 } else {
 893                     entry.extensions.send(hos);
 894                 }
 895             }
 896         }
 897 
 898         @Override
 899         public String toString() {
 900             MessageFormat messageFormat = new MessageFormat(
 901                 &quot;\&quot;Certificate\&quot;: &#39;{&#39;\n&quot; +
 902                 &quot;  \&quot;certificate_request_context\&quot;: \&quot;{0}\&quot;,\n&quot; +
 903                 &quot;  \&quot;certificate_list\&quot;: [{1}\n]\n&quot; +
 904                 &quot;&#39;}&#39;&quot;,
 905                 Locale.ENGLISH);
 906 
 907             StringBuilder builder = new StringBuilder(512);
 908             for (CertificateEntry entry : certEntries) {
 909                 builder.append(entry.toString());
 910             }
 911 
 912             Object[] messageFields = {
 913                 Utilities.toHexString(requestContext),
 914                 Utilities.indent(builder.toString())
 915             };
 916 
 917             return messageFormat.format(messageFields);
 918         }
 919     }
 920 
 921     /**
 922      * The &quot;Certificate&quot; handshake message producer for TLS 1.3.
 923      */
 924     private static final
 925             class T13CertificateProducer implements HandshakeProducer {
 926         // Prevent instantiation of this class.
 927         private T13CertificateProducer() {
 928             // blank
 929         }
 930 
 931         @Override
 932         public byte[] produce(ConnectionContext context,
 933                 HandshakeMessage message) throws IOException {
 934             // The producing happens in handshake context only.
 935             HandshakeContext hc = (HandshakeContext)context;
 936             if (hc.sslConfig.isClientMode) {
 937                 return onProduceCertificate(
 938                         (ClientHandshakeContext)context, message);
 939             } else {
 940                 return onProduceCertificate(
 941                         (ServerHandshakeContext)context, message);
 942             }
 943         }
 944 
 945         private byte[] onProduceCertificate(ServerHandshakeContext shc,
 946                 HandshakeMessage message) throws IOException {
 947             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 948 
 949             SSLPossession pos = choosePossession(shc, clientHello);
 950             if (pos == null) {
 951                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 952                         &quot;No available authentication scheme&quot;);
 953             }
 954 
 955             if (!(pos instanceof X509Possession)) {
 956                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 957                         &quot;No X.509 certificate for server authentication&quot;);
 958             }
 959 
 960             X509Possession x509Possession = (X509Possession)pos;
 961             X509Certificate[] localCerts = x509Possession.popCerts;
 962             if (localCerts == null || localCerts.length == 0) {
 963                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 964                         &quot;No X.509 certificate for server authentication&quot;);
 965             }
 966 
 967             // update the context
 968             shc.handshakePossessions.add(x509Possession);
 969             shc.handshakeSession.setLocalPrivateKey(
 970                     x509Possession.popPrivateKey);
 971             shc.handshakeSession.setLocalCertificates(localCerts);
 972             T13CertificateMessage cm;
 973             try {
 974                 cm = new T13CertificateMessage(shc, (new byte[0]), localCerts);
 975             } catch (SSLException | CertificateException ce) {
 976                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 977                         &quot;Failed to produce server Certificate message&quot;, ce);
 978             }
 979 
 980             // Check the OCSP stapling extensions and attempt
 981             // to get responses.  If the resulting stapleParams is non
 982             // null, it implies that stapling is enabled on the server side.
 983             shc.stapleParams = StatusResponseManager.processStapling(shc);
 984             shc.staplingActive = (shc.stapleParams != null);
 985 
 986             // Process extensions for each CertificateEntry.
 987             // Since there can be multiple CertificateEntries within a
 988             // single CT message, we will pin a specific CertificateEntry
 989             // into the ServerHandshakeContext so individual extension
 990             // producers know which X509Certificate it is processing in
 991             // each call.
 992             SSLExtension[] enabledCTExts = shc.sslConfig.getEnabledExtensions(
 993                     SSLHandshake.CERTIFICATE,
 994                     Arrays.asList(ProtocolVersion.PROTOCOLS_OF_13));
 995             for (CertificateEntry certEnt : cm.certEntries) {
 996                 shc.currentCertEntry = certEnt;
 997                 certEnt.extensions.produce(shc, enabledCTExts);
 998             }
 999 
1000             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1001                 SSLLogger.fine(&quot;Produced server Certificate message&quot;, cm);
1002             }
1003 
1004             // Output the handshake message.
1005             cm.write(shc.handshakeOutput);
1006             shc.handshakeOutput.flush();
1007 
1008             // The handshake message has been delivered.
1009             return null;
1010         }
1011 
1012         private static SSLPossession choosePossession(
1013                 HandshakeContext hc,
1014                 ClientHelloMessage clientHello) throws IOException {
1015             if (hc.peerRequestedCertSignSchemes == null ||
1016                     hc.peerRequestedCertSignSchemes.isEmpty()) {
1017                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1018                     SSLLogger.warning(
1019                             &quot;No signature_algorithms(_cert) in ClientHello&quot;);
1020                 }
1021                 return null;
1022             }
1023 
1024             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
1025             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
1026                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
1027                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1028                         SSLLogger.warning(
1029                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1030                     }
1031                     continue;
1032                 }
1033 
1034                 // Don&#39;t select a signature scheme unless we will be able to
1035                 // produce a CertificateVerify message later
1036                 if (SignatureScheme.getPreferableAlgorithm(
<a name="2" id="anc2"></a>
1037                         hc.peerRequestedSignatureSchemes,
1038                         ss, hc.negotiatedProtocol) == null) {
1039 
1040                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1041                         SSLLogger.warning(
1042                             &quot;Unable to produce CertificateVerify for &quot; +
1043                             &quot;signature scheme: &quot; + ss.name);
1044                     }
1045                     checkedKeyTypes.add(ss.keyAlgorithm);
1046                     continue;
1047                 }
1048 
1049                 SSLAuthentication ka = X509Authentication.valueOf(ss);
1050                 if (ka == null) {
1051                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1052                         SSLLogger.warning(
1053                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1054                     }
1055                     checkedKeyTypes.add(ss.keyAlgorithm);
1056                     continue;
1057                 }
1058 
1059                 SSLPossession pos = ka.createPossession(hc);
1060                 if (pos == null) {
1061                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1062                         SSLLogger.warning(
1063                             &quot;Unavailable authentication scheme: &quot; + ss.name);
1064                     }
1065                     continue;
1066                 }
1067 
1068                 return pos;
1069             }
1070 
1071             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1072                 SSLLogger.warning(&quot;No available authentication scheme&quot;);
1073             }
1074             return null;
1075         }
1076 
1077         private byte[] onProduceCertificate(ClientHandshakeContext chc,
1078                 HandshakeMessage message) throws IOException {
1079             ClientHelloMessage clientHello = (ClientHelloMessage)message;
1080             SSLPossession pos = choosePossession(chc, clientHello);
1081             X509Certificate[] localCerts;
1082             if (pos == null) {
1083                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1084                     SSLLogger.fine(&quot;No available client authentication scheme&quot;);
1085                 }
1086                 localCerts = new X509Certificate[0];
1087             } else {
1088                 chc.handshakePossessions.add(pos);
1089                 if (!(pos instanceof X509Possession)) {
1090                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1091                         SSLLogger.fine(
1092                             &quot;No X.509 certificate for client authentication&quot;);
1093                     }
1094                     localCerts = new X509Certificate[0];
1095                 } else {
1096                     X509Possession x509Possession = (X509Possession)pos;
1097                     localCerts = x509Possession.popCerts;
1098                     chc.handshakeSession.setLocalPrivateKey(
1099                             x509Possession.popPrivateKey);
1100                 }
1101             }
1102 
1103             if (localCerts != null &amp;&amp; localCerts.length != 0) {
1104                 chc.handshakeSession.setLocalCertificates(localCerts);
1105             } else {
1106                 chc.handshakeSession.setLocalCertificates(null);
1107             }
1108 
1109             T13CertificateMessage cm;
1110             try {
1111                 cm = new T13CertificateMessage(
1112                         chc, chc.certRequestContext, localCerts);
1113             } catch (SSLException | CertificateException ce) {
1114                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1115                         &quot;Failed to produce client Certificate message&quot;, ce);
1116             }
1117             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1118                 SSLLogger.fine(&quot;Produced client Certificate message&quot;, cm);
1119             }
1120 
1121             // Output the handshake message.
1122             cm.write(chc.handshakeOutput);
1123             chc.handshakeOutput.flush();
1124 
1125             // The handshake message has been delivered.
1126             return null;
1127         }
1128     }
1129 
1130     /**
1131      * The &quot;Certificate&quot; handshake message consumer for TLS 1.3.
1132      */
1133     private static final class T13CertificateConsumer implements SSLConsumer {
1134         // Prevent instantiation of this class.
1135         private T13CertificateConsumer() {
1136             // blank
1137         }
1138 
1139         @Override
1140         public void consume(ConnectionContext context,
1141                 ByteBuffer message) throws IOException {
1142             // The consuming happens in handshake context only.
1143             HandshakeContext hc = (HandshakeContext)context;
1144 
1145             // clean up this consumer
1146             hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE.id);
1147             T13CertificateMessage cm = new T13CertificateMessage(hc, message);
1148             if (hc.sslConfig.isClientMode) {
1149                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1150                     SSLLogger.fine(
1151                         &quot;Consuming server Certificate handshake message&quot;, cm);
1152                 }
1153                 onConsumeCertificate((ClientHandshakeContext)context, cm);
1154             } else {
1155                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1156                     SSLLogger.fine(
1157                         &quot;Consuming client Certificate handshake message&quot;, cm);
1158                 }
1159                 onConsumeCertificate((ServerHandshakeContext)context, cm);
1160             }
1161         }
1162 
1163         private void onConsumeCertificate(ServerHandshakeContext shc,
1164                 T13CertificateMessage certificateMessage )throws IOException {
1165             if (certificateMessage.certEntries == null ||
1166                     certificateMessage.certEntries.isEmpty()) {
<a name="3" id="anc3"></a>



1167                 if (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED) {
1168                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1169                         &quot;Empty client certificate chain&quot;);
1170                 } else {
1171                     // optional client authentication
1172                     return;
1173                 }
1174             }
1175 
1176             // check client certificate entries
1177             X509Certificate[] cliCerts =
1178                     checkClientCerts(shc, certificateMessage.certEntries);
1179 
1180             //
1181             // update
1182             //
1183             shc.handshakeCredentials.add(
1184                 new X509Credentials(cliCerts[0].getPublicKey(), cliCerts));
1185             shc.handshakeSession.setPeerCertificates(cliCerts);
1186         }
1187 
1188         private void onConsumeCertificate(ClientHandshakeContext chc,
1189                 T13CertificateMessage certificateMessage )throws IOException {
1190             if (certificateMessage.certEntries == null ||
1191                     certificateMessage.certEntries.isEmpty()) {
1192                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
1193                     &quot;Empty server certificate chain&quot;);
1194             }
1195 
1196             // Each CertificateEntry will have its own set of extensions
1197             // which must be consumed.
1198             SSLExtension[] enabledExtensions =
1199                 chc.sslConfig.getEnabledExtensions(SSLHandshake.CERTIFICATE);
1200             for (CertificateEntry certEnt : certificateMessage.certEntries) {
1201                 certEnt.extensions.consumeOnLoad(chc, enabledExtensions);
1202             }
1203 
1204             // check server certificate entries
1205             X509Certificate[] srvCerts =
1206                     checkServerCerts(chc, certificateMessage.certEntries);
1207 
1208             //
1209             // update
1210             //
1211             chc.handshakeCredentials.add(
1212                 new X509Credentials(srvCerts[0].getPublicKey(), srvCerts));
1213             chc.handshakeSession.setPeerCertificates(srvCerts);
1214         }
1215 
1216         private static X509Certificate[] checkClientCerts(
1217                 ServerHandshakeContext shc,
1218                 List&lt;CertificateEntry&gt; certEntries) throws IOException {
1219             X509Certificate[] certs =
1220                     new X509Certificate[certEntries.size()];
1221             try {
1222                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1223                 int i = 0;
1224                 for (CertificateEntry entry : certEntries) {
1225                     certs[i++] = (X509Certificate)cf.generateCertificate(
1226                                     new ByteArrayInputStream(entry.encoded));
1227                 }
1228             } catch (CertificateException ce) {
1229                 throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1230                     &quot;Failed to parse server certificates&quot;, ce);
1231             }
1232 
1233             // find out the types of client authentication used
1234             String keyAlgorithm = certs[0].getPublicKey().getAlgorithm();
1235             String authType;
1236             switch (keyAlgorithm) {
1237                 case &quot;RSA&quot;:
1238                 case &quot;DSA&quot;:
1239                 case &quot;EC&quot;:
1240                 case &quot;RSASSA-PSS&quot;:
1241                     authType = keyAlgorithm;
1242                     break;
1243                 default:
1244                     // unknown public key type
1245                     authType = &quot;UNKNOWN&quot;;
1246             }
1247 
1248             try {
1249                 X509TrustManager tm = shc.sslContext.getX509TrustManager();
1250                 if (tm instanceof X509ExtendedTrustManager) {
1251                     if (shc.conContext.transport instanceof SSLEngine) {
1252                         SSLEngine engine = (SSLEngine)shc.conContext.transport;
1253                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
1254                             certs.clone(),
1255                             authType,
1256                             engine);
1257                     } else {
1258                         SSLSocket socket = (SSLSocket)shc.conContext.transport;
1259                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
1260                             certs.clone(),
1261                             authType,
1262                             socket);
1263                     }
1264                 } else {
1265                     // Unlikely to happen, because we have wrapped the old
1266                     // X509TrustManager with the new X509ExtendedTrustManager.
1267                     throw new CertificateException(
1268                             &quot;Improper X509TrustManager implementation&quot;);
1269                 }
1270 
1271                 // Once the client certificate chain has been validated, set
1272                 // the certificate chain in the TLS session.
1273                 shc.handshakeSession.setPeerCertificates(certs);
1274             } catch (CertificateException ce) {
1275                 throw shc.conContext.fatal(Alert.CERTIFICATE_UNKNOWN, ce);
1276             }
1277 
1278             return certs;
1279         }
1280 
1281         private static X509Certificate[] checkServerCerts(
1282                 ClientHandshakeContext chc,
1283                 List&lt;CertificateEntry&gt; certEntries) throws IOException {
1284             X509Certificate[] certs =
1285                     new X509Certificate[certEntries.size()];
1286             try {
1287                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1288                 int i = 0;
1289                 for (CertificateEntry entry : certEntries) {
1290                     certs[i++] = (X509Certificate)cf.generateCertificate(
1291                                     new ByteArrayInputStream(entry.encoded));
1292                 }
1293             } catch (CertificateException ce) {
1294                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
1295                     &quot;Failed to parse server certificates&quot;, ce);
1296             }
1297 
1298             // find out the types of server authentication used
1299             //
1300             // Note that the &quot;UNKNOWN&quot; authentication type is sufficient to
1301             // check the required digitalSignature KeyUsage for TLS 1.3.
1302             String authType = &quot;UNKNOWN&quot;;
1303 
1304             try {
1305                 X509TrustManager tm = chc.sslContext.getX509TrustManager();
1306                 if (tm instanceof X509ExtendedTrustManager) {
1307                     if (chc.conContext.transport instanceof SSLEngine) {
1308                         SSLEngine engine = (SSLEngine)chc.conContext.transport;
1309                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
1310                             certs.clone(),
1311                             authType,
1312                             engine);
1313                     } else {
1314                         SSLSocket socket = (SSLSocket)chc.conContext.transport;
1315                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
1316                             certs.clone(),
1317                             authType,
1318                             socket);
1319                     }
1320                 } else {
1321                     // Unlikely to happen, because we have wrapped the old
1322                     // X509TrustManager with the new X509ExtendedTrustManager.
1323                     throw new CertificateException(
1324                             &quot;Improper X509TrustManager implementation&quot;);
1325                 }
1326 
1327                 // Once the server certificate chain has been validated, set
1328                 // the certificate chain in the TLS session.
1329                 chc.handshakeSession.setPeerCertificates(certs);
1330             } catch (CertificateException ce) {
1331                 throw chc.conContext.fatal(getCertificateAlert(chc, ce), ce);
1332             }
1333 
1334             return certs;
1335         }
1336 
1337         /**
1338          * When a failure happens during certificate checking from an
1339          * {@link X509TrustManager}, determine what TLS alert description
1340          * to use.
1341          *
1342          * @param cexc The exception thrown by the {@link X509TrustManager}
1343          *
1344          * @return A byte value corresponding to a TLS alert description number.
1345          */
1346         private static Alert getCertificateAlert(
1347                 ClientHandshakeContext chc, CertificateException cexc) {
1348             // The specific reason for the failure will determine how to
1349             // set the alert description value
1350             Alert alert = Alert.CERTIFICATE_UNKNOWN;
1351 
1352             Throwable baseCause = cexc.getCause();
1353             if (baseCause instanceof CertPathValidatorException) {
1354                 CertPathValidatorException cpve =
1355                         (CertPathValidatorException)baseCause;
1356                 Reason reason = cpve.getReason();
1357                 if (reason == BasicReason.REVOKED) {
1358                     alert = chc.staplingActive ?
1359                             Alert.BAD_CERT_STATUS_RESPONSE :
1360                             Alert.CERTIFICATE_REVOKED;
1361                 } else if (
1362                         reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {
1363                     alert = chc.staplingActive ?
1364                             Alert.BAD_CERT_STATUS_RESPONSE :
1365                             Alert.CERTIFICATE_UNKNOWN;
1366                 }
1367             }
1368 
1369             return alert;
1370         }
1371     }
1372 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
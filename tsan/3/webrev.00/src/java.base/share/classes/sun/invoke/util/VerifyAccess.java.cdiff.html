<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/invoke/util/VerifyAccess.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeDescriptor.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../launcher/LauncherHelper.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/invoke/util/VerifyAccess.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 86,31 ***</span>
       *
       * @param refc the class used in the symbolic reference to the proposed member
       * @param defc the class in which the proposed member is actually defined
       * @param mods modifier flags for the proposed member
       * @param lookupClass the class for which the access check is being made
       * @return true iff the accessing class can access such a member
       */
      public static boolean isMemberAccessible(Class&lt;?&gt; refc,  // symbolic ref class
                                               Class&lt;?&gt; defc,  // actual def class
                                               int      mods,  // actual member mods
                                               Class&lt;?&gt; lookupClass,
                                               int      allowedModes) {
          if (allowedModes == 0)  return false;
<span class="line-modified">!         assert((allowedModes &amp; PUBLIC) != 0 &amp;&amp;</span>
<span class="line-removed">-                (allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>
          // The symbolic reference class (refc) must always be fully verified.
<span class="line-modified">!         if (!isClassAccessible(refc, lookupClass, allowedModes)) {</span>
              return false;
          }
          // Usually refc and defc are the same, but verify defc also in case they differ.
          if (defc == lookupClass  &amp;&amp;
              (allowedModes &amp; PRIVATE) != 0)
              return true;        // easy check; all self-access is OK with a private lookup
  
          switch (mods &amp; ALL_ACCESS_MODES) {
          case PUBLIC:
              return true;  // already checked above
          case PROTECTED:
              assert !defc.isInterface(); // protected members aren&#39;t allowed in interfaces
              if ((allowedModes &amp; PROTECTED_OR_PACKAGE_ALLOWED) != 0 &amp;&amp;
                  isSamePackage(defc, lookupClass))
<span class="line-new-header">--- 86,34 ---</span>
       *
       * @param refc the class used in the symbolic reference to the proposed member
       * @param defc the class in which the proposed member is actually defined
       * @param mods modifier flags for the proposed member
       * @param lookupClass the class for which the access check is being made
<span class="line-added">+      * @param prevLookupClass the class for which the access check is being made</span>
<span class="line-added">+      * @param allowedModes allowed modes</span>
       * @return true iff the accessing class can access such a member
       */
      public static boolean isMemberAccessible(Class&lt;?&gt; refc,  // symbolic ref class
                                               Class&lt;?&gt; defc,  // actual def class
                                               int      mods,  // actual member mods
                                               Class&lt;?&gt; lookupClass,
<span class="line-added">+                                              Class&lt;?&gt; prevLookupClass,</span>
                                               int      allowedModes) {
          if (allowedModes == 0)  return false;
<span class="line-modified">!         assert((allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>
          // The symbolic reference class (refc) must always be fully verified.
<span class="line-modified">!         if (!isClassAccessible(refc, lookupClass, prevLookupClass, allowedModes)) {</span>
              return false;
          }
          // Usually refc and defc are the same, but verify defc also in case they differ.
          if (defc == lookupClass  &amp;&amp;
              (allowedModes &amp; PRIVATE) != 0)
              return true;        // easy check; all self-access is OK with a private lookup
  
          switch (mods &amp; ALL_ACCESS_MODES) {
          case PUBLIC:
<span class="line-added">+             assert (allowedModes &amp; PUBLIC) != 0 || (allowedModes &amp; UNCONDITIONAL_ALLOWED) != 0;</span>
              return true;  // already checked above
          case PROTECTED:
              assert !defc.isInterface(); // protected members aren&#39;t allowed in interfaces
              if ((allowedModes &amp; PROTECTED_OR_PACKAGE_ALLOWED) != 0 &amp;&amp;
                  isSamePackage(defc, lookupClass))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,18 ***</span>
       * &lt;li&gt;C is public and in the same module as D.
       * &lt;li&gt;D is in a module that reads the module containing C, C is public and in a
       * package that is exported to the module that contains D.
       * &lt;li&gt;C and D are members of the same runtime package.
       * &lt;/ul&gt;
       * @param refc the symbolic reference class to which access is being checked (C)
       * @param lookupClass the class performing the lookup (D)
       */
<span class="line-modified">!     public static boolean isClassAccessible(Class&lt;?&gt; refc, Class&lt;?&gt; lookupClass,</span>
                                              int allowedModes) {
          if (allowedModes == 0)  return false;
<span class="line-modified">!         assert((allowedModes &amp; PUBLIC) != 0 &amp;&amp;</span>
<span class="line-modified">!                (allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>
          int mods = getClassModifiers(refc);
          if (isPublic(mods)) {
  
              Module lookupModule = lookupClass.getModule();
              Module refModule = refc.getModule();
<span class="line-new-header">--- 176,27 ---</span>
       * &lt;li&gt;C is public and in the same module as D.
       * &lt;li&gt;D is in a module that reads the module containing C, C is public and in a
       * package that is exported to the module that contains D.
       * &lt;li&gt;C and D are members of the same runtime package.
       * &lt;/ul&gt;
<span class="line-added">+      *</span>
       * @param refc the symbolic reference class to which access is being checked (C)
       * @param lookupClass the class performing the lookup (D)
<span class="line-added">+      * @param prevLookupClass the class from which the lookup was teleported or null</span>
<span class="line-added">+      * @param allowedModes allowed modes</span>
       */
<span class="line-modified">!     public static boolean isClassAccessible(Class&lt;?&gt; refc,</span>
<span class="line-added">+                                             Class&lt;?&gt; lookupClass,</span>
<span class="line-added">+                                             Class&lt;?&gt; prevLookupClass,</span>
                                              int allowedModes) {
          if (allowedModes == 0)  return false;
<span class="line-modified">!         assert((allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>
<span class="line-modified">! </span>
<span class="line-added">+         if ((allowedModes &amp; PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="line-added">+             isSamePackage(lookupClass, refc))</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ </span>
          int mods = getClassModifiers(refc);
          if (isPublic(mods)) {
  
              Module lookupModule = lookupClass.getModule();
              Module refModule = refc.getModule();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,41 ***</span>
              if (lookupModule == null) {
                  assert refModule == null;
                  return true;
              }
  
<span class="line-modified">!             // trivially allow</span>
<span class="line-modified">!             if ((allowedModes &amp; MODULE_ALLOWED) != 0 &amp;&amp;</span>
<span class="line-modified">!                 (lookupModule == refModule))</span>
<span class="line-modified">!                 return true;</span>
  
<span class="line-modified">!             // check readability when UNCONDITIONAL not allowed</span>
<span class="line-modified">!             if (((allowedModes &amp; UNCONDITIONAL_ALLOWED) != 0)</span>
<span class="line-modified">!                 || lookupModule.canRead(refModule)) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // check that refc is in an exported package</span>
<span class="line-removed">-                 if ((allowedModes &amp; MODULE_ALLOWED) != 0) {</span>
<span class="line-removed">-                     if (refModule.isExported(refc.getPackageName(), lookupModule))</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     // exported unconditionally</span>
<span class="line-removed">-                     if (refModule.isExported(refc.getPackageName()))</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // not exported but allow access during VM initialization</span>
<span class="line-removed">-                 // because java.base does not have its exports setup</span>
<span class="line-removed">-                 if (!jdk.internal.misc.VM.isModuleSystemInited())</span>
                      return true;
              }
  
              // public class not accessible to lookupClass
              return false;
          }
<span class="line-modified">!         if ((allowedModes &amp; PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="line-modified">!             isSamePackage(lookupClass, refc))</span>
<span class="line-modified">!             return true;</span>
          return false;
      }
  
      /**
       * Decide if the given method type, attributed to a member or symbolic
<span class="line-new-header">--- 205,66 ---</span>
              if (lookupModule == null) {
                  assert refModule == null;
                  return true;
              }
  
<span class="line-modified">!             // allow access to public types in all unconditionally exported packages</span>
<span class="line-modified">!             if ((allowedModes &amp; UNCONDITIONAL_ALLOWED) != 0) {</span>
<span class="line-modified">!                 return refModule.isExported(refc.getPackageName());</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             if (lookupModule == refModule &amp;&amp; prevLookupClass == null) {</span>
<span class="line-modified">!                 // allow access to all public types in lookupModule</span>
<span class="line-modified">!                 if ((allowedModes &amp; MODULE_ALLOWED) != 0)</span>
                      return true;
<span class="line-added">+ </span>
<span class="line-added">+                 assert (allowedModes &amp; PUBLIC) != 0;</span>
<span class="line-added">+                 return refModule.isExported(refc.getPackageName());</span>
              }
  
<span class="line-added">+             // cross-module access</span>
<span class="line-added">+             // 1. refc is in different module from lookupModule, or</span>
<span class="line-added">+             // 2. refc is in lookupModule and a different module from prevLookupModule</span>
<span class="line-added">+             Module prevLookupModule = prevLookupClass != null ? prevLookupClass.getModule()</span>
<span class="line-added">+                                                               : null;</span>
<span class="line-added">+             assert refModule != lookupModule || refModule != prevLookupModule;</span>
<span class="line-added">+             if (isModuleAccessible(refc, lookupModule, prevLookupModule))</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // not exported but allow access during VM initialization</span>
<span class="line-added">+             // because java.base does not have its exports setup</span>
<span class="line-added">+             if (!jdk.internal.misc.VM.isModuleSystemInited())</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+ </span>
              // public class not accessible to lookupClass
              return false;
          }
<span class="line-modified">! </span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * Tests if a class or interface REFC is accessible to m1 and m2 where m2</span>
<span class="line-added">+      * may be null.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * A class or interface REFC in m is accessible to m1 and m2 if and only if</span>
<span class="line-added">+      * both m1 and m2 read m and m exports the package of REFC at least to</span>
<span class="line-added">+      * both m1 and m2.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static boolean isModuleAccessible(Class&lt;?&gt; refc,  Module m1, Module m2) {</span>
<span class="line-added">+         Module refModule = refc.getModule();</span>
<span class="line-added">+         assert refModule != m1 || refModule != m2;</span>
<span class="line-added">+         int mods = getClassModifiers(refc);</span>
<span class="line-added">+         if (isPublic(mods)) {</span>
<span class="line-added">+             if (m1.canRead(refModule) &amp;&amp; (m2 == null || m2.canRead(refModule))) {</span>
<span class="line-added">+                 String pn = refc.getPackageName();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // refc is exported package to at least both m1 and m2</span>
<span class="line-added">+                 if (refModule.isExported(pn, m1) &amp;&amp; (m2 == null || refModule.isExported(pn, m2)))</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          return false;
      }
  
      /**
       * Decide if the given method type, attributed to a member or symbolic
</pre>
<center><a href="BytecodeDescriptor.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../launcher/LauncherHelper.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
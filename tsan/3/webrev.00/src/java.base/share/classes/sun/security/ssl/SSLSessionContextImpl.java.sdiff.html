<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSessionContextImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLServerSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSessionImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSessionContextImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.Enumeration;
 31 import java.util.Locale;
 32 import javax.net.ssl.SSLSession;
 33 import javax.net.ssl.SSLSessionContext;
 34 
 35 import sun.security.action.GetIntegerAction;

 36 import sun.security.util.Cache;
 37 
 38 




















 39 final class SSLSessionContextImpl implements SSLSessionContext {
 40     private final static int DEFAULT_MAX_CACHE_SIZE = 20480;


 41 
 42     private final Cache&lt;SessionId, SSLSessionImpl&gt; sessionCache;
 43                                         // session cache, session id as key
 44     private final Cache&lt;String, SSLSessionImpl&gt; sessionHostPortCache;
 45                                         // session cache, &quot;host:port&quot; as key
 46     private int cacheLimit;             // the max cache size
 47     private int timeout;                // timeout in seconds
 48 



 49     // package private
<span class="line-modified"> 50     SSLSessionContextImpl() {</span>
<span class="line-modified"> 51         cacheLimit = getDefaultCacheLimit();    // default cache size</span>
<span class="line-modified"> 52         timeout = 86400;                        // default, 24 hours</span>
 53 
 54         // use soft reference
 55         sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);
 56         sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);
 57     }
 58 





 59     /**
 60      * Returns the &lt;code&gt;SSLSession&lt;/code&gt; bound to the specified session id.
 61      */
 62     @Override
 63     public SSLSession getSession(byte[] sessionId) {
 64         if (sessionId == null) {
 65             throw new NullPointerException(&quot;session id cannot be null&quot;);
 66         }
 67 
 68         SSLSessionImpl sess = sessionCache.get(new SessionId(sessionId));
 69         if (!isTimedout(sess)) {
 70             return sess;
 71         }
 72 
 73         return null;
 74     }
 75 
 76     /**
 77      * Returns an enumeration of the active SSL sessions.
 78      */
</pre>
<hr />
<pre>
146 
147     // package-private method, used ONLY by ClientHandshaker
148     SSLSessionImpl get(String hostname, int port) {
149         /*
150          * If no session caching info is available, we won&#39;t
151          * get one, so exit before doing a lookup.
152          */
153         if (hostname == null &amp;&amp; port == -1) {
154             return null;
155         }
156 
157         SSLSessionImpl sess = sessionHostPortCache.get(getKey(hostname, port));
158         if (!isTimedout(sess)) {
159             return sess;
160         }
161 
162         return null;
163     }
164 
165     private static String getKey(String hostname, int port) {
<span class="line-modified">166         return (hostname + &quot;:&quot; +</span>
<span class="line-removed">167             String.valueOf(port)).toLowerCase(Locale.ENGLISH);</span>
168     }
169 
170     // cache a SSLSession
171     //
172     // In SunJSSE implementation, a session is created while getting a
173     // client hello or a server hello message, and cached while the
174     // handshaking finished.
175     // Here we time the session from the time it cached instead of the
176     // time it created, which is a little longer than the expected. So
177     // please do check isTimedout() while getting entry from the cache.
178     void put(SSLSessionImpl s) {
179         sessionCache.put(s.getSessionId(), s);
180 
181         // If no hostname/port info is available, don&#39;t add this one.
182         if ((s.getPeerHost() != null) &amp;&amp; (s.getPeerPort() != -1)) {
183             sessionHostPortCache.put(
184                 getKey(s.getPeerHost(), s.getPeerPort()), s);
185         }
186 
187         s.setContext(this);
188     }
189 
190     // package-private method, remove a cached SSLSession
191     void remove(SessionId key) {
192         SSLSessionImpl s = sessionCache.get(key);
193         if (s != null) {
194             sessionCache.remove(key);
195             sessionHostPortCache.remove(
196                     getKey(s.getPeerHost(), s.getPeerPort()));
197         }
198     }
199 
<span class="line-modified">200     private static int getDefaultCacheLimit() {</span>
201         try {












































202             int defaultCacheLimit = GetIntegerAction.privilegedGetProperty(
203                     &quot;javax.net.ssl.sessionCacheSize&quot;, DEFAULT_MAX_CACHE_SIZE);
204 
205             if (defaultCacheLimit &gt;= 0) {
206                 return defaultCacheLimit;
207             } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
208                 SSLLogger.warning(
209                     &quot;invalid System Property javax.net.ssl.sessionCacheSize, &quot; +
210                     &quot;use the default session cache size (&quot; +
211                     DEFAULT_MAX_CACHE_SIZE + &quot;) instead&quot;);
212             }
213         } catch (Exception e) {
214             // unlikely, log it for safe
215             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
216                 SSLLogger.warning(
217                     &quot;the System Property javax.net.ssl.sessionCacheSize is &quot; +
218                     &quot;not available, use the default value (&quot; +
219                     DEFAULT_MAX_CACHE_SIZE + &quot;) instead&quot;);
220             }
221         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.Enumeration;
 31 import java.util.Locale;
 32 import javax.net.ssl.SSLSession;
 33 import javax.net.ssl.SSLSessionContext;
 34 
 35 import sun.security.action.GetIntegerAction;
<span class="line-added"> 36 import sun.security.action.GetPropertyAction;</span>
 37 import sun.security.util.Cache;
 38 
 39 
<span class="line-added"> 40 /**</span>
<span class="line-added"> 41  * @systemProperty jdk.tls.server.enableSessionTicketExtension} determines if the</span>
<span class="line-added"> 42  * server will provide stateless session tickets, if the client supports it,</span>
<span class="line-added"> 43  * as described in RFC 5077 and RFC 8446.  a stateless session ticket</span>
<span class="line-added"> 44  * contains the encrypted server&#39;s state which saves server resources.</span>
<span class="line-added"> 45  *</span>
<span class="line-added"> 46  * {@systemProperty jdk.tls.client.enableSessionTicketExtension} determines if the</span>
<span class="line-added"> 47  * client will send an extension in the ClientHello in the pre-TLS 1.3.</span>
<span class="line-added"> 48  * This extension allows the client to accept the server&#39;s session state for</span>
<span class="line-added"> 49  * Server Side stateless resumption (RFC 5077).  Setting the property to</span>
<span class="line-added"> 50  * &quot;true&quot; turns this on, by default it is false.  For TLS 1.3, the system</span>
<span class="line-added"> 51  * property is not needed as this support is part of the spec.</span>
<span class="line-added"> 52  *</span>
<span class="line-added"> 53  * {@systemProperty jdk.tls.server.sessionTicketTimeout} determines how long</span>
<span class="line-added"> 54  * a session in the server cache or the stateless resumption tickets are</span>
<span class="line-added"> 55  * available for use.  The value set by the property can be modified by</span>
<span class="line-added"> 56  * {@code SSLSessionContext.setSessionTimeout()} during runtime.</span>
<span class="line-added"> 57  *</span>
<span class="line-added"> 58  */</span>
<span class="line-added"> 59 </span>
 60 final class SSLSessionContextImpl implements SSLSessionContext {
 61     private final static int DEFAULT_MAX_CACHE_SIZE = 20480;
<span class="line-added"> 62     // Default lifetime of a session. 24 hours</span>
<span class="line-added"> 63     final static int DEFAULT_SESSION_TIMEOUT = 86400;</span>
 64 
 65     private final Cache&lt;SessionId, SSLSessionImpl&gt; sessionCache;
 66                                         // session cache, session id as key
 67     private final Cache&lt;String, SSLSessionImpl&gt; sessionHostPortCache;
 68                                         // session cache, &quot;host:port&quot; as key
 69     private int cacheLimit;             // the max cache size
 70     private int timeout;                // timeout in seconds
 71 
<span class="line-added"> 72     // Default setting for stateless session resumption support (RFC 5077)</span>
<span class="line-added"> 73     private boolean statelessSession = true;</span>
<span class="line-added"> 74 </span>
 75     // package private
<span class="line-modified"> 76     SSLSessionContextImpl(boolean server) {</span>
<span class="line-modified"> 77         timeout = DEFAULT_SESSION_TIMEOUT;</span>
<span class="line-modified"> 78         cacheLimit = getDefaults(server);    // default cache size</span>
 79 
 80         // use soft reference
 81         sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);
 82         sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);
 83     }
 84 
<span class="line-added"> 85     // Stateless sessions when available, but there is a cache</span>
<span class="line-added"> 86     boolean statelessEnabled() {</span>
<span class="line-added"> 87         return statelessSession;</span>
<span class="line-added"> 88     }</span>
<span class="line-added"> 89 </span>
 90     /**
 91      * Returns the &lt;code&gt;SSLSession&lt;/code&gt; bound to the specified session id.
 92      */
 93     @Override
 94     public SSLSession getSession(byte[] sessionId) {
 95         if (sessionId == null) {
 96             throw new NullPointerException(&quot;session id cannot be null&quot;);
 97         }
 98 
 99         SSLSessionImpl sess = sessionCache.get(new SessionId(sessionId));
100         if (!isTimedout(sess)) {
101             return sess;
102         }
103 
104         return null;
105     }
106 
107     /**
108      * Returns an enumeration of the active SSL sessions.
109      */
</pre>
<hr />
<pre>
177 
178     // package-private method, used ONLY by ClientHandshaker
179     SSLSessionImpl get(String hostname, int port) {
180         /*
181          * If no session caching info is available, we won&#39;t
182          * get one, so exit before doing a lookup.
183          */
184         if (hostname == null &amp;&amp; port == -1) {
185             return null;
186         }
187 
188         SSLSessionImpl sess = sessionHostPortCache.get(getKey(hostname, port));
189         if (!isTimedout(sess)) {
190             return sess;
191         }
192 
193         return null;
194     }
195 
196     private static String getKey(String hostname, int port) {
<span class="line-modified">197         return (hostname + &quot;:&quot; + port).toLowerCase(Locale.ENGLISH);</span>

198     }
199 
200     // cache a SSLSession
201     //
202     // In SunJSSE implementation, a session is created while getting a
203     // client hello or a server hello message, and cached while the
204     // handshaking finished.
205     // Here we time the session from the time it cached instead of the
206     // time it created, which is a little longer than the expected. So
207     // please do check isTimedout() while getting entry from the cache.
208     void put(SSLSessionImpl s) {
209         sessionCache.put(s.getSessionId(), s);
210 
211         // If no hostname/port info is available, don&#39;t add this one.
212         if ((s.getPeerHost() != null) &amp;&amp; (s.getPeerPort() != -1)) {
213             sessionHostPortCache.put(
214                 getKey(s.getPeerHost(), s.getPeerPort()), s);
215         }
216 
217         s.setContext(this);
218     }
219 
220     // package-private method, remove a cached SSLSession
221     void remove(SessionId key) {
222         SSLSessionImpl s = sessionCache.get(key);
223         if (s != null) {
224             sessionCache.remove(key);
225             sessionHostPortCache.remove(
226                     getKey(s.getPeerHost(), s.getPeerPort()));
227         }
228     }
229 
<span class="line-modified">230     private int getDefaults(boolean server) {</span>
231         try {
<span class="line-added">232             String st;</span>
<span class="line-added">233 </span>
<span class="line-added">234             // Property for Session Cache state</span>
<span class="line-added">235             if (server) {</span>
<span class="line-added">236                 st = GetPropertyAction.privilegedGetProperty(</span>
<span class="line-added">237                         &quot;jdk.tls.server.enableSessionTicketExtension&quot;, &quot;true&quot;);</span>
<span class="line-added">238             } else {</span>
<span class="line-added">239                 st = GetPropertyAction.privilegedGetProperty(</span>
<span class="line-added">240                         &quot;jdk.tls.client.enableSessionTicketExtension&quot;, &quot;true&quot;);</span>
<span class="line-added">241             }</span>
<span class="line-added">242 </span>
<span class="line-added">243             if (st.compareToIgnoreCase(&quot;false&quot;) == 0) {</span>
<span class="line-added">244                 statelessSession = false;</span>
<span class="line-added">245             }</span>
<span class="line-added">246 </span>
<span class="line-added">247             // Property for Session Ticket Timeout.  The value can be changed</span>
<span class="line-added">248             // by SSLSessionContext.setSessionTimeout(int)</span>
<span class="line-added">249             String s = GetPropertyAction.privilegedGetProperty(</span>
<span class="line-added">250                     &quot;jdk.tls.server.sessionTicketTimeout&quot;);</span>
<span class="line-added">251             if (s != null) {</span>
<span class="line-added">252                 try {</span>
<span class="line-added">253                     int t = Integer.parseInt(s);</span>
<span class="line-added">254                     if (t &lt; 0 ||</span>
<span class="line-added">255                             t &gt; NewSessionTicket.MAX_TICKET_LIFETIME) {</span>
<span class="line-added">256                         timeout = DEFAULT_SESSION_TIMEOUT;</span>
<span class="line-added">257                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">258                             SSLLogger.warning(&quot;Invalid timeout given &quot; +</span>
<span class="line-added">259                                     &quot;jdk.tls.server.sessionTicketTimeout: &quot; + t +</span>
<span class="line-added">260                                     &quot;.  Set to default value &quot; + timeout);</span>
<span class="line-added">261                         }</span>
<span class="line-added">262                     } else {</span>
<span class="line-added">263                         timeout = t;</span>
<span class="line-added">264                     }</span>
<span class="line-added">265                 } catch (NumberFormatException e) {</span>
<span class="line-added">266                     setSessionTimeout(DEFAULT_SESSION_TIMEOUT);</span>
<span class="line-added">267                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">268                         SSLLogger.warning(&quot;Invalid timeout for &quot; +</span>
<span class="line-added">269                                 &quot;jdk.tls.server.sessionTicketTimeout: &quot; + s +</span>
<span class="line-added">270                                 &quot;.  Set to default value &quot; + timeout);</span>
<span class="line-added">271 </span>
<span class="line-added">272                     }</span>
<span class="line-added">273                 }</span>
<span class="line-added">274             }</span>
<span class="line-added">275 </span>
276             int defaultCacheLimit = GetIntegerAction.privilegedGetProperty(
277                     &quot;javax.net.ssl.sessionCacheSize&quot;, DEFAULT_MAX_CACHE_SIZE);
278 
279             if (defaultCacheLimit &gt;= 0) {
280                 return defaultCacheLimit;
281             } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
282                 SSLLogger.warning(
283                     &quot;invalid System Property javax.net.ssl.sessionCacheSize, &quot; +
284                     &quot;use the default session cache size (&quot; +
285                     DEFAULT_MAX_CACHE_SIZE + &quot;) instead&quot;);
286             }
287         } catch (Exception e) {
288             // unlikely, log it for safe
289             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
290                 SSLLogger.warning(
291                     &quot;the System Property javax.net.ssl.sessionCacheSize is &quot; +
292                     &quot;not available, use the default value (&quot; +
293                     DEFAULT_MAX_CACHE_SIZE + &quot;) instead&quot;);
294             }
295         }
</pre>
</td>
</tr>
</table>
<center><a href="SSLServerSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSessionImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
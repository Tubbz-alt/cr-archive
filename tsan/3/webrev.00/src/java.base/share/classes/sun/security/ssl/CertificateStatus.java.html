<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/CertificateStatus.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import javax.net.ssl.SSLHandshakeException;
 35 import java.security.cert.X509Certificate;
 36 import sun.security.provider.certpath.OCSPResponse;
 37 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 38 import static sun.security.ssl.CertStatusExtension.*;
 39 import static sun.security.ssl.CertificateMessage.*;
 40 
 41 /**
 42  * Consumers and producers for the CertificateStatus handshake message.
 43  * This message takes one of two related but slightly different forms,
 44  * depending on the type of stapling selected by the server.  The message
 45  * data will be of the form(s):
 46  *
 47  *  [status_request, RFC 6066]
 48  *
 49  *  struct {
 50  *      CertificateStatusType status_type;
 51  *      select (status_type) {
 52  *          case ocsp: OCSPResponse;
 53  *      } response;
 54  *  } CertificateStatus;
 55  *
 56  *  opaque OCSPResponse&lt;1..2^24-1&gt;;
 57  *
 58  *  [status_request_v2, RFC 6961]
 59  *
 60  *  struct {
 61  *      CertificateStatusType status_type;
 62  *      select (status_type) {
 63  *        case ocsp: OCSPResponse;
 64  *        case ocsp_multi: OCSPResponseList;
 65  *      } response;
 66  *  } CertificateStatus;
 67  *
 68  *  opaque OCSPResponse&lt;0..2^24-1&gt;;
 69  *
 70  *  struct {
 71  *      OCSPResponse ocsp_response_list&lt;1..2^24-1&gt;;
 72  *  } OCSPResponseList;
 73  */
 74 final class CertificateStatus {
 75     static final SSLConsumer handshakeConsumer =
 76             new CertificateStatusConsumer();
 77     static final HandshakeProducer handshakeProducer =
 78             new CertificateStatusProducer();
 79     static final HandshakeAbsence handshakeAbsence =
 80             new CertificateStatusAbsence();
 81 
 82     /**
 83      * The CertificateStatus handshake message.
 84      */
 85     static final class CertificateStatusMessage extends HandshakeMessage {
 86 
 87         final CertStatusRequestType statusType;
 88         int encodedResponsesLen = 0;
 89         int messageLength = -1;
 90         final List&lt;byte[]&gt; encodedResponses = new ArrayList&lt;&gt;();
 91 
 92         CertificateStatusMessage(HandshakeContext handshakeContext) {
 93             super(handshakeContext);
 94 
 95             ServerHandshakeContext shc =
 96                     (ServerHandshakeContext)handshakeContext;
 97 
 98             // Get the Certificates from the SSLContextImpl amd the Stapling
 99             // parameters
100             StatusResponseManager.StaplingParameters stapleParams =
101                     shc.stapleParams;
102             if (stapleParams == null) {
103                 throw new IllegalArgumentException(
104                         &quot;Unexpected null stapling parameters&quot;);
105             }
106 
107             X509Certificate[] certChain =
108                 (X509Certificate[])shc.handshakeSession.getLocalCertificates();
109             if (certChain == null) {
110                 throw new IllegalArgumentException(
111                         &quot;Unexpected null certificate chain&quot;);
112             }
113 
114             // Walk the certificate list and add the correct encoded responses
115             // to the encoded responses list
116             statusType = stapleParams.statReqType;
117             if (statusType == CertStatusRequestType.OCSP) {
118                 // Just worry about the first cert in the chain
119                 byte[] resp = stapleParams.responseMap.get(certChain[0]);
120                 if (resp == null) {
121                     // A not-found return status means we should include
122                     // a zero-length response in CertificateStatus.
123                     // This is highly unlikely to happen in practice.
124                     resp = new byte[0];
125                 }
126                 encodedResponses.add(resp);
127                 encodedResponsesLen += resp.length + 3;
128             } else if (statusType == CertStatusRequestType.OCSP_MULTI) {
129                 for (X509Certificate cert : certChain) {
130                     byte[] resp = stapleParams.responseMap.get(cert);
131                     if (resp == null) {
132                         resp = new byte[0];
133                     }
134                     encodedResponses.add(resp);
135                     encodedResponsesLen += resp.length + 3;
136                 }
137             } else {
138                 throw new IllegalArgumentException(
139                         &quot;Unsupported StatusResponseType: &quot; + statusType);
140             }
141 
142             messageLength = messageLength();
143         }
144 
145         CertificateStatusMessage(HandshakeContext handshakeContext,
146                 ByteBuffer m) throws IOException {
147             super(handshakeContext);
148 
149             statusType = CertStatusRequestType.valueOf((byte)Record.getInt8(m));
150             if (statusType == CertStatusRequestType.OCSP) {
151                 byte[] respDER = Record.getBytes24(m);
152                 // Convert the incoming bytes to a OCSPResponse strucutre
153                 if (respDER.length &gt; 0) {
154                     encodedResponses.add(respDER);
155                     encodedResponsesLen = 3 + respDER.length;
156                 } else {
157                     throw handshakeContext.conContext.fatal(
158                             Alert.HANDSHAKE_FAILURE,
159                             &quot;Zero-length OCSP Response&quot;);
160                 }
161             } else if (statusType == CertStatusRequestType.OCSP_MULTI) {
162                 int respListLen = Record.getInt24(m);
163                 encodedResponsesLen = respListLen;
164 
165                 // Add each OCSP reponse into the array list in the order
166                 // we receive them off the wire.  A zero-length array is
167                 // allowed for ocsp_multi, and means that a response for
168                 // a given certificate is not available.
169                 while (respListLen &gt; 0) {
170                     byte[] respDER = Record.getBytes24(m);
171                     encodedResponses.add(respDER);
172                     respListLen -= (respDER.length + 3);
173                 }
174 
175                 if (respListLen != 0) {
176                     throw handshakeContext.conContext.fatal(
177                             Alert.INTERNAL_ERROR,
178                             &quot;Bad OCSP response list length&quot;);
179                 }
180             } else {
181                 throw handshakeContext.conContext.fatal(
182                         Alert.HANDSHAKE_FAILURE,
183                         &quot;Unsupported StatusResponseType: &quot; + statusType);
184             }
185             messageLength = messageLength();
186         }
187 
188         @Override
189         public SSLHandshake handshakeType() {
190             return SSLHandshake.CERTIFICATE_STATUS;
191         }
192 
193         @Override
194         public int messageLength() {
195             int len = 1;
196 
197             if (messageLength == -1) {
198                 if (statusType == CertStatusRequestType.OCSP) {
199                     len += encodedResponsesLen;
200                 } else if (statusType == CertStatusRequestType.OCSP_MULTI) {
201                     len += 3 + encodedResponsesLen;
202                 }
203                 messageLength = len;
204             }
205 
206             return messageLength;
207         }
208 
209         @Override
210         public void send(HandshakeOutStream s) throws IOException {
211             s.putInt8(statusType.id);
212             if (statusType == CertStatusRequestType.OCSP) {
213                 s.putBytes24(encodedResponses.get(0));
214             } else if (statusType == CertStatusRequestType.OCSP_MULTI) {
215                 s.putInt24(encodedResponsesLen);
216                 for (byte[] respBytes : encodedResponses) {
217                     if (respBytes != null) {
218                         s.putBytes24(respBytes);
219                     } else {
220                         s.putBytes24(null);
221                     }
222                 }
223             } else {
224                 // It is highly unlikely that we will fall into this section
225                 // of the code.
226                 throw new SSLHandshakeException(&quot;Unsupported status_type: &quot; +
227                         statusType.id);
228             }
229         }
230 
231         @Override
232         public String toString() {
233             StringBuilder sb = new StringBuilder();
234 
235             // Stringify the encoded OCSP response list
236             for (byte[] respDER : encodedResponses) {
237                 if (respDER.length &gt; 0) {
238                     try {
239                         OCSPResponse oResp = new OCSPResponse(respDER);
240                         sb.append(oResp.toString()).append(&quot;\n&quot;);
241                     } catch (IOException ioe) {
242                         sb.append(&quot;OCSP Response Exception: &quot;).append(ioe)
243                                 .append(&quot;\n&quot;);
244                     }
245                 } else {
246                     sb.append(&quot;&lt;Zero-length entry&gt;\n&quot;);
247                 }
248             }
249 
250             MessageFormat messageFormat = new MessageFormat(
251                 &quot;\&quot;CertificateStatus\&quot;: &#39;{&#39;\n&quot; +
252                 &quot;  \&quot;type\&quot;                : \&quot;{0}\&quot;,\n&quot; +
253                 &quot;  \&quot;responses \&quot;          : [\n&quot; + &quot;{1}\n&quot; + &quot;  ]\n&quot; +
254                 &quot;&#39;}&#39;&quot;,
255                 Locale.ENGLISH);
256             Object[] messageFields = {
257                 statusType.name,
258                 Utilities.indent(Utilities.indent(sb.toString()))
259             };
260 
261             return messageFormat.format(messageFields);
262         }
263     }
264 
265     /**
266      * The CertificateStatus handshake message consumer.
267      */
268     private static final class CertificateStatusConsumer
269             implements SSLConsumer {
270         // Prevent instantiation of this class.
271         private CertificateStatusConsumer() {
272             // blank
273         }
274 
275         @Override
276         public void consume(ConnectionContext context,
277                 ByteBuffer message) throws IOException {
278             ClientHandshakeContext chc = (ClientHandshakeContext)context;
279             CertificateStatusMessage cst =
280                     new CertificateStatusMessage(chc, message);
281 
282             // Log the message
283             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
284                 SSLLogger.fine(
285                         &quot;Consuming server CertificateStatus handshake message&quot;,
286                         cst);
287             }
288 
289             // Pin the received responses to the SSLSessionImpl.  It will
290             // be retrieved by the X509TrustManagerImpl during the certificate
291             // checking phase.
292             chc.handshakeSession.setStatusResponses(cst.encodedResponses);
293 
294             // Now perform the check
295             T12CertificateConsumer.checkServerCerts(chc, chc.deferredCerts);
296 
297             // Update the handshake consumers to remove this message, indicating
298             // that it has been processed.
299             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_STATUS.id);
300         }
301     }
302 
303     /**
304      * The CertificateStatus handshake message consumer.
305      */
306     private static final class CertificateStatusProducer
307             implements HandshakeProducer {
308         // Prevent instantiation of this class.
309         private CertificateStatusProducer() {
310             // blank
311         }
312 
313         @Override
314         public byte[] produce(ConnectionContext context,
315                 HandshakeMessage message) throws IOException {
316             // Only the server-side should be a producer of this message
317             ServerHandshakeContext shc = (ServerHandshakeContext)context;
318 
319             // If stapling is not active, immediately return without producing
320             // a message or any further processing.
321             if (!shc.staplingActive) {
322                 return null;
323             }
324 
325             // Create the CertificateStatus message from info in the
326             CertificateStatusMessage csm = new CertificateStatusMessage(shc);
327             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
328                 SSLLogger.fine(
329                     &quot;Produced server CertificateStatus handshake message&quot;, csm);
330             }
331 
332             // Output the handshake message.
333             csm.write(shc.handshakeOutput);
334             shc.handshakeOutput.flush();
335 
336             // The handshake message has been delivered.
337             return null;
338         }
339     }
340 
341     private static final class CertificateStatusAbsence
342             implements HandshakeAbsence {
343         // Prevent instantiation of this class
344         private CertificateStatusAbsence() {
345             // blank
346         }
347 
348         @Override
349         public void absent(ConnectionContext context,
350                 HandshakeMessage message) throws IOException {
351             ClientHandshakeContext chc = (ClientHandshakeContext)context;
352 
353             // Processing should only continue if stapling is active
354             if (chc.staplingActive) {
355                 // Because OCSP stapling is active, it means two things
356                 // if we&#39;re here: 1) The server hello asserted the
357                 // status_request[_v2] extension.  2) The CertificateStatus
358                 // message was not sent.  This means that cert path checking
359                 // was deferred, but must happen immediately.
360                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
361                     SSLLogger.fine(&quot;Server did not send CertificateStatus, &quot; +
362                             &quot;checking cert chain without status info.&quot;);
363                 }
364                 T12CertificateConsumer.checkServerCerts(chc, chc.deferredCerts);
365             }
366         }
367     }
368 }
369 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/util/HostnameChecker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.IOException;
 29 import java.net.IDN;
 30 import java.net.InetAddress;
 31 import java.net.UnknownHostException;
 32 import java.security.Principal;
 33 import java.security.cert.*;
 34 import java.util.*;
 35 import javax.security.auth.x500.X500Principal;
 36 import javax.net.ssl.SNIHostName;
 37 
 38 import sun.net.util.IPAddressUtil;
 39 import sun.security.x509.X500Name;
 40 import sun.security.ssl.SSLLogger;
 41 
 42 /**
 43  * Class to check hostnames against the names specified in a certificate as
 44  * required for TLS and LDAP.
 45  *
 46  */
 47 public class HostnameChecker {
 48 
 49     // Constant for a HostnameChecker for TLS
 50     public static final byte TYPE_TLS = 1;
 51     private static final HostnameChecker INSTANCE_TLS =
 52                                         new HostnameChecker(TYPE_TLS);
 53 
 54     // Constant for a HostnameChecker for LDAP
 55     public static final byte TYPE_LDAP = 2;
 56     private static final HostnameChecker INSTANCE_LDAP =
 57                                         new HostnameChecker(TYPE_LDAP);
 58 
 59     // constants for subject alt names of type DNS and IP
 60     private static final int ALTNAME_DNS = 2;
 61     private static final int ALTNAME_IP  = 7;
 62 
 63     // the algorithm to follow to perform the check. Currently unused.
 64     private final byte checkType;
 65 
 66     private HostnameChecker(byte checkType) {
 67         this.checkType = checkType;
 68     }
 69 
 70     /**
 71      * Get a HostnameChecker instance. checkType should be one of the
 72      * TYPE_* constants defined in this class.
 73      */
 74     public static HostnameChecker getInstance(byte checkType) {
 75         if (checkType == TYPE_TLS) {
 76             return INSTANCE_TLS;
 77         } else if (checkType == TYPE_LDAP) {
 78             return INSTANCE_LDAP;
 79         }
 80         throw new IllegalArgumentException(&quot;Unknown check type: &quot; + checkType);
 81     }
 82 
 83     /**
 84      * Perform the check.
 85      *
 86      * @param expectedName the expected host name or ip address
 87      * @param cert the certificate to check against
 88      * @param chainsToPublicCA true if the certificate chains to a public
 89      *     root CA (as pre-installed in the cacerts file)
 90      * @throws CertificateException if the name does not match any of
 91      *     the names specified in the certificate
 92      */
 93     public void match(String expectedName, X509Certificate cert,
 94                       boolean chainsToPublicCA) throws CertificateException {
 95         if (expectedName == null) {
 96             throw new CertificateException(&quot;Hostname or IP address is &quot; +
 97                     &quot;undefined.&quot;);
 98         }
 99         if (isIpAddress(expectedName)) {
100            matchIP(expectedName, cert);
101         } else {
102            matchDNS(expectedName, cert, chainsToPublicCA);
103         }
104     }
105 
106     public void match(String expectedName, X509Certificate cert)
107             throws CertificateException {
108         match(expectedName, cert, false);
109     }
110 
111     /**
112      * Test whether the given hostname looks like a literal IPv4 or IPv6
113      * address. The hostname does not need to be a fully qualified name.
114      *
115      * This is not a strict check that performs full input validation.
116      * That means if the method returns true, name need not be a correct
117      * IP address, rather that it does not represent a valid DNS hostname.
118      * Likewise for IP addresses when it returns false.
119      */
120     private static boolean isIpAddress(String name) {
121         if (IPAddressUtil.isIPv4LiteralAddress(name) ||
122             IPAddressUtil.isIPv6LiteralAddress(name)) {
123             return true;
124         } else {
125             return false;
126         }
127     }
128 
129     /**
130      * Check if the certificate allows use of the given IP address.
131      *
132      * From RFC2818:
133      * In some cases, the URI is specified as an IP address rather than a
134      * hostname. In this case, the iPAddress subjectAltName must be present
135      * in the certificate and must exactly match the IP in the URI.
136      */
137     private static void matchIP(String expectedIP, X509Certificate cert)
138             throws CertificateException {
139         Collection&lt;List&lt;?&gt;&gt; subjAltNames = cert.getSubjectAlternativeNames();
140         if (subjAltNames == null) {
141             throw new CertificateException
142                                 (&quot;No subject alternative names present&quot;);
143         }
144         for (List&lt;?&gt; next : subjAltNames) {
145             // For IP address, it needs to be exact match
146             if (((Integer)next.get(0)).intValue() == ALTNAME_IP) {
147                 String ipAddress = (String)next.get(1);
148                 if (expectedIP.equalsIgnoreCase(ipAddress)) {
149                     return;
150                 } else {
151                     // compare InetAddress objects in order to ensure
152                     // equality between a long IPv6 address and its
153                     // abbreviated form.
154                     try {
155                         if (InetAddress.getByName(expectedIP).equals(
156                                 InetAddress.getByName(ipAddress))) {
157                             return;
158                         }
159                     } catch (UnknownHostException e) {
160                     } catch (SecurityException e) {}
161                 }
162             }
163         }
164         throw new CertificateException(&quot;No subject alternative &quot; +
165                         &quot;names matching &quot; + &quot;IP address &quot; +
166                         expectedIP + &quot; found&quot;);
167     }
168 
169     /**
170      * Check if the certificate allows use of the given DNS name.
171      *
172      * From RFC2818:
173      * If a subjectAltName extension of type dNSName is present, that MUST
174      * be used as the identity. Otherwise, the (most specific) Common Name
175      * field in the Subject field of the certificate MUST be used. Although
176      * the use of the Common Name is existing practice, it is deprecated and
177      * Certification Authorities are encouraged to use the dNSName instead.
178      *
179      * Matching is performed using the matching rules specified by
180      * [RFC5280].  If more than one identity of a given type is present in
181      * the certificate (e.g., more than one dNSName name, a match in any one
182      * of the set is considered acceptable.)
183      */
184     private void matchDNS(String expectedName, X509Certificate cert,
185                           boolean chainsToPublicCA)
186             throws CertificateException {
187         // Check that the expected name is a valid domain name.
188         try {
189             // Using the checking implemented in SNIHostName
190             SNIHostName sni = new SNIHostName(expectedName);
191         } catch (IllegalArgumentException iae) {
192             throw new CertificateException(
193                 &quot;Illegal given domain name: &quot; + expectedName, iae);
194         }
195 
196         Collection&lt;List&lt;?&gt;&gt; subjAltNames = cert.getSubjectAlternativeNames();
197         if (subjAltNames != null) {
198             boolean foundDNS = false;
199             for (List&lt;?&gt; next : subjAltNames) {
200                 if (((Integer)next.get(0)).intValue() == ALTNAME_DNS) {
201                     foundDNS = true;
202                     String dnsName = (String)next.get(1);
203                     if (isMatched(expectedName, dnsName, chainsToPublicCA)) {
204                         return;
205                     }
206                 }
207             }
208             if (foundDNS) {
209                 // if certificate contains any subject alt names of type DNS
210                 // but none match, reject
211                 throw new CertificateException(&quot;No subject alternative DNS &quot;
212                         + &quot;name matching &quot; + expectedName + &quot; found.&quot;);
213             }
214         }
215         X500Name subjectName = getSubjectX500Name(cert);
216         DerValue derValue = subjectName.findMostSpecificAttribute
217                                                     (X500Name.commonName_oid);
218         if (derValue != null) {
219             try {
220                 if (isMatched(expectedName, derValue.getAsString(),
221                               chainsToPublicCA)) {
222                     return;
223                 }
224             } catch (IOException e) {
225                 // ignore
226             }
227         }
228         String msg = &quot;No name matching &quot; + expectedName + &quot; found&quot;;
229         throw new CertificateException(msg);
230     }
231 
232 
233     /**
234      * Return the subject of a certificate as X500Name, by reparsing if
235      * necessary. X500Name should only be used if access to name components
236      * is required, in other cases X500Principal is to be preferred.
237      *
238      * This method is currently used from within JSSE, do not remove.
239      */
240     public static X500Name getSubjectX500Name(X509Certificate cert)
241             throws CertificateParsingException {
242         try {
243             Principal subjectDN = cert.getSubjectDN();
244             if (subjectDN instanceof X500Name) {
245                 return (X500Name)subjectDN;
246             } else {
247                 X500Principal subjectX500 = cert.getSubjectX500Principal();
248                 return new X500Name(subjectX500.getEncoded());
249             }
250         } catch (IOException e) {
251             throw(CertificateParsingException)
252                 new CertificateParsingException().initCause(e);
253         }
254     }
255 
256 
257     /**
258      * Returns true if name matches against template.&lt;p&gt;
259      *
260      * The matching is performed as per RFC 2818 rules for TLS and
261      * RFC 2830 rules for LDAP.&lt;p&gt;
262      *
263      * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.
264      * The &lt;code&gt;template&lt;/code&gt; parameter
265      * may contain the wildcard character *
266      */
267     private boolean isMatched(String name, String template,
268                               boolean chainsToPublicCA) {
269 
270         // Normalize to Unicode, because PSL is in Unicode.
271         name = IDN.toUnicode(IDN.toASCII(name));
272         template = IDN.toUnicode(IDN.toASCII(template));
273 
274         if (hasIllegalWildcard(name, template, chainsToPublicCA)) {
275             return false;
276         }
277 
278         // check the validity of the domain name template.
279         try {
280             // Replacing wildcard character &#39;*&#39; with &#39;x&#39; so as to check
281             // the domain name template validity.
282             //
283             // Using the checking implemented in SNIHostName
284             new SNIHostName(template.replace(&#39;*&#39;, &#39;x&#39;));
285         } catch (IllegalArgumentException iae) {
286             // It would be nice to add debug log if not matching.
287             return false;
288         }
289 
290         if (checkType == TYPE_TLS) {
291             return matchAllWildcards(name, template);
292         } else if (checkType == TYPE_LDAP) {
293             return matchLeftmostWildcard(name, template);
294         } else {
295             return false;
296         }
297     }
298 
299     /**
300      * Returns true if the template contains an illegal wildcard character.
301      */
302     private static boolean hasIllegalWildcard(String domain, String template,
303                                               boolean chainsToPublicCA) {
304         // not ok if it is a single wildcard character or &quot;*.&quot;
305         if (template.equals(&quot;*&quot;) || template.equals(&quot;*.&quot;)) {
306             if (SSLLogger.isOn) {
307                 SSLLogger.fine(
308                     &quot;Certificate domain name has illegal single &quot; +
309                       &quot;wildcard character: &quot; + template);
310             }
311             return true;
312         }
313 
314         int lastWildcardIndex = template.lastIndexOf(&quot;*&quot;);
315 
316         // ok if it has no wildcard character
317         if (lastWildcardIndex == -1) {
318             return false;
319         }
320 
321         String afterWildcard = template.substring(lastWildcardIndex);
322         int firstDotIndex = afterWildcard.indexOf(&quot;.&quot;);
323 
324         // not ok if there is no dot after wildcard (ex: &quot;*com&quot;)
325         if (firstDotIndex == -1) {
326             if (SSLLogger.isOn) {
327                 SSLLogger.fine(
328                     &quot;Certificate domain name has illegal wildcard, &quot; +
329                     &quot;no dot after wildcard character: &quot; + template);
330             }
331             return true;
332         }
333 
334         // If the wildcarded domain is a top-level domain under which names
335         // can be registered, then a wildcard is not allowed.
336 
337         if (!chainsToPublicCA) {
338             return false; // skip check for non-public certificates
339         }
340         Optional&lt;RegisteredDomain&gt; rd = RegisteredDomain.from(domain)
341                 .filter(d -&gt; d.type() == RegisteredDomain.Type.ICANN);
342 
343         if (rd.isPresent()) {
344             String wDomain = afterWildcard.substring(firstDotIndex + 1);
345             if (rd.get().publicSuffix().equalsIgnoreCase(wDomain)) {
346                 if (SSLLogger.isOn) {
347                     SSLLogger.fine(
348                         &quot;Certificate domain name has illegal &quot; +
349                         &quot;wildcard for public suffix: &quot; + template);
350                 }
351                 return true;
352             }
353         }
354 
355         return false;
356     }
357 
358     /**
359      * Returns true if name matches against template.&lt;p&gt;
360      *
361      * According to RFC 2818, section 3.1 -
362      * Names may contain the wildcard character * which is
363      * considered to match any single domain name component
364      * or component fragment.
365      * E.g., *.a.com matches foo.a.com but not
366      * bar.foo.a.com. f*.com matches foo.com but not bar.com.
367      */
368     private static boolean matchAllWildcards(String name,
369          String template) {
370         name = name.toLowerCase(Locale.ENGLISH);
371         template = template.toLowerCase(Locale.ENGLISH);
372         StringTokenizer nameSt = new StringTokenizer(name, &quot;.&quot;);
373         StringTokenizer templateSt = new StringTokenizer(template, &quot;.&quot;);
374 
375         if (nameSt.countTokens() != templateSt.countTokens()) {
376             return false;
377         }
378 
379         while (nameSt.hasMoreTokens()) {
380             if (!matchWildCards(nameSt.nextToken(),
381                         templateSt.nextToken())) {
382                 return false;
383             }
384         }
385         return true;
386     }
387 
388 
389     /**
390      * Returns true if name matches against template.&lt;p&gt;
391      *
392      * As per RFC 2830, section 3.6 -
393      * The &quot;*&quot; wildcard character is allowed.  If present, it applies only
394      * to the left-most name component.
395      * E.g. *.bar.com would match a.bar.com, b.bar.com, etc. but not
396      * bar.com.
397      */
398     private static boolean matchLeftmostWildcard(String name,
399                          String template) {
400         name = name.toLowerCase(Locale.ENGLISH);
401         template = template.toLowerCase(Locale.ENGLISH);
402 
403         // Retrieve leftmost component
404         int templateIdx = template.indexOf(&quot;.&quot;);
405         int nameIdx = name.indexOf(&quot;.&quot;);
406 
407         if (templateIdx == -1)
408             templateIdx = template.length();
409         if (nameIdx == -1)
410             nameIdx = name.length();
411 
412         if (matchWildCards(name.substring(0, nameIdx),
413             template.substring(0, templateIdx))) {
414 
415             // match rest of the name
416             return template.substring(templateIdx).equals(
417                         name.substring(nameIdx));
418         } else {
419             return false;
420         }
421     }
422 
423 
424     /**
425      * Returns true if the name matches against the template that may
426      * contain wildcard char * &lt;p&gt;
427      */
428     private static boolean matchWildCards(String name, String template) {
429 
430         int wildcardIdx = template.indexOf(&quot;*&quot;);
431         if (wildcardIdx == -1)
432             return name.equals(template);
433 
434         boolean isBeginning = true;
435         String beforeWildcard = &quot;&quot;;
436         String afterWildcard = template;
437 
438         while (wildcardIdx != -1) {
439 
440             // match in sequence the non-wildcard chars in the template.
441             beforeWildcard = afterWildcard.substring(0, wildcardIdx);
442             afterWildcard = afterWildcard.substring(wildcardIdx + 1);
443 
444             int beforeStartIdx = name.indexOf(beforeWildcard);
445             if ((beforeStartIdx == -1) ||
446                         (isBeginning &amp;&amp; beforeStartIdx != 0)) {
447                 return false;
448             }
449             isBeginning = false;
450 
451             // update the match scope
452             name = name.substring(beforeStartIdx + beforeWildcard.length());
453             wildcardIdx = afterWildcard.indexOf(&quot;*&quot;);
454         }
455         return name.endsWith(afterWildcard);
456     }
457 }
    </pre>
  </body>
</html>
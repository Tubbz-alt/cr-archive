<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InterruptedIOException;
  32 import java.io.OutputStream;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import java.net.SocketAddress;
  37 import java.net.SocketException;
  38 import java.net.UnknownHostException;
  39 import java.nio.ByteBuffer;
  40 import java.util.List;
  41 import java.util.function.BiFunction;
  42 import javax.net.ssl.HandshakeCompletedListener;
  43 import javax.net.ssl.SSLException;
  44 import javax.net.ssl.SSLHandshakeException;
  45 import javax.net.ssl.SSLParameters;
  46 import javax.net.ssl.SSLProtocolException;
  47 import javax.net.ssl.SSLServerSocket;
  48 import javax.net.ssl.SSLSession;
  49 import javax.net.ssl.SSLSocket;
  50 import jdk.internal.access.JavaNetInetAddressAccess;
  51 import jdk.internal.access.SharedSecrets;
  52 
  53 /**
  54  * Implementation of an SSL socket.
  55  * &lt;P&gt;
  56  * This is a normal connection type socket, implementing SSL over some lower
  57  * level socket, such as TCP.  Because it is layered over some lower level
  58  * socket, it MUST override all default socket methods.
  59  * &lt;P&gt;
  60  * This API offers a non-traditional option for establishing SSL
  61  * connections.  You may first establish the connection directly, then pass
  62  * that connection to the SSL socket constructor with a flag saying which
  63  * role should be taken in the handshake protocol.  (The two ends of the
  64  * connection must not choose the same role!)  This allows setup of SSL
  65  * proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
  66  * that is required for most FTP data transfers.
  67  *
  68  * @see javax.net.ssl.SSLSocket
  69  * @see SSLServerSocket
  70  *
  71  * @author David Brownell
  72  */
  73 public final class SSLSocketImpl
  74         extends BaseSSLSocketImpl implements SSLTransport {
  75 
  76     final SSLContextImpl            sslContext;
  77     final TransportContext          conContext;
  78 
  79     private final AppInputStream    appInput = new AppInputStream();
  80     private final AppOutputStream   appOutput = new AppOutputStream();
  81 
  82     private String                  peerHost;
  83     private boolean                 autoClose;
  84     private boolean                 isConnected = false;
  85     private volatile boolean        tlsIsClosed = false;
  86 
  87     /*
  88      * Is the local name service trustworthy?
  89      *
  90      * If the local name service is not trustworthy, reverse host name
  91      * resolution should not be performed for endpoint identification.
  92      */
  93     private static final boolean trustNameService =
  94             Utilities.getBooleanProperty(&quot;jdk.tls.trustNameService&quot;, false);
  95 
  96     /**
  97      * Package-private constructor used to instantiate an unconnected
  98      * socket.
  99      *
 100      * This instance is meant to set handshake state to use &quot;client mode&quot;.
 101      */
 102     SSLSocketImpl(SSLContextImpl sslContext) {
 103         super();
 104         this.sslContext = sslContext;
 105         HandshakeHash handshakeHash = new HandshakeHash();
 106         this.conContext = new TransportContext(sslContext, this,
 107                 new SSLSocketInputRecord(handshakeHash),
 108                 new SSLSocketOutputRecord(handshakeHash), true);
 109     }
 110 
 111     /**
 112      * Package-private constructor used to instantiate a server socket.
 113      *
 114      * This instance is meant to set handshake state to use &quot;server mode&quot;.
 115      */
 116     SSLSocketImpl(SSLContextImpl sslContext, SSLConfiguration sslConfig) {
 117         super();
 118         this.sslContext = sslContext;
 119         HandshakeHash handshakeHash = new HandshakeHash();
 120         this.conContext = new TransportContext(sslContext, this, sslConfig,
 121                 new SSLSocketInputRecord(handshakeHash),
 122                 new SSLSocketOutputRecord(handshakeHash));
 123     }
 124 
 125     /**
 126      * Constructs an SSL connection to a named host at a specified
 127      * port, using the authentication context provided.
 128      *
 129      * This endpoint acts as the client, and may rejoin an existing SSL session
 130      * if appropriate.
 131      */
 132     SSLSocketImpl(SSLContextImpl sslContext, String peerHost,
 133             int peerPort) throws IOException, UnknownHostException {
 134         super();
 135         this.sslContext = sslContext;
 136         HandshakeHash handshakeHash = new HandshakeHash();
 137         this.conContext = new TransportContext(sslContext, this,
 138                 new SSLSocketInputRecord(handshakeHash),
 139                 new SSLSocketOutputRecord(handshakeHash), true);
 140         this.peerHost = peerHost;
 141         SocketAddress socketAddress =
 142                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 143                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 144         connect(socketAddress, 0);
 145     }
 146 
 147     /**
 148      * Constructs an SSL connection to a server at a specified
 149      * address, and TCP port, using the authentication context
 150      * provided.
 151      *
 152      * This endpoint acts as the client, and may rejoin an existing SSL
 153      * session if appropriate.
 154      */
 155     SSLSocketImpl(SSLContextImpl sslContext,
 156             InetAddress address, int peerPort) throws IOException {
 157         super();
 158         this.sslContext = sslContext;
 159         HandshakeHash handshakeHash = new HandshakeHash();
 160         this.conContext = new TransportContext(sslContext, this,
 161                 new SSLSocketInputRecord(handshakeHash),
 162                 new SSLSocketOutputRecord(handshakeHash), true);
 163 
 164         SocketAddress socketAddress = new InetSocketAddress(address, peerPort);
 165         connect(socketAddress, 0);
 166     }
 167 
 168     /**
 169      * Constructs an SSL connection to a named host at a specified
 170      * port, using the authentication context provided.
 171      *
 172      * This endpoint acts as the client, and may rejoin an existing SSL
 173      * session if appropriate.
 174      */
 175     SSLSocketImpl(SSLContextImpl sslContext,
 176             String peerHost, int peerPort, InetAddress localAddr,
 177             int localPort) throws IOException, UnknownHostException {
 178         super();
 179         this.sslContext = sslContext;
 180         HandshakeHash handshakeHash = new HandshakeHash();
 181         this.conContext = new TransportContext(sslContext, this,
 182                 new SSLSocketInputRecord(handshakeHash),
 183                 new SSLSocketOutputRecord(handshakeHash), true);
 184         this.peerHost = peerHost;
 185 
 186         bind(new InetSocketAddress(localAddr, localPort));
 187         SocketAddress socketAddress =
 188                peerHost != null ? new InetSocketAddress(peerHost, peerPort) :
 189                new InetSocketAddress(InetAddress.getByName(null), peerPort);
 190         connect(socketAddress, 0);
 191     }
 192 
 193     /**
 194      * Constructs an SSL connection to a server at a specified
 195      * address, and TCP port, using the authentication context
 196      * provided.
 197      *
 198      * This endpoint acts as the client, and may rejoin an existing SSL
 199      * session if appropriate.
 200      */
 201     SSLSocketImpl(SSLContextImpl sslContext,
 202             InetAddress peerAddr, int peerPort,
 203             InetAddress localAddr, int localPort) throws IOException {
 204         super();
 205         this.sslContext = sslContext;
 206         HandshakeHash handshakeHash = new HandshakeHash();
 207         this.conContext = new TransportContext(sslContext, this,
 208                 new SSLSocketInputRecord(handshakeHash),
 209                 new SSLSocketOutputRecord(handshakeHash), true);
 210 
 211         bind(new InetSocketAddress(localAddr, localPort));
 212         SocketAddress socketAddress = new InetSocketAddress(peerAddr, peerPort);
 213         connect(socketAddress, 0);
 214     }
 215 
 216     /**
 217      * Creates a server mode {@link Socket} layered over an
 218      * existing connected socket, and is able to read data which has
 219      * already been consumed/removed from the {@link Socket}&#39;s
 220      * underlying {@link InputStream}.
 221      */
 222     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 223             InputStream consumed, boolean autoClose) throws IOException {
 224         super(sock, consumed);
 225         // We always layer over a connected socket
 226         if (!sock.isConnected()) {
 227             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 228         }
 229 
 230         this.sslContext = sslContext;
 231         HandshakeHash handshakeHash = new HandshakeHash();
 232         this.conContext = new TransportContext(sslContext, this,
 233                 new SSLSocketInputRecord(handshakeHash),
 234                 new SSLSocketOutputRecord(handshakeHash), false);
 235         this.autoClose = autoClose;
 236         doneConnect();
 237     }
 238 
 239     /**
 240      * Layer SSL traffic over an existing connection, rather than
 241      * creating a new connection.
 242      *
 243      * The existing connection may be used only for SSL traffic (using this
 244      * SSLSocket) until the SSLSocket.close() call returns. However, if a
 245      * protocol error is detected, that existing connection is automatically
 246      * closed.
 247      * &lt;p&gt;
 248      * This particular constructor always uses the socket in the
 249      * role of an SSL client. It may be useful in cases which start
 250      * using SSL after some initial data transfers, for example in some
 251      * SSL tunneling applications or as part of some kinds of application
 252      * protocols which negotiate use of a SSL based security.
 253      */
 254     SSLSocketImpl(SSLContextImpl sslContext, Socket sock,
 255             String peerHost, int port, boolean autoClose) throws IOException {
 256         super(sock);
 257         // We always layer over a connected socket
 258         if (!sock.isConnected()) {
 259             throw new SocketException(&quot;Underlying socket is not connected&quot;);
 260         }
 261 
 262         this.sslContext = sslContext;
 263         HandshakeHash handshakeHash = new HandshakeHash();
 264         this.conContext = new TransportContext(sslContext, this,
 265                 new SSLSocketInputRecord(handshakeHash),
 266                 new SSLSocketOutputRecord(handshakeHash), true);
 267         this.peerHost = peerHost;
 268         this.autoClose = autoClose;
 269         doneConnect();
 270     }
 271 
 272     @Override
 273     public void connect(SocketAddress endpoint,
 274             int timeout) throws IOException {
 275 
 276         if (isLayered()) {
 277             throw new SocketException(&quot;Already connected&quot;);
 278         }
 279 
 280         if (!(endpoint instanceof InetSocketAddress)) {
 281             throw new SocketException(
 282                     &quot;Cannot handle non-Inet socket addresses.&quot;);
 283         }
 284 
 285         super.connect(endpoint, timeout);
 286         doneConnect();
 287     }
 288 
 289     @Override
 290     public String[] getSupportedCipherSuites() {
 291         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 292     }
 293 
 294     @Override
 295     public synchronized String[] getEnabledCipherSuites() {
 296         return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);
 297     }
 298 
 299     @Override
 300     public synchronized void setEnabledCipherSuites(String[] suites) {
 301         conContext.sslConfig.enabledCipherSuites =
 302                 CipherSuite.validValuesOf(suites);
 303     }
 304 
 305     @Override
 306     public String[] getSupportedProtocols() {
 307         return ProtocolVersion.toStringArray(
 308                 sslContext.getSupportedProtocolVersions());
 309     }
 310 
 311     @Override
 312     public synchronized String[] getEnabledProtocols() {
 313         return ProtocolVersion.toStringArray(
 314                 conContext.sslConfig.enabledProtocols);
 315     }
 316 
 317     @Override
 318     public synchronized void setEnabledProtocols(String[] protocols) {
 319         if (protocols == null) {
 320             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 321         }
 322 
 323         conContext.sslConfig.enabledProtocols =
 324                 ProtocolVersion.namesOf(protocols);
 325     }
 326 
 327     @Override
 328     public SSLSession getSession() {
 329         try {
 330             // start handshaking, if failed, the connection will be closed.
 331             ensureNegotiated();
 332         } catch (IOException ioe) {
 333             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 334                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 335             }
 336 
 337             return SSLSessionImpl.nullSession;
 338         }
 339 
 340         return conContext.conSession;
 341     }
 342 
 343     @Override
 344     public synchronized SSLSession getHandshakeSession() {
 345         if (conContext.handshakeContext != null) {
 346             synchronized (this) {
 347                 if (conContext.handshakeContext != null) {
 348                     return conContext.handshakeContext.handshakeSession;
 349                 }
 350             }
 351         }
 352 
 353         return null;
 354     }
 355 
 356     @Override
 357     public synchronized void addHandshakeCompletedListener(
 358             HandshakeCompletedListener listener) {
 359         if (listener == null) {
 360             throw new IllegalArgumentException(&quot;listener is null&quot;);
 361         }
 362 
 363         conContext.sslConfig.addHandshakeCompletedListener(listener);
 364     }
 365 
 366     @Override
 367     public synchronized void removeHandshakeCompletedListener(
 368             HandshakeCompletedListener listener) {
 369         if (listener == null) {
 370             throw new IllegalArgumentException(&quot;listener is null&quot;);
 371         }
 372 
 373         conContext.sslConfig.removeHandshakeCompletedListener(listener);
 374     }
 375 
 376     @Override
 377     public void startHandshake() throws IOException {
 378         if (!isConnected) {
 379             throw new SocketException(&quot;Socket is not connected&quot;);
 380         }
 381 
 382         if (conContext.isBroken || conContext.isInboundClosed() ||
 383                 conContext.isOutboundClosed()) {
 384             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 385         }
 386 
 387         synchronized (conContext) {     // handshake lock
 388             // double check the context status
 389             if (conContext.isBroken || conContext.isInboundClosed() ||
 390                     conContext.isOutboundClosed()) {
 391                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 392             }
 393 
 394             try {
 395                 conContext.kickstart();
 396 
 397                 // All initial handshaking goes through this operation until we
 398                 // have a valid SSL connection.
 399                 //
 400                 // Handle handshake messages only, need no application data.
 401                 if (!conContext.isNegotiated) {
 402                     readHandshakeRecord();
 403                 }
 404             } catch (IOException ioe) {
 405                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 406                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 407             } catch (Exception oe) {    // including RuntimeException
 408                 handleException(oe);
 409             }
 410         }
 411     }
 412 
 413     @Override
 414     public synchronized void setUseClientMode(boolean mode) {
 415         conContext.setUseClientMode(mode);
 416     }
 417 
 418     @Override
 419     public synchronized boolean getUseClientMode() {
 420         return conContext.sslConfig.isClientMode;
 421     }
 422 
 423     @Override
 424     public synchronized void setNeedClientAuth(boolean need) {
 425         conContext.sslConfig.clientAuthType =
 426                 (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :
 427                         ClientAuthType.CLIENT_AUTH_NONE);
 428     }
 429 
 430     @Override
 431     public synchronized boolean getNeedClientAuth() {
 432         return (conContext.sslConfig.clientAuthType ==
 433                         ClientAuthType.CLIENT_AUTH_REQUIRED);
 434     }
 435 
 436     @Override
 437     public synchronized void setWantClientAuth(boolean want) {
 438         conContext.sslConfig.clientAuthType =
 439                 (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :
 440                         ClientAuthType.CLIENT_AUTH_NONE);
 441     }
 442 
 443     @Override
 444     public synchronized boolean getWantClientAuth() {
 445         return (conContext.sslConfig.clientAuthType ==
 446                         ClientAuthType.CLIENT_AUTH_REQUESTED);
 447     }
 448 
 449     @Override
 450     public synchronized void setEnableSessionCreation(boolean flag) {
 451         conContext.sslConfig.enableSessionCreation = flag;
 452     }
 453 
 454     @Override
 455     public synchronized boolean getEnableSessionCreation() {
 456         return conContext.sslConfig.enableSessionCreation;
 457     }
 458 
 459     @Override
 460     public boolean isClosed() {
 461         return tlsIsClosed;
 462     }
 463 
 464     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 465     // locks may be deadlocked.
 466     @Override
 467     public void close() throws IOException {
 468         if (tlsIsClosed) {
 469             return;
 470         }
 471 
 472         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 473             SSLLogger.fine(&quot;duplex close of SSLSocket&quot;);
 474         }
 475 
 476         try {
 477             // shutdown output bound, which may have been closed previously.
 478             if (!isOutputShutdown()) {
 479                 duplexCloseOutput();
 480             }
 481 
 482             // shutdown input bound, which may have been closed previously.
 483             if (!isInputShutdown()) {
 484                 duplexCloseInput();
 485             }
 486 
 487             if (!isClosed()) {
 488                 // close the connection directly
 489                 closeSocket(false);
 490             }
 491         } catch (IOException ioe) {
 492             // ignore the exception
 493             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 494                 SSLLogger.warning(&quot;SSLSocket duplex close failed&quot;, ioe);
 495             }
 496         } finally {
 497             tlsIsClosed = true;
 498         }
 499     }
 500 
 501     /**
 502      * Duplex close, start from closing outbound.
 503      *
 504      * For TLS 1.2 [RFC 5246], unless some other fatal alert has been
 505      * transmitted, each party is required to send a close_notify alert
 506      * before closing the write side of the connection.  The other party
 507      * MUST respond with a close_notify alert of its own and close down
 508      * the connection immediately, discarding any pending writes.  It is
 509      * not required for the initiator of the close to wait for the responding
 510      * close_notify alert before closing the read side of the connection.
 511      *
 512      * For TLS 1.3, Each party MUST send a close_notify alert before
 513      * closing its write side of the connection, unless it has already sent
 514      * some error alert.  This does not have any effect on its read side of
 515      * the connection.  Both parties need not wait to receive a close_notify
 516      * alert before closing their read side of the connection, though doing
 517      * so would introduce the possibility of truncation.
 518      *
 519      * In order to support user initiated duplex-close for TLS 1.3 connections,
 520      * the user_canceled alert is used together with the close_notify alert.
 521      */
 522     private void duplexCloseOutput() throws IOException {
 523         boolean useUserCanceled = false;
 524         boolean hasCloseReceipt = false;
 525         if (conContext.isNegotiated) {
 526             if (!conContext.protocolVersion.useTLS13PlusSpec()) {
 527                 hasCloseReceipt = true;
 528             } else {
 529                 // Use a user_canceled alert for TLS 1.3 duplex close.
 530                 useUserCanceled = true;
 531             }
 532         } else if (conContext.handshakeContext != null) {   // initial handshake
 533             // Use user_canceled alert regardless the protocol versions.
 534             useUserCanceled = true;
 535 
 536             // The protocol version may have been negotiated.
 537             ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;
 538             if (pv == null || (!pv.useTLS13PlusSpec())) {
 539                 hasCloseReceipt = true;
 540             }
 541         }
 542 
 543         // Need a lock here so that the user_canceled alert and the
 544         // close_notify alert can be delivered together.
 545         try {
 546             synchronized (conContext.outputRecord) {
 547                 // send a user_canceled alert if needed.
 548                 if (useUserCanceled) {
 549                     conContext.warning(Alert.USER_CANCELED);
 550                 }
 551 
 552                 // send a close_notify alert
 553                 conContext.warning(Alert.CLOSE_NOTIFY);
 554             }
 555         } finally {
 556             if (!conContext.isOutboundClosed()) {
 557                 conContext.outputRecord.close();
 558             }
 559 
 560             if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 561                 super.shutdownOutput();
 562             }
 563         }
 564 
 565         if (!isInputShutdown()) {
 566             bruteForceCloseInput(hasCloseReceipt);
 567         }
 568     }
 569 
 570     /**
 571      * Duplex close, start from closing inbound.
 572      *
 573      * This method should only be called when the outbound has been closed,
 574      * but the inbound is still open.
 575      */
 576     private void duplexCloseInput() throws IOException {
 577         boolean hasCloseReceipt = false;
 578         if (conContext.isNegotiated &amp;&amp;
 579                 !conContext.protocolVersion.useTLS13PlusSpec()) {
 580             hasCloseReceipt = true;
 581         }   // No close receipt if handshake has no completed.
 582 
 583         bruteForceCloseInput(hasCloseReceipt);
 584     }
 585 
 586     /**
 587      * Brute force close the input bound.
 588      *
 589      * This method should only be called when the outbound has been closed,
 590      * but the inbound is still open.
 591      */
 592     private void bruteForceCloseInput(
 593             boolean hasCloseReceipt) throws IOException {
 594         if (hasCloseReceipt) {
 595             // It is not required for the initiator of the close to wait for
 596             // the responding close_notify alert before closing the read side
 597             // of the connection.  However, if the application protocol using
 598             // TLS provides that any data may be carried over the underlying
 599             // transport after the TLS connection is closed, the TLS
 600             // implementation MUST receive a &quot;close_notify&quot; alert before
 601             // indicating end-of-data to the application-layer.
 602             try {
 603                 this.shutdown();
 604             } finally {
 605                 if (!isInputShutdown()) {
 606                     shutdownInput(false);
 607                 }
 608             }
 609         } else {
 610             if (!conContext.isInboundClosed()) {
 611                 try (conContext.inputRecord) {
 612                     // Try the best to use up the input records and close the
 613                     // socket gracefully, without impact the performance too
 614                     // much.
 615                     appInput.deplete();
 616                 }
 617             }
 618 
 619             if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 620                 super.shutdownInput();
 621             }
 622         }
 623     }
 624 
 625     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 626     // locks may be deadlocked.
 627     @Override
 628     public void shutdownInput() throws IOException {
 629         shutdownInput(true);
 630     }
 631 
 632     // It is not required to check the close_notify receipt unless an
 633     // application call shutdownInput() explicitly.
 634     private void shutdownInput(
 635             boolean checkCloseNotify) throws IOException {
 636         if (isInputShutdown()) {
 637             return;
 638         }
 639 
 640         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 641             SSLLogger.fine(&quot;close inbound of SSLSocket&quot;);
 642         }
 643 
 644         // Is it ready to close inbound?
 645         //
 646         // No need to throw exception if the initial handshake is not started.
 647         if (checkCloseNotify &amp;&amp; !conContext.isInputCloseNotified &amp;&amp;
 648             (conContext.isNegotiated || conContext.handshakeContext != null)) {
 649 
 650             throw conContext.fatal(Alert.INTERNAL_ERROR,
 651                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);
 652         }
 653 
 654         conContext.closeInbound();
 655         if ((autoClose || !isLayered()) &amp;&amp; !super.isInputShutdown()) {
 656             super.shutdownInput();
 657         }
 658     }
 659 
 660     @Override
 661     public boolean isInputShutdown() {
 662         return conContext.isInboundClosed() &amp;&amp;
 663                 ((autoClose || !isLayered()) ? super.isInputShutdown(): true);
 664     }
 665 
 666     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 667     // locks may be deadlocked.
 668     @Override
 669     public void shutdownOutput() throws IOException {
 670         if (isOutputShutdown()) {
 671             return;
 672         }
 673 
 674         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 675             SSLLogger.fine(&quot;close outbound of SSLSocket&quot;);
 676         }
 677         conContext.closeOutbound();
 678 
 679         if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 680             super.shutdownOutput();
 681         }
 682     }
 683 
 684     @Override
 685     public boolean isOutputShutdown() {
 686         return conContext.isOutboundClosed() &amp;&amp;
 687                 ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
 688     }
 689 
 690     @Override
 691     public synchronized InputStream getInputStream() throws IOException {
 692         if (isClosed()) {
 693             throw new SocketException(&quot;Socket is closed&quot;);
 694         }
 695 
 696         if (!isConnected) {
 697             throw new SocketException(&quot;Socket is not connected&quot;);
 698         }
 699 
 700         if (conContext.isInboundClosed() || isInputShutdown()) {
 701             throw new SocketException(&quot;Socket input is already shutdown&quot;);
 702         }
 703 
 704         return appInput;
 705     }
 706 
 707     private void ensureNegotiated() throws IOException {
 708         if (conContext.isNegotiated || conContext.isBroken ||
 709                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 710             return;
 711         }
 712 
 713         synchronized (conContext) {     // handshake lock
 714             // double check the context status
 715             if (conContext.isNegotiated || conContext.isBroken ||
 716                     conContext.isInboundClosed() ||
 717                     conContext.isOutboundClosed()) {
 718                 return;
 719             }
 720 
 721             startHandshake();
 722         }
 723     }
 724 
 725     /**
 726      * InputStream for application data as returned by
 727      * SSLSocket.getInputStream().
 728      */
 729     private class AppInputStream extends InputStream {
 730         // One element array used to implement the single byte read() method
 731         private final byte[] oneByte = new byte[1];
 732 
 733         // the temporary buffer used to read network
 734         private ByteBuffer buffer;
 735 
 736         // Is application data available in the stream?
 737         private volatile boolean appDataIsAvailable;
 738 
 739         AppInputStream() {
 740             this.appDataIsAvailable = false;
 741             this.buffer = ByteBuffer.allocate(4096);
 742         }
 743 
 744         /**
 745          * Return the minimum number of bytes that can be read
 746          * without blocking.
 747          */
 748         @Override
 749         public int available() throws IOException {
 750             // Currently not synchronized.
 751             if ((!appDataIsAvailable) || checkEOF()) {
 752                 return 0;
 753             }
 754 
 755             return buffer.remaining();
 756         }
 757 
 758         /**
 759          * Read a single byte, returning -1 on non-fault EOF status.
 760          */
 761         @Override
 762         public int read() throws IOException {
 763             int n = read(oneByte, 0, 1);
 764             if (n &lt;= 0) {   // EOF
 765                 return -1;
 766             }
 767 
 768             return oneByte[0] &amp; 0xFF;
 769         }
 770 
 771         /**
 772          * Reads up to {@code len} bytes of data from the input stream
 773          * into an array of bytes.
 774          *
 775          * An attempt is made to read as many as {@code len} bytes, but a
 776          * smaller number may be read. The number of bytes actually read
 777          * is returned as an integer.
 778          *
 779          * If the layer above needs more data, it asks for more, so we
 780          * are responsible only for blocking to fill at most one buffer,
 781          * and returning &quot;-1&quot; on non-fault EOF status.
 782          */
 783         @Override
 784         public int read(byte[] b, int off, int len)
 785                 throws IOException {
 786             if (b == null) {
 787                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 788             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 789                 throw new IndexOutOfBoundsException(
 790                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 791                         &quot;, bytes to read:&quot; + len);
 792             } else if (len == 0) {
 793                 return 0;
 794             }
 795 
 796             if (checkEOF()) {
 797                 return -1;
 798             }
 799 
 800             // start handshaking if the connection has not been negotiated.
 801             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 802                     !conContext.isInboundClosed() &amp;&amp;
 803                     !conContext.isOutboundClosed()) {
 804                 ensureNegotiated();
 805             }
 806 
 807             // Check if the Socket is invalid (error or closed).
 808             if (!conContext.isNegotiated ||
 809                     conContext.isBroken || conContext.isInboundClosed()) {
 810                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 811             }
 812 
 813             // Read the available bytes at first.
 814             //
 815             // Note that the receiving and processing of post-handshake message
 816             // are also synchronized with the read lock.
 817             synchronized (this) {
 818                 int remains = available();
 819                 if (remains &gt; 0) {
 820                     int howmany = Math.min(remains, len);
 821                     buffer.get(b, off, howmany);
 822 
 823                     return howmany;
 824                 }
 825 
 826                 appDataIsAvailable = false;
 827                 try {
 828                     ByteBuffer bb = readApplicationRecord(buffer);
 829                     if (bb == null) {   // EOF
 830                         return -1;
 831                     } else {
 832                         // The buffer may be reallocated for bigger capacity.
 833                         buffer = bb;
 834                     }
 835 
 836                     bb.flip();
 837                     int volume = Math.min(len, bb.remaining());
 838                     buffer.get(b, off, volume);
 839                     appDataIsAvailable = true;
 840 
 841                     return volume;
 842                 } catch (Exception e) {   // including RuntimeException
 843                     // shutdown and rethrow (wrapped) exception as appropriate
 844                     handleException(e);
 845 
 846                     // dummy for compiler
 847                     return -1;
 848                 }
 849             }
 850         }
 851 
 852         /**
 853          * Skip n bytes.
 854          *
 855          * This implementation is somewhat less efficient than possible, but
 856          * not badly so (redundant copy).  We reuse the read() code to keep
 857          * things simpler.
 858          */
 859         @Override
 860         public synchronized long skip(long n) throws IOException {
 861             // dummy array used to implement skip()
 862             byte[] skipArray = new byte[256];
 863 
 864             long skipped = 0;
 865             while (n &gt; 0) {
 866                 int len = (int)Math.min(n, skipArray.length);
 867                 int r = read(skipArray, 0, len);
 868                 if (r &lt;= 0) {
 869                     break;
 870                 }
 871                 n -= r;
 872                 skipped += r;
 873             }
 874 
 875             return skipped;
 876         }
 877 
 878         @Override
 879         public void close() throws IOException {
 880             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 881                 SSLLogger.finest(&quot;Closing input stream&quot;);
 882             }
 883 
 884             try {
 885                 shutdownInput(false);
 886             } catch (IOException ioe) {
 887                 // ignore the exception
 888                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 889                     SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
 890                 }
 891             }
 892         }
 893 
 894         /**
 895          * Return whether we have reached end-of-file.
 896          *
 897          * If the socket is not connected, has been shutdown because of an error
 898          * or has been closed, throw an Exception.
 899          */
 900         private boolean checkEOF() throws IOException {
 901             if (conContext.isInboundClosed()) {
 902                 return true;
 903             } else if (conContext.isInputCloseNotified || conContext.isBroken) {
 904                 if (conContext.closeReason == null) {
 905                     return true;
 906                 } else {
 907                     throw new SSLException(
 908                         &quot;Connection has closed: &quot; + conContext.closeReason,
 909                         conContext.closeReason);
 910                 }
 911             }
 912 
 913             return false;
 914         }
 915 
 916         /**
 917          * Try the best to use up the input records so as to close the
 918          * socket gracefully, without impact the performance too much.
 919          */
 920         private synchronized void deplete() {
 921             if (!conContext.isInboundClosed()) {
 922                 if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {
 923                     return;
 924                 }
 925 
 926                 SSLSocketInputRecord socketInputRecord =
 927                         (SSLSocketInputRecord)conContext.inputRecord;
 928                 try {
 929                     socketInputRecord.deplete(
 930                         conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));
 931                 } catch (IOException ioe) {
 932                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 933                         SSLLogger.warning(
 934                             &quot;input stream close depletion failed&quot;, ioe);
 935                     }
 936                 }
 937             }
 938         }
 939     }
 940 
 941     @Override
 942     public synchronized OutputStream getOutputStream() throws IOException {
 943         if (isClosed()) {
 944             throw new SocketException(&quot;Socket is closed&quot;);
 945         }
 946 
 947         if (!isConnected) {
 948             throw new SocketException(&quot;Socket is not connected&quot;);
 949         }
 950 
 951         if (conContext.isOutboundDone() || isOutputShutdown()) {
 952             throw new SocketException(&quot;Socket output is already shutdown&quot;);
 953         }
 954 
 955         return appOutput;
 956     }
 957 
 958 
 959     /**
 960      * OutputStream for application data as returned by
 961      * SSLSocket.getOutputStream().
 962      */
 963     private class AppOutputStream extends OutputStream {
 964         // One element array used to implement the write(byte) method
 965         private final byte[] oneByte = new byte[1];
 966 
 967         @Override
 968         public void write(int i) throws IOException {
 969             oneByte[0] = (byte)i;
 970             write(oneByte, 0, 1);
 971         }
 972 
 973         @Override
 974         public void write(byte[] b,
 975                 int off, int len) throws IOException {
 976             if (b == null) {
 977                 throw new NullPointerException(&quot;the source buffer is null&quot;);
 978             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 979                 throw new IndexOutOfBoundsException(
 980                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 981                         &quot;, bytes to read:&quot; + len);
 982             } else if (len == 0) {
 983                 //
 984                 // Don&#39;t bother to really write empty records.  We went this
 985                 // far to drive the handshake machinery, for correctness; not
 986                 // writing empty records improves performance by cutting CPU
 987                 // time and network resource usage.  However, some protocol
 988                 // implementations are fragile and don&#39;t like to see empty
 989                 // records, so this also increases robustness.
 990                 //
 991                 return;
 992             }
 993 
 994             // Start handshaking if the connection has not been negotiated.
 995             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 996                     !conContext.isInboundClosed() &amp;&amp;
 997                     !conContext.isOutboundClosed()) {
 998                 ensureNegotiated();
 999             }
1000 
1001             // Check if the Socket is invalid (error or closed).
1002             if (!conContext.isNegotiated ||
1003                     conContext.isBroken || conContext.isOutboundClosed()) {
1004                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1005             }
1006 
1007             //
1008 
1009             // Delegate the writing to the underlying socket.
1010             try {
1011                 conContext.outputRecord.deliver(b, off, len);
1012             } catch (SSLHandshakeException she) {
1013                 // may be record sequence number overflow
1014                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
1015             } catch (IOException e) {
1016                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);
1017             }
1018 
1019             // Is the sequence number is nearly overflow, or has the key usage
1020             // limit been reached?
1021             if (conContext.outputRecord.seqNumIsHuge() ||
1022                     conContext.outputRecord.writeCipher.atKeyLimit()) {
1023                 tryKeyUpdate();
1024             }
1025         }
1026 
1027         @Override
1028         public void close() throws IOException {
1029             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1030                 SSLLogger.finest(&quot;Closing output stream&quot;);
1031             }
1032 
1033             try {
1034                 shutdownOutput();
1035             } catch (IOException ioe) {
1036                 // ignore the exception
1037                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1038                     SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
1039                 }
1040             }
1041         }
1042     }
1043 
1044     @Override
1045     public synchronized SSLParameters getSSLParameters() {
1046         return conContext.sslConfig.getSSLParameters();
1047     }
1048 
1049     @Override
1050     public synchronized void setSSLParameters(SSLParameters params) {
1051         conContext.sslConfig.setSSLParameters(params);
1052 
1053         if (conContext.sslConfig.maximumPacketSize != 0) {
1054             conContext.outputRecord.changePacketSize(
1055                     conContext.sslConfig.maximumPacketSize);
1056         }
1057     }
1058 
1059     @Override
1060     public synchronized String getApplicationProtocol() {
1061         return conContext.applicationProtocol;
1062     }
1063 
1064     @Override
1065     public synchronized String getHandshakeApplicationProtocol() {
1066         if (conContext.handshakeContext != null) {
1067             return conContext.handshakeContext.applicationProtocol;
1068         }
1069 
1070         return null;
1071     }
1072 
1073     @Override
1074     public synchronized void setHandshakeApplicationProtocolSelector(
1075             BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
1076         conContext.sslConfig.socketAPSelector = selector;
1077     }
1078 
1079     @Override
1080     public synchronized BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;
1081             getHandshakeApplicationProtocolSelector() {
1082         return conContext.sslConfig.socketAPSelector;
1083     }
1084 
1085     /**
1086      * Read the initial handshake records.
1087      */
1088     private int readHandshakeRecord() throws IOException {
1089         while (!conContext.isInboundClosed()) {
1090             try {
1091                 Plaintext plainText = decode(null);
1092                 if ((plainText.contentType == ContentType.HANDSHAKE.id) &amp;&amp;
1093                         conContext.isNegotiated) {
1094                     return 0;
1095                 }
1096             } catch (SSLException ssle) {
1097                 throw ssle;
1098             } catch (IOException ioe) {
1099                 if (!(ioe instanceof SSLException)) {
1100                     throw new SSLException(&quot;readHandshakeRecord&quot;, ioe);
1101                 } else {
1102                     throw ioe;
1103                 }
1104             }
1105         }
1106 
1107         return -1;
1108     }
1109 
1110     /**
1111      * Read application data record. Used by AppInputStream only, but defined
1112      * here so as to use the socket level synchronization.
1113      *
1114      * Note that the connection guarantees that handshake, alert, and change
1115      * cipher spec data streams are handled as they arrive, so we never see
1116      * them here.
1117      *
1118      * Note: Please be careful about the synchronization, and don&#39;t use this
1119      * method other than in the AppInputStream class!
1120      */
1121     private ByteBuffer readApplicationRecord(
1122             ByteBuffer buffer) throws IOException {
1123         while (!conContext.isInboundClosed()) {
1124             /*
1125              * clean the buffer and check if it is too small, e.g. because
1126              * the AppInputStream did not have the chance to see the
1127              * current packet length but rather something like that of the
1128              * handshake before. In that case we return 0 at this point to
1129              * give the caller the chance to adjust the buffer.
1130              */
1131             buffer.clear();
1132             int inLen = conContext.inputRecord.bytesInCompletePacket();
1133             if (inLen &lt; 0) {    // EOF
1134                 handleEOF(null);
1135 
1136                 // if no exception thrown
1137                 return null;
1138             }
1139 
1140             // Is this packet bigger than SSL/TLS normally allows?
1141             if (inLen &gt; SSLRecord.maxLargeRecordSize) {
1142                 throw new SSLProtocolException(
1143                         &quot;Illegal packet size: &quot; + inLen);
1144             }
1145 
1146             if (inLen &gt; buffer.remaining()) {
1147                 buffer = ByteBuffer.allocate(inLen);
1148             }
1149 
1150             try {
1151                 Plaintext plainText;
1152                 synchronized (this) {
1153                     plainText = decode(buffer);
1154                 }
1155                 if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
1156                         buffer.position() &gt; 0) {
1157                     return buffer;
1158                 }
1159             } catch (SSLException ssle) {
1160                 throw ssle;
1161             } catch (IOException ioe) {
1162                 if (!(ioe instanceof SSLException)) {
1163                     throw new SSLException(&quot;readApplicationRecord&quot;, ioe);
1164                 } else {
1165                     throw ioe;
1166                 }
1167             }
1168         }
1169 
1170         //
1171         // couldn&#39;t read, due to some kind of error
1172         //
1173         return null;
1174     }
1175 
1176     private Plaintext decode(ByteBuffer destination) throws IOException {
1177         Plaintext plainText;
1178         try {
1179             if (destination == null) {
1180                 plainText = SSLTransport.decode(conContext,
1181                         null, 0, 0, null, 0, 0);
1182             } else {
1183                 plainText = SSLTransport.decode(conContext,
1184                         null, 0, 0, new ByteBuffer[]{destination}, 0, 1);
1185             }
1186         } catch (EOFException eofe) {
1187             // EOFException is special as it is related to close_notify.
1188             plainText = handleEOF(eofe);
1189         }
1190 
1191         // Is the sequence number is nearly overflow?
1192         if (plainText != Plaintext.PLAINTEXT_NULL &amp;&amp;
1193                 (conContext.inputRecord.seqNumIsHuge() ||
1194                 conContext.inputRecord.readCipher.atKeyLimit())) {
1195             tryKeyUpdate();
1196         }
1197 
1198         return plainText;
1199     }
1200 
1201     /**
1202      * Try key update for sequence number wrap or key usage limit.
1203      *
1204      * Note that in order to maintain the handshake status properly, we check
1205      * the sequence number and key usage limit after the last record
1206      * reading/writing process.
1207      *
1208      * As we request renegotiation or close the connection for wrapped sequence
1209      * number when there is enough sequence number space left to handle a few
1210      * more records, so the sequence number of the last record cannot be
1211      * wrapped.
1212      */
1213     private void tryKeyUpdate() throws IOException {
1214         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1215         // connection is not duplex-open.
1216         if ((conContext.handshakeContext == null) &amp;&amp;
1217                 !conContext.isOutboundClosed() &amp;&amp;
1218                 !conContext.isInboundClosed() &amp;&amp;
1219                 !conContext.isBroken) {
1220             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1221                 SSLLogger.finest(&quot;trigger key update&quot;);
1222             }
1223             startHandshake();
1224         }
1225     }
1226 
1227     /**
1228      * Initialize the handshaker and socket streams.
1229      *
1230      * Called by connect, the layered constructor, and SSLServerSocket.
1231      */
1232     synchronized void doneConnect() throws IOException {
1233         // In server mode, it is not necessary to set host and serverNames.
1234         // Otherwise, would require a reverse DNS lookup to get the hostname.
1235         if (peerHost == null || peerHost.isEmpty()) {
1236             boolean useNameService =
1237                     trustNameService &amp;&amp; conContext.sslConfig.isClientMode;
1238             useImplicitHost(useNameService);
1239         } else {
1240             conContext.sslConfig.serverNames =
1241                     Utilities.addToSNIServerNameList(
1242                             conContext.sslConfig.serverNames, peerHost);
1243         }
1244 
1245         InputStream sockInput = super.getInputStream();
1246         conContext.inputRecord.setReceiverStream(sockInput);
1247 
1248         OutputStream sockOutput = super.getOutputStream();
1249         conContext.inputRecord.setDeliverStream(sockOutput);
1250         conContext.outputRecord.setDeliverStream(sockOutput);
1251 
1252         this.isConnected = true;
1253     }
1254 
1255     private void useImplicitHost(boolean useNameService) {
1256         // Note: If the local name service is not trustworthy, reverse
1257         // host name resolution should not be performed for endpoint
1258         // identification.  Use the application original specified
1259         // hostname or IP address instead.
1260 
1261         // Get the original hostname via jdk.internal.access.SharedSecrets
1262         InetAddress inetAddress = getInetAddress();
1263         if (inetAddress == null) {      // not connected
1264             return;
1265         }
1266 
1267         JavaNetInetAddressAccess jna =
1268                 SharedSecrets.getJavaNetInetAddressAccess();
1269         String originalHostname = jna.getOriginalHostName(inetAddress);
1270         if (originalHostname != null &amp;&amp; !originalHostname.isEmpty()) {
1271 
1272             this.peerHost = originalHostname;
1273             if (conContext.sslConfig.serverNames.isEmpty() &amp;&amp;
1274                     !conContext.sslConfig.noSniExtension) {
1275                 conContext.sslConfig.serverNames =
1276                         Utilities.addToSNIServerNameList(
1277                                 conContext.sslConfig.serverNames, peerHost);
1278             }
1279 
1280             return;
1281         }
1282 
1283         // No explicitly specified hostname, no server name indication.
1284         if (!useNameService) {
1285             // The local name service is not trustworthy, use IP address.
1286             this.peerHost = inetAddress.getHostAddress();
1287         } else {
1288             // Use the underlying reverse host name resolution service.
1289             this.peerHost = getInetAddress().getHostName();
1290         }
1291     }
1292 
1293     // ONLY used by HttpsClient to setup the URI specified hostname
1294     //
1295     // Please NOTE that this method MUST be called before calling to
1296     // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
1297     // may override SNIHostName in the customized server name indication.
1298     public synchronized void setHost(String host) {
1299         this.peerHost = host;
1300         this.conContext.sslConfig.serverNames =
1301                 Utilities.addToSNIServerNameList(
1302                         conContext.sslConfig.serverNames, host);
1303     }
1304 
1305     /**
1306      * Handle an exception.
1307      *
1308      * This method is called by top level exception handlers (in read(),
1309      * write()) to make sure we always shutdown the connection correctly
1310      * and do not pass runtime exception to the application.
1311      *
1312      * This method never returns normally, it always throws an IOException.
1313      */
1314     private void handleException(Exception cause) throws IOException {
1315         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1316             SSLLogger.warning(&quot;handling exception&quot;, cause);
1317         }
1318 
1319         // Don&#39;t close the Socket in case of timeouts or interrupts.
1320         if (cause instanceof InterruptedIOException) {
1321             throw (IOException)cause;
1322         }
1323 
1324         // need to perform error shutdown
1325         boolean isSSLException = (cause instanceof SSLException);
1326         Alert alert;
1327         if (isSSLException) {
1328             if (cause instanceof SSLHandshakeException) {
1329                 alert = Alert.HANDSHAKE_FAILURE;
1330             } else {
1331                 alert = Alert.UNEXPECTED_MESSAGE;
1332             }
1333         } else {
1334             if (cause instanceof IOException) {
1335                 alert = Alert.UNEXPECTED_MESSAGE;
1336             } else {
1337                 // RuntimeException
1338                 alert = Alert.INTERNAL_ERROR;
1339             }
1340         }
1341 
1342         throw conContext.fatal(alert, cause);
1343     }
1344 
1345     private Plaintext handleEOF(EOFException eofe) throws IOException {
1346         if (requireCloseNotify || conContext.handshakeContext != null) {
1347             SSLException ssle;
1348             if (conContext.handshakeContext != null) {
1349                 ssle = new SSLHandshakeException(
1350                         &quot;Remote host terminated the handshake&quot;);
1351             } else {
1352                 ssle = new SSLProtocolException(
1353                         &quot;Remote host terminated the connection&quot;);
1354             }
1355 
1356             if (eofe != null) {
1357                 ssle.initCause(eofe);
1358             }
1359             throw ssle;
1360         } else {
1361             // treat as if we had received a close_notify
1362             conContext.isInputCloseNotified = true;
1363             shutdownInput();
1364 
1365             return Plaintext.PLAINTEXT_NULL;
1366         }
1367     }
1368 
1369 
1370     @Override
1371     public String getPeerHost() {
1372         return peerHost;
1373     }
1374 
1375     @Override
1376     public int getPeerPort() {
1377         return getPort();
1378     }
1379 
1380     @Override
1381     public boolean useDelegatedTask() {
1382         return false;
1383     }
1384 
1385     @Override
1386     public void shutdown() throws IOException {
1387         if (!isClosed()) {
1388             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1389                 SSLLogger.fine(&quot;close the underlying socket&quot;);
1390             }
1391 
1392             try {
1393                 if (conContext.isInputCloseNotified) {
1394                     // Close the connection, no wait for more peer response.
1395                     closeSocket(false);
1396                 } else {
1397                     // Close the connection, may wait for peer close_notify.
1398                     closeSocket(true);
1399                 }
1400             } finally {
1401                 tlsIsClosed = true;
1402             }
1403         }
1404     }
1405 
1406     private void closeSocket(boolean selfInitiated) throws IOException {
1407         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1408             SSLLogger.fine(&quot;close the SSL connection &quot; +
1409                 (selfInitiated ? &quot;(initiative)&quot; : &quot;(passive)&quot;));
1410         }
1411 
1412         if (autoClose || !isLayered()) {
1413             super.close();
1414         } else if (selfInitiated) {
1415             if (!conContext.isInboundClosed() &amp;&amp; !isInputShutdown()) {
1416                 // wait for close_notify alert to clear input stream.
1417                 waitForClose();
1418             }
1419         }
1420     }
1421 
1422    /**
1423     * Wait for close_notify alert for a graceful closure.
1424     *
1425     * [RFC 5246] If the application protocol using TLS provides that any
1426     * data may be carried over the underlying transport after the TLS
1427     * connection is closed, the TLS implementation must receive the responding
1428     * close_notify alert before indicating to the application layer that
1429     * the TLS connection has ended.  If the application protocol will not
1430     * transfer any additional data, but will only close the underlying
1431     * transport connection, then the implementation MAY choose to close the
1432     * transport without waiting for the responding close_notify.
1433     */
1434     private void waitForClose() throws IOException {
1435         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1436             SSLLogger.fine(&quot;wait for close_notify or alert&quot;);
1437         }
1438 
1439         while (!conContext.isInboundClosed()) {
1440             try {
1441                 Plaintext plainText = decode(null);
1442                 // discard and continue
1443                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1444                     SSLLogger.finest(
1445                         &quot;discard plaintext while waiting for close&quot;, plainText);
1446                 }
1447             } catch (Exception e) {   // including RuntimeException
1448                 handleException(e);
1449             }
1450         }
1451     }
1452 }
    </pre>
  </body>
</html>
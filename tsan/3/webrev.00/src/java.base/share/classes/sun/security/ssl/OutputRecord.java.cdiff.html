<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/OutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewSessionTicket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PostHandshakeContext.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/OutputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  import java.io.ByteArrayOutputStream;
  import java.io.Closeable;
  import java.io.IOException;
  import java.io.OutputStream;
  import java.nio.ByteBuffer;
<span class="line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import sun.security.ssl.SSLCipher.SSLWriteCipher;
  
  /**
   * {@code OutputRecord} takes care of the management of SSL/(D)TLS
   * output records, including buffering, encryption, handshake
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,15 ***</span>
  
      // packet size
      int                         packetSize;
  
      // fragment size
<span class="line-modified">!     int                         fragmentSize;</span>
  
      // closed or not?
      volatile boolean            isClosed;
  
      /*
       * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
       * This is taken from the SSL V3 specification, Appendix E.
       */
      private static final int[] V3toV2CipherMap1 =
<span class="line-new-header">--- 62,17 ---</span>
  
      // packet size
      int                         packetSize;
  
      // fragment size
<span class="line-modified">!     private int                 fragmentSize;</span>
  
      // closed or not?
      volatile boolean            isClosed;
  
<span class="line-added">+     final ReentrantLock recordLock = new ReentrantLock();</span>
<span class="line-added">+ </span>
      /*
       * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
       * This is taken from the SSL V3 specification, Appendix E.
       */
      private static final int[] V3toV2CipherMap1 =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,32 ***</span>
          this.handshakeHash = handshakeHash;
  
          // Please set packetSize and protocolVersion in the implementation.
      }
  
<span class="line-modified">!     synchronized void setVersion(ProtocolVersion protocolVersion) {</span>
<span class="line-modified">!         this.protocolVersion = protocolVersion;</span>
      }
  
      /*
       * Updates helloVersion of this record.
       */
<span class="line-modified">!     synchronized void setHelloVersion(ProtocolVersion helloVersion) {</span>
<span class="line-modified">!         this.helloVersion = helloVersion;</span>
      }
  
      /*
       * Return true iff the record is empty -- to avoid doing the work
       * of sending empty records over the network.
       */
      boolean isEmpty() {
          return false;
      }
  
<span class="line-modified">!     synchronized boolean seqNumIsHuge() {</span>
<span class="line-modified">!         return (writeCipher.authenticator != null) &amp;&amp;</span>
                          writeCipher.authenticator.seqNumIsHuge();
      }
  
      // SSLEngine and SSLSocket
      abstract void encodeAlert(byte level, byte description) throws IOException;
  
<span class="line-new-header">--- 90,47 ---</span>
          this.handshakeHash = handshakeHash;
  
          // Please set packetSize and protocolVersion in the implementation.
      }
  
<span class="line-modified">!     void setVersion(ProtocolVersion protocolVersion) {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             this.protocolVersion = protocolVersion;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      /*
       * Updates helloVersion of this record.
       */
<span class="line-modified">!     void setHelloVersion(ProtocolVersion helloVersion) {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             this.helloVersion = helloVersion;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      /*
       * Return true iff the record is empty -- to avoid doing the work
       * of sending empty records over the network.
       */
      boolean isEmpty() {
          return false;
      }
  
<span class="line-modified">!     boolean seqNumIsHuge() {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return (writeCipher.authenticator != null) &amp;&amp;</span>
                          writeCipher.authenticator.seqNumIsHuge();
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      // SSLEngine and SSLSocket
      abstract void encodeAlert(byte level, byte description) throws IOException;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,72 ***</span>
      void setDeliverStream(OutputStream outputStream) {
          throw new UnsupportedOperationException();
      }
  
      // Change write ciphers, may use change_cipher_spec record.
<span class="line-modified">!     synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
              boolean useChangeCipherSpec) throws IOException {
<span class="line-modified">!         if (isClosed()) {</span>
<span class="line-modified">!             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">!                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified">!                     &quot;change_cipher_spec message&quot;);</span>
              }
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         if (useChangeCipherSpec) {</span>
<span class="line-modified">!             encodeChangeCipherSpec();</span>
<span class="line-modified">!         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-removed">-          * For PKCS11 ciphers, this will release any attached sessions,</span>
<span class="line-removed">-          * and thus make finalization faster.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * Since MAC&#39;s doFinal() is called for every SSL/TLS packet, it&#39;s</span>
<span class="line-removed">-          * not necessary to do the same with MAC&#39;s.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         writeCipher.dispose();</span>
  
<span class="line-modified">!         this.writeCipher = writeCipher;</span>
<span class="line-modified">!         this.isFirstAppOutputRecord = true;</span>
      }
  
      // Change write ciphers using key_update handshake message.
<span class="line-modified">!     synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
              byte keyUpdateRequest) throws IOException {
<span class="line-modified">!         if (isClosed()) {</span>
<span class="line-modified">!             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">!                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified">!                     &quot;key_update handshake message&quot;);</span>
              }
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         // encode the handshake message, KeyUpdate</span>
<span class="line-modified">!         byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();</span>
<span class="line-modified">!         hm[hm.length - 1] = keyUpdateRequest;</span>
<span class="line-modified">!         encodeHandshake(hm, 0, hm.length);</span>
<span class="line-modified">!         flush();</span>
  
<span class="line-modified">!         // Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-modified">!         writeCipher.dispose();</span>
  
<span class="line-modified">!         this.writeCipher = writeCipher;</span>
<span class="line-modified">!         this.isFirstAppOutputRecord = true;</span>
      }
  
<span class="line-modified">!     synchronized void changePacketSize(int packetSize) {</span>
<span class="line-modified">!         this.packetSize = packetSize;</span>
      }
  
<span class="line-modified">!     synchronized void changeFragmentSize(int fragmentSize) {</span>
<span class="line-modified">!         this.fragmentSize = fragmentSize;</span>
      }
  
<span class="line-modified">!     synchronized int getMaxPacketSize() {</span>
<span class="line-modified">!         return packetSize;</span>
      }
  
      // apply to DTLS SSLEngine
      void initHandshaker() {
          // blank
<span class="line-new-header">--- 164,97 ---</span>
      void setDeliverStream(OutputStream outputStream) {
          throw new UnsupportedOperationException();
      }
  
      // Change write ciphers, may use change_cipher_spec record.
<span class="line-modified">!     void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
              boolean useChangeCipherSpec) throws IOException {
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (isClosed()) {</span>
<span class="line-modified">!                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">+                         &quot;change_cipher_spec message&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return;</span>
              }
  
<span class="line-modified">!             if (useChangeCipherSpec) {</span>
<span class="line-modified">!                 encodeChangeCipherSpec();</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-added">+              * For PKCS11 ciphers, this will release any attached sessions,</span>
<span class="line-added">+              * and thus make finalization faster.</span>
<span class="line-added">+              *</span>
<span class="line-added">+              * Since MAC&#39;s doFinal() is called for every SSL/TLS packet, it&#39;s</span>
<span class="line-added">+              * not necessary to do the same with MAC&#39;s.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             writeCipher.dispose();</span>
<span class="line-added">+ </span>
<span class="line-added">+             this.writeCipher = writeCipher;</span>
<span class="line-added">+             this.isFirstAppOutputRecord = true;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      // Change write ciphers using key_update handshake message.
<span class="line-modified">!     void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
              byte keyUpdateRequest) throws IOException {
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (isClosed()) {</span>
<span class="line-modified">!                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">+                         &quot;key_update handshake message&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return;</span>
              }
  
<span class="line-modified">!             // encode the handshake message, KeyUpdate</span>
<span class="line-modified">!             byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();</span>
<span class="line-modified">!             hm[hm.length - 1] = keyUpdateRequest;</span>
<span class="line-modified">!             encodeHandshake(hm, 0, hm.length);</span>
<span class="line-modified">!             flush();</span>
  
<span class="line-modified">!             // Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-modified">!             writeCipher.dispose();</span>
  
<span class="line-modified">!             this.writeCipher = writeCipher;</span>
<span class="line-modified">!             this.isFirstAppOutputRecord = true;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     void changePacketSize(int packetSize) {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             this.packetSize = packetSize;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     void changeFragmentSize(int fragmentSize) {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             this.fragmentSize = fragmentSize;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     int getMaxPacketSize() {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return packetSize;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      // apply to DTLS SSLEngine
      void initHandshaker() {
          // blank
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,27 ***</span>
      void launchRetransmission() {
          // blank
      }
  
      @Override
<span class="line-modified">!     public synchronized void close() throws IOException {</span>
<span class="line-modified">!         if (isClosed) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         isClosed = true;</span>
<span class="line-modified">!         writeCipher.dispose();</span>
      }
  
      boolean isClosed() {
          return isClosed;
      }
  
      //
      // shared helpers
      //
  
      // Encrypt a fragment and wrap up a record.
      //
      // To be consistent with the spec of SSLEngine.wrap() methods, the
      // destination ByteBuffer&#39;s position is updated to reflect the amount
      // of data produced.  The limit remains the same.
<span class="line-new-header">--- 269,50 ---</span>
      void launchRetransmission() {
          // blank
      }
  
      @Override
<span class="line-modified">!     public void close() throws IOException {</span>
<span class="line-modified">!         recordLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (isClosed) {</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             isClosed = true;</span>
<span class="line-modified">!             writeCipher.dispose();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             recordLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      boolean isClosed() {
          return isClosed;
      }
  
      //
      // shared helpers
      //
  
<span class="line-added">+     private static final class T13PaddingHolder {</span>
<span class="line-added">+         private static final byte[] zeros = new byte[16];</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     int calculateFragmentSize(int fragmentLimit) {</span>
<span class="line-added">+         if (fragmentSize &gt; 0) {</span>
<span class="line-added">+             fragmentLimit = Math.min(fragmentLimit, fragmentSize);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added">+             // No negative integer checking as the fragment capacity should</span>
<span class="line-added">+             // have been ensured.</span>
<span class="line-added">+             return fragmentLimit -  T13PaddingHolder.zeros.length - 1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return fragmentLimit;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Encrypt a fragment and wrap up a record.
      //
      // To be consistent with the spec of SSLEngine.wrap() methods, the
      // destination ByteBuffer&#39;s position is updated to reflect the amount
      // of data produced.  The limit remains the same.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,12 ***</span>
              int headerOffset, int dstLim, int headerSize,
              ProtocolVersion protocolVersion) {
          if (!encCipher.isNullCipher()) {
              // inner plaintext, using zero length padding.
              int endOfPt = destination.limit();
<span class="line-modified">!             destination.limit(endOfPt + 1);</span>
<span class="line-modified">!             destination.put(endOfPt, contentType);</span>
          }
  
          // use the right TLSCiphertext.opaque_type and legacy_record_version
          ProtocolVersion pv = protocolVersion;
          if (!encCipher.isNullCipher()) {
<span class="line-new-header">--- 390,16 ---</span>
              int headerOffset, int dstLim, int headerSize,
              ProtocolVersion protocolVersion) {
          if (!encCipher.isNullCipher()) {
              // inner plaintext, using zero length padding.
              int endOfPt = destination.limit();
<span class="line-modified">!             int startOfPt = destination.position();</span>
<span class="line-modified">!             destination.position(endOfPt);</span>
<span class="line-added">+             destination.limit(endOfPt + 1 + T13PaddingHolder.zeros.length);</span>
<span class="line-added">+             destination.put(contentType);</span>
<span class="line-added">+             destination.put(T13PaddingHolder.zeros);</span>
<span class="line-added">+             destination.position(startOfPt);</span>
          }
  
          // use the right TLSCiphertext.opaque_type and legacy_record_version
          ProtocolVersion pv = protocolVersion;
          if (!encCipher.isNullCipher()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,14 ***</span>
          } else {
              return t10Encrypt(encCipher, contentType, headerSize);
          }
      }
  
<span class="line-removed">-     private static final class T13PaddingHolder {</span>
<span class="line-removed">-         private static final byte[] zeros = new byte[16];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private long t13Encrypt(
              SSLWriteCipher encCipher, byte contentType, int headerSize) {
          if (!encCipher.isNullCipher()) {
              // inner plaintext
              write(contentType);
<span class="line-new-header">--- 463,10 ---</span>
</pre>
<center><a href="NewSessionTicket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PostHandshakeContext.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-added"> 29 import java.io.UncheckedIOException;</span>
<span class="line-added"> 30 import java.lang.invoke.MethodHandle;</span>
<span class="line-added"> 31 import java.lang.invoke.MethodHandles;</span>
<span class="line-added"> 32 import java.lang.invoke.MethodHandles.Lookup;</span>
<span class="line-added"> 33 import java.lang.invoke.MethodType;</span>
<span class="line-added"> 34 import java.lang.invoke.VarHandle;</span>
 35 import java.net.DatagramPacket;
 36 import java.net.DatagramSocket;
<a name="3" id="anc3"></a>
 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.NetworkInterface;
<a name="4" id="anc4"></a><span class="line-added"> 40 import java.net.MulticastSocket;</span>
 41 import java.net.SocketAddress;
 42 import java.net.SocketException;
 43 import java.net.SocketOption;
<a name="5" id="anc5"></a>
 44 import java.net.StandardSocketOptions;
 45 import java.nio.ByteBuffer;
<a name="6" id="anc6"></a><span class="line-added"> 46 import java.nio.channels.AlreadyConnectedException;</span>
 47 import java.nio.channels.ClosedChannelException;
 48 import java.nio.channels.DatagramChannel;
<a name="7" id="anc7"></a><span class="line-modified"> 49 import java.nio.channels.MembershipKey;</span>
<span class="line-added"> 50 import java.security.AccessController;</span>
<span class="line-added"> 51 import java.security.PrivilegedAction;</span>
<span class="line-added"> 52 import java.security.PrivilegedExceptionAction;</span>
 53 import java.util.Objects;
<a name="8" id="anc8"></a><span class="line-added"> 54 import java.util.Set;</span>
<span class="line-added"> 55 import java.util.concurrent.locks.ReentrantLock;</span>
 56 
<a name="9" id="anc9"></a><span class="line-added"> 57 import static java.util.concurrent.TimeUnit.MILLISECONDS;</span>
 58 
<a name="10" id="anc10"></a><span class="line-modified"> 59 /**</span>
<span class="line-modified"> 60  * A multicast datagram socket based on a datagram channel.</span>
<span class="line-modified"> 61  *</span>
<span class="line-modified"> 62  * This class overrides every public method defined by java.net.DatagramSocket</span>
<span class="line-modified"> 63  * and java.net.MulticastSocket. The methods in this class are defined in exactly</span>
<span class="line-modified"> 64  * the same order as in java.net.DatagramSocket and java.net.MulticastSocket so</span>
<span class="line-modified"> 65  * as to simplify tracking changes.</span>
<span class="line-added"> 66  */</span>
 67 public class DatagramSocketAdaptor
<a name="11" id="anc11"></a><span class="line-modified"> 68     extends MulticastSocket</span>
 69 {
 70     // The channel being adapted
 71     private final DatagramChannelImpl dc;
 72 
 73     // Timeout &quot;option&quot; value for receives
 74     private volatile int timeout;
 75 
<a name="12" id="anc12"></a>
 76     private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
<a name="13" id="anc13"></a><span class="line-modified"> 77         super(/*SocketAddress*/null);</span>




 78         this.dc = dc;
 79     }
 80 
<a name="14" id="anc14"></a><span class="line-modified"> 81     static DatagramSocket create(DatagramChannelImpl dc) {</span>
 82         try {
 83             return new DatagramSocketAdaptor(dc);
<a name="15" id="anc15"></a><span class="line-modified"> 84         } catch (IOException e) {</span>
<span class="line-modified"> 85             throw new Error(e);</span>
 86         }
 87     }
 88 
<a name="16" id="anc16"></a><span class="line-modified"> 89     private void connectInternal(SocketAddress remote) throws SocketException {</span>








 90         try {
<a name="17" id="anc17"></a><span class="line-modified"> 91             dc.connect(remote, false); // skips check for already connected</span>
 92         } catch (ClosedChannelException e) {
 93             // ignore
 94         } catch (Exception x) {
 95             Net.translateToSocketException(x);
 96         }
 97     }
 98 
<a name="18" id="anc18"></a><span class="line-added"> 99     @Override</span>
100     public void bind(SocketAddress local) throws SocketException {
<a name="19" id="anc19"></a><span class="line-added">101         if (local != null) {</span>
<span class="line-added">102             local = Net.asInetSocketAddress(local);</span>
<span class="line-added">103         } else {</span>
<span class="line-added">104             local = new InetSocketAddress(0);</span>
<span class="line-added">105         }</span>
106         try {
<a name="20" id="anc20"></a>

107             dc.bind(local);
108         } catch (Exception x) {
109             Net.translateToSocketException(x);
110         }
111     }
112 
<a name="21" id="anc21"></a><span class="line-added">113     @Override</span>
114     public void connect(InetAddress address, int port) {
<a name="22" id="anc22"></a><span class="line-added">115         if (address == null)</span>
<span class="line-added">116             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
117         try {
118             connectInternal(new InetSocketAddress(address, port));
119         } catch (SocketException x) {
<a name="23" id="anc23"></a><span class="line-modified">120             throw new UncheckedIOException(x);</span>
121         }
122     }
123 
<a name="24" id="anc24"></a><span class="line-added">124     @Override</span>
125     public void connect(SocketAddress remote) throws SocketException {
<a name="25" id="anc25"></a><span class="line-modified">126         if (remote == null)</span>
<span class="line-modified">127             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
<span class="line-added">128         connectInternal(Net.asInetSocketAddress(remote));</span>
129     }
130 
<a name="26" id="anc26"></a><span class="line-added">131     @Override</span>
132     public void disconnect() {
133         try {
134             dc.disconnect();
135         } catch (IOException x) {
<a name="27" id="anc27"></a><span class="line-modified">136             throw new UncheckedIOException(x);</span>
137         }
138     }
139 
<a name="28" id="anc28"></a><span class="line-added">140     @Override</span>
141     public boolean isBound() {
142         return dc.localAddress() != null;
143     }
144 
<a name="29" id="anc29"></a><span class="line-added">145     @Override</span>
146     public boolean isConnected() {
147         return dc.remoteAddress() != null;
148     }
149 
<a name="30" id="anc30"></a><span class="line-added">150     @Override</span>
151     public InetAddress getInetAddress() {
152         InetSocketAddress remote = dc.remoteAddress();
153         return (remote != null) ? remote.getAddress() : null;
154     }
155 
<a name="31" id="anc31"></a><span class="line-added">156     @Override</span>
157     public int getPort() {
158         InetSocketAddress remote = dc.remoteAddress();
159         return (remote != null) ? remote.getPort() : -1;
160     }
161 
<a name="32" id="anc32"></a><span class="line-modified">162     @Override</span>
<span class="line-modified">163     public SocketAddress getRemoteSocketAddress() {</span>
<span class="line-modified">164         return dc.remoteAddress();</span>



























165     }
166 
<a name="33" id="anc33"></a><span class="line-modified">167     @Override</span>
<span class="line-modified">168     public SocketAddress getLocalSocketAddress() {</span>
<span class="line-added">169         try {</span>
<span class="line-added">170             return dc.getLocalAddress();</span>
<span class="line-added">171         } catch (ClosedChannelException e) {</span>
<span class="line-added">172             return null;</span>
<span class="line-added">173         } catch (Exception x) {</span>
<span class="line-added">174             throw new Error(x);</span>
<span class="line-added">175         }</span>
<span class="line-added">176     }</span>
177 
<a name="34" id="anc34"></a><span class="line-modified">178     @Override</span>
<span class="line-modified">179     public void send(DatagramPacket p) throws IOException {</span>
<span class="line-modified">180         ByteBuffer bb = null;</span>
<span class="line-modified">181         try {</span>
<span class="line-modified">182             InetSocketAddress target;</span>
<span class="line-modified">183             synchronized (p) {</span>
<span class="line-modified">184                 // copy bytes to temporary direct buffer</span>
<span class="line-modified">185                 int len = p.getLength();</span>
<span class="line-modified">186                 bb = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">187                 bb.put(p.getData(), p.getOffset(), len);</span>
<span class="line-added">188                 bb.flip();</span>
<span class="line-added">189 </span>
<span class="line-added">190                 // target address</span>
<span class="line-added">191                 if (p.getAddress() == null) {</span>
<span class="line-added">192                     InetSocketAddress remote = dc.remoteAddress();</span>
<span class="line-added">193                     if (remote == null) {</span>
<span class="line-added">194                         // not specified by DatagramSocket</span>
<span class="line-added">195                         throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added">196                     }</span>
<span class="line-added">197                     // set address/port to maintain compatibility with DatagramSocket</span>
<span class="line-added">198                     p.setAddress(remote.getAddress());</span>
<span class="line-added">199                     p.setPort(remote.getPort());</span>
<span class="line-added">200                     target = remote;</span>
<span class="line-added">201                 } else {</span>
<span class="line-added">202                     // throws IllegalArgumentException if port not set</span>
<span class="line-added">203                     target = (InetSocketAddress) p.getSocketAddress();</span>
204                 }
<a name="35" id="anc35"></a><span class="line-modified">205             }</span>
<span class="line-modified">206             // send datagram</span>
<span class="line-modified">207             try {</span>
<span class="line-added">208                 dc.blockingSend(bb, target);</span>
<span class="line-added">209             } catch (AlreadyConnectedException e) {</span>
<span class="line-added">210                 throw new IllegalArgumentException(&quot;Connected and packet address differ&quot;);</span>
<span class="line-added">211             } catch (ClosedChannelException e) {</span>
<span class="line-added">212                 var exc = new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">213                 exc.initCause(e);</span>
<span class="line-added">214                 throw exc;</span>
<span class="line-added">215             }</span>
<span class="line-added">216         } finally {</span>
<span class="line-added">217             if (bb != null) {</span>
<span class="line-added">218                 Util.offerFirstTemporaryDirectBuffer(bb);</span>
219             }
220         }
221     }
222 
<a name="36" id="anc36"></a><span class="line-added">223     @Override</span>
224     public void receive(DatagramPacket p) throws IOException {
<a name="37" id="anc37"></a><span class="line-modified">225         // get temporary direct buffer with a capacity of p.bufLength</span>
<span class="line-modified">226         int bufLength = DatagramPackets.getBufLength(p);</span>
<span class="line-modified">227         ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);</span>
<span class="line-modified">228         try {</span>
<span class="line-modified">229             long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-modified">230             SocketAddress sender = dc.blockingReceive(bb, nanos);</span>
<span class="line-modified">231             bb.flip();</span>
<span class="line-modified">232             synchronized (p) {</span>
<span class="line-modified">233                 // copy bytes to the DatagramPacket and set length</span>
<span class="line-modified">234                 int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));</span>
<span class="line-modified">235                 bb.get(p.getData(), p.getOffset(), len);</span>
<span class="line-modified">236                 DatagramPackets.setLength(p, len);</span>
<span class="line-modified">237 </span>
<span class="line-modified">238                 // sender address</span>
<span class="line-added">239                 p.setSocketAddress(sender);</span>
240             }
<a name="38" id="anc38"></a><span class="line-added">241         } catch (ClosedChannelException e) {</span>
<span class="line-added">242             var exc = new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">243             exc.initCause(e);</span>
<span class="line-added">244             throw exc;</span>
<span class="line-added">245         } finally {</span>
<span class="line-added">246             Util.offerFirstTemporaryDirectBuffer(bb);</span>
247         }
248     }
249 
<a name="39" id="anc39"></a><span class="line-added">250     @Override</span>
251     public InetAddress getLocalAddress() {
252         if (isClosed())
253             return null;
254         InetSocketAddress local = dc.localAddress();
255         if (local == null)
256             local = new InetSocketAddress(0);
257         InetAddress result = local.getAddress();
258         SecurityManager sm = System.getSecurityManager();
259         if (sm != null) {
260             try {
261                 sm.checkConnect(result.getHostAddress(), -1);
262             } catch (SecurityException x) {
263                 return new InetSocketAddress(0).getAddress();
264             }
265         }
266         return result;
267     }
268 
<a name="40" id="anc40"></a><span class="line-added">269     @Override</span>
270     public int getLocalPort() {
271         if (isClosed())
272             return -1;
<a name="41" id="anc41"></a><span class="line-modified">273         InetSocketAddress local = dc.localAddress();</span>
<span class="line-modified">274         if (local != null) {</span>
<span class="line-modified">275             return local.getPort();</span>



276         }
277         return 0;
278     }
279 
<a name="42" id="anc42"></a><span class="line-added">280     @Override</span>
281     public void setSoTimeout(int timeout) throws SocketException {
<a name="43" id="anc43"></a><span class="line-added">282         if (isClosed())</span>
<span class="line-added">283             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">284         if (timeout &lt; 0)</span>
<span class="line-added">285             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
286         this.timeout = timeout;
287     }
288 
<a name="44" id="anc44"></a><span class="line-added">289     @Override</span>
290     public int getSoTimeout() throws SocketException {
<a name="45" id="anc45"></a><span class="line-added">291         if (isClosed())</span>
<span class="line-added">292             throw new SocketException(&quot;Socket is closed&quot;);</span>
293         return timeout;
294     }
295 
296     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
297         throws SocketException
298     {
299         try {
300             dc.setOption(name, value);
301         } catch (IOException x) {
302             Net.translateToSocketException(x);
303         }
304     }
305 
306     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
307         throws SocketException
308     {
309         try {
310             dc.setOption(name, value);
311         } catch (IOException x) {
312             Net.translateToSocketException(x);
313         }
314     }
315 
316     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
317         try {
318             return dc.getOption(name).booleanValue();
319         } catch (IOException x) {
320             Net.translateToSocketException(x);
321             return false;       // keep compiler happy
322         }
323     }
324 
325     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
326         try {
327             return dc.getOption(name).intValue();
328         } catch (IOException x) {
329             Net.translateToSocketException(x);
330             return -1;          // keep compiler happy
331         }
332     }
333 
<a name="46" id="anc46"></a><span class="line-added">334     @Override</span>
335     public void setSendBufferSize(int size) throws SocketException {
336         if (size &lt;= 0)
337             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
338         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
339     }
340 
<a name="47" id="anc47"></a><span class="line-added">341     @Override</span>
342     public int getSendBufferSize() throws SocketException {
343         return getIntOption(StandardSocketOptions.SO_SNDBUF);
344     }
345 
<a name="48" id="anc48"></a><span class="line-added">346     @Override</span>
347     public void setReceiveBufferSize(int size) throws SocketException {
348         if (size &lt;= 0)
349             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
350         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
351     }
352 
<a name="49" id="anc49"></a><span class="line-added">353     @Override</span>
354     public int getReceiveBufferSize() throws SocketException {
355         return getIntOption(StandardSocketOptions.SO_RCVBUF);
356     }
357 
<a name="50" id="anc50"></a><span class="line-added">358     @Override</span>
359     public void setReuseAddress(boolean on) throws SocketException {
360         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
361     }
362 
<a name="51" id="anc51"></a><span class="line-added">363     @Override</span>
364     public boolean getReuseAddress() throws SocketException {
365         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
<a name="52" id="anc52"></a>
366     }
367 
<a name="53" id="anc53"></a><span class="line-added">368     @Override</span>
369     public void setBroadcast(boolean on) throws SocketException {
370         setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
371     }
372 
<a name="54" id="anc54"></a><span class="line-added">373     @Override</span>
374     public boolean getBroadcast() throws SocketException {
375         return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
376     }
377 
<a name="55" id="anc55"></a><span class="line-added">378     @Override</span>
379     public void setTrafficClass(int tc) throws SocketException {
380         setIntOption(StandardSocketOptions.IP_TOS, tc);
381     }
382 
<a name="56" id="anc56"></a><span class="line-added">383     @Override</span>
384     public int getTrafficClass() throws SocketException {
385         return getIntOption(StandardSocketOptions.IP_TOS);
386     }
387 
<a name="57" id="anc57"></a><span class="line-added">388     @Override</span>
389     public void close() {
390         try {
391             dc.close();
392         } catch (IOException x) {
393             throw new Error(x);
394         }
395     }
396 
<a name="58" id="anc58"></a><span class="line-added">397     @Override</span>
398     public boolean isClosed() {
399         return !dc.isOpen();
400     }
401 
<a name="59" id="anc59"></a><span class="line-added">402     @Override</span>
403     public DatagramChannel getChannel() {
404         return dc;
405     }
406 
<a name="60" id="anc60"></a><span class="line-modified">407     @Override</span>
<span class="line-modified">408     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-modified">409         dc.setOption(name, value);</span>
<span class="line-modified">410         return this;</span>
<span class="line-modified">411     }</span>




412 
<a name="61" id="anc61"></a><span class="line-modified">413     @Override</span>
<span class="line-added">414     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">415         return dc.getOption(name);</span>
<span class="line-added">416     }</span>
417 
<a name="62" id="anc62"></a><span class="line-modified">418     @Override</span>
<span class="line-added">419     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">420         return dc.supportedOptions();</span>
<span class="line-added">421     }</span>
422 
<a name="63" id="anc63"></a><span class="line-modified">423     // -- java.net.MulticastSocket --</span>
424 
<a name="64" id="anc64"></a><span class="line-modified">425     // used to coordinate changing TTL with the deprecated send method</span>
<span class="line-added">426     private final ReentrantLock sendLock = new ReentrantLock();</span>
427 
<a name="65" id="anc65"></a><span class="line-modified">428     // cached outgoing interface (for use by setInterface/getInterface)</span>
<span class="line-added">429     private final Object outgoingInterfaceLock = new Object();</span>
<span class="line-added">430     private NetworkInterface outgoingNetworkInterface;</span>
<span class="line-added">431     private InetAddress outgoingInetAddress;</span>
432 
<a name="66" id="anc66"></a><span class="line-modified">433     @Override</span>
<span class="line-modified">434     @Deprecated</span>
<span class="line-added">435     public void setTTL(byte ttl) throws IOException {</span>
<span class="line-added">436         setTimeToLive(Byte.toUnsignedInt(ttl));</span>
<span class="line-added">437     }</span>
438 
<a name="67" id="anc67"></a><span class="line-modified">439     @Override</span>
<span class="line-modified">440     public void setTimeToLive(int ttl) throws IOException {</span>
<span class="line-added">441         sendLock.lock();</span>
<span class="line-added">442         try {</span>
<span class="line-added">443             setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);</span>
<span class="line-added">444         } finally {</span>
<span class="line-added">445             sendLock.unlock();</span>
<span class="line-added">446         }</span>
<span class="line-added">447     }</span>
448 
<a name="68" id="anc68"></a><span class="line-modified">449     @Override</span>
<span class="line-added">450     @Deprecated</span>
<span class="line-added">451     public byte getTTL() throws IOException {</span>
<span class="line-added">452         return (byte) getTimeToLive();</span>
<span class="line-added">453     }</span>
454 
<a name="69" id="anc69"></a><span class="line-modified">455     @Override</span>
<span class="line-added">456     public int getTimeToLive() throws IOException {</span>
<span class="line-added">457         sendLock.lock();</span>
<span class="line-added">458         try {</span>
<span class="line-added">459             return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);</span>
<span class="line-added">460         } finally {</span>
<span class="line-added">461             sendLock.unlock();</span>
<span class="line-added">462         }</span>
<span class="line-added">463     }</span>
464 
<a name="70" id="anc70"></a><span class="line-modified">465     @Override</span>
<span class="line-added">466     @Deprecated</span>
<span class="line-added">467     public void joinGroup(InetAddress group) throws IOException {</span>
<span class="line-added">468         Objects.requireNonNull(group);</span>
<span class="line-added">469         try {</span>
<span class="line-added">470             joinGroup(new InetSocketAddress(group, 0), null);</span>
<span class="line-added">471         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">472             // 1-arg joinGroup does not specify IllegalArgumentException</span>
<span class="line-added">473             throw (SocketException) new SocketException(&quot;joinGroup failed&quot;).initCause(iae);</span>
<span class="line-added">474         }</span>
<span class="line-added">475     }</span>
476 
<a name="71" id="anc71"></a><span class="line-modified">477     @Override</span>
<span class="line-added">478     @Deprecated</span>
<span class="line-added">479     public void leaveGroup(InetAddress group) throws IOException {</span>
<span class="line-added">480         Objects.requireNonNull(group);</span>
<span class="line-added">481         try {</span>
<span class="line-added">482             leaveGroup(new InetSocketAddress(group, 0), null);</span>
<span class="line-added">483         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">484             // 1-arg leaveGroup does not specify IllegalArgumentException</span>
<span class="line-added">485             throw (SocketException) new SocketException(&quot;leaveGroup failed&quot;).initCause(iae);</span>
<span class="line-added">486         }</span>
<span class="line-added">487     }</span>
488 
<a name="72" id="anc72"></a><span class="line-modified">489     /**</span>
<span class="line-modified">490      * Checks a SocketAddress to ensure that it is a multicast address.</span>
<span class="line-added">491      *</span>
<span class="line-added">492      * @return the multicast group</span>
<span class="line-added">493      * @throws IllegalArgumentException if group is null, an unsupported address</span>
<span class="line-added">494      *         type, or an unresolved address</span>
<span class="line-added">495      * @throws SocketException if group is not a multicast address</span>
<span class="line-added">496      */</span>
<span class="line-added">497     private static InetAddress checkGroup(SocketAddress mcastaddr) throws SocketException {</span>
<span class="line-added">498         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="line-added">499             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-added">500         InetAddress group = ((InetSocketAddress) mcastaddr).getAddress();</span>
<span class="line-added">501         if (group == null)</span>
<span class="line-added">502             throw new IllegalArgumentException(&quot;Unresolved address&quot;);</span>
<span class="line-added">503         if (!group.isMulticastAddress())</span>
<span class="line-added">504             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-added">505         return group;</span>
<span class="line-added">506     }</span>
<span class="line-added">507 </span>
<span class="line-added">508     @Override</span>
<span class="line-added">509     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {</span>
<span class="line-added">510         InetAddress group = checkGroup(mcastaddr);</span>
<span class="line-added">511         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();</span>
<span class="line-added">512         if (isClosed())</span>
<span class="line-added">513             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">514         synchronized (this) {</span>
<span class="line-added">515             MembershipKey key = dc.findMembership(group, ni);</span>
<span class="line-added">516             if (key != null) {</span>
<span class="line-added">517                 // already a member but need to check permission anyway</span>
<span class="line-added">518                 SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">519                 if (sm != null)</span>
<span class="line-added">520                     sm.checkMulticast(group);</span>
<span class="line-added">521                 throw new SocketException(&quot;Already a member of group&quot;);</span>
<span class="line-added">522             }</span>
<span class="line-added">523             dc.join(group, ni);  // checks permission</span>
<span class="line-added">524         }</span>
<span class="line-added">525     }</span>
<span class="line-added">526 </span>
<span class="line-added">527     @Override</span>
<span class="line-added">528     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {</span>
<span class="line-added">529         InetAddress group = checkGroup(mcastaddr);</span>
<span class="line-added">530         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();</span>
<span class="line-added">531         if (isClosed())</span>
<span class="line-added">532             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">533         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">534         if (sm != null)</span>
<span class="line-added">535             sm.checkMulticast(group);</span>
<span class="line-added">536         synchronized (this) {</span>
<span class="line-added">537             MembershipKey key = dc.findMembership(group, ni);</span>
<span class="line-added">538             if (key == null)</span>
<span class="line-added">539                 throw new SocketException(&quot;Not a member of group&quot;);</span>
<span class="line-added">540             key.drop();</span>
<span class="line-added">541         }</span>
<span class="line-added">542     }</span>
<span class="line-added">543 </span>
<span class="line-added">544     @Override</span>
<span class="line-added">545     @Deprecated</span>
<span class="line-added">546     public void setInterface(InetAddress inf) throws SocketException {</span>
<span class="line-added">547         if (inf == null)</span>
<span class="line-added">548             throw new SocketException(&quot;Invalid value &#39;null&#39;&quot;);</span>
<span class="line-added">549         NetworkInterface ni = NetworkInterface.getByInetAddress(inf);</span>
<span class="line-added">550         if (ni == null) {</span>
<span class="line-added">551             String address = inf.getHostAddress();</span>
<span class="line-added">552             throw new SocketException(&quot;No network interface with address &quot; + address);</span>
<span class="line-added">553         }</span>
<span class="line-added">554         synchronized (outgoingInterfaceLock) {</span>
<span class="line-added">555             // set interface and update cached values</span>
<span class="line-added">556             setNetworkInterface(ni);</span>
<span class="line-added">557             outgoingNetworkInterface = ni;</span>
<span class="line-added">558             outgoingInetAddress = inf;</span>
<span class="line-added">559         }</span>
<span class="line-added">560     }</span>
<span class="line-added">561 </span>
<span class="line-added">562     @Override</span>
<span class="line-added">563     @Deprecated</span>
<span class="line-added">564     public InetAddress getInterface() throws SocketException {</span>
<span class="line-added">565         synchronized (outgoingInterfaceLock) {</span>
<span class="line-added">566             NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">567             if (ni != null) {</span>
<span class="line-added">568                 if (ni.equals(outgoingNetworkInterface)) {</span>
<span class="line-added">569                     return outgoingInetAddress;</span>
<span class="line-added">570                 } else {</span>
<span class="line-added">571                     // network interface has changed so update cached values</span>
<span class="line-added">572                     PrivilegedAction&lt;InetAddress&gt; pa;</span>
<span class="line-added">573                     pa = () -&gt; ni.inetAddresses().findFirst().orElse(null);</span>
<span class="line-added">574                     InetAddress ia = AccessController.doPrivileged(pa);</span>
<span class="line-added">575                     if (ia == null)</span>
<span class="line-added">576                         throw new SocketException(&quot;Network interface has no IP address&quot;);</span>
<span class="line-added">577                     outgoingNetworkInterface = ni;</span>
<span class="line-added">578                     outgoingInetAddress = ia;</span>
<span class="line-added">579                     return ia;</span>
<span class="line-added">580                 }</span>
<span class="line-added">581             }</span>
<span class="line-added">582         }</span>
<span class="line-added">583 </span>
<span class="line-added">584         // no interface set</span>
<span class="line-added">585         return anyInetAddress();</span>
<span class="line-added">586     }</span>
<span class="line-added">587 </span>
<span class="line-added">588     @Override</span>
<span class="line-added">589     public void setNetworkInterface(NetworkInterface netIf) throws SocketException {</span>
<span class="line-added">590         try {</span>
<span class="line-added">591             setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf);</span>
<span class="line-added">592         } catch (IOException e) {</span>
<span class="line-added">593             Net.translateToSocketException(e);</span>
<span class="line-added">594         }</span>
<span class="line-added">595     }</span>
<span class="line-added">596 </span>
<span class="line-added">597     @Override</span>
<span class="line-added">598     public NetworkInterface getNetworkInterface() throws SocketException {</span>
<span class="line-added">599         NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">600         if (ni == null) {</span>
<span class="line-added">601             // return NetworkInterface with index == 0 as placeholder</span>
<span class="line-added">602             ni = anyNetworkInterface();</span>
<span class="line-added">603         }</span>
<span class="line-added">604         return ni;</span>
<span class="line-added">605     }</span>
<span class="line-added">606 </span>
<span class="line-added">607     @Override</span>
<span class="line-added">608     @Deprecated</span>
<span class="line-added">609     public void setLoopbackMode(boolean disable) throws SocketException {</span>
<span class="line-added">610         boolean enable = !disable;</span>
<span class="line-added">611         setBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP, enable);</span>
<span class="line-added">612     }</span>
<span class="line-added">613 </span>
<span class="line-added">614     @Override</span>
<span class="line-added">615     @Deprecated</span>
<span class="line-added">616     public boolean getLoopbackMode() throws SocketException {</span>
<span class="line-added">617         boolean enabled = getBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">618         return !enabled;</span>
<span class="line-added">619     }</span>
620 
<a name="73" id="anc73"></a><span class="line-modified">621     @Override</span>
<span class="line-modified">622     @Deprecated</span>
<span class="line-added">623     public void send(DatagramPacket p, byte ttl) throws IOException {</span>
<span class="line-added">624         sendLock.lock();</span>
<span class="line-added">625         try {</span>
<span class="line-added">626             int oldValue = getTimeToLive();</span>
<span class="line-added">627             try {</span>
<span class="line-added">628                 setTTL(ttl);</span>
<span class="line-added">629                 send(p);</span>
<span class="line-added">630             } finally {</span>
<span class="line-added">631                 setTimeToLive(oldValue);</span>
<span class="line-added">632             }</span>
<span class="line-added">633         } finally {</span>
<span class="line-added">634             sendLock.unlock();</span>
<span class="line-added">635         }</span>
<span class="line-added">636     }</span>
<span class="line-added">637 </span>
<span class="line-added">638     /**</span>
<span class="line-added">639      * Returns the outgoing NetworkInterface or null if not set.</span>
<span class="line-added">640      */</span>
<span class="line-added">641     private NetworkInterface outgoingNetworkInterface() throws SocketException {</span>
<span class="line-added">642         try {</span>
<span class="line-added">643             return getOption(StandardSocketOptions.IP_MULTICAST_IF);</span>
<span class="line-added">644         } catch (IOException e) {</span>
<span class="line-added">645             Net.translateToSocketException(e);</span>
<span class="line-added">646             return null; // keep compiler happy</span>
<span class="line-added">647         }</span>
<span class="line-added">648     }</span>
<span class="line-added">649 </span>
<span class="line-added">650     /**</span>
<span class="line-added">651      * Returns the default NetworkInterface to use when joining or leaving a</span>
<span class="line-added">652      * multicast group and a network interface is not specified.</span>
<span class="line-added">653      * This method will return the outgoing NetworkInterface if set, otherwise</span>
<span class="line-added">654      * the result of NetworkInterface.getDefault(), otherwise a NetworkInterface</span>
<span class="line-added">655      * with index == 0 as a placeholder for &quot;any network interface&quot;.</span>
<span class="line-added">656      */</span>
<span class="line-added">657     private NetworkInterface defaultNetworkInterface() throws SocketException {</span>
<span class="line-added">658         NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">659         if (ni == null)</span>
<span class="line-added">660             ni = NetworkInterfaces.getDefault();   // macOS</span>
<span class="line-added">661         if (ni == null)</span>
<span class="line-added">662             ni = anyNetworkInterface();</span>
<span class="line-added">663         return ni;</span>
<span class="line-added">664     }</span>
<span class="line-added">665 </span>
<span class="line-added">666     /**</span>
<span class="line-added">667      * Returns the placeholder for &quot;any network interface&quot;, its index is 0.</span>
<span class="line-added">668      */</span>
<span class="line-added">669     private NetworkInterface anyNetworkInterface() {</span>
<span class="line-added">670         InetAddress[] addrs = new InetAddress[1];</span>
<span class="line-added">671         addrs[0] = anyInetAddress();</span>
<span class="line-added">672         return NetworkInterfaces.newNetworkInterface(addrs[0].getHostName(), 0, addrs);</span>
<span class="line-added">673     }</span>
<span class="line-added">674 </span>
<span class="line-added">675     /**</span>
<span class="line-added">676      * Returns the InetAddress representing anyLocalAddress.</span>
<span class="line-added">677      */</span>
<span class="line-added">678     private InetAddress anyInetAddress() {</span>
<span class="line-added">679         return new InetSocketAddress(0).getAddress();</span>
<span class="line-added">680     }</span>
<span class="line-added">681 </span>
<span class="line-added">682     /**</span>
<span class="line-added">683      * Defines static methods to get/set DatagramPacket fields and workaround</span>
<span class="line-added">684      * DatagramPacket deficiencies.</span>
<span class="line-added">685      */</span>
<span class="line-added">686     private static class DatagramPackets {</span>
<span class="line-added">687         private static final VarHandle LENGTH;</span>
<span class="line-added">688         private static final VarHandle BUF_LENGTH;</span>
<span class="line-added">689         static {</span>
<span class="line-added">690             try {</span>
<span class="line-added">691                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;</span>
<span class="line-added">692                     MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());</span>
<span class="line-added">693                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);</span>
<span class="line-added">694                 LENGTH = l.findVarHandle(DatagramPacket.class, &quot;length&quot;, int.class);</span>
<span class="line-added">695                 BUF_LENGTH = l.findVarHandle(DatagramPacket.class, &quot;bufLength&quot;, int.class);</span>
<span class="line-added">696             } catch (Exception e) {</span>
<span class="line-added">697                 throw new ExceptionInInitializerError(e);</span>
<span class="line-added">698             }</span>
<span class="line-added">699         }</span>
<span class="line-added">700 </span>
<span class="line-added">701         /**</span>
<span class="line-added">702          * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be</span>
<span class="line-added">703          * used at this time because it sets both the length and bufLength fields.</span>
<span class="line-added">704          */</span>
<span class="line-added">705         static void setLength(DatagramPacket p, int value) {</span>
<span class="line-added">706             synchronized (p) {</span>
<span class="line-added">707                 LENGTH.set(p, value);</span>
<span class="line-added">708             }</span>
<span class="line-added">709         }</span>
710 
<a name="74" id="anc74"></a><span class="line-modified">711         /**</span>
<span class="line-added">712          * Returns the value of the DatagramPacket.bufLength field.</span>
<span class="line-added">713          */</span>
<span class="line-added">714         static int getBufLength(DatagramPacket p) {</span>
<span class="line-added">715             synchronized (p) {</span>
<span class="line-added">716                 return (int) BUF_LENGTH.get(p);</span>
<span class="line-added">717             }</span>
<span class="line-added">718         }</span>
<span class="line-added">719     }</span>
720 
<a name="75" id="anc75"></a><span class="line-modified">721     /**</span>
<span class="line-added">722      * Defines static methods to invoke non-public NetworkInterface methods.</span>
<span class="line-added">723      */</span>
<span class="line-added">724     private static class NetworkInterfaces {</span>
<span class="line-added">725         static final MethodHandle GET_DEFAULT;</span>
<span class="line-added">726         static final MethodHandle CONSTRUCTOR;</span>
<span class="line-added">727         static {</span>
<span class="line-added">728             try {</span>
<span class="line-added">729                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;</span>
<span class="line-added">730                     MethodHandles.privateLookupIn(NetworkInterface.class, MethodHandles.lookup());</span>
<span class="line-added">731                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);</span>
<span class="line-added">732                 MethodType methodType = MethodType.methodType(NetworkInterface.class);</span>
<span class="line-added">733                 GET_DEFAULT = l.findStatic(NetworkInterface.class, &quot;getDefault&quot;, methodType);</span>
<span class="line-added">734                 methodType = MethodType.methodType(void.class, String.class, int.class, InetAddress[].class);</span>
<span class="line-added">735                 CONSTRUCTOR = l.findConstructor(NetworkInterface.class, methodType);</span>
<span class="line-added">736             } catch (Exception e) {</span>
<span class="line-added">737                 throw new ExceptionInInitializerError(e);</span>
<span class="line-added">738             }</span>
<span class="line-added">739         }</span>
740 
<a name="76" id="anc76"></a><span class="line-modified">741         /**</span>
<span class="line-modified">742          * Returns the default network interface or null.</span>
<span class="line-modified">743          */</span>
<span class="line-added">744         static NetworkInterface getDefault() {</span>
<span class="line-added">745             try {</span>
<span class="line-added">746                 return (NetworkInterface) GET_DEFAULT.invokeExact();</span>
<span class="line-added">747             } catch (Throwable e) {</span>
<span class="line-added">748                 throw new InternalError(e);</span>
<span class="line-added">749             }</span>
<span class="line-added">750         }</span>
<span class="line-added">751 </span>
<span class="line-added">752         /**</span>
<span class="line-added">753          * Creates a NetworkInterface with the given name index and addresses.</span>
<span class="line-added">754          */</span>
<span class="line-added">755         static NetworkInterface newNetworkInterface(String name, int index, InetAddress[] addrs) {</span>
<span class="line-added">756             try {</span>
<span class="line-added">757                 return (NetworkInterface) CONSTRUCTOR.invoke(name, index, addrs);</span>
<span class="line-added">758             } catch (Throwable e) {</span>
<span class="line-added">759                 throw new InternalError(e);</span>
<span class="line-added">760             }</span>
<span class="line-added">761         }</span>
<span class="line-added">762     }</span>
<span class="line-added">763 }</span>
<a name="77" id="anc77"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="77" type="hidden" />
</body>
</html>
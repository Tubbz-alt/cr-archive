diff a/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java b/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java
--- a/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java
+++ b/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -37,15 +37,11 @@
 import java.util.List;
 import java.util.Locale;
 import javax.net.ssl.SSLProtocolException;
 import sun.security.provider.certpath.OCSPResponse;
 import sun.security.provider.certpath.ResponderId;
-import static sun.security.ssl.SSLExtension.CH_STATUS_REQUEST;
-import static sun.security.ssl.SSLExtension.CH_STATUS_REQUEST_V2;
 import sun.security.ssl.SSLExtension.ExtensionConsumer;
-import static sun.security.ssl.SSLExtension.SH_STATUS_REQUEST;
-import static sun.security.ssl.SSLExtension.SH_STATUS_REQUEST_V2;
 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 import sun.security.util.DerInputStream;
 import sun.security.util.DerValue;
 import sun.security.util.HexDumpEncoder;
@@ -432,12 +428,13 @@
                     if (isFirst) {
                         isFirst = false;
                     } else {
                         extBuilder.append(",\n");
                     }
-                    extBuilder.append(
-                            "{\n" + Utilities.indent(ext.toString()) + "}");
+                    extBuilder.append("{\n").
+                            append(Utilities.indent(ext.toString())).
+                            append("}");
                 }
 
                 extsStr = extBuilder.toString();
             }
 
@@ -550,15 +547,15 @@
 
             if (!chc.sslContext.isStaplingEnabled(true)) {
                 return null;
             }
 
-            if (!chc.sslConfig.isAvailable(CH_STATUS_REQUEST)) {
+            if (!chc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {
                 if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                     SSLLogger.fine(
                         "Ignore unavailable extension: " +
-                        CH_STATUS_REQUEST.name);
+                        SSLExtension.CH_STATUS_REQUEST.name);
                 }
                 return null;
             }
 
             // Produce the extension.
@@ -566,12 +563,12 @@
             // We are using empty OCSPStatusRequest at present. May extend to
             // support specific responder or extensions later.
             byte[] extData = new byte[] {0x01, 0x00, 0x00, 0x00, 0x00};
 
             // Update the context.
-            chc.handshakeExtensions.put(
-                    CH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);
+            chc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST,
+                    CertStatusRequestSpec.DEFAULT);
 
             return extData;
         }
     }
 
@@ -591,14 +588,14 @@
             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 
             // The consuming happens in server side only.
             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 
-            if (!shc.sslConfig.isAvailable(CH_STATUS_REQUEST)) {
+            if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {
                 if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                     SSLLogger.fine("Ignore unavailable extension: " +
-                        CH_STATUS_REQUEST.name);
+                        SSLExtension.CH_STATUS_REQUEST.name);
                 }
                 return;     // ignore the extension
             }
 
             // Parse the extension.
@@ -608,11 +605,11 @@
             } catch (IOException ioe) {
                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
             }
 
             // Update the context.
-            shc.handshakeExtensions.put(CH_STATUS_REQUEST, spec);
+            shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST, spec);
             if (!shc.isResumption &&
                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
                     SSLHandshake.CERTIFICATE_STATUS);
             }   // Otherwise, the certificate status presents in server cert.
@@ -652,17 +649,16 @@
                 return null;    // Do not produce status_request in ServerHello
             }
 
             // In response to "status_request" extension request only.
             CertStatusRequestSpec spec = (CertStatusRequestSpec)
-                    shc.handshakeExtensions.get(CH_STATUS_REQUEST);
+                    shc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST);
             if (spec == null) {
                 // Ignore, no status_request extension requested.
                 if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
-                    SSLLogger.finest(
-                        "Ignore unavailable extension: " +
-                        CH_STATUS_REQUEST.name);
+                    SSLLogger.finest("Ignore unavailable extension: " +
+                        SSLExtension.CH_STATUS_REQUEST.name);
                 }
 
                 return null;        // ignore the extension
             }
 
@@ -679,12 +675,12 @@
             // The "extension_data" in the extended ServerHello handshake
             // message MUST be empty.
             byte[] extData = new byte[0];
 
             // Update the context.
-            shc.handshakeExtensions.put(
-                    SH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);
+            shc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST,
+                    CertStatusRequestSpec.DEFAULT);
 
             return extData;
         }
     }
 
@@ -706,11 +702,11 @@
             // The producing happens in client side only.
             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 
             // In response to "status_request" extension request only.
             CertStatusRequestSpec requestedCsr = (CertStatusRequestSpec)
-                    chc.handshakeExtensions.get(CH_STATUS_REQUEST);
+                    chc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST);
             if (requestedCsr == null) {
                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
                     "Unexpected status_request extension in ServerHello");
             }
 
@@ -720,18 +716,20 @@
                   "Invalid status_request extension in ServerHello message: " +
                   "the extension data must be empty");
             }
 
             // Update the context.
-            chc.handshakeExtensions.put(
-                    SH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);
-            chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
-                    SSLHandshake.CERTIFICATE_STATUS);
+            chc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST,
+                    CertStatusRequestSpec.DEFAULT);
 
             // Since we've received a legitimate status_request in the
             // ServerHello, stapling is active if it's been enabled.
             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
+            if (chc.staplingActive) {
+                chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
+                    SSLHandshake.CERTIFICATE_STATUS);
+            }
 
             // No impact on session resumption.
         }
     }
 
@@ -905,11 +903,11 @@
 
             if (!chc.sslContext.isStaplingEnabled(true)) {
                 return null;
             }
 
-            if (!chc.sslConfig.isAvailable(CH_STATUS_REQUEST_V2)) {
+            if (!chc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {
                 if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                     SSLLogger.finest(
                         "Ignore unavailable status_request_v2 extension");
                 }
 
@@ -922,12 +920,12 @@
             // support specific responder or extensions later.
             byte[] extData = new byte[] {
                 0x00, 0x07, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00};
 
             // Update the context.
-            chc.handshakeExtensions.put(
-                    CH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);
+            chc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
+                    CertStatusRequestV2Spec.DEFAULT);
 
             return extData;
         }
     }
 
@@ -947,11 +945,11 @@
             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 
             // The consuming happens in server side only.
             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 
-            if (!shc.sslConfig.isAvailable(CH_STATUS_REQUEST_V2)) {
+            if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {
                 if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                     SSLLogger.finest(
                         "Ignore unavailable status_request_v2 extension");
                 }
 
@@ -965,11 +963,12 @@
             } catch (IOException ioe) {
                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
             }
 
             // Update the context.
-            shc.handshakeExtensions.put(CH_STATUS_REQUEST_V2, spec);
+            shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
+                    spec);
             if (!shc.isResumption) {
                 shc.handshakeProducers.putIfAbsent(
                         SSLHandshake.CERTIFICATE_STATUS.id,
                         SSLHandshake.CERTIFICATE_STATUS);
             }
@@ -1009,11 +1008,11 @@
                 return null;    // Do not produce status_request_v2 in SH
             }
 
             // In response to "status_request_v2" extension request only
             CertStatusRequestV2Spec spec = (CertStatusRequestV2Spec)
-                    shc.handshakeExtensions.get(CH_STATUS_REQUEST_V2);
+                shc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST_V2);
             if (spec == null) {
                 // Ignore, no status_request_v2 extension requested.
                 if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
                     SSLLogger.finest(
                         "Ignore unavailable status_request_v2 extension");
@@ -1034,12 +1033,12 @@
             // The "extension_data" in the extended ServerHello handshake
             // message MUST be empty.
             byte[] extData = new byte[0];
 
             // Update the context.
-            shc.handshakeExtensions.put(
-                    SH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);
+            shc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST_V2,
+                    CertStatusRequestV2Spec.DEFAULT);
 
             return extData;
         }
     }
 
@@ -1061,11 +1060,11 @@
             // The consumption happens in client side only.
             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 
             // In response to "status_request" extension request only
             CertStatusRequestV2Spec requestedCsr = (CertStatusRequestV2Spec)
-                    chc.handshakeExtensions.get(CH_STATUS_REQUEST_V2);
+                chc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST_V2);
             if (requestedCsr == null) {
                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
                     "Unexpected status_request_v2 extension in ServerHello");
             }
 
@@ -1075,18 +1074,22 @@
                   "Invalid status_request_v2 extension in ServerHello: " +
                   "the extension data must be empty");
             }
 
             // Update the context.
-            chc.handshakeExtensions.put(
-                    SH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);
-            chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
-                    SSLHandshake.CERTIFICATE_STATUS);
+            chc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST_V2,
+                    CertStatusRequestV2Spec.DEFAULT);
 
             // Since we've received a legitimate status_request in the
-            // ServerHello, stapling is active if it's been enabled.
+            // ServerHello, stapling is active if it's been enabled.  If it
+            // is active, make sure we add the CertificateStatus message
+            // consumer.
             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
+            if (chc.staplingActive) {
+                chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
+                    SSLHandshake.CERTIFICATE_STATUS);
+            }
 
             // No impact on session resumption.
         }
     }
 

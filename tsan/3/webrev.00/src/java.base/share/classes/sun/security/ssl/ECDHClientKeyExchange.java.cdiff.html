<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DTLSOutputRecord.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHKeyExchange.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,37 ***</span>
  
  package sun.security.ssl;
  
  import java.io.IOException;
  import java.nio.ByteBuffer;
<span class="line-removed">- import java.security.AlgorithmConstraints;</span>
<span class="line-removed">- import java.security.CryptoPrimitive;</span>
  import java.security.GeneralSecurityException;
<span class="line-removed">- import java.security.KeyFactory;</span>
<span class="line-removed">- import java.security.PrivateKey;</span>
  import java.security.PublicKey;
<span class="line-removed">- import java.security.interfaces.ECPrivateKey;</span>
  import java.security.interfaces.ECPublicKey;
  import java.security.spec.ECParameterSpec;
<span class="line-modified">! import java.security.spec.ECPoint;</span>
<span class="line-removed">- import java.security.spec.ECPublicKeySpec;</span>
  import java.text.MessageFormat;
<span class="line-removed">- import java.util.EnumSet;</span>
  import java.util.Locale;
  import javax.crypto.SecretKey;
<span class="line-removed">- import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-removed">- import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;</span>
<span class="line-removed">- import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;</span>
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-removed">- import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
  import sun.security.ssl.X509Authentication.X509Credentials;
  import sun.security.ssl.X509Authentication.X509Possession;
<span class="line-removed">- import sun.security.util.ECUtil;</span>
  import sun.security.util.HexDumpEncoder;
  
  /**
   * Pack of the &quot;ClientKeyExchange&quot; handshake message.
   */
  final class ECDHClientKeyExchange {
      static final SSLConsumer ecdhHandshakeConsumer =
              new ECDHClientKeyExchangeConsumer();
      static final HandshakeProducer ecdhHandshakeProducer =
<span class="line-new-header">--- 25,32 ---</span>
  
  package sun.security.ssl;
  
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.security.GeneralSecurityException;
  import java.security.PublicKey;
  import java.security.interfaces.ECPublicKey;
<span class="line-added">+ import java.security.interfaces.XECPublicKey;</span>
<span class="line-added">+ import java.security.spec.AlgorithmParameterSpec;</span>
  import java.security.spec.ECParameterSpec;
<span class="line-modified">! import java.security.spec.NamedParameterSpec;</span>
  import java.text.MessageFormat;
  import java.util.Locale;
  import javax.crypto.SecretKey;
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
  import sun.security.ssl.X509Authentication.X509Credentials;
  import sun.security.ssl.X509Authentication.X509Possession;
  import sun.security.util.HexDumpEncoder;
  
  /**
   * Pack of the &quot;ClientKeyExchange&quot; handshake message.
<span class="line-added">+  *</span>
<span class="line-added">+  * This file is used by both the ECDH/ECDHE/XDH code since much of the</span>
<span class="line-added">+  * code is the same between the EC named groups (i.e.</span>
<span class="line-added">+  * x25519/x448/secp*r1), even though the APIs are very different (i.e.</span>
<span class="line-added">+  * ECPublicKey/XECPublicKey, KeyExchange.getInstance(&quot;EC&quot;/&quot;XDH&quot;), etc.).</span>
   */
  final class ECDHClientKeyExchange {
      static final SSLConsumer ecdhHandshakeConsumer =
              new ECDHClientKeyExchangeConsumer();
      static final HandshakeProducer ecdhHandshakeProducer =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,23 ***</span>
              new ECDHEClientKeyExchangeConsumer();
      static final HandshakeProducer ecdheHandshakeProducer =
              new ECDHEClientKeyExchangeProducer();
  
      /**
<span class="line-modified">!      * The ECDH/ECDHE ClientKeyExchange handshake message.</span>
       */
      private static final
              class ECDHClientKeyExchangeMessage extends HandshakeMessage {
          private final byte[] encodedPoint;
  
          ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
<span class="line-modified">!                 ECPublicKey publicKey) {</span>
              super(handshakeContext);
  
<span class="line-modified">!             ECPoint point = publicKey.getW();</span>
<span class="line-removed">-             ECParameterSpec params = publicKey.getParams();</span>
<span class="line-removed">-             encodedPoint = ECUtil.encodePoint(point, params.getCurve());</span>
          }
  
          ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
                  ByteBuffer m) throws IOException {
              super(handshakeContext);
<span class="line-new-header">--- 60,21 ---</span>
              new ECDHEClientKeyExchangeConsumer();
      static final HandshakeProducer ecdheHandshakeProducer =
              new ECDHEClientKeyExchangeProducer();
  
      /**
<span class="line-modified">!      * The ECDH/ECDHE/XDH ClientKeyExchange handshake message.</span>
       */
      private static final
              class ECDHClientKeyExchangeMessage extends HandshakeMessage {
          private final byte[] encodedPoint;
  
          ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
<span class="line-modified">!                 byte[] encodedPublicKey) {</span>
              super(handshakeContext);
  
<span class="line-modified">!             this.encodedPoint = encodedPublicKey;</span>
          }
  
          ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
                  ByteBuffer m) throws IOException {
              super(handshakeContext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,38 ***</span>
              } else {
                  this.encodedPoint = new byte[0];
              }
          }
  
<span class="line-removed">-         // Check constraints of the specified EC public key.</span>
<span class="line-removed">-         static void checkConstraints(AlgorithmConstraints constraints,</span>
<span class="line-removed">-                 ECPublicKey publicKey,</span>
<span class="line-removed">-                 byte[] encodedPoint) throws SSLHandshakeException {</span>
<span class="line-removed">- </span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 ECParameterSpec params = publicKey.getParams();</span>
<span class="line-removed">-                 ECPoint point =</span>
<span class="line-removed">-                         ECUtil.decodePoint(encodedPoint, params.getCurve());</span>
<span class="line-removed">-                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-removed">-                 ECPublicKey peerPublicKey =</span>
<span class="line-removed">-                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // check constraints of ECPublicKey</span>
<span class="line-removed">-                 if (!constraints.permits(</span>
<span class="line-removed">-                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">-                         peerPublicKey)) {</span>
<span class="line-removed">-                     throw new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">-                 throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;Could not generate ECPublicKey&quot;).initCause(e);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          @Override
          public SSLHandshake handshakeType() {
              return SSLHandshake.CLIENT_KEY_EXCHANGE;
          }
  
<span class="line-new-header">--- 83,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,28 ***</span>
                  throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No server certificate for ECDH client key exchange&quot;);
              }
  
              PublicKey publicKey = x509Credentials.popPublicKey;
<span class="line-modified">!             if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Not EC server certificate for ECDH client key exchange&quot;);</span>
              }
  
<span class="line-removed">-             ECParameterSpec params = ((ECPublicKey)publicKey).getParams();</span>
<span class="line-removed">-             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
              if (namedGroup == null) {
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);</span>
              }
  
<span class="line-modified">!             ECDHEPossession ecdhePossession = new ECDHEPossession(</span>
<span class="line-modified">!                     namedGroup, chc.sslContext.getSecureRandom());</span>
<span class="line-modified">!             chc.handshakePossessions.add(ecdhePossession);</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(
<span class="line-modified">!                             chc, ecdhePossession.publicKey);</span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
              }
  
<span class="line-new-header">--- 159,45 ---</span>
                  throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No server certificate for ECDH client key exchange&quot;);
              }
  
              PublicKey publicKey = x509Credentials.popPublicKey;
<span class="line-modified">! </span>
<span class="line-added">+             NamedGroup namedGroup = null;</span>
<span class="line-added">+             String algorithm = publicKey.getAlgorithm();</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Determine which NamedGroup we&#39;ll be using, then use</span>
<span class="line-added">+             // the creator functions.</span>
<span class="line-added">+             if (algorithm.equals(&quot;EC&quot;)) {</span>
<span class="line-added">+                 ECParameterSpec params = ((ECPublicKey)publicKey).getParams();</span>
<span class="line-added">+                 namedGroup = NamedGroup.valueOf(params);</span>
<span class="line-added">+             } else if (algorithm.equals(&quot;XDH&quot;)) {</span>
<span class="line-added">+                 AlgorithmParameterSpec params =</span>
<span class="line-added">+                         ((XECPublicKey)publicKey).getParams();</span>
<span class="line-added">+                 if (params instanceof NamedParameterSpec) {</span>
<span class="line-added">+                     String name = ((NamedParameterSpec)params).getName();</span>
<span class="line-added">+                     namedGroup = NamedGroup.nameOf(name);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Not EC/XDH server certificate for &quot; +</span>
<span class="line-added">+                             &quot;ECDH client key exchange&quot;);</span>
              }
  
              if (namedGroup == null) {
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Unsupported EC/XDH server cert for &quot; +</span>
<span class="line-added">+                         &quot;ECDH client key exchange&quot;);</span>
              }
  
<span class="line-modified">!             SSLPossession sslPossession = namedGroup.createPossession(</span>
<span class="line-modified">!                     chc.sslContext.getSecureRandom());</span>
<span class="line-modified">! </span>
<span class="line-added">+             chc.handshakePossessions.add(sslPossession);</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(
<span class="line-modified">!                             chc, sslPossession.encode());</span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,23 ***</span>
                  // unlikely, have been checked during cipher suite negotiation.
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No expected EC server cert for ECDH client key exchange&quot;);
              }
  
<span class="line-modified">!             PrivateKey privateKey = x509Possession.popPrivateKey;</span>
<span class="line-modified">!             if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {</span>
                  // unlikely, have been checked during cipher suite negotiation.
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Not EC server cert for ECDH client key exchange&quot;);</span>
              }
  
<span class="line-modified">!             ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();</span>
<span class="line-removed">-             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
              if (namedGroup == null) {
<span class="line-removed">-                 // unlikely, have been checked during cipher suite negotiation.</span>
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);</span>
              }
  
              SSLKeyExchange ke = SSLKeyExchange.valueOf(
                      shc.negotiatedCipherSuite.keyExchange,
                      shc.negotiatedProtocol);
<span class="line-new-header">--- 265,39 ---</span>
                  // unlikely, have been checked during cipher suite negotiation.
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No expected EC server cert for ECDH client key exchange&quot;);
              }
  
<span class="line-modified">!             // Determine which NamedGroup we&#39;ll be using, then use</span>
<span class="line-modified">!             // the creator functions.</span>
<span class="line-added">+             NamedGroup namedGroup = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Iteratively determine the X509Possession type&#39;s ParameterSpec.</span>
<span class="line-added">+             ECParameterSpec ecParams = x509Possession.getECParameterSpec();</span>
<span class="line-added">+             NamedParameterSpec namedParams = null;</span>
<span class="line-added">+             if (ecParams != null) {</span>
<span class="line-added">+                 namedGroup = NamedGroup.valueOf(ecParams);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Wasn&#39;t EC, try XEC.</span>
<span class="line-added">+             if (ecParams == null) {</span>
<span class="line-added">+                 namedParams = x509Possession.getXECParameterSpec();</span>
<span class="line-added">+                 namedGroup = NamedGroup.nameOf(namedParams.getName());</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Can&#39;t figure this out, bail.</span>
<span class="line-added">+             if ((ecParams == null) &amp;&amp; (namedParams == null)) {</span>
                  // unlikely, have been checked during cipher suite negotiation.
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Not EC/XDH server cert for ECDH client key exchange&quot;);</span>
              }
  
<span class="line-modified">!             // unlikely, have been checked during cipher suite negotiation.</span>
              if (namedGroup == null) {
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Unknown named group in server cert for &quot; +</span>
<span class="line-added">+                         &quot;ECDH client key exchange&quot;);</span>
              }
  
              SSLKeyExchange ke = SSLKeyExchange.valueOf(
                      shc.negotiatedCipherSuite.keyExchange,
                      shc.negotiatedProtocol);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,41 ***</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                          &quot;Not supported key exchange type&quot;);
              }
  
<span class="line-modified">!             // parse the handshake message</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(shc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
              }
  
              // create the credentials
              try {
<span class="line-modified">!                 ECPoint point =</span>
<span class="line-modified">!                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());</span>
<span class="line-modified">!                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">!                 ECPublicKey peerPublicKey =</span>
<span class="line-modified">!                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // check constraints of peer ECPublicKey</span>
<span class="line-modified">!                 if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">!                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">-                         peerPublicKey)) {</span>
<span class="line-removed">-                     throw new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 shc.handshakeCredentials.add(new ECDHECredentials(</span>
<span class="line-removed">-                         peerPublicKey, namedGroup));</span>
<span class="line-removed">-             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">-                 throw (SSLHandshakeException)(new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;Could not generate ECPublicKey&quot;).initCause(e));</span>
              }
  
              // update the states
              SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
              SecretKey masterSecret =
<span class="line-new-header">--- 305,31 ---</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                          &quot;Not supported key exchange type&quot;);
              }
  
<span class="line-modified">!             // parse either handshake message containing either EC/XEC.</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(shc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
              }
  
              // create the credentials
              try {
<span class="line-modified">!                 NamedGroup ng = namedGroup;  // &quot;effectively final&quot; the lambda</span>
<span class="line-modified">!                 // AlgorithmConstraints are checked internally.</span>
<span class="line-modified">!                 SSLCredentials sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">!                         cke.encodedPoint, shc.algorithmConstraints,</span>
<span class="line-modified">!                         s -&gt; shc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">!                         &quot;ClientKeyExchange &quot; + ng + &quot;: &quot; + s));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 shc.handshakeCredentials.add(sslCredentials);</span>
<span class="line-modified">!             } catch (GeneralSecurityException e) {</span>
<span class="line-modified">!                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">!                         &quot;Cannot decode ECDH PublicKey: &quot; + namedGroup);</span>
              }
  
              // update the states
              SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
              SecretKey masterSecret =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,29 ***</span>
          public byte[] produce(ConnectionContext context,
                  HandshakeMessage message) throws IOException {
              // The producing happens in client side only.
              ClientHandshakeContext chc = (ClientHandshakeContext)context;
  
<span class="line-modified">!             ECDHECredentials ecdheCredentials = null;</span>
              for (SSLCredentials cd : chc.handshakeCredentials) {
<span class="line-modified">!                 if (cd instanceof ECDHECredentials) {</span>
<span class="line-modified">!                     ecdheCredentials = (ECDHECredentials)cd;</span>
                      break;
                  }
              }
  
<span class="line-modified">!             if (ecdheCredentials == null) {</span>
                  throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No ECDHE credentials negotiated for client key exchange&quot;);
              }
  
<span class="line-modified">!             ECDHEPossession ecdhePossession = new ECDHEPossession(</span>
<span class="line-modified">!                     ecdheCredentials, chc.sslContext.getSecureRandom());</span>
<span class="line-modified">!             chc.handshakePossessions.add(ecdhePossession);</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(
<span class="line-modified">!                             chc, ecdhePossession.publicKey);</span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
              }
  
<span class="line-new-header">--- 363,41 ---</span>
          public byte[] produce(ConnectionContext context,
                  HandshakeMessage message) throws IOException {
              // The producing happens in client side only.
              ClientHandshakeContext chc = (ClientHandshakeContext)context;
  
<span class="line-modified">!             SSLCredentials sslCredentials = null;</span>
<span class="line-added">+             NamedGroup ng = null;</span>
<span class="line-added">+             PublicKey publicKey = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Find a good EC/XEC credential to use, determine the</span>
<span class="line-added">+             // NamedGroup to use for creating Possessions/Credentials/Keys.</span>
              for (SSLCredentials cd : chc.handshakeCredentials) {
<span class="line-modified">!                 if (cd instanceof NamedGroupCredentials) {</span>
<span class="line-modified">!                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;</span>
<span class="line-added">+                     ng = creds.getNamedGroup();</span>
<span class="line-added">+                     publicKey = creds.getPublicKey();</span>
<span class="line-added">+                     sslCredentials = cd;</span>
                      break;
                  }
              }
  
<span class="line-modified">!             if (sslCredentials == null) {</span>
                  throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No ECDHE credentials negotiated for client key exchange&quot;);
              }
  
<span class="line-modified">!             SSLPossession sslPossession = ng.createPossession(</span>
<span class="line-modified">!                     chc.sslContext.getSecureRandom());</span>
<span class="line-modified">! </span>
<span class="line-added">+             chc.handshakePossessions.add(sslPossession);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Write the EC/XEC message.</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(
<span class="line-modified">!                             chc, sslPossession.encode());</span>
<span class="line-added">+ </span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,27 ***</span>
          public void consume(ConnectionContext context,
                  ByteBuffer message) throws IOException {
              // The consuming happens in server side only.
              ServerHandshakeContext shc = (ServerHandshakeContext)context;
  
<span class="line-modified">!             ECDHEPossession ecdhePossession = null;</span>
              for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">!                 if (possession instanceof ECDHEPossession) {</span>
<span class="line-modified">!                     ecdhePossession = (ECDHEPossession)possession;</span>
                      break;
                  }
              }
<span class="line-modified">!             if (ecdhePossession == null) {</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No expected ECDHE possessions for client key exchange&quot;);
              }
  
<span class="line-removed">-             ECParameterSpec params = ecdhePossession.publicKey.getParams();</span>
<span class="line-removed">-             NamedGroup namedGroup = NamedGroup.valueOf(params);</span>
              if (namedGroup == null) {
<span class="line-modified">!                 // unlikely, have been checked during cipher suite negotiation.</span>
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                      &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
              }
  
              SSLKeyExchange ke = SSLKeyExchange.valueOf(
<span class="line-new-header">--- 451,33 ---</span>
          public void consume(ConnectionContext context,
                  ByteBuffer message) throws IOException {
              // The consuming happens in server side only.
              ServerHandshakeContext shc = (ServerHandshakeContext)context;
  
<span class="line-modified">!             SSLPossession sslPossession = null;</span>
<span class="line-added">+             NamedGroup namedGroup = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+            // Find a good EC/XEC credential to use, determine the</span>
<span class="line-added">+            // NamedGroup to use for creating Possessions/Credentials/Keys.</span>
              for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">!                 if (possession instanceof NamedGroupPossession) {</span>
<span class="line-modified">!                     NamedGroupPossession poss =</span>
<span class="line-added">+                             (NamedGroupPossession)possession;</span>
<span class="line-added">+                     namedGroup = poss.getNamedGroup();</span>
<span class="line-added">+                     sslPossession = poss;</span>
                      break;
                  }
              }
<span class="line-modified">! </span>
<span class="line-added">+             if (sslPossession == null) {</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                      &quot;No expected ECDHE possessions for client key exchange&quot;);
              }
  
              if (namedGroup == null) {
<span class="line-modified">!                 // unlikely, have been checked during cipher suite negotiation</span>
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                      &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
              }
  
              SSLKeyExchange ke = SSLKeyExchange.valueOf(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,41 ***</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                          &quot;Not supported key exchange type&quot;);
              }
  
<span class="line-modified">!             // parse the handshake message</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(shc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
              }
  
              // create the credentials
              try {
<span class="line-modified">!                 ECPoint point =</span>
<span class="line-modified">!                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());</span>
<span class="line-modified">!                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">!                 ECPublicKey peerPublicKey =</span>
<span class="line-modified">!                         (ECPublicKey)kf.generatePublic(spec);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // check constraints of peer ECPublicKey</span>
<span class="line-modified">!                 if (!shc.algorithmConstraints.permits(</span>
<span class="line-modified">!                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">-                         peerPublicKey)) {</span>
<span class="line-removed">-                     throw new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 shc.handshakeCredentials.add(new ECDHECredentials(</span>
<span class="line-removed">-                         peerPublicKey, namedGroup));</span>
<span class="line-removed">-             } catch (GeneralSecurityException | java.io.IOException e) {</span>
<span class="line-removed">-                 throw (SSLHandshakeException)(new SSLHandshakeException(</span>
<span class="line-removed">-                         &quot;Could not generate ECPublicKey&quot;).initCause(e));</span>
              }
  
              // update the states
              SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
              SecretKey masterSecret =
<span class="line-new-header">--- 487,31 ---</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
                          &quot;Not supported key exchange type&quot;);
              }
  
<span class="line-modified">!             // parse the EC/XEC handshake message</span>
              ECDHClientKeyExchangeMessage cke =
                      new ECDHClientKeyExchangeMessage(shc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
              }
  
              // create the credentials
              try {
<span class="line-modified">!                 NamedGroup ng = namedGroup; // &quot;effectively final&quot; the lambda</span>
<span class="line-modified">!                 // AlgorithmConstraints are checked internally.</span>
<span class="line-modified">!                 SSLCredentials sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">!                         cke.encodedPoint, shc.algorithmConstraints,</span>
<span class="line-modified">!                         s -&gt; shc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">!                         &quot;ClientKeyExchange &quot; + ng + &quot;: &quot; + s));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 shc.handshakeCredentials.add(sslCredentials);</span>
<span class="line-modified">!             } catch (GeneralSecurityException e) {</span>
<span class="line-modified">!                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">!                         &quot;Cannot decode named group: &quot; + namedGroup);</span>
              }
  
              // update the states
              SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
              SecretKey masterSecret =
</pre>
<center><a href="DTLSOutputRecord.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECDHKeyExchange.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
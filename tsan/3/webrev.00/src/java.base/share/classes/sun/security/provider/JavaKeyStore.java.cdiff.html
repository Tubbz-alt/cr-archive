<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/provider/JavaKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DomainKeyStore.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/provider/JavaKeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,12 ---</span>
  import java.security.cert.Certificate;
  import java.security.cert.CertificateFactory;
  import java.security.cert.CertificateException;
  import java.util.*;
  
<span class="line-added">+ import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added">+ </span>
  import sun.security.pkcs.EncryptedPrivateKeyInfo;
  import sun.security.pkcs12.PKCS12KeyStore;
  import sun.security.util.Debug;
  import sun.security.util.IOUtils;
  import sun.security.util.KeyStoreDelegator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 693,11 ***</span>
                      // Read the (entry creation) date
                      entry.date = new Date(dis.readLong());
  
                      // Read the private key
                      entry.protectedPrivKey =
<span class="line-modified">!                             IOUtils.readFully(dis, dis.readInt(), true);</span>
  
                      // Read the certificate chain
                      int numOfCerts = dis.readInt();
                      if (numOfCerts &gt; 0) {
                          List&lt;Certificate&gt; certs = new ArrayList&lt;&gt;(
<span class="line-new-header">--- 695,11 ---</span>
                      // Read the (entry creation) date
                      entry.date = new Date(dis.readLong());
  
                      // Read the private key
                      entry.protectedPrivKey =
<span class="line-modified">!                             IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
  
                      // Read the certificate chain
                      int numOfCerts = dis.readInt();
                      if (numOfCerts &gt; 0) {
                          List&lt;Certificate&gt; certs = new ArrayList&lt;&gt;(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 718,11 ***</span>
                                      // reuse it later
                                      cfs.put(certType, cf);
                                  }
                              }
                              // instantiate the certificate
<span class="line-modified">!                             encoded = IOUtils.readFully(dis, dis.readInt(), true);</span>
                              bais = new ByteArrayInputStream(encoded);
                              certs.add(cf.generateCertificate(bais));
                              bais.close();
                          }
                          // We can be sure now that numOfCerts of certs are read
<span class="line-new-header">--- 720,11 ---</span>
                                      // reuse it later
                                      cfs.put(certType, cf);
                                  }
                              }
                              // instantiate the certificate
<span class="line-modified">!                             encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
                              bais = new ByteArrayInputStream(encoded);
                              certs.add(cf.generateCertificate(bais));
                              bais.close();
                          }
                          // We can be sure now that numOfCerts of certs are read
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,11 ***</span>
                              // store the certificate factory so we can
                              // reuse it later
                              cfs.put(certType, cf);
                          }
                      }
<span class="line-modified">!                     encoded = IOUtils.readFully(dis, dis.readInt(), true);</span>
                      bais = new ByteArrayInputStream(encoded);
                      entry.cert = cf.generateCertificate(bais);
                      bais.close();
  
                      // Add the entry to the list
<span class="line-new-header">--- 759,11 ---</span>
                              // store the certificate factory so we can
                              // reuse it later
                              cfs.put(certType, cf);
                          }
                      }
<span class="line-modified">!                     encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
                      bais = new ByteArrayInputStream(encoded);
                      entry.cert = cf.generateCertificate(bais);
                      bais.close();
  
                      // Add the entry to the list
</pre>
<hr />
<pre>
<span class="line-old-header">*** 783,38 ***</span>
               * at the end. If this check fails, the store has been tampered
               * with
               */
              if (password != null) {
                  byte[] computed = md.digest();
<span class="line-modified">!                 byte[] actual = new byte[computed.length];</span>
<span class="line-modified">!                 dis.readFully(actual);</span>
<span class="line-modified">!                 for (int i = 0; i &lt; computed.length; i++) {</span>
<span class="line-removed">-                     if (computed[i] != actual[i]) {</span>
<span class="line-removed">-                         Throwable t = new UnrecoverableKeyException</span>
                              (&quot;Password verification failed&quot;);
<span class="line-modified">!                         throw (IOException)new IOException</span>
                              (&quot;Keystore was tampered with, or &quot;
<span class="line-modified">!                             + &quot;password was incorrect&quot;).initCause(t);</span>
<span class="line-removed">-                     }</span>
                  }
              }
          }
      }
  
      /**
       * To guard against tampering with the keystore, we append a keyed
       * hash with a bit of whitener.
       */
      private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">!         throws NoSuchAlgorithmException, UnsupportedEncodingException</span>
      {
  
          MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
          byte[] passwdBytes = convertToBytes(password);
          md.update(passwdBytes);
          Arrays.fill(passwdBytes, (byte) 0x00);
<span class="line-modified">!         md.update(&quot;Mighty Aphrodite&quot;.getBytes(&quot;UTF8&quot;));</span>
          return md;
      }
  
      /**
       * Helper method to convert char[] to byte[]
<span class="line-new-header">--- 785,35 ---</span>
               * at the end. If this check fails, the store has been tampered
               * with
               */
              if (password != null) {
                  byte[] computed = md.digest();
<span class="line-modified">!                 byte[] actual = IOUtils.readExactlyNBytes(dis, computed.length);</span>
<span class="line-modified">!                 if (!MessageDigest.isEqual(computed, actual)) {</span>
<span class="line-modified">!                     Throwable t = new UnrecoverableKeyException</span>
                              (&quot;Password verification failed&quot;);
<span class="line-modified">!                     throw (IOException) new IOException</span>
                              (&quot;Keystore was tampered with, or &quot;
<span class="line-modified">!                                     + &quot;password was incorrect&quot;).initCause(t);</span>
                  }
              }
          }
      }
  
      /**
       * To guard against tampering with the keystore, we append a keyed
       * hash with a bit of whitener.
       */
      private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">!         throws NoSuchAlgorithmException</span>
      {
  
          MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
          byte[] passwdBytes = convertToBytes(password);
          md.update(passwdBytes);
          Arrays.fill(passwdBytes, (byte) 0x00);
<span class="line-modified">!         md.update(&quot;Mighty Aphrodite&quot;.getBytes(UTF_8));</span>
          return md;
      }
  
      /**
       * Helper method to convert char[] to byte[]
</pre>
<center><a href="DomainKeyStore.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
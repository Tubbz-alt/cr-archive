<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/CertificateMessage.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertStatusExtension.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateRequest.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertificateMessage.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -369,10 +369,14 @@</span>
  
          private void onCertificate(ServerHandshakeContext shc,
                  T12CertificateMessage certificateMessage )throws IOException {
              List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
              if (encodedCerts == null || encodedCerts.isEmpty()) {
<span class="udiff-line-added">+                 // For empty Certificate messages, we should not expect</span>
<span class="udiff-line-added">+                 // a CertificateVerify message to follow</span>
<span class="udiff-line-added">+                 shc.handshakeConsumers.remove(</span>
<span class="udiff-line-added">+                         SSLHandshake.CERTIFICATE_VERIFY.id);</span>
                  if (shc.sslConfig.clientAuthType !=
                          ClientAuthType.CLIENT_AUTH_REQUESTED) {
                      // unexpected or require client authentication
                      throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
                          &quot;Empty server certificate chain&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1032,10 +1036,11 @@</span>
                  }
  
                  // Don&#39;t select a signature scheme unless we will be able to
                  // produce a CertificateVerify message later
                  if (SignatureScheme.getPreferableAlgorithm(
<span class="udiff-line-added">+                         hc.algorithmConstraints,</span>
                          hc.peerRequestedSignatureSchemes,
                          ss, hc.negotiatedProtocol) == null) {
  
                      if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                          SSLLogger.warning(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1162,10 +1167,14 @@</span>
  
          private void onConsumeCertificate(ServerHandshakeContext shc,
                  T13CertificateMessage certificateMessage )throws IOException {
              if (certificateMessage.certEntries == null ||
                      certificateMessage.certEntries.isEmpty()) {
<span class="udiff-line-added">+                 // For empty Certificate messages, we should not expect</span>
<span class="udiff-line-added">+                 // a CertificateVerify message to follow</span>
<span class="udiff-line-added">+                 shc.handshakeConsumers.remove(</span>
<span class="udiff-line-added">+                         SSLHandshake.CERTIFICATE_VERIFY.id);</span>
                  if (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED) {
                      throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
                          &quot;Empty client certificate chain&quot;);
                  } else {
                      // optional client authentication
</pre>
<center><a href="CertStatusExtension.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateRequest.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
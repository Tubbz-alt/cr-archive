<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/javax/security/auth/Subject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="RefreshFailedException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="callback/ChoiceCallback.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/javax/security/auth/Subject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  83  *
  84  *      // add a Principal and credential to the Subject
  85  *      subject.getPrincipals().add(principal);
  86  *      subject.getPublicCredentials().add(credential);
  87  * &lt;/pre&gt;
  88  *
  89  * &lt;p&gt; This {@code Subject} class implements {@code Serializable}.
  90  * While the Principals associated with the {@code Subject} are serialized,
  91  * the credentials associated with the {@code Subject} are not.
  92  * Note that the {@code java.security.Principal} class
  93  * does not implement {@code Serializable}.  Therefore all concrete
  94  * {@code Principal} implementations associated with Subjects
  95  * must implement {@code Serializable}.
  96  *
  97  * @since 1.4
  98  * @see java.security.Principal
  99  * @see java.security.DomainCombiner
 100  */
 101 public final class Subject implements java.io.Serializable {
 102 

 103     private static final long serialVersionUID = -8308522755600156056L;
 104 
 105     /**
 106      * A {@code Set} that provides a view of all of this
 107      * Subject&#39;s Principals
 108      *
 109      * @serial Each element in this set is a
 110      *          {@code java.security.Principal}.
 111      *          The set is a {@code Subject.SecureSet}.
 112      */

 113     Set&lt;Principal&gt; principals;
 114 
 115     /**
 116      * Sets that provide a view of all of this
 117      * Subject&#39;s Credentials
 118      */
 119     transient Set&lt;Object&gt; pubCredentials;
 120     transient Set&lt;Object&gt; privCredentials;
 121 
 122     /**
 123      * Whether this Subject is read-only
 124      *
 125      * @serial
 126      */
 127     private volatile boolean readOnly = false;
 128 
 129     private static final int PRINCIPAL_SET = 1;
 130     private static final int PUB_CREDENTIAL_SET = 2;
 131     private static final int PRIV_CREDENTIAL_SET = 3;
 132 
</pre>
<hr />
<pre>
 929                 hashCode ^= getCredHashCode(pubCIterator.next());
 930             }
 931         }
 932         return hashCode;
 933     }
 934 
 935     /**
 936      * get a credential&#39;s hashcode
 937      */
 938     private int getCredHashCode(Object o) {
 939         try {
 940             return o.hashCode();
 941         } catch (IllegalStateException ise) {
 942             return o.getClass().toString().hashCode();
 943         }
 944     }
 945 
 946     /**
 947      * Writes this object out to a stream (i.e., serializes it).
 948      */

 949     private void writeObject(java.io.ObjectOutputStream oos)
 950                 throws java.io.IOException {
 951         synchronized(principals) {
 952             oos.defaultWriteObject();
 953         }
 954     }
 955 
 956     /**
 957      * Reads this object from a stream (i.e., deserializes it)
 958      */
 959     @SuppressWarnings(&quot;unchecked&quot;)

 960     private void readObject(java.io.ObjectInputStream s)
 961                 throws java.io.IOException, ClassNotFoundException {
 962 
 963         ObjectInputStream.GetField gf = s.readFields();
 964 
 965         readOnly = gf.get(&quot;readOnly&quot;, false);
 966 
 967         Set&lt;Principal&gt; inputPrincs = (Set&lt;Principal&gt;)gf.get(&quot;principals&quot;, null);
 968 
 969         Objects.requireNonNull(inputPrincs,
 970                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
 971 
 972         // Rewrap the principals into a SecureSet
 973         try {
 974             principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
 975                                 (this, PRINCIPAL_SET, inputPrincs));
 976         } catch (NullPointerException npe) {
 977             // Sometimes people deserialize the principals set only.
 978             // Subject is not accessible, so just don&#39;t fail.
 979             principals = Collections.synchronizedSet
</pre>
<hr />
<pre>
1010             // NullPointerException if contains(null) is called on it
1011             // rather than returning false.
1012             // If this happens we know the collection is null-clean.
1013             hasNullElements = false;
1014         } finally {
1015             if (hasNullElements) {
1016                 throw new NullPointerException
1017                     (ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1018             }
1019         }
1020     }
1021 
1022     /**
1023      * Prevent modifications unless caller has permission.
1024      *
1025      * @serial include
1026      */
1027     private static class SecureSet&lt;E&gt;
1028         implements Set&lt;E&gt;, java.io.Serializable {
1029 

1030         private static final long serialVersionUID = 7911754171111800359L;
1031 
1032         /**
1033          * @serialField this$0 Subject The outer Subject instance.
1034          * @serialField elements LinkedList The elements in this set.
1035          */

1036         private static final ObjectStreamField[] serialPersistentFields = {
1037             new ObjectStreamField(&quot;this$0&quot;, Subject.class),
1038             new ObjectStreamField(&quot;elements&quot;, LinkedList.class),
1039             new ObjectStreamField(&quot;which&quot;, int.class)
1040         };
1041 
1042         Subject subject;
1043         LinkedList&lt;E&gt; elements;
1044 
1045         /**
1046          * @serial An integer identifying the type of objects contained
1047          *      in this set.  If {@code which == 1},
1048          *      this is a Principal set and all the elements are
1049          *      of type {@code java.security.Principal}.
1050          *      If {@code which == 2}, this is a public credential
1051          *      set and all the elements are of type {@code Object}.
1052          *      If {@code which == 3}, this is a private credential
1053          *      set and all the elements are of type {@code Object}.
1054          */
1055         private int which;
</pre>
<hr />
<pre>
1391             int h = 0;
1392             Iterator&lt;E&gt; i = iterator();
1393             while (i.hasNext()) {
1394                 E obj = i.next();
1395                 if (obj != null) {
1396                     h += obj.hashCode();
1397                 }
1398             }
1399             return h;
1400         }
1401 
1402         /**
1403          * Writes this object out to a stream (i.e., serializes it).
1404          *
1405          * @serialData If this is a private credential set,
1406          *      a security check is performed to ensure that
1407          *      the caller has permission to access each credential
1408          *      in the set.  If the security check passes,
1409          *      the set is serialized.
1410          */

1411         private void writeObject(java.io.ObjectOutputStream oos)
1412                 throws java.io.IOException {
1413 
1414             if (which == Subject.PRIV_CREDENTIAL_SET) {
1415                 // check permissions before serializing
1416                 Iterator&lt;E&gt; i = iterator();
1417                 while (i.hasNext()) {
1418                     i.next();
1419                 }
1420             }
1421             ObjectOutputStream.PutField fields = oos.putFields();
1422             fields.put(&quot;this$0&quot;, subject);
1423             fields.put(&quot;elements&quot;, elements);
1424             fields.put(&quot;which&quot;, which);
1425             oos.writeFields();
1426         }
1427 
1428         @SuppressWarnings(&quot;unchecked&quot;)

1429         private void readObject(ObjectInputStream ois)
1430             throws IOException, ClassNotFoundException
1431         {
1432             ObjectInputStream.GetField fields = ois.readFields();
1433             subject = (Subject) fields.get(&quot;this$0&quot;, null);
1434             which = fields.get(&quot;which&quot;, 0);
1435 
1436             LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);
1437 
1438             Subject.collectionNullClean(tmp);
1439 
1440             if (tmp.getClass() != LinkedList.class) {
1441                 elements = new LinkedList&lt;E&gt;(tmp);
1442             } else {
1443                 elements = tmp;
1444             }
1445         }
1446 
1447     }
1448 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  83  *
  84  *      // add a Principal and credential to the Subject
  85  *      subject.getPrincipals().add(principal);
  86  *      subject.getPublicCredentials().add(credential);
  87  * &lt;/pre&gt;
  88  *
  89  * &lt;p&gt; This {@code Subject} class implements {@code Serializable}.
  90  * While the Principals associated with the {@code Subject} are serialized,
  91  * the credentials associated with the {@code Subject} are not.
  92  * Note that the {@code java.security.Principal} class
  93  * does not implement {@code Serializable}.  Therefore all concrete
  94  * {@code Principal} implementations associated with Subjects
  95  * must implement {@code Serializable}.
  96  *
  97  * @since 1.4
  98  * @see java.security.Principal
  99  * @see java.security.DomainCombiner
 100  */
 101 public final class Subject implements java.io.Serializable {
 102 
<span class="line-added"> 103     @java.io.Serial</span>
 104     private static final long serialVersionUID = -8308522755600156056L;
 105 
 106     /**
 107      * A {@code Set} that provides a view of all of this
 108      * Subject&#39;s Principals
 109      *
 110      * @serial Each element in this set is a
 111      *          {@code java.security.Principal}.
 112      *          The set is a {@code Subject.SecureSet}.
 113      */
<span class="line-added"> 114     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 115     Set&lt;Principal&gt; principals;
 116 
 117     /**
 118      * Sets that provide a view of all of this
 119      * Subject&#39;s Credentials
 120      */
 121     transient Set&lt;Object&gt; pubCredentials;
 122     transient Set&lt;Object&gt; privCredentials;
 123 
 124     /**
 125      * Whether this Subject is read-only
 126      *
 127      * @serial
 128      */
 129     private volatile boolean readOnly = false;
 130 
 131     private static final int PRINCIPAL_SET = 1;
 132     private static final int PUB_CREDENTIAL_SET = 2;
 133     private static final int PRIV_CREDENTIAL_SET = 3;
 134 
</pre>
<hr />
<pre>
 931                 hashCode ^= getCredHashCode(pubCIterator.next());
 932             }
 933         }
 934         return hashCode;
 935     }
 936 
 937     /**
 938      * get a credential&#39;s hashcode
 939      */
 940     private int getCredHashCode(Object o) {
 941         try {
 942             return o.hashCode();
 943         } catch (IllegalStateException ise) {
 944             return o.getClass().toString().hashCode();
 945         }
 946     }
 947 
 948     /**
 949      * Writes this object out to a stream (i.e., serializes it).
 950      */
<span class="line-added"> 951     @java.io.Serial</span>
 952     private void writeObject(java.io.ObjectOutputStream oos)
 953                 throws java.io.IOException {
 954         synchronized(principals) {
 955             oos.defaultWriteObject();
 956         }
 957     }
 958 
 959     /**
 960      * Reads this object from a stream (i.e., deserializes it)
 961      */
 962     @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-added"> 963     @java.io.Serial</span>
 964     private void readObject(java.io.ObjectInputStream s)
 965                 throws java.io.IOException, ClassNotFoundException {
 966 
 967         ObjectInputStream.GetField gf = s.readFields();
 968 
 969         readOnly = gf.get(&quot;readOnly&quot;, false);
 970 
 971         Set&lt;Principal&gt; inputPrincs = (Set&lt;Principal&gt;)gf.get(&quot;principals&quot;, null);
 972 
 973         Objects.requireNonNull(inputPrincs,
 974                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
 975 
 976         // Rewrap the principals into a SecureSet
 977         try {
 978             principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
 979                                 (this, PRINCIPAL_SET, inputPrincs));
 980         } catch (NullPointerException npe) {
 981             // Sometimes people deserialize the principals set only.
 982             // Subject is not accessible, so just don&#39;t fail.
 983             principals = Collections.synchronizedSet
</pre>
<hr />
<pre>
1014             // NullPointerException if contains(null) is called on it
1015             // rather than returning false.
1016             // If this happens we know the collection is null-clean.
1017             hasNullElements = false;
1018         } finally {
1019             if (hasNullElements) {
1020                 throw new NullPointerException
1021                     (ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1022             }
1023         }
1024     }
1025 
1026     /**
1027      * Prevent modifications unless caller has permission.
1028      *
1029      * @serial include
1030      */
1031     private static class SecureSet&lt;E&gt;
1032         implements Set&lt;E&gt;, java.io.Serializable {
1033 
<span class="line-added">1034         @java.io.Serial</span>
1035         private static final long serialVersionUID = 7911754171111800359L;
1036 
1037         /**
1038          * @serialField this$0 Subject The outer Subject instance.
1039          * @serialField elements LinkedList The elements in this set.
1040          */
<span class="line-added">1041         @java.io.Serial</span>
1042         private static final ObjectStreamField[] serialPersistentFields = {
1043             new ObjectStreamField(&quot;this$0&quot;, Subject.class),
1044             new ObjectStreamField(&quot;elements&quot;, LinkedList.class),
1045             new ObjectStreamField(&quot;which&quot;, int.class)
1046         };
1047 
1048         Subject subject;
1049         LinkedList&lt;E&gt; elements;
1050 
1051         /**
1052          * @serial An integer identifying the type of objects contained
1053          *      in this set.  If {@code which == 1},
1054          *      this is a Principal set and all the elements are
1055          *      of type {@code java.security.Principal}.
1056          *      If {@code which == 2}, this is a public credential
1057          *      set and all the elements are of type {@code Object}.
1058          *      If {@code which == 3}, this is a private credential
1059          *      set and all the elements are of type {@code Object}.
1060          */
1061         private int which;
</pre>
<hr />
<pre>
1397             int h = 0;
1398             Iterator&lt;E&gt; i = iterator();
1399             while (i.hasNext()) {
1400                 E obj = i.next();
1401                 if (obj != null) {
1402                     h += obj.hashCode();
1403                 }
1404             }
1405             return h;
1406         }
1407 
1408         /**
1409          * Writes this object out to a stream (i.e., serializes it).
1410          *
1411          * @serialData If this is a private credential set,
1412          *      a security check is performed to ensure that
1413          *      the caller has permission to access each credential
1414          *      in the set.  If the security check passes,
1415          *      the set is serialized.
1416          */
<span class="line-added">1417         @java.io.Serial</span>
1418         private void writeObject(java.io.ObjectOutputStream oos)
1419                 throws java.io.IOException {
1420 
1421             if (which == Subject.PRIV_CREDENTIAL_SET) {
1422                 // check permissions before serializing
1423                 Iterator&lt;E&gt; i = iterator();
1424                 while (i.hasNext()) {
1425                     i.next();
1426                 }
1427             }
1428             ObjectOutputStream.PutField fields = oos.putFields();
1429             fields.put(&quot;this$0&quot;, subject);
1430             fields.put(&quot;elements&quot;, elements);
1431             fields.put(&quot;which&quot;, which);
1432             oos.writeFields();
1433         }
1434 
1435         @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-added">1436         @java.io.Serial</span>
1437         private void readObject(ObjectInputStream ois)
1438             throws IOException, ClassNotFoundException
1439         {
1440             ObjectInputStream.GetField fields = ois.readFields();
1441             subject = (Subject) fields.get(&quot;this$0&quot;, null);
1442             which = fields.get(&quot;which&quot;, 0);
1443 
1444             LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);
1445 
1446             Subject.collectionNullClean(tmp);
1447 
1448             if (tmp.getClass() != LinkedList.class) {
1449                 elements = new LinkedList&lt;E&gt;(tmp);
1450             } else {
1451                 elements = tmp;
1452             }
1453         }
1454 
1455     }
1456 
</pre>
</td>
</tr>
</table>
<center><a href="RefreshFailedException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="callback/ChoiceCallback.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
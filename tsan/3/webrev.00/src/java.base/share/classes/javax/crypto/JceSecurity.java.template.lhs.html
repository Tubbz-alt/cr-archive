<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/javax/crypto/JceSecurity.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * README README README README README README README README README
 28  *
 29  * This file is the template for generating the JceSecurity.java source
 30  * file.
 31  *
 32  * In the current jdk builds, this file is first preprocessed to replace
 33  * @@JCE_DEFAULT_POLICY@ [sic] with &quot;limited&quot; or &quot;unlimited&quot; which is
 34  * determined by the $(UNLIMTED_CRYPTO) make variable.  This variable is
 35  * set by top-level configure script, using either
 36  * --disable-unlimited-crypto or --enable-unlimited-crypto [default].
 37  *
 38  * Since this file is a generated source, incremental changes to
 39  * this file require regenerating the source.  Compilation options:
 40  *
 41  *     (fewer dependencies/&quot;faster&quot; ones first)
 42  *
 43  * 1.  make JDK_FILTER=javax/crypto java.base-gensrc-only java.base-java-only
 44  * 2.  make java.base-gensrc-only java.base-java-only
 45  * 3.  make java.base-gensrc-only java.base-only
 46  * 4.  make java.base-only
 47  * 5.  make
 48  */
 49 
 50 package javax.crypto;
 51 
 52 import java.util.*;
<a name="2" id="anc2"></a>
 53 import java.io.*;
 54 import java.net.URL;
 55 import java.nio.file.*;
 56 import java.security.*;
 57 
 58 import java.security.Provider.Service;
 59 
 60 import jdk.internal.util.StaticProperty;
 61 
 62 import sun.security.jca.*;
 63 import sun.security.jca.GetInstance.Instance;
 64 import sun.security.util.Debug;
 65 
 66 /**
 67  * This class instantiates implementations of JCE engine classes from
 68  * providers registered with the java.security.Security object.
 69  *
 70  * @author Jan Luehe
 71  * @author Sharon Liu
 72  * @since 1.4
 73  */
 74 
 75 final class JceSecurity {
 76 
 77 
 78     private static final Debug debug = Debug.getInstance(&quot;jca&quot;);
 79 
 80     static final SecureRandom RANDOM = new SecureRandom();
 81 
 82     // The defaultPolicy and exemptPolicy will be set up
 83     // in the static initializer.
 84     private static CryptoPermissions defaultPolicy = null;
 85     private static CryptoPermissions exemptPolicy = null;
 86 
<a name="3" id="anc3"></a><span class="line-modified"> 87     // Map&lt;Provider,?&gt; of the providers we already have verified</span>
<span class="line-modified"> 88     // value == PROVIDER_VERIFIED is successfully verified</span>
<span class="line-modified"> 89     // value is failure cause Exception in error case</span>
<span class="line-modified"> 90     private static final Map&lt;Provider, Object&gt; verificationResults =</span>
<span class="line-modified"> 91             new IdentityHashMap&lt;&gt;();</span>
 92 
 93     // Map&lt;Provider,?&gt; of the providers currently being verified
 94     private static final Map&lt;Provider, Object&gt; verifyingProviders =
 95             new IdentityHashMap&lt;&gt;();
 96 
 97     private static final boolean isRestricted;
 98 
 99     /*
100      * Don&#39;t let anyone instantiate this.
101      */
102     private JceSecurity() {
103     }
104 
105     static {
106         try {
107             AccessController.doPrivileged(
108                 new PrivilegedExceptionAction&lt;&gt; () {
109                     @Override
110                     public Void run() throws Exception {
111                         setupJurisdictionPolicies();
112                         return null;
113                     }
114                 }
115             );
116 
117             isRestricted = defaultPolicy.implies(
118                 CryptoAllPermission.INSTANCE) ? false : true;
119         } catch (Exception e) {
120             throw new SecurityException(
121                     &quot;Can not initialize cryptographic mechanism&quot;, e);
122         }
123     }
124 
125     static Instance getInstance(String type, Class&lt;?&gt; clazz, String algorithm,
126             String provider) throws NoSuchAlgorithmException,
127             NoSuchProviderException {
128         Service s = GetInstance.getService(type, algorithm, provider);
129         Exception ve = getVerificationResult(s.getProvider());
130         if (ve != null) {
131             String msg = &quot;JCE cannot authenticate the provider &quot; + provider;
132             throw (NoSuchProviderException)
133                                 new NoSuchProviderException(msg).initCause(ve);
134         }
135         return GetInstance.getInstance(s, clazz);
136     }
137 
138     static Instance getInstance(String type, Class&lt;?&gt; clazz, String algorithm,
139             Provider provider) throws NoSuchAlgorithmException {
140         Service s = GetInstance.getService(type, algorithm, provider);
141         Exception ve = JceSecurity.getVerificationResult(provider);
142         if (ve != null) {
143             String msg = &quot;JCE cannot authenticate the provider &quot;
144                 + provider.getName();
145             throw new SecurityException(msg, ve);
146         }
147         return GetInstance.getInstance(s, clazz);
148     }
149 
150     static Instance getInstance(String type, Class&lt;?&gt; clazz, String algorithm)
151             throws NoSuchAlgorithmException {
152         List&lt;Service&gt; services = GetInstance.getServices(type, algorithm);
153         NoSuchAlgorithmException failure = null;
154         for (Service s : services) {
155             if (canUseProvider(s.getProvider()) == false) {
156                 // allow only signed providers
157                 continue;
158             }
159             try {
160                 Instance instance = GetInstance.getInstance(s, clazz);
161                 return instance;
162             } catch (NoSuchAlgorithmException e) {
163                 failure = e;
164             }
165         }
166         throw new NoSuchAlgorithmException(&quot;Algorithm &quot; + algorithm
167                 + &quot; not available&quot;, failure);
168     }
169 
170     /**
171      * Verify if the JAR at URL codeBase is a signed exempt application
172      * JAR file and returns the permissions bundled with the JAR.
173      *
174      * @throws Exception on error
175      */
176     static CryptoPermissions verifyExemptJar(URL codeBase) throws Exception {
177         ProviderVerifier pv = new ProviderVerifier(codeBase, true);
178         pv.verify();
179         return pv.getPermissions();
180     }
181 
182     /**
183      * Verify if the JAR at URL codeBase is a signed provider JAR file.
184      *
185      * @throws Exception on error
186      */
187     static void verifyProvider(URL codeBase, Provider p) throws Exception {
188         // Verify the provider JAR file and all
189         // supporting JAR files if there are any.
190         ProviderVerifier pv = new ProviderVerifier(codeBase, p, false);
191         pv.verify();
192     }
193 
194     private static final Object PROVIDER_VERIFIED = Boolean.TRUE;
195 
196     /*
197      * Verify that the provider JAR files are signed properly, which
198      * means the signer&#39;s certificate can be traced back to a
199      * JCE trusted CA.
200      * Return null if ok, failure Exception if verification failed.
201      */
<a name="4" id="anc4"></a><span class="line-modified">202     static synchronized Exception getVerificationResult(Provider p) {</span>
<span class="line-modified">203         Object o = verificationResults.get(p);</span>
<span class="line-modified">204         if (o == PROVIDER_VERIFIED) {</span>
<span class="line-modified">205             return null;</span>
<span class="line-modified">206         } else if (o != null) {</span>
<span class="line-modified">207             return (Exception)o;</span>
<span class="line-modified">208         }</span>
<span class="line-modified">209         if (verifyingProviders.get(p) != null) {</span>
<span class="line-modified">210             // this method is static synchronized, must be recursion</span>
<span class="line-modified">211             // return failure now but do not save the result</span>
<span class="line-modified">212             return new NoSuchProviderException(&quot;Recursion during verification&quot;);</span>
<span class="line-modified">213         }</span>
<span class="line-modified">214         try {</span>
<span class="line-modified">215             verifyingProviders.put(p, Boolean.FALSE);</span>
<span class="line-modified">216             URL providerURL = getCodeBase(p.getClass());</span>
<span class="line-modified">217             verifyProvider(providerURL, p);</span>
<span class="line-modified">218             // Verified ok, cache result</span>
<span class="line-modified">219             verificationResults.put(p, PROVIDER_VERIFIED);</span>
<span class="line-modified">220             return null;</span>
<span class="line-modified">221         } catch (Exception e) {</span>
<span class="line-modified">222             verificationResults.put(p, e);</span>
<span class="line-modified">223             return e;</span>
<span class="line-modified">224         } finally {</span>
<span class="line-modified">225             verifyingProviders.remove(p);</span>







226         }
<a name="5" id="anc5"></a>
227     }
228 
229     // return whether this provider is properly signed and can be used by JCE
230     static boolean canUseProvider(Provider p) {
231         return getVerificationResult(p) == null;
232     }
233 
234     // dummy object to represent null
235     private static final URL NULL_URL;
236 
237     static {
238         try {
239             NULL_URL = new URL(&quot;http://null.oracle.com/&quot;);
240         } catch (Exception e) {
241             throw new RuntimeException(e);
242         }
243     }
244 
245     // reference to a Map we use as a cache for codebases
246     private static final Map&lt;Class&lt;?&gt;, URL&gt; codeBaseCacheRef =
247             new WeakHashMap&lt;&gt;();
248 
249     /*
250      * Returns the CodeBase for the given class.
251      */
252     static URL getCodeBase(final Class&lt;?&gt; clazz) {
253         synchronized (codeBaseCacheRef) {
254             URL url = codeBaseCacheRef.get(clazz);
255             if (url == null) {
256                 url = AccessController.doPrivileged(
257                     new PrivilegedAction&lt;&gt;() {
258                         @Override
259                         public URL run() {
260                             ProtectionDomain pd = clazz.getProtectionDomain();
261                             if (pd != null) {
262                                 CodeSource cs = pd.getCodeSource();
263                                 if (cs != null) {
264                                     return cs.getLocation();
265                                 }
266                             }
267                             return NULL_URL;
268                         }
269                     });
270                 codeBaseCacheRef.put(clazz, url);
271             }
272             return (url == NULL_URL) ? null : url;
273         }
274     }
275 
276     // This is called from within an doPrivileged block.
277     private static void setupJurisdictionPolicies() throws Exception {
278 
279         // Sanity check the crypto.policy Security property.  Single
280         // directory entry, no pseudo-directories (&quot;.&quot;, &quot;..&quot;, leading/trailing
281         // path separators). normalize()/getParent() will help later.
282         String cryptoPolicyProperty = Security.getProperty(&quot;crypto.policy&quot;);
283 
284         /*
285          * In case no property is present, rather than fail catastrophically,
286          * we at least try for a &quot;sane&quot; value, which is what we were
287          * built with.  We first preprocess this file to plug in that
288          * value, then compile the result gensrc.
289          *
290          * Log the warning first.
291          */
292         if (cryptoPolicyProperty == null) {
293             cryptoPolicyProperty = &quot;@@JCE_DEFAULT_POLICY@@&quot;;
294             if (debug != null) {
295                 debug.println(
296                     &quot;Security Property &#39;crypto.policy&#39; not found: &quot;
297                     + &quot;using &#39;&quot; + cryptoPolicyProperty + &quot;&#39; as fallback&quot;);
298             }
299         }
300 
301         Path cpPath = Paths.get(cryptoPolicyProperty);
302 
303         if ((cpPath.getNameCount() != 1) ||
304                 (cpPath.compareTo(cpPath.getFileName()) != 0)) {
305             throw new SecurityException(
306                 &quot;Invalid policy directory name format: &quot; +
307                 cryptoPolicyProperty);
308         }
309 
310         // Prepend java.home to get the full path.  normalize() in
311         // case an extra &quot;.&quot; or &quot;..&quot; snuck in somehow.
312         String javaHomeProperty = StaticProperty.javaHome();
313         Path javaHomePolicyPath = Paths.get(javaHomeProperty, &quot;conf&quot;,
314                 &quot;security&quot;, &quot;policy&quot;).normalize();
315         Path cryptoPolicyPath = Paths.get(javaHomeProperty, &quot;conf&quot;, &quot;security&quot;,
316                 &quot;policy&quot;, cryptoPolicyProperty).normalize();
317 
318         if (cryptoPolicyPath.getParent().compareTo(javaHomePolicyPath) != 0) {
319             throw new SecurityException(
320                 &quot;Invalid cryptographic jurisdiction policy directory path: &quot; +
321                 cryptoPolicyProperty);
322         }
323 
324         if (!Files.isDirectory(cryptoPolicyPath)
325                 || !Files.isReadable(cryptoPolicyPath)) {
326             throw new SecurityException(
327                 &quot;Can&#39;t read cryptographic policy directory: &quot; +
328                 cryptoPolicyProperty);
329         }
330 
331         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(
332                 cryptoPolicyPath, &quot;{default,exempt}_*.policy&quot;)) {
333             for (Path entry : stream) {
334                 try (InputStream is = new BufferedInputStream(
335                         Files.newInputStream(entry))) {
336                     String filename = entry.getFileName().toString();
337 
338                     CryptoPermissions tmpPerms = new CryptoPermissions();
339                     tmpPerms.load(is);
340 
341                     if (filename.startsWith(&quot;default_&quot;)) {
342                         // Did we find a default perms?
343                         defaultPolicy = ((defaultPolicy == null) ? tmpPerms :
344                                 defaultPolicy.getMinimum(tmpPerms));
345                     } else if (filename.startsWith(&quot;exempt_&quot;)) {
346                         // Did we find a exempt perms?
347                         exemptPolicy = ((exemptPolicy == null) ? tmpPerms :
348                                 exemptPolicy.getMinimum(tmpPerms));
349                     } else {
350                         // This should never happen.  newDirectoryStream
351                         // should only throw return &quot;{default,exempt}_*.policy&quot;
352                         throw new SecurityException(
353                             &quot;Unexpected jurisdiction policy files in : &quot; +
354                             cryptoPolicyProperty);
355                     }
356                 } catch (Exception e) {
357                     throw new SecurityException(
358                         &quot;Couldn&#39;t parse jurisdiction policy files in: &quot; +
359                         cryptoPolicyProperty);
360                 }
361             }
362         } catch (DirectoryIteratorException ex) {
363             // I/O error encountered during the iteration,
364             // the cause is an IOException
365             throw new SecurityException(
366                 &quot;Couldn&#39;t iterate through the jurisdiction policy files: &quot; +
367                 cryptoPolicyProperty);
368         }
369 
370         // Must have a default policy
371         if ((defaultPolicy == null) || defaultPolicy.isEmpty()) {
372             throw new SecurityException(
373                 &quot;Missing mandatory jurisdiction policy files: &quot; +
374                 cryptoPolicyProperty);
375         }
376 
377         // If there was an empty exempt policy file, ignore it.
378         if ((exemptPolicy != null) &amp;&amp; exemptPolicy.isEmpty()) {
379             exemptPolicy = null;
380         }
381     }
382 
383     static CryptoPermissions getDefaultPolicy() {
384         return defaultPolicy;
385     }
386 
387     static CryptoPermissions getExemptPolicy() {
388         return exemptPolicy;
389     }
390 
391     static boolean isRestricted() {
392         return isRestricted;
393     }
<a name="6" id="anc6"></a>
























394 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
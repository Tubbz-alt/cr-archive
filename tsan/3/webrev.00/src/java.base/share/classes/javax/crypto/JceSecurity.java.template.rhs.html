<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/javax/crypto/JceSecurity.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * README README README README README README README README README
 28  *
 29  * This file is the template for generating the JceSecurity.java source
 30  * file.
 31  *
 32  * In the current jdk builds, this file is first preprocessed to replace
 33  * @@JCE_DEFAULT_POLICY@ [sic] with &quot;limited&quot; or &quot;unlimited&quot; which is
 34  * determined by the $(UNLIMTED_CRYPTO) make variable.  This variable is
 35  * set by top-level configure script, using either
 36  * --disable-unlimited-crypto or --enable-unlimited-crypto [default].
 37  *
 38  * Since this file is a generated source, incremental changes to
 39  * this file require regenerating the source.  Compilation options:
 40  *
 41  *     (fewer dependencies/&quot;faster&quot; ones first)
 42  *
 43  * 1.  make JDK_FILTER=javax/crypto java.base-gensrc-only java.base-java-only
 44  * 2.  make java.base-gensrc-only java.base-java-only
 45  * 3.  make java.base-gensrc-only java.base-only
 46  * 4.  make java.base-only
 47  * 5.  make
 48  */
 49 
 50 package javax.crypto;
 51 
 52 import java.util.*;
<a name="2" id="anc2"></a><span class="line-added"> 53 import java.util.concurrent.ConcurrentHashMap;</span>
 54 import java.io.*;
 55 import java.net.URL;
 56 import java.nio.file.*;
 57 import java.security.*;
 58 
 59 import java.security.Provider.Service;
 60 
 61 import jdk.internal.util.StaticProperty;
 62 
 63 import sun.security.jca.*;
 64 import sun.security.jca.GetInstance.Instance;
 65 import sun.security.util.Debug;
 66 
 67 /**
 68  * This class instantiates implementations of JCE engine classes from
 69  * providers registered with the java.security.Security object.
 70  *
 71  * @author Jan Luehe
 72  * @author Sharon Liu
 73  * @since 1.4
 74  */
 75 
 76 final class JceSecurity {
 77 
 78 
 79     private static final Debug debug = Debug.getInstance(&quot;jca&quot;);
 80 
 81     static final SecureRandom RANDOM = new SecureRandom();
 82 
 83     // The defaultPolicy and exemptPolicy will be set up
 84     // in the static initializer.
 85     private static CryptoPermissions defaultPolicy = null;
 86     private static CryptoPermissions exemptPolicy = null;
 87 
<a name="3" id="anc3"></a><span class="line-modified"> 88     // Map of the providers we already have verified.</span>
<span class="line-modified"> 89     // If verified ok, value == PROVIDER_VERIFIED, otherwise</span>
<span class="line-modified"> 90     // the cause of verification failure is stored as value.</span>
<span class="line-modified"> 91     private static final Map&lt;IdentityWrapper, Object&gt;</span>
<span class="line-modified"> 92         verificationResults = new ConcurrentHashMap&lt;&gt;();</span>
 93 
 94     // Map&lt;Provider,?&gt; of the providers currently being verified
 95     private static final Map&lt;Provider, Object&gt; verifyingProviders =
 96             new IdentityHashMap&lt;&gt;();
 97 
 98     private static final boolean isRestricted;
 99 
100     /*
101      * Don&#39;t let anyone instantiate this.
102      */
103     private JceSecurity() {
104     }
105 
106     static {
107         try {
108             AccessController.doPrivileged(
109                 new PrivilegedExceptionAction&lt;&gt; () {
110                     @Override
111                     public Void run() throws Exception {
112                         setupJurisdictionPolicies();
113                         return null;
114                     }
115                 }
116             );
117 
118             isRestricted = defaultPolicy.implies(
119                 CryptoAllPermission.INSTANCE) ? false : true;
120         } catch (Exception e) {
121             throw new SecurityException(
122                     &quot;Can not initialize cryptographic mechanism&quot;, e);
123         }
124     }
125 
126     static Instance getInstance(String type, Class&lt;?&gt; clazz, String algorithm,
127             String provider) throws NoSuchAlgorithmException,
128             NoSuchProviderException {
129         Service s = GetInstance.getService(type, algorithm, provider);
130         Exception ve = getVerificationResult(s.getProvider());
131         if (ve != null) {
132             String msg = &quot;JCE cannot authenticate the provider &quot; + provider;
133             throw (NoSuchProviderException)
134                                 new NoSuchProviderException(msg).initCause(ve);
135         }
136         return GetInstance.getInstance(s, clazz);
137     }
138 
139     static Instance getInstance(String type, Class&lt;?&gt; clazz, String algorithm,
140             Provider provider) throws NoSuchAlgorithmException {
141         Service s = GetInstance.getService(type, algorithm, provider);
142         Exception ve = JceSecurity.getVerificationResult(provider);
143         if (ve != null) {
144             String msg = &quot;JCE cannot authenticate the provider &quot;
145                 + provider.getName();
146             throw new SecurityException(msg, ve);
147         }
148         return GetInstance.getInstance(s, clazz);
149     }
150 
151     static Instance getInstance(String type, Class&lt;?&gt; clazz, String algorithm)
152             throws NoSuchAlgorithmException {
153         List&lt;Service&gt; services = GetInstance.getServices(type, algorithm);
154         NoSuchAlgorithmException failure = null;
155         for (Service s : services) {
156             if (canUseProvider(s.getProvider()) == false) {
157                 // allow only signed providers
158                 continue;
159             }
160             try {
161                 Instance instance = GetInstance.getInstance(s, clazz);
162                 return instance;
163             } catch (NoSuchAlgorithmException e) {
164                 failure = e;
165             }
166         }
167         throw new NoSuchAlgorithmException(&quot;Algorithm &quot; + algorithm
168                 + &quot; not available&quot;, failure);
169     }
170 
171     /**
172      * Verify if the JAR at URL codeBase is a signed exempt application
173      * JAR file and returns the permissions bundled with the JAR.
174      *
175      * @throws Exception on error
176      */
177     static CryptoPermissions verifyExemptJar(URL codeBase) throws Exception {
178         ProviderVerifier pv = new ProviderVerifier(codeBase, true);
179         pv.verify();
180         return pv.getPermissions();
181     }
182 
183     /**
184      * Verify if the JAR at URL codeBase is a signed provider JAR file.
185      *
186      * @throws Exception on error
187      */
188     static void verifyProvider(URL codeBase, Provider p) throws Exception {
189         // Verify the provider JAR file and all
190         // supporting JAR files if there are any.
191         ProviderVerifier pv = new ProviderVerifier(codeBase, p, false);
192         pv.verify();
193     }
194 
195     private static final Object PROVIDER_VERIFIED = Boolean.TRUE;
196 
197     /*
198      * Verify that the provider JAR files are signed properly, which
199      * means the signer&#39;s certificate can be traced back to a
200      * JCE trusted CA.
201      * Return null if ok, failure Exception if verification failed.
202      */
<a name="4" id="anc4"></a><span class="line-modified">203     static Exception getVerificationResult(Provider p) {</span>
<span class="line-modified">204         IdentityWrapper pKey = new IdentityWrapper(p);</span>
<span class="line-modified">205         Object o = verificationResults.get(pKey);</span>
<span class="line-modified">206         // no mapping found</span>
<span class="line-modified">207         if (o == null) {</span>
<span class="line-modified">208             synchronized (JceSecurity.class) {</span>
<span class="line-modified">209                 // check cache again in case the result is now available</span>
<span class="line-modified">210                 o = verificationResults.get(pKey);</span>
<span class="line-modified">211                 if (o == null) {</span>
<span class="line-modified">212                     if (verifyingProviders.get(p) != null) {</span>
<span class="line-modified">213                         // recursion; return failure now</span>
<span class="line-modified">214                         return new NoSuchProviderException</span>
<span class="line-modified">215                                 (&quot;Recursion during verification&quot;);</span>
<span class="line-modified">216                     }</span>
<span class="line-modified">217                     try {</span>
<span class="line-modified">218                         verifyingProviders.put(p, Boolean.FALSE);</span>
<span class="line-modified">219                         URL providerURL = getCodeBase(p.getClass());</span>
<span class="line-modified">220                         verifyProvider(providerURL, p);</span>
<span class="line-modified">221                         o = PROVIDER_VERIFIED;</span>
<span class="line-modified">222                     } catch (Exception e) {</span>
<span class="line-modified">223                         o = e;</span>
<span class="line-modified">224                     } finally {</span>
<span class="line-modified">225                         verifyingProviders.remove(p);</span>
<span class="line-modified">226                     }</span>
<span class="line-added">227                     verificationResults.put(pKey, o);</span>
<span class="line-added">228                     if (debug != null) {</span>
<span class="line-added">229                         debug.println(&quot;Provider &quot; + p.getName() +</span>
<span class="line-added">230                                 &quot; verification result: &quot; + o);</span>
<span class="line-added">231                     }</span>
<span class="line-added">232                 }</span>
<span class="line-added">233             }</span>
234         }
<a name="5" id="anc5"></a><span class="line-added">235         return (o == PROVIDER_VERIFIED? null : (Exception) o);</span>
236     }
237 
238     // return whether this provider is properly signed and can be used by JCE
239     static boolean canUseProvider(Provider p) {
240         return getVerificationResult(p) == null;
241     }
242 
243     // dummy object to represent null
244     private static final URL NULL_URL;
245 
246     static {
247         try {
248             NULL_URL = new URL(&quot;http://null.oracle.com/&quot;);
249         } catch (Exception e) {
250             throw new RuntimeException(e);
251         }
252     }
253 
254     // reference to a Map we use as a cache for codebases
255     private static final Map&lt;Class&lt;?&gt;, URL&gt; codeBaseCacheRef =
256             new WeakHashMap&lt;&gt;();
257 
258     /*
259      * Returns the CodeBase for the given class.
260      */
261     static URL getCodeBase(final Class&lt;?&gt; clazz) {
262         synchronized (codeBaseCacheRef) {
263             URL url = codeBaseCacheRef.get(clazz);
264             if (url == null) {
265                 url = AccessController.doPrivileged(
266                     new PrivilegedAction&lt;&gt;() {
267                         @Override
268                         public URL run() {
269                             ProtectionDomain pd = clazz.getProtectionDomain();
270                             if (pd != null) {
271                                 CodeSource cs = pd.getCodeSource();
272                                 if (cs != null) {
273                                     return cs.getLocation();
274                                 }
275                             }
276                             return NULL_URL;
277                         }
278                     });
279                 codeBaseCacheRef.put(clazz, url);
280             }
281             return (url == NULL_URL) ? null : url;
282         }
283     }
284 
285     // This is called from within an doPrivileged block.
286     private static void setupJurisdictionPolicies() throws Exception {
287 
288         // Sanity check the crypto.policy Security property.  Single
289         // directory entry, no pseudo-directories (&quot;.&quot;, &quot;..&quot;, leading/trailing
290         // path separators). normalize()/getParent() will help later.
291         String cryptoPolicyProperty = Security.getProperty(&quot;crypto.policy&quot;);
292 
293         /*
294          * In case no property is present, rather than fail catastrophically,
295          * we at least try for a &quot;sane&quot; value, which is what we were
296          * built with.  We first preprocess this file to plug in that
297          * value, then compile the result gensrc.
298          *
299          * Log the warning first.
300          */
301         if (cryptoPolicyProperty == null) {
302             cryptoPolicyProperty = &quot;@@JCE_DEFAULT_POLICY@@&quot;;
303             if (debug != null) {
304                 debug.println(
305                     &quot;Security Property &#39;crypto.policy&#39; not found: &quot;
306                     + &quot;using &#39;&quot; + cryptoPolicyProperty + &quot;&#39; as fallback&quot;);
307             }
308         }
309 
310         Path cpPath = Paths.get(cryptoPolicyProperty);
311 
312         if ((cpPath.getNameCount() != 1) ||
313                 (cpPath.compareTo(cpPath.getFileName()) != 0)) {
314             throw new SecurityException(
315                 &quot;Invalid policy directory name format: &quot; +
316                 cryptoPolicyProperty);
317         }
318 
319         // Prepend java.home to get the full path.  normalize() in
320         // case an extra &quot;.&quot; or &quot;..&quot; snuck in somehow.
321         String javaHomeProperty = StaticProperty.javaHome();
322         Path javaHomePolicyPath = Paths.get(javaHomeProperty, &quot;conf&quot;,
323                 &quot;security&quot;, &quot;policy&quot;).normalize();
324         Path cryptoPolicyPath = Paths.get(javaHomeProperty, &quot;conf&quot;, &quot;security&quot;,
325                 &quot;policy&quot;, cryptoPolicyProperty).normalize();
326 
327         if (cryptoPolicyPath.getParent().compareTo(javaHomePolicyPath) != 0) {
328             throw new SecurityException(
329                 &quot;Invalid cryptographic jurisdiction policy directory path: &quot; +
330                 cryptoPolicyProperty);
331         }
332 
333         if (!Files.isDirectory(cryptoPolicyPath)
334                 || !Files.isReadable(cryptoPolicyPath)) {
335             throw new SecurityException(
336                 &quot;Can&#39;t read cryptographic policy directory: &quot; +
337                 cryptoPolicyProperty);
338         }
339 
340         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(
341                 cryptoPolicyPath, &quot;{default,exempt}_*.policy&quot;)) {
342             for (Path entry : stream) {
343                 try (InputStream is = new BufferedInputStream(
344                         Files.newInputStream(entry))) {
345                     String filename = entry.getFileName().toString();
346 
347                     CryptoPermissions tmpPerms = new CryptoPermissions();
348                     tmpPerms.load(is);
349 
350                     if (filename.startsWith(&quot;default_&quot;)) {
351                         // Did we find a default perms?
352                         defaultPolicy = ((defaultPolicy == null) ? tmpPerms :
353                                 defaultPolicy.getMinimum(tmpPerms));
354                     } else if (filename.startsWith(&quot;exempt_&quot;)) {
355                         // Did we find a exempt perms?
356                         exemptPolicy = ((exemptPolicy == null) ? tmpPerms :
357                                 exemptPolicy.getMinimum(tmpPerms));
358                     } else {
359                         // This should never happen.  newDirectoryStream
360                         // should only throw return &quot;{default,exempt}_*.policy&quot;
361                         throw new SecurityException(
362                             &quot;Unexpected jurisdiction policy files in : &quot; +
363                             cryptoPolicyProperty);
364                     }
365                 } catch (Exception e) {
366                     throw new SecurityException(
367                         &quot;Couldn&#39;t parse jurisdiction policy files in: &quot; +
368                         cryptoPolicyProperty);
369                 }
370             }
371         } catch (DirectoryIteratorException ex) {
372             // I/O error encountered during the iteration,
373             // the cause is an IOException
374             throw new SecurityException(
375                 &quot;Couldn&#39;t iterate through the jurisdiction policy files: &quot; +
376                 cryptoPolicyProperty);
377         }
378 
379         // Must have a default policy
380         if ((defaultPolicy == null) || defaultPolicy.isEmpty()) {
381             throw new SecurityException(
382                 &quot;Missing mandatory jurisdiction policy files: &quot; +
383                 cryptoPolicyProperty);
384         }
385 
386         // If there was an empty exempt policy file, ignore it.
387         if ((exemptPolicy != null) &amp;&amp; exemptPolicy.isEmpty()) {
388             exemptPolicy = null;
389         }
390     }
391 
392     static CryptoPermissions getDefaultPolicy() {
393         return defaultPolicy;
394     }
395 
396     static CryptoPermissions getExemptPolicy() {
397         return exemptPolicy;
398     }
399 
400     static boolean isRestricted() {
401         return isRestricted;
402     }
<a name="6" id="anc6"></a><span class="line-added">403 </span>
<span class="line-added">404     private static final class IdentityWrapper {</span>
<span class="line-added">405 </span>
<span class="line-added">406         final Provider obj;</span>
<span class="line-added">407 </span>
<span class="line-added">408         IdentityWrapper(Provider obj) {</span>
<span class="line-added">409             this.obj = obj;</span>
<span class="line-added">410         }</span>
<span class="line-added">411 </span>
<span class="line-added">412         @Override</span>
<span class="line-added">413         public boolean equals(Object o) {</span>
<span class="line-added">414             if (this == o) {</span>
<span class="line-added">415                 return true;</span>
<span class="line-added">416             }</span>
<span class="line-added">417             if (!(o instanceof IdentityWrapper)) {</span>
<span class="line-added">418                 return false;</span>
<span class="line-added">419             }</span>
<span class="line-added">420             return this.obj == ((IdentityWrapper)o).obj;</span>
<span class="line-added">421         }</span>
<span class="line-added">422 </span>
<span class="line-added">423         @Override</span>
<span class="line-added">424         public int hashCode() {</span>
<span class="line-added">425             return System.identityHashCode(obj);</span>
<span class="line-added">426         }</span>
<span class="line-added">427     }</span>
428 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
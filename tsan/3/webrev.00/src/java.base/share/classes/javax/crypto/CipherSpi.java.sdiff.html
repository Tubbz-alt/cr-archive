<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/javax/crypto/CipherSpi.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Cipher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CryptoAllPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/javax/crypto/CipherSpi.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 744     private int bufferCrypt(ByteBuffer input, ByteBuffer output,
 745             boolean isUpdate) throws ShortBufferException,
 746             IllegalBlockSizeException, BadPaddingException {
 747         if ((input == null) || (output == null)) {
 748             throw new NullPointerException
 749                 (&quot;Input and output buffers must not be null&quot;);
 750         }
 751         int inPos = input.position();
 752         int inLimit = input.limit();
 753         int inLen = inLimit - inPos;
 754         if (isUpdate &amp;&amp; (inLen == 0)) {
 755             return 0;
 756         }
 757         int outLenNeeded = engineGetOutputSize(inLen);
 758 
 759         if (output.remaining() &lt; outLenNeeded) {
 760             throw new ShortBufferException(&quot;Need at least &quot; + outLenNeeded
 761                 + &quot; bytes of space in output buffer&quot;);
 762         }
 763 




 764         boolean a1 = input.hasArray();
 765         boolean a2 = output.hasArray();
 766         int total = 0;
<span class="line-removed"> 767         byte[] inArray, outArray;</span>
<span class="line-removed"> 768         if (a2) { // output has an accessible byte[]</span>
<span class="line-removed"> 769             outArray = output.array();</span>
<span class="line-removed"> 770             int outPos = output.position();</span>
<span class="line-removed"> 771             int outOfs = output.arrayOffset() + outPos;</span>
 772 
<span class="line-modified"> 773             if (a1) { // input also has an accessible byte[]</span>
<span class="line-modified"> 774                 inArray = input.array();</span>
<span class="line-modified"> 775                 int inOfs = input.arrayOffset() + inPos;</span>
















 776                 if (isUpdate) {
 777                     total = engineUpdate(inArray, inOfs, inLen, outArray, outOfs);
 778                 } else {
 779                     total = engineDoFinal(inArray, inOfs, inLen, outArray, outOfs);
 780                 }







 781                 input.position(inLimit);
<span class="line-modified"> 782             } else { // input does not have accessible byte[]</span>
<span class="line-modified"> 783                 inArray = new byte[getTempArraySize(inLen)];</span>
<span class="line-removed"> 784                 do {</span>
<span class="line-removed"> 785                     int chunk = Math.min(inLen, inArray.length);</span>
<span class="line-removed"> 786                     if (chunk &gt; 0) {</span>
<span class="line-removed"> 787                         input.get(inArray, 0, chunk);</span>
<span class="line-removed"> 788                     }</span>
<span class="line-removed"> 789                     int n;</span>
<span class="line-removed"> 790                     if (isUpdate || (inLen &gt; chunk)) {</span>
<span class="line-removed"> 791                         n = engineUpdate(inArray, 0, chunk, outArray, outOfs);</span>
<span class="line-removed"> 792                     } else {</span>
<span class="line-removed"> 793                         n = engineDoFinal(inArray, 0, chunk, outArray, outOfs);</span>
<span class="line-removed"> 794                     }</span>
<span class="line-removed"> 795                     total += n;</span>
<span class="line-removed"> 796                     outOfs += n;</span>
<span class="line-removed"> 797                     inLen -= chunk;</span>
<span class="line-removed"> 798                 } while (inLen &gt; 0);</span>
<span class="line-removed"> 799             }</span>
<span class="line-removed"> 800             output.position(outPos + total);</span>
<span class="line-removed"> 801         } else { // output does not have an accessible byte[]</span>
<span class="line-removed"> 802             if (a1) { // but input has an accessible byte[]</span>
<span class="line-removed"> 803                 inArray = input.array();</span>
<span class="line-removed"> 804                 int inOfs = input.arrayOffset() + inPos;</span>
 805                 if (isUpdate) {
 806                     outArray = engineUpdate(inArray, inOfs, inLen);
 807                 } else {
 808                     outArray = engineDoFinal(inArray, inOfs, inLen);
 809                 }
<span class="line-removed"> 810                 input.position(inLimit);</span>
 811                 if (outArray != null &amp;&amp; outArray.length != 0) {
 812                     output.put(outArray);
 813                     total = outArray.length;
 814                 }
<span class="line-modified"> 815             } else { // input also does not have an accessible byte[]</span>
<span class="line-modified"> 816                 inArray = new byte[getTempArraySize(inLen)];</span>
<span class="line-modified"> 817                 do {</span>
<span class="line-modified"> 818                     int chunk = Math.min(inLen, inArray.length);</span>
<span class="line-modified"> 819                     if (chunk &gt; 0) {</span>
<span class="line-modified"> 820                         input.get(inArray, 0, chunk);</span>
<span class="line-modified"> 821                     }</span>
<span class="line-modified"> 822                     int n;</span>
<span class="line-modified"> 823                     if (isUpdate || (inLen &gt; chunk)) {</span>
<span class="line-modified"> 824                         outArray = engineUpdate(inArray, 0, chunk);</span>
<span class="line-modified"> 825                     } else {</span>
<span class="line-modified"> 826                         outArray = engineDoFinal(inArray, 0, chunk);</span>
<span class="line-modified"> 827                     }</span>
<span class="line-modified"> 828                     if (outArray != null &amp;&amp; outArray.length != 0) {</span>
<span class="line-modified"> 829                         output.put(outArray);</span>
<span class="line-modified"> 830                         total += outArray.length;</span>
<span class="line-modified"> 831                     }</span>
<span class="line-modified"> 832                     inLen -= chunk;</span>
<span class="line-modified"> 833                 } while (inLen &gt; 0);</span>








 834             }
 835         }

 836         return total;
 837     }
 838 
 839     /**
 840      * Wrap a key.
 841      *
 842      * &lt;p&gt;This concrete method has been added to this previously-defined
 843      * abstract class. (For backwards compatibility, it cannot be abstract.)
 844      * It may be overridden by a provider to wrap a key.
 845      * Such an override is expected to throw an IllegalBlockSizeException or
 846      * InvalidKeyException (under the specified circumstances),
 847      * if the given key cannot be wrapped.
 848      * If this method is not overridden, it always throws an
 849      * UnsupportedOperationException.
 850      *
 851      * @param key the key to be wrapped.
 852      *
 853      * @return the wrapped key.
 854      *
 855      * @exception IllegalBlockSizeException if this cipher is a block cipher,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 744     private int bufferCrypt(ByteBuffer input, ByteBuffer output,
 745             boolean isUpdate) throws ShortBufferException,
 746             IllegalBlockSizeException, BadPaddingException {
 747         if ((input == null) || (output == null)) {
 748             throw new NullPointerException
 749                 (&quot;Input and output buffers must not be null&quot;);
 750         }
 751         int inPos = input.position();
 752         int inLimit = input.limit();
 753         int inLen = inLimit - inPos;
 754         if (isUpdate &amp;&amp; (inLen == 0)) {
 755             return 0;
 756         }
 757         int outLenNeeded = engineGetOutputSize(inLen);
 758 
 759         if (output.remaining() &lt; outLenNeeded) {
 760             throw new ShortBufferException(&quot;Need at least &quot; + outLenNeeded
 761                 + &quot; bytes of space in output buffer&quot;);
 762         }
 763 
<span class="line-added"> 764         // detecting input and output buffer overlap may be tricky</span>
<span class="line-added"> 765         // we can only write directly into output buffer when we</span>
<span class="line-added"> 766         // are 100% sure it&#39;s safe to do so</span>
<span class="line-added"> 767 </span>
 768         boolean a1 = input.hasArray();
 769         boolean a2 = output.hasArray();
 770         int total = 0;





 771 
<span class="line-modified"> 772         if (a1) { // input has an accessible byte[]</span>
<span class="line-modified"> 773             byte[] inArray = input.array();</span>
<span class="line-modified"> 774             int inOfs = input.arrayOffset() + inPos;</span>
<span class="line-added"> 775 </span>
<span class="line-added"> 776             if (a2) { // output has an accessible byte[]</span>
<span class="line-added"> 777                 byte[] outArray = output.array();</span>
<span class="line-added"> 778                 int outPos = output.position();</span>
<span class="line-added"> 779                 int outOfs = output.arrayOffset() + outPos;</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781                 // check array address and offsets and use temp output buffer</span>
<span class="line-added"> 782                 // if output offset is larger than input offset and</span>
<span class="line-added"> 783                 // falls within the range of input data</span>
<span class="line-added"> 784                 boolean useTempOut = false;</span>
<span class="line-added"> 785                 if (inArray == outArray &amp;&amp;</span>
<span class="line-added"> 786                     ((inOfs &lt; outOfs) &amp;&amp; (outOfs &lt; inOfs + inLen))) {</span>
<span class="line-added"> 787                     useTempOut = true;</span>
<span class="line-added"> 788                     outArray = new byte[outLenNeeded];</span>
<span class="line-added"> 789                     outOfs = 0;</span>
<span class="line-added"> 790                 }</span>
 791                 if (isUpdate) {
 792                     total = engineUpdate(inArray, inOfs, inLen, outArray, outOfs);
 793                 } else {
 794                     total = engineDoFinal(inArray, inOfs, inLen, outArray, outOfs);
 795                 }
<span class="line-added"> 796                 if (useTempOut) {</span>
<span class="line-added"> 797                     output.put(outArray, outOfs, total);</span>
<span class="line-added"> 798                 } else {</span>
<span class="line-added"> 799                     // adjust output position manually</span>
<span class="line-added"> 800                     output.position(outPos + total);</span>
<span class="line-added"> 801                 }</span>
<span class="line-added"> 802                 // adjust input position manually</span>
 803                 input.position(inLimit);
<span class="line-modified"> 804             } else { // output does not have an accessible byte[]</span>
<span class="line-modified"> 805                 byte[] outArray = null;</span>





















 806                 if (isUpdate) {
 807                     outArray = engineUpdate(inArray, inOfs, inLen);
 808                 } else {
 809                     outArray = engineDoFinal(inArray, inOfs, inLen);
 810                 }

 811                 if (outArray != null &amp;&amp; outArray.length != 0) {
 812                     output.put(outArray);
 813                     total = outArray.length;
 814                 }
<span class="line-modified"> 815                 // adjust input position manually</span>
<span class="line-modified"> 816                 input.position(inLimit);</span>
<span class="line-modified"> 817             }</span>
<span class="line-modified"> 818         } else { // input does not have an accessible byte[]</span>
<span class="line-modified"> 819             // have to assume the worst, since we have no way of determine</span>
<span class="line-modified"> 820             // if input and output overlaps or not</span>
<span class="line-modified"> 821             byte[] tempOut = new byte[outLenNeeded];</span>
<span class="line-modified"> 822             int outOfs = 0;</span>
<span class="line-modified"> 823 </span>
<span class="line-modified"> 824             byte[] tempIn = new byte[getTempArraySize(inLen)];</span>
<span class="line-modified"> 825             do {</span>
<span class="line-modified"> 826                 int chunk = Math.min(inLen, tempIn.length);</span>
<span class="line-modified"> 827                 if (chunk &gt; 0) {</span>
<span class="line-modified"> 828                     input.get(tempIn, 0, chunk);</span>
<span class="line-modified"> 829                 }</span>
<span class="line-modified"> 830                 int n;</span>
<span class="line-modified"> 831                 if (isUpdate || (inLen &gt; chunk)) {</span>
<span class="line-modified"> 832                     n = engineUpdate(tempIn, 0, chunk, tempOut, outOfs);</span>
<span class="line-modified"> 833                 } else {</span>
<span class="line-added"> 834                     n = engineDoFinal(tempIn, 0, chunk, tempOut, outOfs);</span>
<span class="line-added"> 835                 }</span>
<span class="line-added"> 836                 outOfs += n;</span>
<span class="line-added"> 837                 total += n;</span>
<span class="line-added"> 838                 inLen -= chunk;</span>
<span class="line-added"> 839             } while (inLen &gt; 0);</span>
<span class="line-added"> 840             if (total &gt; 0) {</span>
<span class="line-added"> 841                 output.put(tempOut, 0, total);</span>
 842             }
 843         }
<span class="line-added"> 844 </span>
 845         return total;
 846     }
 847 
 848     /**
 849      * Wrap a key.
 850      *
 851      * &lt;p&gt;This concrete method has been added to this previously-defined
 852      * abstract class. (For backwards compatibility, it cannot be abstract.)
 853      * It may be overridden by a provider to wrap a key.
 854      * Such an override is expected to throw an IllegalBlockSizeException or
 855      * InvalidKeyException (under the specified circumstances),
 856      * if the given key cannot be wrapped.
 857      * If this method is not overridden, it always throws an
 858      * UnsupportedOperationException.
 859      *
 860      * @param key the key to be wrapped.
 861      *
 862      * @return the wrapped key.
 863      *
 864      * @exception IllegalBlockSizeException if this cipher is a block cipher,
</pre>
</td>
</tr>
</table>
<center><a href="Cipher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CryptoAllPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="IllegalAccessMaps.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ModuleInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 123      * Returns the ModuleFinder for the initial configuration.
 124      *
 125      * @apiNote Used to support &quot;{@code java --list-modules}&quot;.
 126      */
 127     public static ModuleFinder limitedFinder() {
 128         ModuleFinder finder = limitedFinder;
 129         if (finder == null) {
 130             return unlimitedFinder();
 131         } else {
 132             return finder;
 133         }
 134     }
 135 
 136     /**
 137      * Initialize the module system, returning the boot layer.
 138      *
 139      * @see java.lang.System#initPhase2(boolean, boolean)
 140      */
 141     public static ModuleLayer boot() throws Exception {
 142 
<span class="line-modified"> 143         // Step 0: Command line options</span>
 144 
<span class="line-modified"> 145         long t0 = System.nanoTime();</span>
 146 
 147         ModuleFinder upgradeModulePath = finderFor(&quot;jdk.module.upgrade.path&quot;);
 148         ModuleFinder appModulePath = finderFor(&quot;jdk.module.path&quot;);
 149         boolean isPatched = patcher.hasPatches();
 150 
 151         String mainModule = System.getProperty(&quot;jdk.module.main&quot;);
 152         Set&lt;String&gt; addModules = addModules();
 153         Set&lt;String&gt; limitModules = limitModules();
 154 
 155         PrintStream traceOutput = null;
 156         String trace = getAndRemoveProperty(&quot;jdk.module.showModuleResolution&quot;);
 157         if (trace != null &amp;&amp; Boolean.parseBoolean(trace))
 158             traceOutput = System.out;
 159 

 160 
 161         // Step 1: The observable system modules, either all system modules
 162         // or the system modules pre-generated for the initial module (the
 163         // initial module may be the unnamed module). If the system modules
 164         // are pre-generated for the initial module then resolution can be
 165         // skipped.
 166 
<span class="line-removed"> 167         long t1 = System.nanoTime();</span>
<span class="line-removed"> 168 </span>
 169         SystemModules systemModules = null;
 170         ModuleFinder systemModuleFinder;
 171 
 172         boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);
 173         boolean needResolution = true;
 174         boolean canArchive = false;
 175         boolean hasSplitPackages;
 176         boolean hasIncubatorModules;
 177 
 178         // If the java heap was archived at CDS dump time and the environment
 179         // at dump time matches the current environment then use the archived
 180         // system modules and finder.
 181         ArchivedModuleGraph archivedModuleGraph = ArchivedModuleGraph.get(mainModule);
 182         if (archivedModuleGraph != null
 183                 &amp;&amp; !haveModulePath
 184                 &amp;&amp; addModules.isEmpty()
 185                 &amp;&amp; limitModules.isEmpty()
 186                 &amp;&amp; !isPatched) {
 187             systemModuleFinder = archivedModuleGraph.finder();
 188             hasSplitPackages = archivedModuleGraph.hasSplitPackages();
</pre>
<hr />
<pre>
 198             }
 199             if (systemModules == null) {
 200                 // all system modules are observable
 201                 systemModules = SystemModuleFinders.allSystemModules();
 202             }
 203             if (systemModules != null) {
 204                 // images build
 205                 systemModuleFinder = SystemModuleFinders.of(systemModules);
 206             } else {
 207                 // exploded build or testing
 208                 systemModules = new ExplodedSystemModules();
 209                 systemModuleFinder = SystemModuleFinders.ofSystem();
 210             }
 211 
 212             hasSplitPackages = systemModules.hasSplitPackages();
 213             hasIncubatorModules = systemModules.hasIncubatorModules();
 214             // not using the archived module graph - avoid accidental use
 215             archivedModuleGraph = null;
 216         }
 217 
<span class="line-modified"> 218         Counters.add(&quot;jdk.module.boot.1.systemModulesTime&quot;, t1);</span>
<span class="line-removed"> 219 </span>
 220 
 221         // Step 2: Define and load java.base. This patches all classes loaded
 222         // to date so that they are members of java.base. Once java.base is
 223         // loaded then resources in java.base are available for error messages
 224         // needed from here on.
 225 
<span class="line-removed"> 226         long t2 = System.nanoTime();</span>
<span class="line-removed"> 227 </span>
 228         ModuleReference base = systemModuleFinder.find(JAVA_BASE).orElse(null);
 229         if (base == null)
 230             throw new InternalError(JAVA_BASE + &quot; not found&quot;);
 231         URI baseUri = base.location().orElse(null);
 232         if (baseUri == null)
 233             throw new InternalError(JAVA_BASE + &quot; does not have a location&quot;);
 234         BootLoader.loadModule(base);
 235         Modules.defineModule(null, base.descriptor(), baseUri);
 236 
<span class="line-removed"> 237         Counters.add(&quot;jdk.module.boot.2.defineBaseTime&quot;, t2);</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239 </span>
 240         // Step 2a: Scan all modules when --validate-modules specified
 241 
 242         if (getAndRemoveProperty(&quot;jdk.module.validation&quot;) != null) {
 243             int errors = ModulePathValidator.scanAllModules(System.out);
 244             if (errors &gt; 0) {
 245                 fail(&quot;Validation of module path failed&quot;);
 246             }
 247         }
 248 

 249 
 250         // Step 3: If resolution is needed then create the module finder and
 251         // the set of root modules to resolve.
 252 
<span class="line-removed"> 253         long t3 = System.nanoTime();</span>
<span class="line-removed"> 254 </span>
 255         ModuleFinder savedModuleFinder = null;
 256         ModuleFinder finder;
 257         Set&lt;String&gt; roots;
 258         if (needResolution) {
 259 
 260             // upgraded modules override the modules in the run-time image
 261             if (upgradeModulePath != null)
 262                 systemModuleFinder = ModuleFinder.compose(upgradeModulePath,
 263                                                           systemModuleFinder);
 264 
 265             // The module finder: [--upgrade-module-path] system [--module-path]
 266             if (appModulePath != null) {
 267                 finder = ModuleFinder.compose(systemModuleFinder, appModulePath);
 268             } else {
 269                 finder = systemModuleFinder;
 270             }
 271 
 272             // The root modules to resolve
 273             roots = new HashSet&lt;&gt;();
 274 
</pre>
<hr />
<pre>
 324                     .forEach(mn -&gt; roots.add(mn));
 325             }
 326 
 327             // If `--add-modules ALL-MODULE-PATH` is specified then all observable
 328             // modules on the application module path will be resolved.
 329             if (appModulePath != null &amp;&amp; addAllApplicationModules) {
 330                 ModuleFinder f = finder;  // observable modules
 331                 appModulePath.findAll()
 332                     .stream()
 333                     .map(ModuleReference::descriptor)
 334                     .map(ModuleDescriptor::name)
 335                     .filter(mn -&gt; f.find(mn).isPresent())  // observable
 336                     .forEach(mn -&gt; roots.add(mn));
 337             }
 338         } else {
 339             // no resolution case
 340             finder = systemModuleFinder;
 341             roots = null;
 342         }
 343 
<span class="line-modified"> 344         Counters.add(&quot;jdk.module.boot.3.optionsAndRootsTime&quot;, t3);</span>
 345 
 346         // Step 4: Resolve the root modules, with service binding, to create
 347         // the configuration for the boot layer. If resolution is not needed
 348         // then create the configuration for the boot layer from the
 349         // readability graph created at link time.
 350 
<span class="line-removed"> 351         long t4 = System.nanoTime();</span>
<span class="line-removed"> 352 </span>
 353         Configuration cf;
 354         if (needResolution) {
<span class="line-modified"> 355             cf = JLMA.resolveAndBind(finder, roots, traceOutput);</span>
 356         } else {
 357             if (archivedModuleGraph != null) {
 358                 cf = archivedModuleGraph.configuration();
 359             } else {
 360                 Map&lt;String, Set&lt;String&gt;&gt; map = systemModules.moduleReads();
 361                 cf = JLMA.newConfiguration(systemModuleFinder, map);
 362             }
 363         }
 364 
 365         // check that modules specified to --patch-module are resolved
 366         if (isPatched) {
 367             patcher.patchedModules()
 368                     .stream()
 369                     .filter(mn -&gt; !cf.findModule(mn).isPresent())
 370                     .forEach(mn -&gt; warnUnknownModule(PATCH_MODULE, mn));
 371         }
 372 
<span class="line-modified"> 373         Counters.add(&quot;jdk.module.boot.4.resolveTime&quot;, t4);</span>
<span class="line-removed"> 374 </span>
 375 
 376         // Step 5: Map the modules in the configuration to class loaders.
 377         // The static configuration provides the mapping of standard and JDK
 378         // modules to the boot and platform loaders. All other modules (JDK
 379         // tool modules, and both explicit and automatic modules on the
 380         // application module path) are defined to the application class
 381         // loader.
 382 
<span class="line-removed"> 383         long t5 = System.nanoTime();</span>
<span class="line-removed"> 384 </span>
 385         // mapping of modules to class loaders
<span class="line-modified"> 386         Function&lt;String, ClassLoader&gt; clf = ModuleLoaderMap.mappingFunction(cf);</span>





 387 
 388         // check that all modules to be mapped to the boot loader will be
 389         // loaded from the runtime image
 390         if (haveModulePath) {
 391             for (ResolvedModule resolvedModule : cf.modules()) {
 392                 ModuleReference mref = resolvedModule.reference();
 393                 String name = mref.descriptor().name();
 394                 ClassLoader cl = clf.apply(name);
 395                 if (cl == null) {
 396                     if (upgradeModulePath != null
 397                             &amp;&amp; upgradeModulePath.find(name).isPresent())
 398                         fail(name + &quot;: cannot be loaded from upgrade module path&quot;);
 399                     if (!systemModuleFinder.find(name).isPresent())
 400                         fail(name + &quot;: cannot be loaded from application module path&quot;);
 401                 }
 402             }
 403         }
 404 
 405         // check for split packages in the modules mapped to the built-in loaders
 406         if (hasSplitPackages || isPatched || haveModulePath) {
 407             checkSplitPackages(cf, clf);
 408         }
 409 
 410         // load/register the modules with the built-in class loaders
 411         loadModules(cf, clf);
<span class="line-modified"> 412 </span>
<span class="line-removed"> 413         Counters.add(&quot;jdk.module.boot.5.loadModulesTime&quot;, t5);</span>
<span class="line-removed"> 414 </span>
 415 
 416         // Step 6: Define all modules to the VM
 417 
<span class="line-removed"> 418         long t6 = System.nanoTime();</span>
 419         ModuleLayer bootLayer = ModuleLayer.empty().defineModules(cf, clf);
<span class="line-modified"> 420         Counters.add(&quot;jdk.module.boot.6.layerCreateTime&quot;, t6);</span>
<span class="line-removed"> 421 </span>
 422 
 423         // Step 7: Miscellaneous
 424 
 425         // check incubating status
 426         if (hasIncubatorModules || haveModulePath) {
 427             checkIncubatingStatus(cf);
 428         }
 429 
 430         // --add-reads, --add-exports/--add-opens, and --illegal-access
<span class="line-removed"> 431         long t7 = System.nanoTime();</span>
 432         addExtraReads(bootLayer);
 433         boolean extraExportsOrOpens = addExtraExportsAndOpens(bootLayer);
 434 
 435         Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen;
 436         Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen;
 437         if (archivedModuleGraph != null) {
 438             concealedPackagesToOpen = archivedModuleGraph.concealedPackagesToOpen();
 439             exportedPackagesToOpen = archivedModuleGraph.exportedPackagesToOpen();
 440         } else {
 441             concealedPackagesToOpen = systemModules.concealedPackagesToOpen();
 442             exportedPackagesToOpen = systemModules.exportedPackagesToOpen();
 443         }
 444         addIllegalAccess(upgradeModulePath,
 445                          concealedPackagesToOpen,
 446                          exportedPackagesToOpen,
 447                          bootLayer,
 448                          extraExportsOrOpens);
<span class="line-modified"> 449         Counters.add(&quot;jdk.module.boot.7.adjustModulesTime&quot;, t7);</span>
 450 
 451         // save module finders for later use
 452         if (savedModuleFinder != null) {
 453             unlimitedFinder = new SafeModuleFinder(savedModuleFinder);
 454             if (savedModuleFinder != finder)
 455                 limitedFinder = new SafeModuleFinder(finder);
 456         }
 457 
 458         // Module graph can be archived at CDS dump time. Only allow the
 459         // unnamed module case for now.
 460         if (canArchive &amp;&amp; (mainModule == null)) {
<span class="line-modified"> 461             ArchivedModuleGraph.archive(mainModule,</span>
<span class="line-modified"> 462                                         hasSplitPackages,</span>
<span class="line-modified"> 463                                         hasIncubatorModules,</span>
<span class="line-modified"> 464                                         systemModuleFinder,</span>
<span class="line-modified"> 465                                         cf,</span>
<span class="line-modified"> 466                                         concealedPackagesToOpen,</span>
<span class="line-modified"> 467                                         exportedPackagesToOpen);</span>

 468         }
 469 
 470         // total time to initialize
<span class="line-modified"> 471         Counters.add(&quot;jdk.module.boot.totalTime&quot;, t0);</span>
<span class="line-removed"> 472         Counters.publish();</span>
 473 
 474         return bootLayer;
 475     }
 476 
 477     /**
 478      * Load/register the modules to the built-in class loaders.
 479      */
 480     private static void loadModules(Configuration cf,
 481                                     Function&lt;String, ClassLoader&gt; clf) {
 482         for (ResolvedModule resolvedModule : cf.modules()) {
 483             ModuleReference mref = resolvedModule.reference();
 484             String name = resolvedModule.name();
 485             ClassLoader loader = clf.apply(name);
 486             if (loader == null) {
 487                 // skip java.base as it is already loaded
 488                 if (!name.equals(JAVA_BASE)) {
 489                     BootLoader.loadModule(mref);
 490                 }
 491             } else if (loader instanceof BuiltinClassLoader) {
 492                 ((BuiltinClassLoader) loader).loadModule(mref);
</pre>
<hr />
<pre>
 739                     if (om.isPresent()) {
 740                         other = om.get();
 741                     } else {
 742                         warnUnknownModule(option, name);
 743                         continue;
 744                     }
 745                 }
 746                 if (allUnnamed) {
 747                     if (opens) {
 748                         Modules.addOpensToAllUnnamed(m, pn);
 749                     } else {
 750                         Modules.addExportsToAllUnnamed(m, pn);
 751                     }
 752                 } else {
 753                     if (opens) {
 754                         Modules.addOpens(m, pn, other);
 755                     } else {
 756                         Modules.addExports(m, pn, other);
 757                     }
 758                 }
<span class="line-removed"> 759 </span>
 760             }
 761         }
 762     }
 763 
 764     /**
 765      * Process the --illegal-access option (and its default) to open packages
 766      * of system modules in the boot layer to code in unnamed modules.
 767      */
 768     private static void addIllegalAccess(ModuleFinder upgradeModulePath,
 769                                          Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen,
 770                                          Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen,
 771                                          ModuleLayer bootLayer,
 772                                          boolean extraExportsOrOpens) {
 773         String value = getAndRemoveProperty(&quot;jdk.module.illegalAccess&quot;);
 774         IllegalAccessLogger.Mode mode = IllegalAccessLogger.Mode.ONESHOT;
 775         if (value != null) {
 776             switch (value) {
 777                 case &quot;deny&quot;:
 778                     return;
 779                 case &quot;permit&quot;:
</pre>
<hr />
<pre>
 784                 case &quot;debug&quot;:
 785                     mode = IllegalAccessLogger.Mode.DEBUG;
 786                     break;
 787                 default:
 788                     fail(&quot;Value specified to --illegal-access not recognized:&quot;
 789                             + &quot; &#39;&quot; + value + &quot;&#39;&quot;);
 790                     return;
 791             }
 792         }
 793         IllegalAccessLogger.Builder builder
 794             = new IllegalAccessLogger.Builder(mode, System.err);
 795 
 796         if (concealedPackagesToOpen.isEmpty() &amp;&amp; exportedPackagesToOpen.isEmpty()) {
 797             // need to generate (exploded build)
 798             IllegalAccessMaps maps = IllegalAccessMaps.generate(limitedFinder());
 799             concealedPackagesToOpen = maps.concealedPackagesToOpen();
 800             exportedPackagesToOpen = maps.exportedPackagesToOpen();
 801         }
 802 
 803         // open specific packages in the system modules

 804         for (Module m : bootLayer.modules()) {
 805             ModuleDescriptor descriptor = m.getDescriptor();
 806             String name = m.getName();
 807 
 808             // skip open modules
 809             if (descriptor.isOpen()) {
 810                 continue;
 811             }
 812 
 813             // skip modules loaded from the upgrade module path
 814             if (upgradeModulePath != null
 815                 &amp;&amp; upgradeModulePath.find(name).isPresent()) {
 816                 continue;
 817             }
 818 
<span class="line-modified"> 819             Set&lt;String&gt; concealedPackages = concealedPackagesToOpen.getOrDefault(name, Set.of());</span>
<span class="line-modified"> 820             Set&lt;String&gt; exportedPackages = exportedPackagesToOpen.getOrDefault(name, Set.of());</span>
 821 
 822             // refresh the set of concealed and exported packages if needed
 823             if (extraExportsOrOpens) {
 824                 concealedPackages = new HashSet&lt;&gt;(concealedPackages);
 825                 exportedPackages = new HashSet&lt;&gt;(exportedPackages);
 826                 Iterator&lt;String&gt; iterator = concealedPackages.iterator();
 827                 while (iterator.hasNext()) {
 828                     String pn = iterator.next();
 829                     if (m.isExported(pn, BootLoader.getUnnamedModule())) {
 830                         // concealed package is exported to ALL-UNNAMED
 831                         iterator.remove();
 832                         exportedPackages.add(pn);
 833                     }
 834                 }
 835                 iterator = exportedPackages.iterator();
 836                 while (iterator.hasNext()) {
 837                     String pn = iterator.next();
 838                     if (m.isOpen(pn, BootLoader.getUnnamedModule())) {
 839                         // exported package is opened to ALL-UNNAMED
 840                         iterator.remove();
 841                     }
 842                 }
 843             }
 844 
 845             // log reflective access to all types in concealed packages
 846             builder.logAccessToConcealedPackages(m, concealedPackages);
 847 
 848             // log reflective access to non-public members/types in exported packages
 849             builder.logAccessToExportedPackages(m, exportedPackages);
 850 
 851             // open the packages to unnamed modules
 852             JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
<span class="line-modified"> 853             jla.addOpensToAllUnnamed(m, concat(concealedPackages.iterator(),</span>
<span class="line-removed"> 854                                                exportedPackages.iterator()));</span>
 855         }
 856 
 857         builder.complete();
 858     }
 859 
 860     /**
 861      * Decodes the values of --add-reads, -add-exports, --add-opens or
 862      * --patch-modules options that are encoded in system properties.
 863      *
 864      * @param prefix the system property prefix
 865      * @praam regex the regex for splitting the RHS of the option value
 866      */
 867     private static Map&lt;String, List&lt;String&gt;&gt; decode(String prefix,
 868                                                     String regex,
 869                                                     boolean allowDuplicates) {
 870         int index = 0;
 871         // the system property is removed after decoding
 872         String value = getAndRemoveProperty(prefix + index);
 873         if (value == null)
 874             return Map.of();
</pre>
<hr />
<pre>
 978      * Returns the command-line option name corresponds to the specified
 979      * system property prefix.
 980      */
 981     static String option(String prefix) {
 982         switch (prefix) {
 983             case &quot;jdk.module.addexports.&quot;:
 984                 return ADD_EXPORTS;
 985             case &quot;jdk.module.addopens.&quot;:
 986                 return ADD_OPENS;
 987             case &quot;jdk.module.addreads.&quot;:
 988                 return ADD_READS;
 989             case &quot;jdk.module.patch.&quot;:
 990                 return PATCH_MODULE;
 991             case &quot;jdk.module.addmods.&quot;:
 992                 return ADD_MODULES;
 993             default:
 994                 throw new IllegalArgumentException(prefix);
 995         }
 996     }
 997 
<span class="line-removed"> 998     /**</span>
<span class="line-removed"> 999      * Returns an iterator that yields all elements of the first iterator</span>
<span class="line-removed">1000      * followed by all the elements of the second iterator.</span>
<span class="line-removed">1001      */</span>
<span class="line-removed">1002     static &lt;T&gt; Iterator&lt;T&gt; concat(Iterator&lt;T&gt; iterator1, Iterator&lt;T&gt; iterator2) {</span>
<span class="line-removed">1003         return new Iterator&lt;T&gt;() {</span>
<span class="line-removed">1004             @Override</span>
<span class="line-removed">1005             public boolean hasNext() {</span>
<span class="line-removed">1006                 return iterator1.hasNext() || iterator2.hasNext();</span>
<span class="line-removed">1007             }</span>
<span class="line-removed">1008             @Override</span>
<span class="line-removed">1009             public T next() {</span>
<span class="line-removed">1010                 if (iterator1.hasNext()) return iterator1.next();</span>
<span class="line-removed">1011                 if (iterator2.hasNext()) return iterator2.next();</span>
<span class="line-removed">1012                 throw new NoSuchElementException();</span>
<span class="line-removed">1013             }</span>
<span class="line-removed">1014         };</span>
<span class="line-removed">1015     }</span>
<span class="line-removed">1016 </span>
1017     /**
1018      * Wraps a (potentially not thread safe) ModuleFinder created during startup
1019      * for use after startup.
1020      */
1021     static class SafeModuleFinder implements ModuleFinder {
1022         private final Set&lt;ModuleReference&gt; mrefs;
1023         private volatile Map&lt;String, ModuleReference&gt; nameToModule;
1024 
1025         SafeModuleFinder(ModuleFinder finder) {
1026             this.mrefs = Collections.unmodifiableSet(finder.findAll());
1027         }
1028         @Override
1029         public Optional&lt;ModuleReference&gt; find(String name) {
1030             Objects.requireNonNull(name);
1031             Map&lt;String, ModuleReference&gt; nameToModule = this.nameToModule;
1032             if (nameToModule == null) {
1033                 this.nameToModule = nameToModule = mrefs.stream()
1034                         .collect(Collectors.toMap(m -&gt; m.descriptor().name(),
1035                                                   Function.identity()));
1036             }
1037             return Optional.ofNullable(nameToModule.get(name));
1038         }
1039         @Override
1040         public Set&lt;ModuleReference&gt; findAll() {
1041             return mrefs;
1042         }
1043     }
1044 
1045     /**
1046      * Counters for startup performance analysis.
1047      */
1048     static class Counters {
1049         private static final boolean PUBLISH_COUNTERS;
1050         private static final boolean PRINT_COUNTERS;
1051         private static Map&lt;String, Long&gt; counters;



1052         static {
1053             String s = System.getProperty(&quot;jdk.module.boot.usePerfData&quot;);
1054             if (s == null) {
1055                 PUBLISH_COUNTERS = false;
1056                 PRINT_COUNTERS = false;
1057             } else {
1058                 PUBLISH_COUNTERS = true;
1059                 PRINT_COUNTERS = s.equals(&quot;debug&quot;);
1060                 counters = new LinkedHashMap&lt;&gt;();  // preserve insert order
1061             }
1062         }
1063 
1064         /**
<span class="line-modified">1065          * Add a counter</span>










1066          */
<span class="line-modified">1067         static void add(String name, long start) {</span>
<span class="line-modified">1068             if (PUBLISH_COUNTERS || PRINT_COUNTERS) {</span>
<span class="line-modified">1069                 counters.put(name, (System.nanoTime() - start));</span>



1070             }
1071         }
1072 
1073         /**
1074          * Publish the counters to the instrumentation buffer or stdout.
1075          */
<span class="line-modified">1076         static void publish() {</span>
<span class="line-modified">1077             if (PUBLISH_COUNTERS || PRINT_COUNTERS) {</span>

1078                 for (Map.Entry&lt;String, Long&gt; e : counters.entrySet()) {
1079                     String name = e.getKey();
1080                     long value = e.getValue();
<span class="line-modified">1081                     if (PUBLISH_COUNTERS)</span>
<span class="line-removed">1082                         PerfCounter.newPerfCounter(name).set(value);</span>
1083                     if (PRINT_COUNTERS)
1084                         System.out.println(name + &quot; = &quot; + value);
1085                 }




1086             }
1087         }
1088     }
1089 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 123      * Returns the ModuleFinder for the initial configuration.
 124      *
 125      * @apiNote Used to support &quot;{@code java --list-modules}&quot;.
 126      */
 127     public static ModuleFinder limitedFinder() {
 128         ModuleFinder finder = limitedFinder;
 129         if (finder == null) {
 130             return unlimitedFinder();
 131         } else {
 132             return finder;
 133         }
 134     }
 135 
 136     /**
 137      * Initialize the module system, returning the boot layer.
 138      *
 139      * @see java.lang.System#initPhase2(boolean, boolean)
 140      */
 141     public static ModuleLayer boot() throws Exception {
 142 
<span class="line-modified"> 143         Counters.start();</span>
 144 
<span class="line-modified"> 145         // Step 0: Command line options</span>
 146 
 147         ModuleFinder upgradeModulePath = finderFor(&quot;jdk.module.upgrade.path&quot;);
 148         ModuleFinder appModulePath = finderFor(&quot;jdk.module.path&quot;);
 149         boolean isPatched = patcher.hasPatches();
 150 
 151         String mainModule = System.getProperty(&quot;jdk.module.main&quot;);
 152         Set&lt;String&gt; addModules = addModules();
 153         Set&lt;String&gt; limitModules = limitModules();
 154 
 155         PrintStream traceOutput = null;
 156         String trace = getAndRemoveProperty(&quot;jdk.module.showModuleResolution&quot;);
 157         if (trace != null &amp;&amp; Boolean.parseBoolean(trace))
 158             traceOutput = System.out;
 159 
<span class="line-added"> 160         Counters.add(&quot;jdk.module.boot.0.commandLineTime&quot;);</span>
 161 
 162         // Step 1: The observable system modules, either all system modules
 163         // or the system modules pre-generated for the initial module (the
 164         // initial module may be the unnamed module). If the system modules
 165         // are pre-generated for the initial module then resolution can be
 166         // skipped.
 167 


 168         SystemModules systemModules = null;
 169         ModuleFinder systemModuleFinder;
 170 
 171         boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);
 172         boolean needResolution = true;
 173         boolean canArchive = false;
 174         boolean hasSplitPackages;
 175         boolean hasIncubatorModules;
 176 
 177         // If the java heap was archived at CDS dump time and the environment
 178         // at dump time matches the current environment then use the archived
 179         // system modules and finder.
 180         ArchivedModuleGraph archivedModuleGraph = ArchivedModuleGraph.get(mainModule);
 181         if (archivedModuleGraph != null
 182                 &amp;&amp; !haveModulePath
 183                 &amp;&amp; addModules.isEmpty()
 184                 &amp;&amp; limitModules.isEmpty()
 185                 &amp;&amp; !isPatched) {
 186             systemModuleFinder = archivedModuleGraph.finder();
 187             hasSplitPackages = archivedModuleGraph.hasSplitPackages();
</pre>
<hr />
<pre>
 197             }
 198             if (systemModules == null) {
 199                 // all system modules are observable
 200                 systemModules = SystemModuleFinders.allSystemModules();
 201             }
 202             if (systemModules != null) {
 203                 // images build
 204                 systemModuleFinder = SystemModuleFinders.of(systemModules);
 205             } else {
 206                 // exploded build or testing
 207                 systemModules = new ExplodedSystemModules();
 208                 systemModuleFinder = SystemModuleFinders.ofSystem();
 209             }
 210 
 211             hasSplitPackages = systemModules.hasSplitPackages();
 212             hasIncubatorModules = systemModules.hasIncubatorModules();
 213             // not using the archived module graph - avoid accidental use
 214             archivedModuleGraph = null;
 215         }
 216 
<span class="line-modified"> 217         Counters.add(&quot;jdk.module.boot.1.systemModulesTime&quot;);</span>

 218 
 219         // Step 2: Define and load java.base. This patches all classes loaded
 220         // to date so that they are members of java.base. Once java.base is
 221         // loaded then resources in java.base are available for error messages
 222         // needed from here on.
 223 


 224         ModuleReference base = systemModuleFinder.find(JAVA_BASE).orElse(null);
 225         if (base == null)
 226             throw new InternalError(JAVA_BASE + &quot; not found&quot;);
 227         URI baseUri = base.location().orElse(null);
 228         if (baseUri == null)
 229             throw new InternalError(JAVA_BASE + &quot; does not have a location&quot;);
 230         BootLoader.loadModule(base);
 231         Modules.defineModule(null, base.descriptor(), baseUri);
 232 



 233         // Step 2a: Scan all modules when --validate-modules specified
 234 
 235         if (getAndRemoveProperty(&quot;jdk.module.validation&quot;) != null) {
 236             int errors = ModulePathValidator.scanAllModules(System.out);
 237             if (errors &gt; 0) {
 238                 fail(&quot;Validation of module path failed&quot;);
 239             }
 240         }
 241 
<span class="line-added"> 242         Counters.add(&quot;jdk.module.boot.2.defineBaseTime&quot;);</span>
 243 
 244         // Step 3: If resolution is needed then create the module finder and
 245         // the set of root modules to resolve.
 246 


 247         ModuleFinder savedModuleFinder = null;
 248         ModuleFinder finder;
 249         Set&lt;String&gt; roots;
 250         if (needResolution) {
 251 
 252             // upgraded modules override the modules in the run-time image
 253             if (upgradeModulePath != null)
 254                 systemModuleFinder = ModuleFinder.compose(upgradeModulePath,
 255                                                           systemModuleFinder);
 256 
 257             // The module finder: [--upgrade-module-path] system [--module-path]
 258             if (appModulePath != null) {
 259                 finder = ModuleFinder.compose(systemModuleFinder, appModulePath);
 260             } else {
 261                 finder = systemModuleFinder;
 262             }
 263 
 264             // The root modules to resolve
 265             roots = new HashSet&lt;&gt;();
 266 
</pre>
<hr />
<pre>
 316                     .forEach(mn -&gt; roots.add(mn));
 317             }
 318 
 319             // If `--add-modules ALL-MODULE-PATH` is specified then all observable
 320             // modules on the application module path will be resolved.
 321             if (appModulePath != null &amp;&amp; addAllApplicationModules) {
 322                 ModuleFinder f = finder;  // observable modules
 323                 appModulePath.findAll()
 324                     .stream()
 325                     .map(ModuleReference::descriptor)
 326                     .map(ModuleDescriptor::name)
 327                     .filter(mn -&gt; f.find(mn).isPresent())  // observable
 328                     .forEach(mn -&gt; roots.add(mn));
 329             }
 330         } else {
 331             // no resolution case
 332             finder = systemModuleFinder;
 333             roots = null;
 334         }
 335 
<span class="line-modified"> 336         Counters.add(&quot;jdk.module.boot.3.optionsAndRootsTime&quot;);</span>
 337 
 338         // Step 4: Resolve the root modules, with service binding, to create
 339         // the configuration for the boot layer. If resolution is not needed
 340         // then create the configuration for the boot layer from the
 341         // readability graph created at link time.
 342 


 343         Configuration cf;
 344         if (needResolution) {
<span class="line-modified"> 345             cf = Modules.newBootLayerConfiguration(finder, roots, traceOutput);</span>
 346         } else {
 347             if (archivedModuleGraph != null) {
 348                 cf = archivedModuleGraph.configuration();
 349             } else {
 350                 Map&lt;String, Set&lt;String&gt;&gt; map = systemModules.moduleReads();
 351                 cf = JLMA.newConfiguration(systemModuleFinder, map);
 352             }
 353         }
 354 
 355         // check that modules specified to --patch-module are resolved
 356         if (isPatched) {
 357             patcher.patchedModules()
 358                     .stream()
 359                     .filter(mn -&gt; !cf.findModule(mn).isPresent())
 360                     .forEach(mn -&gt; warnUnknownModule(PATCH_MODULE, mn));
 361         }
 362 
<span class="line-modified"> 363         Counters.add(&quot;jdk.module.boot.4.resolveTime&quot;);</span>

 364 
 365         // Step 5: Map the modules in the configuration to class loaders.
 366         // The static configuration provides the mapping of standard and JDK
 367         // modules to the boot and platform loaders. All other modules (JDK
 368         // tool modules, and both explicit and automatic modules on the
 369         // application module path) are defined to the application class
 370         // loader.
 371 


 372         // mapping of modules to class loaders
<span class="line-modified"> 373         Function&lt;String, ClassLoader&gt; clf;</span>
<span class="line-added"> 374         if (archivedModuleGraph != null) {</span>
<span class="line-added"> 375             clf = archivedModuleGraph.classLoaderFunction();</span>
<span class="line-added"> 376         } else {</span>
<span class="line-added"> 377             clf = ModuleLoaderMap.mappingFunction(cf);</span>
<span class="line-added"> 378         }</span>
 379 
 380         // check that all modules to be mapped to the boot loader will be
 381         // loaded from the runtime image
 382         if (haveModulePath) {
 383             for (ResolvedModule resolvedModule : cf.modules()) {
 384                 ModuleReference mref = resolvedModule.reference();
 385                 String name = mref.descriptor().name();
 386                 ClassLoader cl = clf.apply(name);
 387                 if (cl == null) {
 388                     if (upgradeModulePath != null
 389                             &amp;&amp; upgradeModulePath.find(name).isPresent())
 390                         fail(name + &quot;: cannot be loaded from upgrade module path&quot;);
 391                     if (!systemModuleFinder.find(name).isPresent())
 392                         fail(name + &quot;: cannot be loaded from application module path&quot;);
 393                 }
 394             }
 395         }
 396 
 397         // check for split packages in the modules mapped to the built-in loaders
 398         if (hasSplitPackages || isPatched || haveModulePath) {
 399             checkSplitPackages(cf, clf);
 400         }
 401 
 402         // load/register the modules with the built-in class loaders
 403         loadModules(cf, clf);
<span class="line-modified"> 404         Counters.add(&quot;jdk.module.boot.5.loadModulesTime&quot;);</span>


 405 
 406         // Step 6: Define all modules to the VM
 407 

 408         ModuleLayer bootLayer = ModuleLayer.empty().defineModules(cf, clf);
<span class="line-modified"> 409         Counters.add(&quot;jdk.module.boot.6.layerCreateTime&quot;);</span>

 410 
 411         // Step 7: Miscellaneous
 412 
 413         // check incubating status
 414         if (hasIncubatorModules || haveModulePath) {
 415             checkIncubatingStatus(cf);
 416         }
 417 
 418         // --add-reads, --add-exports/--add-opens, and --illegal-access

 419         addExtraReads(bootLayer);
 420         boolean extraExportsOrOpens = addExtraExportsAndOpens(bootLayer);
 421 
 422         Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen;
 423         Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen;
 424         if (archivedModuleGraph != null) {
 425             concealedPackagesToOpen = archivedModuleGraph.concealedPackagesToOpen();
 426             exportedPackagesToOpen = archivedModuleGraph.exportedPackagesToOpen();
 427         } else {
 428             concealedPackagesToOpen = systemModules.concealedPackagesToOpen();
 429             exportedPackagesToOpen = systemModules.exportedPackagesToOpen();
 430         }
 431         addIllegalAccess(upgradeModulePath,
 432                          concealedPackagesToOpen,
 433                          exportedPackagesToOpen,
 434                          bootLayer,
 435                          extraExportsOrOpens);
<span class="line-modified"> 436         Counters.add(&quot;jdk.module.boot.7.adjustModulesTime&quot;);</span>
 437 
 438         // save module finders for later use
 439         if (savedModuleFinder != null) {
 440             unlimitedFinder = new SafeModuleFinder(savedModuleFinder);
 441             if (savedModuleFinder != finder)
 442                 limitedFinder = new SafeModuleFinder(finder);
 443         }
 444 
 445         // Module graph can be archived at CDS dump time. Only allow the
 446         // unnamed module case for now.
 447         if (canArchive &amp;&amp; (mainModule == null)) {
<span class="line-modified"> 448             ArchivedModuleGraph.archive(</span>
<span class="line-modified"> 449                     new ArchivedModuleGraph(hasSplitPackages,</span>
<span class="line-modified"> 450                                             hasIncubatorModules,</span>
<span class="line-modified"> 451                                             systemModuleFinder,</span>
<span class="line-modified"> 452                                             cf,</span>
<span class="line-modified"> 453                                             clf,</span>
<span class="line-modified"> 454                                             concealedPackagesToOpen,</span>
<span class="line-added"> 455                                             exportedPackagesToOpen));</span>
 456         }
 457 
 458         // total time to initialize
<span class="line-modified"> 459         Counters.publish(&quot;jdk.module.boot.totalTime&quot;);</span>

 460 
 461         return bootLayer;
 462     }
 463 
 464     /**
 465      * Load/register the modules to the built-in class loaders.
 466      */
 467     private static void loadModules(Configuration cf,
 468                                     Function&lt;String, ClassLoader&gt; clf) {
 469         for (ResolvedModule resolvedModule : cf.modules()) {
 470             ModuleReference mref = resolvedModule.reference();
 471             String name = resolvedModule.name();
 472             ClassLoader loader = clf.apply(name);
 473             if (loader == null) {
 474                 // skip java.base as it is already loaded
 475                 if (!name.equals(JAVA_BASE)) {
 476                     BootLoader.loadModule(mref);
 477                 }
 478             } else if (loader instanceof BuiltinClassLoader) {
 479                 ((BuiltinClassLoader) loader).loadModule(mref);
</pre>
<hr />
<pre>
 726                     if (om.isPresent()) {
 727                         other = om.get();
 728                     } else {
 729                         warnUnknownModule(option, name);
 730                         continue;
 731                     }
 732                 }
 733                 if (allUnnamed) {
 734                     if (opens) {
 735                         Modules.addOpensToAllUnnamed(m, pn);
 736                     } else {
 737                         Modules.addExportsToAllUnnamed(m, pn);
 738                     }
 739                 } else {
 740                     if (opens) {
 741                         Modules.addOpens(m, pn, other);
 742                     } else {
 743                         Modules.addExports(m, pn, other);
 744                     }
 745                 }

 746             }
 747         }
 748     }
 749 
 750     /**
 751      * Process the --illegal-access option (and its default) to open packages
 752      * of system modules in the boot layer to code in unnamed modules.
 753      */
 754     private static void addIllegalAccess(ModuleFinder upgradeModulePath,
 755                                          Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen,
 756                                          Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen,
 757                                          ModuleLayer bootLayer,
 758                                          boolean extraExportsOrOpens) {
 759         String value = getAndRemoveProperty(&quot;jdk.module.illegalAccess&quot;);
 760         IllegalAccessLogger.Mode mode = IllegalAccessLogger.Mode.ONESHOT;
 761         if (value != null) {
 762             switch (value) {
 763                 case &quot;deny&quot;:
 764                     return;
 765                 case &quot;permit&quot;:
</pre>
<hr />
<pre>
 770                 case &quot;debug&quot;:
 771                     mode = IllegalAccessLogger.Mode.DEBUG;
 772                     break;
 773                 default:
 774                     fail(&quot;Value specified to --illegal-access not recognized:&quot;
 775                             + &quot; &#39;&quot; + value + &quot;&#39;&quot;);
 776                     return;
 777             }
 778         }
 779         IllegalAccessLogger.Builder builder
 780             = new IllegalAccessLogger.Builder(mode, System.err);
 781 
 782         if (concealedPackagesToOpen.isEmpty() &amp;&amp; exportedPackagesToOpen.isEmpty()) {
 783             // need to generate (exploded build)
 784             IllegalAccessMaps maps = IllegalAccessMaps.generate(limitedFinder());
 785             concealedPackagesToOpen = maps.concealedPackagesToOpen();
 786             exportedPackagesToOpen = maps.exportedPackagesToOpen();
 787         }
 788 
 789         // open specific packages in the system modules
<span class="line-added"> 790         Set&lt;String&gt; emptySet = Set.of();</span>
 791         for (Module m : bootLayer.modules()) {
 792             ModuleDescriptor descriptor = m.getDescriptor();
 793             String name = m.getName();
 794 
 795             // skip open modules
 796             if (descriptor.isOpen()) {
 797                 continue;
 798             }
 799 
 800             // skip modules loaded from the upgrade module path
 801             if (upgradeModulePath != null
 802                 &amp;&amp; upgradeModulePath.find(name).isPresent()) {
 803                 continue;
 804             }
 805 
<span class="line-modified"> 806             Set&lt;String&gt; concealedPackages = concealedPackagesToOpen.getOrDefault(name, emptySet);</span>
<span class="line-modified"> 807             Set&lt;String&gt; exportedPackages = exportedPackagesToOpen.getOrDefault(name, emptySet);</span>
 808 
 809             // refresh the set of concealed and exported packages if needed
 810             if (extraExportsOrOpens) {
 811                 concealedPackages = new HashSet&lt;&gt;(concealedPackages);
 812                 exportedPackages = new HashSet&lt;&gt;(exportedPackages);
 813                 Iterator&lt;String&gt; iterator = concealedPackages.iterator();
 814                 while (iterator.hasNext()) {
 815                     String pn = iterator.next();
 816                     if (m.isExported(pn, BootLoader.getUnnamedModule())) {
 817                         // concealed package is exported to ALL-UNNAMED
 818                         iterator.remove();
 819                         exportedPackages.add(pn);
 820                     }
 821                 }
 822                 iterator = exportedPackages.iterator();
 823                 while (iterator.hasNext()) {
 824                     String pn = iterator.next();
 825                     if (m.isOpen(pn, BootLoader.getUnnamedModule())) {
 826                         // exported package is opened to ALL-UNNAMED
 827                         iterator.remove();
 828                     }
 829                 }
 830             }
 831 
 832             // log reflective access to all types in concealed packages
 833             builder.logAccessToConcealedPackages(m, concealedPackages);
 834 
 835             // log reflective access to non-public members/types in exported packages
 836             builder.logAccessToExportedPackages(m, exportedPackages);
 837 
 838             // open the packages to unnamed modules
 839             JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
<span class="line-modified"> 840             jla.addOpensToAllUnnamed(m, concealedPackages, exportedPackages);</span>

 841         }
 842 
 843         builder.complete();
 844     }
 845 
 846     /**
 847      * Decodes the values of --add-reads, -add-exports, --add-opens or
 848      * --patch-modules options that are encoded in system properties.
 849      *
 850      * @param prefix the system property prefix
 851      * @praam regex the regex for splitting the RHS of the option value
 852      */
 853     private static Map&lt;String, List&lt;String&gt;&gt; decode(String prefix,
 854                                                     String regex,
 855                                                     boolean allowDuplicates) {
 856         int index = 0;
 857         // the system property is removed after decoding
 858         String value = getAndRemoveProperty(prefix + index);
 859         if (value == null)
 860             return Map.of();
</pre>
<hr />
<pre>
 964      * Returns the command-line option name corresponds to the specified
 965      * system property prefix.
 966      */
 967     static String option(String prefix) {
 968         switch (prefix) {
 969             case &quot;jdk.module.addexports.&quot;:
 970                 return ADD_EXPORTS;
 971             case &quot;jdk.module.addopens.&quot;:
 972                 return ADD_OPENS;
 973             case &quot;jdk.module.addreads.&quot;:
 974                 return ADD_READS;
 975             case &quot;jdk.module.patch.&quot;:
 976                 return PATCH_MODULE;
 977             case &quot;jdk.module.addmods.&quot;:
 978                 return ADD_MODULES;
 979             default:
 980                 throw new IllegalArgumentException(prefix);
 981         }
 982     }
 983 



















 984     /**
 985      * Wraps a (potentially not thread safe) ModuleFinder created during startup
 986      * for use after startup.
 987      */
 988     static class SafeModuleFinder implements ModuleFinder {
 989         private final Set&lt;ModuleReference&gt; mrefs;
 990         private volatile Map&lt;String, ModuleReference&gt; nameToModule;
 991 
 992         SafeModuleFinder(ModuleFinder finder) {
 993             this.mrefs = Collections.unmodifiableSet(finder.findAll());
 994         }
 995         @Override
 996         public Optional&lt;ModuleReference&gt; find(String name) {
 997             Objects.requireNonNull(name);
 998             Map&lt;String, ModuleReference&gt; nameToModule = this.nameToModule;
 999             if (nameToModule == null) {
1000                 this.nameToModule = nameToModule = mrefs.stream()
1001                         .collect(Collectors.toMap(m -&gt; m.descriptor().name(),
1002                                                   Function.identity()));
1003             }
1004             return Optional.ofNullable(nameToModule.get(name));
1005         }
1006         @Override
1007         public Set&lt;ModuleReference&gt; findAll() {
1008             return mrefs;
1009         }
1010     }
1011 
1012     /**
1013      * Counters for startup performance analysis.
1014      */
1015     static class Counters {
1016         private static final boolean PUBLISH_COUNTERS;
1017         private static final boolean PRINT_COUNTERS;
1018         private static Map&lt;String, Long&gt; counters;
<span class="line-added">1019         private static long startTime;</span>
<span class="line-added">1020         private static long previousTime;</span>
<span class="line-added">1021 </span>
1022         static {
1023             String s = System.getProperty(&quot;jdk.module.boot.usePerfData&quot;);
1024             if (s == null) {
1025                 PUBLISH_COUNTERS = false;
1026                 PRINT_COUNTERS = false;
1027             } else {
1028                 PUBLISH_COUNTERS = true;
1029                 PRINT_COUNTERS = s.equals(&quot;debug&quot;);
1030                 counters = new LinkedHashMap&lt;&gt;();  // preserve insert order
1031             }
1032         }
1033 
1034         /**
<span class="line-modified">1035          * Start counting time.</span>
<span class="line-added">1036          */</span>
<span class="line-added">1037         static void start() {</span>
<span class="line-added">1038             if (PUBLISH_COUNTERS) {</span>
<span class="line-added">1039                 startTime = previousTime = System.nanoTime();</span>
<span class="line-added">1040             }</span>
<span class="line-added">1041         }</span>
<span class="line-added">1042 </span>
<span class="line-added">1043         /**</span>
<span class="line-added">1044          * Add a counter - storing the time difference between now and the</span>
<span class="line-added">1045          * previous add or the start.</span>
1046          */
<span class="line-modified">1047         static void add(String name) {</span>
<span class="line-modified">1048             if (PUBLISH_COUNTERS) {</span>
<span class="line-modified">1049                 long current = System.nanoTime();</span>
<span class="line-added">1050                 long elapsed = current - previousTime;</span>
<span class="line-added">1051                 previousTime = current;</span>
<span class="line-added">1052                 counters.put(name, elapsed);</span>
1053             }
1054         }
1055 
1056         /**
1057          * Publish the counters to the instrumentation buffer or stdout.
1058          */
<span class="line-modified">1059         static void publish(String totalTimeName) {</span>
<span class="line-modified">1060             if (PUBLISH_COUNTERS) {</span>
<span class="line-added">1061                 long currentTime = System.nanoTime();</span>
1062                 for (Map.Entry&lt;String, Long&gt; e : counters.entrySet()) {
1063                     String name = e.getKey();
1064                     long value = e.getValue();
<span class="line-modified">1065                     PerfCounter.newPerfCounter(name).set(value);</span>

1066                     if (PRINT_COUNTERS)
1067                         System.out.println(name + &quot; = &quot; + value);
1068                 }
<span class="line-added">1069                 long elapsedTotal = currentTime - startTime;</span>
<span class="line-added">1070                 PerfCounter.newPerfCounter(totalTimeName).set(elapsedTotal);</span>
<span class="line-added">1071                 if (PRINT_COUNTERS)</span>
<span class="line-added">1072                     System.out.println(totalTimeName + &quot; = &quot; + elapsedTotal);</span>
1073             }
1074         }
1075     }
1076 }
</pre>
</td>
</tr>
</table>
<center><a href="IllegalAccessMaps.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ModuleInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
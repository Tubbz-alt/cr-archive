<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.ref.Cleaner;
  30 import jdk.internal.vm.annotation.ForceInline;
  31 import sun.nio.ch.DirectBuffer;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
<a name="2" id="anc2"></a>
  36 
  37 /**
  38  * A collection of methods for performing low-level, unsafe operations.
  39  * Although the class and all methods are public, use of this class is
  40  * limited because only trusted code can obtain instances of it.
  41  *
<a name="3" id="anc3"></a><span class="line-modified">  42  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure</span>
  43  * arguments are checked before methods of this class are
  44  * called. While some rudimentary checks are performed on the input,
  45  * the checks are best effort and when performance is an overriding
  46  * priority, as when methods of this class are optimized by the
  47  * runtime compiler, some or all checks (if any) may be elided. Hence,
  48  * the caller must not rely on the checks and corresponding
  49  * exceptions!
  50  *
  51  * @author John R. Rose
  52  * @see #getUnsafe
  53  */
  54 
  55 public final class Unsafe {
  56 
  57     private static native void registerNatives();
  58     static {
  59         registerNatives();
  60     }
  61 
  62     private Unsafe() {}
  63 
  64     private static final Unsafe theUnsafe = new Unsafe();
  65 
  66     /**
  67      * Provides the caller with the capability of performing unsafe
  68      * operations.
  69      *
  70      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  71      * by the caller, since it can be used to read and write data at arbitrary
  72      * memory addresses.  It must never be passed to untrusted code.
  73      *
  74      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  75      * small number of hardware instructions (on typical machines).  Compilers
  76      * are encouraged to optimize these methods accordingly.
  77      *
  78      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  79      *
  80      * &lt;pre&gt; {@code
  81      * class MyTrustedClass {
  82      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  83      *   ...
  84      *   private long myCountAddress = ...;
  85      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  86      * }}&lt;/pre&gt;
  87      *
  88      * (It may assist compilers to make the local variable {@code final}.)
  89      */
  90     public static Unsafe getUnsafe() {
  91         return theUnsafe;
  92     }
  93 
  94     /// peek and poke operations
  95     /// (compilers should optimize these to memory ops)
  96 
  97     // These work on object fields in the Java heap.
  98     // They will not work on elements of packed arrays.
  99 
 100     /**
 101      * Fetches a value from a given Java variable.
 102      * More specifically, fetches a field or array element within the given
 103      * object {@code o} at the given offset, or (if {@code o} is null)
 104      * from the memory address whose numerical value is the given offset.
 105      * &lt;p&gt;
 106      * The results are undefined unless one of the following cases is true:
 107      * &lt;ul&gt;
 108      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 109      * the {@link java.lang.reflect.Field} of some Java field and the object
 110      * referred to by {@code o} is of a class compatible with that
 111      * field&#39;s class.
 112      *
 113      * &lt;li&gt;The offset and object reference {@code o} (either null or
 114      * non-null) were both obtained via {@link #staticFieldOffset}
 115      * and {@link #staticFieldBase} (respectively) from the
 116      * reflective {@link Field} representation of some Java field.
 117      *
 118      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 119      * is an integer of the form {@code B+N*S}, where {@code N} is
 120      * a valid index into the array, and {@code B} and {@code S} are
 121      * the values obtained by {@link #arrayBaseOffset} and {@link
 122      * #arrayIndexScale} (respectively) from the array&#39;s class.  The value
 123      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 124      *
 125      * &lt;/ul&gt;
 126      * &lt;p&gt;
 127      * If one of the above cases is true, the call references a specific Java
 128      * variable (field or array element).  However, the results are undefined
 129      * if that variable is not in fact of the type returned by this method.
 130      * &lt;p&gt;
 131      * This method refers to a variable by means of two parameters, and so
 132      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 133      * for Java variables.  When the object reference is null, this method
 134      * uses its offset as an absolute address.  This is similar in operation
 135      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 136      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 137      * However, because Java variables may have a different layout in memory
 138      * from non-Java variables, programmers should not assume that these
 139      * two addressing modes are ever equivalent.  Also, programmers should
 140      * remember that offsets from the double-register addressing mode cannot
 141      * be portably confused with longs used in the single-register addressing
 142      * mode.
 143      *
 144      * @param o Java heap object in which the variable resides, if any, else
 145      *        null
 146      * @param offset indication of where the variable resides in a Java heap
 147      *        object, if any, else a memory address locating the variable
 148      *        statically
 149      * @return the value fetched from the indicated Java variable
 150      * @throws RuntimeException No defined exceptions are thrown, not even
 151      *         {@link NullPointerException}
 152      */
 153     @HotSpotIntrinsicCandidate
 154     public native int getInt(Object o, long offset);
 155 
 156     /**
 157      * Stores a value into a given Java variable.
 158      * &lt;p&gt;
 159      * The first two parameters are interpreted exactly as with
 160      * {@link #getInt(Object, long)} to refer to a specific
 161      * Java variable (field or array element).  The given value
 162      * is stored into that variable.
 163      * &lt;p&gt;
 164      * The variable must be of the same type as the method
 165      * parameter {@code x}.
 166      *
 167      * @param o Java heap object in which the variable resides, if any, else
 168      *        null
 169      * @param offset indication of where the variable resides in a Java heap
 170      *        object, if any, else a memory address locating the variable
 171      *        statically
 172      * @param x the value to store into the indicated Java variable
 173      * @throws RuntimeException No defined exceptions are thrown, not even
 174      *         {@link NullPointerException}
 175      */
 176     @HotSpotIntrinsicCandidate
 177     public native void putInt(Object o, long offset, int x);
 178 
 179     /**
 180      * Fetches a reference value from a given Java variable.
 181      * @see #getInt(Object, long)
 182      */
 183     @HotSpotIntrinsicCandidate
 184     public native Object getReference(Object o, long offset);
 185 
 186     /**
 187      * Stores a reference value into a given Java variable.
 188      * &lt;p&gt;
 189      * Unless the reference {@code x} being stored is either null
 190      * or matches the field type, the results are undefined.
 191      * If the reference {@code o} is non-null, card marks or
 192      * other store barriers for that object (if the VM requires them)
 193      * are updated.
 194      * @see #putInt(Object, long, int)
 195      */
 196     @HotSpotIntrinsicCandidate
 197     public native void putReference(Object o, long offset, Object x);
 198 
 199     /** @see #getInt(Object, long) */
 200     @HotSpotIntrinsicCandidate
 201     public native boolean getBoolean(Object o, long offset);
 202 
 203     /** @see #putInt(Object, long, int) */
 204     @HotSpotIntrinsicCandidate
 205     public native void    putBoolean(Object o, long offset, boolean x);
 206 
 207     /** @see #getInt(Object, long) */
 208     @HotSpotIntrinsicCandidate
 209     public native byte    getByte(Object o, long offset);
 210 
 211     /** @see #putInt(Object, long, int) */
 212     @HotSpotIntrinsicCandidate
 213     public native void    putByte(Object o, long offset, byte x);
 214 
 215     /** @see #getInt(Object, long) */
 216     @HotSpotIntrinsicCandidate
 217     public native short   getShort(Object o, long offset);
 218 
 219     /** @see #putInt(Object, long, int) */
 220     @HotSpotIntrinsicCandidate
 221     public native void    putShort(Object o, long offset, short x);
 222 
 223     /** @see #getInt(Object, long) */
 224     @HotSpotIntrinsicCandidate
 225     public native char    getChar(Object o, long offset);
 226 
 227     /** @see #putInt(Object, long, int) */
 228     @HotSpotIntrinsicCandidate
 229     public native void    putChar(Object o, long offset, char x);
 230 
 231     /** @see #getInt(Object, long) */
 232     @HotSpotIntrinsicCandidate
 233     public native long    getLong(Object o, long offset);
 234 
 235     /** @see #putInt(Object, long, int) */
 236     @HotSpotIntrinsicCandidate
 237     public native void    putLong(Object o, long offset, long x);
 238 
 239     /** @see #getInt(Object, long) */
 240     @HotSpotIntrinsicCandidate
 241     public native float   getFloat(Object o, long offset);
 242 
 243     /** @see #putInt(Object, long, int) */
 244     @HotSpotIntrinsicCandidate
 245     public native void    putFloat(Object o, long offset, float x);
 246 
 247     /** @see #getInt(Object, long) */
 248     @HotSpotIntrinsicCandidate
 249     public native double  getDouble(Object o, long offset);
 250 
 251     /** @see #putInt(Object, long, int) */
 252     @HotSpotIntrinsicCandidate
 253     public native void    putDouble(Object o, long offset, double x);
 254 
 255     /**
 256      * Fetches a native pointer from a given memory address.  If the address is
 257      * zero, or does not point into a block obtained from {@link
 258      * #allocateMemory}, the results are undefined.
 259      *
 260      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 261      * an unsigned number to a Java long.  The pointer may be indexed by any
 262      * given byte offset, simply by adding that offset (as a simple integer) to
 263      * the long representing the pointer.  The number of bytes actually read
 264      * from the target address may be determined by consulting {@link
 265      * #addressSize}.
 266      *
 267      * @see #allocateMemory
 268      * @see #getInt(Object, long)
 269      */
 270     @ForceInline
 271     public long getAddress(Object o, long offset) {
 272         if (ADDRESS_SIZE == 4) {
 273             return Integer.toUnsignedLong(getInt(o, offset));
 274         } else {
 275             return getLong(o, offset);
 276         }
 277     }
 278 
 279     /**
 280      * Stores a native pointer into a given memory address.  If the address is
 281      * zero, or does not point into a block obtained from {@link
 282      * #allocateMemory}, the results are undefined.
 283      *
 284      * &lt;p&gt;The number of bytes actually written at the target address may be
 285      * determined by consulting {@link #addressSize}.
 286      *
 287      * @see #allocateMemory
 288      * @see #putInt(Object, long, int)
 289      */
 290     @ForceInline
 291     public void putAddress(Object o, long offset, long x) {
 292         if (ADDRESS_SIZE == 4) {
 293             putInt(o, offset, (int)x);
 294         } else {
 295             putLong(o, offset, x);
 296         }
 297     }
 298 
 299     // These read VM internal data.
 300 
 301     /**
 302      * Fetches an uncompressed reference value from a given native variable
 303      * ignoring the VM&#39;s compressed references mode.
 304      *
 305      * @param address a memory address locating the variable
 306      * @return the value fetched from the indicated native variable
 307      */
 308     public native Object getUncompressedObject(long address);
 309 
 310     // These work on values in the C heap.
 311 
 312     /**
 313      * Fetches a value from a given memory address.  If the address is zero, or
 314      * does not point into a block obtained from {@link #allocateMemory}, the
 315      * results are undefined.
 316      *
 317      * @see #allocateMemory
 318      */
 319     @ForceInline
 320     public byte getByte(long address) {
 321         return getByte(null, address);
 322     }
 323 
 324     /**
 325      * Stores a value into a given memory address.  If the address is zero, or
 326      * does not point into a block obtained from {@link #allocateMemory}, the
 327      * results are undefined.
 328      *
 329      * @see #getByte(long)
 330      */
 331     @ForceInline
 332     public void putByte(long address, byte x) {
 333         putByte(null, address, x);
 334     }
 335 
 336     /** @see #getByte(long) */
 337     @ForceInline
 338     public short getShort(long address) {
 339         return getShort(null, address);
 340     }
 341 
 342     /** @see #putByte(long, byte) */
 343     @ForceInline
 344     public void putShort(long address, short x) {
 345         putShort(null, address, x);
 346     }
 347 
 348     /** @see #getByte(long) */
 349     @ForceInline
 350     public char getChar(long address) {
 351         return getChar(null, address);
 352     }
 353 
 354     /** @see #putByte(long, byte) */
 355     @ForceInline
 356     public void putChar(long address, char x) {
 357         putChar(null, address, x);
 358     }
 359 
 360     /** @see #getByte(long) */
 361     @ForceInline
 362     public int getInt(long address) {
 363         return getInt(null, address);
 364     }
 365 
 366     /** @see #putByte(long, byte) */
 367     @ForceInline
 368     public void putInt(long address, int x) {
 369         putInt(null, address, x);
 370     }
 371 
 372     /** @see #getByte(long) */
 373     @ForceInline
 374     public long getLong(long address) {
 375         return getLong(null, address);
 376     }
 377 
 378     /** @see #putByte(long, byte) */
 379     @ForceInline
 380     public void putLong(long address, long x) {
 381         putLong(null, address, x);
 382     }
 383 
 384     /** @see #getByte(long) */
 385     @ForceInline
 386     public float getFloat(long address) {
 387         return getFloat(null, address);
 388     }
 389 
 390     /** @see #putByte(long, byte) */
 391     @ForceInline
 392     public void putFloat(long address, float x) {
 393         putFloat(null, address, x);
 394     }
 395 
 396     /** @see #getByte(long) */
 397     @ForceInline
 398     public double getDouble(long address) {
 399         return getDouble(null, address);
 400     }
 401 
 402     /** @see #putByte(long, byte) */
 403     @ForceInline
 404     public void putDouble(long address, double x) {
 405         putDouble(null, address, x);
 406     }
 407 
 408     /** @see #getAddress(Object, long) */
 409     @ForceInline
 410     public long getAddress(long address) {
 411         return getAddress(null, address);
 412     }
 413 
 414     /** @see #putAddress(Object, long, long) */
 415     @ForceInline
 416     public void putAddress(long address, long x) {
 417         putAddress(null, address, x);
 418     }
 419 
 420 
 421 
 422     /// helper methods for validating various types of objects/values
 423 
 424     /**
 425      * Create an exception reflecting that some of the input was invalid
 426      *
<a name="4" id="anc4"></a><span class="line-modified"> 427      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 428      * sure arguments are checked before the methods are called. While
 429      * some rudimentary checks are performed on the input, the checks
 430      * are best effort and when performance is an overriding priority,
 431      * as when methods of this class are optimized by the runtime
 432      * compiler, some or all checks (if any) may be elided. Hence, the
 433      * caller must not rely on the checks and corresponding
 434      * exceptions!
 435      *
 436      * @return an exception object
 437      */
 438     private RuntimeException invalidInput() {
 439         return new IllegalArgumentException();
 440     }
 441 
 442     /**
 443      * Check if a value is 32-bit clean (32 MSB are all zero)
 444      *
 445      * @param value the 64-bit value to check
 446      *
 447      * @return true if the value is 32-bit clean
 448      */
 449     private boolean is32BitClean(long value) {
 450         return value &gt;&gt;&gt; 32 == 0;
 451     }
 452 
 453     /**
 454      * Check the validity of a size (the equivalent of a size_t)
 455      *
 456      * @throws RuntimeException if the size is invalid
 457      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 458      *         go undetected, which will lead to unpredictable
 459      *         behavior)
 460      */
 461     private void checkSize(long size) {
 462         if (ADDRESS_SIZE == 4) {
 463             // Note: this will also check for negative sizes
 464             if (!is32BitClean(size)) {
 465                 throw invalidInput();
 466             }
 467         } else if (size &lt; 0) {
 468             throw invalidInput();
 469         }
 470     }
 471 
 472     /**
 473      * Check the validity of a native address (the equivalent of void*)
 474      *
 475      * @throws RuntimeException if the address is invalid
 476      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 477      *         go undetected, which will lead to unpredictable
 478      *         behavior)
 479      */
 480     private void checkNativeAddress(long address) {
 481         if (ADDRESS_SIZE == 4) {
 482             // Accept both zero and sign extended pointers. A valid
 483             // pointer will, after the +1 below, either have produced
 484             // the value 0x0 or 0x1. Masking off the low bit allows
 485             // for testing against 0.
 486             if ((((address &gt;&gt; 32) + 1) &amp; ~1) != 0) {
 487                 throw invalidInput();
 488             }
 489         }
 490     }
 491 
 492     /**
 493      * Check the validity of an offset, relative to a base object
 494      *
 495      * @param o the base object
 496      * @param offset the offset to check
 497      *
 498      * @throws RuntimeException if the size is invalid
 499      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 500      *         go undetected, which will lead to unpredictable
 501      *         behavior)
 502      */
 503     private void checkOffset(Object o, long offset) {
 504         if (ADDRESS_SIZE == 4) {
 505             // Note: this will also check for negative offsets
 506             if (!is32BitClean(offset)) {
 507                 throw invalidInput();
 508             }
 509         } else if (offset &lt; 0) {
 510             throw invalidInput();
 511         }
 512     }
 513 
 514     /**
 515      * Check the validity of a double-register pointer
 516      *
 517      * Note: This code deliberately does *not* check for NPE for (at
 518      * least) three reasons:
 519      *
 520      * 1) NPE is not just NULL/0 - there is a range of values all
 521      * resulting in an NPE, which is not trivial to check for
 522      *
 523      * 2) It is the responsibility of the callers of Unsafe methods
 524      * to verify the input, so throwing an exception here is not really
 525      * useful - passing in a NULL pointer is a critical error and the
 526      * must not expect an exception to be thrown anyway.
 527      *
 528      * 3) the actual operations will detect NULL pointers anyway by
 529      * means of traps and signals (like SIGSEGV).
 530      *
 531      * @param o Java heap object, or null
 532      * @param offset indication of where the variable resides in a Java heap
 533      *        object, if any, else a memory address locating the variable
 534      *        statically
 535      *
 536      * @throws RuntimeException if the pointer is invalid
 537      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 538      *         go undetected, which will lead to unpredictable
 539      *         behavior)
 540      */
 541     private void checkPointer(Object o, long offset) {
 542         if (o == null) {
 543             checkNativeAddress(offset);
 544         } else {
 545             checkOffset(o, offset);
 546         }
 547     }
 548 
 549     /**
 550      * Check if a type is a primitive array type
 551      *
 552      * @param c the type to check
 553      *
 554      * @return true if the type is a primitive array type
 555      */
 556     private void checkPrimitiveArray(Class&lt;?&gt; c) {
 557         Class&lt;?&gt; componentType = c.getComponentType();
 558         if (componentType == null || !componentType.isPrimitive()) {
 559             throw invalidInput();
 560         }
 561     }
 562 
 563     /**
 564      * Check that a pointer is a valid primitive array type pointer
 565      *
 566      * Note: pointers off-heap are considered to be primitive arrays
 567      *
 568      * @throws RuntimeException if the pointer is invalid
 569      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 570      *         go undetected, which will lead to unpredictable
 571      *         behavior)
 572      */
 573     private void checkPrimitivePointer(Object o, long offset) {
 574         checkPointer(o, offset);
 575 
 576         if (o != null) {
 577             // If on heap, it must be a primitive array
 578             checkPrimitiveArray(o.getClass());
 579         }
 580     }
 581 
 582 
 583     /// wrappers for malloc, realloc, free:
 584 
<a name="5" id="anc5"></a>










 585     /**
 586      * Allocates a new block of native memory, of the given size in bytes.  The
 587      * contents of the memory are uninitialized; they will generally be
 588      * garbage.  The resulting native pointer will never be zero, and will be
 589      * aligned for all value types.  Dispose of this memory by calling {@link
 590      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 591      *
<a name="6" id="anc6"></a><span class="line-modified"> 592      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 593      * sure arguments are checked before the methods are called. While
 594      * some rudimentary checks are performed on the input, the checks
 595      * are best effort and when performance is an overriding priority,
 596      * as when methods of this class are optimized by the runtime
 597      * compiler, some or all checks (if any) may be elided. Hence, the
 598      * caller must not rely on the checks and corresponding
 599      * exceptions!
 600      *
 601      * @throws RuntimeException if the size is negative or too large
 602      *         for the native size_t type
 603      *
 604      * @throws OutOfMemoryError if the allocation is refused by the system
 605      *
 606      * @see #getByte(long)
 607      * @see #putByte(long, byte)
 608      */
 609     public long allocateMemory(long bytes) {
<a name="7" id="anc7"></a>

 610         allocateMemoryChecks(bytes);
 611 
 612         if (bytes == 0) {
 613             return 0;
 614         }
 615 
 616         long p = allocateMemory0(bytes);
 617         if (p == 0) {
 618             throw new OutOfMemoryError();
 619         }
 620 
 621         return p;
 622     }
 623 
 624     /**
 625      * Validate the arguments to allocateMemory
 626      *
 627      * @throws RuntimeException if the arguments are invalid
 628      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 629      *         go undetected, which will lead to unpredictable
 630      *         behavior)
 631      */
 632     private void allocateMemoryChecks(long bytes) {
 633         checkSize(bytes);
 634     }
 635 
 636     /**
 637      * Resizes a new block of native memory, to the given size in bytes.  The
 638      * contents of the new block past the size of the old block are
 639      * uninitialized; they will generally be garbage.  The resulting native
 640      * pointer will be zero if and only if the requested size is zero.  The
 641      * resulting native pointer will be aligned for all value types.  Dispose
 642      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 643      * #reallocateMemory}.  The address passed to this method may be null, in
 644      * which case an allocation will be performed.
 645      *
<a name="8" id="anc8"></a><span class="line-modified"> 646      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 647      * sure arguments are checked before the methods are called. While
 648      * some rudimentary checks are performed on the input, the checks
 649      * are best effort and when performance is an overriding priority,
 650      * as when methods of this class are optimized by the runtime
 651      * compiler, some or all checks (if any) may be elided. Hence, the
 652      * caller must not rely on the checks and corresponding
 653      * exceptions!
 654      *
 655      * @throws RuntimeException if the size is negative or too large
 656      *         for the native size_t type
 657      *
 658      * @throws OutOfMemoryError if the allocation is refused by the system
 659      *
 660      * @see #allocateMemory
 661      */
 662     public long reallocateMemory(long address, long bytes) {
<a name="9" id="anc9"></a>

 663         reallocateMemoryChecks(address, bytes);
 664 
 665         if (bytes == 0) {
 666             freeMemory(address);
 667             return 0;
 668         }
 669 
 670         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 671         if (p == 0) {
 672             throw new OutOfMemoryError();
 673         }
 674 
 675         return p;
 676     }
 677 
 678     /**
 679      * Validate the arguments to reallocateMemory
 680      *
 681      * @throws RuntimeException if the arguments are invalid
 682      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 683      *         go undetected, which will lead to unpredictable
 684      *         behavior)
 685      */
 686     private void reallocateMemoryChecks(long address, long bytes) {
 687         checkPointer(null, address);
 688         checkSize(bytes);
 689     }
 690 
 691     /**
 692      * Sets all bytes in a given block of memory to a fixed value
 693      * (usually zero).
 694      *
 695      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 696      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 697      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 698      * the offset supplies an absolute base address.
 699      *
 700      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 701      * by the address and length parameters.  If the effective address and
 702      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 703      * If the effective address and length are (resp.) even modulo 4 or 2,
 704      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 705      *
<a name="10" id="anc10"></a><span class="line-modified"> 706      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 707      * sure arguments are checked before the methods are called. While
 708      * some rudimentary checks are performed on the input, the checks
 709      * are best effort and when performance is an overriding priority,
 710      * as when methods of this class are optimized by the runtime
 711      * compiler, some or all checks (if any) may be elided. Hence, the
 712      * caller must not rely on the checks and corresponding
 713      * exceptions!
 714      *
 715      * @throws RuntimeException if any of the arguments is invalid
 716      *
 717      * @since 1.7
 718      */
 719     public void setMemory(Object o, long offset, long bytes, byte value) {
 720         setMemoryChecks(o, offset, bytes, value);
 721 
 722         if (bytes == 0) {
 723             return;
 724         }
 725 
 726         setMemory0(o, offset, bytes, value);
 727     }
 728 
 729     /**
 730      * Sets all bytes in a given block of memory to a fixed value
 731      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 732      * as discussed in {@link #getInt(Object,long)}.
 733      *
 734      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 735      */
 736     public void setMemory(long address, long bytes, byte value) {
 737         setMemory(null, address, bytes, value);
 738     }
 739 
 740     /**
 741      * Validate the arguments to setMemory
 742      *
 743      * @throws RuntimeException if the arguments are invalid
 744      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 745      *         go undetected, which will lead to unpredictable
 746      *         behavior)
 747      */
 748     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 749         checkPrimitivePointer(o, offset);
 750         checkSize(bytes);
 751     }
 752 
 753     /**
 754      * Sets all bytes in a given block of memory to a copy of another
 755      * block.
 756      *
 757      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 758      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 759      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 760      * the offset supplies an absolute base address.
 761      *
 762      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 763      * by the address and length parameters.  If the effective addresses and
 764      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 765      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 766      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 767      *
<a name="11" id="anc11"></a><span class="line-modified"> 768      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 769      * sure arguments are checked before the methods are called. While
 770      * some rudimentary checks are performed on the input, the checks
 771      * are best effort and when performance is an overriding priority,
 772      * as when methods of this class are optimized by the runtime
 773      * compiler, some or all checks (if any) may be elided. Hence, the
 774      * caller must not rely on the checks and corresponding
 775      * exceptions!
 776      *
 777      * @throws RuntimeException if any of the arguments is invalid
 778      *
 779      * @since 1.7
 780      */
 781     public void copyMemory(Object srcBase, long srcOffset,
 782                            Object destBase, long destOffset,
 783                            long bytes) {
 784         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 785 
 786         if (bytes == 0) {
 787             return;
 788         }
 789 
 790         copyMemory0(srcBase, srcOffset, destBase, destOffset, bytes);
 791     }
 792 
 793     /**
 794      * Sets all bytes in a given block of memory to a copy of another
 795      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 796      * as discussed in {@link #getInt(Object,long)}.
 797      *
 798      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 799      */
 800     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 801         copyMemory(null, srcAddress, null, destAddress, bytes);
 802     }
 803 
 804     /**
 805      * Validate the arguments to copyMemory
 806      *
 807      * @throws RuntimeException if any of the arguments is invalid
 808      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 809      *         go undetected, which will lead to unpredictable
 810      *         behavior)
 811      */
 812     private void copyMemoryChecks(Object srcBase, long srcOffset,
 813                                   Object destBase, long destOffset,
 814                                   long bytes) {
 815         checkSize(bytes);
 816         checkPrimitivePointer(srcBase, srcOffset);
 817         checkPrimitivePointer(destBase, destOffset);
 818     }
 819 
 820     /**
 821      * Copies all elements from one block of memory to another block,
 822      * *unconditionally* byte swapping the elements on the fly.
 823      *
 824      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 825      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 826      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 827      * the offset supplies an absolute base address.
 828      *
<a name="12" id="anc12"></a><span class="line-modified"> 829      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 830      * sure arguments are checked before the methods are called. While
 831      * some rudimentary checks are performed on the input, the checks
 832      * are best effort and when performance is an overriding priority,
 833      * as when methods of this class are optimized by the runtime
 834      * compiler, some or all checks (if any) may be elided. Hence, the
 835      * caller must not rely on the checks and corresponding
 836      * exceptions!
 837      *
 838      * @throws RuntimeException if any of the arguments is invalid
 839      *
 840      * @since 9
 841      */
 842     public void copySwapMemory(Object srcBase, long srcOffset,
 843                                Object destBase, long destOffset,
 844                                long bytes, long elemSize) {
 845         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 846 
 847         if (bytes == 0) {
 848             return;
 849         }
 850 
 851         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 852     }
 853 
 854     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 855                                       Object destBase, long destOffset,
 856                                       long bytes, long elemSize) {
 857         checkSize(bytes);
 858 
 859         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 860             throw invalidInput();
 861         }
 862         if (bytes % elemSize != 0) {
 863             throw invalidInput();
 864         }
 865 
 866         checkPrimitivePointer(srcBase, srcOffset);
 867         checkPrimitivePointer(destBase, destOffset);
 868     }
 869 
 870    /**
 871      * Copies all elements from one block of memory to another block, byte swapping the
 872      * elements on the fly.
 873      *
 874      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 875      * discussed in {@link #getInt(Object,long)}.
 876      *
 877      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 878      */
 879     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 880         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 881     }
 882 
 883     /**
 884      * Disposes of a block of native memory, as obtained from {@link
 885      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 886      * this method may be null, in which case no action is taken.
 887      *
<a name="13" id="anc13"></a><span class="line-modified"> 888      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 889      * sure arguments are checked before the methods are called. While
 890      * some rudimentary checks are performed on the input, the checks
 891      * are best effort and when performance is an overriding priority,
 892      * as when methods of this class are optimized by the runtime
 893      * compiler, some or all checks (if any) may be elided. Hence, the
 894      * caller must not rely on the checks and corresponding
 895      * exceptions!
 896      *
 897      * @throws RuntimeException if any of the arguments is invalid
 898      *
 899      * @see #allocateMemory
 900      */
 901     public void freeMemory(long address) {
 902         freeMemoryChecks(address);
 903 
 904         if (address == 0) {
 905             return;
 906         }
 907 
 908         freeMemory0(address);
 909     }
 910 
 911     /**
 912      * Validate the arguments to freeMemory
 913      *
 914      * @throws RuntimeException if the arguments are invalid
 915      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 916      *         go undetected, which will lead to unpredictable
 917      *         behavior)
 918      */
 919     private void freeMemoryChecks(long address) {
 920         checkPointer(null, address);
 921     }
 922 
<a name="14" id="anc14"></a>






























































































 923     /// random queries
 924 
 925     /**
 926      * This constant differs from all results that will ever be returned from
 927      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 928      * or {@link #arrayBaseOffset}.
 929      */
 930     public static final int INVALID_FIELD_OFFSET = -1;
 931 
 932     /**
 933      * Reports the location of a given field in the storage allocation of its
 934      * class.  Do not expect to perform any sort of arithmetic on this offset;
 935      * it is just a cookie which is passed to the unsafe heap memory accessors.
 936      *
 937      * &lt;p&gt;Any given field will always have the same offset and base, and no
 938      * two distinct fields of the same class will ever have the same offset
 939      * and base.
 940      *
 941      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 942      * although the Sun JVM does not use the most significant 32 bits.
 943      * However, JVM implementations which store static fields at absolute
 944      * addresses can use long offsets and null base pointers to express
 945      * the field locations in a form usable by {@link #getInt(Object,long)}.
 946      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 947      * must preserve all bits of static field offsets.
 948      * @see #getInt(Object, long)
 949      */
 950     public long objectFieldOffset(Field f) {
 951         if (f == null) {
 952             throw new NullPointerException();
 953         }
 954 
 955         return objectFieldOffset0(f);
 956     }
 957 
 958     /**
 959      * Reports the location of the field with a given name in the storage
 960      * allocation of its class.
 961      *
 962      * @throws NullPointerException if any parameter is {@code null}.
 963      * @throws InternalError if there is no field named {@code name} declared
 964      *         in class {@code c}, i.e., if {@code c.getDeclaredField(name)}
 965      *         would throw {@code java.lang.NoSuchFieldException}.
 966      *
 967      * @see #objectFieldOffset(Field)
 968      */
 969     public long objectFieldOffset(Class&lt;?&gt; c, String name) {
 970         if (c == null || name == null) {
 971             throw new NullPointerException();
 972         }
 973 
 974         return objectFieldOffset1(c, name);
 975     }
 976 
 977     /**
 978      * Reports the location of a given static field, in conjunction with {@link
 979      * #staticFieldBase}.
 980      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 981      * it is just a cookie which is passed to the unsafe heap memory accessors.
 982      *
 983      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 984      * fields of the same class will ever have the same offset.
 985      *
 986      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 987      * although the Sun JVM does not use the most significant 32 bits.
 988      * It is hard to imagine a JVM technology which needs more than
 989      * a few bits to encode an offset within a non-array object,
 990      * However, for consistency with other methods in this class,
 991      * this method reports its result as a long value.
 992      * @see #getInt(Object, long)
 993      */
 994     public long staticFieldOffset(Field f) {
 995         if (f == null) {
 996             throw new NullPointerException();
 997         }
 998 
 999         return staticFieldOffset0(f);
1000     }
1001 
1002     /**
1003      * Reports the location of a given static field, in conjunction with {@link
1004      * #staticFieldOffset}.
1005      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
1006      * given class can be accessed via methods like {@link #getInt(Object,
1007      * long)}.  This value may be null.  This value may refer to an object
1008      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
1009      * not be used in any way except as argument to the get and put routines in
1010      * this class.
1011      */
1012     public Object staticFieldBase(Field f) {
1013         if (f == null) {
1014             throw new NullPointerException();
1015         }
1016 
1017         return staticFieldBase0(f);
1018     }
1019 
1020     /**
1021      * Detects if the given class may need to be initialized. This is often
1022      * needed in conjunction with obtaining the static field base of a
1023      * class.
1024      * @return false only if a call to {@code ensureClassInitialized} would have no effect
1025      */
1026     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
1027         if (c == null) {
1028             throw new NullPointerException();
1029         }
1030 
1031         return shouldBeInitialized0(c);
1032     }
1033 
1034     /**
1035      * Ensures the given class has been initialized. This is often
1036      * needed in conjunction with obtaining the static field base of a
1037      * class.
1038      */
1039     public void ensureClassInitialized(Class&lt;?&gt; c) {
1040         if (c == null) {
1041             throw new NullPointerException();
1042         }
1043 
1044         ensureClassInitialized0(c);
1045     }
1046 
1047     /**
1048      * Reports the offset of the first element in the storage allocation of a
1049      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
1050      * for the same class, you may use that scale factor, together with this
1051      * base offset, to form new offsets to access elements of arrays of the
1052      * given class.
1053      *
1054      * @see #getInt(Object, long)
1055      * @see #putInt(Object, long, int)
1056      */
1057     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
1058         if (arrayClass == null) {
1059             throw new NullPointerException();
1060         }
1061 
1062         return arrayBaseOffset0(arrayClass);
1063     }
1064 
1065 
1066     /** The value of {@code arrayBaseOffset(boolean[].class)} */
1067     public static final int ARRAY_BOOLEAN_BASE_OFFSET
1068             = theUnsafe.arrayBaseOffset(boolean[].class);
1069 
1070     /** The value of {@code arrayBaseOffset(byte[].class)} */
1071     public static final int ARRAY_BYTE_BASE_OFFSET
1072             = theUnsafe.arrayBaseOffset(byte[].class);
1073 
1074     /** The value of {@code arrayBaseOffset(short[].class)} */
1075     public static final int ARRAY_SHORT_BASE_OFFSET
1076             = theUnsafe.arrayBaseOffset(short[].class);
1077 
1078     /** The value of {@code arrayBaseOffset(char[].class)} */
1079     public static final int ARRAY_CHAR_BASE_OFFSET
1080             = theUnsafe.arrayBaseOffset(char[].class);
1081 
1082     /** The value of {@code arrayBaseOffset(int[].class)} */
1083     public static final int ARRAY_INT_BASE_OFFSET
1084             = theUnsafe.arrayBaseOffset(int[].class);
1085 
1086     /** The value of {@code arrayBaseOffset(long[].class)} */
1087     public static final int ARRAY_LONG_BASE_OFFSET
1088             = theUnsafe.arrayBaseOffset(long[].class);
1089 
1090     /** The value of {@code arrayBaseOffset(float[].class)} */
1091     public static final int ARRAY_FLOAT_BASE_OFFSET
1092             = theUnsafe.arrayBaseOffset(float[].class);
1093 
1094     /** The value of {@code arrayBaseOffset(double[].class)} */
1095     public static final int ARRAY_DOUBLE_BASE_OFFSET
1096             = theUnsafe.arrayBaseOffset(double[].class);
1097 
1098     /** The value of {@code arrayBaseOffset(Object[].class)} */
1099     public static final int ARRAY_OBJECT_BASE_OFFSET
1100             = theUnsafe.arrayBaseOffset(Object[].class);
1101 
1102     /**
1103      * Reports the scale factor for addressing elements in the storage
1104      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
1105      * will generally not work properly with accessors like {@link
1106      * #getByte(Object, long)}, so the scale factor for such classes is reported
1107      * as zero.
1108      *
1109      * @see #arrayBaseOffset
1110      * @see #getInt(Object, long)
1111      * @see #putInt(Object, long, int)
1112      */
1113     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1114         if (arrayClass == null) {
1115             throw new NullPointerException();
1116         }
1117 
1118         return arrayIndexScale0(arrayClass);
1119     }
1120 
1121 
1122     /** The value of {@code arrayIndexScale(boolean[].class)} */
1123     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1124             = theUnsafe.arrayIndexScale(boolean[].class);
1125 
1126     /** The value of {@code arrayIndexScale(byte[].class)} */
1127     public static final int ARRAY_BYTE_INDEX_SCALE
1128             = theUnsafe.arrayIndexScale(byte[].class);
1129 
1130     /** The value of {@code arrayIndexScale(short[].class)} */
1131     public static final int ARRAY_SHORT_INDEX_SCALE
1132             = theUnsafe.arrayIndexScale(short[].class);
1133 
1134     /** The value of {@code arrayIndexScale(char[].class)} */
1135     public static final int ARRAY_CHAR_INDEX_SCALE
1136             = theUnsafe.arrayIndexScale(char[].class);
1137 
1138     /** The value of {@code arrayIndexScale(int[].class)} */
1139     public static final int ARRAY_INT_INDEX_SCALE
1140             = theUnsafe.arrayIndexScale(int[].class);
1141 
1142     /** The value of {@code arrayIndexScale(long[].class)} */
1143     public static final int ARRAY_LONG_INDEX_SCALE
1144             = theUnsafe.arrayIndexScale(long[].class);
1145 
1146     /** The value of {@code arrayIndexScale(float[].class)} */
1147     public static final int ARRAY_FLOAT_INDEX_SCALE
1148             = theUnsafe.arrayIndexScale(float[].class);
1149 
1150     /** The value of {@code arrayIndexScale(double[].class)} */
1151     public static final int ARRAY_DOUBLE_INDEX_SCALE
1152             = theUnsafe.arrayIndexScale(double[].class);
1153 
1154     /** The value of {@code arrayIndexScale(Object[].class)} */
1155     public static final int ARRAY_OBJECT_INDEX_SCALE
1156             = theUnsafe.arrayIndexScale(Object[].class);
1157 
1158     /**
1159      * Reports the size in bytes of a native pointer, as stored via {@link
1160      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1161      * other primitive types (as stored in native memory blocks) is determined
1162      * fully by their information content.
1163      */
1164     public int addressSize() {
1165         return ADDRESS_SIZE;
1166     }
1167 
1168     /** The value of {@code addressSize()} */
<a name="15" id="anc15"></a><span class="line-modified">1169     public static final int ADDRESS_SIZE = theUnsafe.addressSize0();</span>
1170 
1171     /**
1172      * Reports the size in bytes of a native memory page (whatever that is).
1173      * This value will always be a power of two.
1174      */
<a name="16" id="anc16"></a><span class="line-modified">1175     public native int pageSize();</span>
1176 
<a name="17" id="anc17"></a>



















1177 
1178     /// random trusted operations from JNI:
1179 
1180     /**
1181      * Tells the VM to define a class, without security checks.  By default, the
1182      * class loader and protection domain come from the caller&#39;s class.
1183      */
1184     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1185                                 ClassLoader loader,
1186                                 ProtectionDomain protectionDomain) {
1187         if (b == null) {
1188             throw new NullPointerException();
1189         }
1190         if (len &lt; 0) {
1191             throw new ArrayIndexOutOfBoundsException();
1192         }
1193 
1194         return defineClass0(name, b, off, len, loader, protectionDomain);
1195     }
1196 
1197     public native Class&lt;?&gt; defineClass0(String name, byte[] b, int off, int len,
1198                                         ClassLoader loader,
1199                                         ProtectionDomain protectionDomain);
1200 
1201     /**
1202      * Defines a class but does not make it known to the class loader or system dictionary.
1203      * &lt;p&gt;
1204      * For each CP entry, the corresponding CP patch must either be null or have
1205      * the a format that matches its tag:
1206      * &lt;ul&gt;
1207      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
1208      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
1209      * &lt;li&gt;Class: any java.lang.Class object
1210      * &lt;li&gt;String: any object (not just a java.lang.String)
1211      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
1212      * &lt;/ul&gt;
1213      * @param hostClass context for linkage, access control, protection domain, and class loader
1214      * @param data      bytes of a class file
1215      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
1216      */
1217     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
1218         if (hostClass == null || data == null) {
1219             throw new NullPointerException();
1220         }
1221         if (hostClass.isArray() || hostClass.isPrimitive()) {
1222             throw new IllegalArgumentException();
1223         }
1224 
1225         return defineAnonymousClass0(hostClass, data, cpPatches);
1226     }
1227 
1228     /**
1229      * Allocates an instance but does not run any constructor.
1230      * Initializes the class if it has not yet been.
1231      */
1232     @HotSpotIntrinsicCandidate
1233     public native Object allocateInstance(Class&lt;?&gt; cls)
1234         throws InstantiationException;
1235 
1236     /**
1237      * Allocates an array of a given type, but does not do zeroing.
1238      * &lt;p&gt;
1239      * This method should only be used in the very rare cases where a high-performance code
1240      * overwrites the destination array completely, and compilers cannot assist in zeroing elimination.
1241      * In an overwhelming majority of cases, a normal Java allocation should be used instead.
1242      * &lt;p&gt;
1243      * Users of this method are &lt;b&gt;required&lt;/b&gt; to overwrite the initial (garbage) array contents
1244      * before allowing untrusted code, or code in other threads, to observe the reference
1245      * to the newly allocated array. In addition, the publication of the array reference must be
1246      * safe according to the Java Memory Model requirements.
1247      * &lt;p&gt;
1248      * The safest approach to deal with an uninitialized array is to keep the reference to it in local
1249      * variable at least until the initialization is complete, and then publish it &lt;b&gt;once&lt;/b&gt;, either
1250      * by writing it to a &lt;em&gt;volatile&lt;/em&gt; field, or storing it into a &lt;em&gt;final&lt;/em&gt; field in constructor,
1251      * or issuing a {@link #storeFence} before publishing the reference.
1252      * &lt;p&gt;
1253      * @implnote This method can only allocate primitive arrays, to avoid garbage reference
1254      * elements that could break heap integrity.
1255      *
1256      * @param componentType array component type to allocate
1257      * @param length array size to allocate
1258      * @throws IllegalArgumentException if component type is null, or not a primitive class;
1259      *                                  or the length is negative
1260      */
1261     public Object allocateUninitializedArray(Class&lt;?&gt; componentType, int length) {
1262        if (componentType == null) {
1263            throw new IllegalArgumentException(&quot;Component type is null&quot;);
1264        }
1265        if (!componentType.isPrimitive()) {
1266            throw new IllegalArgumentException(&quot;Component type is not primitive&quot;);
1267        }
1268        if (length &lt; 0) {
1269            throw new IllegalArgumentException(&quot;Negative length&quot;);
1270        }
1271        return allocateUninitializedArray0(componentType, length);
1272     }
1273 
1274     @HotSpotIntrinsicCandidate
1275     private Object allocateUninitializedArray0(Class&lt;?&gt; componentType, int length) {
1276        // These fallbacks provide zeroed arrays, but intrinsic is not required to
1277        // return the zeroed arrays.
1278        if (componentType == byte.class)    return new byte[length];
1279        if (componentType == boolean.class) return new boolean[length];
1280        if (componentType == short.class)   return new short[length];
1281        if (componentType == char.class)    return new char[length];
1282        if (componentType == int.class)     return new int[length];
1283        if (componentType == float.class)   return new float[length];
1284        if (componentType == long.class)    return new long[length];
1285        if (componentType == double.class)  return new double[length];
1286        return null;
1287     }
1288 
1289     /** Throws the exception without telling the verifier. */
1290     public native void throwException(Throwable ee);
1291 
1292     /**
1293      * Atomically updates Java variable to {@code x} if it is currently
1294      * holding {@code expected}.
1295      *
1296      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1297      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1298      *
1299      * @return {@code true} if successful
1300      */
1301     @HotSpotIntrinsicCandidate
1302     public final native boolean compareAndSetReference(Object o, long offset,
1303                                                        Object expected,
1304                                                        Object x);
1305 
1306     @HotSpotIntrinsicCandidate
1307     public final native Object compareAndExchangeReference(Object o, long offset,
1308                                                            Object expected,
1309                                                            Object x);
1310 
1311     @HotSpotIntrinsicCandidate
1312     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
1313                                                            Object expected,
1314                                                            Object x) {
1315         return compareAndExchangeReference(o, offset, expected, x);
1316     }
1317 
1318     @HotSpotIntrinsicCandidate
1319     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
1320                                                            Object expected,
1321                                                            Object x) {
1322         return compareAndExchangeReference(o, offset, expected, x);
1323     }
1324 
1325     @HotSpotIntrinsicCandidate
1326     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
1327                                                          Object expected,
1328                                                          Object x) {
1329         return compareAndSetReference(o, offset, expected, x);
1330     }
1331 
1332     @HotSpotIntrinsicCandidate
1333     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1334                                                            Object expected,
1335                                                            Object x) {
1336         return compareAndSetReference(o, offset, expected, x);
1337     }
1338 
1339     @HotSpotIntrinsicCandidate
1340     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1341                                                            Object expected,
1342                                                            Object x) {
1343         return compareAndSetReference(o, offset, expected, x);
1344     }
1345 
1346     @HotSpotIntrinsicCandidate
1347     public final boolean weakCompareAndSetReference(Object o, long offset,
1348                                                     Object expected,
1349                                                     Object x) {
1350         return compareAndSetReference(o, offset, expected, x);
1351     }
1352 
1353     /**
1354      * Atomically updates Java variable to {@code x} if it is currently
1355      * holding {@code expected}.
1356      *
1357      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1358      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1359      *
1360      * @return {@code true} if successful
1361      */
1362     @HotSpotIntrinsicCandidate
1363     public final native boolean compareAndSetInt(Object o, long offset,
1364                                                  int expected,
1365                                                  int x);
1366 
1367     @HotSpotIntrinsicCandidate
1368     public final native int compareAndExchangeInt(Object o, long offset,
1369                                                   int expected,
1370                                                   int x);
1371 
1372     @HotSpotIntrinsicCandidate
1373     public final int compareAndExchangeIntAcquire(Object o, long offset,
1374                                                          int expected,
1375                                                          int x) {
1376         return compareAndExchangeInt(o, offset, expected, x);
1377     }
1378 
1379     @HotSpotIntrinsicCandidate
1380     public final int compareAndExchangeIntRelease(Object o, long offset,
1381                                                          int expected,
1382                                                          int x) {
1383         return compareAndExchangeInt(o, offset, expected, x);
1384     }
1385 
1386     @HotSpotIntrinsicCandidate
1387     public final boolean weakCompareAndSetIntPlain(Object o, long offset,
1388                                                    int expected,
1389                                                    int x) {
1390         return compareAndSetInt(o, offset, expected, x);
1391     }
1392 
1393     @HotSpotIntrinsicCandidate
1394     public final boolean weakCompareAndSetIntAcquire(Object o, long offset,
1395                                                      int expected,
1396                                                      int x) {
1397         return compareAndSetInt(o, offset, expected, x);
1398     }
1399 
1400     @HotSpotIntrinsicCandidate
1401     public final boolean weakCompareAndSetIntRelease(Object o, long offset,
1402                                                      int expected,
1403                                                      int x) {
1404         return compareAndSetInt(o, offset, expected, x);
1405     }
1406 
1407     @HotSpotIntrinsicCandidate
1408     public final boolean weakCompareAndSetInt(Object o, long offset,
1409                                               int expected,
1410                                               int x) {
1411         return compareAndSetInt(o, offset, expected, x);
1412     }
1413 
1414     @HotSpotIntrinsicCandidate
1415     public final byte compareAndExchangeByte(Object o, long offset,
1416                                              byte expected,
1417                                              byte x) {
1418         long wordOffset = offset &amp; ~3;
1419         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<a name="18" id="anc18"></a><span class="line-modified">1420         if (BE) {</span>
1421             shift = 24 - shift;
1422         }
1423         int mask           = 0xFF &lt;&lt; shift;
1424         int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
1425         int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
1426         int fullWord;
1427         do {
1428             fullWord = getIntVolatile(o, wordOffset);
1429             if ((fullWord &amp; mask) != maskedExpected)
1430                 return (byte) ((fullWord &amp; mask) &gt;&gt; shift);
1431         } while (!weakCompareAndSetInt(o, wordOffset,
1432                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1433         return expected;
1434     }
1435 
1436     @HotSpotIntrinsicCandidate
1437     public final boolean compareAndSetByte(Object o, long offset,
1438                                            byte expected,
1439                                            byte x) {
1440         return compareAndExchangeByte(o, offset, expected, x) == expected;
1441     }
1442 
1443     @HotSpotIntrinsicCandidate
1444     public final boolean weakCompareAndSetByte(Object o, long offset,
1445                                                byte expected,
1446                                                byte x) {
1447         return compareAndSetByte(o, offset, expected, x);
1448     }
1449 
1450     @HotSpotIntrinsicCandidate
1451     public final boolean weakCompareAndSetByteAcquire(Object o, long offset,
1452                                                       byte expected,
1453                                                       byte x) {
1454         return weakCompareAndSetByte(o, offset, expected, x);
1455     }
1456 
1457     @HotSpotIntrinsicCandidate
1458     public final boolean weakCompareAndSetByteRelease(Object o, long offset,
1459                                                       byte expected,
1460                                                       byte x) {
1461         return weakCompareAndSetByte(o, offset, expected, x);
1462     }
1463 
1464     @HotSpotIntrinsicCandidate
1465     public final boolean weakCompareAndSetBytePlain(Object o, long offset,
1466                                                     byte expected,
1467                                                     byte x) {
1468         return weakCompareAndSetByte(o, offset, expected, x);
1469     }
1470 
1471     @HotSpotIntrinsicCandidate
1472     public final byte compareAndExchangeByteAcquire(Object o, long offset,
1473                                                     byte expected,
1474                                                     byte x) {
1475         return compareAndExchangeByte(o, offset, expected, x);
1476     }
1477 
1478     @HotSpotIntrinsicCandidate
1479     public final byte compareAndExchangeByteRelease(Object o, long offset,
1480                                                     byte expected,
1481                                                     byte x) {
1482         return compareAndExchangeByte(o, offset, expected, x);
1483     }
1484 
1485     @HotSpotIntrinsicCandidate
1486     public final short compareAndExchangeShort(Object o, long offset,
1487                                                short expected,
1488                                                short x) {
1489         if ((offset &amp; 3) == 3) {
1490             throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
1491         }
1492         long wordOffset = offset &amp; ~3;
1493         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<a name="19" id="anc19"></a><span class="line-modified">1494         if (BE) {</span>
1495             shift = 16 - shift;
1496         }
1497         int mask           = 0xFFFF &lt;&lt; shift;
1498         int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
1499         int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
1500         int fullWord;
1501         do {
1502             fullWord = getIntVolatile(o, wordOffset);
1503             if ((fullWord &amp; mask) != maskedExpected) {
1504                 return (short) ((fullWord &amp; mask) &gt;&gt; shift);
1505             }
1506         } while (!weakCompareAndSetInt(o, wordOffset,
1507                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1508         return expected;
1509     }
1510 
1511     @HotSpotIntrinsicCandidate
1512     public final boolean compareAndSetShort(Object o, long offset,
1513                                             short expected,
1514                                             short x) {
1515         return compareAndExchangeShort(o, offset, expected, x) == expected;
1516     }
1517 
1518     @HotSpotIntrinsicCandidate
1519     public final boolean weakCompareAndSetShort(Object o, long offset,
1520                                                 short expected,
1521                                                 short x) {
1522         return compareAndSetShort(o, offset, expected, x);
1523     }
1524 
1525     @HotSpotIntrinsicCandidate
1526     public final boolean weakCompareAndSetShortAcquire(Object o, long offset,
1527                                                        short expected,
1528                                                        short x) {
1529         return weakCompareAndSetShort(o, offset, expected, x);
1530     }
1531 
1532     @HotSpotIntrinsicCandidate
1533     public final boolean weakCompareAndSetShortRelease(Object o, long offset,
1534                                                        short expected,
1535                                                        short x) {
1536         return weakCompareAndSetShort(o, offset, expected, x);
1537     }
1538 
1539     @HotSpotIntrinsicCandidate
1540     public final boolean weakCompareAndSetShortPlain(Object o, long offset,
1541                                                      short expected,
1542                                                      short x) {
1543         return weakCompareAndSetShort(o, offset, expected, x);
1544     }
1545 
1546 
1547     @HotSpotIntrinsicCandidate
1548     public final short compareAndExchangeShortAcquire(Object o, long offset,
1549                                                      short expected,
1550                                                      short x) {
1551         return compareAndExchangeShort(o, offset, expected, x);
1552     }
1553 
1554     @HotSpotIntrinsicCandidate
1555     public final short compareAndExchangeShortRelease(Object o, long offset,
1556                                                     short expected,
1557                                                     short x) {
1558         return compareAndExchangeShort(o, offset, expected, x);
1559     }
1560 
1561     @ForceInline
1562     private char s2c(short s) {
1563         return (char) s;
1564     }
1565 
1566     @ForceInline
1567     private short c2s(char s) {
1568         return (short) s;
1569     }
1570 
1571     @ForceInline
1572     public final boolean compareAndSetChar(Object o, long offset,
1573                                            char expected,
1574                                            char x) {
1575         return compareAndSetShort(o, offset, c2s(expected), c2s(x));
1576     }
1577 
1578     @ForceInline
1579     public final char compareAndExchangeChar(Object o, long offset,
1580                                              char expected,
1581                                              char x) {
1582         return s2c(compareAndExchangeShort(o, offset, c2s(expected), c2s(x)));
1583     }
1584 
1585     @ForceInline
1586     public final char compareAndExchangeCharAcquire(Object o, long offset,
1587                                             char expected,
1588                                             char x) {
1589         return s2c(compareAndExchangeShortAcquire(o, offset, c2s(expected), c2s(x)));
1590     }
1591 
1592     @ForceInline
1593     public final char compareAndExchangeCharRelease(Object o, long offset,
1594                                             char expected,
1595                                             char x) {
1596         return s2c(compareAndExchangeShortRelease(o, offset, c2s(expected), c2s(x)));
1597     }
1598 
1599     @ForceInline
1600     public final boolean weakCompareAndSetChar(Object o, long offset,
1601                                                char expected,
1602                                                char x) {
1603         return weakCompareAndSetShort(o, offset, c2s(expected), c2s(x));
1604     }
1605 
1606     @ForceInline
1607     public final boolean weakCompareAndSetCharAcquire(Object o, long offset,
1608                                                       char expected,
1609                                                       char x) {
1610         return weakCompareAndSetShortAcquire(o, offset, c2s(expected), c2s(x));
1611     }
1612 
1613     @ForceInline
1614     public final boolean weakCompareAndSetCharRelease(Object o, long offset,
1615                                                       char expected,
1616                                                       char x) {
1617         return weakCompareAndSetShortRelease(o, offset, c2s(expected), c2s(x));
1618     }
1619 
1620     @ForceInline
1621     public final boolean weakCompareAndSetCharPlain(Object o, long offset,
1622                                                     char expected,
1623                                                     char x) {
1624         return weakCompareAndSetShortPlain(o, offset, c2s(expected), c2s(x));
1625     }
1626 
1627     /**
1628      * The JVM converts integral values to boolean values using two
1629      * different conventions, byte testing against zero and truncation
1630      * to least-significant bit.
1631      *
1632      * &lt;p&gt;The JNI documents specify that, at least for returning
1633      * values from native methods, a Java boolean value is converted
1634      * to the value-set 0..1 by first truncating to a byte (0..255 or
1635      * maybe -128..127) and then testing against zero. Thus, Java
1636      * booleans in non-Java data structures are by convention
1637      * represented as 8-bit containers containing either zero (for
1638      * false) or any non-zero value (for true).
1639      *
1640      * &lt;p&gt;Java booleans in the heap are also stored in bytes, but are
1641      * strongly normalized to the value-set 0..1 (i.e., they are
1642      * truncated to the least-significant bit).
1643      *
1644      * &lt;p&gt;The main reason for having different conventions for
1645      * conversion is performance: Truncation to the least-significant
1646      * bit can be usually implemented with fewer (machine)
1647      * instructions than byte testing against zero.
1648      *
1649      * &lt;p&gt;A number of Unsafe methods load boolean values from the heap
1650      * as bytes. Unsafe converts those values according to the JNI
1651      * rules (i.e, using the &quot;testing against zero&quot; convention). The
1652      * method {@code byte2bool} implements that conversion.
1653      *
1654      * @param b the byte to be converted to boolean
1655      * @return the result of the conversion
1656      */
1657     @ForceInline
1658     private boolean byte2bool(byte b) {
1659         return b != 0;
1660     }
1661 
1662     /**
1663      * Convert a boolean value to a byte. The return value is strongly
1664      * normalized to the value-set 0..1 (i.e., the value is truncated
1665      * to the least-significant bit). See {@link #byte2bool(byte)} for
1666      * more details on conversion conventions.
1667      *
1668      * @param b the boolean to be converted to byte (and then normalized)
1669      * @return the result of the conversion
1670      */
1671     @ForceInline
1672     private byte bool2byte(boolean b) {
1673         return b ? (byte)1 : (byte)0;
1674     }
1675 
1676     @ForceInline
1677     public final boolean compareAndSetBoolean(Object o, long offset,
1678                                               boolean expected,
1679                                               boolean x) {
1680         return compareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
1681     }
1682 
1683     @ForceInline
1684     public final boolean compareAndExchangeBoolean(Object o, long offset,
1685                                                    boolean expected,
1686                                                    boolean x) {
1687         return byte2bool(compareAndExchangeByte(o, offset, bool2byte(expected), bool2byte(x)));
1688     }
1689 
1690     @ForceInline
1691     public final boolean compareAndExchangeBooleanAcquire(Object o, long offset,
1692                                                     boolean expected,
1693                                                     boolean x) {
1694         return byte2bool(compareAndExchangeByteAcquire(o, offset, bool2byte(expected), bool2byte(x)));
1695     }
1696 
1697     @ForceInline
1698     public final boolean compareAndExchangeBooleanRelease(Object o, long offset,
1699                                                        boolean expected,
1700                                                        boolean x) {
1701         return byte2bool(compareAndExchangeByteRelease(o, offset, bool2byte(expected), bool2byte(x)));
1702     }
1703 
1704     @ForceInline
1705     public final boolean weakCompareAndSetBoolean(Object o, long offset,
1706                                                   boolean expected,
1707                                                   boolean x) {
1708         return weakCompareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
1709     }
1710 
1711     @ForceInline
1712     public final boolean weakCompareAndSetBooleanAcquire(Object o, long offset,
1713                                                          boolean expected,
1714                                                          boolean x) {
1715         return weakCompareAndSetByteAcquire(o, offset, bool2byte(expected), bool2byte(x));
1716     }
1717 
1718     @ForceInline
1719     public final boolean weakCompareAndSetBooleanRelease(Object o, long offset,
1720                                                          boolean expected,
1721                                                          boolean x) {
1722         return weakCompareAndSetByteRelease(o, offset, bool2byte(expected), bool2byte(x));
1723     }
1724 
1725     @ForceInline
1726     public final boolean weakCompareAndSetBooleanPlain(Object o, long offset,
1727                                                        boolean expected,
1728                                                        boolean x) {
1729         return weakCompareAndSetBytePlain(o, offset, bool2byte(expected), bool2byte(x));
1730     }
1731 
1732     /**
1733      * Atomically updates Java variable to {@code x} if it is currently
1734      * holding {@code expected}.
1735      *
1736      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1737      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1738      *
1739      * @return {@code true} if successful
1740      */
1741     @ForceInline
1742     public final boolean compareAndSetFloat(Object o, long offset,
1743                                             float expected,
1744                                             float x) {
1745         return compareAndSetInt(o, offset,
1746                                  Float.floatToRawIntBits(expected),
1747                                  Float.floatToRawIntBits(x));
1748     }
1749 
1750     @ForceInline
1751     public final float compareAndExchangeFloat(Object o, long offset,
1752                                                float expected,
1753                                                float x) {
1754         int w = compareAndExchangeInt(o, offset,
1755                                       Float.floatToRawIntBits(expected),
1756                                       Float.floatToRawIntBits(x));
1757         return Float.intBitsToFloat(w);
1758     }
1759 
1760     @ForceInline
1761     public final float compareAndExchangeFloatAcquire(Object o, long offset,
1762                                                   float expected,
1763                                                   float x) {
1764         int w = compareAndExchangeIntAcquire(o, offset,
1765                                              Float.floatToRawIntBits(expected),
1766                                              Float.floatToRawIntBits(x));
1767         return Float.intBitsToFloat(w);
1768     }
1769 
1770     @ForceInline
1771     public final float compareAndExchangeFloatRelease(Object o, long offset,
1772                                                   float expected,
1773                                                   float x) {
1774         int w = compareAndExchangeIntRelease(o, offset,
1775                                              Float.floatToRawIntBits(expected),
1776                                              Float.floatToRawIntBits(x));
1777         return Float.intBitsToFloat(w);
1778     }
1779 
1780     @ForceInline
1781     public final boolean weakCompareAndSetFloatPlain(Object o, long offset,
1782                                                      float expected,
1783                                                      float x) {
1784         return weakCompareAndSetIntPlain(o, offset,
1785                                      Float.floatToRawIntBits(expected),
1786                                      Float.floatToRawIntBits(x));
1787     }
1788 
1789     @ForceInline
1790     public final boolean weakCompareAndSetFloatAcquire(Object o, long offset,
1791                                                        float expected,
1792                                                        float x) {
1793         return weakCompareAndSetIntAcquire(o, offset,
1794                                             Float.floatToRawIntBits(expected),
1795                                             Float.floatToRawIntBits(x));
1796     }
1797 
1798     @ForceInline
1799     public final boolean weakCompareAndSetFloatRelease(Object o, long offset,
1800                                                        float expected,
1801                                                        float x) {
1802         return weakCompareAndSetIntRelease(o, offset,
1803                                             Float.floatToRawIntBits(expected),
1804                                             Float.floatToRawIntBits(x));
1805     }
1806 
1807     @ForceInline
1808     public final boolean weakCompareAndSetFloat(Object o, long offset,
1809                                                 float expected,
1810                                                 float x) {
1811         return weakCompareAndSetInt(o, offset,
1812                                              Float.floatToRawIntBits(expected),
1813                                              Float.floatToRawIntBits(x));
1814     }
1815 
1816     /**
1817      * Atomically updates Java variable to {@code x} if it is currently
1818      * holding {@code expected}.
1819      *
1820      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1821      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1822      *
1823      * @return {@code true} if successful
1824      */
1825     @ForceInline
1826     public final boolean compareAndSetDouble(Object o, long offset,
1827                                              double expected,
1828                                              double x) {
1829         return compareAndSetLong(o, offset,
1830                                  Double.doubleToRawLongBits(expected),
1831                                  Double.doubleToRawLongBits(x));
1832     }
1833 
1834     @ForceInline
1835     public final double compareAndExchangeDouble(Object o, long offset,
1836                                                  double expected,
1837                                                  double x) {
1838         long w = compareAndExchangeLong(o, offset,
1839                                         Double.doubleToRawLongBits(expected),
1840                                         Double.doubleToRawLongBits(x));
1841         return Double.longBitsToDouble(w);
1842     }
1843 
1844     @ForceInline
1845     public final double compareAndExchangeDoubleAcquire(Object o, long offset,
1846                                                         double expected,
1847                                                         double x) {
1848         long w = compareAndExchangeLongAcquire(o, offset,
1849                                                Double.doubleToRawLongBits(expected),
1850                                                Double.doubleToRawLongBits(x));
1851         return Double.longBitsToDouble(w);
1852     }
1853 
1854     @ForceInline
1855     public final double compareAndExchangeDoubleRelease(Object o, long offset,
1856                                                         double expected,
1857                                                         double x) {
1858         long w = compareAndExchangeLongRelease(o, offset,
1859                                                Double.doubleToRawLongBits(expected),
1860                                                Double.doubleToRawLongBits(x));
1861         return Double.longBitsToDouble(w);
1862     }
1863 
1864     @ForceInline
1865     public final boolean weakCompareAndSetDoublePlain(Object o, long offset,
1866                                                       double expected,
1867                                                       double x) {
1868         return weakCompareAndSetLongPlain(o, offset,
1869                                      Double.doubleToRawLongBits(expected),
1870                                      Double.doubleToRawLongBits(x));
1871     }
1872 
1873     @ForceInline
1874     public final boolean weakCompareAndSetDoubleAcquire(Object o, long offset,
1875                                                         double expected,
1876                                                         double x) {
1877         return weakCompareAndSetLongAcquire(o, offset,
1878                                              Double.doubleToRawLongBits(expected),
1879                                              Double.doubleToRawLongBits(x));
1880     }
1881 
1882     @ForceInline
1883     public final boolean weakCompareAndSetDoubleRelease(Object o, long offset,
1884                                                         double expected,
1885                                                         double x) {
1886         return weakCompareAndSetLongRelease(o, offset,
1887                                              Double.doubleToRawLongBits(expected),
1888                                              Double.doubleToRawLongBits(x));
1889     }
1890 
1891     @ForceInline
1892     public final boolean weakCompareAndSetDouble(Object o, long offset,
1893                                                  double expected,
1894                                                  double x) {
1895         return weakCompareAndSetLong(o, offset,
1896                                               Double.doubleToRawLongBits(expected),
1897                                               Double.doubleToRawLongBits(x));
1898     }
1899 
1900     /**
1901      * Atomically updates Java variable to {@code x} if it is currently
1902      * holding {@code expected}.
1903      *
1904      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1905      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1906      *
1907      * @return {@code true} if successful
1908      */
1909     @HotSpotIntrinsicCandidate
1910     public final native boolean compareAndSetLong(Object o, long offset,
1911                                                   long expected,
1912                                                   long x);
1913 
1914     @HotSpotIntrinsicCandidate
1915     public final native long compareAndExchangeLong(Object o, long offset,
1916                                                     long expected,
1917                                                     long x);
1918 
1919     @HotSpotIntrinsicCandidate
1920     public final long compareAndExchangeLongAcquire(Object o, long offset,
1921                                                            long expected,
1922                                                            long x) {
1923         return compareAndExchangeLong(o, offset, expected, x);
1924     }
1925 
1926     @HotSpotIntrinsicCandidate
1927     public final long compareAndExchangeLongRelease(Object o, long offset,
1928                                                            long expected,
1929                                                            long x) {
1930         return compareAndExchangeLong(o, offset, expected, x);
1931     }
1932 
1933     @HotSpotIntrinsicCandidate
1934     public final boolean weakCompareAndSetLongPlain(Object o, long offset,
1935                                                     long expected,
1936                                                     long x) {
1937         return compareAndSetLong(o, offset, expected, x);
1938     }
1939 
1940     @HotSpotIntrinsicCandidate
1941     public final boolean weakCompareAndSetLongAcquire(Object o, long offset,
1942                                                       long expected,
1943                                                       long x) {
1944         return compareAndSetLong(o, offset, expected, x);
1945     }
1946 
1947     @HotSpotIntrinsicCandidate
1948     public final boolean weakCompareAndSetLongRelease(Object o, long offset,
1949                                                       long expected,
1950                                                       long x) {
1951         return compareAndSetLong(o, offset, expected, x);
1952     }
1953 
1954     @HotSpotIntrinsicCandidate
1955     public final boolean weakCompareAndSetLong(Object o, long offset,
1956                                                long expected,
1957                                                long x) {
1958         return compareAndSetLong(o, offset, expected, x);
1959     }
1960 
1961     /**
1962      * Fetches a reference value from a given Java variable, with volatile
1963      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
1964      */
1965     @HotSpotIntrinsicCandidate
1966     public native Object getReferenceVolatile(Object o, long offset);
1967 
1968     /**
1969      * Stores a reference value into a given Java variable, with
1970      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
1971      */
1972     @HotSpotIntrinsicCandidate
1973     public native void putReferenceVolatile(Object o, long offset, Object x);
1974 
1975     /** Volatile version of {@link #getInt(Object, long)}  */
1976     @HotSpotIntrinsicCandidate
1977     public native int     getIntVolatile(Object o, long offset);
1978 
1979     /** Volatile version of {@link #putInt(Object, long, int)}  */
1980     @HotSpotIntrinsicCandidate
1981     public native void    putIntVolatile(Object o, long offset, int x);
1982 
1983     /** Volatile version of {@link #getBoolean(Object, long)}  */
1984     @HotSpotIntrinsicCandidate
1985     public native boolean getBooleanVolatile(Object o, long offset);
1986 
1987     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
1988     @HotSpotIntrinsicCandidate
1989     public native void    putBooleanVolatile(Object o, long offset, boolean x);
1990 
1991     /** Volatile version of {@link #getByte(Object, long)}  */
1992     @HotSpotIntrinsicCandidate
1993     public native byte    getByteVolatile(Object o, long offset);
1994 
1995     /** Volatile version of {@link #putByte(Object, long, byte)}  */
1996     @HotSpotIntrinsicCandidate
1997     public native void    putByteVolatile(Object o, long offset, byte x);
1998 
1999     /** Volatile version of {@link #getShort(Object, long)}  */
2000     @HotSpotIntrinsicCandidate
2001     public native short   getShortVolatile(Object o, long offset);
2002 
2003     /** Volatile version of {@link #putShort(Object, long, short)}  */
2004     @HotSpotIntrinsicCandidate
2005     public native void    putShortVolatile(Object o, long offset, short x);
2006 
2007     /** Volatile version of {@link #getChar(Object, long)}  */
2008     @HotSpotIntrinsicCandidate
2009     public native char    getCharVolatile(Object o, long offset);
2010 
2011     /** Volatile version of {@link #putChar(Object, long, char)}  */
2012     @HotSpotIntrinsicCandidate
2013     public native void    putCharVolatile(Object o, long offset, char x);
2014 
2015     /** Volatile version of {@link #getLong(Object, long)}  */
2016     @HotSpotIntrinsicCandidate
2017     public native long    getLongVolatile(Object o, long offset);
2018 
2019     /** Volatile version of {@link #putLong(Object, long, long)}  */
2020     @HotSpotIntrinsicCandidate
2021     public native void    putLongVolatile(Object o, long offset, long x);
2022 
2023     /** Volatile version of {@link #getFloat(Object, long)}  */
2024     @HotSpotIntrinsicCandidate
2025     public native float   getFloatVolatile(Object o, long offset);
2026 
2027     /** Volatile version of {@link #putFloat(Object, long, float)}  */
2028     @HotSpotIntrinsicCandidate
2029     public native void    putFloatVolatile(Object o, long offset, float x);
2030 
2031     /** Volatile version of {@link #getDouble(Object, long)}  */
2032     @HotSpotIntrinsicCandidate
2033     public native double  getDoubleVolatile(Object o, long offset);
2034 
2035     /** Volatile version of {@link #putDouble(Object, long, double)}  */
2036     @HotSpotIntrinsicCandidate
2037     public native void    putDoubleVolatile(Object o, long offset, double x);
2038 
2039 
2040 
2041     /** Acquire version of {@link #getReferenceVolatile(Object, long)} */
2042     @HotSpotIntrinsicCandidate
2043     public final Object getReferenceAcquire(Object o, long offset) {
2044         return getReferenceVolatile(o, offset);
2045     }
2046 
2047     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
2048     @HotSpotIntrinsicCandidate
2049     public final boolean getBooleanAcquire(Object o, long offset) {
2050         return getBooleanVolatile(o, offset);
2051     }
2052 
2053     /** Acquire version of {@link #getByteVolatile(Object, long)} */
2054     @HotSpotIntrinsicCandidate
2055     public final byte getByteAcquire(Object o, long offset) {
2056         return getByteVolatile(o, offset);
2057     }
2058 
2059     /** Acquire version of {@link #getShortVolatile(Object, long)} */
2060     @HotSpotIntrinsicCandidate
2061     public final short getShortAcquire(Object o, long offset) {
2062         return getShortVolatile(o, offset);
2063     }
2064 
2065     /** Acquire version of {@link #getCharVolatile(Object, long)} */
2066     @HotSpotIntrinsicCandidate
2067     public final char getCharAcquire(Object o, long offset) {
2068         return getCharVolatile(o, offset);
2069     }
2070 
2071     /** Acquire version of {@link #getIntVolatile(Object, long)} */
2072     @HotSpotIntrinsicCandidate
2073     public final int getIntAcquire(Object o, long offset) {
2074         return getIntVolatile(o, offset);
2075     }
2076 
2077     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2078     @HotSpotIntrinsicCandidate
2079     public final float getFloatAcquire(Object o, long offset) {
2080         return getFloatVolatile(o, offset);
2081     }
2082 
2083     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2084     @HotSpotIntrinsicCandidate
2085     public final long getLongAcquire(Object o, long offset) {
2086         return getLongVolatile(o, offset);
2087     }
2088 
2089     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2090     @HotSpotIntrinsicCandidate
2091     public final double getDoubleAcquire(Object o, long offset) {
2092         return getDoubleVolatile(o, offset);
2093     }
2094 
2095     /*
2096       * Versions of {@link #putReferenceVolatile(Object, long, Object)}
2097       * that do not guarantee immediate visibility of the store to
2098       * other threads. This method is generally only useful if the
2099       * underlying field is a Java volatile (or if an array cell, one
2100       * that is otherwise only accessed using volatile accesses).
2101       *
2102       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
2103       */
2104 
2105     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2106     @HotSpotIntrinsicCandidate
2107     public final void putReferenceRelease(Object o, long offset, Object x) {
2108         putReferenceVolatile(o, offset, x);
2109     }
2110 
2111     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2112     @HotSpotIntrinsicCandidate
2113     public final void putBooleanRelease(Object o, long offset, boolean x) {
2114         putBooleanVolatile(o, offset, x);
2115     }
2116 
2117     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2118     @HotSpotIntrinsicCandidate
2119     public final void putByteRelease(Object o, long offset, byte x) {
2120         putByteVolatile(o, offset, x);
2121     }
2122 
2123     /** Release version of {@link #putShortVolatile(Object, long, short)} */
2124     @HotSpotIntrinsicCandidate
2125     public final void putShortRelease(Object o, long offset, short x) {
2126         putShortVolatile(o, offset, x);
2127     }
2128 
2129     /** Release version of {@link #putCharVolatile(Object, long, char)} */
2130     @HotSpotIntrinsicCandidate
2131     public final void putCharRelease(Object o, long offset, char x) {
2132         putCharVolatile(o, offset, x);
2133     }
2134 
2135     /** Release version of {@link #putIntVolatile(Object, long, int)} */
2136     @HotSpotIntrinsicCandidate
2137     public final void putIntRelease(Object o, long offset, int x) {
2138         putIntVolatile(o, offset, x);
2139     }
2140 
2141     /** Release version of {@link #putFloatVolatile(Object, long, float)} */
2142     @HotSpotIntrinsicCandidate
2143     public final void putFloatRelease(Object o, long offset, float x) {
2144         putFloatVolatile(o, offset, x);
2145     }
2146 
2147     /** Release version of {@link #putLongVolatile(Object, long, long)} */
2148     @HotSpotIntrinsicCandidate
2149     public final void putLongRelease(Object o, long offset, long x) {
2150         putLongVolatile(o, offset, x);
2151     }
2152 
2153     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
2154     @HotSpotIntrinsicCandidate
2155     public final void putDoubleRelease(Object o, long offset, double x) {
2156         putDoubleVolatile(o, offset, x);
2157     }
2158 
2159     // ------------------------------ Opaque --------------------------------------
2160 
2161     /** Opaque version of {@link #getReferenceVolatile(Object, long)} */
2162     @HotSpotIntrinsicCandidate
2163     public final Object getReferenceOpaque(Object o, long offset) {
2164         return getReferenceVolatile(o, offset);
2165     }
2166 
2167     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
2168     @HotSpotIntrinsicCandidate
2169     public final boolean getBooleanOpaque(Object o, long offset) {
2170         return getBooleanVolatile(o, offset);
2171     }
2172 
2173     /** Opaque version of {@link #getByteVolatile(Object, long)} */
2174     @HotSpotIntrinsicCandidate
2175     public final byte getByteOpaque(Object o, long offset) {
2176         return getByteVolatile(o, offset);
2177     }
2178 
2179     /** Opaque version of {@link #getShortVolatile(Object, long)} */
2180     @HotSpotIntrinsicCandidate
2181     public final short getShortOpaque(Object o, long offset) {
2182         return getShortVolatile(o, offset);
2183     }
2184 
2185     /** Opaque version of {@link #getCharVolatile(Object, long)} */
2186     @HotSpotIntrinsicCandidate
2187     public final char getCharOpaque(Object o, long offset) {
2188         return getCharVolatile(o, offset);
2189     }
2190 
2191     /** Opaque version of {@link #getIntVolatile(Object, long)} */
2192     @HotSpotIntrinsicCandidate
2193     public final int getIntOpaque(Object o, long offset) {
2194         return getIntVolatile(o, offset);
2195     }
2196 
2197     /** Opaque version of {@link #getFloatVolatile(Object, long)} */
2198     @HotSpotIntrinsicCandidate
2199     public final float getFloatOpaque(Object o, long offset) {
2200         return getFloatVolatile(o, offset);
2201     }
2202 
2203     /** Opaque version of {@link #getLongVolatile(Object, long)} */
2204     @HotSpotIntrinsicCandidate
2205     public final long getLongOpaque(Object o, long offset) {
2206         return getLongVolatile(o, offset);
2207     }
2208 
2209     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
2210     @HotSpotIntrinsicCandidate
2211     public final double getDoubleOpaque(Object o, long offset) {
2212         return getDoubleVolatile(o, offset);
2213     }
2214 
2215     /** Opaque version of {@link #putReferenceVolatile(Object, long, Object)} */
2216     @HotSpotIntrinsicCandidate
2217     public final void putReferenceOpaque(Object o, long offset, Object x) {
2218         putReferenceVolatile(o, offset, x);
2219     }
2220 
2221     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
2222     @HotSpotIntrinsicCandidate
2223     public final void putBooleanOpaque(Object o, long offset, boolean x) {
2224         putBooleanVolatile(o, offset, x);
2225     }
2226 
2227     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
2228     @HotSpotIntrinsicCandidate
2229     public final void putByteOpaque(Object o, long offset, byte x) {
2230         putByteVolatile(o, offset, x);
2231     }
2232 
2233     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
2234     @HotSpotIntrinsicCandidate
2235     public final void putShortOpaque(Object o, long offset, short x) {
2236         putShortVolatile(o, offset, x);
2237     }
2238 
2239     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
2240     @HotSpotIntrinsicCandidate
2241     public final void putCharOpaque(Object o, long offset, char x) {
2242         putCharVolatile(o, offset, x);
2243     }
2244 
2245     /** Opaque version of {@link #putIntVolatile(Object, long, int)} */
2246     @HotSpotIntrinsicCandidate
2247     public final void putIntOpaque(Object o, long offset, int x) {
2248         putIntVolatile(o, offset, x);
2249     }
2250 
2251     /** Opaque version of {@link #putFloatVolatile(Object, long, float)} */
2252     @HotSpotIntrinsicCandidate
2253     public final void putFloatOpaque(Object o, long offset, float x) {
2254         putFloatVolatile(o, offset, x);
2255     }
2256 
2257     /** Opaque version of {@link #putLongVolatile(Object, long, long)} */
2258     @HotSpotIntrinsicCandidate
2259     public final void putLongOpaque(Object o, long offset, long x) {
2260         putLongVolatile(o, offset, x);
2261     }
2262 
2263     /** Opaque version of {@link #putDoubleVolatile(Object, long, double)} */
2264     @HotSpotIntrinsicCandidate
2265     public final void putDoubleOpaque(Object o, long offset, double x) {
2266         putDoubleVolatile(o, offset, x);
2267     }
2268 
2269     /**
2270      * Unblocks the given thread blocked on {@code park}, or, if it is
2271      * not blocked, causes the subsequent call to {@code park} not to
2272      * block.  Note: this operation is &quot;unsafe&quot; solely because the
2273      * caller must somehow ensure that the thread has not been
2274      * destroyed. Nothing special is usually required to ensure this
2275      * when called from Java (in which there will ordinarily be a live
2276      * reference to the thread) but this is not nearly-automatically
2277      * so when calling from native code.
2278      *
2279      * @param thread the thread to unpark.
2280      */
2281     @HotSpotIntrinsicCandidate
2282     public native void unpark(Object thread);
2283 
2284     /**
2285      * Blocks current thread, returning when a balancing
2286      * {@code unpark} occurs, or a balancing {@code unpark} has
2287      * already occurred, or the thread is interrupted, or, if not
2288      * absolute and time is not zero, the given time nanoseconds have
2289      * elapsed, or if absolute, the given deadline in milliseconds
2290      * since Epoch has passed, or spuriously (i.e., returning for no
2291      * &quot;reason&quot;). Note: This operation is in the Unsafe class only
2292      * because {@code unpark} is, so it would be strange to place it
2293      * elsewhere.
2294      */
2295     @HotSpotIntrinsicCandidate
2296     public native void park(boolean isAbsolute, long time);
2297 
2298     /**
2299      * Gets the load average in the system run queue assigned
2300      * to the available processors averaged over various periods of time.
2301      * This method retrieves the given {@code nelem} samples and
2302      * assigns to the elements of the given {@code loadavg} array.
2303      * The system imposes a maximum of 3 samples, representing
2304      * averages over the last 1,  5,  and  15 minutes, respectively.
2305      *
2306      * @param loadavg an array of double of size nelems
2307      * @param nelems the number of samples to be retrieved and
2308      *        must be 1 to 3.
2309      *
2310      * @return the number of samples actually retrieved; or -1
2311      *         if the load average is unobtainable.
2312      */
2313     public int getLoadAverage(double[] loadavg, int nelems) {
2314         if (nelems &lt; 0 || nelems &gt; 3 || nelems &gt; loadavg.length) {
2315             throw new ArrayIndexOutOfBoundsException();
2316         }
2317 
2318         return getLoadAverage0(loadavg, nelems);
2319     }
2320 
2321     // The following contain CAS-based Java implementations used on
2322     // platforms not supporting native instructions
2323 
2324     /**
2325      * Atomically adds the given value to the current value of a field
2326      * or array element within the given object {@code o}
2327      * at the given {@code offset}.
2328      *
2329      * @param o object/array to update the field/element in
2330      * @param offset field/element offset
2331      * @param delta the value to add
2332      * @return the previous value
2333      * @since 1.8
2334      */
2335     @HotSpotIntrinsicCandidate
2336     public final int getAndAddInt(Object o, long offset, int delta) {
2337         int v;
2338         do {
2339             v = getIntVolatile(o, offset);
2340         } while (!weakCompareAndSetInt(o, offset, v, v + delta));
2341         return v;
2342     }
2343 
2344     @ForceInline
2345     public final int getAndAddIntRelease(Object o, long offset, int delta) {
2346         int v;
2347         do {
2348             v = getInt(o, offset);
2349         } while (!weakCompareAndSetIntRelease(o, offset, v, v + delta));
2350         return v;
2351     }
2352 
2353     @ForceInline
2354     public final int getAndAddIntAcquire(Object o, long offset, int delta) {
2355         int v;
2356         do {
2357             v = getIntAcquire(o, offset);
2358         } while (!weakCompareAndSetIntAcquire(o, offset, v, v + delta));
2359         return v;
2360     }
2361 
2362     /**
2363      * Atomically adds the given value to the current value of a field
2364      * or array element within the given object {@code o}
2365      * at the given {@code offset}.
2366      *
2367      * @param o object/array to update the field/element in
2368      * @param offset field/element offset
2369      * @param delta the value to add
2370      * @return the previous value
2371      * @since 1.8
2372      */
2373     @HotSpotIntrinsicCandidate
2374     public final long getAndAddLong(Object o, long offset, long delta) {
2375         long v;
2376         do {
2377             v = getLongVolatile(o, offset);
2378         } while (!weakCompareAndSetLong(o, offset, v, v + delta));
2379         return v;
2380     }
2381 
2382     @ForceInline
2383     public final long getAndAddLongRelease(Object o, long offset, long delta) {
2384         long v;
2385         do {
2386             v = getLong(o, offset);
2387         } while (!weakCompareAndSetLongRelease(o, offset, v, v + delta));
2388         return v;
2389     }
2390 
2391     @ForceInline
2392     public final long getAndAddLongAcquire(Object o, long offset, long delta) {
2393         long v;
2394         do {
2395             v = getLongAcquire(o, offset);
2396         } while (!weakCompareAndSetLongAcquire(o, offset, v, v + delta));
2397         return v;
2398     }
2399 
2400     @HotSpotIntrinsicCandidate
2401     public final byte getAndAddByte(Object o, long offset, byte delta) {
2402         byte v;
2403         do {
2404             v = getByteVolatile(o, offset);
2405         } while (!weakCompareAndSetByte(o, offset, v, (byte) (v + delta)));
2406         return v;
2407     }
2408 
2409     @ForceInline
2410     public final byte getAndAddByteRelease(Object o, long offset, byte delta) {
2411         byte v;
2412         do {
2413             v = getByte(o, offset);
2414         } while (!weakCompareAndSetByteRelease(o, offset, v, (byte) (v + delta)));
2415         return v;
2416     }
2417 
2418     @ForceInline
2419     public final byte getAndAddByteAcquire(Object o, long offset, byte delta) {
2420         byte v;
2421         do {
2422             v = getByteAcquire(o, offset);
2423         } while (!weakCompareAndSetByteAcquire(o, offset, v, (byte) (v + delta)));
2424         return v;
2425     }
2426 
2427     @HotSpotIntrinsicCandidate
2428     public final short getAndAddShort(Object o, long offset, short delta) {
2429         short v;
2430         do {
2431             v = getShortVolatile(o, offset);
2432         } while (!weakCompareAndSetShort(o, offset, v, (short) (v + delta)));
2433         return v;
2434     }
2435 
2436     @ForceInline
2437     public final short getAndAddShortRelease(Object o, long offset, short delta) {
2438         short v;
2439         do {
2440             v = getShort(o, offset);
2441         } while (!weakCompareAndSetShortRelease(o, offset, v, (short) (v + delta)));
2442         return v;
2443     }
2444 
2445     @ForceInline
2446     public final short getAndAddShortAcquire(Object o, long offset, short delta) {
2447         short v;
2448         do {
2449             v = getShortAcquire(o, offset);
2450         } while (!weakCompareAndSetShortAcquire(o, offset, v, (short) (v + delta)));
2451         return v;
2452     }
2453 
2454     @ForceInline
2455     public final char getAndAddChar(Object o, long offset, char delta) {
2456         return (char) getAndAddShort(o, offset, (short) delta);
2457     }
2458 
2459     @ForceInline
2460     public final char getAndAddCharRelease(Object o, long offset, char delta) {
2461         return (char) getAndAddShortRelease(o, offset, (short) delta);
2462     }
2463 
2464     @ForceInline
2465     public final char getAndAddCharAcquire(Object o, long offset, char delta) {
2466         return (char) getAndAddShortAcquire(o, offset, (short) delta);
2467     }
2468 
2469     @ForceInline
2470     public final float getAndAddFloat(Object o, long offset, float delta) {
2471         int expectedBits;
2472         float v;
2473         do {
2474             // Load and CAS with the raw bits to avoid issues with NaNs and
2475             // possible bit conversion from signaling NaNs to quiet NaNs that
2476             // may result in the loop not terminating.
2477             expectedBits = getIntVolatile(o, offset);
2478             v = Float.intBitsToFloat(expectedBits);
2479         } while (!weakCompareAndSetInt(o, offset,
2480                                                 expectedBits, Float.floatToRawIntBits(v + delta)));
2481         return v;
2482     }
2483 
2484     @ForceInline
2485     public final float getAndAddFloatRelease(Object o, long offset, float delta) {
2486         int expectedBits;
2487         float v;
2488         do {
2489             // Load and CAS with the raw bits to avoid issues with NaNs and
2490             // possible bit conversion from signaling NaNs to quiet NaNs that
2491             // may result in the loop not terminating.
2492             expectedBits = getInt(o, offset);
2493             v = Float.intBitsToFloat(expectedBits);
2494         } while (!weakCompareAndSetIntRelease(o, offset,
2495                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2496         return v;
2497     }
2498 
2499     @ForceInline
2500     public final float getAndAddFloatAcquire(Object o, long offset, float delta) {
2501         int expectedBits;
2502         float v;
2503         do {
2504             // Load and CAS with the raw bits to avoid issues with NaNs and
2505             // possible bit conversion from signaling NaNs to quiet NaNs that
2506             // may result in the loop not terminating.
2507             expectedBits = getIntAcquire(o, offset);
2508             v = Float.intBitsToFloat(expectedBits);
2509         } while (!weakCompareAndSetIntAcquire(o, offset,
2510                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2511         return v;
2512     }
2513 
2514     @ForceInline
2515     public final double getAndAddDouble(Object o, long offset, double delta) {
2516         long expectedBits;
2517         double v;
2518         do {
2519             // Load and CAS with the raw bits to avoid issues with NaNs and
2520             // possible bit conversion from signaling NaNs to quiet NaNs that
2521             // may result in the loop not terminating.
2522             expectedBits = getLongVolatile(o, offset);
2523             v = Double.longBitsToDouble(expectedBits);
2524         } while (!weakCompareAndSetLong(o, offset,
2525                                                  expectedBits, Double.doubleToRawLongBits(v + delta)));
2526         return v;
2527     }
2528 
2529     @ForceInline
2530     public final double getAndAddDoubleRelease(Object o, long offset, double delta) {
2531         long expectedBits;
2532         double v;
2533         do {
2534             // Load and CAS with the raw bits to avoid issues with NaNs and
2535             // possible bit conversion from signaling NaNs to quiet NaNs that
2536             // may result in the loop not terminating.
2537             expectedBits = getLong(o, offset);
2538             v = Double.longBitsToDouble(expectedBits);
2539         } while (!weakCompareAndSetLongRelease(o, offset,
2540                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
2541         return v;
2542     }
2543 
2544     @ForceInline
2545     public final double getAndAddDoubleAcquire(Object o, long offset, double delta) {
2546         long expectedBits;
2547         double v;
2548         do {
2549             // Load and CAS with the raw bits to avoid issues with NaNs and
2550             // possible bit conversion from signaling NaNs to quiet NaNs that
2551             // may result in the loop not terminating.
2552             expectedBits = getLongAcquire(o, offset);
2553             v = Double.longBitsToDouble(expectedBits);
2554         } while (!weakCompareAndSetLongAcquire(o, offset,
2555                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
2556         return v;
2557     }
2558 
2559     /**
2560      * Atomically exchanges the given value with the current value of
2561      * a field or array element within the given object {@code o}
2562      * at the given {@code offset}.
2563      *
2564      * @param o object/array to update the field/element in
2565      * @param offset field/element offset
2566      * @param newValue new value
2567      * @return the previous value
2568      * @since 1.8
2569      */
2570     @HotSpotIntrinsicCandidate
2571     public final int getAndSetInt(Object o, long offset, int newValue) {
2572         int v;
2573         do {
2574             v = getIntVolatile(o, offset);
2575         } while (!weakCompareAndSetInt(o, offset, v, newValue));
2576         return v;
2577     }
2578 
2579     @ForceInline
2580     public final int getAndSetIntRelease(Object o, long offset, int newValue) {
2581         int v;
2582         do {
2583             v = getInt(o, offset);
2584         } while (!weakCompareAndSetIntRelease(o, offset, v, newValue));
2585         return v;
2586     }
2587 
2588     @ForceInline
2589     public final int getAndSetIntAcquire(Object o, long offset, int newValue) {
2590         int v;
2591         do {
2592             v = getIntAcquire(o, offset);
2593         } while (!weakCompareAndSetIntAcquire(o, offset, v, newValue));
2594         return v;
2595     }
2596 
2597     /**
2598      * Atomically exchanges the given value with the current value of
2599      * a field or array element within the given object {@code o}
2600      * at the given {@code offset}.
2601      *
2602      * @param o object/array to update the field/element in
2603      * @param offset field/element offset
2604      * @param newValue new value
2605      * @return the previous value
2606      * @since 1.8
2607      */
2608     @HotSpotIntrinsicCandidate
2609     public final long getAndSetLong(Object o, long offset, long newValue) {
2610         long v;
2611         do {
2612             v = getLongVolatile(o, offset);
2613         } while (!weakCompareAndSetLong(o, offset, v, newValue));
2614         return v;
2615     }
2616 
2617     @ForceInline
2618     public final long getAndSetLongRelease(Object o, long offset, long newValue) {
2619         long v;
2620         do {
2621             v = getLong(o, offset);
2622         } while (!weakCompareAndSetLongRelease(o, offset, v, newValue));
2623         return v;
2624     }
2625 
2626     @ForceInline
2627     public final long getAndSetLongAcquire(Object o, long offset, long newValue) {
2628         long v;
2629         do {
2630             v = getLongAcquire(o, offset);
2631         } while (!weakCompareAndSetLongAcquire(o, offset, v, newValue));
2632         return v;
2633     }
2634 
2635     /**
2636      * Atomically exchanges the given reference value with the current
2637      * reference value of a field or array element within the given
2638      * object {@code o} at the given {@code offset}.
2639      *
2640      * @param o object/array to update the field/element in
2641      * @param offset field/element offset
2642      * @param newValue new value
2643      * @return the previous value
2644      * @since 1.8
2645      */
2646     @HotSpotIntrinsicCandidate
2647     public final Object getAndSetReference(Object o, long offset, Object newValue) {
2648         Object v;
2649         do {
2650             v = getReferenceVolatile(o, offset);
2651         } while (!weakCompareAndSetReference(o, offset, v, newValue));
2652         return v;
2653     }
2654 
2655     @ForceInline
2656     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
2657         Object v;
2658         do {
2659             v = getReference(o, offset);
2660         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
2661         return v;
2662     }
2663 
2664     @ForceInline
2665     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
2666         Object v;
2667         do {
2668             v = getReferenceAcquire(o, offset);
2669         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
2670         return v;
2671     }
2672 
2673     @HotSpotIntrinsicCandidate
2674     public final byte getAndSetByte(Object o, long offset, byte newValue) {
2675         byte v;
2676         do {
2677             v = getByteVolatile(o, offset);
2678         } while (!weakCompareAndSetByte(o, offset, v, newValue));
2679         return v;
2680     }
2681 
2682     @ForceInline
2683     public final byte getAndSetByteRelease(Object o, long offset, byte newValue) {
2684         byte v;
2685         do {
2686             v = getByte(o, offset);
2687         } while (!weakCompareAndSetByteRelease(o, offset, v, newValue));
2688         return v;
2689     }
2690 
2691     @ForceInline
2692     public final byte getAndSetByteAcquire(Object o, long offset, byte newValue) {
2693         byte v;
2694         do {
2695             v = getByteAcquire(o, offset);
2696         } while (!weakCompareAndSetByteAcquire(o, offset, v, newValue));
2697         return v;
2698     }
2699 
2700     @ForceInline
2701     public final boolean getAndSetBoolean(Object o, long offset, boolean newValue) {
2702         return byte2bool(getAndSetByte(o, offset, bool2byte(newValue)));
2703     }
2704 
2705     @ForceInline
2706     public final boolean getAndSetBooleanRelease(Object o, long offset, boolean newValue) {
2707         return byte2bool(getAndSetByteRelease(o, offset, bool2byte(newValue)));
2708     }
2709 
2710     @ForceInline
2711     public final boolean getAndSetBooleanAcquire(Object o, long offset, boolean newValue) {
2712         return byte2bool(getAndSetByteAcquire(o, offset, bool2byte(newValue)));
2713     }
2714 
2715     @HotSpotIntrinsicCandidate
2716     public final short getAndSetShort(Object o, long offset, short newValue) {
2717         short v;
2718         do {
2719             v = getShortVolatile(o, offset);
2720         } while (!weakCompareAndSetShort(o, offset, v, newValue));
2721         return v;
2722     }
2723 
2724     @ForceInline
2725     public final short getAndSetShortRelease(Object o, long offset, short newValue) {
2726         short v;
2727         do {
2728             v = getShort(o, offset);
2729         } while (!weakCompareAndSetShortRelease(o, offset, v, newValue));
2730         return v;
2731     }
2732 
2733     @ForceInline
2734     public final short getAndSetShortAcquire(Object o, long offset, short newValue) {
2735         short v;
2736         do {
2737             v = getShortAcquire(o, offset);
2738         } while (!weakCompareAndSetShortAcquire(o, offset, v, newValue));
2739         return v;
2740     }
2741 
2742     @ForceInline
2743     public final char getAndSetChar(Object o, long offset, char newValue) {
2744         return s2c(getAndSetShort(o, offset, c2s(newValue)));
2745     }
2746 
2747     @ForceInline
2748     public final char getAndSetCharRelease(Object o, long offset, char newValue) {
2749         return s2c(getAndSetShortRelease(o, offset, c2s(newValue)));
2750     }
2751 
2752     @ForceInline
2753     public final char getAndSetCharAcquire(Object o, long offset, char newValue) {
2754         return s2c(getAndSetShortAcquire(o, offset, c2s(newValue)));
2755     }
2756 
2757     @ForceInline
2758     public final float getAndSetFloat(Object o, long offset, float newValue) {
2759         int v = getAndSetInt(o, offset, Float.floatToRawIntBits(newValue));
2760         return Float.intBitsToFloat(v);
2761     }
2762 
2763     @ForceInline
2764     public final float getAndSetFloatRelease(Object o, long offset, float newValue) {
2765         int v = getAndSetIntRelease(o, offset, Float.floatToRawIntBits(newValue));
2766         return Float.intBitsToFloat(v);
2767     }
2768 
2769     @ForceInline
2770     public final float getAndSetFloatAcquire(Object o, long offset, float newValue) {
2771         int v = getAndSetIntAcquire(o, offset, Float.floatToRawIntBits(newValue));
2772         return Float.intBitsToFloat(v);
2773     }
2774 
2775     @ForceInline
2776     public final double getAndSetDouble(Object o, long offset, double newValue) {
2777         long v = getAndSetLong(o, offset, Double.doubleToRawLongBits(newValue));
2778         return Double.longBitsToDouble(v);
2779     }
2780 
2781     @ForceInline
2782     public final double getAndSetDoubleRelease(Object o, long offset, double newValue) {
2783         long v = getAndSetLongRelease(o, offset, Double.doubleToRawLongBits(newValue));
2784         return Double.longBitsToDouble(v);
2785     }
2786 
2787     @ForceInline
2788     public final double getAndSetDoubleAcquire(Object o, long offset, double newValue) {
2789         long v = getAndSetLongAcquire(o, offset, Double.doubleToRawLongBits(newValue));
2790         return Double.longBitsToDouble(v);
2791     }
2792 
2793 
2794     // The following contain CAS-based Java implementations used on
2795     // platforms not supporting native instructions
2796 
2797     @ForceInline
2798     public final boolean getAndBitwiseOrBoolean(Object o, long offset, boolean mask) {
2799         return byte2bool(getAndBitwiseOrByte(o, offset, bool2byte(mask)));
2800     }
2801 
2802     @ForceInline
2803     public final boolean getAndBitwiseOrBooleanRelease(Object o, long offset, boolean mask) {
2804         return byte2bool(getAndBitwiseOrByteRelease(o, offset, bool2byte(mask)));
2805     }
2806 
2807     @ForceInline
2808     public final boolean getAndBitwiseOrBooleanAcquire(Object o, long offset, boolean mask) {
2809         return byte2bool(getAndBitwiseOrByteAcquire(o, offset, bool2byte(mask)));
2810     }
2811 
2812     @ForceInline
2813     public final boolean getAndBitwiseAndBoolean(Object o, long offset, boolean mask) {
2814         return byte2bool(getAndBitwiseAndByte(o, offset, bool2byte(mask)));
2815     }
2816 
2817     @ForceInline
2818     public final boolean getAndBitwiseAndBooleanRelease(Object o, long offset, boolean mask) {
2819         return byte2bool(getAndBitwiseAndByteRelease(o, offset, bool2byte(mask)));
2820     }
2821 
2822     @ForceInline
2823     public final boolean getAndBitwiseAndBooleanAcquire(Object o, long offset, boolean mask) {
2824         return byte2bool(getAndBitwiseAndByteAcquire(o, offset, bool2byte(mask)));
2825     }
2826 
2827     @ForceInline
2828     public final boolean getAndBitwiseXorBoolean(Object o, long offset, boolean mask) {
2829         return byte2bool(getAndBitwiseXorByte(o, offset, bool2byte(mask)));
2830     }
2831 
2832     @ForceInline
2833     public final boolean getAndBitwiseXorBooleanRelease(Object o, long offset, boolean mask) {
2834         return byte2bool(getAndBitwiseXorByteRelease(o, offset, bool2byte(mask)));
2835     }
2836 
2837     @ForceInline
2838     public final boolean getAndBitwiseXorBooleanAcquire(Object o, long offset, boolean mask) {
2839         return byte2bool(getAndBitwiseXorByteAcquire(o, offset, bool2byte(mask)));
2840     }
2841 
2842 
2843     @ForceInline
2844     public final byte getAndBitwiseOrByte(Object o, long offset, byte mask) {
2845         byte current;
2846         do {
2847             current = getByteVolatile(o, offset);
2848         } while (!weakCompareAndSetByte(o, offset,
2849                                                   current, (byte) (current | mask)));
2850         return current;
2851     }
2852 
2853     @ForceInline
2854     public final byte getAndBitwiseOrByteRelease(Object o, long offset, byte mask) {
2855         byte current;
2856         do {
2857             current = getByte(o, offset);
2858         } while (!weakCompareAndSetByteRelease(o, offset,
2859                                                  current, (byte) (current | mask)));
2860         return current;
2861     }
2862 
2863     @ForceInline
2864     public final byte getAndBitwiseOrByteAcquire(Object o, long offset, byte mask) {
2865         byte current;
2866         do {
2867             // Plain read, the value is a hint, the acquire CAS does the work
2868             current = getByte(o, offset);
2869         } while (!weakCompareAndSetByteAcquire(o, offset,
2870                                                  current, (byte) (current | mask)));
2871         return current;
2872     }
2873 
2874     @ForceInline
2875     public final byte getAndBitwiseAndByte(Object o, long offset, byte mask) {
2876         byte current;
2877         do {
2878             current = getByteVolatile(o, offset);
2879         } while (!weakCompareAndSetByte(o, offset,
2880                                                   current, (byte) (current &amp; mask)));
2881         return current;
2882     }
2883 
2884     @ForceInline
2885     public final byte getAndBitwiseAndByteRelease(Object o, long offset, byte mask) {
2886         byte current;
2887         do {
2888             current = getByte(o, offset);
2889         } while (!weakCompareAndSetByteRelease(o, offset,
2890                                                  current, (byte) (current &amp; mask)));
2891         return current;
2892     }
2893 
2894     @ForceInline
2895     public final byte getAndBitwiseAndByteAcquire(Object o, long offset, byte mask) {
2896         byte current;
2897         do {
2898             // Plain read, the value is a hint, the acquire CAS does the work
2899             current = getByte(o, offset);
2900         } while (!weakCompareAndSetByteAcquire(o, offset,
2901                                                  current, (byte) (current &amp; mask)));
2902         return current;
2903     }
2904 
2905     @ForceInline
2906     public final byte getAndBitwiseXorByte(Object o, long offset, byte mask) {
2907         byte current;
2908         do {
2909             current = getByteVolatile(o, offset);
2910         } while (!weakCompareAndSetByte(o, offset,
2911                                                   current, (byte) (current ^ mask)));
2912         return current;
2913     }
2914 
2915     @ForceInline
2916     public final byte getAndBitwiseXorByteRelease(Object o, long offset, byte mask) {
2917         byte current;
2918         do {
2919             current = getByte(o, offset);
2920         } while (!weakCompareAndSetByteRelease(o, offset,
2921                                                  current, (byte) (current ^ mask)));
2922         return current;
2923     }
2924 
2925     @ForceInline
2926     public final byte getAndBitwiseXorByteAcquire(Object o, long offset, byte mask) {
2927         byte current;
2928         do {
2929             // Plain read, the value is a hint, the acquire CAS does the work
2930             current = getByte(o, offset);
2931         } while (!weakCompareAndSetByteAcquire(o, offset,
2932                                                  current, (byte) (current ^ mask)));
2933         return current;
2934     }
2935 
2936 
2937     @ForceInline
2938     public final char getAndBitwiseOrChar(Object o, long offset, char mask) {
2939         return s2c(getAndBitwiseOrShort(o, offset, c2s(mask)));
2940     }
2941 
2942     @ForceInline
2943     public final char getAndBitwiseOrCharRelease(Object o, long offset, char mask) {
2944         return s2c(getAndBitwiseOrShortRelease(o, offset, c2s(mask)));
2945     }
2946 
2947     @ForceInline
2948     public final char getAndBitwiseOrCharAcquire(Object o, long offset, char mask) {
2949         return s2c(getAndBitwiseOrShortAcquire(o, offset, c2s(mask)));
2950     }
2951 
2952     @ForceInline
2953     public final char getAndBitwiseAndChar(Object o, long offset, char mask) {
2954         return s2c(getAndBitwiseAndShort(o, offset, c2s(mask)));
2955     }
2956 
2957     @ForceInline
2958     public final char getAndBitwiseAndCharRelease(Object o, long offset, char mask) {
2959         return s2c(getAndBitwiseAndShortRelease(o, offset, c2s(mask)));
2960     }
2961 
2962     @ForceInline
2963     public final char getAndBitwiseAndCharAcquire(Object o, long offset, char mask) {
2964         return s2c(getAndBitwiseAndShortAcquire(o, offset, c2s(mask)));
2965     }
2966 
2967     @ForceInline
2968     public final char getAndBitwiseXorChar(Object o, long offset, char mask) {
2969         return s2c(getAndBitwiseXorShort(o, offset, c2s(mask)));
2970     }
2971 
2972     @ForceInline
2973     public final char getAndBitwiseXorCharRelease(Object o, long offset, char mask) {
2974         return s2c(getAndBitwiseXorShortRelease(o, offset, c2s(mask)));
2975     }
2976 
2977     @ForceInline
2978     public final char getAndBitwiseXorCharAcquire(Object o, long offset, char mask) {
2979         return s2c(getAndBitwiseXorShortAcquire(o, offset, c2s(mask)));
2980     }
2981 
2982 
2983     @ForceInline
2984     public final short getAndBitwiseOrShort(Object o, long offset, short mask) {
2985         short current;
2986         do {
2987             current = getShortVolatile(o, offset);
2988         } while (!weakCompareAndSetShort(o, offset,
2989                                                 current, (short) (current | mask)));
2990         return current;
2991     }
2992 
2993     @ForceInline
2994     public final short getAndBitwiseOrShortRelease(Object o, long offset, short mask) {
2995         short current;
2996         do {
2997             current = getShort(o, offset);
2998         } while (!weakCompareAndSetShortRelease(o, offset,
2999                                                current, (short) (current | mask)));
3000         return current;
3001     }
3002 
3003     @ForceInline
3004     public final short getAndBitwiseOrShortAcquire(Object o, long offset, short mask) {
3005         short current;
3006         do {
3007             // Plain read, the value is a hint, the acquire CAS does the work
3008             current = getShort(o, offset);
3009         } while (!weakCompareAndSetShortAcquire(o, offset,
3010                                                current, (short) (current | mask)));
3011         return current;
3012     }
3013 
3014     @ForceInline
3015     public final short getAndBitwiseAndShort(Object o, long offset, short mask) {
3016         short current;
3017         do {
3018             current = getShortVolatile(o, offset);
3019         } while (!weakCompareAndSetShort(o, offset,
3020                                                 current, (short) (current &amp; mask)));
3021         return current;
3022     }
3023 
3024     @ForceInline
3025     public final short getAndBitwiseAndShortRelease(Object o, long offset, short mask) {
3026         short current;
3027         do {
3028             current = getShort(o, offset);
3029         } while (!weakCompareAndSetShortRelease(o, offset,
3030                                                current, (short) (current &amp; mask)));
3031         return current;
3032     }
3033 
3034     @ForceInline
3035     public final short getAndBitwiseAndShortAcquire(Object o, long offset, short mask) {
3036         short current;
3037         do {
3038             // Plain read, the value is a hint, the acquire CAS does the work
3039             current = getShort(o, offset);
3040         } while (!weakCompareAndSetShortAcquire(o, offset,
3041                                                current, (short) (current &amp; mask)));
3042         return current;
3043     }
3044 
3045     @ForceInline
3046     public final short getAndBitwiseXorShort(Object o, long offset, short mask) {
3047         short current;
3048         do {
3049             current = getShortVolatile(o, offset);
3050         } while (!weakCompareAndSetShort(o, offset,
3051                                                 current, (short) (current ^ mask)));
3052         return current;
3053     }
3054 
3055     @ForceInline
3056     public final short getAndBitwiseXorShortRelease(Object o, long offset, short mask) {
3057         short current;
3058         do {
3059             current = getShort(o, offset);
3060         } while (!weakCompareAndSetShortRelease(o, offset,
3061                                                current, (short) (current ^ mask)));
3062         return current;
3063     }
3064 
3065     @ForceInline
3066     public final short getAndBitwiseXorShortAcquire(Object o, long offset, short mask) {
3067         short current;
3068         do {
3069             // Plain read, the value is a hint, the acquire CAS does the work
3070             current = getShort(o, offset);
3071         } while (!weakCompareAndSetShortAcquire(o, offset,
3072                                                current, (short) (current ^ mask)));
3073         return current;
3074     }
3075 
3076 
3077     @ForceInline
3078     public final int getAndBitwiseOrInt(Object o, long offset, int mask) {
3079         int current;
3080         do {
3081             current = getIntVolatile(o, offset);
3082         } while (!weakCompareAndSetInt(o, offset,
3083                                                 current, current | mask));
3084         return current;
3085     }
3086 
3087     @ForceInline
3088     public final int getAndBitwiseOrIntRelease(Object o, long offset, int mask) {
3089         int current;
3090         do {
3091             current = getInt(o, offset);
3092         } while (!weakCompareAndSetIntRelease(o, offset,
3093                                                current, current | mask));
3094         return current;
3095     }
3096 
3097     @ForceInline
3098     public final int getAndBitwiseOrIntAcquire(Object o, long offset, int mask) {
3099         int current;
3100         do {
3101             // Plain read, the value is a hint, the acquire CAS does the work
3102             current = getInt(o, offset);
3103         } while (!weakCompareAndSetIntAcquire(o, offset,
3104                                                current, current | mask));
3105         return current;
3106     }
3107 
3108     /**
3109      * Atomically replaces the current value of a field or array element within
3110      * the given object with the result of bitwise AND between the current value
3111      * and mask.
3112      *
3113      * @param o object/array to update the field/element in
3114      * @param offset field/element offset
3115      * @param mask the mask value
3116      * @return the previous value
3117      * @since 9
3118      */
3119     @ForceInline
3120     public final int getAndBitwiseAndInt(Object o, long offset, int mask) {
3121         int current;
3122         do {
3123             current = getIntVolatile(o, offset);
3124         } while (!weakCompareAndSetInt(o, offset,
3125                                                 current, current &amp; mask));
3126         return current;
3127     }
3128 
3129     @ForceInline
3130     public final int getAndBitwiseAndIntRelease(Object o, long offset, int mask) {
3131         int current;
3132         do {
3133             current = getInt(o, offset);
3134         } while (!weakCompareAndSetIntRelease(o, offset,
3135                                                current, current &amp; mask));
3136         return current;
3137     }
3138 
3139     @ForceInline
3140     public final int getAndBitwiseAndIntAcquire(Object o, long offset, int mask) {
3141         int current;
3142         do {
3143             // Plain read, the value is a hint, the acquire CAS does the work
3144             current = getInt(o, offset);
3145         } while (!weakCompareAndSetIntAcquire(o, offset,
3146                                                current, current &amp; mask));
3147         return current;
3148     }
3149 
3150     @ForceInline
3151     public final int getAndBitwiseXorInt(Object o, long offset, int mask) {
3152         int current;
3153         do {
3154             current = getIntVolatile(o, offset);
3155         } while (!weakCompareAndSetInt(o, offset,
3156                                                 current, current ^ mask));
3157         return current;
3158     }
3159 
3160     @ForceInline
3161     public final int getAndBitwiseXorIntRelease(Object o, long offset, int mask) {
3162         int current;
3163         do {
3164             current = getInt(o, offset);
3165         } while (!weakCompareAndSetIntRelease(o, offset,
3166                                                current, current ^ mask));
3167         return current;
3168     }
3169 
3170     @ForceInline
3171     public final int getAndBitwiseXorIntAcquire(Object o, long offset, int mask) {
3172         int current;
3173         do {
3174             // Plain read, the value is a hint, the acquire CAS does the work
3175             current = getInt(o, offset);
3176         } while (!weakCompareAndSetIntAcquire(o, offset,
3177                                                current, current ^ mask));
3178         return current;
3179     }
3180 
3181 
3182     @ForceInline
3183     public final long getAndBitwiseOrLong(Object o, long offset, long mask) {
3184         long current;
3185         do {
3186             current = getLongVolatile(o, offset);
3187         } while (!weakCompareAndSetLong(o, offset,
3188                                                 current, current | mask));
3189         return current;
3190     }
3191 
3192     @ForceInline
3193     public final long getAndBitwiseOrLongRelease(Object o, long offset, long mask) {
3194         long current;
3195         do {
3196             current = getLong(o, offset);
3197         } while (!weakCompareAndSetLongRelease(o, offset,
3198                                                current, current | mask));
3199         return current;
3200     }
3201 
3202     @ForceInline
3203     public final long getAndBitwiseOrLongAcquire(Object o, long offset, long mask) {
3204         long current;
3205         do {
3206             // Plain read, the value is a hint, the acquire CAS does the work
3207             current = getLong(o, offset);
3208         } while (!weakCompareAndSetLongAcquire(o, offset,
3209                                                current, current | mask));
3210         return current;
3211     }
3212 
3213     @ForceInline
3214     public final long getAndBitwiseAndLong(Object o, long offset, long mask) {
3215         long current;
3216         do {
3217             current = getLongVolatile(o, offset);
3218         } while (!weakCompareAndSetLong(o, offset,
3219                                                 current, current &amp; mask));
3220         return current;
3221     }
3222 
3223     @ForceInline
3224     public final long getAndBitwiseAndLongRelease(Object o, long offset, long mask) {
3225         long current;
3226         do {
3227             current = getLong(o, offset);
3228         } while (!weakCompareAndSetLongRelease(o, offset,
3229                                                current, current &amp; mask));
3230         return current;
3231     }
3232 
3233     @ForceInline
3234     public final long getAndBitwiseAndLongAcquire(Object o, long offset, long mask) {
3235         long current;
3236         do {
3237             // Plain read, the value is a hint, the acquire CAS does the work
3238             current = getLong(o, offset);
3239         } while (!weakCompareAndSetLongAcquire(o, offset,
3240                                                current, current &amp; mask));
3241         return current;
3242     }
3243 
3244     @ForceInline
3245     public final long getAndBitwiseXorLong(Object o, long offset, long mask) {
3246         long current;
3247         do {
3248             current = getLongVolatile(o, offset);
3249         } while (!weakCompareAndSetLong(o, offset,
3250                                                 current, current ^ mask));
3251         return current;
3252     }
3253 
3254     @ForceInline
3255     public final long getAndBitwiseXorLongRelease(Object o, long offset, long mask) {
3256         long current;
3257         do {
3258             current = getLong(o, offset);
3259         } while (!weakCompareAndSetLongRelease(o, offset,
3260                                                current, current ^ mask));
3261         return current;
3262     }
3263 
3264     @ForceInline
3265     public final long getAndBitwiseXorLongAcquire(Object o, long offset, long mask) {
3266         long current;
3267         do {
3268             // Plain read, the value is a hint, the acquire CAS does the work
3269             current = getLong(o, offset);
3270         } while (!weakCompareAndSetLongAcquire(o, offset,
3271                                                current, current ^ mask));
3272         return current;
3273     }
3274 
3275 
3276 
3277     /**
3278      * Ensures that loads before the fence will not be reordered with loads and
3279      * stores after the fence; a &quot;LoadLoad plus LoadStore barrier&quot;.
3280      *
3281      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
3282      * (an &quot;acquire fence&quot;).
3283      *
3284      * A pure LoadLoad fence is not provided, since the addition of LoadStore
3285      * is almost always desired, and most current hardware instructions that
3286      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
3287      * @since 1.8
3288      */
3289     @HotSpotIntrinsicCandidate
3290     public native void loadFence();
3291 
3292     /**
3293      * Ensures that loads and stores before the fence will not be reordered with
3294      * stores after the fence; a &quot;StoreStore plus LoadStore barrier&quot;.
3295      *
3296      * Corresponds to C11 atomic_thread_fence(memory_order_release)
3297      * (a &quot;release fence&quot;).
3298      *
3299      * A pure StoreStore fence is not provided, since the addition of LoadStore
3300      * is almost always desired, and most current hardware instructions that
3301      * provide a StoreStore barrier also provide a LoadStore barrier for free.
3302      * @since 1.8
3303      */
3304     @HotSpotIntrinsicCandidate
3305     public native void storeFence();
3306 
3307     /**
3308      * Ensures that loads and stores before the fence will not be reordered
3309      * with loads and stores after the fence.  Implies the effects of both
3310      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
3311      * barrier.
3312      *
3313      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
3314      * @since 1.8
3315      */
3316     @HotSpotIntrinsicCandidate
3317     public native void fullFence();
3318 
3319     /**
3320      * Ensures that loads before the fence will not be reordered with
3321      * loads after the fence.
3322      */
3323     public final void loadLoadFence() {
3324         loadFence();
3325     }
3326 
3327     /**
3328      * Ensures that stores before the fence will not be reordered with
3329      * stores after the fence.
3330      */
3331     public final void storeStoreFence() {
3332         storeFence();
3333     }
3334 
3335 
3336     /**
3337      * Throws IllegalAccessError; for use by the VM for access control
3338      * error support.
3339      * @since 1.8
3340      */
3341     private static void throwIllegalAccessError() {
3342         throw new IllegalAccessError();
3343     }
3344 
3345     /**
3346      * Throws NoSuchMethodError; for use by the VM for redefinition support.
3347      * @since 13
3348      */
3349     private static void throwNoSuchMethodError() {
3350         throw new NoSuchMethodError();
3351     }
3352 
3353     /**
3354      * @return Returns true if the native byte ordering of this
3355      * platform is big-endian, false if it is little-endian.
3356      */
<a name="20" id="anc20"></a><span class="line-modified">3357     public final boolean isBigEndian() { return BE; }</span>
3358 
3359     /**
3360      * @return Returns true if this platform is capable of performing
3361      * accesses at addresses which are not aligned for the type of the
3362      * primitive type being accessed, false otherwise.
3363      */
<a name="21" id="anc21"></a><span class="line-modified">3364     public final boolean unalignedAccess() { return unalignedAccess; }</span>
3365 
3366     /**
3367      * Fetches a value at some byte offset into a given Java object.
3368      * More specifically, fetches a value within the given object
3369      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
3370      * null) from the memory address whose numerical value is the
3371      * given offset.  &lt;p&gt;
3372      *
3373      * The specification of this method is the same as {@link
3374      * #getLong(Object, long)} except that the offset does not need to
3375      * have been obtained from {@link #objectFieldOffset} on the
3376      * {@link java.lang.reflect.Field} of some Java field.  The value
3377      * in memory is raw data, and need not correspond to any Java
3378      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
3379      * must be entirely within the allocated object.  The endianness
3380      * of the value in memory is the endianness of the native platform.
3381      *
3382      * &lt;p&gt; The read will be atomic with respect to the largest power
3383      * of two that divides the GCD of the offset and the storage size.
3384      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
3385      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3386      * respectively.  There are no other guarantees of atomicity.
3387      * &lt;p&gt;
3388      * 8-byte atomicity is only guaranteed on platforms on which
3389      * support atomic accesses to longs.
3390      *
3391      * @param o Java heap object in which the value resides, if any, else
3392      *        null
3393      * @param offset The offset in bytes from the start of the object
3394      * @return the value fetched from the indicated object
3395      * @throws RuntimeException No defined exceptions are thrown, not even
3396      *         {@link NullPointerException}
3397      * @since 9
3398      */
3399     @HotSpotIntrinsicCandidate
3400     public final long getLongUnaligned(Object o, long offset) {
3401         if ((offset &amp; 7) == 0) {
3402             return getLong(o, offset);
3403         } else if ((offset &amp; 3) == 0) {
3404             return makeLong(getInt(o, offset),
3405                             getInt(o, offset + 4));
3406         } else if ((offset &amp; 1) == 0) {
3407             return makeLong(getShort(o, offset),
3408                             getShort(o, offset + 2),
3409                             getShort(o, offset + 4),
3410                             getShort(o, offset + 6));
3411         } else {
3412             return makeLong(getByte(o, offset),
3413                             getByte(o, offset + 1),
3414                             getByte(o, offset + 2),
3415                             getByte(o, offset + 3),
3416                             getByte(o, offset + 4),
3417                             getByte(o, offset + 5),
3418                             getByte(o, offset + 6),
3419                             getByte(o, offset + 7));
3420         }
3421     }
3422     /**
3423      * As {@link #getLongUnaligned(Object, long)} but with an
3424      * additional argument which specifies the endianness of the value
3425      * as stored in memory.
3426      *
3427      * @param o Java heap object in which the variable resides
3428      * @param offset The offset in bytes from the start of the object
3429      * @param bigEndian The endianness of the value
3430      * @return the value fetched from the indicated object
3431      * @since 9
3432      */
3433     public final long getLongUnaligned(Object o, long offset, boolean bigEndian) {
3434         return convEndian(bigEndian, getLongUnaligned(o, offset));
3435     }
3436 
3437     /** @see #getLongUnaligned(Object, long) */
3438     @HotSpotIntrinsicCandidate
3439     public final int getIntUnaligned(Object o, long offset) {
3440         if ((offset &amp; 3) == 0) {
3441             return getInt(o, offset);
3442         } else if ((offset &amp; 1) == 0) {
3443             return makeInt(getShort(o, offset),
3444                            getShort(o, offset + 2));
3445         } else {
3446             return makeInt(getByte(o, offset),
3447                            getByte(o, offset + 1),
3448                            getByte(o, offset + 2),
3449                            getByte(o, offset + 3));
3450         }
3451     }
3452     /** @see #getLongUnaligned(Object, long, boolean) */
3453     public final int getIntUnaligned(Object o, long offset, boolean bigEndian) {
3454         return convEndian(bigEndian, getIntUnaligned(o, offset));
3455     }
3456 
3457     /** @see #getLongUnaligned(Object, long) */
3458     @HotSpotIntrinsicCandidate
3459     public final short getShortUnaligned(Object o, long offset) {
3460         if ((offset &amp; 1) == 0) {
3461             return getShort(o, offset);
3462         } else {
3463             return makeShort(getByte(o, offset),
3464                              getByte(o, offset + 1));
3465         }
3466     }
3467     /** @see #getLongUnaligned(Object, long, boolean) */
3468     public final short getShortUnaligned(Object o, long offset, boolean bigEndian) {
3469         return convEndian(bigEndian, getShortUnaligned(o, offset));
3470     }
3471 
3472     /** @see #getLongUnaligned(Object, long) */
3473     @HotSpotIntrinsicCandidate
3474     public final char getCharUnaligned(Object o, long offset) {
3475         if ((offset &amp; 1) == 0) {
3476             return getChar(o, offset);
3477         } else {
3478             return (char)makeShort(getByte(o, offset),
3479                                    getByte(o, offset + 1));
3480         }
3481     }
3482 
3483     /** @see #getLongUnaligned(Object, long, boolean) */
3484     public final char getCharUnaligned(Object o, long offset, boolean bigEndian) {
3485         return convEndian(bigEndian, getCharUnaligned(o, offset));
3486     }
3487 
3488     /**
3489      * Stores a value at some byte offset into a given Java object.
3490      * &lt;p&gt;
3491      * The specification of this method is the same as {@link
3492      * #getLong(Object, long)} except that the offset does not need to
3493      * have been obtained from {@link #objectFieldOffset} on the
3494      * {@link java.lang.reflect.Field} of some Java field.  The value
3495      * in memory is raw data, and need not correspond to any Java
3496      * variable.  The endianness of the value in memory is the
3497      * endianness of the native platform.
3498      * &lt;p&gt;
3499      * The write will be atomic with respect to the largest power of
3500      * two that divides the GCD of the offset and the storage size.
3501      * For example, putLongUnaligned will make atomic writes of 2-, 4-,
3502      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3503      * respectively.  There are no other guarantees of atomicity.
3504      * &lt;p&gt;
3505      * 8-byte atomicity is only guaranteed on platforms on which
3506      * support atomic accesses to longs.
3507      *
3508      * @param o Java heap object in which the value resides, if any, else
3509      *        null
3510      * @param offset The offset in bytes from the start of the object
3511      * @param x the value to store
3512      * @throws RuntimeException No defined exceptions are thrown, not even
3513      *         {@link NullPointerException}
3514      * @since 9
3515      */
3516     @HotSpotIntrinsicCandidate
3517     public final void putLongUnaligned(Object o, long offset, long x) {
3518         if ((offset &amp; 7) == 0) {
3519             putLong(o, offset, x);
3520         } else if ((offset &amp; 3) == 0) {
3521             putLongParts(o, offset,
3522                          (int)(x &gt;&gt; 0),
3523                          (int)(x &gt;&gt;&gt; 32));
3524         } else if ((offset &amp; 1) == 0) {
3525             putLongParts(o, offset,
3526                          (short)(x &gt;&gt;&gt; 0),
3527                          (short)(x &gt;&gt;&gt; 16),
3528                          (short)(x &gt;&gt;&gt; 32),
3529                          (short)(x &gt;&gt;&gt; 48));
3530         } else {
3531             putLongParts(o, offset,
3532                          (byte)(x &gt;&gt;&gt; 0),
3533                          (byte)(x &gt;&gt;&gt; 8),
3534                          (byte)(x &gt;&gt;&gt; 16),
3535                          (byte)(x &gt;&gt;&gt; 24),
3536                          (byte)(x &gt;&gt;&gt; 32),
3537                          (byte)(x &gt;&gt;&gt; 40),
3538                          (byte)(x &gt;&gt;&gt; 48),
3539                          (byte)(x &gt;&gt;&gt; 56));
3540         }
3541     }
3542 
3543     /**
3544      * As {@link #putLongUnaligned(Object, long, long)} but with an additional
3545      * argument which specifies the endianness of the value as stored in memory.
3546      * @param o Java heap object in which the value resides
3547      * @param offset The offset in bytes from the start of the object
3548      * @param x the value to store
3549      * @param bigEndian The endianness of the value
3550      * @throws RuntimeException No defined exceptions are thrown, not even
3551      *         {@link NullPointerException}
3552      * @since 9
3553      */
3554     public final void putLongUnaligned(Object o, long offset, long x, boolean bigEndian) {
3555         putLongUnaligned(o, offset, convEndian(bigEndian, x));
3556     }
3557 
3558     /** @see #putLongUnaligned(Object, long, long) */
3559     @HotSpotIntrinsicCandidate
3560     public final void putIntUnaligned(Object o, long offset, int x) {
3561         if ((offset &amp; 3) == 0) {
3562             putInt(o, offset, x);
3563         } else if ((offset &amp; 1) == 0) {
3564             putIntParts(o, offset,
3565                         (short)(x &gt;&gt; 0),
3566                         (short)(x &gt;&gt;&gt; 16));
3567         } else {
3568             putIntParts(o, offset,
3569                         (byte)(x &gt;&gt;&gt; 0),
3570                         (byte)(x &gt;&gt;&gt; 8),
3571                         (byte)(x &gt;&gt;&gt; 16),
3572                         (byte)(x &gt;&gt;&gt; 24));
3573         }
3574     }
3575     /** @see #putLongUnaligned(Object, long, long, boolean) */
3576     public final void putIntUnaligned(Object o, long offset, int x, boolean bigEndian) {
3577         putIntUnaligned(o, offset, convEndian(bigEndian, x));
3578     }
3579 
3580     /** @see #putLongUnaligned(Object, long, long) */
3581     @HotSpotIntrinsicCandidate
3582     public final void putShortUnaligned(Object o, long offset, short x) {
3583         if ((offset &amp; 1) == 0) {
3584             putShort(o, offset, x);
3585         } else {
3586             putShortParts(o, offset,
3587                           (byte)(x &gt;&gt;&gt; 0),
3588                           (byte)(x &gt;&gt;&gt; 8));
3589         }
3590     }
3591     /** @see #putLongUnaligned(Object, long, long, boolean) */
3592     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
3593         putShortUnaligned(o, offset, convEndian(bigEndian, x));
3594     }
3595 
3596     /** @see #putLongUnaligned(Object, long, long) */
3597     @HotSpotIntrinsicCandidate
3598     public final void putCharUnaligned(Object o, long offset, char x) {
3599         putShortUnaligned(o, offset, (short)x);
3600     }
3601     /** @see #putLongUnaligned(Object, long, long, boolean) */
3602     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
3603         putCharUnaligned(o, offset, convEndian(bigEndian, x));
3604     }
3605 
<a name="22" id="anc22"></a><span class="line-modified">3606     // JVM interface methods</span>
<span class="line-removed">3607     // BE is true iff the native endianness of this platform is big.</span>
<span class="line-removed">3608     private static final boolean BE = theUnsafe.isBigEndian0();</span>
<span class="line-removed">3609 </span>
<span class="line-removed">3610     // unalignedAccess is true iff this platform can perform unaligned accesses.</span>
<span class="line-removed">3611     private static final boolean unalignedAccess = theUnsafe.unalignedAccess0();</span>
<span class="line-removed">3612 </span>
<span class="line-removed">3613     private static int pickPos(int top, int pos) { return BE ? top - pos : pos; }</span>
3614 
3615     // These methods construct integers from bytes.  The byte ordering
3616     // is the native endianness of this platform.
3617     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3618         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
3619               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
3620               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
3621               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
3622               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
3623               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
3624               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
3625               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
3626     }
3627     private static long makeLong(short i0, short i1, short i2, short i3) {
3628         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
3629               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
3630               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
3631               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
3632     }
3633     private static long makeLong(int i0, int i1) {
3634         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
3635              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
3636     }
3637     private static int makeInt(short i0, short i1) {
3638         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
3639              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
3640     }
3641     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
3642         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
3643               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
3644               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
3645               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
3646     }
3647     private static short makeShort(byte i0, byte i1) {
3648         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
3649                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
3650     }
3651 
<a name="23" id="anc23"></a><span class="line-modified">3652     private static byte  pick(byte  le, byte  be) { return BE ? be : le; }</span>
<span class="line-modified">3653     private static short pick(short le, short be) { return BE ? be : le; }</span>
<span class="line-modified">3654     private static int   pick(int   le, int   be) { return BE ? be : le; }</span>
3655 
3656     // These methods write integers to memory from smaller parts
3657     // provided by their caller.  The ordering in which these parts
3658     // are written is the native endianness of this platform.
3659     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3660         putByte(o, offset + 0, pick(i0, i7));
3661         putByte(o, offset + 1, pick(i1, i6));
3662         putByte(o, offset + 2, pick(i2, i5));
3663         putByte(o, offset + 3, pick(i3, i4));
3664         putByte(o, offset + 4, pick(i4, i3));
3665         putByte(o, offset + 5, pick(i5, i2));
3666         putByte(o, offset + 6, pick(i6, i1));
3667         putByte(o, offset + 7, pick(i7, i0));
3668     }
3669     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
3670         putShort(o, offset + 0, pick(i0, i3));
3671         putShort(o, offset + 2, pick(i1, i2));
3672         putShort(o, offset + 4, pick(i2, i1));
3673         putShort(o, offset + 6, pick(i3, i0));
3674     }
3675     private void putLongParts(Object o, long offset, int i0, int i1) {
3676         putInt(o, offset + 0, pick(i0, i1));
3677         putInt(o, offset + 4, pick(i1, i0));
3678     }
3679     private void putIntParts(Object o, long offset, short i0, short i1) {
3680         putShort(o, offset + 0, pick(i0, i1));
3681         putShort(o, offset + 2, pick(i1, i0));
3682     }
3683     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
3684         putByte(o, offset + 0, pick(i0, i3));
3685         putByte(o, offset + 1, pick(i1, i2));
3686         putByte(o, offset + 2, pick(i2, i1));
3687         putByte(o, offset + 3, pick(i3, i0));
3688     }
3689     private void putShortParts(Object o, long offset, byte i0, byte i1) {
3690         putByte(o, offset + 0, pick(i0, i1));
3691         putByte(o, offset + 1, pick(i1, i0));
3692     }
3693 
3694     // Zero-extend an integer
3695     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
3696     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
3697     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
3698     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
3699     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
3700 
3701     // Maybe byte-reverse an integer
<a name="24" id="anc24"></a><span class="line-modified">3702     private static char convEndian(boolean big, char n)   { return big == BE ? n : Character.reverseBytes(n); }</span>
<span class="line-modified">3703     private static short convEndian(boolean big, short n) { return big == BE ? n : Short.reverseBytes(n)    ; }</span>
<span class="line-modified">3704     private static int convEndian(boolean big, int n)     { return big == BE ? n : Integer.reverseBytes(n)  ; }</span>
<span class="line-modified">3705     private static long convEndian(boolean big, long n)   { return big == BE ? n : Long.reverseBytes(n)     ; }</span>
3706 
3707 
3708 
3709     private native long allocateMemory0(long bytes);
3710     private native long reallocateMemory0(long address, long bytes);
3711     private native void freeMemory0(long address);
3712     private native void setMemory0(Object o, long offset, long bytes, byte value);
3713     @HotSpotIntrinsicCandidate
3714     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
3715     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
3716     private native long objectFieldOffset0(Field f);
3717     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
3718     private native long staticFieldOffset0(Field f);
3719     private native Object staticFieldBase0(Field f);
3720     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
3721     private native void ensureClassInitialized0(Class&lt;?&gt; c);
3722     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
3723     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
<a name="25" id="anc25"></a><span class="line-removed">3724     private native int addressSize0();</span>
3725     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
3726     private native int getLoadAverage0(double[] loadavg, int nelems);
<a name="26" id="anc26"></a><span class="line-removed">3727     private native boolean unalignedAccess0();</span>
<span class="line-removed">3728     private native boolean isBigEndian0();</span>
3729 
3730 
3731     /**
3732      * Invokes the given direct byte buffer&#39;s cleaner, if any.
3733      *
3734      * @param directBuffer a direct byte buffer
3735      * @throws NullPointerException     if {@code directBuffer} is null
3736      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
3737      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
3738      *                                  {@link java.nio.Buffer#duplicate duplicate}
3739      */
3740     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
3741         if (!directBuffer.isDirect())
3742             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
3743 
3744         DirectBuffer db = (DirectBuffer) directBuffer;
3745         if (db.attachment() != null)
3746             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
3747 
3748         Cleaner cleaner = db.cleaner();
3749         if (cleaner != null) {
3750             cleaner.clean();
3751         }
3752     }
3753 
3754     // The following deprecated methods are used by JSR 166.
3755 
3756     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3757     public final Object getObject(Object o, long offset) {
3758         return getReference(o, offset);
3759     }
3760     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3761     public final Object getObjectVolatile(Object o, long offset) {
3762         return getReferenceVolatile(o, offset);
3763     }
3764     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3765     public final Object getObjectAcquire(Object o, long offset) {
3766         return getReferenceAcquire(o, offset);
3767     }
3768     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3769     public final Object getObjectOpaque(Object o, long offset) {
3770         return getReferenceOpaque(o, offset);
3771     }
3772 
3773 
3774     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3775     public final void putObject(Object o, long offset, Object x) {
3776         putReference(o, offset, x);
3777     }
3778     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3779     public final void putObjectVolatile(Object o, long offset, Object x) {
3780         putReferenceVolatile(o, offset, x);
3781     }
3782     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3783     public final void putObjectOpaque(Object o, long offset, Object x) {
3784         putReferenceOpaque(o, offset, x);
3785     }
3786     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3787     public final void putObjectRelease(Object o, long offset, Object x) {
3788         putReferenceRelease(o, offset, x);
3789     }
3790 
3791 
3792     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3793     public final Object getAndSetObject(Object o, long offset, Object newValue) {
3794         return getAndSetReference(o, offset, newValue);
3795     }
3796     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3797     public final Object getAndSetObjectAcquire(Object o, long offset, Object newValue) {
3798         return getAndSetReferenceAcquire(o, offset, newValue);
3799     }
3800     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3801     public final Object getAndSetObjectRelease(Object o, long offset, Object newValue) {
3802         return getAndSetReferenceRelease(o, offset, newValue);
3803     }
3804 
3805 
3806     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3807     public final boolean compareAndSetObject(Object o, long offset, Object expected, Object x) {
3808         return compareAndSetReference(o, offset, expected, x);
3809     }
3810     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3811     public final Object compareAndExchangeObject(Object o, long offset, Object expected, Object x) {
3812         return compareAndExchangeReference(o, offset, expected, x);
3813     }
3814     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3815     public final Object compareAndExchangeObjectAcquire(Object o, long offset, Object expected, Object x) {
3816         return compareAndExchangeReferenceAcquire(o, offset, expected, x);
3817     }
3818     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3819     public final Object compareAndExchangeObjectRelease(Object o, long offset, Object expected, Object x) {
3820         return compareAndExchangeReferenceRelease(o, offset, expected, x);
3821     }
3822 
3823 
3824     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3825     public final boolean weakCompareAndSetObject(Object o, long offset, Object expected, Object x) {
3826         return weakCompareAndSetReference(o, offset, expected, x);
3827     }
3828     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3829     public final boolean weakCompareAndSetObjectAcquire(Object o, long offset, Object expected, Object x) {
3830         return weakCompareAndSetReferenceAcquire(o, offset, expected, x);
3831     }
3832     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3833     public final boolean weakCompareAndSetObjectPlain(Object o, long offset, Object expected, Object x) {
3834         return weakCompareAndSetReferencePlain(o, offset, expected, x);
3835     }
3836     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3837     public final boolean weakCompareAndSetObjectRelease(Object o, long offset, Object expected, Object x) {
3838         return weakCompareAndSetReferenceRelease(o, offset, expected, x);
3839     }
3840 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
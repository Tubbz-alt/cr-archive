<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/jdk/internal/icu/text/NormalizerBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *******************************************************************************
 28  * Copyright (C) 2000-2014, International Business Machines Corporation and
 29  * others. All Rights Reserved.
 30  *******************************************************************************
 31  */
 32 package jdk.internal.icu.text;
 33 
 34 import jdk.internal.icu.impl.Norm2AllModes;
 35 
 36 import java.text.CharacterIterator;
 37 import java.text.Normalizer;
 38 
 39 /**
 40  * Unicode Normalization
 41  *
 42  * &lt;h2&gt;Unicode normalization API&lt;/h2&gt;
 43  *
 44  * &lt;code&gt;normalize&lt;/code&gt; transforms Unicode text into an equivalent composed or
 45  * decomposed form, allowing for easier sorting and searching of text.
 46  * &lt;code&gt;normalize&lt;/code&gt; supports the standard normalization forms described in
 47  * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/&quot; target=&quot;unicode&quot;&gt;
 48  * Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;.
 49  *
 50  * Characters with accents or other adornments can be encoded in
 51  * several different ways in Unicode.  For example, take the character A-acute.
 52  * In Unicode, this can be encoded as a single character (the
 53  * &quot;composed&quot; form):
 54  *
 55  * &lt;pre&gt;
 56  *      00C1    LATIN CAPITAL LETTER A WITH ACUTE
 57  * &lt;/pre&gt;
 58  *
 59  * or as two separate characters (the &quot;decomposed&quot; form):
 60  *
 61  * &lt;pre&gt;
 62  *      0041    LATIN CAPITAL LETTER A
 63  *      0301    COMBINING ACUTE ACCENT
 64  * &lt;/pre&gt;
 65  *
 66  * To a user of your program, however, both of these sequences should be
 67  * treated as the same &quot;user-level&quot; character &quot;A with acute accent&quot;.  When you
 68  * are searching or comparing text, you must ensure that these two sequences are
 69  * treated equivalently.  In addition, you must handle characters with more than
 70  * one accent.  Sometimes the order of a character&#39;s combining accents is
 71  * significant, while in other cases accent sequences in different orders are
 72  * really equivalent.
 73  *
 74  * Similarly, the string &quot;ffi&quot; can be encoded as three separate letters:
 75  *
 76  * &lt;pre&gt;
 77  *      0066    LATIN SMALL LETTER F
 78  *      0066    LATIN SMALL LETTER F
 79  *      0069    LATIN SMALL LETTER I
 80  * &lt;/pre&gt;
 81  *
 82  * or as the single character
 83  *
 84  * &lt;pre&gt;
 85  *      FB03    LATIN SMALL LIGATURE FFI
 86  * &lt;/pre&gt;
 87  *
 88  * The ffi ligature is not a distinct semantic character, and strictly speaking
 89  * it shouldn&#39;t be in Unicode at all, but it was included for compatibility
 90  * with existing character sets that already provided it.  The Unicode standard
 91  * identifies such characters by giving them &quot;compatibility&quot; decompositions
 92  * into the corresponding semantic characters.  When sorting and searching, you
 93  * will often want to use these mappings.
 94  *
 95  * &lt;code&gt;normalize&lt;/code&gt; helps solve these problems by transforming text into
 96  * the canonical composed and decomposed forms as shown in the first example
 97  * above. In addition, you can have it perform compatibility decompositions so
 98  * that you can treat compatibility characters the same as their equivalents.
 99  * Finally, &lt;code&gt;normalize&lt;/code&gt; rearranges accents into the proper canonical
100  * order, so that you do not have to worry about accent rearrangement on your
101  * own.
102  *
103  * Form FCD, &quot;Fast C or D&quot;, is also designed for collation.
104  * It allows to work on strings that are not necessarily normalized
105  * with an algorithm (like in collation) that works under &quot;canonical closure&quot;,
106  * i.e., it treats precomposed characters and their decomposed equivalents the
107  * same.
108  *
109  * It is not a normalization form because it does not provide for uniqueness of
110  * representation. Multiple strings may be canonically equivalent (their NFDs
111  * are identical) and may all conform to FCD without being identical themselves.
112  *
113  * The form is defined such that the &quot;raw decomposition&quot;, the recursive
114  * canonical decomposition of each character, results in a string that is
115  * canonically ordered. This means that precomposed characters are allowed for
116  * as long as their decompositions do not need canonical reordering.
117  *
118  * Its advantage for a process like collation is that all NFD and most NFC texts
119  * - and many unnormalized texts - already conform to FCD and do not need to be
120  * normalized (NFD) for such a process. The FCD quick check will return YES for
121  * most strings in practice.
122  *
123  * normalize(FCD) may be implemented with NFD.
124  *
125  * For more details on FCD see Unicode Technical Note #5 (Canonical Equivalence in Applications):
126  * http://www.unicode.org/notes/tn5/#FCD
127  *
128  * ICU collation performs either NFD or FCD normalization automatically if
129  * normalization is turned on for the collator object. Beyond collation and
130  * string search, normalized strings may be useful for string equivalence
131  * comparisons, transliteration/transcription, unique representations, etc.
132  *
133  * The W3C generally recommends to exchange texts in NFC.
134  * Note also that most legacy character encodings use only precomposed forms and
135  * often do not encode any combining marks by themselves. For conversion to such
136  * character encodings the Unicode text needs to be normalized to NFC.
137  * For more usage examples, see the Unicode Standard Annex.
138  *
139  * Note: The Normalizer class also provides API for iterative normalization.
140  * While the setIndex() and getIndex() refer to indices in the
141  * underlying Unicode input text, the next() and previous() methods
142  * iterate through characters in the normalized output.
143  * This means that there is not necessarily a one-to-one correspondence
144  * between characters returned by next() and previous() and the indices
145  * passed to and returned from setIndex() and getIndex().
146  * It is for this reason that Normalizer does not implement the CharacterIterator interface.
147  *
148  * @stable ICU 2.8
149  */
150 // Original filename in ICU4J: Normalizer.java
151 public final class NormalizerBase implements Cloneable {
152 
153     // The input text and our position in it
154     private UCharacterIterator  text;
155     private Normalizer2         norm2;
156     private Mode                mode;
157     private int                 options;
158 
159     // The normalization buffer is the result of normalization
160     // of the source in [currentIndex..nextIndex] .
161     private int                 currentIndex;
162     private int                 nextIndex;
163 
164     // A buffer for holding intermediate results
165     private StringBuilder       buffer;
166     private int                 bufferPos;
167 
168     // Helper classes to defer loading of normalization data.
169     private static final class ModeImpl {
170         private ModeImpl(Normalizer2 n2) {
171             normalizer2 = n2;
172         }
173         private final Normalizer2 normalizer2;
174     }
175 
176     private static final class NFDModeImpl {
177         private static final ModeImpl INSTANCE = new ModeImpl(Normalizer2.getNFDInstance());
178     }
179 
180     private static final class NFKDModeImpl {
181         private static final ModeImpl INSTANCE = new ModeImpl(Normalizer2.getNFKDInstance());
182     }
183 
184     private static final class NFCModeImpl {
185         private static final ModeImpl INSTANCE = new ModeImpl(Normalizer2.getNFCInstance());
186     }
187 
188     private static final class NFKCModeImpl {
189         private static final ModeImpl INSTANCE = new ModeImpl(Normalizer2.getNFKCInstance());
190     }
191 
192     private static final class Unicode32 {
193         private static final UnicodeSet INSTANCE = new UnicodeSet(&quot;[:age=3.2:]&quot;).freeze();
194     }
195 
196     private static final class NFD32ModeImpl {
197         private static final ModeImpl INSTANCE =
198             new ModeImpl(new FilteredNormalizer2(Normalizer2.getNFDInstance(),
199                                                  Unicode32.INSTANCE));
200     }
201 
202     private static final class NFKD32ModeImpl {
203         private static final ModeImpl INSTANCE =
204             new ModeImpl(new FilteredNormalizer2(Normalizer2.getNFKDInstance(),
205                                                  Unicode32.INSTANCE));
206     }
207 
208     private static final class NFC32ModeImpl {
209         private static final ModeImpl INSTANCE =
210             new ModeImpl(new FilteredNormalizer2(Normalizer2.getNFCInstance(),
211                                                  Unicode32.INSTANCE));
212     }
213 
214     private static final class NFKC32ModeImpl {
215         private static final ModeImpl INSTANCE =
216             new ModeImpl(new FilteredNormalizer2(Normalizer2.getNFKCInstance(),
217                                                  Unicode32.INSTANCE));
218     }
219 
220     /**
221      * Options bit set value to select Unicode 3.2 normalization
222      * (except NormalizationCorrections).
223      * At most one Unicode version can be selected at a time.
224      * @stable ICU 2.6
225      */
226     public static final int UNICODE_3_2=0x20;
227 
228     public static final int UNICODE_3_2_0_ORIGINAL=UNICODE_3_2;
229 
230     /*
231      * Default option for the latest Unicode normalization. This option is
232      * provided mainly for testing.
233      * The value zero means that normalization is done with the fixes for
234      *   - Corrigendum 4 (Five CJK Canonical Mapping Errors)
235      *   - Corrigendum 5 (Normalization Idempotency)
236      */
237     public static final int UNICODE_LATEST = 0x00;
238 
239     /**
240      * Constant indicating that the end of the iteration has been reached.
241      * This is guaranteed to have the same value as {@link UCharacterIterator#DONE}.
242      * @stable ICU 2.8
243      */
244     public static final int DONE = UCharacterIterator.DONE;
245 
246     /**
247      * Constants for normalization modes.
248      * &lt;p&gt;
249      * The Mode class is not intended for public subclassing.
250      * Only the Mode constants provided by the Normalizer class should be used,
251      * and any fields or methods should not be called or overridden by users.
252      * @stable ICU 2.8
253      */
254     public abstract static class Mode {
255 
256         /**
257          * Sole constructor
258          * @internal
259          * @deprecated This API is ICU internal only.
260          */
261         @Deprecated
262         protected Mode() {
263         }
264 
265         /**
266          * @internal
267          * @deprecated This API is ICU internal only.
268          */
269         @Deprecated
270         protected abstract Normalizer2 getNormalizer2(int options);
271     }
272 
273     private static Mode toMode(Normalizer.Form form) {
274         switch (form) {
275         case NFC :
276             return NFC;
277         case NFD :
278             return NFD;
279         case NFKC :
280             return NFKC;
281         case NFKD :
282             return NFKD;
283         }
284 
285         throw new IllegalArgumentException(&quot;Unexpected normalization form: &quot; +
286                                            form);
287     }
288 
289     private static final class NONEMode extends Mode {
290         protected Normalizer2 getNormalizer2(int options) { return Norm2AllModes.NOOP_NORMALIZER2; }
291     }
292 
293     private static final class NFDMode extends Mode {
294         protected Normalizer2 getNormalizer2(int options) {
295             return (options&amp;UNICODE_3_2) != 0 ?
296                     NFD32ModeImpl.INSTANCE.normalizer2 :
297                     NFDModeImpl.INSTANCE.normalizer2;
298         }
299     }
300 
301     private static final class NFKDMode extends Mode {
302         protected Normalizer2 getNormalizer2(int options) {
303             return (options&amp;UNICODE_3_2) != 0 ?
304                     NFKD32ModeImpl.INSTANCE.normalizer2 :
305                     NFKDModeImpl.INSTANCE.normalizer2;
306         }
307     }
308 
309     private static final class NFCMode extends Mode {
310         protected Normalizer2 getNormalizer2(int options) {
311             return (options&amp;UNICODE_3_2) != 0 ?
312                     NFC32ModeImpl.INSTANCE.normalizer2 :
313                     NFCModeImpl.INSTANCE.normalizer2;
314         }
315     }
316 
317     private static final class NFKCMode extends Mode {
318         protected Normalizer2 getNormalizer2(int options) {
319             return (options&amp;UNICODE_3_2) != 0 ?
320                     NFKC32ModeImpl.INSTANCE.normalizer2 :
321                     NFKCModeImpl.INSTANCE.normalizer2;
322         }
323     }
324 
325     /**
326      * No decomposition/composition.
327      * @stable ICU 2.8
328      */
329     public static final Mode NONE = new NONEMode();
330 
331     /**
332      * Canonical decomposition.
333      * @stable ICU 2.8
334      */
335     public static final Mode NFD = new NFDMode();
336 
337     /**
338      * Compatibility decomposition.
339      * @stable ICU 2.8
340      */
341     public static final Mode NFKD = new NFKDMode();
342 
343     /**
344      * Canonical decomposition followed by canonical composition.
345      * @stable ICU 2.8
346      */
347     public static final Mode NFC = new NFCMode();
348 
349     public static final Mode NFKC =new NFKCMode();
350 
351     //-------------------------------------------------------------------------
352     // Iterator constructors
353     //-------------------------------------------------------------------------
354 
355     /**
356      * Creates a new {@code NormalizerBase} object for iterating over the
357      * normalized form of a given string.
358      * &lt;p&gt;
359      * The {@code options} parameter specifies which optional
360      * {@code NormalizerBase} features are to be enabled for this object.
361      * &lt;p&gt;
362      * @param str  The string to be normalized.  The normalization
363      *              will start at the beginning of the string.
364      *
365      * @param mode The normalization mode.
366      *
367      * @param opt Any optional features to be enabled.
368      *            Currently the only available option is {@link #UNICODE_3_2}.
369      *            If you want the default behavior corresponding to one of the
370      *            standard Unicode Normalization Forms, use 0 for this argument.
371      * @stable ICU 2.6
372      */
373     public NormalizerBase(String str, Mode mode, int opt) {
374         this.text = UCharacterIterator.getInstance(str);
375         this.mode = mode;
376         this.options=opt;
377         norm2 = mode.getNormalizer2(opt);
378         buffer = new StringBuilder();
379     }
380 
381     public NormalizerBase(String str, Mode mode) {
382        this(str, mode, 0);
383     }
384 
385 
386     /**
387      * Creates a new {@code NormalizerBase} object for iterating over the
388      * normalized form of the given text.
389      * &lt;p&gt;
390      * @param iter  The input text to be normalized.  The normalization
391      *              will start at the beginning of the string.
392      *
393      * @param mode  The normalization mode.
394      *
395      * @param opt Any optional features to be enabled.
396      *            Currently the only available option is {@link #UNICODE_3_2}.
397      *            If you want the default behavior corresponding to one of the
398      *            standard Unicode Normalization Forms, use 0 for this argument.
399      * @stable ICU 2.6
400      */
401     public NormalizerBase(CharacterIterator iter, Mode mode, int opt) {
402         this.text = UCharacterIterator.getInstance((CharacterIterator)iter.clone());
403         this.mode = mode;
404         this.options = opt;
405         norm2 = mode.getNormalizer2(opt);
406         buffer = new StringBuilder();
407     }
408 
409     public NormalizerBase(CharacterIterator iter, Mode mode) {
410        this(iter, mode, 0);
411     }
412 
413     /**
414      * Clones this {@code NormalizerBase} object.  All properties of this
415      * object are duplicated in the new object, including the cloning of any
416      * {@link CharacterIterator} that was passed in to the constructor
417      * or to {@link #setText(CharacterIterator) setText}.
418      * However, the text storage underlying
419      * the {@code CharacterIterator} is not duplicated unless the
420      * iterator&#39;s {@code clone} method does so.
421      * @stable ICU 2.8
422      */
423     public Object clone() {
424         try {
425             NormalizerBase copy = (NormalizerBase) super.clone();
426             copy.text = (UCharacterIterator) text.clone();
427             copy.mode = mode;
428             copy.options = options;
429             copy.norm2 = norm2;
430             copy.buffer = new StringBuilder(buffer);
431             copy.bufferPos = bufferPos;
432             copy.currentIndex = currentIndex;
433             copy.nextIndex = nextIndex;
434             return copy;
435         }
436         catch (CloneNotSupportedException e) {
437             throw new InternalError(e.toString(), e);
438         }
439     }
440 
441     /**
442      * Normalizes a {@code String} using the given normalization operation.
443      * &lt;p&gt;
444      * The {@code options} parameter specifies which optional
445      * {@code NormalizerBase} features are to be enabled for this operation.
446      * Currently the only available option is {@link #UNICODE_3_2}.
447      * If you want the default behavior corresponding to one of the standard
448      * Unicode Normalization Forms, use 0 for this argument.
449      * &lt;p&gt;
450      * @param str       the input string to be normalized.
451      * @param mode      the normalization mode
452      * @param options   the optional features to be enabled.
453      * @return String   the normalized string
454      * @stable ICU 2.6
455      */
456     public static String normalize(String str, Mode mode, int options) {
457         return mode.getNormalizer2(options).normalize(str);
458     }
459 
460     public static String normalize(String str, Normalizer.Form form) {
461         return NormalizerBase.normalize(str, toMode(form), UNICODE_LATEST);
462     }
463 
464     public static String normalize(String str, Normalizer.Form form, int options) {
465         return NormalizerBase.normalize(str, toMode(form), options);
466     }
467 
468     /**
469      * Test if a string is in a given normalization form.
470      * This is semantically equivalent to source.equals(normalize(source, mode)).
471      *
472      * Unlike quickCheck(), this function returns a definitive result,
473      * never a &quot;maybe&quot;.
474      * For NFD, NFKD, and FCD, both functions work exactly the same.
475      * For NFC and NFKC where quickCheck may return &quot;maybe&quot;, this function will
476      * perform further tests to arrive at a true/false result.
477      * @param str       the input string to be checked to see if it is
478      *                   normalized
479      * @param mode      the normalization mode
480      * @param options   Options for use with exclusion set and tailored Normalization
481      *                  The only option that is currently recognized is UNICODE_3_2
482      * @see #isNormalized
483      * @stable ICU 2.6
484      */
485     public static boolean isNormalized(String str, Mode mode, int options) {
486         return mode.getNormalizer2(options).isNormalized(str);
487     }
488 
489     public static boolean isNormalized(String str, Normalizer.Form form) {
490         return NormalizerBase.isNormalized(str, toMode(form), UNICODE_LATEST);
491     }
492 
493     public static boolean isNormalized(String str, Normalizer.Form form, int options) {
494         return NormalizerBase.isNormalized(str, toMode(form), options);
495     }
496 
497     //-------------------------------------------------------------------------
498     // Iteration API
499     //-------------------------------------------------------------------------
500 
501     /**
502      * Return the current character in the normalized text.
503      * @return The codepoint as an int
504      * @stable ICU 2.8
505      */
506     public int current() {
507         if(bufferPos&lt;buffer.length() || nextNormalize()) {
508             return buffer.codePointAt(bufferPos);
509         } else {
510             return DONE;
511         }
512     }
513 
514     /**
515      * Return the next character in the normalized text and advance
516      * the iteration position by one.  If the end
517      * of the text has already been reached, {@link #DONE} is returned.
518      * @return The codepoint as an int
519      * @stable ICU 2.8
520      */
521     public int next() {
522         if(bufferPos&lt;buffer.length() ||  nextNormalize()) {
523             int c=buffer.codePointAt(bufferPos);
524             bufferPos+=Character.charCount(c);
525             return c;
526         } else {
527             return DONE;
528         }
529     }
530 
531     /**
532      * Return the previous character in the normalized text and decrement
533      * the iteration position by one.  If the beginning
534      * of the text has already been reached, {@link #DONE} is returned.
535      * @return The codepoint as an int
536      * @stable ICU 2.8
537      */
538     public int previous() {
539         if(bufferPos&gt;0 || previousNormalize()) {
540             int c=buffer.codePointBefore(bufferPos);
541             bufferPos-=Character.charCount(c);
542             return c;
543         } else {
544             return DONE;
545         }
546     }
547 
548     /**
549      * Reset the index to the beginning of the text.
550      * This is equivalent to setIndexOnly(startIndex)).
551      * @stable ICU 2.8
552      */
553     public void reset() {
554         text.setIndex(0);
555         currentIndex=nextIndex=0;
556         clearBuffer();
557     }
558 
559     /**
560      * Set the iteration position in the input text that is being normalized,
561      * without any immediate normalization.
562      * After setIndexOnly(), getIndex() will return the same index that is
563      * specified here.
564      *
565      * @param index the desired index in the input text.
566      * @stable ICU 2.8
567      */
568     public void setIndexOnly(int index) {
569         text.setIndex(index);  // validates index
570         currentIndex=nextIndex=index;
571         clearBuffer();
572     }
573 
574     /**
575      * Set the iteration position in the input text that is being normalized
576      * and return the first normalized character at that position.
577      * &lt;p&gt;
578      * &lt;b&gt;Note:&lt;/b&gt; This method sets the position in the &lt;em&gt;input&lt;/em&gt; text,
579      * while {@link #next} and {@link #previous} iterate through characters
580      * in the normalized &lt;em&gt;output&lt;/em&gt;.  This means that there is not
581      * necessarily a one-to-one correspondence between characters returned
582      * by {@code next} and {@code previous} and the indices passed to and
583      * returned from {@code setIndex} and {@link #getIndex}.
584      * &lt;p&gt;
585      * @param index the desired index in the input text.
586      *
587      * @return   the first normalized character that is the result of iterating
588      *            forward starting at the given index.
589      *
590      * @throws IllegalArgumentException if the given index is less than
591      *          {@link #getBeginIndex} or greater than {@link #getEndIndex}.
592      * deprecated ICU 3.2
593      * @obsolete ICU 3.2
594      */
595      public int setIndex(int index) {
596          setIndexOnly(index);
597          return current();
598      }
599 
600     /**
601      * Retrieve the index of the start of the input text. This is the begin
602      * index of the {@code CharacterIterator} or the start (i.e. 0) of the
603      * {@code String} over which this {@code NormalizerBase} is iterating
604      * @deprecated ICU 2.2. Use startIndex() instead.
605      * @return The codepoint as an int
606      * @see #startIndex
607      */
608     @Deprecated
609     public int getBeginIndex() {
610         return 0;
611     }
612 
613     /**
614      * Retrieve the index of the end of the input text.  This is the end index
615      * of the {@code CharacterIterator} or the length of the {@code String}
616      * over which this {@code NormalizerBase} is iterating
617      * @deprecated ICU 2.2. Use endIndex() instead.
618      * @return The codepoint as an int
619      * @see #endIndex
620      */
621     @Deprecated
622     public int getEndIndex() {
623         return endIndex();
624     }
625 
626     /**
627      * Retrieve the current iteration position in the input text that is
628      * being normalized.  This method is useful in applications such as
629      * searching, where you need to be able to determine the position in
630      * the input text that corresponds to a given normalized output character.
631      * &lt;p&gt;
632      * &lt;b&gt;Note:&lt;/b&gt; This method sets the position in the &lt;em&gt;input&lt;/em&gt;, while
633      * {@link #next} and {@link #previous} iterate through characters in the
634      * &lt;em&gt;output&lt;/em&gt;.  This means that there is not necessarily a one-to-one
635      * correspondence between characters returned by {@code next} and
636      * {@code previous} and the indices passed to and returned from
637      * {@code setIndex} and {@link #getIndex}.
638      * @return The current iteration position
639      * @stable ICU 2.8
640      */
641     public int getIndex() {
642         if(bufferPos&lt;buffer.length()) {
643             return currentIndex;
644         } else {
645             return nextIndex;
646         }
647     }
648 
649     /**
650      * Retrieve the index of the end of the input text.  This is the end index
651      * of the {@code CharacterIterator} or the length of the {@code String}
652      * over which this {@code NormalizerBase} is iterating
653      * @return The current iteration position
654      * @stable ICU 2.8
655      */
656     public int endIndex() {
657         return text.getLength();
658     }
659 
660     //-------------------------------------------------------------------------
661     // Iterator attributes
662     //-------------------------------------------------------------------------
663     /**
664      * Set the normalization mode for this object.
665      * &lt;p&gt;
666      * &lt;b&gt;Note:&lt;/b&gt;If the normalization mode is changed while iterating
667      * over a string, calls to {@link #next} and {@link #previous} may
668      * return previously buffers characters in the old normalization mode
669      * until the iteration is able to re-sync at the next base character.
670      * It is safest to call {@link #setText setText()}, {@link #first},
671      * {@link #last}, etc. after calling {@code setMode}.
672      * &lt;p&gt;
673      * @param newMode the new mode for this {@code NormalizerBase}.
674      * The supported modes are:
675      * &lt;ul&gt;
676      *  &lt;li&gt;{@link #NFC}    - Unicode canonical decompositiion
677      *                        followed by canonical composition.
678      *  &lt;li&gt;{@link #NFKC}   - Unicode compatibility decompositiion
679      *                        follwed by canonical composition.
680      *  &lt;li&gt;{@link #NFD}    - Unicode canonical decomposition
681      *  &lt;li&gt;{@link #NFKD}   - Unicode compatibility decomposition.
682      *  &lt;li&gt;{@link #NONE}   - Do nothing but return characters
683      *                        from the underlying input text.
684      * &lt;/ul&gt;
685      *
686      * @see #getMode
687      * @stable ICU 2.8
688      */
689     public void setMode(Mode newMode) {
690         mode = newMode;
691         norm2 = mode.getNormalizer2(options);
692     }
693 
694     /**
695      * Return the basic operation performed by this {@code NormalizerBase}
696      *
697      * @see #setMode
698      * @stable ICU 2.8
699      */
700     public Mode getMode() {
701         return mode;
702     }
703 
704     /**
705      * Set the input text over which this {@code NormalizerBase} will iterate.
706      * The iteration position is set to the beginning of the input text.
707      * @param newText   The new string to be normalized.
708      * @stable ICU 2.8
709      */
710     public void setText(String newText) {
711         UCharacterIterator newIter = UCharacterIterator.getInstance(newText);
712         if (newIter == null) {
713             throw new IllegalStateException(&quot;Could not create a new UCharacterIterator&quot;);
714         }
715         text = newIter;
716         reset();
717     }
718 
719     /**
720      * Set the input text over which this {@code NormalizerBase} will iterate.
721      * The iteration position is set to the beginning of the input text.
722      * @param newText   The new string to be normalized.
723      * @stable ICU 2.8
724      */
725     public void setText(CharacterIterator newText) {
726         UCharacterIterator newIter = UCharacterIterator.getInstance(newText);
727         if (newIter == null) {
728             throw new IllegalStateException(&quot;Could not create a new UCharacterIterator&quot;);
729         }
730         text = newIter;
731         currentIndex=nextIndex=0;
732         clearBuffer();
733     }
734 
735     private void clearBuffer() {
736         buffer.setLength(0);
737         bufferPos=0;
738     }
739 
740     private boolean nextNormalize() {
741         clearBuffer();
742         currentIndex=nextIndex;
743         text.setIndex(nextIndex);
744         // Skip at least one character so we make progress.
745         int c=text.nextCodePoint();
746         if(c&lt;0) {
747             return false;
748         }
749         StringBuilder segment=new StringBuilder().appendCodePoint(c);
750         while((c=text.nextCodePoint())&gt;=0) {
751             if(norm2.hasBoundaryBefore(c)) {
752                 text.moveCodePointIndex(-1);
753                 break;
754             }
755             segment.appendCodePoint(c);
756         }
757         nextIndex=text.getIndex();
758         norm2.normalize(segment, buffer);
759         return buffer.length()!=0;
760     }
761 
762     private boolean previousNormalize() {
763         clearBuffer();
764         nextIndex=currentIndex;
765         text.setIndex(currentIndex);
766         StringBuilder segment=new StringBuilder();
767         int c;
768         while((c=text.previousCodePoint())&gt;=0) {
769             if(c&lt;=0xffff) {
770                 segment.insert(0, (char)c);
771             } else {
772                 segment.insert(0, Character.toChars(c));
773             }
774             if(norm2.hasBoundaryBefore(c)) {
775                 break;
776             }
777         }
778         currentIndex=text.getIndex();
779         norm2.normalize(segment, buffer);
780         bufferPos=buffer.length();
781         return buffer.length()!=0;
782     }
783 
784 }
    </pre>
  </body>
</html>
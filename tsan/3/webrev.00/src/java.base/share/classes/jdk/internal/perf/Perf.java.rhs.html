<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/perf/Perf.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.perf;
 26 
 27 import java.nio.ByteBuffer;
 28 import java.security.Permission;
 29 import java.security.PrivilegedAction;
 30 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-modified"> 31 </span>
<span class="line-added"> 32 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 33 </span>
 34 import jdk.internal.ref.CleanerFactory;
 35 
 36 /**
 37  * The Perf class provides the ability to attach to an instrumentation
 38  * buffer maintained by a Java virtual machine. The instrumentation
 39  * buffer may be for the Java virtual machine running the methods of
 40  * this class or it may be for another Java virtual machine on the
 41  * same system.
 42  * &lt;p&gt;
 43  * In addition, this class provides methods to create instrumentation
 44  * objects in the instrumentation buffer for the Java virtual machine
 45  * that is running these methods. It also contains methods for acquiring
 46  * the value of a platform specific high resolution clock for time
 47  * stamp and interval measurement purposes.
 48  *
 49  * @author   Brian Doherty
 50  * @since    1.4.2
 51  * @see      #getPerf
 52  * @see      jdk.internal.perf.Perf.GetPerfAction
 53  * @see      java.nio.ByteBuffer
 54  */
 55 public final class Perf {
 56 
 57     private static Perf instance;
 58 
 59     private static final int PERF_MODE_RO = 0;
 60     private static final int PERF_MODE_RW = 1;
 61 
 62     private Perf() { }    // prevent instantiation
 63 
 64     /**
 65      * The GetPerfAction class is a convenience class for acquiring access
 66      * to the singleton Perf instance using the
 67      * &lt;code&gt;AccessController.doPrivileged()&lt;/code&gt; method.
 68      * &lt;p&gt;
 69      * An instance of this class can be used as the argument to
 70      * &lt;code&gt;AccessController.doPrivileged(PrivilegedAction)&lt;/code&gt;.
 71      * &lt;p&gt; Here is a suggested idiom for use of this class:
 72      *
 73      * &lt;blockquote&gt;&lt;pre&gt;{@code
 74      * class MyTrustedClass {
 75      *   private static final Perf perf =
 76      *       AccessController.doPrivileged(new Perf.GetPerfAction&lt;Perf&gt;());
 77      *   ...
 78      * }
 79      * }&lt;/pre&gt;&lt;/blockquote&gt;
 80      * &lt;p&gt;
 81      * In the presence of a security manager, the &lt;code&gt;MyTrustedClass&lt;/code&gt;
 82      * class in the above example will need to be granted the
 83      * &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; &lt;code&gt;RuntimePermission&lt;/code&gt;
 84      * permission in order to successfully acquire the singleton Perf instance.
 85      * &lt;p&gt;
 86      * Please note that the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; permission
 87      * is not a JDK specified permission.
 88      *
 89      * @see  java.security.AccessController#doPrivileged(PrivilegedAction)
 90      * @see  java.lang.RuntimePermission
 91      */
 92     public static class GetPerfAction implements PrivilegedAction&lt;Perf&gt;
 93     {
 94         /**
 95          * Run the &lt;code&gt;Perf.getPerf()&lt;/code&gt; method in a privileged context.
 96          *
 97          * @see #getPerf
 98          */
 99         public Perf run() {
100             return getPerf();
101         }
102     }
103 
104     /**
105      * Return a reference to the singleton Perf instance.
106      * &lt;p&gt;
107      * The getPerf() method returns the singleton instance of the Perf
108      * class. The returned object provides the caller with the capability
109      * for accessing the instrumentation buffer for this or another local
110      * Java virtual machine.
111      * &lt;p&gt;
112      * If a security manager is installed, its &lt;code&gt;checkPermission&lt;/code&gt;
113      * method is called with a &lt;code&gt;RuntimePermission&lt;/code&gt; with a target
114      * of &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt;. A security exception will result
115      * if the caller has not been granted this permission.
116      * &lt;p&gt;
117      * Access to the returned &lt;code&gt;Perf&lt;/code&gt; object should be protected
118      * by its caller and not passed on to untrusted code. This object can
119      * be used to attach to the instrumentation buffer provided by this Java
120      * virtual machine or for those of other Java virtual machines running
121      * on the same system. The instrumentation buffer may contain senstitive
122      * information. API&#39;s built on top of this interface may want to provide
123      * finer grained access control to the contents of individual
124      * instrumentation objects contained within the buffer.
125      * &lt;p&gt;
126      * Please note that the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; permission
127      * is not a JDK specified permission.
128      *
129      * @return  A reference to the singleton Perf instance.
130      * @throws SecurityException  if a security manager exists and its
131      *         &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow access
132      *         to the &lt;em&gt;&quot;jdk.internal.perf.Perf.getPerf&quot;&quot;&lt;/em&gt; target.
133      * @see  java.lang.RuntimePermission
134      * @see  #attach
135      */
136     public static Perf getPerf()
137     {
138         SecurityManager security = System.getSecurityManager();
139         if (security != null) {
140             Permission perm = new RuntimePermission(&quot;jdk.internal.perf.Perf.getPerf&quot;);
141             security.checkPermission(perm);
142         }
143 
144         return instance;
145     }
146 
147     /**
148      * Attach to the instrumentation buffer for the specified Java virtual
149      * machine.
150      * &lt;p&gt;
151      * This method will attach to the instrumentation buffer for the
152      * specified virtual machine. It returns a &lt;code&gt;ByteBuffer&lt;/code&gt; object
153      * that is initialized to access the instrumentation buffer for the
154      * indicated Java virtual machine. The &lt;code&gt;lvmid&lt;/code&gt; parameter is
155      * a integer value that uniquely identifies the target local Java virtual
156      * machine. It is typically, but not necessarily, the process id of
157      * the target Java virtual machine.
158      * &lt;p&gt;
159      * If the &lt;code&gt;lvmid&lt;/code&gt; identifies a Java virtual machine different
160      * from the one running this method, then the coherency characteristics
161      * of the buffer are implementation dependent. Implementations that do
162      * not support named, coherent, shared memory may return a
163      * &lt;code&gt;ByteBuffer&lt;/code&gt; object that contains only a snap shot of the
164      * data in the instrumentation buffer. Implementations that support named,
165      * coherent, shared memory, may return a &lt;code&gt;ByteBuffer&lt;/code&gt; object
166      * that will be changing dynamically over time as the target Java virtual
167      * machine updates its mapping of this buffer.
168      * &lt;p&gt;
169      * If the &lt;code&gt;lvmid&lt;/code&gt; is 0 or equal to the actual &lt;code&gt;lvmid&lt;/code&gt;
170      * for the Java virtual machine running this method, then the returned
171      * &lt;code&gt;ByteBuffer&lt;/code&gt; object will always be coherent and dynamically
172      * changing.
173      * &lt;p&gt;
174      * The attach mode specifies the access permissions requested for the
175      * instrumentation buffer of the target virtual machine. The permitted
176      * access permissions are:
177      * &lt;ul&gt;
178      * &lt;li&gt;&quot;r&quot;  - Read only access. This Java virtual machine has only
179      * read access to the instrumentation buffer for the target Java
180      * virtual machine.
181      * &lt;li&gt;&quot;rw&quot;  - Read/Write access. This Java virtual machine has read and
182      * write access to the instrumentation buffer for the target Java virtual
183      * machine. This mode is currently not supported and is reserved for
184      * future enhancements.
185      * &lt;/ul&gt;
186      *
187      * @param   lvmid            an integer that uniquely identifies the
188      *                           target local Java virtual machine.
189      * @param   mode             a string indicating the attach mode.
190      * @return  ByteBuffer       a direct allocated byte buffer
191      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
192      * @throws  IOException      An I/O error occurred while trying to acquire
193      *                           the instrumentation buffer.
194      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
195      *                           into the virtual machine&#39;s address space.
196      * @see     java.nio.ByteBuffer
197      */
198     public ByteBuffer attach(int lvmid, String mode)
199            throws IllegalArgumentException, IOException
200     {
201         if (mode.compareTo(&quot;r&quot;) == 0) {
202             return attachImpl(null, lvmid, PERF_MODE_RO);
203         }
204         else if (mode.compareTo(&quot;rw&quot;) == 0) {
205             return attachImpl(null, lvmid, PERF_MODE_RW);
206         }
207         else {
208             throw new IllegalArgumentException(&quot;unknown mode&quot;);
209         }
210     }
211 
212     /**
213      * Attach to the instrumentation buffer for the specified Java virtual
214      * machine owned by the given user.
215      * &lt;p&gt;
216      * This method behaves just as the &lt;code&gt;attach(int lvmid, String mode)
217      * &lt;/code&gt; method, except that it only searches for Java virtual machines
218      * owned by the specified user.
219      *
220      * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
221      *                           name of the user that owns the target Java
222      *                           virtual machine.
223      * @param   lvmid            an integer that uniquely identifies the
224      *                           target local Java virtual machine.
225      * @param   mode             a string indicating the attach mode.
226      * @return  ByteBuffer       a direct allocated byte buffer
227      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
228      * @throws  IOException      An I/O error occurred while trying to acquire
229      *                           the instrumentation buffer.
230      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
231      *                           into the virtual machine&#39;s address space.
232      * @see     java.nio.ByteBuffer
233      */
234     public ByteBuffer attach(String user, int lvmid, String mode)
235            throws IllegalArgumentException, IOException
236     {
237         if (mode.compareTo(&quot;r&quot;) == 0) {
238             return attachImpl(user, lvmid, PERF_MODE_RO);
239         }
240         else if (mode.compareTo(&quot;rw&quot;) == 0) {
241             return attachImpl(user, lvmid, PERF_MODE_RW);
242         }
243         else {
244             throw new IllegalArgumentException(&quot;unknown mode&quot;);
245         }
246     }
247 
248     /**
249      * Call the implementation specific attach method.
250      * &lt;p&gt;
251      * This method calls into the Java virtual machine to perform the platform
252      * specific attach method. Buffers returned from this method are
253      * internally managed as &lt;code&gt;PhantomRefereces&lt;/code&gt; to provide for
254      * guaranteed, secure release of the native resources.
255      *
256      * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
257      *                           name of the user that owns the target Java
258      *                           virtual machine.
259      * @param   lvmid            an integer that uniquely identifies the
260      *                           target local Java virtual machine.
261      * @param   mode             a string indicating the attach mode.
262      * @return  ByteBuffer       a direct allocated byte buffer
263      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
264      * @throws  IOException      An I/O error occurred while trying to acquire
265      *                           the instrumentation buffer.
266      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
267      *                           into the virtual machine&#39;s address space.
268      */
269     private ByteBuffer attachImpl(String user, int lvmid, int mode)
270             throws IllegalArgumentException, IOException
271     {
272         final ByteBuffer b = attach(user, lvmid, mode);
273 
274         if (lvmid == 0) {
275             // The native instrumentation buffer for this Java virtual
276             // machine is never unmapped.
277             return b;
278         }
279         else {
280             // This is an instrumentation buffer for another Java virtual
281             // machine with native resources that need to be managed. We
282             // create a duplicate of the native ByteBuffer and manage it
283             // with a Cleaner. When the duplicate becomes phantom reachable,
284             // the native resources will be released.
285 
286             final ByteBuffer dup = b.duplicate();
287 
288             CleanerFactory.cleaner()
289                           .register(dup, new CleanerAction(instance, b));
290             return dup;
291         }
292     }
293 
294     private static class CleanerAction implements Runnable {
295         private final ByteBuffer bb;
296         private final Perf perf;
297         CleanerAction(Perf perf, ByteBuffer bb) {
298             this.perf = perf;
299             this.bb = bb;
300         }
301         public void run() {
302             try {
303                 perf.detach(bb);
304             } catch (Throwable th) {
305                 // avoid crashing the reference handler thread,
306                 // but provide for some diagnosability
307                 assert false : th.toString();
308             }
309         }
310     }
311 
312     /**
313      * Native method to perform the implementation specific attach mechanism.
314      * &lt;p&gt;
315      * The implementation of this method may return distinct or identical
316      * &lt;code&gt;ByteBuffer&lt;/code&gt; objects for two distinct calls requesting
317      * attachment to the same Java virtual machine.
318      * &lt;p&gt;
319      * For the Sun HotSpot JVM, two distinct calls to attach to the same
320      * target Java virtual machine will result in two distinct ByteBuffer
321      * objects returned by this method. This may change in a future release.
322      *
323      * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
324      *                           name of the user that owns the target Java
325      *                           virtual machine.
326      * @param   lvmid            an integer that uniquely identifies the
327      *                           target local Java virtual machine.
328      * @param   mode             a string indicating the attach mode.
329      * @return  ByteBuffer       a direct allocated byte buffer
330      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
331      * @throws  IOException      An I/O error occurred while trying to acquire
332      *                           the instrumentation buffer.
333      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
334      *                           into the virtual machine&#39;s address space.
335      */
336     private native ByteBuffer attach(String user, int lvmid, int mode)
337                    throws IllegalArgumentException, IOException;
338 
339     /**
340      * Native method to perform the implementation specific detach mechanism.
341      * &lt;p&gt;
342      * If this method is passed a &lt;code&gt;ByteBuffer&lt;/code&gt; object that is
343      * not created by the &lt;code&gt;attach&lt;/code&gt; method, then the results of
344      * this method are undefined, with unpredictable and potentially damaging
345      * effects to the Java virtual machine. To prevent accidental or malicious
346      * use of this method, all native ByteBuffer created by the &lt;code&gt;
347      * attach&lt;/code&gt; method are managed internally as PhantomReferences
348      * and resources are freed by the system.
349      * &lt;p&gt;
350      * If this method is passed a &lt;code&gt;ByteBuffer&lt;/code&gt; object created
351      * by the &lt;code&gt;attach&lt;/code&gt; method with a lvmid for the Java virtual
352      * machine running this method (lvmid=0, for example), then the detach
353      * request is silently ignored.
354      *
355      * @param bb  A direct allocated byte buffer created by the
356      *                    &lt;code&gt;attach&lt;/code&gt; method.
357      * @see   java.nio.ByteBuffer
358      * @see   #attach
359      */
360     private native void detach(ByteBuffer bb);
361 
362     /**
363      * Create a &lt;code&gt;long&lt;/code&gt; scalar entry in the instrumentation buffer
364      * with the given variability characteristic, units, and initial value.
365      * &lt;p&gt;
366      * Access to the instrument is provided through the returned &lt;code&gt;
367      * ByteBuffer&lt;/code&gt; object. Typically, this object should be wrapped
368      * with &lt;code&gt;LongBuffer&lt;/code&gt; view object.
369      *
370      * @param   variability the variability characteristic for this entry.
371      * @param   units       the units for this entry.
372      * @param   name        the name of this entry.
373      * @param   value       the initial value for this entry.
374      * @return  ByteBuffer  a direct allocated ByteBuffer object that
375      *                      allows write access to a native memory location
376      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
377      *
378      * see sun.misc.perf.Variability
379      * see sun.misc.perf.Units
380      * @see java.nio.ByteBuffer
381      */
382     public native ByteBuffer createLong(String name, int variability,
383                                         int units, long value);
384 
385     /**
386      * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
387      * the given variability characteristic, units, and initial value.
388      * &lt;p&gt;
389      * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
390      * instrument is given in by &lt;code&gt;maxLength&lt;/code&gt; parameter. Updates
391      * to this instrument with &lt;code&gt;String&lt;/code&gt; values with lengths greater
392      * than &lt;code&gt;maxLength&lt;/code&gt; will be truncated to &lt;code&gt;maxLength&lt;/code&gt;.
393      * The truncated value will be terminated by a null character.
394      * &lt;p&gt;
395      * The underlying implementation may further limit the length of the
396      * value, but will continue to preserve the null terminator.
397      * &lt;p&gt;
398      * Access to the instrument is provided through the returned &lt;code&gt;
399      * ByteBuffer&lt;/code&gt; object.
400      *
401      * @param   variability the variability characteristic for this entry.
402      * @param   units       the units for this entry.
403      * @param   name        the name of this entry.
404      * @param   value       the initial value for this entry.
405      * @param   maxLength   the maximum string length for this string
406      *                      instrument.
407      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
408      *                      write access to a native memory location
409      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
410      *
411      * see sun.misc.perf.Variability
412      * see sun.misc.perf.Units
413      * @see java.nio.ByteBuffer
414      */
415     public ByteBuffer createString(String name, int variability,
416                                    int units, String value, int maxLength)
417     {
<a name="3" id="anc3"></a><span class="line-modified">418         byte[] v = value.getBytes(UTF_8.INSTANCE);</span>
419         byte[] v1 = new byte[v.length+1];
420         System.arraycopy(v, 0, v1, 0, v.length);
421         v1[v.length] = &#39;\0&#39;;
422         return createByteArray(name, variability, units, v1, Math.max(v1.length, maxLength));
423     }
424 
425     /**
426      * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
427      * the given variability characteristic, units, and initial value.
428      * &lt;p&gt;
429      * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
430      * instrument is implied by the length of the &lt;code&gt;value&lt;/code&gt; parameter.
431      * Subsequent updates to the value of this instrument will be truncated
432      * to this implied maximum length. The truncated value will be terminated
433      * by a null character.
434      * &lt;p&gt;
435      * The underlying implementation may further limit the length of the
436      * initial or subsequent value, but will continue to preserve the null
437      * terminator.
438      * &lt;p&gt;
439      * Access to the instrument is provided through the returned &lt;code&gt;
440      * ByteBuffer&lt;/code&gt; object.
441      *
442      * @param   variability the variability characteristic for this entry.
443      * @param   units       the units for this entry.
444      * @param   name        the name of this entry.
445      * @param   value       the initial value for this entry.
446      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
447      *                      write access to a native memory location
448      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
449      *
450      * see sun.misc.perf.Variability
451      * see sun.misc.perf.Units
452      * @see java.nio.ByteBuffer
453      */
454     public ByteBuffer createString(String name, int variability,
455                                    int units, String value)
456     {
<a name="4" id="anc4"></a><span class="line-modified">457         byte[] v = value.getBytes(UTF_8.INSTANCE);</span>
458         byte[] v1 = new byte[v.length+1];
459         System.arraycopy(v, 0, v1, 0, v.length);
460         v1[v.length] = &#39;\0&#39;;
461         return createByteArray(name, variability, units, v1, v1.length);
462     }
463 
464     /**
465      * Create a &lt;code&gt;byte&lt;/code&gt; vector entry in the instrumentation buffer
466      * with the given variability characteristic, units, and initial value.
467      * &lt;p&gt;
468      * The &lt;code&gt;maxLength&lt;/code&gt; parameter limits the size of the byte
469      * array instrument such that the initial or subsequent updates beyond
470      * this length are silently ignored. No special handling of truncated
471      * updates is provided.
472      * &lt;p&gt;
473      * The underlying implementation may further limit the length of the
474      * length of the initial or subsequent value.
475      * &lt;p&gt;
476      * Access to the instrument is provided through the returned &lt;code&gt;
477      * ByteBuffer&lt;/code&gt; object.
478      *
479      * @param   variability the variability characteristic for this entry.
480      * @param   units       the units for this entry.
481      * @param   name        the name of this entry.
482      * @param   value       the initial value for this entry.
483      * @param   maxLength   the maximum length of this byte array.
484      * @return  ByteBuffer  a direct allocated byte buffer that allows
485      *                      write access to a native memory location
486      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
487      *
488      * see sun.misc.perf.Variability
489      * see sun.misc.perf.Units
490      * @see java.nio.ByteBuffer
491      */
492     public native ByteBuffer createByteArray(String name, int variability,
493                                              int units, byte[] value,
494                                              int maxLength);
495 
<a name="5" id="anc5"></a>

















496     /**
497      * Return the value of the High Resolution Counter.
498      *
499      * The High Resolution Counter returns the number of ticks since
500      * since the start of the Java virtual machine. The resolution of
501      * the counter is machine dependent and can be determined from the
502      * value return by the {@link #highResFrequency} method.
503      *
504      * @return  the number of ticks of machine dependent resolution since
505      *          the start of the Java virtual machine.
506      *
507      * @see #highResFrequency
508      * @see java.lang.System#currentTimeMillis()
509      */
510     public native long highResCounter();
511 
512     /**
513      * Returns the frequency of the High Resolution Counter, in ticks per
514      * second.
515      *
516      * This value can be used to convert the value of the High Resolution
517      * Counter, as returned from a call to the {@link #highResCounter} method,
518      * into the number of seconds since the start of the Java virtual machine.
519      *
520      * @return  the frequency of the High Resolution Counter.
521      * @see #highResCounter
522      */
523     public native long highResFrequency();
524 
525     private static native void registerNatives();
526 
527     static {
528         registerNatives();
529         instance = new Perf();
530     }
531 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
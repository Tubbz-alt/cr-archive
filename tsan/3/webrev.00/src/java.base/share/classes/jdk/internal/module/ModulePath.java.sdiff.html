<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/module/ModulePath.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ModuleLoaderMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Modules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/module/ModulePath.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 44 import java.nio.file.NoSuchFileException;
 45 import java.nio.file.Path;
 46 import java.nio.file.attribute.BasicFileAttributes;
 47 import java.util.ArrayList;
 48 import java.util.HashMap;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Objects;
 52 import java.util.Optional;
 53 import java.util.Set;
 54 import java.util.jar.Attributes;
 55 import java.util.jar.JarEntry;
 56 import java.util.jar.JarFile;
 57 import java.util.jar.Manifest;
 58 import java.util.regex.Matcher;
 59 import java.util.regex.Pattern;
 60 import java.util.stream.Collectors;
 61 import java.util.zip.ZipException;
 62 import java.util.zip.ZipFile;
 63 


 64 import jdk.internal.jmod.JmodFile;
 65 import jdk.internal.jmod.JmodFile.Section;
 66 import jdk.internal.perf.PerfCounter;
 67 
 68 /**
 69  * A {@code ModuleFinder} that locates modules on the file system by searching
 70  * a sequence of directories or packaged modules. The ModuleFinder can be
 71  * created to work in either the run-time or link-time phases. In both cases it
 72  * locates modular JAR and exploded modules. When created for link-time then it
 73  * additionally locates modules in JMOD files. The ModuleFinder can also
 74  * optionally patch any modules that it locates with a ModulePatcher.
 75  */
 76 
 77 public class ModulePath implements ModuleFinder {
 78     private static final String MODULE_INFO = &quot;module-info.class&quot;;
 79 
 80     // the version to use for multi-release modular JARs
 81     private final Runtime.Version releaseVersion;
 82 
 83     // true for the link phase (supports modules packaged in JMOD format)
</pre>
<hr />
<pre>
526                 .map(this::toPackageName)
527                 .flatMap(Optional::stream)
528                 .distinct()
529                 .collect(Collectors.toSet());
530 
531         // all packages are exported and open
532         builder.packages(packages);
533 
534         // map names of service configuration files to service names
535         Set&lt;String&gt; serviceNames = configFiles.stream()
536                 .map(this::toServiceName)
537                 .flatMap(Optional::stream)
538                 .collect(Collectors.toSet());
539 
540         // parse each service configuration file
541         for (String sn : serviceNames) {
542             JarEntry entry = jf.getJarEntry(SERVICES_PREFIX + sn);
543             List&lt;String&gt; providerClasses = new ArrayList&lt;&gt;();
544             try (InputStream in = jf.getInputStream(entry)) {
545                 BufferedReader reader
<span class="line-modified">546                     = new BufferedReader(new InputStreamReader(in, &quot;UTF-8&quot;));</span>
547                 String cn;
548                 while ((cn = nextLine(reader)) != null) {
549                     if (!cn.isEmpty()) {
550                         String pn = packageName(cn);
551                         if (!packages.contains(pn)) {
552                             String msg = &quot;Provider class &quot; + cn + &quot; not in module&quot;;
553                             throw new InvalidModuleDescriptorException(msg);
554                         }
555                         providerClasses.add(cn);
556                     }
557                 }
558             }
559             if (!providerClasses.isEmpty())
560                 builder.provides(sn, providerClasses);
561         }
562 
563         // Main-Class attribute if it exists
564         if (attrs != null) {
565             String mainClass = attrs.getValue(Attributes.Name.MAIN_CLASS);
566             if (mainClass != null) {
<span class="line-modified">567                 mainClass = mainClass.replace(&quot;/&quot;, &quot;.&quot;);</span>
568                 if (Checks.isClassName(mainClass)) {
569                     String pn = packageName(mainClass);
570                     if (packages.contains(pn)) {
571                         builder.mainClass(mainClass);
572                     }
573                 }
574             }
575         }
576 
577         return builder.build();
578     }
579 
580     /**
581      * Patterns used to derive the module name from a JAR file name.
582      */
583     private static class Patterns {
584         static final Pattern DASH_VERSION = Pattern.compile(&quot;-(\\d+(\\.|$))&quot;);
585         static final Pattern NON_ALPHANUM = Pattern.compile(&quot;[^A-Za-z0-9]&quot;);
586         static final Pattern REPEATING_DOTS = Pattern.compile(&quot;(\\.)(\\1)+&quot;);
587         static final Pattern LEADING_DOTS = Pattern.compile(&quot;^\\.&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 44 import java.nio.file.NoSuchFileException;
 45 import java.nio.file.Path;
 46 import java.nio.file.attribute.BasicFileAttributes;
 47 import java.util.ArrayList;
 48 import java.util.HashMap;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Objects;
 52 import java.util.Optional;
 53 import java.util.Set;
 54 import java.util.jar.Attributes;
 55 import java.util.jar.JarEntry;
 56 import java.util.jar.JarFile;
 57 import java.util.jar.Manifest;
 58 import java.util.regex.Matcher;
 59 import java.util.regex.Pattern;
 60 import java.util.stream.Collectors;
 61 import java.util.zip.ZipException;
 62 import java.util.zip.ZipFile;
 63 
<span class="line-added"> 64 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 65 </span>
 66 import jdk.internal.jmod.JmodFile;
 67 import jdk.internal.jmod.JmodFile.Section;
 68 import jdk.internal.perf.PerfCounter;
 69 
 70 /**
 71  * A {@code ModuleFinder} that locates modules on the file system by searching
 72  * a sequence of directories or packaged modules. The ModuleFinder can be
 73  * created to work in either the run-time or link-time phases. In both cases it
 74  * locates modular JAR and exploded modules. When created for link-time then it
 75  * additionally locates modules in JMOD files. The ModuleFinder can also
 76  * optionally patch any modules that it locates with a ModulePatcher.
 77  */
 78 
 79 public class ModulePath implements ModuleFinder {
 80     private static final String MODULE_INFO = &quot;module-info.class&quot;;
 81 
 82     // the version to use for multi-release modular JARs
 83     private final Runtime.Version releaseVersion;
 84 
 85     // true for the link phase (supports modules packaged in JMOD format)
</pre>
<hr />
<pre>
528                 .map(this::toPackageName)
529                 .flatMap(Optional::stream)
530                 .distinct()
531                 .collect(Collectors.toSet());
532 
533         // all packages are exported and open
534         builder.packages(packages);
535 
536         // map names of service configuration files to service names
537         Set&lt;String&gt; serviceNames = configFiles.stream()
538                 .map(this::toServiceName)
539                 .flatMap(Optional::stream)
540                 .collect(Collectors.toSet());
541 
542         // parse each service configuration file
543         for (String sn : serviceNames) {
544             JarEntry entry = jf.getJarEntry(SERVICES_PREFIX + sn);
545             List&lt;String&gt; providerClasses = new ArrayList&lt;&gt;();
546             try (InputStream in = jf.getInputStream(entry)) {
547                 BufferedReader reader
<span class="line-modified">548                     = new BufferedReader(new InputStreamReader(in, UTF_8.INSTANCE));</span>
549                 String cn;
550                 while ((cn = nextLine(reader)) != null) {
551                     if (!cn.isEmpty()) {
552                         String pn = packageName(cn);
553                         if (!packages.contains(pn)) {
554                             String msg = &quot;Provider class &quot; + cn + &quot; not in module&quot;;
555                             throw new InvalidModuleDescriptorException(msg);
556                         }
557                         providerClasses.add(cn);
558                     }
559                 }
560             }
561             if (!providerClasses.isEmpty())
562                 builder.provides(sn, providerClasses);
563         }
564 
565         // Main-Class attribute if it exists
566         if (attrs != null) {
567             String mainClass = attrs.getValue(Attributes.Name.MAIN_CLASS);
568             if (mainClass != null) {
<span class="line-modified">569                 mainClass = mainClass.replace(&#39;/&#39;, &#39;.&#39;);</span>
570                 if (Checks.isClassName(mainClass)) {
571                     String pn = packageName(mainClass);
572                     if (packages.contains(pn)) {
573                         builder.mainClass(mainClass);
574                     }
575                 }
576             }
577         }
578 
579         return builder.build();
580     }
581 
582     /**
583      * Patterns used to derive the module name from a JAR file name.
584      */
585     private static class Patterns {
586         static final Pattern DASH_VERSION = Pattern.compile(&quot;-(\\d+(\\.|$))&quot;);
587         static final Pattern NON_ALPHANUM = Pattern.compile(&quot;[^A-Za-z0-9]&quot;);
588         static final Pattern REPEATING_DOTS = Pattern.compile(&quot;(\\.)(\\1)+&quot;);
589         static final Pattern LEADING_DOTS = Pattern.compile(&quot;^\\.&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="ModuleLoaderMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Modules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
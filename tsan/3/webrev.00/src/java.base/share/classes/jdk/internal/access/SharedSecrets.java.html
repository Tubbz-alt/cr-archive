<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/jdk/internal/access/SharedSecrets.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.access;
 27 
 28 import javax.crypto.SealedObject;
 29 import java.io.ObjectInputFilter;
 30 import java.lang.module.ModuleDescriptor;
 31 import java.util.ResourceBundle;
 32 import java.util.jar.JarFile;
 33 import java.io.Console;
 34 import java.io.FileDescriptor;
 35 import java.io.FilePermission;
 36 import java.io.ObjectInputStream;
 37 import java.io.RandomAccessFile;
 38 import java.security.ProtectionDomain;
 39 import java.security.Signature;
 40 import jdk.internal.misc.Unsafe;
 41 
 42 /** A repository of &quot;shared secrets&quot;, which are a mechanism for
 43     calling implementation-private methods in another package without
 44     using reflection. A package-private class implements a public
 45     interface and provides the ability to call package-private methods
 46     within that package; the object implementing that interface is
 47     provided through a third package to which access is restricted.
 48     This framework avoids the primary disadvantage of using reflection
 49     for this purpose, namely the loss of compile-time checking. */
 50 
 51 public class SharedSecrets {
 52     private static final Unsafe unsafe = Unsafe.getUnsafe();
 53     private static JavaAWTAccess javaAWTAccess;
 54     private static JavaAWTFontAccess javaAWTFontAccess;
 55     private static JavaBeansAccess javaBeansAccess;
 56     private static JavaLangAccess javaLangAccess;
 57     private static JavaLangInvokeAccess javaLangInvokeAccess;
 58     private static JavaLangModuleAccess javaLangModuleAccess;
 59     private static JavaLangRefAccess javaLangRefAccess;
 60     private static JavaLangReflectAccess javaLangReflectAccess;
 61     private static JavaIOAccess javaIOAccess;
 62     private static JavaIOFileDescriptorAccess javaIOFileDescriptorAccess;
 63     private static JavaIOFilePermissionAccess javaIOFilePermissionAccess;
 64     private static JavaIORandomAccessFileAccess javaIORandomAccessFileAccess;
 65     private static JavaObjectInputStreamReadString javaObjectInputStreamReadString;
 66     private static JavaObjectInputStreamAccess javaObjectInputStreamAccess;
 67     private static JavaObjectInputFilterAccess javaObjectInputFilterAccess;
 68     private static JavaNetInetAddressAccess javaNetInetAddressAccess;
 69     private static JavaNetHttpCookieAccess javaNetHttpCookieAccess;
 70     private static JavaNetUriAccess javaNetUriAccess;
 71     private static JavaNetURLAccess javaNetURLAccess;
 72     private static JavaNioAccess javaNioAccess;
 73     private static JavaUtilJarAccess javaUtilJarAccess;
 74     private static JavaUtilZipFileAccess javaUtilZipFileAccess;
 75     private static JavaUtilResourceBundleAccess javaUtilResourceBundleAccess;
 76     private static JavaSecurityAccess javaSecurityAccess;
 77     private static JavaSecuritySignatureAccess javaSecuritySignatureAccess;
 78     private static JavaxCryptoSealedObjectAccess javaxCryptoSealedObjectAccess;
 79 
 80     public static JavaUtilJarAccess javaUtilJarAccess() {
 81         if (javaUtilJarAccess == null) {
 82             // Ensure JarFile is initialized; we know that this class
 83             // provides the shared secret
 84             unsafe.ensureClassInitialized(JarFile.class);
 85         }
 86         return javaUtilJarAccess;
 87     }
 88 
 89     public static void setJavaUtilJarAccess(JavaUtilJarAccess access) {
 90         javaUtilJarAccess = access;
 91     }
 92 
 93     public static void setJavaLangAccess(JavaLangAccess jla) {
 94         javaLangAccess = jla;
 95     }
 96 
 97     public static JavaLangAccess getJavaLangAccess() {
 98         return javaLangAccess;
 99     }
100 
101     public static void setJavaLangInvokeAccess(JavaLangInvokeAccess jlia) {
102         javaLangInvokeAccess = jlia;
103     }
104 
105     public static JavaLangInvokeAccess getJavaLangInvokeAccess() {
106         if (javaLangInvokeAccess == null) {
107             try {
108                 Class&lt;?&gt; c = Class.forName(&quot;java.lang.invoke.MethodHandleImpl&quot;);
109                 unsafe.ensureClassInitialized(c);
110             } catch (ClassNotFoundException e) {};
111         }
112         return javaLangInvokeAccess;
113     }
114 
115     public static void setJavaLangModuleAccess(JavaLangModuleAccess jlrma) {
116         javaLangModuleAccess = jlrma;
117     }
118 
119     public static JavaLangModuleAccess getJavaLangModuleAccess() {
120         if (javaLangModuleAccess == null) {
121             unsafe.ensureClassInitialized(ModuleDescriptor.class);
122         }
123         return javaLangModuleAccess;
124     }
125 
126     public static void setJavaLangRefAccess(JavaLangRefAccess jlra) {
127         javaLangRefAccess = jlra;
128     }
129 
130     public static JavaLangRefAccess getJavaLangRefAccess() {
131         return javaLangRefAccess;
132     }
133 
134     public static void setJavaLangReflectAccess(JavaLangReflectAccess jlra) {
135         javaLangReflectAccess = jlra;
136     }
137 
138     public static JavaLangReflectAccess getJavaLangReflectAccess() {
139         return javaLangReflectAccess;
140     }
141 
142     public static void setJavaNetUriAccess(JavaNetUriAccess jnua) {
143         javaNetUriAccess = jnua;
144     }
145 
146     public static JavaNetUriAccess getJavaNetUriAccess() {
147         if (javaNetUriAccess == null)
148             unsafe.ensureClassInitialized(java.net.URI.class);
149         return javaNetUriAccess;
150     }
151 
152     public static void setJavaNetURLAccess(JavaNetURLAccess jnua) {
153         javaNetURLAccess = jnua;
154     }
155 
156     public static JavaNetURLAccess getJavaNetURLAccess() {
157         if (javaNetURLAccess == null)
158             unsafe.ensureClassInitialized(java.net.URL.class);
159         return javaNetURLAccess;
160     }
161 
162     public static void setJavaNetInetAddressAccess(JavaNetInetAddressAccess jna) {
163         javaNetInetAddressAccess = jna;
164     }
165 
166     public static JavaNetInetAddressAccess getJavaNetInetAddressAccess() {
167         if (javaNetInetAddressAccess == null)
168             unsafe.ensureClassInitialized(java.net.InetAddress.class);
169         return javaNetInetAddressAccess;
170     }
171 
172     public static void setJavaNetHttpCookieAccess(JavaNetHttpCookieAccess a) {
173         javaNetHttpCookieAccess = a;
174     }
175 
176     public static JavaNetHttpCookieAccess getJavaNetHttpCookieAccess() {
177         if (javaNetHttpCookieAccess == null)
178             unsafe.ensureClassInitialized(java.net.HttpCookie.class);
179         return javaNetHttpCookieAccess;
180     }
181 
182     public static void setJavaNioAccess(JavaNioAccess jna) {
183         javaNioAccess = jna;
184     }
185 
186     public static JavaNioAccess getJavaNioAccess() {
187         if (javaNioAccess == null) {
188             // Ensure java.nio.Buffer is initialized, which provides the
189             // shared secret.
190             unsafe.ensureClassInitialized(java.nio.Buffer.class);
191         }
192         return javaNioAccess;
193     }
194 
195     public static void setJavaIOAccess(JavaIOAccess jia) {
196         javaIOAccess = jia;
197     }
198 
199     public static JavaIOAccess getJavaIOAccess() {
200         if (javaIOAccess == null) {
201             unsafe.ensureClassInitialized(Console.class);
202         }
203         return javaIOAccess;
204     }
205 
206     public static void setJavaIOFileDescriptorAccess(JavaIOFileDescriptorAccess jiofda) {
207         javaIOFileDescriptorAccess = jiofda;
208     }
209 
210     public static JavaIOFilePermissionAccess getJavaIOFilePermissionAccess() {
211         if (javaIOFilePermissionAccess == null)
212             unsafe.ensureClassInitialized(FilePermission.class);
213 
214         return javaIOFilePermissionAccess;
215     }
216 
217     public static void setJavaIOFilePermissionAccess(JavaIOFilePermissionAccess jiofpa) {
218         javaIOFilePermissionAccess = jiofpa;
219     }
220 
221     public static JavaIOFileDescriptorAccess getJavaIOFileDescriptorAccess() {
222         if (javaIOFileDescriptorAccess == null)
223             unsafe.ensureClassInitialized(FileDescriptor.class);
224 
225         return javaIOFileDescriptorAccess;
226     }
227 
228     public static void setJavaSecurityAccess(JavaSecurityAccess jsa) {
229         javaSecurityAccess = jsa;
230     }
231 
232     public static JavaSecurityAccess getJavaSecurityAccess() {
233         if (javaSecurityAccess == null) {
234             unsafe.ensureClassInitialized(ProtectionDomain.class);
235         }
236         return javaSecurityAccess;
237     }
238 
239     public static JavaUtilZipFileAccess getJavaUtilZipFileAccess() {
240         if (javaUtilZipFileAccess == null)
241             unsafe.ensureClassInitialized(java.util.zip.ZipFile.class);
242         return javaUtilZipFileAccess;
243     }
244 
245     public static void setJavaUtilZipFileAccess(JavaUtilZipFileAccess access) {
246         javaUtilZipFileAccess = access;
247     }
248 
249     public static void setJavaAWTAccess(JavaAWTAccess jaa) {
250         javaAWTAccess = jaa;
251     }
252 
253     public static JavaAWTAccess getJavaAWTAccess() {
254         // this may return null in which case calling code needs to
255         // provision for.
256         return javaAWTAccess;
257     }
258 
259     public static void setJavaAWTFontAccess(JavaAWTFontAccess jafa) {
260         javaAWTFontAccess = jafa;
261     }
262 
263     public static JavaAWTFontAccess getJavaAWTFontAccess() {
264         // this may return null in which case calling code needs to
265         // provision for.
266         return javaAWTFontAccess;
267     }
268 
269     public static JavaBeansAccess getJavaBeansAccess() {
270         return javaBeansAccess;
271     }
272 
273     public static void setJavaBeansAccess(JavaBeansAccess access) {
274         javaBeansAccess = access;
275     }
276 
277     public static JavaUtilResourceBundleAccess getJavaUtilResourceBundleAccess() {
278         if (javaUtilResourceBundleAccess == null)
279             unsafe.ensureClassInitialized(ResourceBundle.class);
280         return javaUtilResourceBundleAccess;
281     }
282 
283     public static void setJavaUtilResourceBundleAccess(JavaUtilResourceBundleAccess access) {
284         javaUtilResourceBundleAccess = access;
285     }
286 
287     public static JavaObjectInputStreamReadString getJavaObjectInputStreamReadString() {
288         if (javaObjectInputStreamReadString == null) {
289             unsafe.ensureClassInitialized(ObjectInputStream.class);
290         }
291         return javaObjectInputStreamReadString;
292     }
293 
294     public static void setJavaObjectInputStreamReadString(JavaObjectInputStreamReadString access) {
295         javaObjectInputStreamReadString = access;
296     }
297 
298     public static JavaObjectInputStreamAccess getJavaObjectInputStreamAccess() {
299         if (javaObjectInputStreamAccess == null) {
300             unsafe.ensureClassInitialized(ObjectInputStream.class);
301         }
302         return javaObjectInputStreamAccess;
303     }
304 
305     public static void setJavaObjectInputStreamAccess(JavaObjectInputStreamAccess access) {
306         javaObjectInputStreamAccess = access;
307     }
308 
309     public static JavaObjectInputFilterAccess getJavaObjectInputFilterAccess() {
310         if (javaObjectInputFilterAccess == null) {
311             unsafe.ensureClassInitialized(ObjectInputFilter.Config.class);
312         }
313         return javaObjectInputFilterAccess;
314     }
315 
316     public static void setJavaObjectInputFilterAccess(JavaObjectInputFilterAccess access) {
317         javaObjectInputFilterAccess = access;
318     }
319 
320     public static void setJavaIORandomAccessFileAccess(JavaIORandomAccessFileAccess jirafa) {
321         javaIORandomAccessFileAccess = jirafa;
322     }
323 
324     public static JavaIORandomAccessFileAccess getJavaIORandomAccessFileAccess() {
325         if (javaIORandomAccessFileAccess == null) {
326             unsafe.ensureClassInitialized(RandomAccessFile.class);
327         }
328         return javaIORandomAccessFileAccess;
329     }
330 
331     public static void setJavaSecuritySignatureAccess(JavaSecuritySignatureAccess jssa) {
332         javaSecuritySignatureAccess = jssa;
333     }
334 
335     public static JavaSecuritySignatureAccess getJavaSecuritySignatureAccess() {
336         if (javaSecuritySignatureAccess == null) {
337             unsafe.ensureClassInitialized(Signature.class);
338         }
339         return javaSecuritySignatureAccess;
340     }
341 
342     public static void setJavaxCryptoSealedObjectAccess(JavaxCryptoSealedObjectAccess jcsoa) {
343         javaxCryptoSealedObjectAccess = jcsoa;
344     }
345 
346     public static JavaxCryptoSealedObjectAccess getJavaxCryptoSealedObjectAccess() {
347         if (javaxCryptoSealedObjectAccess == null) {
348             unsafe.ensureClassInitialized(SealedObject.class);
349         }
350         return javaxCryptoSealedObjectAccess;
351     }
352 }
    </pre>
  </body>
</html>
diff a/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java b/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java
--- a/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java
+++ b/src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,12 +23,10 @@
  * questions.
  */
 
 package jdk.internal.loader;
 
-import java.io.File;
-import java.io.FilePermission;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.module.ModuleDescriptor;
 import java.lang.module.ModuleReference;
 import java.lang.module.ModuleReader;
@@ -38,11 +36,10 @@
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.security.AccessController;
 import java.security.CodeSigner;
 import java.security.CodeSource;
-import java.security.Permission;
 import java.security.PermissionCollection;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.security.SecureClassLoader;
@@ -62,10 +59,12 @@
 
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.module.ModulePatcher.PatchedModuleReader;
 import jdk.internal.module.Resources;
+import jdk.internal.vm.annotation.Stable;
+import sun.security.util.LazyCodeSourcePermissionCollection;
 
 
 /**
  * The platform or application class loader. Resources loaded from modules
  * defined to the boot class loader are also loaded via an instance of this
@@ -115,28 +114,48 @@
      * URL to avoid needing to create this URL when defining classes.
      */
     private static class LoadedModule {
         private final BuiltinClassLoader loader;
         private final ModuleReference mref;
-        private final URL codeSourceURL;          // may be null
+        private final URI uri;                      // may be null
+        private @Stable URL codeSourceURL;          // may be null
 
         LoadedModule(BuiltinClassLoader loader, ModuleReference mref) {
             URL url = null;
-            if (mref.location().isPresent()) {
-                try {
-                    url = mref.location().get().toURL();
-                } catch (MalformedURLException | IllegalArgumentException e) { }
+            this.uri = mref.location().orElse(null);
+
+            // for non-jrt schemes we need to resolve the codeSourceURL
+            // eagerly during bootstrap since the handler might be
+            // overridden
+            if (uri != null && !"jrt".equals(uri.getScheme())) {
+                url = createURL(uri);
             }
             this.loader = loader;
             this.mref = mref;
             this.codeSourceURL = url;
         }
 
         BuiltinClassLoader loader() { return loader; }
         ModuleReference mref() { return mref; }
         String name() { return mref.descriptor().name(); }
-        URL codeSourceURL() { return codeSourceURL; }
+
+        URL codeSourceURL() {
+            URL url = codeSourceURL;
+            if (url == null && uri != null) {
+                codeSourceURL = url = createURL(uri);
+            }
+            return url;
+        }
+
+        private URL createURL(URI uri) {
+            URL url = null;
+            try {
+                url = uri.toURL();
+            } catch (MalformedURLException | IllegalArgumentException e) {
+            }
+            return url;
+        }
     }
 
 
     // maps package name to loaded module for modules in the boot layer
     private static final Map<String, LoadedModule> packageToModule
@@ -160,11 +179,11 @@
         super(name, parent == null || parent == ClassLoaders.bootLoader() ? null : parent);
 
         this.parent = parent;
         this.ucp = ucp;
 
-        this.nameToModule = new ConcurrentHashMap<>();
+        this.nameToModule = new ConcurrentHashMap<>(32);
         this.moduleToReader = new ConcurrentHashMap<>();
     }
 
     /**
      * Returns {@code true} if there is a class path associated with this
@@ -177,26 +196,27 @@
     /**
      * Register a module this class loader. This has the effect of making the
      * types in the module visible.
      */
     public void loadModule(ModuleReference mref) {
-        String mn = mref.descriptor().name();
+        ModuleDescriptor descriptor = mref.descriptor();
+        String mn = descriptor.name();
         if (nameToModule.putIfAbsent(mn, mref) != null) {
             throw new InternalError(mn + " already defined to this loader");
         }
 
         LoadedModule loadedModule = new LoadedModule(this, mref);
-        for (String pn : mref.descriptor().packages()) {
+        for (String pn : descriptor.packages()) {
             LoadedModule other = packageToModule.putIfAbsent(pn, loadedModule);
             if (other != null) {
                 throw new InternalError(pn + " in modules " + mn + " and "
-                                        + other.mref().descriptor().name());
+                                        + other.name());
             }
         }
 
         // clear resources cache if VM is already initialized
-        if (VM.isModuleSystemInited() && resourceCache != null) {
+        if (resourceCache != null && VM.isModuleSystemInited()) {
             resourceCache = null;
         }
     }
 
     /**
@@ -387,12 +407,15 @@
      */
     private List<URL> findMiscResource(String name) throws IOException {
         SoftReference<Map<String, List<URL>>> ref = this.resourceCache;
         Map<String, List<URL>> map = (ref != null) ? ref.get() : null;
         if (map == null) {
-            map = new ConcurrentHashMap<>();
-            this.resourceCache = new SoftReference<>(map);
+            // only cache resources after VM is fully initialized
+            if (VM.isModuleSystemInited()) {
+                map = new ConcurrentHashMap<>();
+                this.resourceCache = new SoftReference<>(map);
+            }
         } else {
             List<URL> urls = map.get(name);
             if (urls != null)
                 return urls;
         }
@@ -423,11 +446,11 @@
         } catch (PrivilegedActionException pae) {
             throw (IOException) pae.getCause();
         }
 
         // only cache resources after VM is fully initialized
-        if (VM.isModuleSystemInited()) {
+        if (map != null) {
             map.putIfAbsent(name, urls);
         }
 
         return urls;
     }
@@ -943,43 +966,13 @@
     /**
      * Returns the permissions for the given CodeSource.
      */
     @Override
     protected PermissionCollection getPermissions(CodeSource cs) {
-        PermissionCollection perms = super.getPermissions(cs);
-
-        // add the permission to access the resource
-        URL url = cs.getLocation();
-        if (url == null)
-            return perms;
-
-        // avoid opening connection when URL is to resource in run-time image
-        if (url.getProtocol().equals("jrt")) {
-            perms.add(new RuntimePermission("accessSystemModules"));
-            return perms;
-        }
-
-        // open connection to determine the permission needed
-        try {
-            Permission p = url.openConnection().getPermission();
-            if (p != null) {
-                // for directories then need recursive access
-                if (p instanceof FilePermission) {
-                    String path = p.getName();
-                    if (path.endsWith(File.separator)) {
-                        path += "-";
-                        p = new FilePermission(path, "read");
-                    }
-                }
-                perms.add(p);
-            }
-        } catch (IOException ioe) { }
-
-        return perms;
+        return new LazyCodeSourcePermissionCollection(super.getPermissions(cs), cs);
     }
 
-
     // -- miscellaneous supporting methods
 
     /**
      * Returns the ModuleReader for the given module, creating it if needed.
      */

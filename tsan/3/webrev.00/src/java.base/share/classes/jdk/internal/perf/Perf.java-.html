<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/jdk/internal/perf/Perf.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2006, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.perf;
 26 
 27 import java.nio.ByteBuffer;
 28 import java.security.Permission;
 29 import java.security.PrivilegedAction;
 30 import java.io.IOException;
 31 import java.io.UnsupportedEncodingException;
 32 import jdk.internal.ref.CleanerFactory;
 33 
 34 /**
 35  * The Perf class provides the ability to attach to an instrumentation
 36  * buffer maintained by a Java virtual machine. The instrumentation
 37  * buffer may be for the Java virtual machine running the methods of
 38  * this class or it may be for another Java virtual machine on the
 39  * same system.
 40  * &lt;p&gt;
 41  * In addition, this class provides methods to create instrumentation
 42  * objects in the instrumentation buffer for the Java virtual machine
 43  * that is running these methods. It also contains methods for acquiring
 44  * the value of a platform specific high resolution clock for time
 45  * stamp and interval measurement purposes.
 46  *
 47  * @author   Brian Doherty
 48  * @since    1.4.2
 49  * @see      #getPerf
 50  * @see      jdk.internal.perf.Perf.GetPerfAction
 51  * @see      java.nio.ByteBuffer
 52  */
 53 public final class Perf {
 54 
 55     private static Perf instance;
 56 
 57     private static final int PERF_MODE_RO = 0;
 58     private static final int PERF_MODE_RW = 1;
 59 
 60     private Perf() { }    // prevent instantiation
 61 
 62     /**
 63      * The GetPerfAction class is a convenience class for acquiring access
 64      * to the singleton Perf instance using the
 65      * &lt;code&gt;AccessController.doPrivileged()&lt;/code&gt; method.
 66      * &lt;p&gt;
 67      * An instance of this class can be used as the argument to
 68      * &lt;code&gt;AccessController.doPrivileged(PrivilegedAction)&lt;/code&gt;.
 69      * &lt;p&gt; Here is a suggested idiom for use of this class:
 70      *
 71      * &lt;blockquote&gt;&lt;pre&gt;{@code
 72      * class MyTrustedClass {
 73      *   private static final Perf perf =
 74      *       AccessController.doPrivileged(new Perf.GetPerfAction&lt;Perf&gt;());
 75      *   ...
 76      * }
 77      * }&lt;/pre&gt;&lt;/blockquote&gt;
 78      * &lt;p&gt;
 79      * In the presence of a security manager, the &lt;code&gt;MyTrustedClass&lt;/code&gt;
 80      * class in the above example will need to be granted the
 81      * &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; &lt;code&gt;RuntimePermission&lt;/code&gt;
 82      * permission in order to successfully acquire the singleton Perf instance.
 83      * &lt;p&gt;
 84      * Please note that the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; permission
 85      * is not a JDK specified permission.
 86      *
 87      * @see  java.security.AccessController#doPrivileged(PrivilegedAction)
 88      * @see  java.lang.RuntimePermission
 89      */
 90     public static class GetPerfAction implements PrivilegedAction&lt;Perf&gt;
 91     {
 92         /**
 93          * Run the &lt;code&gt;Perf.getPerf()&lt;/code&gt; method in a privileged context.
 94          *
 95          * @see #getPerf
 96          */
 97         public Perf run() {
 98             return getPerf();
 99         }
100     }
101 
102     /**
103      * Return a reference to the singleton Perf instance.
104      * &lt;p&gt;
105      * The getPerf() method returns the singleton instance of the Perf
106      * class. The returned object provides the caller with the capability
107      * for accessing the instrumentation buffer for this or another local
108      * Java virtual machine.
109      * &lt;p&gt;
110      * If a security manager is installed, its &lt;code&gt;checkPermission&lt;/code&gt;
111      * method is called with a &lt;code&gt;RuntimePermission&lt;/code&gt; with a target
112      * of &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt;. A security exception will result
113      * if the caller has not been granted this permission.
114      * &lt;p&gt;
115      * Access to the returned &lt;code&gt;Perf&lt;/code&gt; object should be protected
116      * by its caller and not passed on to untrusted code. This object can
117      * be used to attach to the instrumentation buffer provided by this Java
118      * virtual machine or for those of other Java virtual machines running
119      * on the same system. The instrumentation buffer may contain senstitive
120      * information. API&#39;s built on top of this interface may want to provide
121      * finer grained access control to the contents of individual
122      * instrumentation objects contained within the buffer.
123      * &lt;p&gt;
124      * Please note that the &lt;em&gt;&quot;sun.misc.Perf.getPerf&quot;&lt;/em&gt; permission
125      * is not a JDK specified permission.
126      *
127      * @return  A reference to the singleton Perf instance.
128      * @throws SecurityException  if a security manager exists and its
129      *         &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow access
130      *         to the &lt;em&gt;&quot;jdk.internal.perf.Perf.getPerf&quot;&quot;&lt;/em&gt; target.
131      * @see  java.lang.RuntimePermission
132      * @see  #attach
133      */
134     public static Perf getPerf()
135     {
136         SecurityManager security = System.getSecurityManager();
137         if (security != null) {
138             Permission perm = new RuntimePermission(&quot;jdk.internal.perf.Perf.getPerf&quot;);
139             security.checkPermission(perm);
140         }
141 
142         return instance;
143     }
144 
145     /**
146      * Attach to the instrumentation buffer for the specified Java virtual
147      * machine.
148      * &lt;p&gt;
149      * This method will attach to the instrumentation buffer for the
150      * specified virtual machine. It returns a &lt;code&gt;ByteBuffer&lt;/code&gt; object
151      * that is initialized to access the instrumentation buffer for the
152      * indicated Java virtual machine. The &lt;code&gt;lvmid&lt;/code&gt; parameter is
153      * a integer value that uniquely identifies the target local Java virtual
154      * machine. It is typically, but not necessarily, the process id of
155      * the target Java virtual machine.
156      * &lt;p&gt;
157      * If the &lt;code&gt;lvmid&lt;/code&gt; identifies a Java virtual machine different
158      * from the one running this method, then the coherency characteristics
159      * of the buffer are implementation dependent. Implementations that do
160      * not support named, coherent, shared memory may return a
161      * &lt;code&gt;ByteBuffer&lt;/code&gt; object that contains only a snap shot of the
162      * data in the instrumentation buffer. Implementations that support named,
163      * coherent, shared memory, may return a &lt;code&gt;ByteBuffer&lt;/code&gt; object
164      * that will be changing dynamically over time as the target Java virtual
165      * machine updates its mapping of this buffer.
166      * &lt;p&gt;
167      * If the &lt;code&gt;lvmid&lt;/code&gt; is 0 or equal to the actual &lt;code&gt;lvmid&lt;/code&gt;
168      * for the Java virtual machine running this method, then the returned
169      * &lt;code&gt;ByteBuffer&lt;/code&gt; object will always be coherent and dynamically
170      * changing.
171      * &lt;p&gt;
172      * The attach mode specifies the access permissions requested for the
173      * instrumentation buffer of the target virtual machine. The permitted
174      * access permissions are:
175      * &lt;ul&gt;
176      * &lt;li&gt;&quot;r&quot;  - Read only access. This Java virtual machine has only
177      * read access to the instrumentation buffer for the target Java
178      * virtual machine.
179      * &lt;li&gt;&quot;rw&quot;  - Read/Write access. This Java virtual machine has read and
180      * write access to the instrumentation buffer for the target Java virtual
181      * machine. This mode is currently not supported and is reserved for
182      * future enhancements.
183      * &lt;/ul&gt;
184      *
185      * @param   lvmid            an integer that uniquely identifies the
186      *                           target local Java virtual machine.
187      * @param   mode             a string indicating the attach mode.
188      * @return  ByteBuffer       a direct allocated byte buffer
189      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
190      * @throws  IOException      An I/O error occurred while trying to acquire
191      *                           the instrumentation buffer.
192      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
193      *                           into the virtual machine&#39;s address space.
194      * @see     java.nio.ByteBuffer
195      */
196     public ByteBuffer attach(int lvmid, String mode)
197            throws IllegalArgumentException, IOException
198     {
199         if (mode.compareTo(&quot;r&quot;) == 0) {
200             return attachImpl(null, lvmid, PERF_MODE_RO);
201         }
202         else if (mode.compareTo(&quot;rw&quot;) == 0) {
203             return attachImpl(null, lvmid, PERF_MODE_RW);
204         }
205         else {
206             throw new IllegalArgumentException(&quot;unknown mode&quot;);
207         }
208     }
209 
210     /**
211      * Attach to the instrumentation buffer for the specified Java virtual
212      * machine owned by the given user.
213      * &lt;p&gt;
214      * This method behaves just as the &lt;code&gt;attach(int lvmid, String mode)
215      * &lt;/code&gt; method, except that it only searches for Java virtual machines
216      * owned by the specified user.
217      *
218      * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
219      *                           name of the user that owns the target Java
220      *                           virtual machine.
221      * @param   lvmid            an integer that uniquely identifies the
222      *                           target local Java virtual machine.
223      * @param   mode             a string indicating the attach mode.
224      * @return  ByteBuffer       a direct allocated byte buffer
225      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
226      * @throws  IOException      An I/O error occurred while trying to acquire
227      *                           the instrumentation buffer.
228      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
229      *                           into the virtual machine&#39;s address space.
230      * @see     java.nio.ByteBuffer
231      */
232     public ByteBuffer attach(String user, int lvmid, String mode)
233            throws IllegalArgumentException, IOException
234     {
235         if (mode.compareTo(&quot;r&quot;) == 0) {
236             return attachImpl(user, lvmid, PERF_MODE_RO);
237         }
238         else if (mode.compareTo(&quot;rw&quot;) == 0) {
239             return attachImpl(user, lvmid, PERF_MODE_RW);
240         }
241         else {
242             throw new IllegalArgumentException(&quot;unknown mode&quot;);
243         }
244     }
245 
246     /**
247      * Call the implementation specific attach method.
248      * &lt;p&gt;
249      * This method calls into the Java virtual machine to perform the platform
250      * specific attach method. Buffers returned from this method are
251      * internally managed as &lt;code&gt;PhantomRefereces&lt;/code&gt; to provide for
252      * guaranteed, secure release of the native resources.
253      *
254      * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
255      *                           name of the user that owns the target Java
256      *                           virtual machine.
257      * @param   lvmid            an integer that uniquely identifies the
258      *                           target local Java virtual machine.
259      * @param   mode             a string indicating the attach mode.
260      * @return  ByteBuffer       a direct allocated byte buffer
261      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
262      * @throws  IOException      An I/O error occurred while trying to acquire
263      *                           the instrumentation buffer.
264      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
265      *                           into the virtual machine&#39;s address space.
266      */
267     private ByteBuffer attachImpl(String user, int lvmid, int mode)
268             throws IllegalArgumentException, IOException
269     {
270         final ByteBuffer b = attach(user, lvmid, mode);
271 
272         if (lvmid == 0) {
273             // The native instrumentation buffer for this Java virtual
274             // machine is never unmapped.
275             return b;
276         }
277         else {
278             // This is an instrumentation buffer for another Java virtual
279             // machine with native resources that need to be managed. We
280             // create a duplicate of the native ByteBuffer and manage it
281             // with a Cleaner. When the duplicate becomes phantom reachable,
282             // the native resources will be released.
283 
284             final ByteBuffer dup = b.duplicate();
285 
286             CleanerFactory.cleaner()
287                           .register(dup, new CleanerAction(instance, b));
288             return dup;
289         }
290     }
291 
292     private static class CleanerAction implements Runnable {
293         private final ByteBuffer bb;
294         private final Perf perf;
295         CleanerAction(Perf perf, ByteBuffer bb) {
296             this.perf = perf;
297             this.bb = bb;
298         }
299         public void run() {
300             try {
301                 perf.detach(bb);
302             } catch (Throwable th) {
303                 // avoid crashing the reference handler thread,
304                 // but provide for some diagnosability
305                 assert false : th.toString();
306             }
307         }
308     }
309 
310     /**
311      * Native method to perform the implementation specific attach mechanism.
312      * &lt;p&gt;
313      * The implementation of this method may return distinct or identical
314      * &lt;code&gt;ByteBuffer&lt;/code&gt; objects for two distinct calls requesting
315      * attachment to the same Java virtual machine.
316      * &lt;p&gt;
317      * For the Sun HotSpot JVM, two distinct calls to attach to the same
318      * target Java virtual machine will result in two distinct ByteBuffer
319      * objects returned by this method. This may change in a future release.
320      *
321      * @param   user             A &lt;code&gt;String&lt;/code&gt; object containing the
322      *                           name of the user that owns the target Java
323      *                           virtual machine.
324      * @param   lvmid            an integer that uniquely identifies the
325      *                           target local Java virtual machine.
326      * @param   mode             a string indicating the attach mode.
327      * @return  ByteBuffer       a direct allocated byte buffer
328      * @throws  IllegalArgumentException  The lvmid or mode was invalid.
329      * @throws  IOException      An I/O error occurred while trying to acquire
330      *                           the instrumentation buffer.
331      * @throws  OutOfMemoryError The instrumentation buffer could not be mapped
332      *                           into the virtual machine&#39;s address space.
333      */
334     private native ByteBuffer attach(String user, int lvmid, int mode)
335                    throws IllegalArgumentException, IOException;
336 
337     /**
338      * Native method to perform the implementation specific detach mechanism.
339      * &lt;p&gt;
340      * If this method is passed a &lt;code&gt;ByteBuffer&lt;/code&gt; object that is
341      * not created by the &lt;code&gt;attach&lt;/code&gt; method, then the results of
342      * this method are undefined, with unpredictable and potentially damaging
343      * effects to the Java virtual machine. To prevent accidental or malicious
344      * use of this method, all native ByteBuffer created by the &lt;code&gt;
345      * attach&lt;/code&gt; method are managed internally as PhantomReferences
346      * and resources are freed by the system.
347      * &lt;p&gt;
348      * If this method is passed a &lt;code&gt;ByteBuffer&lt;/code&gt; object created
349      * by the &lt;code&gt;attach&lt;/code&gt; method with a lvmid for the Java virtual
350      * machine running this method (lvmid=0, for example), then the detach
351      * request is silently ignored.
352      *
353      * @param bb  A direct allocated byte buffer created by the
354      *                    &lt;code&gt;attach&lt;/code&gt; method.
355      * @see   java.nio.ByteBuffer
356      * @see   #attach
357      */
358     private native void detach(ByteBuffer bb);
359 
360     /**
361      * Create a &lt;code&gt;long&lt;/code&gt; scalar entry in the instrumentation buffer
362      * with the given variability characteristic, units, and initial value.
363      * &lt;p&gt;
364      * Access to the instrument is provided through the returned &lt;code&gt;
365      * ByteBuffer&lt;/code&gt; object. Typically, this object should be wrapped
366      * with &lt;code&gt;LongBuffer&lt;/code&gt; view object.
367      *
368      * @param   variability the variability characteristic for this entry.
369      * @param   units       the units for this entry.
370      * @param   name        the name of this entry.
371      * @param   value       the initial value for this entry.
372      * @return  ByteBuffer  a direct allocated ByteBuffer object that
373      *                      allows write access to a native memory location
374      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
375      *
376      * see sun.misc.perf.Variability
377      * see sun.misc.perf.Units
378      * @see java.nio.ByteBuffer
379      */
380     public native ByteBuffer createLong(String name, int variability,
381                                         int units, long value);
382 
383     /**
384      * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
385      * the given variability characteristic, units, and initial value.
386      * &lt;p&gt;
387      * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
388      * instrument is given in by &lt;code&gt;maxLength&lt;/code&gt; parameter. Updates
389      * to this instrument with &lt;code&gt;String&lt;/code&gt; values with lengths greater
390      * than &lt;code&gt;maxLength&lt;/code&gt; will be truncated to &lt;code&gt;maxLength&lt;/code&gt;.
391      * The truncated value will be terminated by a null character.
392      * &lt;p&gt;
393      * The underlying implementation may further limit the length of the
394      * value, but will continue to preserve the null terminator.
395      * &lt;p&gt;
396      * Access to the instrument is provided through the returned &lt;code&gt;
397      * ByteBuffer&lt;/code&gt; object.
398      *
399      * @param   variability the variability characteristic for this entry.
400      * @param   units       the units for this entry.
401      * @param   name        the name of this entry.
402      * @param   value       the initial value for this entry.
403      * @param   maxLength   the maximum string length for this string
404      *                      instrument.
405      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
406      *                      write access to a native memory location
407      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
408      *
409      * see sun.misc.perf.Variability
410      * see sun.misc.perf.Units
411      * @see java.nio.ByteBuffer
412      */
413     public ByteBuffer createString(String name, int variability,
414                                    int units, String value, int maxLength)
415     {
416         byte[] v = getBytes(value);
417         byte[] v1 = new byte[v.length+1];
418         System.arraycopy(v, 0, v1, 0, v.length);
419         v1[v.length] = &#39;\0&#39;;
420         return createByteArray(name, variability, units, v1, Math.max(v1.length, maxLength));
421     }
422 
423     /**
424      * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
425      * the given variability characteristic, units, and initial value.
426      * &lt;p&gt;
427      * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
428      * instrument is implied by the length of the &lt;code&gt;value&lt;/code&gt; parameter.
429      * Subsequent updates to the value of this instrument will be truncated
430      * to this implied maximum length. The truncated value will be terminated
431      * by a null character.
432      * &lt;p&gt;
433      * The underlying implementation may further limit the length of the
434      * initial or subsequent value, but will continue to preserve the null
435      * terminator.
436      * &lt;p&gt;
437      * Access to the instrument is provided through the returned &lt;code&gt;
438      * ByteBuffer&lt;/code&gt; object.
439      *
440      * @param   variability the variability characteristic for this entry.
441      * @param   units       the units for this entry.
442      * @param   name        the name of this entry.
443      * @param   value       the initial value for this entry.
444      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
445      *                      write access to a native memory location
446      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
447      *
448      * see sun.misc.perf.Variability
449      * see sun.misc.perf.Units
450      * @see java.nio.ByteBuffer
451      */
452     public ByteBuffer createString(String name, int variability,
453                                    int units, String value)
454     {
455         byte[] v = getBytes(value);
456         byte[] v1 = new byte[v.length+1];
457         System.arraycopy(v, 0, v1, 0, v.length);
458         v1[v.length] = &#39;\0&#39;;
459         return createByteArray(name, variability, units, v1, v1.length);
460     }
461 
462     /**
463      * Create a &lt;code&gt;byte&lt;/code&gt; vector entry in the instrumentation buffer
464      * with the given variability characteristic, units, and initial value.
465      * &lt;p&gt;
466      * The &lt;code&gt;maxLength&lt;/code&gt; parameter limits the size of the byte
467      * array instrument such that the initial or subsequent updates beyond
468      * this length are silently ignored. No special handling of truncated
469      * updates is provided.
470      * &lt;p&gt;
471      * The underlying implementation may further limit the length of the
472      * length of the initial or subsequent value.
473      * &lt;p&gt;
474      * Access to the instrument is provided through the returned &lt;code&gt;
475      * ByteBuffer&lt;/code&gt; object.
476      *
477      * @param   variability the variability characteristic for this entry.
478      * @param   units       the units for this entry.
479      * @param   name        the name of this entry.
480      * @param   value       the initial value for this entry.
481      * @param   maxLength   the maximum length of this byte array.
482      * @return  ByteBuffer  a direct allocated byte buffer that allows
483      *                      write access to a native memory location
484      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
485      *
486      * see sun.misc.perf.Variability
487      * see sun.misc.perf.Units
488      * @see java.nio.ByteBuffer
489      */
490     public native ByteBuffer createByteArray(String name, int variability,
491                                              int units, byte[] value,
492                                              int maxLength);
493 
494 
495     /**
496      * convert string to an array of UTF-8 bytes
497      */
498     private static byte[] getBytes(String s)
499     {
500         byte[] bytes = null;
501 
502         try {
503             bytes = s.getBytes(&quot;UTF-8&quot;);
504         }
505         catch (UnsupportedEncodingException e) {
506             // ignore, UTF-8 encoding is always known
507         }
508 
509         return bytes;
510     }
511 
512     /**
513      * Return the value of the High Resolution Counter.
514      *
515      * The High Resolution Counter returns the number of ticks since
516      * since the start of the Java virtual machine. The resolution of
517      * the counter is machine dependent and can be determined from the
518      * value return by the {@link #highResFrequency} method.
519      *
520      * @return  the number of ticks of machine dependent resolution since
521      *          the start of the Java virtual machine.
522      *
523      * @see #highResFrequency
524      * @see java.lang.System#currentTimeMillis()
525      */
526     public native long highResCounter();
527 
528     /**
529      * Returns the frequency of the High Resolution Counter, in ticks per
530      * second.
531      *
532      * This value can be used to convert the value of the High Resolution
533      * Counter, as returned from a call to the {@link #highResCounter} method,
534      * into the number of seconds since the start of the Java virtual machine.
535      *
536      * @return  the frequency of the High Resolution Counter.
537      * @see #highResCounter
538      */
539     public native long highResFrequency();
540 
541     private static native void registerNatives();
542 
543     static {
544         registerNatives();
545         instance = new Perf();
546     }
547 }
    </pre>
  </body>
</html>
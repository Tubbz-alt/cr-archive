<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Reflection.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../util/ArraysSupport.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,10 ***</span>
<span class="line-new-header">--- 41,12 ---</span>
  import java.lang.reflect.Modifier;
  import java.security.PrivilegedAction;
  import java.util.Objects;
  import java.util.Properties;
  
<span class="line-added">+ import jdk.internal.access.JavaLangReflectAccess;</span>
<span class="line-added">+ import jdk.internal.access.SharedSecrets;</span>
  import jdk.internal.misc.VM;
  import sun.reflect.misc.ReflectUtil;
  import sun.security.action.GetPropertyAction;
  import sun.security.util.SecurityConstants;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,12 ***</span>
  
  public class ReflectionFactory {
  
      private static boolean initted = false;
      private static final ReflectionFactory soleInstance = new ReflectionFactory();
<span class="line-modified">!     // Provides access to package-private mechanisms in java.lang.reflect</span>
<span class="line-removed">-     private static volatile LangReflectAccess langReflectAccess;</span>
  
      /* Method for static class initializer &lt;clinit&gt;, or null */
      private static volatile Method hasStaticInitializerMethod;
  
      //
<span class="line-new-header">--- 64,11 ---</span>
  
  public class ReflectionFactory {
  
      private static boolean initted = false;
      private static final ReflectionFactory soleInstance = new ReflectionFactory();
<span class="line-modified">! </span>
  
      /* Method for static class initializer &lt;clinit&gt;, or null */
      private static volatile Method hasStaticInitializerMethod;
  
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,11 ***</span>
<span class="line-new-header">--- 89,13 ---</span>
      private static int     inflationThreshold = 15;
  
      // true if deserialization constructor checking is disabled
      private static boolean disableSerialConstructorChecks = false;
  
<span class="line-added">+     private final JavaLangReflectAccess langReflectAccess;</span>
      private ReflectionFactory() {
<span class="line-added">+         this.langReflectAccess = SharedSecrets.getJavaLangReflectAccess();</span>
      }
  
      /**
       * A convenience class for acquiring the capability to instantiate
       * reflective objects.  Use this instead of a raw call to {@link
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,26 ***</span>
      //
      // Routines used by java.lang.reflect
      //
      //
  
<span class="line-modified">!     /** Called only by java.lang.reflect.Modifier&#39;s static initializer */</span>
<span class="line-removed">-     public void setLangReflectAccess(LangReflectAccess access) {</span>
<span class="line-removed">-         langReflectAccess = access;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
       * Note: this routine can cause the declaring class for the field
       * be initialized and therefore must not be called until the
       * first get/set of this field.
       * @param field the field
       * @param override true if caller has overridden accessibility
       */
      public FieldAccessor newFieldAccessor(Field field, boolean override) {
          checkInitted();
  
<span class="line-modified">!         Field root = langReflectAccess().getRoot(field);</span>
          if (root != null) {
              // FieldAccessor will use the root unless the modifiers have
              // been overrridden
              if (root.getModifiers() == field.getModifiers() || !override) {
                  field = root;
<span class="line-new-header">--- 161,21 ---</span>
      //
      // Routines used by java.lang.reflect
      //
      //
  
<span class="line-modified">!     /*</span>
       * Note: this routine can cause the declaring class for the field
       * be initialized and therefore must not be called until the
       * first get/set of this field.
       * @param field the field
       * @param override true if caller has overridden accessibility
       */
      public FieldAccessor newFieldAccessor(Field field, boolean override) {
          checkInitted();
  
<span class="line-modified">!         Field root = langReflectAccess.getRoot(field);</span>
          if (root != null) {
              // FieldAccessor will use the root unless the modifiers have
              // been overrridden
              if (root.getModifiers() == field.getModifiers() || !override) {
                  field = root;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,11 ***</span>
                  method = altMethod;
              }
          }
  
          // use the root Method that will not cache caller class
<span class="line-modified">!         Method root = langReflectAccess().getRoot(method);</span>
          if (root != null) {
              method = root;
          }
  
          if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
<span class="line-new-header">--- 193,11 ---</span>
                  method = altMethod;
              }
          }
  
          // use the root Method that will not cache caller class
<span class="line-modified">!         Method root = langReflectAccess.getRoot(method);</span>
          if (root != null) {
              method = root;
          }
  
          if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,11 ***</span>
              return new InstantiationExceptionConstructorAccessorImpl
                  (&quot;Can not instantiate java.lang.Class&quot;);
          }
  
          // use the root Constructor that will not cache caller class
<span class="line-modified">!         Constructor&lt;?&gt; root = langReflectAccess().getRoot(c);</span>
          if (root != null) {
              c = root;
          }
  
          // Bootstrapping issue: since we use Class.newInstance() in
<span class="line-new-header">--- 229,11 ---</span>
              return new InstantiationExceptionConstructorAccessorImpl
                  (&quot;Can not instantiate java.lang.Class&quot;);
          }
  
          // use the root Constructor that will not cache caller class
<span class="line-modified">!         Constructor&lt;?&gt; root = langReflectAccess.getRoot(c);</span>
          if (root != null) {
              c = root;
          }
  
          // Bootstrapping issue: since we use Class.newInstance() in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,56 ***</span>
      //
      // Routines used by java.lang
      //
      //
  
<span class="line-removed">-     /** Creates a new java.lang.reflect.Field. Access checks as per</span>
<span class="line-removed">-         java.lang.reflect.AccessibleObject are not overridden. */</span>
<span class="line-removed">-     public Field newField(Class&lt;?&gt; declaringClass,</span>
<span class="line-removed">-                           String name,</span>
<span class="line-removed">-                           Class&lt;?&gt; type,</span>
<span class="line-removed">-                           int modifiers,</span>
<span class="line-removed">-                           int slot,</span>
<span class="line-removed">-                           String signature,</span>
<span class="line-removed">-                           byte[] annotations)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return langReflectAccess().newField(declaringClass,</span>
<span class="line-removed">-                                             name,</span>
<span class="line-removed">-                                             type,</span>
<span class="line-removed">-                                             modifiers,</span>
<span class="line-removed">-                                             slot,</span>
<span class="line-removed">-                                             signature,</span>
<span class="line-removed">-                                             annotations);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Creates a new java.lang.reflect.Method. Access checks as per</span>
<span class="line-removed">-         java.lang.reflect.AccessibleObject are not overridden. */</span>
<span class="line-removed">-     public Method newMethod(Class&lt;?&gt; declaringClass,</span>
<span class="line-removed">-                             String name,</span>
<span class="line-removed">-                             Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-removed">-                             Class&lt;?&gt; returnType,</span>
<span class="line-removed">-                             Class&lt;?&gt;[] checkedExceptions,</span>
<span class="line-removed">-                             int modifiers,</span>
<span class="line-removed">-                             int slot,</span>
<span class="line-removed">-                             String signature,</span>
<span class="line-removed">-                             byte[] annotations,</span>
<span class="line-removed">-                             byte[] parameterAnnotations,</span>
<span class="line-removed">-                             byte[] annotationDefault)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return langReflectAccess().newMethod(declaringClass,</span>
<span class="line-removed">-                                              name,</span>
<span class="line-removed">-                                              parameterTypes,</span>
<span class="line-removed">-                                              returnType,</span>
<span class="line-removed">-                                              checkedExceptions,</span>
<span class="line-removed">-                                              modifiers,</span>
<span class="line-removed">-                                              slot,</span>
<span class="line-removed">-                                              signature,</span>
<span class="line-removed">-                                              annotations,</span>
<span class="line-removed">-                                              parameterAnnotations,</span>
<span class="line-removed">-                                              annotationDefault);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /** Creates a new java.lang.reflect.Constructor. Access checks as
          per java.lang.reflect.AccessibleObject are not overridden. */
      public Constructor&lt;?&gt; newConstructor(Class&lt;?&gt; declaringClass,
                                           Class&lt;?&gt;[] parameterTypes,
                                           Class&lt;?&gt;[] checkedExceptions,
<span class="line-new-header">--- 264,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,87 ***</span>
                                           int slot,
                                           String signature,
                                           byte[] annotations,
                                           byte[] parameterAnnotations)
      {
<span class="line-modified">!         return langReflectAccess().newConstructor(declaringClass,</span>
<span class="line-modified">!                                                   parameterTypes,</span>
<span class="line-modified">!                                                   checkedExceptions,</span>
<span class="line-modified">!                                                   modifiers,</span>
<span class="line-modified">!                                                   slot,</span>
<span class="line-modified">!                                                   signature,</span>
<span class="line-modified">!                                                   annotations,</span>
<span class="line-modified">!                                                   parameterAnnotations);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Gets the MethodAccessor object for a java.lang.reflect.Method */</span>
<span class="line-removed">-     public MethodAccessor getMethodAccessor(Method m) {</span>
<span class="line-removed">-         return langReflectAccess().getMethodAccessor(m);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Sets the MethodAccessor object for a java.lang.reflect.Method */</span>
<span class="line-removed">-     public void setMethodAccessor(Method m, MethodAccessor accessor) {</span>
<span class="line-removed">-         langReflectAccess().setMethodAccessor(m, accessor);</span>
      }
  
      /** Gets the ConstructorAccessor object for a
          java.lang.reflect.Constructor */
      public ConstructorAccessor getConstructorAccessor(Constructor&lt;?&gt; c) {
<span class="line-modified">!         return langReflectAccess().getConstructorAccessor(c);</span>
      }
  
      /** Sets the ConstructorAccessor object for a
          java.lang.reflect.Constructor */
      public void setConstructorAccessor(Constructor&lt;?&gt; c,
                                         ConstructorAccessor accessor)
      {
<span class="line-modified">!         langReflectAccess().setConstructorAccessor(c, accessor);</span>
      }
  
      /** Makes a copy of the passed method. The returned method is a
          &quot;child&quot; of the passed one; see the comments in Method.java for
          details. */
      public Method copyMethod(Method arg) {
<span class="line-modified">!         return langReflectAccess().copyMethod(arg);</span>
      }
  
      /** Makes a copy of the passed method. The returned method is NOT
       * a &quot;child&quot; but a &quot;sibling&quot; of the Method in arg. Should only be
       * used on non-root methods. */
      public Method leafCopyMethod(Method arg) {
<span class="line-modified">!         return langReflectAccess().leafCopyMethod(arg);</span>
      }
  
  
      /** Makes a copy of the passed field. The returned field is a
          &quot;child&quot; of the passed one; see the comments in Field.java for
          details. */
      public Field copyField(Field arg) {
<span class="line-modified">!         return langReflectAccess().copyField(arg);</span>
      }
  
      /** Makes a copy of the passed constructor. The returned
          constructor is a &quot;child&quot; of the passed one; see the comments
          in Constructor.java for details. */
      public &lt;T&gt; Constructor&lt;T&gt; copyConstructor(Constructor&lt;T&gt; arg) {
<span class="line-modified">!         return langReflectAccess().copyConstructor(arg);</span>
      }
  
      /** Gets the byte[] that encodes TypeAnnotations on an executable.
       */
      public byte[] getExecutableTypeAnnotationBytes(Executable ex) {
<span class="line-modified">!         return langReflectAccess().getExecutableTypeAnnotationBytes(ex);</span>
      }
  
      public Class&lt;?&gt;[] getExecutableSharedParameterTypes(Executable ex) {
<span class="line-modified">!         return langReflectAccess().getExecutableSharedParameterTypes(ex);</span>
      }
  
      public &lt;T&gt; T newInstance(Constructor&lt;T&gt; ctor, Object[] args, Class&lt;?&gt; caller)
          throws IllegalAccessException, InstantiationException, InvocationTargetException
      {
<span class="line-modified">!         return langReflectAccess().newInstance(ctor, args, caller);</span>
      }
  
      //--------------------------------------------------------------------------
      //
      // Routines used by serialization
<span class="line-new-header">--- 275,77 ---</span>
                                           int slot,
                                           String signature,
                                           byte[] annotations,
                                           byte[] parameterAnnotations)
      {
<span class="line-modified">!         return langReflectAccess.newConstructor(declaringClass,</span>
<span class="line-modified">!                                                 parameterTypes,</span>
<span class="line-modified">!                                                 checkedExceptions,</span>
<span class="line-modified">!                                                 modifiers,</span>
<span class="line-modified">!                                                 slot,</span>
<span class="line-modified">!                                                 signature,</span>
<span class="line-modified">!                                                 annotations,</span>
<span class="line-modified">!                                                 parameterAnnotations);</span>
      }
  
      /** Gets the ConstructorAccessor object for a
          java.lang.reflect.Constructor */
      public ConstructorAccessor getConstructorAccessor(Constructor&lt;?&gt; c) {
<span class="line-modified">!         return langReflectAccess.getConstructorAccessor(c);</span>
      }
  
      /** Sets the ConstructorAccessor object for a
          java.lang.reflect.Constructor */
      public void setConstructorAccessor(Constructor&lt;?&gt; c,
                                         ConstructorAccessor accessor)
      {
<span class="line-modified">!         langReflectAccess.setConstructorAccessor(c, accessor);</span>
      }
  
      /** Makes a copy of the passed method. The returned method is a
          &quot;child&quot; of the passed one; see the comments in Method.java for
          details. */
      public Method copyMethod(Method arg) {
<span class="line-modified">!         return langReflectAccess.copyMethod(arg);</span>
      }
  
      /** Makes a copy of the passed method. The returned method is NOT
       * a &quot;child&quot; but a &quot;sibling&quot; of the Method in arg. Should only be
       * used on non-root methods. */
      public Method leafCopyMethod(Method arg) {
<span class="line-modified">!         return langReflectAccess.leafCopyMethod(arg);</span>
      }
  
  
      /** Makes a copy of the passed field. The returned field is a
          &quot;child&quot; of the passed one; see the comments in Field.java for
          details. */
      public Field copyField(Field arg) {
<span class="line-modified">!         return langReflectAccess.copyField(arg);</span>
      }
  
      /** Makes a copy of the passed constructor. The returned
          constructor is a &quot;child&quot; of the passed one; see the comments
          in Constructor.java for details. */
      public &lt;T&gt; Constructor&lt;T&gt; copyConstructor(Constructor&lt;T&gt; arg) {
<span class="line-modified">!         return langReflectAccess.copyConstructor(arg);</span>
      }
  
      /** Gets the byte[] that encodes TypeAnnotations on an executable.
       */
      public byte[] getExecutableTypeAnnotationBytes(Executable ex) {
<span class="line-modified">!         return langReflectAccess.getExecutableTypeAnnotationBytes(ex);</span>
      }
  
      public Class&lt;?&gt;[] getExecutableSharedParameterTypes(Executable ex) {
<span class="line-modified">!         return langReflectAccess.getExecutableSharedParameterTypes(ex);</span>
      }
  
      public &lt;T&gt; T newInstance(Constructor&lt;T&gt; ctor, Object[] args, Class&lt;?&gt; caller)
          throws IllegalAccessException, InstantiationException, InvocationTargetException
      {
<span class="line-modified">!         return langReflectAccess.newInstance(ctor, args, caller);</span>
      }
  
      //--------------------------------------------------------------------------
      //
      // Routines used by serialization
</pre>
<hr />
<pre>
<span class="line-old-header">*** 524,17 ***</span>
                                               constructorToCall.getDeclaringClass());
          Constructor&lt;?&gt; c = newConstructor(constructorToCall.getDeclaringClass(),
                                            constructorToCall.getParameterTypes(),
                                            constructorToCall.getExceptionTypes(),
                                            constructorToCall.getModifiers(),
<span class="line-modified">!                                           langReflectAccess().</span>
                                            getConstructorSlot(constructorToCall),
<span class="line-modified">!                                           langReflectAccess().</span>
                                            getConstructorSignature(constructorToCall),
<span class="line-modified">!                                           langReflectAccess().</span>
                                            getConstructorAnnotations(constructorToCall),
<span class="line-modified">!                                           langReflectAccess().</span>
                                            getConstructorParameterAnnotations(constructorToCall));
          setConstructorAccessor(c, acc);
          c.setAccessible(true);
          return c;
      }
<span class="line-new-header">--- 466,17 ---</span>
                                               constructorToCall.getDeclaringClass());
          Constructor&lt;?&gt; c = newConstructor(constructorToCall.getDeclaringClass(),
                                            constructorToCall.getParameterTypes(),
                                            constructorToCall.getExceptionTypes(),
                                            constructorToCall.getModifiers(),
<span class="line-modified">!                                           langReflectAccess.</span>
                                            getConstructorSlot(constructorToCall),
<span class="line-modified">!                                           langReflectAccess.</span>
                                            getConstructorSignature(constructorToCall),
<span class="line-modified">!                                           langReflectAccess.</span>
                                            getConstructorAnnotations(constructorToCall),
<span class="line-modified">!                                           langReflectAccess.</span>
                                            getConstructorParameterAnnotations(constructorToCall));
          setConstructorAccessor(c, acc);
          c.setAccessible(true);
          return c;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 723,21 ***</span>
              &quot;true&quot;.equals(props.getProperty(&quot;jdk.disableSerialConstructorChecks&quot;));
  
          initted = true;
      }
  
<span class="line-removed">-     private static LangReflectAccess langReflectAccess() {</span>
<span class="line-removed">-         if (langReflectAccess == null) {</span>
<span class="line-removed">-             // Call a static method to get class java.lang.reflect.Modifier</span>
<span class="line-removed">-             // initialized. Its static initializer will cause</span>
<span class="line-removed">-             // setLangReflectAccess() to be called from the context of the</span>
<span class="line-removed">-             // java.lang.reflect package.</span>
<span class="line-removed">-             Modifier.isPublic(Modifier.PUBLIC);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return langReflectAccess;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Returns true if classes are defined in the classloader and same package, false
       * otherwise.
       * @param cl1 a class
       * @param cl2 another class
<span class="line-new-header">--- 665,10 ---</span>
</pre>
<center><a href="Reflection.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../util/ArraysSupport.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
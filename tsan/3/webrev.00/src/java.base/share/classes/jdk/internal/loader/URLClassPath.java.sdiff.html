<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/loader/URLClassPath.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Resource.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../math/FDBigInteger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/loader/URLClassPath.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  86 public class URLClassPath {
  87     private static final String USER_AGENT_JAVA_VERSION = &quot;UA-Java-Version&quot;;
  88     private static final String JAVA_VERSION;
  89     private static final boolean DEBUG;
  90     private static final boolean DISABLE_JAR_CHECKING;
  91     private static final boolean DISABLE_ACC_CHECKING;
  92     private static final boolean DISABLE_CP_URL_CHECK;
  93     private static final boolean DEBUG_CP_URL_CHECK;
  94 
  95     static {
  96         Properties props = GetPropertyAction.privilegedGetProperties();
  97         JAVA_VERSION = props.getProperty(&quot;java.version&quot;);
  98         DEBUG = (props.getProperty(&quot;sun.misc.URLClassPath.debug&quot;) != null);
  99         String p = props.getProperty(&quot;sun.misc.URLClassPath.disableJarChecking&quot;);
 100         DISABLE_JAR_CHECKING = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;
 101 
 102         p = props.getProperty(&quot;jdk.net.URLClassPath.disableRestrictedPermissions&quot;);
 103         DISABLE_ACC_CHECKING = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;
 104 
 105         // This property will be removed in a later release
<span class="line-modified"> 106         p = props.getProperty(&quot;jdk.net.URLClassPath.disableClassPathURLCheck&quot;, &quot;true&quot;);</span>
<span class="line-removed"> 107 </span>
 108         DISABLE_CP_URL_CHECK = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;
<span class="line-modified"> 109         DEBUG_CP_URL_CHECK = &quot;debug&quot;.equals(p);</span>




 110     }
 111 
 112     /* The original search path of URLs. */
 113     private final ArrayList&lt;URL&gt; path;
 114 
 115     /* The deque of unopened URLs */
 116     private final ArrayDeque&lt;URL&gt; unopenedUrls;
 117 
 118     /* The resulting search path of Loaders */
 119     private final ArrayList&lt;Loader&gt; loaders = new ArrayList&lt;&gt;();
 120 
 121     /* Map of each URL opened to its corresponding Loader */
 122     private final HashMap&lt;String, Loader&gt; lmap = new HashMap&lt;&gt;();
 123 
 124     /* The jar protocol handler to use when creating new URLs */
 125     private final URLStreamHandler jarHandler;
 126 
 127     /* Whether this URLClassLoader has been closed yet */
 128     private boolean closed = false;
 129 
</pre>
<hr />
<pre>
 679          * Method overridden in sub-classes.
 680          */
 681         @Override
 682         public void close() throws IOException {
 683             if (jarfile != null) {
 684                 jarfile.close();
 685             }
 686         }
 687 
 688         /*
 689          * Returns the local class path for this loader, or null if none.
 690          */
 691         URL[] getClassPath() throws IOException {
 692             return null;
 693         }
 694     }
 695 
 696     /*
 697      * Nested class used to represent a Loader of resources from a JAR URL.
 698      */
<span class="line-modified"> 699     static class JarLoader extends Loader {</span>
 700         private JarFile jar;
 701         private final URL csu;
 702         private JarIndex index;
 703         private URLStreamHandler handler;
 704         private final HashMap&lt;String, Loader&gt; lmap;
 705         private final AccessControlContext acc;
 706         private boolean closed = false;
 707         private static final JavaUtilZipFileAccess zipAccess =
 708                 SharedSecrets.getJavaUtilZipFileAccess();
 709 
 710         /*
 711          * Creates a new JarLoader for the specified URL referring to
 712          * a JAR file.
 713          */
<span class="line-modified"> 714         JarLoader(URL url, URLStreamHandler jarHandler,</span>
<span class="line-modified"> 715                   HashMap&lt;String, Loader&gt; loaderMap,</span>
<span class="line-modified"> 716                   AccessControlContext acc)</span>
 717             throws IOException
 718         {
 719             super(new URL(&quot;jar&quot;, &quot;&quot;, -1, url + &quot;!/&quot;, jarHandler));
 720             csu = url;
 721             handler = jarHandler;
 722             lmap = loaderMap;
 723             this.acc = acc;
 724 
 725             ensureOpen();
 726         }
 727 
 728         @Override
 729         public void close () throws IOException {
 730             // closing is synchronized at higher level
 731             if (!closed) {
 732                 closed = true;
 733                 // in case not already open.
 734                 ensureOpen();
 735                 jar.close();
 736             }
</pre>
<hr />
<pre>
1105             }
1106             if (i == 0) {
1107                 urls = null;
1108             } else if (i != urls.length) {
1109                 // Truncate nulls from end of array
1110                 urls = Arrays.copyOf(urls, i);
1111             }
1112             return urls;
1113         }
1114 
1115         static URL tryResolve(URL base, String input) throws MalformedURLException {
1116             if (&quot;file&quot;.equalsIgnoreCase(base.getProtocol())) {
1117                 return tryResolveFile(base, input);
1118             } else {
1119                 return tryResolveNonFile(base, input);
1120             }
1121         }
1122 
1123         /**
1124          * Attempt to return a file URL by resolving input against a base file
<span class="line-modified">1125          * URL. The input is an absolute or relative file URL that encodes a</span>
<span class="line-removed">1126          * file path.</span>
<span class="line-removed">1127          *</span>
<span class="line-removed">1128          * @apiNote Nonsensical input such as a Windows file path with a drive</span>
<span class="line-removed">1129          * letter cannot be disambiguated from an absolute URL so will be rejected</span>
<span class="line-removed">1130          * (by returning null) by this method.</span>
<span class="line-removed">1131          *</span>
1132          * @return the resolved URL or null if the input is an absolute URL with
1133          *         a scheme other than file (ignoring case)
1134          * @throws MalformedURLException
1135          */
1136         static URL tryResolveFile(URL base, String input) throws MalformedURLException {
<span class="line-modified">1137             int index = input.indexOf(&#39;:&#39;);</span>
<span class="line-modified">1138             boolean isFile;</span>
<span class="line-modified">1139             if (index &gt;= 0) {</span>
<span class="line-modified">1140                 String scheme = input.substring(0, index);</span>
<span class="line-modified">1141                 isFile = &quot;file&quot;.equalsIgnoreCase(scheme);</span>
<span class="line-modified">1142             } else {</span>
<span class="line-modified">1143                 isFile = true;</span>
1144             }
<span class="line-modified">1145             return (isFile) ? new URL(base, input) : null;</span>
1146         }
1147 
1148         /**
1149          * Attempt to return a URL by resolving input against a base URL. Returns
1150          * null if the resolved URL is not contained by the base URL.
1151          *
1152          * @return the resolved URL or null
1153          * @throws MalformedURLException
1154          */
1155         static URL tryResolveNonFile(URL base, String input) throws MalformedURLException {
1156             String child = input.replace(File.separatorChar, &#39;/&#39;);
1157             if (isRelative(child)) {
1158                 URL url = new URL(base, child);
1159                 String bp = base.getPath();
1160                 String urlp = url.getPath();
1161                 int pos = bp.lastIndexOf(&#39;/&#39;);
1162                 if (pos == -1) {
1163                     pos = bp.length() - 1;
1164                 }
1165                 if (urlp.regionMatches(0, bp, 0, pos + 1)
</pre>
<hr />
<pre>
1173         /**
1174          * Returns true if the given input is a relative URI.
1175          */
1176         static boolean isRelative(String child) {
1177             try {
1178                 return !URI.create(child).isAbsolute();
1179             } catch (IllegalArgumentException e) {
1180                 return false;
1181             }
1182         }
1183     }
1184 
1185     /*
1186      * Nested class used to represent a loader of classes and resources
1187      * from a file URL that refers to a directory.
1188      */
1189     private static class FileLoader extends Loader {
1190         /* Canonicalized File */
1191         private File dir;
1192 
<span class="line-modified">1193         FileLoader(URL url) throws IOException {</span>



1194             super(url);
<span class="line-removed">1195             if (!&quot;file&quot;.equals(url.getProtocol())) {</span>
<span class="line-removed">1196                 throw new IllegalArgumentException(&quot;url&quot;);</span>
<span class="line-removed">1197             }</span>
1198             String path = url.getFile().replace(&#39;/&#39;, File.separatorChar);
1199             path = ParseUtil.decode(path);
1200             dir = (new File(path)).getCanonicalFile();
1201         }
1202 
1203         /*
1204          * Returns the URL for a resource with the specified name
1205          */
1206         @Override
1207         URL findResource(final String name, boolean check) {
1208             Resource rsc = getResource(name, check);
1209             if (rsc != null) {
1210                 return rsc.getURL();
1211             }
1212             return null;
1213         }
1214 
1215         @Override
1216         Resource getResource(final String name, boolean check) {
1217             final URL url;
</pre>
</td>
<td>
<hr />
<pre>
  86 public class URLClassPath {
  87     private static final String USER_AGENT_JAVA_VERSION = &quot;UA-Java-Version&quot;;
  88     private static final String JAVA_VERSION;
  89     private static final boolean DEBUG;
  90     private static final boolean DISABLE_JAR_CHECKING;
  91     private static final boolean DISABLE_ACC_CHECKING;
  92     private static final boolean DISABLE_CP_URL_CHECK;
  93     private static final boolean DEBUG_CP_URL_CHECK;
  94 
  95     static {
  96         Properties props = GetPropertyAction.privilegedGetProperties();
  97         JAVA_VERSION = props.getProperty(&quot;java.version&quot;);
  98         DEBUG = (props.getProperty(&quot;sun.misc.URLClassPath.debug&quot;) != null);
  99         String p = props.getProperty(&quot;sun.misc.URLClassPath.disableJarChecking&quot;);
 100         DISABLE_JAR_CHECKING = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;
 101 
 102         p = props.getProperty(&quot;jdk.net.URLClassPath.disableRestrictedPermissions&quot;);
 103         DISABLE_ACC_CHECKING = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;
 104 
 105         // This property will be removed in a later release
<span class="line-modified"> 106         p = props.getProperty(&quot;jdk.net.URLClassPath.disableClassPathURLCheck&quot;);</span>

 107         DISABLE_CP_URL_CHECK = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;
<span class="line-modified"> 108 </span>
<span class="line-added"> 109         // Print a message for each Class-Path entry that is ignored (assuming</span>
<span class="line-added"> 110         // the check is not disabled).</span>
<span class="line-added"> 111         p = props.getProperty(&quot;jdk.net.URLClassPath.showIgnoredClassPathEntries&quot;);</span>
<span class="line-added"> 112         DEBUG_CP_URL_CHECK = p != null ? p.equals(&quot;true&quot;) || p.isEmpty() : false;</span>
 113     }
 114 
 115     /* The original search path of URLs. */
 116     private final ArrayList&lt;URL&gt; path;
 117 
 118     /* The deque of unopened URLs */
 119     private final ArrayDeque&lt;URL&gt; unopenedUrls;
 120 
 121     /* The resulting search path of Loaders */
 122     private final ArrayList&lt;Loader&gt; loaders = new ArrayList&lt;&gt;();
 123 
 124     /* Map of each URL opened to its corresponding Loader */
 125     private final HashMap&lt;String, Loader&gt; lmap = new HashMap&lt;&gt;();
 126 
 127     /* The jar protocol handler to use when creating new URLs */
 128     private final URLStreamHandler jarHandler;
 129 
 130     /* Whether this URLClassLoader has been closed yet */
 131     private boolean closed = false;
 132 
</pre>
<hr />
<pre>
 682          * Method overridden in sub-classes.
 683          */
 684         @Override
 685         public void close() throws IOException {
 686             if (jarfile != null) {
 687                 jarfile.close();
 688             }
 689         }
 690 
 691         /*
 692          * Returns the local class path for this loader, or null if none.
 693          */
 694         URL[] getClassPath() throws IOException {
 695             return null;
 696         }
 697     }
 698 
 699     /*
 700      * Nested class used to represent a Loader of resources from a JAR URL.
 701      */
<span class="line-modified"> 702     private static class JarLoader extends Loader {</span>
 703         private JarFile jar;
 704         private final URL csu;
 705         private JarIndex index;
 706         private URLStreamHandler handler;
 707         private final HashMap&lt;String, Loader&gt; lmap;
 708         private final AccessControlContext acc;
 709         private boolean closed = false;
 710         private static final JavaUtilZipFileAccess zipAccess =
 711                 SharedSecrets.getJavaUtilZipFileAccess();
 712 
 713         /*
 714          * Creates a new JarLoader for the specified URL referring to
 715          * a JAR file.
 716          */
<span class="line-modified"> 717         private JarLoader(URL url, URLStreamHandler jarHandler,</span>
<span class="line-modified"> 718                           HashMap&lt;String, Loader&gt; loaderMap,</span>
<span class="line-modified"> 719                           AccessControlContext acc)</span>
 720             throws IOException
 721         {
 722             super(new URL(&quot;jar&quot;, &quot;&quot;, -1, url + &quot;!/&quot;, jarHandler));
 723             csu = url;
 724             handler = jarHandler;
 725             lmap = loaderMap;
 726             this.acc = acc;
 727 
 728             ensureOpen();
 729         }
 730 
 731         @Override
 732         public void close () throws IOException {
 733             // closing is synchronized at higher level
 734             if (!closed) {
 735                 closed = true;
 736                 // in case not already open.
 737                 ensureOpen();
 738                 jar.close();
 739             }
</pre>
<hr />
<pre>
1108             }
1109             if (i == 0) {
1110                 urls = null;
1111             } else if (i != urls.length) {
1112                 // Truncate nulls from end of array
1113                 urls = Arrays.copyOf(urls, i);
1114             }
1115             return urls;
1116         }
1117 
1118         static URL tryResolve(URL base, String input) throws MalformedURLException {
1119             if (&quot;file&quot;.equalsIgnoreCase(base.getProtocol())) {
1120                 return tryResolveFile(base, input);
1121             } else {
1122                 return tryResolveNonFile(base, input);
1123             }
1124         }
1125 
1126         /**
1127          * Attempt to return a file URL by resolving input against a base file
<span class="line-modified">1128          * URL.</span>






1129          * @return the resolved URL or null if the input is an absolute URL with
1130          *         a scheme other than file (ignoring case)
1131          * @throws MalformedURLException
1132          */
1133         static URL tryResolveFile(URL base, String input) throws MalformedURLException {
<span class="line-modified">1134             URL retVal = new URL(base, input);</span>
<span class="line-modified">1135             if (input.indexOf(&#39;:&#39;) &gt;= 0 &amp;&amp;</span>
<span class="line-modified">1136                     !&quot;file&quot;.equalsIgnoreCase(retVal.getProtocol())) {</span>
<span class="line-modified">1137                 // &#39;input&#39; contains a &#39;:&#39;, which might be a scheme, or might be</span>
<span class="line-modified">1138                 // a Windows drive letter.  If the protocol for the resolved URL</span>
<span class="line-modified">1139                 // isn&#39;t &quot;file:&quot;, it should be ignored.</span>
<span class="line-modified">1140                 return null;</span>
1141             }
<span class="line-modified">1142             return retVal;</span>
1143         }
1144 
1145         /**
1146          * Attempt to return a URL by resolving input against a base URL. Returns
1147          * null if the resolved URL is not contained by the base URL.
1148          *
1149          * @return the resolved URL or null
1150          * @throws MalformedURLException
1151          */
1152         static URL tryResolveNonFile(URL base, String input) throws MalformedURLException {
1153             String child = input.replace(File.separatorChar, &#39;/&#39;);
1154             if (isRelative(child)) {
1155                 URL url = new URL(base, child);
1156                 String bp = base.getPath();
1157                 String urlp = url.getPath();
1158                 int pos = bp.lastIndexOf(&#39;/&#39;);
1159                 if (pos == -1) {
1160                     pos = bp.length() - 1;
1161                 }
1162                 if (urlp.regionMatches(0, bp, 0, pos + 1)
</pre>
<hr />
<pre>
1170         /**
1171          * Returns true if the given input is a relative URI.
1172          */
1173         static boolean isRelative(String child) {
1174             try {
1175                 return !URI.create(child).isAbsolute();
1176             } catch (IllegalArgumentException e) {
1177                 return false;
1178             }
1179         }
1180     }
1181 
1182     /*
1183      * Nested class used to represent a loader of classes and resources
1184      * from a file URL that refers to a directory.
1185      */
1186     private static class FileLoader extends Loader {
1187         /* Canonicalized File */
1188         private File dir;
1189 
<span class="line-modified">1190         /*</span>
<span class="line-added">1191          * Creates a new FileLoader for the specified URL with a file protocol.</span>
<span class="line-added">1192          */</span>
<span class="line-added">1193         private FileLoader(URL url) throws IOException {</span>
1194             super(url);



1195             String path = url.getFile().replace(&#39;/&#39;, File.separatorChar);
1196             path = ParseUtil.decode(path);
1197             dir = (new File(path)).getCanonicalFile();
1198         }
1199 
1200         /*
1201          * Returns the URL for a resource with the specified name
1202          */
1203         @Override
1204         URL findResource(final String name, boolean check) {
1205             Resource rsc = getResource(name, check);
1206             if (rsc != null) {
1207                 return rsc.getURL();
1208             }
1209             return null;
1210         }
1211 
1212         @Override
1213         Resource getResource(final String name, boolean check) {
1214             final URL url;
</pre>
</td>
</tr>
</table>
<center><a href="Resource.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../math/FDBigInteger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
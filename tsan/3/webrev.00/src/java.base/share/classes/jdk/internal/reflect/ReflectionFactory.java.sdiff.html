<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Reflection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../util/ArraysSupport.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 package jdk.internal.reflect;
 27 
 28 import java.io.Externalizable;
 29 import java.io.ObjectInputStream;
 30 import java.io.ObjectOutputStream;
 31 import java.io.ObjectStreamClass;
 32 import java.io.OptionalDataException;
 33 import java.io.Serializable;
 34 import java.lang.invoke.MethodHandle;
 35 import java.lang.invoke.MethodHandles;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Executable;
 38 import java.lang.reflect.InvocationTargetException;
 39 import java.lang.reflect.Method;
 40 import java.lang.reflect.Constructor;
 41 import java.lang.reflect.Modifier;
 42 import java.security.PrivilegedAction;
 43 import java.util.Objects;
 44 import java.util.Properties;
 45 


 46 import jdk.internal.misc.VM;
 47 import sun.reflect.misc.ReflectUtil;
 48 import sun.security.action.GetPropertyAction;
 49 import sun.security.util.SecurityConstants;
 50 
 51 /** &lt;P&gt; The master factory for all reflective objects, both those in
 52     java.lang.reflect (Fields, Methods, Constructors) as well as their
 53     delegates (FieldAccessors, MethodAccessors, ConstructorAccessors).
 54     &lt;/P&gt;
 55 
 56     &lt;P&gt; The methods in this class are extremely unsafe and can cause
 57     subversion of both the language and the verifier. For this reason,
 58     they are all instance methods, and access to the constructor of
 59     this factory is guarded by a security check, in similar style to
 60     {@link jdk.internal.misc.Unsafe}. &lt;/P&gt;
 61 */
 62 
 63 public class ReflectionFactory {
 64 
 65     private static boolean initted = false;
 66     private static final ReflectionFactory soleInstance = new ReflectionFactory();
<span class="line-modified"> 67     // Provides access to package-private mechanisms in java.lang.reflect</span>
<span class="line-removed"> 68     private static volatile LangReflectAccess langReflectAccess;</span>
 69 
 70     /* Method for static class initializer &lt;clinit&gt;, or null */
 71     private static volatile Method hasStaticInitializerMethod;
 72 
 73     //
 74     // &quot;Inflation&quot; mechanism. Loading bytecodes to implement
 75     // Method.invoke() and Constructor.newInstance() currently costs
 76     // 3-4x more than an invocation via native code for the first
 77     // invocation (though subsequent invocations have been benchmarked
 78     // to be over 20x faster). Unfortunately this cost increases
 79     // startup time for certain applications that use reflection
 80     // intensively (but only once per class) to bootstrap themselves.
 81     // To avoid this penalty we reuse the existing JVM entry points
 82     // for the first few invocations of Methods and Constructors and
 83     // then switch to the bytecode-based implementations.
 84     //
 85     // Package-private to be accessible to NativeMethodAccessorImpl
 86     // and NativeConstructorAccessorImpl
 87     private static boolean noInflation        = false;
 88     private static int     inflationThreshold = 15;
 89 
 90     // true if deserialization constructor checking is disabled
 91     private static boolean disableSerialConstructorChecks = false;
 92 

 93     private ReflectionFactory() {

 94     }
 95 
 96     /**
 97      * A convenience class for acquiring the capability to instantiate
 98      * reflective objects.  Use this instead of a raw call to {@link
 99      * #getReflectionFactory} in order to avoid being limited by the
100      * permissions of your callers.
101      *
102      * &lt;p&gt;An instance of this class can be used as the argument of
103      * &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;.
104      */
105     public static final class GetReflectionFactoryAction
106         implements PrivilegedAction&lt;ReflectionFactory&gt; {
107         public ReflectionFactory run() {
108             return getReflectionFactory();
109         }
110     }
111 
112     /**
113      * Provides the caller with the capability to instantiate reflective
</pre>
<hr />
<pre>
143      * A trusted method can define an alternate implementation for a method `foo`
144      * by defining a method named &quot;reflected$foo&quot; that will be invoked
145      * reflectively.
146      */
147     private static Method findMethodForReflection(Method method) {
148         String altName = &quot;reflected$&quot; + method.getName();
149         try {
150            return method.getDeclaringClass()
151                         .getDeclaredMethod(altName, method.getParameterTypes());
152         } catch (NoSuchMethodException ex) {
153             return null;
154         }
155     }
156 
157     //--------------------------------------------------------------------------
158     //
159     // Routines used by java.lang.reflect
160     //
161     //
162 
<span class="line-modified">163     /** Called only by java.lang.reflect.Modifier&#39;s static initializer */</span>
<span class="line-removed">164     public void setLangReflectAccess(LangReflectAccess access) {</span>
<span class="line-removed">165         langReflectAccess = access;</span>
<span class="line-removed">166     }</span>
<span class="line-removed">167 </span>
<span class="line-removed">168     /**</span>
169      * Note: this routine can cause the declaring class for the field
170      * be initialized and therefore must not be called until the
171      * first get/set of this field.
172      * @param field the field
173      * @param override true if caller has overridden accessibility
174      */
175     public FieldAccessor newFieldAccessor(Field field, boolean override) {
176         checkInitted();
177 
<span class="line-modified">178         Field root = langReflectAccess().getRoot(field);</span>
179         if (root != null) {
180             // FieldAccessor will use the root unless the modifiers have
181             // been overrridden
182             if (root.getModifiers() == field.getModifiers() || !override) {
183                 field = root;
184             }
185         }
186         return UnsafeFieldAccessorFactory.newFieldAccessor(field, override);
187     }
188 
189     public MethodAccessor newMethodAccessor(Method method) {
190         checkInitted();
191 
192         if (Reflection.isCallerSensitive(method)) {
193             Method altMethod = findMethodForReflection(method);
194             if (altMethod != null) {
195                 method = altMethod;
196             }
197         }
198 
199         // use the root Method that will not cache caller class
<span class="line-modified">200         Method root = langReflectAccess().getRoot(method);</span>
201         if (root != null) {
202             method = root;
203         }
204 
205         if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
206             return new MethodAccessorGenerator().
207                 generateMethod(method.getDeclaringClass(),
208                                method.getName(),
209                                method.getParameterTypes(),
210                                method.getReturnType(),
211                                method.getExceptionTypes(),
212                                method.getModifiers());
213         } else {
214             NativeMethodAccessorImpl acc =
215                 new NativeMethodAccessorImpl(method);
216             DelegatingMethodAccessorImpl res =
217                 new DelegatingMethodAccessorImpl(acc);
218             acc.setParent(res);
219             return res;
220         }
221     }
222 
223     public ConstructorAccessor newConstructorAccessor(Constructor&lt;?&gt; c) {
224         checkInitted();
225 
226         Class&lt;?&gt; declaringClass = c.getDeclaringClass();
227         if (Modifier.isAbstract(declaringClass.getModifiers())) {
228             return new InstantiationExceptionConstructorAccessorImpl(null);
229         }
230         if (declaringClass == Class.class) {
231             return new InstantiationExceptionConstructorAccessorImpl
232                 (&quot;Can not instantiate java.lang.Class&quot;);
233         }
234 
235         // use the root Constructor that will not cache caller class
<span class="line-modified">236         Constructor&lt;?&gt; root = langReflectAccess().getRoot(c);</span>
237         if (root != null) {
238             c = root;
239         }
240 
241         // Bootstrapping issue: since we use Class.newInstance() in
242         // the ConstructorAccessor generation process, we have to
243         // break the cycle here.
244         if (Reflection.isSubclassOf(declaringClass,
245                                     ConstructorAccessorImpl.class)) {
246             return new BootstrapConstructorAccessorImpl(c);
247         }
248 
249         if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) {
250             return new MethodAccessorGenerator().
251                 generateConstructor(c.getDeclaringClass(),
252                                     c.getParameterTypes(),
253                                     c.getExceptionTypes(),
254                                     c.getModifiers());
255         } else {
256             NativeConstructorAccessorImpl acc =
257                 new NativeConstructorAccessorImpl(c);
258             DelegatingConstructorAccessorImpl res =
259                 new DelegatingConstructorAccessorImpl(acc);
260             acc.setParent(res);
261             return res;
262         }
263     }
264 
265     //--------------------------------------------------------------------------
266     //
267     // Routines used by java.lang
268     //
269     //
270 
<span class="line-removed">271     /** Creates a new java.lang.reflect.Field. Access checks as per</span>
<span class="line-removed">272         java.lang.reflect.AccessibleObject are not overridden. */</span>
<span class="line-removed">273     public Field newField(Class&lt;?&gt; declaringClass,</span>
<span class="line-removed">274                           String name,</span>
<span class="line-removed">275                           Class&lt;?&gt; type,</span>
<span class="line-removed">276                           int modifiers,</span>
<span class="line-removed">277                           int slot,</span>
<span class="line-removed">278                           String signature,</span>
<span class="line-removed">279                           byte[] annotations)</span>
<span class="line-removed">280     {</span>
<span class="line-removed">281         return langReflectAccess().newField(declaringClass,</span>
<span class="line-removed">282                                             name,</span>
<span class="line-removed">283                                             type,</span>
<span class="line-removed">284                                             modifiers,</span>
<span class="line-removed">285                                             slot,</span>
<span class="line-removed">286                                             signature,</span>
<span class="line-removed">287                                             annotations);</span>
<span class="line-removed">288     }</span>
<span class="line-removed">289 </span>
<span class="line-removed">290     /** Creates a new java.lang.reflect.Method. Access checks as per</span>
<span class="line-removed">291         java.lang.reflect.AccessibleObject are not overridden. */</span>
<span class="line-removed">292     public Method newMethod(Class&lt;?&gt; declaringClass,</span>
<span class="line-removed">293                             String name,</span>
<span class="line-removed">294                             Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-removed">295                             Class&lt;?&gt; returnType,</span>
<span class="line-removed">296                             Class&lt;?&gt;[] checkedExceptions,</span>
<span class="line-removed">297                             int modifiers,</span>
<span class="line-removed">298                             int slot,</span>
<span class="line-removed">299                             String signature,</span>
<span class="line-removed">300                             byte[] annotations,</span>
<span class="line-removed">301                             byte[] parameterAnnotations,</span>
<span class="line-removed">302                             byte[] annotationDefault)</span>
<span class="line-removed">303     {</span>
<span class="line-removed">304         return langReflectAccess().newMethod(declaringClass,</span>
<span class="line-removed">305                                              name,</span>
<span class="line-removed">306                                              parameterTypes,</span>
<span class="line-removed">307                                              returnType,</span>
<span class="line-removed">308                                              checkedExceptions,</span>
<span class="line-removed">309                                              modifiers,</span>
<span class="line-removed">310                                              slot,</span>
<span class="line-removed">311                                              signature,</span>
<span class="line-removed">312                                              annotations,</span>
<span class="line-removed">313                                              parameterAnnotations,</span>
<span class="line-removed">314                                              annotationDefault);</span>
<span class="line-removed">315     }</span>
<span class="line-removed">316 </span>
317     /** Creates a new java.lang.reflect.Constructor. Access checks as
318         per java.lang.reflect.AccessibleObject are not overridden. */
319     public Constructor&lt;?&gt; newConstructor(Class&lt;?&gt; declaringClass,
320                                          Class&lt;?&gt;[] parameterTypes,
321                                          Class&lt;?&gt;[] checkedExceptions,
322                                          int modifiers,
323                                          int slot,
324                                          String signature,
325                                          byte[] annotations,
326                                          byte[] parameterAnnotations)
327     {
<span class="line-modified">328         return langReflectAccess().newConstructor(declaringClass,</span>
<span class="line-modified">329                                                   parameterTypes,</span>
<span class="line-modified">330                                                   checkedExceptions,</span>
<span class="line-modified">331                                                   modifiers,</span>
<span class="line-modified">332                                                   slot,</span>
<span class="line-modified">333                                                   signature,</span>
<span class="line-modified">334                                                   annotations,</span>
<span class="line-modified">335                                                   parameterAnnotations);</span>
<span class="line-removed">336     }</span>
<span class="line-removed">337 </span>
<span class="line-removed">338     /** Gets the MethodAccessor object for a java.lang.reflect.Method */</span>
<span class="line-removed">339     public MethodAccessor getMethodAccessor(Method m) {</span>
<span class="line-removed">340         return langReflectAccess().getMethodAccessor(m);</span>
<span class="line-removed">341     }</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     /** Sets the MethodAccessor object for a java.lang.reflect.Method */</span>
<span class="line-removed">344     public void setMethodAccessor(Method m, MethodAccessor accessor) {</span>
<span class="line-removed">345         langReflectAccess().setMethodAccessor(m, accessor);</span>
346     }
347 
348     /** Gets the ConstructorAccessor object for a
349         java.lang.reflect.Constructor */
350     public ConstructorAccessor getConstructorAccessor(Constructor&lt;?&gt; c) {
<span class="line-modified">351         return langReflectAccess().getConstructorAccessor(c);</span>
352     }
353 
354     /** Sets the ConstructorAccessor object for a
355         java.lang.reflect.Constructor */
356     public void setConstructorAccessor(Constructor&lt;?&gt; c,
357                                        ConstructorAccessor accessor)
358     {
<span class="line-modified">359         langReflectAccess().setConstructorAccessor(c, accessor);</span>
360     }
361 
362     /** Makes a copy of the passed method. The returned method is a
363         &quot;child&quot; of the passed one; see the comments in Method.java for
364         details. */
365     public Method copyMethod(Method arg) {
<span class="line-modified">366         return langReflectAccess().copyMethod(arg);</span>
367     }
368 
369     /** Makes a copy of the passed method. The returned method is NOT
370      * a &quot;child&quot; but a &quot;sibling&quot; of the Method in arg. Should only be
371      * used on non-root methods. */
372     public Method leafCopyMethod(Method arg) {
<span class="line-modified">373         return langReflectAccess().leafCopyMethod(arg);</span>
374     }
375 
376 
377     /** Makes a copy of the passed field. The returned field is a
378         &quot;child&quot; of the passed one; see the comments in Field.java for
379         details. */
380     public Field copyField(Field arg) {
<span class="line-modified">381         return langReflectAccess().copyField(arg);</span>
382     }
383 
384     /** Makes a copy of the passed constructor. The returned
385         constructor is a &quot;child&quot; of the passed one; see the comments
386         in Constructor.java for details. */
387     public &lt;T&gt; Constructor&lt;T&gt; copyConstructor(Constructor&lt;T&gt; arg) {
<span class="line-modified">388         return langReflectAccess().copyConstructor(arg);</span>
389     }
390 
391     /** Gets the byte[] that encodes TypeAnnotations on an executable.
392      */
393     public byte[] getExecutableTypeAnnotationBytes(Executable ex) {
<span class="line-modified">394         return langReflectAccess().getExecutableTypeAnnotationBytes(ex);</span>
395     }
396 
397     public Class&lt;?&gt;[] getExecutableSharedParameterTypes(Executable ex) {
<span class="line-modified">398         return langReflectAccess().getExecutableSharedParameterTypes(ex);</span>
399     }
400 
401     public &lt;T&gt; T newInstance(Constructor&lt;T&gt; ctor, Object[] args, Class&lt;?&gt; caller)
402         throws IllegalAccessException, InstantiationException, InvocationTargetException
403     {
<span class="line-modified">404         return langReflectAccess().newInstance(ctor, args, caller);</span>
405     }
406 
407     //--------------------------------------------------------------------------
408     //
409     // Routines used by serialization
410     //
411     //
412 
413     public final Constructor&lt;?&gt; newConstructorForExternalization(Class&lt;?&gt; cl) {
414         if (!Externalizable.class.isAssignableFrom(cl)) {
415             return null;
416         }
417         try {
418             Constructor&lt;?&gt; cons = cl.getConstructor();
419             cons.setAccessible(true);
420             return cons;
421         } catch (NoSuchMethodException ex) {
422             return null;
423         }
424     }
</pre>
<hr />
<pre>
509         } catch (NoSuchMethodException ex) {
510             return null;
511         }
512         return generateConstructor(cl, constructorToCall);
513     }
514 
515     private final Constructor&lt;?&gt; generateConstructor(Class&lt;?&gt; cl,
516                                                      Constructor&lt;?&gt; constructorToCall) {
517 
518 
519         ConstructorAccessor acc = new MethodAccessorGenerator().
520             generateSerializationConstructor(cl,
521                                              constructorToCall.getParameterTypes(),
522                                              constructorToCall.getExceptionTypes(),
523                                              constructorToCall.getModifiers(),
524                                              constructorToCall.getDeclaringClass());
525         Constructor&lt;?&gt; c = newConstructor(constructorToCall.getDeclaringClass(),
526                                           constructorToCall.getParameterTypes(),
527                                           constructorToCall.getExceptionTypes(),
528                                           constructorToCall.getModifiers(),
<span class="line-modified">529                                           langReflectAccess().</span>
530                                           getConstructorSlot(constructorToCall),
<span class="line-modified">531                                           langReflectAccess().</span>
532                                           getConstructorSignature(constructorToCall),
<span class="line-modified">533                                           langReflectAccess().</span>
534                                           getConstructorAnnotations(constructorToCall),
<span class="line-modified">535                                           langReflectAccess().</span>
536                                           getConstructorParameterAnnotations(constructorToCall));
537         setConstructorAccessor(c, acc);
538         c.setAccessible(true);
539         return c;
540     }
541 
542     public final MethodHandle readObjectForSerialization(Class&lt;?&gt; cl) {
543         return findReadWriteObjectForSerialization(cl, &quot;readObject&quot;, ObjectInputStream.class);
544     }
545 
546     public final MethodHandle readObjectNoDataForSerialization(Class&lt;?&gt; cl) {
547         return findReadWriteObjectForSerialization(cl, &quot;readObjectNoData&quot;, ObjectInputStream.class);
548     }
549 
550     public final MethodHandle writeObjectForSerialization(Class&lt;?&gt; cl) {
551         return findReadWriteObjectForSerialization(cl, &quot;writeObject&quot;, ObjectOutputStream.class);
552     }
553 
554     private final MethodHandle findReadWriteObjectForSerialization(Class&lt;?&gt; cl,
555                                                                    String methodName,
</pre>
<hr />
<pre>
708         String val = props.getProperty(&quot;sun.reflect.noInflation&quot;);
709         if (val != null &amp;&amp; val.equals(&quot;true&quot;)) {
710             noInflation = true;
711         }
712 
713         val = props.getProperty(&quot;sun.reflect.inflationThreshold&quot;);
714         if (val != null) {
715             try {
716                 inflationThreshold = Integer.parseInt(val);
717             } catch (NumberFormatException e) {
718                 throw new RuntimeException(&quot;Unable to parse property sun.reflect.inflationThreshold&quot;, e);
719             }
720         }
721 
722         disableSerialConstructorChecks =
723             &quot;true&quot;.equals(props.getProperty(&quot;jdk.disableSerialConstructorChecks&quot;));
724 
725         initted = true;
726     }
727 
<span class="line-removed">728     private static LangReflectAccess langReflectAccess() {</span>
<span class="line-removed">729         if (langReflectAccess == null) {</span>
<span class="line-removed">730             // Call a static method to get class java.lang.reflect.Modifier</span>
<span class="line-removed">731             // initialized. Its static initializer will cause</span>
<span class="line-removed">732             // setLangReflectAccess() to be called from the context of the</span>
<span class="line-removed">733             // java.lang.reflect package.</span>
<span class="line-removed">734             Modifier.isPublic(Modifier.PUBLIC);</span>
<span class="line-removed">735         }</span>
<span class="line-removed">736         return langReflectAccess;</span>
<span class="line-removed">737     }</span>
<span class="line-removed">738 </span>
739     /**
740      * Returns true if classes are defined in the classloader and same package, false
741      * otherwise.
742      * @param cl1 a class
743      * @param cl2 another class
744      * @returns true if the two classes are in the same classloader and package
745      */
746     private static boolean packageEquals(Class&lt;?&gt; cl1, Class&lt;?&gt; cl2) {
747         assert !cl1.isArray() &amp;&amp; !cl2.isArray();
748 
749         if (cl1 == cl2) {
750             return true;
751         }
752 
753         return cl1.getClassLoader() == cl2.getClassLoader() &amp;&amp;
754                 Objects.equals(cl1.getPackageName(), cl2.getPackageName());
755     }
756 
757 }
</pre>
</td>
<td>
<hr />
<pre>
 26 package jdk.internal.reflect;
 27 
 28 import java.io.Externalizable;
 29 import java.io.ObjectInputStream;
 30 import java.io.ObjectOutputStream;
 31 import java.io.ObjectStreamClass;
 32 import java.io.OptionalDataException;
 33 import java.io.Serializable;
 34 import java.lang.invoke.MethodHandle;
 35 import java.lang.invoke.MethodHandles;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Executable;
 38 import java.lang.reflect.InvocationTargetException;
 39 import java.lang.reflect.Method;
 40 import java.lang.reflect.Constructor;
 41 import java.lang.reflect.Modifier;
 42 import java.security.PrivilegedAction;
 43 import java.util.Objects;
 44 import java.util.Properties;
 45 
<span class="line-added"> 46 import jdk.internal.access.JavaLangReflectAccess;</span>
<span class="line-added"> 47 import jdk.internal.access.SharedSecrets;</span>
 48 import jdk.internal.misc.VM;
 49 import sun.reflect.misc.ReflectUtil;
 50 import sun.security.action.GetPropertyAction;
 51 import sun.security.util.SecurityConstants;
 52 
 53 /** &lt;P&gt; The master factory for all reflective objects, both those in
 54     java.lang.reflect (Fields, Methods, Constructors) as well as their
 55     delegates (FieldAccessors, MethodAccessors, ConstructorAccessors).
 56     &lt;/P&gt;
 57 
 58     &lt;P&gt; The methods in this class are extremely unsafe and can cause
 59     subversion of both the language and the verifier. For this reason,
 60     they are all instance methods, and access to the constructor of
 61     this factory is guarded by a security check, in similar style to
 62     {@link jdk.internal.misc.Unsafe}. &lt;/P&gt;
 63 */
 64 
 65 public class ReflectionFactory {
 66 
 67     private static boolean initted = false;
 68     private static final ReflectionFactory soleInstance = new ReflectionFactory();
<span class="line-modified"> 69 </span>

 70 
 71     /* Method for static class initializer &lt;clinit&gt;, or null */
 72     private static volatile Method hasStaticInitializerMethod;
 73 
 74     //
 75     // &quot;Inflation&quot; mechanism. Loading bytecodes to implement
 76     // Method.invoke() and Constructor.newInstance() currently costs
 77     // 3-4x more than an invocation via native code for the first
 78     // invocation (though subsequent invocations have been benchmarked
 79     // to be over 20x faster). Unfortunately this cost increases
 80     // startup time for certain applications that use reflection
 81     // intensively (but only once per class) to bootstrap themselves.
 82     // To avoid this penalty we reuse the existing JVM entry points
 83     // for the first few invocations of Methods and Constructors and
 84     // then switch to the bytecode-based implementations.
 85     //
 86     // Package-private to be accessible to NativeMethodAccessorImpl
 87     // and NativeConstructorAccessorImpl
 88     private static boolean noInflation        = false;
 89     private static int     inflationThreshold = 15;
 90 
 91     // true if deserialization constructor checking is disabled
 92     private static boolean disableSerialConstructorChecks = false;
 93 
<span class="line-added"> 94     private final JavaLangReflectAccess langReflectAccess;</span>
 95     private ReflectionFactory() {
<span class="line-added"> 96         this.langReflectAccess = SharedSecrets.getJavaLangReflectAccess();</span>
 97     }
 98 
 99     /**
100      * A convenience class for acquiring the capability to instantiate
101      * reflective objects.  Use this instead of a raw call to {@link
102      * #getReflectionFactory} in order to avoid being limited by the
103      * permissions of your callers.
104      *
105      * &lt;p&gt;An instance of this class can be used as the argument of
106      * &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;.
107      */
108     public static final class GetReflectionFactoryAction
109         implements PrivilegedAction&lt;ReflectionFactory&gt; {
110         public ReflectionFactory run() {
111             return getReflectionFactory();
112         }
113     }
114 
115     /**
116      * Provides the caller with the capability to instantiate reflective
</pre>
<hr />
<pre>
146      * A trusted method can define an alternate implementation for a method `foo`
147      * by defining a method named &quot;reflected$foo&quot; that will be invoked
148      * reflectively.
149      */
150     private static Method findMethodForReflection(Method method) {
151         String altName = &quot;reflected$&quot; + method.getName();
152         try {
153            return method.getDeclaringClass()
154                         .getDeclaredMethod(altName, method.getParameterTypes());
155         } catch (NoSuchMethodException ex) {
156             return null;
157         }
158     }
159 
160     //--------------------------------------------------------------------------
161     //
162     // Routines used by java.lang.reflect
163     //
164     //
165 
<span class="line-modified">166     /*</span>





167      * Note: this routine can cause the declaring class for the field
168      * be initialized and therefore must not be called until the
169      * first get/set of this field.
170      * @param field the field
171      * @param override true if caller has overridden accessibility
172      */
173     public FieldAccessor newFieldAccessor(Field field, boolean override) {
174         checkInitted();
175 
<span class="line-modified">176         Field root = langReflectAccess.getRoot(field);</span>
177         if (root != null) {
178             // FieldAccessor will use the root unless the modifiers have
179             // been overrridden
180             if (root.getModifiers() == field.getModifiers() || !override) {
181                 field = root;
182             }
183         }
184         return UnsafeFieldAccessorFactory.newFieldAccessor(field, override);
185     }
186 
187     public MethodAccessor newMethodAccessor(Method method) {
188         checkInitted();
189 
190         if (Reflection.isCallerSensitive(method)) {
191             Method altMethod = findMethodForReflection(method);
192             if (altMethod != null) {
193                 method = altMethod;
194             }
195         }
196 
197         // use the root Method that will not cache caller class
<span class="line-modified">198         Method root = langReflectAccess.getRoot(method);</span>
199         if (root != null) {
200             method = root;
201         }
202 
203         if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
204             return new MethodAccessorGenerator().
205                 generateMethod(method.getDeclaringClass(),
206                                method.getName(),
207                                method.getParameterTypes(),
208                                method.getReturnType(),
209                                method.getExceptionTypes(),
210                                method.getModifiers());
211         } else {
212             NativeMethodAccessorImpl acc =
213                 new NativeMethodAccessorImpl(method);
214             DelegatingMethodAccessorImpl res =
215                 new DelegatingMethodAccessorImpl(acc);
216             acc.setParent(res);
217             return res;
218         }
219     }
220 
221     public ConstructorAccessor newConstructorAccessor(Constructor&lt;?&gt; c) {
222         checkInitted();
223 
224         Class&lt;?&gt; declaringClass = c.getDeclaringClass();
225         if (Modifier.isAbstract(declaringClass.getModifiers())) {
226             return new InstantiationExceptionConstructorAccessorImpl(null);
227         }
228         if (declaringClass == Class.class) {
229             return new InstantiationExceptionConstructorAccessorImpl
230                 (&quot;Can not instantiate java.lang.Class&quot;);
231         }
232 
233         // use the root Constructor that will not cache caller class
<span class="line-modified">234         Constructor&lt;?&gt; root = langReflectAccess.getRoot(c);</span>
235         if (root != null) {
236             c = root;
237         }
238 
239         // Bootstrapping issue: since we use Class.newInstance() in
240         // the ConstructorAccessor generation process, we have to
241         // break the cycle here.
242         if (Reflection.isSubclassOf(declaringClass,
243                                     ConstructorAccessorImpl.class)) {
244             return new BootstrapConstructorAccessorImpl(c);
245         }
246 
247         if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) {
248             return new MethodAccessorGenerator().
249                 generateConstructor(c.getDeclaringClass(),
250                                     c.getParameterTypes(),
251                                     c.getExceptionTypes(),
252                                     c.getModifiers());
253         } else {
254             NativeConstructorAccessorImpl acc =
255                 new NativeConstructorAccessorImpl(c);
256             DelegatingConstructorAccessorImpl res =
257                 new DelegatingConstructorAccessorImpl(acc);
258             acc.setParent(res);
259             return res;
260         }
261     }
262 
263     //--------------------------------------------------------------------------
264     //
265     // Routines used by java.lang
266     //
267     //
268 














































269     /** Creates a new java.lang.reflect.Constructor. Access checks as
270         per java.lang.reflect.AccessibleObject are not overridden. */
271     public Constructor&lt;?&gt; newConstructor(Class&lt;?&gt; declaringClass,
272                                          Class&lt;?&gt;[] parameterTypes,
273                                          Class&lt;?&gt;[] checkedExceptions,
274                                          int modifiers,
275                                          int slot,
276                                          String signature,
277                                          byte[] annotations,
278                                          byte[] parameterAnnotations)
279     {
<span class="line-modified">280         return langReflectAccess.newConstructor(declaringClass,</span>
<span class="line-modified">281                                                 parameterTypes,</span>
<span class="line-modified">282                                                 checkedExceptions,</span>
<span class="line-modified">283                                                 modifiers,</span>
<span class="line-modified">284                                                 slot,</span>
<span class="line-modified">285                                                 signature,</span>
<span class="line-modified">286                                                 annotations,</span>
<span class="line-modified">287                                                 parameterAnnotations);</span>










288     }
289 
290     /** Gets the ConstructorAccessor object for a
291         java.lang.reflect.Constructor */
292     public ConstructorAccessor getConstructorAccessor(Constructor&lt;?&gt; c) {
<span class="line-modified">293         return langReflectAccess.getConstructorAccessor(c);</span>
294     }
295 
296     /** Sets the ConstructorAccessor object for a
297         java.lang.reflect.Constructor */
298     public void setConstructorAccessor(Constructor&lt;?&gt; c,
299                                        ConstructorAccessor accessor)
300     {
<span class="line-modified">301         langReflectAccess.setConstructorAccessor(c, accessor);</span>
302     }
303 
304     /** Makes a copy of the passed method. The returned method is a
305         &quot;child&quot; of the passed one; see the comments in Method.java for
306         details. */
307     public Method copyMethod(Method arg) {
<span class="line-modified">308         return langReflectAccess.copyMethod(arg);</span>
309     }
310 
311     /** Makes a copy of the passed method. The returned method is NOT
312      * a &quot;child&quot; but a &quot;sibling&quot; of the Method in arg. Should only be
313      * used on non-root methods. */
314     public Method leafCopyMethod(Method arg) {
<span class="line-modified">315         return langReflectAccess.leafCopyMethod(arg);</span>
316     }
317 
318 
319     /** Makes a copy of the passed field. The returned field is a
320         &quot;child&quot; of the passed one; see the comments in Field.java for
321         details. */
322     public Field copyField(Field arg) {
<span class="line-modified">323         return langReflectAccess.copyField(arg);</span>
324     }
325 
326     /** Makes a copy of the passed constructor. The returned
327         constructor is a &quot;child&quot; of the passed one; see the comments
328         in Constructor.java for details. */
329     public &lt;T&gt; Constructor&lt;T&gt; copyConstructor(Constructor&lt;T&gt; arg) {
<span class="line-modified">330         return langReflectAccess.copyConstructor(arg);</span>
331     }
332 
333     /** Gets the byte[] that encodes TypeAnnotations on an executable.
334      */
335     public byte[] getExecutableTypeAnnotationBytes(Executable ex) {
<span class="line-modified">336         return langReflectAccess.getExecutableTypeAnnotationBytes(ex);</span>
337     }
338 
339     public Class&lt;?&gt;[] getExecutableSharedParameterTypes(Executable ex) {
<span class="line-modified">340         return langReflectAccess.getExecutableSharedParameterTypes(ex);</span>
341     }
342 
343     public &lt;T&gt; T newInstance(Constructor&lt;T&gt; ctor, Object[] args, Class&lt;?&gt; caller)
344         throws IllegalAccessException, InstantiationException, InvocationTargetException
345     {
<span class="line-modified">346         return langReflectAccess.newInstance(ctor, args, caller);</span>
347     }
348 
349     //--------------------------------------------------------------------------
350     //
351     // Routines used by serialization
352     //
353     //
354 
355     public final Constructor&lt;?&gt; newConstructorForExternalization(Class&lt;?&gt; cl) {
356         if (!Externalizable.class.isAssignableFrom(cl)) {
357             return null;
358         }
359         try {
360             Constructor&lt;?&gt; cons = cl.getConstructor();
361             cons.setAccessible(true);
362             return cons;
363         } catch (NoSuchMethodException ex) {
364             return null;
365         }
366     }
</pre>
<hr />
<pre>
451         } catch (NoSuchMethodException ex) {
452             return null;
453         }
454         return generateConstructor(cl, constructorToCall);
455     }
456 
457     private final Constructor&lt;?&gt; generateConstructor(Class&lt;?&gt; cl,
458                                                      Constructor&lt;?&gt; constructorToCall) {
459 
460 
461         ConstructorAccessor acc = new MethodAccessorGenerator().
462             generateSerializationConstructor(cl,
463                                              constructorToCall.getParameterTypes(),
464                                              constructorToCall.getExceptionTypes(),
465                                              constructorToCall.getModifiers(),
466                                              constructorToCall.getDeclaringClass());
467         Constructor&lt;?&gt; c = newConstructor(constructorToCall.getDeclaringClass(),
468                                           constructorToCall.getParameterTypes(),
469                                           constructorToCall.getExceptionTypes(),
470                                           constructorToCall.getModifiers(),
<span class="line-modified">471                                           langReflectAccess.</span>
472                                           getConstructorSlot(constructorToCall),
<span class="line-modified">473                                           langReflectAccess.</span>
474                                           getConstructorSignature(constructorToCall),
<span class="line-modified">475                                           langReflectAccess.</span>
476                                           getConstructorAnnotations(constructorToCall),
<span class="line-modified">477                                           langReflectAccess.</span>
478                                           getConstructorParameterAnnotations(constructorToCall));
479         setConstructorAccessor(c, acc);
480         c.setAccessible(true);
481         return c;
482     }
483 
484     public final MethodHandle readObjectForSerialization(Class&lt;?&gt; cl) {
485         return findReadWriteObjectForSerialization(cl, &quot;readObject&quot;, ObjectInputStream.class);
486     }
487 
488     public final MethodHandle readObjectNoDataForSerialization(Class&lt;?&gt; cl) {
489         return findReadWriteObjectForSerialization(cl, &quot;readObjectNoData&quot;, ObjectInputStream.class);
490     }
491 
492     public final MethodHandle writeObjectForSerialization(Class&lt;?&gt; cl) {
493         return findReadWriteObjectForSerialization(cl, &quot;writeObject&quot;, ObjectOutputStream.class);
494     }
495 
496     private final MethodHandle findReadWriteObjectForSerialization(Class&lt;?&gt; cl,
497                                                                    String methodName,
</pre>
<hr />
<pre>
650         String val = props.getProperty(&quot;sun.reflect.noInflation&quot;);
651         if (val != null &amp;&amp; val.equals(&quot;true&quot;)) {
652             noInflation = true;
653         }
654 
655         val = props.getProperty(&quot;sun.reflect.inflationThreshold&quot;);
656         if (val != null) {
657             try {
658                 inflationThreshold = Integer.parseInt(val);
659             } catch (NumberFormatException e) {
660                 throw new RuntimeException(&quot;Unable to parse property sun.reflect.inflationThreshold&quot;, e);
661             }
662         }
663 
664         disableSerialConstructorChecks =
665             &quot;true&quot;.equals(props.getProperty(&quot;jdk.disableSerialConstructorChecks&quot;));
666 
667         initted = true;
668     }
669 











670     /**
671      * Returns true if classes are defined in the classloader and same package, false
672      * otherwise.
673      * @param cl1 a class
674      * @param cl2 another class
675      * @returns true if the two classes are in the same classloader and package
676      */
677     private static boolean packageEquals(Class&lt;?&gt; cl1, Class&lt;?&gt; cl2) {
678         assert !cl1.isArray() &amp;&amp; !cl2.isArray();
679 
680         if (cl1 == cl2) {
681             return true;
682         }
683 
684         return cl1.getClassLoader() == cl2.getClassLoader() &amp;&amp;
685                 Objects.equals(cl1.getPackageName(), cl2.getPackageName());
686     }
687 
688 }
</pre>
</td>
</tr>
</table>
<center><a href="Reflection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../util/ArraysSupport.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
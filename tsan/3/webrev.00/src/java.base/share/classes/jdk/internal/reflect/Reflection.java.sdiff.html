<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/reflect/Reflection.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../platform/Metrics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectionFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/reflect/Reflection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
105         }
106     }
107 
108     /**
109      * Verify access to a member and return {@code true} if it is granted.
110      *
111      * @param currentClass the class performing the access
112      * @param memberClass the declaring class of the member being accessed
113      * @param targetClass the class of target object if accessing instance
114      *                    field or method;
115      *                    or the declaring class if accessing constructor;
116      *                    or null if accessing static field or method
117      * @param modifiers the member&#39;s access modifiers
118      * @return {@code true} if access to member is granted
119      */
120     public static boolean verifyMemberAccess(Class&lt;?&gt; currentClass,
121                                              Class&lt;?&gt; memberClass,
122                                              Class&lt;?&gt; targetClass,
123                                              int modifiers)
124     {



125         if (currentClass == memberClass) {
126             // Always succeeds
127             return true;
128         }
129 
130         if (!verifyModuleAccess(currentClass.getModule(), memberClass)) {
131             return false;
132         }
133 
134         boolean gotIsSameClassPackage = false;
135         boolean isSameClassPackage = false;
136 
137         if (!Modifier.isPublic(getClassAccessFlags(memberClass))) {
138             isSameClassPackage = isSameClassPackage(currentClass, memberClass);
139             gotIsSameClassPackage = true;
140             if (!isSameClassPackage) {
141                 return false;
142             }
143         }
144 
</pre>
<hr />
<pre>
184 
185         // Additional test for protected instance members
186         // and protected constructors: JLS 6.6.2
187         if (targetClass != null &amp;&amp; Modifier.isProtected(modifiers) &amp;&amp;
188             targetClass != currentClass)
189         {
190             if (!gotIsSameClassPackage) {
191                 isSameClassPackage = isSameClassPackage(currentClass, memberClass);
192                 gotIsSameClassPackage = true;
193             }
194             if (!isSameClassPackage) {
195                 if (!isSubclassOf(targetClass, currentClass)) {
196                     return false;
197                 }
198             }
199         }
200 
201         return true;
202     }
203 
















204     /**
205      * Returns {@code true} if memberClass&#39;s module exports memberClass&#39;s
206      * package to currentModule.
207      */
208     public static boolean verifyModuleAccess(Module currentModule, Class&lt;?&gt; memberClass) {
209         Module memberModule = memberClass.getModule();
210         if (currentModule == memberModule) {
211             // same module (named or unnamed) or both null if called
212             // before module system is initialized, which means we are
213             // dealing with java.base only.
214             return true;
215         } else {
216             String pkg = memberClass.getPackageName();
217             return memberModule.isExported(pkg, currentModule);
218         }
219     }
220 
221     /**
222      * Returns true if two classes in the same package.
223      */
</pre>
<hr />
<pre>
308     /**
309      * Tests if the given method is caller-sensitive and the declaring class
310      * is defined by either the bootstrap class loader or platform class loader.
311      */
312     public static boolean isCallerSensitive(Method m) {
313         final ClassLoader loader = m.getDeclaringClass().getClassLoader();
314         if (VM.isSystemDomainLoader(loader)) {
315             return m.isAnnotationPresent(CallerSensitive.class);
316         }
317         return false;
318     }
319 
320     /**
321      * Returns an IllegalAccessException with an exception message based on
322      * the access that is denied.
323      */
324     public static IllegalAccessException newIllegalAccessException(Class&lt;?&gt; currentClass,
325                                                                    Class&lt;?&gt; memberClass,
326                                                                    Class&lt;?&gt; targetClass,
327                                                                    int modifiers)
<span class="line-removed">328         throws IllegalAccessException</span>
329     {



330         String currentSuffix = &quot;&quot;;
331         String memberSuffix = &quot;&quot;;
332         Module m1 = currentClass.getModule();
333         if (m1.isNamed())
334             currentSuffix = &quot; (in &quot; + m1 + &quot;)&quot;;
335         Module m2 = memberClass.getModule();
336         if (m2.isNamed())
337             memberSuffix = &quot; (in &quot; + m2 + &quot;)&quot;;
338 
339         String memberPackageName = memberClass.getPackageName();
340 
341         String msg = currentClass + currentSuffix + &quot; cannot access &quot;;
342         if (m2.isExported(memberPackageName, m1)) {
343 
344             // module access okay so include the modifiers in the message
345             msg += &quot;a member of &quot; + memberClass + memberSuffix +
346                     &quot; with modifiers \&quot;&quot; + Modifier.toString(modifiers) + &quot;\&quot;&quot;;
347 
348         } else {
349             // module access failed
350             msg += memberClass + memberSuffix+ &quot; because &quot;
351                    + m2 + &quot; does not export &quot; + memberPackageName;
352             if (m2.isNamed()) msg += &quot; to &quot; + m1;
353         }
354 
355         return new IllegalAccessException(msg);
356     }
357 






























358     /**
359      * Returns true if {@code currentClass} and {@code memberClass}
360      * are nestmates - that is, if they have the same nesthost as
361      * determined by the VM.
362      */
363     public static native boolean areNestMates(Class&lt;?&gt; currentClass,
364                                               Class&lt;?&gt; memberClass);
365 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
105         }
106     }
107 
108     /**
109      * Verify access to a member and return {@code true} if it is granted.
110      *
111      * @param currentClass the class performing the access
112      * @param memberClass the declaring class of the member being accessed
113      * @param targetClass the class of target object if accessing instance
114      *                    field or method;
115      *                    or the declaring class if accessing constructor;
116      *                    or null if accessing static field or method
117      * @param modifiers the member&#39;s access modifiers
118      * @return {@code true} if access to member is granted
119      */
120     public static boolean verifyMemberAccess(Class&lt;?&gt; currentClass,
121                                              Class&lt;?&gt; memberClass,
122                                              Class&lt;?&gt; targetClass,
123                                              int modifiers)
124     {
<span class="line-added">125         Objects.requireNonNull(currentClass);</span>
<span class="line-added">126         Objects.requireNonNull(memberClass);</span>
<span class="line-added">127 </span>
128         if (currentClass == memberClass) {
129             // Always succeeds
130             return true;
131         }
132 
133         if (!verifyModuleAccess(currentClass.getModule(), memberClass)) {
134             return false;
135         }
136 
137         boolean gotIsSameClassPackage = false;
138         boolean isSameClassPackage = false;
139 
140         if (!Modifier.isPublic(getClassAccessFlags(memberClass))) {
141             isSameClassPackage = isSameClassPackage(currentClass, memberClass);
142             gotIsSameClassPackage = true;
143             if (!isSameClassPackage) {
144                 return false;
145             }
146         }
147 
</pre>
<hr />
<pre>
187 
188         // Additional test for protected instance members
189         // and protected constructors: JLS 6.6.2
190         if (targetClass != null &amp;&amp; Modifier.isProtected(modifiers) &amp;&amp;
191             targetClass != currentClass)
192         {
193             if (!gotIsSameClassPackage) {
194                 isSameClassPackage = isSameClassPackage(currentClass, memberClass);
195                 gotIsSameClassPackage = true;
196             }
197             if (!isSameClassPackage) {
198                 if (!isSubclassOf(targetClass, currentClass)) {
199                     return false;
200                 }
201             }
202         }
203 
204         return true;
205     }
206 
<span class="line-added">207     /*</span>
<span class="line-added">208      * Verify if a member is public and memberClass is a public type</span>
<span class="line-added">209      * in a package that is unconditionally exported and</span>
<span class="line-added">210      * return {@code true}if it is granted.</span>
<span class="line-added">211      *</span>
<span class="line-added">212      * @param memberClass the declaring class of the member being accessed</span>
<span class="line-added">213      * @param modifiers the member&#39;s access modifiers</span>
<span class="line-added">214      * @return {@code true} if the member is public and in a publicly accessible type</span>
<span class="line-added">215      */</span>
<span class="line-added">216     public static boolean verifyPublicMemberAccess(Class&lt;?&gt; memberClass, int modifiers) {</span>
<span class="line-added">217         Module m = memberClass.getModule();</span>
<span class="line-added">218         return Modifier.isPublic(modifiers)</span>
<span class="line-added">219             &amp;&amp; m.isExported(memberClass.getPackageName())</span>
<span class="line-added">220             &amp;&amp; Modifier.isPublic(Reflection.getClassAccessFlags(memberClass));</span>
<span class="line-added">221     }</span>
<span class="line-added">222 </span>
223     /**
224      * Returns {@code true} if memberClass&#39;s module exports memberClass&#39;s
225      * package to currentModule.
226      */
227     public static boolean verifyModuleAccess(Module currentModule, Class&lt;?&gt; memberClass) {
228         Module memberModule = memberClass.getModule();
229         if (currentModule == memberModule) {
230             // same module (named or unnamed) or both null if called
231             // before module system is initialized, which means we are
232             // dealing with java.base only.
233             return true;
234         } else {
235             String pkg = memberClass.getPackageName();
236             return memberModule.isExported(pkg, currentModule);
237         }
238     }
239 
240     /**
241      * Returns true if two classes in the same package.
242      */
</pre>
<hr />
<pre>
327     /**
328      * Tests if the given method is caller-sensitive and the declaring class
329      * is defined by either the bootstrap class loader or platform class loader.
330      */
331     public static boolean isCallerSensitive(Method m) {
332         final ClassLoader loader = m.getDeclaringClass().getClassLoader();
333         if (VM.isSystemDomainLoader(loader)) {
334             return m.isAnnotationPresent(CallerSensitive.class);
335         }
336         return false;
337     }
338 
339     /**
340      * Returns an IllegalAccessException with an exception message based on
341      * the access that is denied.
342      */
343     public static IllegalAccessException newIllegalAccessException(Class&lt;?&gt; currentClass,
344                                                                    Class&lt;?&gt; memberClass,
345                                                                    Class&lt;?&gt; targetClass,
346                                                                    int modifiers)

347     {
<span class="line-added">348         if (currentClass == null)</span>
<span class="line-added">349             return newIllegalAccessException(memberClass, modifiers);</span>
<span class="line-added">350 </span>
351         String currentSuffix = &quot;&quot;;
352         String memberSuffix = &quot;&quot;;
353         Module m1 = currentClass.getModule();
354         if (m1.isNamed())
355             currentSuffix = &quot; (in &quot; + m1 + &quot;)&quot;;
356         Module m2 = memberClass.getModule();
357         if (m2.isNamed())
358             memberSuffix = &quot; (in &quot; + m2 + &quot;)&quot;;
359 
360         String memberPackageName = memberClass.getPackageName();
361 
362         String msg = currentClass + currentSuffix + &quot; cannot access &quot;;
363         if (m2.isExported(memberPackageName, m1)) {
364 
365             // module access okay so include the modifiers in the message
366             msg += &quot;a member of &quot; + memberClass + memberSuffix +
367                     &quot; with modifiers \&quot;&quot; + Modifier.toString(modifiers) + &quot;\&quot;&quot;;
368 
369         } else {
370             // module access failed
371             msg += memberClass + memberSuffix+ &quot; because &quot;
372                    + m2 + &quot; does not export &quot; + memberPackageName;
373             if (m2.isNamed()) msg += &quot; to &quot; + m1;
374         }
375 
376         return new IllegalAccessException(msg);
377     }
378 
<span class="line-added">379     /**</span>
<span class="line-added">380      * Returns an IllegalAccessException with an exception message where</span>
<span class="line-added">381      * there is no caller frame.</span>
<span class="line-added">382      */</span>
<span class="line-added">383     private static IllegalAccessException newIllegalAccessException(Class&lt;?&gt; memberClass,</span>
<span class="line-added">384                                                                     int modifiers)</span>
<span class="line-added">385     {</span>
<span class="line-added">386         String memberSuffix = &quot;&quot;;</span>
<span class="line-added">387         Module m2 = memberClass.getModule();</span>
<span class="line-added">388         if (m2.isNamed())</span>
<span class="line-added">389             memberSuffix = &quot; (in &quot; + m2 + &quot;)&quot;;</span>
<span class="line-added">390 </span>
<span class="line-added">391         String memberPackageName = memberClass.getPackageName();</span>
<span class="line-added">392 </span>
<span class="line-added">393         String msg = &quot;JNI attached native thread (null caller frame) cannot access &quot;;</span>
<span class="line-added">394         if (m2.isExported(memberPackageName)) {</span>
<span class="line-added">395 </span>
<span class="line-added">396             // module access okay so include the modifiers in the message</span>
<span class="line-added">397             msg += &quot;a member of &quot; + memberClass + memberSuffix +</span>
<span class="line-added">398                 &quot; with modifiers \&quot;&quot; + Modifier.toString(modifiers) + &quot;\&quot;&quot;;</span>
<span class="line-added">399 </span>
<span class="line-added">400         } else {</span>
<span class="line-added">401             // module access failed</span>
<span class="line-added">402             msg += memberClass + memberSuffix+ &quot; because &quot;</span>
<span class="line-added">403                 + m2 + &quot; does not export &quot; + memberPackageName;</span>
<span class="line-added">404         }</span>
<span class="line-added">405 </span>
<span class="line-added">406         return new IllegalAccessException(msg);</span>
<span class="line-added">407     }</span>
<span class="line-added">408 </span>
409     /**
410      * Returns true if {@code currentClass} and {@code memberClass}
411      * are nestmates - that is, if they have the same nesthost as
412      * determined by the VM.
413      */
414     public static native boolean areNestMates(Class&lt;?&gt; currentClass,
415                                               Class&lt;?&gt; memberClass);
416 }
</pre>
</td>
</tr>
</table>
<center><a href="../platform/Metrics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectionFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
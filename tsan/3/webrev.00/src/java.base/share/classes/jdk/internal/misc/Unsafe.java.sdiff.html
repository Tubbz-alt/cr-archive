<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../math/FloatingDecimal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ArchivedModuleGraph.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.ref.Cleaner;
  30 import jdk.internal.vm.annotation.ForceInline;
  31 import sun.nio.ch.DirectBuffer;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 

  36 
  37 /**
  38  * A collection of methods for performing low-level, unsafe operations.
  39  * Although the class and all methods are public, use of this class is
  40  * limited because only trusted code can obtain instances of it.
  41  *
<span class="line-modified">  42  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure</span>
  43  * arguments are checked before methods of this class are
  44  * called. While some rudimentary checks are performed on the input,
  45  * the checks are best effort and when performance is an overriding
  46  * priority, as when methods of this class are optimized by the
  47  * runtime compiler, some or all checks (if any) may be elided. Hence,
  48  * the caller must not rely on the checks and corresponding
  49  * exceptions!
  50  *
  51  * @author John R. Rose
  52  * @see #getUnsafe
  53  */
  54 
  55 public final class Unsafe {
  56 
  57     private static native void registerNatives();
  58     static {
  59         registerNatives();
  60     }
  61 
  62     private Unsafe() {}
</pre>
<hr />
<pre>
 407 
 408     /** @see #getAddress(Object, long) */
 409     @ForceInline
 410     public long getAddress(long address) {
 411         return getAddress(null, address);
 412     }
 413 
 414     /** @see #putAddress(Object, long, long) */
 415     @ForceInline
 416     public void putAddress(long address, long x) {
 417         putAddress(null, address, x);
 418     }
 419 
 420 
 421 
 422     /// helper methods for validating various types of objects/values
 423 
 424     /**
 425      * Create an exception reflecting that some of the input was invalid
 426      *
<span class="line-modified"> 427      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 428      * sure arguments are checked before the methods are called. While
 429      * some rudimentary checks are performed on the input, the checks
 430      * are best effort and when performance is an overriding priority,
 431      * as when methods of this class are optimized by the runtime
 432      * compiler, some or all checks (if any) may be elided. Hence, the
 433      * caller must not rely on the checks and corresponding
 434      * exceptions!
 435      *
 436      * @return an exception object
 437      */
 438     private RuntimeException invalidInput() {
 439         return new IllegalArgumentException();
 440     }
 441 
 442     /**
 443      * Check if a value is 32-bit clean (32 MSB are all zero)
 444      *
 445      * @param value the 64-bit value to check
 446      *
 447      * @return true if the value is 32-bit clean
</pre>
<hr />
<pre>
 565      *
 566      * Note: pointers off-heap are considered to be primitive arrays
 567      *
 568      * @throws RuntimeException if the pointer is invalid
 569      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 570      *         go undetected, which will lead to unpredictable
 571      *         behavior)
 572      */
 573     private void checkPrimitivePointer(Object o, long offset) {
 574         checkPointer(o, offset);
 575 
 576         if (o != null) {
 577             // If on heap, it must be a primitive array
 578             checkPrimitiveArray(o.getClass());
 579         }
 580     }
 581 
 582 
 583     /// wrappers for malloc, realloc, free:
 584 











 585     /**
 586      * Allocates a new block of native memory, of the given size in bytes.  The
 587      * contents of the memory are uninitialized; they will generally be
 588      * garbage.  The resulting native pointer will never be zero, and will be
 589      * aligned for all value types.  Dispose of this memory by calling {@link
 590      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 591      *
<span class="line-modified"> 592      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 593      * sure arguments are checked before the methods are called. While
 594      * some rudimentary checks are performed on the input, the checks
 595      * are best effort and when performance is an overriding priority,
 596      * as when methods of this class are optimized by the runtime
 597      * compiler, some or all checks (if any) may be elided. Hence, the
 598      * caller must not rely on the checks and corresponding
 599      * exceptions!
 600      *
 601      * @throws RuntimeException if the size is negative or too large
 602      *         for the native size_t type
 603      *
 604      * @throws OutOfMemoryError if the allocation is refused by the system
 605      *
 606      * @see #getByte(long)
 607      * @see #putByte(long, byte)
 608      */
 609     public long allocateMemory(long bytes) {


 610         allocateMemoryChecks(bytes);
 611 
 612         if (bytes == 0) {
 613             return 0;
 614         }
 615 
 616         long p = allocateMemory0(bytes);
 617         if (p == 0) {
 618             throw new OutOfMemoryError();
 619         }
 620 
 621         return p;
 622     }
 623 
 624     /**
 625      * Validate the arguments to allocateMemory
 626      *
 627      * @throws RuntimeException if the arguments are invalid
 628      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 629      *         go undetected, which will lead to unpredictable
 630      *         behavior)
 631      */
 632     private void allocateMemoryChecks(long bytes) {
 633         checkSize(bytes);
 634     }
 635 
 636     /**
 637      * Resizes a new block of native memory, to the given size in bytes.  The
 638      * contents of the new block past the size of the old block are
 639      * uninitialized; they will generally be garbage.  The resulting native
 640      * pointer will be zero if and only if the requested size is zero.  The
 641      * resulting native pointer will be aligned for all value types.  Dispose
 642      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 643      * #reallocateMemory}.  The address passed to this method may be null, in
 644      * which case an allocation will be performed.
 645      *
<span class="line-modified"> 646      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 647      * sure arguments are checked before the methods are called. While
 648      * some rudimentary checks are performed on the input, the checks
 649      * are best effort and when performance is an overriding priority,
 650      * as when methods of this class are optimized by the runtime
 651      * compiler, some or all checks (if any) may be elided. Hence, the
 652      * caller must not rely on the checks and corresponding
 653      * exceptions!
 654      *
 655      * @throws RuntimeException if the size is negative or too large
 656      *         for the native size_t type
 657      *
 658      * @throws OutOfMemoryError if the allocation is refused by the system
 659      *
 660      * @see #allocateMemory
 661      */
 662     public long reallocateMemory(long address, long bytes) {


 663         reallocateMemoryChecks(address, bytes);
 664 
 665         if (bytes == 0) {
 666             freeMemory(address);
 667             return 0;
 668         }
 669 
 670         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 671         if (p == 0) {
 672             throw new OutOfMemoryError();
 673         }
 674 
 675         return p;
 676     }
 677 
 678     /**
 679      * Validate the arguments to reallocateMemory
 680      *
 681      * @throws RuntimeException if the arguments are invalid
 682      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
</pre>
<hr />
<pre>
 686     private void reallocateMemoryChecks(long address, long bytes) {
 687         checkPointer(null, address);
 688         checkSize(bytes);
 689     }
 690 
 691     /**
 692      * Sets all bytes in a given block of memory to a fixed value
 693      * (usually zero).
 694      *
 695      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 696      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 697      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 698      * the offset supplies an absolute base address.
 699      *
 700      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 701      * by the address and length parameters.  If the effective address and
 702      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 703      * If the effective address and length are (resp.) even modulo 4 or 2,
 704      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 705      *
<span class="line-modified"> 706      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 707      * sure arguments are checked before the methods are called. While
 708      * some rudimentary checks are performed on the input, the checks
 709      * are best effort and when performance is an overriding priority,
 710      * as when methods of this class are optimized by the runtime
 711      * compiler, some or all checks (if any) may be elided. Hence, the
 712      * caller must not rely on the checks and corresponding
 713      * exceptions!
 714      *
 715      * @throws RuntimeException if any of the arguments is invalid
 716      *
 717      * @since 1.7
 718      */
 719     public void setMemory(Object o, long offset, long bytes, byte value) {
 720         setMemoryChecks(o, offset, bytes, value);
 721 
 722         if (bytes == 0) {
 723             return;
 724         }
 725 
 726         setMemory0(o, offset, bytes, value);
</pre>
<hr />
<pre>
 748     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 749         checkPrimitivePointer(o, offset);
 750         checkSize(bytes);
 751     }
 752 
 753     /**
 754      * Sets all bytes in a given block of memory to a copy of another
 755      * block.
 756      *
 757      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 758      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 759      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 760      * the offset supplies an absolute base address.
 761      *
 762      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 763      * by the address and length parameters.  If the effective addresses and
 764      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 765      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 766      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 767      *
<span class="line-modified"> 768      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 769      * sure arguments are checked before the methods are called. While
 770      * some rudimentary checks are performed on the input, the checks
 771      * are best effort and when performance is an overriding priority,
 772      * as when methods of this class are optimized by the runtime
 773      * compiler, some or all checks (if any) may be elided. Hence, the
 774      * caller must not rely on the checks and corresponding
 775      * exceptions!
 776      *
 777      * @throws RuntimeException if any of the arguments is invalid
 778      *
 779      * @since 1.7
 780      */
 781     public void copyMemory(Object srcBase, long srcOffset,
 782                            Object destBase, long destOffset,
 783                            long bytes) {
 784         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 785 
 786         if (bytes == 0) {
 787             return;
 788         }
</pre>
<hr />
<pre>
 809      *         go undetected, which will lead to unpredictable
 810      *         behavior)
 811      */
 812     private void copyMemoryChecks(Object srcBase, long srcOffset,
 813                                   Object destBase, long destOffset,
 814                                   long bytes) {
 815         checkSize(bytes);
 816         checkPrimitivePointer(srcBase, srcOffset);
 817         checkPrimitivePointer(destBase, destOffset);
 818     }
 819 
 820     /**
 821      * Copies all elements from one block of memory to another block,
 822      * *unconditionally* byte swapping the elements on the fly.
 823      *
 824      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 825      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 826      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 827      * the offset supplies an absolute base address.
 828      *
<span class="line-modified"> 829      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 830      * sure arguments are checked before the methods are called. While
 831      * some rudimentary checks are performed on the input, the checks
 832      * are best effort and when performance is an overriding priority,
 833      * as when methods of this class are optimized by the runtime
 834      * compiler, some or all checks (if any) may be elided. Hence, the
 835      * caller must not rely on the checks and corresponding
 836      * exceptions!
 837      *
 838      * @throws RuntimeException if any of the arguments is invalid
 839      *
 840      * @since 9
 841      */
 842     public void copySwapMemory(Object srcBase, long srcOffset,
 843                                Object destBase, long destOffset,
 844                                long bytes, long elemSize) {
 845         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 846 
 847         if (bytes == 0) {
 848             return;
 849         }
</pre>
<hr />
<pre>
 868     }
 869 
 870    /**
 871      * Copies all elements from one block of memory to another block, byte swapping the
 872      * elements on the fly.
 873      *
 874      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 875      * discussed in {@link #getInt(Object,long)}.
 876      *
 877      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 878      */
 879     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 880         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 881     }
 882 
 883     /**
 884      * Disposes of a block of native memory, as obtained from {@link
 885      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 886      * this method may be null, in which case no action is taken.
 887      *
<span class="line-modified"> 888      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
 889      * sure arguments are checked before the methods are called. While
 890      * some rudimentary checks are performed on the input, the checks
 891      * are best effort and when performance is an overriding priority,
 892      * as when methods of this class are optimized by the runtime
 893      * compiler, some or all checks (if any) may be elided. Hence, the
 894      * caller must not rely on the checks and corresponding
 895      * exceptions!
 896      *
 897      * @throws RuntimeException if any of the arguments is invalid
 898      *
 899      * @see #allocateMemory
 900      */
 901     public void freeMemory(long address) {
 902         freeMemoryChecks(address);
 903 
 904         if (address == 0) {
 905             return;
 906         }
 907 
 908         freeMemory0(address);
 909     }
 910 
 911     /**
 912      * Validate the arguments to freeMemory
 913      *
 914      * @throws RuntimeException if the arguments are invalid
 915      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 916      *         go undetected, which will lead to unpredictable
 917      *         behavior)
 918      */
 919     private void freeMemoryChecks(long address) {
 920         checkPointer(null, address);
 921     }
 922 































































































 923     /// random queries
 924 
 925     /**
 926      * This constant differs from all results that will ever be returned from
 927      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
 928      * or {@link #arrayBaseOffset}.
 929      */
 930     public static final int INVALID_FIELD_OFFSET = -1;
 931 
 932     /**
 933      * Reports the location of a given field in the storage allocation of its
 934      * class.  Do not expect to perform any sort of arithmetic on this offset;
 935      * it is just a cookie which is passed to the unsafe heap memory accessors.
 936      *
 937      * &lt;p&gt;Any given field will always have the same offset and base, and no
 938      * two distinct fields of the same class will ever have the same offset
 939      * and base.
 940      *
 941      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 942      * although the Sun JVM does not use the most significant 32 bits.
</pre>
<hr />
<pre>
1149 
1150     /** The value of {@code arrayIndexScale(double[].class)} */
1151     public static final int ARRAY_DOUBLE_INDEX_SCALE
1152             = theUnsafe.arrayIndexScale(double[].class);
1153 
1154     /** The value of {@code arrayIndexScale(Object[].class)} */
1155     public static final int ARRAY_OBJECT_INDEX_SCALE
1156             = theUnsafe.arrayIndexScale(Object[].class);
1157 
1158     /**
1159      * Reports the size in bytes of a native pointer, as stored via {@link
1160      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1161      * other primitive types (as stored in native memory blocks) is determined
1162      * fully by their information content.
1163      */
1164     public int addressSize() {
1165         return ADDRESS_SIZE;
1166     }
1167 
1168     /** The value of {@code addressSize()} */
<span class="line-modified">1169     public static final int ADDRESS_SIZE = theUnsafe.addressSize0();</span>
1170 
1171     /**
1172      * Reports the size in bytes of a native memory page (whatever that is).
1173      * This value will always be a power of two.
1174      */
<span class="line-modified">1175     public native int pageSize();</span>
1176 




















1177 
1178     /// random trusted operations from JNI:
1179 
1180     /**
1181      * Tells the VM to define a class, without security checks.  By default, the
1182      * class loader and protection domain come from the caller&#39;s class.
1183      */
1184     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1185                                 ClassLoader loader,
1186                                 ProtectionDomain protectionDomain) {
1187         if (b == null) {
1188             throw new NullPointerException();
1189         }
1190         if (len &lt; 0) {
1191             throw new ArrayIndexOutOfBoundsException();
1192         }
1193 
1194         return defineClass0(name, b, off, len, loader, protectionDomain);
1195     }
1196 
</pre>
<hr />
<pre>
1400     @HotSpotIntrinsicCandidate
1401     public final boolean weakCompareAndSetIntRelease(Object o, long offset,
1402                                                      int expected,
1403                                                      int x) {
1404         return compareAndSetInt(o, offset, expected, x);
1405     }
1406 
1407     @HotSpotIntrinsicCandidate
1408     public final boolean weakCompareAndSetInt(Object o, long offset,
1409                                               int expected,
1410                                               int x) {
1411         return compareAndSetInt(o, offset, expected, x);
1412     }
1413 
1414     @HotSpotIntrinsicCandidate
1415     public final byte compareAndExchangeByte(Object o, long offset,
1416                                              byte expected,
1417                                              byte x) {
1418         long wordOffset = offset &amp; ~3;
1419         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">1420         if (BE) {</span>
1421             shift = 24 - shift;
1422         }
1423         int mask           = 0xFF &lt;&lt; shift;
1424         int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
1425         int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
1426         int fullWord;
1427         do {
1428             fullWord = getIntVolatile(o, wordOffset);
1429             if ((fullWord &amp; mask) != maskedExpected)
1430                 return (byte) ((fullWord &amp; mask) &gt;&gt; shift);
1431         } while (!weakCompareAndSetInt(o, wordOffset,
1432                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1433         return expected;
1434     }
1435 
1436     @HotSpotIntrinsicCandidate
1437     public final boolean compareAndSetByte(Object o, long offset,
1438                                            byte expected,
1439                                            byte x) {
1440         return compareAndExchangeByte(o, offset, expected, x) == expected;
</pre>
<hr />
<pre>
1474                                                     byte x) {
1475         return compareAndExchangeByte(o, offset, expected, x);
1476     }
1477 
1478     @HotSpotIntrinsicCandidate
1479     public final byte compareAndExchangeByteRelease(Object o, long offset,
1480                                                     byte expected,
1481                                                     byte x) {
1482         return compareAndExchangeByte(o, offset, expected, x);
1483     }
1484 
1485     @HotSpotIntrinsicCandidate
1486     public final short compareAndExchangeShort(Object o, long offset,
1487                                                short expected,
1488                                                short x) {
1489         if ((offset &amp; 3) == 3) {
1490             throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
1491         }
1492         long wordOffset = offset &amp; ~3;
1493         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">1494         if (BE) {</span>
1495             shift = 16 - shift;
1496         }
1497         int mask           = 0xFFFF &lt;&lt; shift;
1498         int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
1499         int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
1500         int fullWord;
1501         do {
1502             fullWord = getIntVolatile(o, wordOffset);
1503             if ((fullWord &amp; mask) != maskedExpected) {
1504                 return (short) ((fullWord &amp; mask) &gt;&gt; shift);
1505             }
1506         } while (!weakCompareAndSetInt(o, wordOffset,
1507                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1508         return expected;
1509     }
1510 
1511     @HotSpotIntrinsicCandidate
1512     public final boolean compareAndSetShort(Object o, long offset,
1513                                             short expected,
1514                                             short x) {
</pre>
<hr />
<pre>
3337      * Throws IllegalAccessError; for use by the VM for access control
3338      * error support.
3339      * @since 1.8
3340      */
3341     private static void throwIllegalAccessError() {
3342         throw new IllegalAccessError();
3343     }
3344 
3345     /**
3346      * Throws NoSuchMethodError; for use by the VM for redefinition support.
3347      * @since 13
3348      */
3349     private static void throwNoSuchMethodError() {
3350         throw new NoSuchMethodError();
3351     }
3352 
3353     /**
3354      * @return Returns true if the native byte ordering of this
3355      * platform is big-endian, false if it is little-endian.
3356      */
<span class="line-modified">3357     public final boolean isBigEndian() { return BE; }</span>
3358 
3359     /**
3360      * @return Returns true if this platform is capable of performing
3361      * accesses at addresses which are not aligned for the type of the
3362      * primitive type being accessed, false otherwise.
3363      */
<span class="line-modified">3364     public final boolean unalignedAccess() { return unalignedAccess; }</span>
3365 
3366     /**
3367      * Fetches a value at some byte offset into a given Java object.
3368      * More specifically, fetches a value within the given object
3369      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
3370      * null) from the memory address whose numerical value is the
3371      * given offset.  &lt;p&gt;
3372      *
3373      * The specification of this method is the same as {@link
3374      * #getLong(Object, long)} except that the offset does not need to
3375      * have been obtained from {@link #objectFieldOffset} on the
3376      * {@link java.lang.reflect.Field} of some Java field.  The value
3377      * in memory is raw data, and need not correspond to any Java
3378      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
3379      * must be entirely within the allocated object.  The endianness
3380      * of the value in memory is the endianness of the native platform.
3381      *
3382      * &lt;p&gt; The read will be atomic with respect to the largest power
3383      * of two that divides the GCD of the offset and the storage size.
3384      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
</pre>
<hr />
<pre>
3586             putShortParts(o, offset,
3587                           (byte)(x &gt;&gt;&gt; 0),
3588                           (byte)(x &gt;&gt;&gt; 8));
3589         }
3590     }
3591     /** @see #putLongUnaligned(Object, long, long, boolean) */
3592     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
3593         putShortUnaligned(o, offset, convEndian(bigEndian, x));
3594     }
3595 
3596     /** @see #putLongUnaligned(Object, long, long) */
3597     @HotSpotIntrinsicCandidate
3598     public final void putCharUnaligned(Object o, long offset, char x) {
3599         putShortUnaligned(o, offset, (short)x);
3600     }
3601     /** @see #putLongUnaligned(Object, long, long, boolean) */
3602     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
3603         putCharUnaligned(o, offset, convEndian(bigEndian, x));
3604     }
3605 
<span class="line-modified">3606     // JVM interface methods</span>
<span class="line-removed">3607     // BE is true iff the native endianness of this platform is big.</span>
<span class="line-removed">3608     private static final boolean BE = theUnsafe.isBigEndian0();</span>
<span class="line-removed">3609 </span>
<span class="line-removed">3610     // unalignedAccess is true iff this platform can perform unaligned accesses.</span>
<span class="line-removed">3611     private static final boolean unalignedAccess = theUnsafe.unalignedAccess0();</span>
<span class="line-removed">3612 </span>
<span class="line-removed">3613     private static int pickPos(int top, int pos) { return BE ? top - pos : pos; }</span>
3614 
3615     // These methods construct integers from bytes.  The byte ordering
3616     // is the native endianness of this platform.
3617     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3618         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
3619               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
3620               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
3621               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
3622               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
3623               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
3624               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
3625               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
3626     }
3627     private static long makeLong(short i0, short i1, short i2, short i3) {
3628         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
3629               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
3630               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
3631               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
3632     }
3633     private static long makeLong(int i0, int i1) {
3634         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
3635              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
3636     }
3637     private static int makeInt(short i0, short i1) {
3638         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
3639              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
3640     }
3641     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
3642         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
3643               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
3644               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
3645               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
3646     }
3647     private static short makeShort(byte i0, byte i1) {
3648         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
3649                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
3650     }
3651 
<span class="line-modified">3652     private static byte  pick(byte  le, byte  be) { return BE ? be : le; }</span>
<span class="line-modified">3653     private static short pick(short le, short be) { return BE ? be : le; }</span>
<span class="line-modified">3654     private static int   pick(int   le, int   be) { return BE ? be : le; }</span>
3655 
3656     // These methods write integers to memory from smaller parts
3657     // provided by their caller.  The ordering in which these parts
3658     // are written is the native endianness of this platform.
3659     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3660         putByte(o, offset + 0, pick(i0, i7));
3661         putByte(o, offset + 1, pick(i1, i6));
3662         putByte(o, offset + 2, pick(i2, i5));
3663         putByte(o, offset + 3, pick(i3, i4));
3664         putByte(o, offset + 4, pick(i4, i3));
3665         putByte(o, offset + 5, pick(i5, i2));
3666         putByte(o, offset + 6, pick(i6, i1));
3667         putByte(o, offset + 7, pick(i7, i0));
3668     }
3669     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
3670         putShort(o, offset + 0, pick(i0, i3));
3671         putShort(o, offset + 2, pick(i1, i2));
3672         putShort(o, offset + 4, pick(i2, i1));
3673         putShort(o, offset + 6, pick(i3, i0));
3674     }
</pre>
<hr />
<pre>
3682     }
3683     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
3684         putByte(o, offset + 0, pick(i0, i3));
3685         putByte(o, offset + 1, pick(i1, i2));
3686         putByte(o, offset + 2, pick(i2, i1));
3687         putByte(o, offset + 3, pick(i3, i0));
3688     }
3689     private void putShortParts(Object o, long offset, byte i0, byte i1) {
3690         putByte(o, offset + 0, pick(i0, i1));
3691         putByte(o, offset + 1, pick(i1, i0));
3692     }
3693 
3694     // Zero-extend an integer
3695     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
3696     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
3697     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
3698     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
3699     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
3700 
3701     // Maybe byte-reverse an integer
<span class="line-modified">3702     private static char convEndian(boolean big, char n)   { return big == BE ? n : Character.reverseBytes(n); }</span>
<span class="line-modified">3703     private static short convEndian(boolean big, short n) { return big == BE ? n : Short.reverseBytes(n)    ; }</span>
<span class="line-modified">3704     private static int convEndian(boolean big, int n)     { return big == BE ? n : Integer.reverseBytes(n)  ; }</span>
<span class="line-modified">3705     private static long convEndian(boolean big, long n)   { return big == BE ? n : Long.reverseBytes(n)     ; }</span>
3706 
3707 
3708 
3709     private native long allocateMemory0(long bytes);
3710     private native long reallocateMemory0(long address, long bytes);
3711     private native void freeMemory0(long address);
3712     private native void setMemory0(Object o, long offset, long bytes, byte value);
3713     @HotSpotIntrinsicCandidate
3714     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
3715     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
3716     private native long objectFieldOffset0(Field f);
3717     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
3718     private native long staticFieldOffset0(Field f);
3719     private native Object staticFieldBase0(Field f);
3720     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
3721     private native void ensureClassInitialized0(Class&lt;?&gt; c);
3722     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
3723     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
<span class="line-removed">3724     private native int addressSize0();</span>
3725     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
3726     private native int getLoadAverage0(double[] loadavg, int nelems);
<span class="line-removed">3727     private native boolean unalignedAccess0();</span>
<span class="line-removed">3728     private native boolean isBigEndian0();</span>
3729 
3730 
3731     /**
3732      * Invokes the given direct byte buffer&#39;s cleaner, if any.
3733      *
3734      * @param directBuffer a direct byte buffer
3735      * @throws NullPointerException     if {@code directBuffer} is null
3736      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
3737      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
3738      *                                  {@link java.nio.Buffer#duplicate duplicate}
3739      */
3740     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
3741         if (!directBuffer.isDirect())
3742             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
3743 
3744         DirectBuffer db = (DirectBuffer) directBuffer;
3745         if (db.attachment() != null)
3746             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
3747 
3748         Cleaner cleaner = db.cleaner();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.ref.Cleaner;
  30 import jdk.internal.vm.annotation.ForceInline;
  31 import sun.nio.ch.DirectBuffer;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
<span class="line-added">  36 import static jdk.internal.misc.UnsafeConstants.*;</span>
  37 
  38 /**
  39  * A collection of methods for performing low-level, unsafe operations.
  40  * Although the class and all methods are public, use of this class is
  41  * limited because only trusted code can obtain instances of it.
  42  *
<span class="line-modified">  43  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure</span>
  44  * arguments are checked before methods of this class are
  45  * called. While some rudimentary checks are performed on the input,
  46  * the checks are best effort and when performance is an overriding
  47  * priority, as when methods of this class are optimized by the
  48  * runtime compiler, some or all checks (if any) may be elided. Hence,
  49  * the caller must not rely on the checks and corresponding
  50  * exceptions!
  51  *
  52  * @author John R. Rose
  53  * @see #getUnsafe
  54  */
  55 
  56 public final class Unsafe {
  57 
  58     private static native void registerNatives();
  59     static {
  60         registerNatives();
  61     }
  62 
  63     private Unsafe() {}
</pre>
<hr />
<pre>
 408 
 409     /** @see #getAddress(Object, long) */
 410     @ForceInline
 411     public long getAddress(long address) {
 412         return getAddress(null, address);
 413     }
 414 
 415     /** @see #putAddress(Object, long, long) */
 416     @ForceInline
 417     public void putAddress(long address, long x) {
 418         putAddress(null, address, x);
 419     }
 420 
 421 
 422 
 423     /// helper methods for validating various types of objects/values
 424 
 425     /**
 426      * Create an exception reflecting that some of the input was invalid
 427      *
<span class="line-modified"> 428      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 429      * sure arguments are checked before the methods are called. While
 430      * some rudimentary checks are performed on the input, the checks
 431      * are best effort and when performance is an overriding priority,
 432      * as when methods of this class are optimized by the runtime
 433      * compiler, some or all checks (if any) may be elided. Hence, the
 434      * caller must not rely on the checks and corresponding
 435      * exceptions!
 436      *
 437      * @return an exception object
 438      */
 439     private RuntimeException invalidInput() {
 440         return new IllegalArgumentException();
 441     }
 442 
 443     /**
 444      * Check if a value is 32-bit clean (32 MSB are all zero)
 445      *
 446      * @param value the 64-bit value to check
 447      *
 448      * @return true if the value is 32-bit clean
</pre>
<hr />
<pre>
 566      *
 567      * Note: pointers off-heap are considered to be primitive arrays
 568      *
 569      * @throws RuntimeException if the pointer is invalid
 570      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 571      *         go undetected, which will lead to unpredictable
 572      *         behavior)
 573      */
 574     private void checkPrimitivePointer(Object o, long offset) {
 575         checkPointer(o, offset);
 576 
 577         if (o != null) {
 578             // If on heap, it must be a primitive array
 579             checkPrimitiveArray(o.getClass());
 580         }
 581     }
 582 
 583 
 584     /// wrappers for malloc, realloc, free:
 585 
<span class="line-added"> 586     /**</span>
<span class="line-added"> 587      * Round up allocation size to a multiple of HeapWordSize.</span>
<span class="line-added"> 588      */</span>
<span class="line-added"> 589     private long alignToHeapWordSize(long bytes) {</span>
<span class="line-added"> 590         if (bytes &gt;= 0) {</span>
<span class="line-added"> 591             return (bytes + ADDRESS_SIZE - 1) &amp; ~(ADDRESS_SIZE - 1);</span>
<span class="line-added"> 592         } else {</span>
<span class="line-added"> 593             throw invalidInput();</span>
<span class="line-added"> 594         }</span>
<span class="line-added"> 595     }</span>
<span class="line-added"> 596 </span>
 597     /**
 598      * Allocates a new block of native memory, of the given size in bytes.  The
 599      * contents of the memory are uninitialized; they will generally be
 600      * garbage.  The resulting native pointer will never be zero, and will be
 601      * aligned for all value types.  Dispose of this memory by calling {@link
 602      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 603      *
<span class="line-modified"> 604      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 605      * sure arguments are checked before the methods are called. While
 606      * some rudimentary checks are performed on the input, the checks
 607      * are best effort and when performance is an overriding priority,
 608      * as when methods of this class are optimized by the runtime
 609      * compiler, some or all checks (if any) may be elided. Hence, the
 610      * caller must not rely on the checks and corresponding
 611      * exceptions!
 612      *
 613      * @throws RuntimeException if the size is negative or too large
 614      *         for the native size_t type
 615      *
 616      * @throws OutOfMemoryError if the allocation is refused by the system
 617      *
 618      * @see #getByte(long)
 619      * @see #putByte(long, byte)
 620      */
 621     public long allocateMemory(long bytes) {
<span class="line-added"> 622         bytes = alignToHeapWordSize(bytes);</span>
<span class="line-added"> 623 </span>
 624         allocateMemoryChecks(bytes);
 625 
 626         if (bytes == 0) {
 627             return 0;
 628         }
 629 
 630         long p = allocateMemory0(bytes);
 631         if (p == 0) {
 632             throw new OutOfMemoryError();
 633         }
 634 
 635         return p;
 636     }
 637 
 638     /**
 639      * Validate the arguments to allocateMemory
 640      *
 641      * @throws RuntimeException if the arguments are invalid
 642      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 643      *         go undetected, which will lead to unpredictable
 644      *         behavior)
 645      */
 646     private void allocateMemoryChecks(long bytes) {
 647         checkSize(bytes);
 648     }
 649 
 650     /**
 651      * Resizes a new block of native memory, to the given size in bytes.  The
 652      * contents of the new block past the size of the old block are
 653      * uninitialized; they will generally be garbage.  The resulting native
 654      * pointer will be zero if and only if the requested size is zero.  The
 655      * resulting native pointer will be aligned for all value types.  Dispose
 656      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 657      * #reallocateMemory}.  The address passed to this method may be null, in
 658      * which case an allocation will be performed.
 659      *
<span class="line-modified"> 660      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 661      * sure arguments are checked before the methods are called. While
 662      * some rudimentary checks are performed on the input, the checks
 663      * are best effort and when performance is an overriding priority,
 664      * as when methods of this class are optimized by the runtime
 665      * compiler, some or all checks (if any) may be elided. Hence, the
 666      * caller must not rely on the checks and corresponding
 667      * exceptions!
 668      *
 669      * @throws RuntimeException if the size is negative or too large
 670      *         for the native size_t type
 671      *
 672      * @throws OutOfMemoryError if the allocation is refused by the system
 673      *
 674      * @see #allocateMemory
 675      */
 676     public long reallocateMemory(long address, long bytes) {
<span class="line-added"> 677         bytes = alignToHeapWordSize(bytes);</span>
<span class="line-added"> 678 </span>
 679         reallocateMemoryChecks(address, bytes);
 680 
 681         if (bytes == 0) {
 682             freeMemory(address);
 683             return 0;
 684         }
 685 
 686         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 687         if (p == 0) {
 688             throw new OutOfMemoryError();
 689         }
 690 
 691         return p;
 692     }
 693 
 694     /**
 695      * Validate the arguments to reallocateMemory
 696      *
 697      * @throws RuntimeException if the arguments are invalid
 698      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
</pre>
<hr />
<pre>
 702     private void reallocateMemoryChecks(long address, long bytes) {
 703         checkPointer(null, address);
 704         checkSize(bytes);
 705     }
 706 
 707     /**
 708      * Sets all bytes in a given block of memory to a fixed value
 709      * (usually zero).
 710      *
 711      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 712      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 713      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 714      * the offset supplies an absolute base address.
 715      *
 716      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 717      * by the address and length parameters.  If the effective address and
 718      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 719      * If the effective address and length are (resp.) even modulo 4 or 2,
 720      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 721      *
<span class="line-modified"> 722      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 723      * sure arguments are checked before the methods are called. While
 724      * some rudimentary checks are performed on the input, the checks
 725      * are best effort and when performance is an overriding priority,
 726      * as when methods of this class are optimized by the runtime
 727      * compiler, some or all checks (if any) may be elided. Hence, the
 728      * caller must not rely on the checks and corresponding
 729      * exceptions!
 730      *
 731      * @throws RuntimeException if any of the arguments is invalid
 732      *
 733      * @since 1.7
 734      */
 735     public void setMemory(Object o, long offset, long bytes, byte value) {
 736         setMemoryChecks(o, offset, bytes, value);
 737 
 738         if (bytes == 0) {
 739             return;
 740         }
 741 
 742         setMemory0(o, offset, bytes, value);
</pre>
<hr />
<pre>
 764     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 765         checkPrimitivePointer(o, offset);
 766         checkSize(bytes);
 767     }
 768 
 769     /**
 770      * Sets all bytes in a given block of memory to a copy of another
 771      * block.
 772      *
 773      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 774      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 775      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 776      * the offset supplies an absolute base address.
 777      *
 778      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 779      * by the address and length parameters.  If the effective addresses and
 780      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 781      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 782      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 783      *
<span class="line-modified"> 784      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 785      * sure arguments are checked before the methods are called. While
 786      * some rudimentary checks are performed on the input, the checks
 787      * are best effort and when performance is an overriding priority,
 788      * as when methods of this class are optimized by the runtime
 789      * compiler, some or all checks (if any) may be elided. Hence, the
 790      * caller must not rely on the checks and corresponding
 791      * exceptions!
 792      *
 793      * @throws RuntimeException if any of the arguments is invalid
 794      *
 795      * @since 1.7
 796      */
 797     public void copyMemory(Object srcBase, long srcOffset,
 798                            Object destBase, long destOffset,
 799                            long bytes) {
 800         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 801 
 802         if (bytes == 0) {
 803             return;
 804         }
</pre>
<hr />
<pre>
 825      *         go undetected, which will lead to unpredictable
 826      *         behavior)
 827      */
 828     private void copyMemoryChecks(Object srcBase, long srcOffset,
 829                                   Object destBase, long destOffset,
 830                                   long bytes) {
 831         checkSize(bytes);
 832         checkPrimitivePointer(srcBase, srcOffset);
 833         checkPrimitivePointer(destBase, destOffset);
 834     }
 835 
 836     /**
 837      * Copies all elements from one block of memory to another block,
 838      * *unconditionally* byte swapping the elements on the fly.
 839      *
 840      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 841      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 842      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 843      * the offset supplies an absolute base address.
 844      *
<span class="line-modified"> 845      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 846      * sure arguments are checked before the methods are called. While
 847      * some rudimentary checks are performed on the input, the checks
 848      * are best effort and when performance is an overriding priority,
 849      * as when methods of this class are optimized by the runtime
 850      * compiler, some or all checks (if any) may be elided. Hence, the
 851      * caller must not rely on the checks and corresponding
 852      * exceptions!
 853      *
 854      * @throws RuntimeException if any of the arguments is invalid
 855      *
 856      * @since 9
 857      */
 858     public void copySwapMemory(Object srcBase, long srcOffset,
 859                                Object destBase, long destOffset,
 860                                long bytes, long elemSize) {
 861         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 862 
 863         if (bytes == 0) {
 864             return;
 865         }
</pre>
<hr />
<pre>
 884     }
 885 
 886    /**
 887      * Copies all elements from one block of memory to another block, byte swapping the
 888      * elements on the fly.
 889      *
 890      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 891      * discussed in {@link #getInt(Object,long)}.
 892      *
 893      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 894      */
 895     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 896         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 897     }
 898 
 899     /**
 900      * Disposes of a block of native memory, as obtained from {@link
 901      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 902      * this method may be null, in which case no action is taken.
 903      *
<span class="line-modified"> 904      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
 905      * sure arguments are checked before the methods are called. While
 906      * some rudimentary checks are performed on the input, the checks
 907      * are best effort and when performance is an overriding priority,
 908      * as when methods of this class are optimized by the runtime
 909      * compiler, some or all checks (if any) may be elided. Hence, the
 910      * caller must not rely on the checks and corresponding
 911      * exceptions!
 912      *
 913      * @throws RuntimeException if any of the arguments is invalid
 914      *
 915      * @see #allocateMemory
 916      */
 917     public void freeMemory(long address) {
 918         freeMemoryChecks(address);
 919 
 920         if (address == 0) {
 921             return;
 922         }
 923 
 924         freeMemory0(address);
 925     }
 926 
 927     /**
 928      * Validate the arguments to freeMemory
 929      *
 930      * @throws RuntimeException if the arguments are invalid
 931      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 932      *         go undetected, which will lead to unpredictable
 933      *         behavior)
 934      */
 935     private void freeMemoryChecks(long address) {
 936         checkPointer(null, address);
 937     }
 938 
<span class="line-added"> 939     /**</span>
<span class="line-added"> 940      * Ensure writeback of a specified virtual memory address range</span>
<span class="line-added"> 941      * from cache to physical memory. All bytes in the address range</span>
<span class="line-added"> 942      * are guaranteed to have been written back to physical memory on</span>
<span class="line-added"> 943      * return from this call i.e. subsequently executed store</span>
<span class="line-added"> 944      * instructions are guaranteed not to be visible before the</span>
<span class="line-added"> 945      * writeback is completed.</span>
<span class="line-added"> 946      *</span>
<span class="line-added"> 947      * @param address</span>
<span class="line-added"> 948      *        the lowest byte address that must be guaranteed written</span>
<span class="line-added"> 949      *        back to memory. bytes at lower addresses may also be</span>
<span class="line-added"> 950      *        written back.</span>
<span class="line-added"> 951      *</span>
<span class="line-added"> 952      * @param length</span>
<span class="line-added"> 953      *        the length in bytes of the region starting at address</span>
<span class="line-added"> 954      *        that must be guaranteed written back to memory.</span>
<span class="line-added"> 955      *</span>
<span class="line-added"> 956      * @throws RuntimeException if memory writeback is not supported</span>
<span class="line-added"> 957      *         on the current hardware of if the arguments are invalid.</span>
<span class="line-added"> 958      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may</span>
<span class="line-added"> 959      *         go undetected, which will lead to unpredictable</span>
<span class="line-added"> 960      *         behavior)</span>
<span class="line-added"> 961      *</span>
<span class="line-added"> 962      * @since 14</span>
<span class="line-added"> 963      */</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965     public void writebackMemory(long address, long length) {</span>
<span class="line-added"> 966         checkWritebackEnabled();</span>
<span class="line-added"> 967         checkWritebackMemory(address, length);</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969         // perform any required pre-writeback barrier</span>
<span class="line-added"> 970         writebackPreSync0();</span>
<span class="line-added"> 971 </span>
<span class="line-added"> 972         // write back one cache line at a time</span>
<span class="line-added"> 973         long line = dataCacheLineAlignDown(address);</span>
<span class="line-added"> 974         long end = address + length;</span>
<span class="line-added"> 975         while (line &lt; end) {</span>
<span class="line-added"> 976             writeback0(line);</span>
<span class="line-added"> 977             line += dataCacheLineFlushSize();</span>
<span class="line-added"> 978         }</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980         // perform any required post-writeback barrier</span>
<span class="line-added"> 981         writebackPostSync0();</span>
<span class="line-added"> 982     }</span>
<span class="line-added"> 983 </span>
<span class="line-added"> 984     /**</span>
<span class="line-added"> 985      * Validate the arguments to writebackMemory</span>
<span class="line-added"> 986      *</span>
<span class="line-added"> 987      * @throws RuntimeException if the arguments are invalid</span>
<span class="line-added"> 988      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may</span>
<span class="line-added"> 989      *         go undetected, which will lead to unpredictable</span>
<span class="line-added"> 990      *         behavior)</span>
<span class="line-added"> 991      */</span>
<span class="line-added"> 992     private void checkWritebackMemory(long address, long length) {</span>
<span class="line-added"> 993         checkNativeAddress(address);</span>
<span class="line-added"> 994         checkSize(length);</span>
<span class="line-added"> 995     }</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997     /**</span>
<span class="line-added"> 998      * Validate that the current hardware supports memory writeback.</span>
<span class="line-added"> 999      * (&lt;em&gt;Note:&lt;/em&gt; this is a belt and braces check.  Clients are</span>
<span class="line-added">1000      * expected to test whether writeback is enabled by calling</span>
<span class="line-added">1001      * ({@link isWritebackEnabled #isWritebackEnabled} and avoid</span>
<span class="line-added">1002      * calling method {@link writeback #writeback} if it is disabled).</span>
<span class="line-added">1003      *</span>
<span class="line-added">1004      *</span>
<span class="line-added">1005      * @throws RuntimeException if memory writeback is not supported</span>
<span class="line-added">1006      */</span>
<span class="line-added">1007     private void checkWritebackEnabled() {</span>
<span class="line-added">1008         if (!isWritebackEnabled()) {</span>
<span class="line-added">1009             throw new RuntimeException(&quot;writebackMemory not enabled!&quot;);</span>
<span class="line-added">1010         }</span>
<span class="line-added">1011     }</span>
<span class="line-added">1012 </span>
<span class="line-added">1013     /**</span>
<span class="line-added">1014      * force writeback of an individual cache line.</span>
<span class="line-added">1015      *</span>
<span class="line-added">1016      * @param address</span>
<span class="line-added">1017      *        the start address of the cache line to be written back</span>
<span class="line-added">1018      */</span>
<span class="line-added">1019     @HotSpotIntrinsicCandidate</span>
<span class="line-added">1020     private native void writeback0(long address);</span>
<span class="line-added">1021 </span>
<span class="line-added">1022      /**</span>
<span class="line-added">1023       * Serialize writeback operations relative to preceding memory writes.</span>
<span class="line-added">1024       */</span>
<span class="line-added">1025     @HotSpotIntrinsicCandidate</span>
<span class="line-added">1026     private native void writebackPreSync0();</span>
<span class="line-added">1027 </span>
<span class="line-added">1028      /**</span>
<span class="line-added">1029       * Serialize writeback operations relative to following memory writes.</span>
<span class="line-added">1030       */</span>
<span class="line-added">1031     @HotSpotIntrinsicCandidate</span>
<span class="line-added">1032     private native void writebackPostSync0();</span>
<span class="line-added">1033 </span>
1034     /// random queries
1035 
1036     /**
1037      * This constant differs from all results that will ever be returned from
1038      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
1039      * or {@link #arrayBaseOffset}.
1040      */
1041     public static final int INVALID_FIELD_OFFSET = -1;
1042 
1043     /**
1044      * Reports the location of a given field in the storage allocation of its
1045      * class.  Do not expect to perform any sort of arithmetic on this offset;
1046      * it is just a cookie which is passed to the unsafe heap memory accessors.
1047      *
1048      * &lt;p&gt;Any given field will always have the same offset and base, and no
1049      * two distinct fields of the same class will ever have the same offset
1050      * and base.
1051      *
1052      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1053      * although the Sun JVM does not use the most significant 32 bits.
</pre>
<hr />
<pre>
1260 
1261     /** The value of {@code arrayIndexScale(double[].class)} */
1262     public static final int ARRAY_DOUBLE_INDEX_SCALE
1263             = theUnsafe.arrayIndexScale(double[].class);
1264 
1265     /** The value of {@code arrayIndexScale(Object[].class)} */
1266     public static final int ARRAY_OBJECT_INDEX_SCALE
1267             = theUnsafe.arrayIndexScale(Object[].class);
1268 
1269     /**
1270      * Reports the size in bytes of a native pointer, as stored via {@link
1271      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1272      * other primitive types (as stored in native memory blocks) is determined
1273      * fully by their information content.
1274      */
1275     public int addressSize() {
1276         return ADDRESS_SIZE;
1277     }
1278 
1279     /** The value of {@code addressSize()} */
<span class="line-modified">1280     public static final int ADDRESS_SIZE = ADDRESS_SIZE0;</span>
1281 
1282     /**
1283      * Reports the size in bytes of a native memory page (whatever that is).
1284      * This value will always be a power of two.
1285      */
<span class="line-modified">1286     public int pageSize() { return PAGE_SIZE; }</span>
1287 
<span class="line-added">1288     /**</span>
<span class="line-added">1289      * Reports the size in bytes of a data cache line written back by</span>
<span class="line-added">1290      * the hardware cache line flush operation available to the JVM or</span>
<span class="line-added">1291      * 0 if data cache line flushing is not enabled.</span>
<span class="line-added">1292      */</span>
<span class="line-added">1293     public int dataCacheLineFlushSize() { return DATA_CACHE_LINE_FLUSH_SIZE; }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295     /**</span>
<span class="line-added">1296      * Rounds down address to a data cache line boundary as</span>
<span class="line-added">1297      * determined by {@link #dataCacheLineFlushSize}</span>
<span class="line-added">1298      * @return the rounded down address</span>
<span class="line-added">1299      */</span>
<span class="line-added">1300     public long dataCacheLineAlignDown(long address) {</span>
<span class="line-added">1301         return (address &amp; ~(DATA_CACHE_LINE_FLUSH_SIZE - 1));</span>
<span class="line-added">1302     }</span>
<span class="line-added">1303 </span>
<span class="line-added">1304     /**</span>
<span class="line-added">1305      * Returns true if data cache line writeback</span>
<span class="line-added">1306      */</span>
<span class="line-added">1307     public static boolean isWritebackEnabled() { return DATA_CACHE_LINE_FLUSH_SIZE != 0; }</span>
1308 
1309     /// random trusted operations from JNI:
1310 
1311     /**
1312      * Tells the VM to define a class, without security checks.  By default, the
1313      * class loader and protection domain come from the caller&#39;s class.
1314      */
1315     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1316                                 ClassLoader loader,
1317                                 ProtectionDomain protectionDomain) {
1318         if (b == null) {
1319             throw new NullPointerException();
1320         }
1321         if (len &lt; 0) {
1322             throw new ArrayIndexOutOfBoundsException();
1323         }
1324 
1325         return defineClass0(name, b, off, len, loader, protectionDomain);
1326     }
1327 
</pre>
<hr />
<pre>
1531     @HotSpotIntrinsicCandidate
1532     public final boolean weakCompareAndSetIntRelease(Object o, long offset,
1533                                                      int expected,
1534                                                      int x) {
1535         return compareAndSetInt(o, offset, expected, x);
1536     }
1537 
1538     @HotSpotIntrinsicCandidate
1539     public final boolean weakCompareAndSetInt(Object o, long offset,
1540                                               int expected,
1541                                               int x) {
1542         return compareAndSetInt(o, offset, expected, x);
1543     }
1544 
1545     @HotSpotIntrinsicCandidate
1546     public final byte compareAndExchangeByte(Object o, long offset,
1547                                              byte expected,
1548                                              byte x) {
1549         long wordOffset = offset &amp; ~3;
1550         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">1551         if (BIG_ENDIAN) {</span>
1552             shift = 24 - shift;
1553         }
1554         int mask           = 0xFF &lt;&lt; shift;
1555         int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
1556         int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
1557         int fullWord;
1558         do {
1559             fullWord = getIntVolatile(o, wordOffset);
1560             if ((fullWord &amp; mask) != maskedExpected)
1561                 return (byte) ((fullWord &amp; mask) &gt;&gt; shift);
1562         } while (!weakCompareAndSetInt(o, wordOffset,
1563                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1564         return expected;
1565     }
1566 
1567     @HotSpotIntrinsicCandidate
1568     public final boolean compareAndSetByte(Object o, long offset,
1569                                            byte expected,
1570                                            byte x) {
1571         return compareAndExchangeByte(o, offset, expected, x) == expected;
</pre>
<hr />
<pre>
1605                                                     byte x) {
1606         return compareAndExchangeByte(o, offset, expected, x);
1607     }
1608 
1609     @HotSpotIntrinsicCandidate
1610     public final byte compareAndExchangeByteRelease(Object o, long offset,
1611                                                     byte expected,
1612                                                     byte x) {
1613         return compareAndExchangeByte(o, offset, expected, x);
1614     }
1615 
1616     @HotSpotIntrinsicCandidate
1617     public final short compareAndExchangeShort(Object o, long offset,
1618                                                short expected,
1619                                                short x) {
1620         if ((offset &amp; 3) == 3) {
1621             throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
1622         }
1623         long wordOffset = offset &amp; ~3;
1624         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">1625         if (BIG_ENDIAN) {</span>
1626             shift = 16 - shift;
1627         }
1628         int mask           = 0xFFFF &lt;&lt; shift;
1629         int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
1630         int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
1631         int fullWord;
1632         do {
1633             fullWord = getIntVolatile(o, wordOffset);
1634             if ((fullWord &amp; mask) != maskedExpected) {
1635                 return (short) ((fullWord &amp; mask) &gt;&gt; shift);
1636             }
1637         } while (!weakCompareAndSetInt(o, wordOffset,
1638                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1639         return expected;
1640     }
1641 
1642     @HotSpotIntrinsicCandidate
1643     public final boolean compareAndSetShort(Object o, long offset,
1644                                             short expected,
1645                                             short x) {
</pre>
<hr />
<pre>
3468      * Throws IllegalAccessError; for use by the VM for access control
3469      * error support.
3470      * @since 1.8
3471      */
3472     private static void throwIllegalAccessError() {
3473         throw new IllegalAccessError();
3474     }
3475 
3476     /**
3477      * Throws NoSuchMethodError; for use by the VM for redefinition support.
3478      * @since 13
3479      */
3480     private static void throwNoSuchMethodError() {
3481         throw new NoSuchMethodError();
3482     }
3483 
3484     /**
3485      * @return Returns true if the native byte ordering of this
3486      * platform is big-endian, false if it is little-endian.
3487      */
<span class="line-modified">3488     public final boolean isBigEndian() { return BIG_ENDIAN; }</span>
3489 
3490     /**
3491      * @return Returns true if this platform is capable of performing
3492      * accesses at addresses which are not aligned for the type of the
3493      * primitive type being accessed, false otherwise.
3494      */
<span class="line-modified">3495     public final boolean unalignedAccess() { return UNALIGNED_ACCESS; }</span>
3496 
3497     /**
3498      * Fetches a value at some byte offset into a given Java object.
3499      * More specifically, fetches a value within the given object
3500      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
3501      * null) from the memory address whose numerical value is the
3502      * given offset.  &lt;p&gt;
3503      *
3504      * The specification of this method is the same as {@link
3505      * #getLong(Object, long)} except that the offset does not need to
3506      * have been obtained from {@link #objectFieldOffset} on the
3507      * {@link java.lang.reflect.Field} of some Java field.  The value
3508      * in memory is raw data, and need not correspond to any Java
3509      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
3510      * must be entirely within the allocated object.  The endianness
3511      * of the value in memory is the endianness of the native platform.
3512      *
3513      * &lt;p&gt; The read will be atomic with respect to the largest power
3514      * of two that divides the GCD of the offset and the storage size.
3515      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
</pre>
<hr />
<pre>
3717             putShortParts(o, offset,
3718                           (byte)(x &gt;&gt;&gt; 0),
3719                           (byte)(x &gt;&gt;&gt; 8));
3720         }
3721     }
3722     /** @see #putLongUnaligned(Object, long, long, boolean) */
3723     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
3724         putShortUnaligned(o, offset, convEndian(bigEndian, x));
3725     }
3726 
3727     /** @see #putLongUnaligned(Object, long, long) */
3728     @HotSpotIntrinsicCandidate
3729     public final void putCharUnaligned(Object o, long offset, char x) {
3730         putShortUnaligned(o, offset, (short)x);
3731     }
3732     /** @see #putLongUnaligned(Object, long, long, boolean) */
3733     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
3734         putCharUnaligned(o, offset, convEndian(bigEndian, x));
3735     }
3736 
<span class="line-modified">3737     private static int pickPos(int top, int pos) { return BIG_ENDIAN ? top - pos : pos; }</span>







3738 
3739     // These methods construct integers from bytes.  The byte ordering
3740     // is the native endianness of this platform.
3741     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3742         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
3743               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
3744               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
3745               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
3746               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
3747               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
3748               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
3749               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
3750     }
3751     private static long makeLong(short i0, short i1, short i2, short i3) {
3752         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
3753               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
3754               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
3755               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
3756     }
3757     private static long makeLong(int i0, int i1) {
3758         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
3759              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
3760     }
3761     private static int makeInt(short i0, short i1) {
3762         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
3763              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
3764     }
3765     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
3766         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
3767               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
3768               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
3769               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
3770     }
3771     private static short makeShort(byte i0, byte i1) {
3772         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
3773                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
3774     }
3775 
<span class="line-modified">3776     private static byte  pick(byte  le, byte  be) { return BIG_ENDIAN ? be : le; }</span>
<span class="line-modified">3777     private static short pick(short le, short be) { return BIG_ENDIAN ? be : le; }</span>
<span class="line-modified">3778     private static int   pick(int   le, int   be) { return BIG_ENDIAN ? be : le; }</span>
3779 
3780     // These methods write integers to memory from smaller parts
3781     // provided by their caller.  The ordering in which these parts
3782     // are written is the native endianness of this platform.
3783     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3784         putByte(o, offset + 0, pick(i0, i7));
3785         putByte(o, offset + 1, pick(i1, i6));
3786         putByte(o, offset + 2, pick(i2, i5));
3787         putByte(o, offset + 3, pick(i3, i4));
3788         putByte(o, offset + 4, pick(i4, i3));
3789         putByte(o, offset + 5, pick(i5, i2));
3790         putByte(o, offset + 6, pick(i6, i1));
3791         putByte(o, offset + 7, pick(i7, i0));
3792     }
3793     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
3794         putShort(o, offset + 0, pick(i0, i3));
3795         putShort(o, offset + 2, pick(i1, i2));
3796         putShort(o, offset + 4, pick(i2, i1));
3797         putShort(o, offset + 6, pick(i3, i0));
3798     }
</pre>
<hr />
<pre>
3806     }
3807     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
3808         putByte(o, offset + 0, pick(i0, i3));
3809         putByte(o, offset + 1, pick(i1, i2));
3810         putByte(o, offset + 2, pick(i2, i1));
3811         putByte(o, offset + 3, pick(i3, i0));
3812     }
3813     private void putShortParts(Object o, long offset, byte i0, byte i1) {
3814         putByte(o, offset + 0, pick(i0, i1));
3815         putByte(o, offset + 1, pick(i1, i0));
3816     }
3817 
3818     // Zero-extend an integer
3819     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
3820     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
3821     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
3822     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
3823     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
3824 
3825     // Maybe byte-reverse an integer
<span class="line-modified">3826     private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }</span>
<span class="line-modified">3827     private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }</span>
<span class="line-modified">3828     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }</span>
<span class="line-modified">3829     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }</span>
3830 
3831 
3832 
3833     private native long allocateMemory0(long bytes);
3834     private native long reallocateMemory0(long address, long bytes);
3835     private native void freeMemory0(long address);
3836     private native void setMemory0(Object o, long offset, long bytes, byte value);
3837     @HotSpotIntrinsicCandidate
3838     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
3839     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
3840     private native long objectFieldOffset0(Field f);
3841     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
3842     private native long staticFieldOffset0(Field f);
3843     private native Object staticFieldBase0(Field f);
3844     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
3845     private native void ensureClassInitialized0(Class&lt;?&gt; c);
3846     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
3847     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);

3848     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
3849     private native int getLoadAverage0(double[] loadavg, int nelems);


3850 
3851 
3852     /**
3853      * Invokes the given direct byte buffer&#39;s cleaner, if any.
3854      *
3855      * @param directBuffer a direct byte buffer
3856      * @throws NullPointerException     if {@code directBuffer} is null
3857      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
3858      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
3859      *                                  {@link java.nio.Buffer#duplicate duplicate}
3860      */
3861     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
3862         if (!directBuffer.isDirect())
3863             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
3864 
3865         DirectBuffer db = (DirectBuffer) directBuffer;
3866         if (db.attachment() != null)
3867             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
3868 
3869         Cleaner cleaner = db.cleaner();
</pre>
</td>
</tr>
</table>
<center><a href="../math/FloatingDecimal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ArchivedModuleGraph.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
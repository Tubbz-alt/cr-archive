diff a/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java b/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java
--- a/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java
@@ -41,10 +41,12 @@
 import java.lang.reflect.Modifier;
 import java.security.PrivilegedAction;
 import java.util.Objects;
 import java.util.Properties;
 
+import jdk.internal.access.JavaLangReflectAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import sun.reflect.misc.ReflectUtil;
 import sun.security.action.GetPropertyAction;
 import sun.security.util.SecurityConstants;
 
@@ -62,12 +64,11 @@
 
 public class ReflectionFactory {
 
     private static boolean initted = false;
     private static final ReflectionFactory soleInstance = new ReflectionFactory();
-    // Provides access to package-private mechanisms in java.lang.reflect
-    private static volatile LangReflectAccess langReflectAccess;
+
 
     /* Method for static class initializer <clinit>, or null */
     private static volatile Method hasStaticInitializerMethod;
 
     //
@@ -88,11 +89,13 @@
     private static int     inflationThreshold = 15;
 
     // true if deserialization constructor checking is disabled
     private static boolean disableSerialConstructorChecks = false;
 
+    private final JavaLangReflectAccess langReflectAccess;
     private ReflectionFactory() {
+        this.langReflectAccess = SharedSecrets.getJavaLangReflectAccess();
     }
 
     /**
      * A convenience class for acquiring the capability to instantiate
      * reflective objects.  Use this instead of a raw call to {@link
@@ -158,26 +161,21 @@
     //
     // Routines used by java.lang.reflect
     //
     //
 
-    /** Called only by java.lang.reflect.Modifier's static initializer */
-    public void setLangReflectAccess(LangReflectAccess access) {
-        langReflectAccess = access;
-    }
-
-    /**
+    /*
      * Note: this routine can cause the declaring class for the field
      * be initialized and therefore must not be called until the
      * first get/set of this field.
      * @param field the field
      * @param override true if caller has overridden accessibility
      */
     public FieldAccessor newFieldAccessor(Field field, boolean override) {
         checkInitted();
 
-        Field root = langReflectAccess().getRoot(field);
+        Field root = langReflectAccess.getRoot(field);
         if (root != null) {
             // FieldAccessor will use the root unless the modifiers have
             // been overrridden
             if (root.getModifiers() == field.getModifiers() || !override) {
                 field = root;
@@ -195,11 +193,11 @@
                 method = altMethod;
             }
         }
 
         // use the root Method that will not cache caller class
-        Method root = langReflectAccess().getRoot(method);
+        Method root = langReflectAccess.getRoot(method);
         if (root != null) {
             method = root;
         }
 
         if (noInflation && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
@@ -231,11 +229,11 @@
             return new InstantiationExceptionConstructorAccessorImpl
                 ("Can not instantiate java.lang.Class");
         }
 
         // use the root Constructor that will not cache caller class
-        Constructor<?> root = langReflectAccess().getRoot(c);
+        Constructor<?> root = langReflectAccess.getRoot(c);
         if (root != null) {
             c = root;
         }
 
         // Bootstrapping issue: since we use Class.newInstance() in
@@ -266,56 +264,10 @@
     //
     // Routines used by java.lang
     //
     //
 
-    /** Creates a new java.lang.reflect.Field. Access checks as per
-        java.lang.reflect.AccessibleObject are not overridden. */
-    public Field newField(Class<?> declaringClass,
-                          String name,
-                          Class<?> type,
-                          int modifiers,
-                          int slot,
-                          String signature,
-                          byte[] annotations)
-    {
-        return langReflectAccess().newField(declaringClass,
-                                            name,
-                                            type,
-                                            modifiers,
-                                            slot,
-                                            signature,
-                                            annotations);
-    }
-
-    /** Creates a new java.lang.reflect.Method. Access checks as per
-        java.lang.reflect.AccessibleObject are not overridden. */
-    public Method newMethod(Class<?> declaringClass,
-                            String name,
-                            Class<?>[] parameterTypes,
-                            Class<?> returnType,
-                            Class<?>[] checkedExceptions,
-                            int modifiers,
-                            int slot,
-                            String signature,
-                            byte[] annotations,
-                            byte[] parameterAnnotations,
-                            byte[] annotationDefault)
-    {
-        return langReflectAccess().newMethod(declaringClass,
-                                             name,
-                                             parameterTypes,
-                                             returnType,
-                                             checkedExceptions,
-                                             modifiers,
-                                             slot,
-                                             signature,
-                                             annotations,
-                                             parameterAnnotations,
-                                             annotationDefault);
-    }
-
     /** Creates a new java.lang.reflect.Constructor. Access checks as
         per java.lang.reflect.AccessibleObject are not overridden. */
     public Constructor<?> newConstructor(Class<?> declaringClass,
                                          Class<?>[] parameterTypes,
                                          Class<?>[] checkedExceptions,
@@ -323,87 +275,77 @@
                                          int slot,
                                          String signature,
                                          byte[] annotations,
                                          byte[] parameterAnnotations)
     {
-        return langReflectAccess().newConstructor(declaringClass,
-                                                  parameterTypes,
-                                                  checkedExceptions,
-                                                  modifiers,
-                                                  slot,
-                                                  signature,
-                                                  annotations,
-                                                  parameterAnnotations);
-    }
-
-    /** Gets the MethodAccessor object for a java.lang.reflect.Method */
-    public MethodAccessor getMethodAccessor(Method m) {
-        return langReflectAccess().getMethodAccessor(m);
-    }
-
-    /** Sets the MethodAccessor object for a java.lang.reflect.Method */
-    public void setMethodAccessor(Method m, MethodAccessor accessor) {
-        langReflectAccess().setMethodAccessor(m, accessor);
+        return langReflectAccess.newConstructor(declaringClass,
+                                                parameterTypes,
+                                                checkedExceptions,
+                                                modifiers,
+                                                slot,
+                                                signature,
+                                                annotations,
+                                                parameterAnnotations);
     }
 
     /** Gets the ConstructorAccessor object for a
         java.lang.reflect.Constructor */
     public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {
-        return langReflectAccess().getConstructorAccessor(c);
+        return langReflectAccess.getConstructorAccessor(c);
     }
 
     /** Sets the ConstructorAccessor object for a
         java.lang.reflect.Constructor */
     public void setConstructorAccessor(Constructor<?> c,
                                        ConstructorAccessor accessor)
     {
-        langReflectAccess().setConstructorAccessor(c, accessor);
+        langReflectAccess.setConstructorAccessor(c, accessor);
     }
 
     /** Makes a copy of the passed method. The returned method is a
         "child" of the passed one; see the comments in Method.java for
         details. */
     public Method copyMethod(Method arg) {
-        return langReflectAccess().copyMethod(arg);
+        return langReflectAccess.copyMethod(arg);
     }
 
     /** Makes a copy of the passed method. The returned method is NOT
      * a "child" but a "sibling" of the Method in arg. Should only be
      * used on non-root methods. */
     public Method leafCopyMethod(Method arg) {
-        return langReflectAccess().leafCopyMethod(arg);
+        return langReflectAccess.leafCopyMethod(arg);
     }
 
 
     /** Makes a copy of the passed field. The returned field is a
         "child" of the passed one; see the comments in Field.java for
         details. */
     public Field copyField(Field arg) {
-        return langReflectAccess().copyField(arg);
+        return langReflectAccess.copyField(arg);
     }
 
     /** Makes a copy of the passed constructor. The returned
         constructor is a "child" of the passed one; see the comments
         in Constructor.java for details. */
     public <T> Constructor<T> copyConstructor(Constructor<T> arg) {
-        return langReflectAccess().copyConstructor(arg);
+        return langReflectAccess.copyConstructor(arg);
     }
 
     /** Gets the byte[] that encodes TypeAnnotations on an executable.
      */
     public byte[] getExecutableTypeAnnotationBytes(Executable ex) {
-        return langReflectAccess().getExecutableTypeAnnotationBytes(ex);
+        return langReflectAccess.getExecutableTypeAnnotationBytes(ex);
     }
 
     public Class<?>[] getExecutableSharedParameterTypes(Executable ex) {
-        return langReflectAccess().getExecutableSharedParameterTypes(ex);
+        return langReflectAccess.getExecutableSharedParameterTypes(ex);
     }
 
     public <T> T newInstance(Constructor<T> ctor, Object[] args, Class<?> caller)
         throws IllegalAccessException, InstantiationException, InvocationTargetException
     {
-        return langReflectAccess().newInstance(ctor, args, caller);
+        return langReflectAccess.newInstance(ctor, args, caller);
     }
 
     //--------------------------------------------------------------------------
     //
     // Routines used by serialization
@@ -524,17 +466,17 @@
                                              constructorToCall.getDeclaringClass());
         Constructor<?> c = newConstructor(constructorToCall.getDeclaringClass(),
                                           constructorToCall.getParameterTypes(),
                                           constructorToCall.getExceptionTypes(),
                                           constructorToCall.getModifiers(),
-                                          langReflectAccess().
+                                          langReflectAccess.
                                           getConstructorSlot(constructorToCall),
-                                          langReflectAccess().
+                                          langReflectAccess.
                                           getConstructorSignature(constructorToCall),
-                                          langReflectAccess().
+                                          langReflectAccess.
                                           getConstructorAnnotations(constructorToCall),
-                                          langReflectAccess().
+                                          langReflectAccess.
                                           getConstructorParameterAnnotations(constructorToCall));
         setConstructorAccessor(c, acc);
         c.setAccessible(true);
         return c;
     }
@@ -723,21 +665,10 @@
             "true".equals(props.getProperty("jdk.disableSerialConstructorChecks"));
 
         initted = true;
     }
 
-    private static LangReflectAccess langReflectAccess() {
-        if (langReflectAccess == null) {
-            // Call a static method to get class java.lang.reflect.Modifier
-            // initialized. Its static initializer will cause
-            // setLangReflectAccess() to be called from the context of the
-            // java.lang.reflect package.
-            Modifier.isPublic(Modifier.PUBLIC);
-        }
-        return langReflectAccess;
-    }
-
     /**
      * Returns true if classes are defined in the classloader and same package, false
      * otherwise.
      * @param cl1 a class
      * @param cl2 another class

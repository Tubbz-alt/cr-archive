<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystemProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.jrtfs;
 26 
 27 import java.io.*;
 28 import java.net.MalformedURLException;
 29 import java.net.URL;
 30 import java.net.URLClassLoader;
 31 import java.nio.channels.*;
 32 import java.nio.file.*;
 33 import java.nio.file.DirectoryStream.Filter;
 34 import java.nio.file.attribute.*;
 35 import java.nio.file.spi.FileSystemProvider;
 36 import java.net.URI;
 37 import java.security.AccessController;
 38 import java.security.PrivilegedAction;
 39 import java.util.HashMap;
 40 import java.util.Map;
 41 import java.util.Objects;
 42 import java.util.Set;
 43 import java.util.concurrent.ExecutorService;
 44 
 45 /**
 46  * File system provider for jrt file systems. Conditionally creates jrt fs on
 47  * .jimage file or exploded modules directory of underlying JDK.
 48  *
 49  * @implNote This class needs to maintain JDK 8 source compatibility.
 50  *
 51  * It is used internally in the JDK to implement jimage/jrtfs access,
 52  * but also compiled and delivered as part of the jrtfs.jar to support access
 53  * to the jimage file provided by the shipped JDK by tools running on JDK 8.
 54  */
 55 public final class JrtFileSystemProvider extends FileSystemProvider {
 56 
 57     private volatile FileSystem theFileSystem;
 58 
 59     public JrtFileSystemProvider() {
 60     }
 61 
 62     @Override
 63     public String getScheme() {
 64         return &quot;jrt&quot;;
 65     }
 66 
 67     /**
 68      * Need RuntimePermission &quot;accessSystemModules&quot; to create or get jrt:/
 69      */
 70     private void checkPermission() {
 71         SecurityManager sm = System.getSecurityManager();
 72         if (sm != null) {
 73             RuntimePermission perm = new RuntimePermission(&quot;accessSystemModules&quot;);
 74             sm.checkPermission(perm);
 75         }
 76     }
 77 
 78     private void checkUri(URI uri) {
 79         if (!uri.getScheme().equalsIgnoreCase(getScheme())) {
 80             throw new IllegalArgumentException(&quot;URI does not match this provider&quot;);
 81         }
 82         if (uri.getAuthority() != null) {
 83             throw new IllegalArgumentException(&quot;Authority component present&quot;);
 84         }
 85         if (uri.getPath() == null) {
 86             throw new IllegalArgumentException(&quot;Path component is undefined&quot;);
 87         }
 88         if (!uri.getPath().equals(&quot;/&quot;)) {
 89             throw new IllegalArgumentException(&quot;Path component should be &#39;/&#39;&quot;);
 90         }
 91         if (uri.getQuery() != null) {
 92             throw new IllegalArgumentException(&quot;Query component present&quot;);
 93         }
 94         if (uri.getFragment() != null) {
 95             throw new IllegalArgumentException(&quot;Fragment component present&quot;);
 96         }
 97     }
 98 
 99     @Override
100     public FileSystem newFileSystem(URI uri, Map&lt;String, ?&gt; env)
101             throws IOException {
102         Objects.requireNonNull(env);
103         checkPermission();
104         checkUri(uri);
105         if (env.containsKey(&quot;java.home&quot;)) {
106             return newFileSystem((String)env.get(&quot;java.home&quot;), uri, env);
107         } else {
108             return new JrtFileSystem(this, env);
109         }
110     }
111 
112     private static final String JRT_FS_JAR = &quot;jrt-fs.jar&quot;;
113     private FileSystem newFileSystem(String targetHome, URI uri, Map&lt;String, ?&gt; env)
114             throws IOException {
115         Objects.requireNonNull(targetHome);
116         Path jrtfs = FileSystems.getDefault().getPath(targetHome, &quot;lib&quot;, JRT_FS_JAR);
117         if (Files.notExists(jrtfs)) {
118             throw new IOException(jrtfs.toString() + &quot; not exist&quot;);
119         }
120         Map&lt;String,?&gt; newEnv = new HashMap&lt;&gt;(env);
121         newEnv.remove(&quot;java.home&quot;);
122         ClassLoader cl = newJrtFsLoader(jrtfs);
123         try {
124             Class&lt;?&gt; c = Class.forName(JrtFileSystemProvider.class.getName(), false, cl);
125             @SuppressWarnings(&quot;deprecation&quot;)
126             Object tmp = c.newInstance();
127             return ((FileSystemProvider)tmp).newFileSystem(uri, newEnv);
128         } catch (ClassNotFoundException |
129                  IllegalAccessException |
130                  InstantiationException e) {
131             throw new IOException(e);
132         }
133     }
134 
135     private static class JrtFsLoader extends URLClassLoader {
136         JrtFsLoader(URL[] urls) {
137             super(urls);
138         }
139         @Override
140         protected Class&lt;?&gt; loadClass(String cn, boolean resolve)
141                 throws ClassNotFoundException
142         {
143             Class&lt;?&gt; c = findLoadedClass(cn);
144             if (c == null) {
145                 URL u = findResource(cn.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
146                 if (u != null) {
147                     c = findClass(cn);
148                 } else {
149                     return super.loadClass(cn, resolve);
150                 }
151             }
152             if (resolve)
153                 resolveClass(c);
154             return c;
155         }
156     }
157 
158     private static URLClassLoader newJrtFsLoader(Path jrtfs) {
159         final URL url;
160         try {
161             url = jrtfs.toUri().toURL();
162         } catch (MalformedURLException mue) {
163             throw new IllegalArgumentException(mue);
164         }
165 
166         final URL[] urls = new URL[] { url };
167         return AccessController.doPrivileged(
168                 new PrivilegedAction&lt;URLClassLoader&gt;() {
169                     @Override
170                     public URLClassLoader run() {
171                         return new JrtFsLoader(urls);
172                     }
173                 }
174         );
175     }
176 
177     @Override
178     public Path getPath(URI uri) {
179         checkPermission();
180         if (!uri.getScheme().equalsIgnoreCase(getScheme())) {
181             throw new IllegalArgumentException(&quot;URI does not match this provider&quot;);
182         }
183         if (uri.getAuthority() != null) {
184             throw new IllegalArgumentException(&quot;Authority component present&quot;);
185         }
186         if (uri.getQuery() != null) {
187             throw new IllegalArgumentException(&quot;Query component present&quot;);
188         }
189         if (uri.getFragment() != null) {
190             throw new IllegalArgumentException(&quot;Fragment component present&quot;);
191         }
192         String path = uri.getPath();
193         if (path == null || path.charAt(0) != &#39;/&#39; || path.contains(&quot;..&quot;)) {
194             throw new IllegalArgumentException(&quot;Invalid path component&quot;);
195         }
196 
197         return getTheFileSystem().getPath(&quot;/modules&quot; + path);
198     }
199 
200     private FileSystem getTheFileSystem() {
201         checkPermission();
202         FileSystem fs = this.theFileSystem;
203         if (fs == null) {
204             synchronized (this) {
205                 fs = this.theFileSystem;
206                 if (fs == null) {
207                     try {
208                         this.theFileSystem = fs = new JrtFileSystem(this, null);
209                     } catch (IOException ioe) {
210                         throw new InternalError(ioe);
211                     }
212                 }
213             }
214         }
215         return fs;
216     }
217 
218     @Override
219     public FileSystem getFileSystem(URI uri) {
220         checkPermission();
221         checkUri(uri);
222         return getTheFileSystem();
223     }
224 
225     // Checks that the given file is a JrtPath
226     static final JrtPath toJrtPath(Path path) {
227         Objects.requireNonNull(path, &quot;path&quot;);
228         if (!(path instanceof JrtPath)) {
229             throw new ProviderMismatchException();
230         }
231         return (JrtPath) path;
232     }
233 
234     @Override
235     public void checkAccess(Path path, AccessMode... modes) throws IOException {
236         toJrtPath(path).checkAccess(modes);
237     }
238 
239     @Override
240     public Path readSymbolicLink(Path link) throws IOException {
241         return toJrtPath(link).readSymbolicLink();
242     }
243 
244     @Override
245     public void copy(Path src, Path target, CopyOption... options)
246             throws IOException {
247         toJrtPath(src).copy(toJrtPath(target), options);
248     }
249 
250     @Override
251     public void createDirectory(Path path, FileAttribute&lt;?&gt;... attrs)
252             throws IOException {
253         toJrtPath(path).createDirectory(attrs);
254     }
255 
256     @Override
257     public final void delete(Path path) throws IOException {
258         toJrtPath(path).delete();
259     }
260 
261     @Override
262     @SuppressWarnings(&quot;unchecked&quot;)
263     public &lt;V extends FileAttributeView&gt; V
264             getFileAttributeView(Path path, Class&lt;V&gt; type, LinkOption... options) {
265         return JrtFileAttributeView.get(toJrtPath(path), type, options);
266     }
267 
268     @Override
269     public FileStore getFileStore(Path path) throws IOException {
270         return toJrtPath(path).getFileStore();
271     }
272 
273     @Override
274     public boolean isHidden(Path path) {
275         return toJrtPath(path).isHidden();
276     }
277 
278     @Override
279     public boolean isSameFile(Path path, Path other) throws IOException {
280         return toJrtPath(path).isSameFile(other);
281     }
282 
283     @Override
284     public void move(Path src, Path target, CopyOption... options)
285             throws IOException {
286         toJrtPath(src).move(toJrtPath(target), options);
287     }
288 
289     @Override
290     public AsynchronousFileChannel newAsynchronousFileChannel(Path path,
291             Set&lt;? extends OpenOption&gt; options,
292             ExecutorService exec,
293             FileAttribute&lt;?&gt;... attrs)
294             throws IOException {
295         throw new UnsupportedOperationException();
296     }
297 
298     @Override
299     public SeekableByteChannel newByteChannel(Path path,
300             Set&lt;? extends OpenOption&gt; options,
301             FileAttribute&lt;?&gt;... attrs)
302             throws IOException {
303         return toJrtPath(path).newByteChannel(options, attrs);
304     }
305 
306     @Override
307     public DirectoryStream&lt;Path&gt; newDirectoryStream(
308             Path path, Filter&lt;? super Path&gt; filter) throws IOException {
309         return toJrtPath(path).newDirectoryStream(filter);
310     }
311 
312     @Override
313     public FileChannel newFileChannel(Path path,
314             Set&lt;? extends OpenOption&gt; options,
315             FileAttribute&lt;?&gt;... attrs)
316             throws IOException {
317         return toJrtPath(path).newFileChannel(options, attrs);
318     }
319 
320     @Override
321     public InputStream newInputStream(Path path, OpenOption... options)
322             throws IOException {
323         return toJrtPath(path).newInputStream(options);
324     }
325 
326     @Override
327     public OutputStream newOutputStream(Path path, OpenOption... options)
328             throws IOException {
329         return toJrtPath(path).newOutputStream(options);
330     }
331 
332     @Override
333     @SuppressWarnings(&quot;unchecked&quot;) // Cast to A
334     public &lt;A extends BasicFileAttributes&gt; A
335             readAttributes(Path path, Class&lt;A&gt; type, LinkOption... options)
336             throws IOException {
337         if (type == BasicFileAttributes.class || type == JrtFileAttributes.class) {
338             return (A) toJrtPath(path).getAttributes(options);
339         }
340         return null;
341     }
342 
343     @Override
344     public Map&lt;String, Object&gt;
345             readAttributes(Path path, String attribute, LinkOption... options)
346             throws IOException {
347         return toJrtPath(path).readAttributes(attribute, options);
348     }
349 
350     @Override
351     public void setAttribute(Path path, String attribute,
352             Object value, LinkOption... options)
353             throws IOException {
354         toJrtPath(path).setAttribute(attribute, value, options);
355     }
356 }
    </pre>
  </body>
</html>
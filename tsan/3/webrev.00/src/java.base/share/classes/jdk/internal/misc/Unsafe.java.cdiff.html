<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../math/FloatingDecimal.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ArchivedModuleGraph.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,17 ***</span>
  import sun.nio.ch.DirectBuffer;
  
  import java.lang.reflect.Field;
  import java.security.ProtectionDomain;
  
  
  /**
   * A collection of methods for performing low-level, unsafe operations.
   * Although the class and all methods are public, use of this class is
   * limited because only trusted code can obtain instances of it.
   *
<span class="line-modified">!  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure</span>
   * arguments are checked before methods of this class are
   * called. While some rudimentary checks are performed on the input,
   * the checks are best effort and when performance is an overriding
   * priority, as when methods of this class are optimized by the
   * runtime compiler, some or all checks (if any) may be elided. Hence,
<span class="line-new-header">--- 31,18 ---</span>
  import sun.nio.ch.DirectBuffer;
  
  import java.lang.reflect.Field;
  import java.security.ProtectionDomain;
  
<span class="line-added">+ import static jdk.internal.misc.UnsafeConstants.*;</span>
  
  /**
   * A collection of methods for performing low-level, unsafe operations.
   * Although the class and all methods are public, use of this class is
   * limited because only trusted code can obtain instances of it.
   *
<span class="line-modified">!  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure</span>
   * arguments are checked before methods of this class are
   * called. While some rudimentary checks are performed on the input,
   * the checks are best effort and when performance is an overriding
   * priority, as when methods of this class are optimized by the
   * runtime compiler, some or all checks (if any) may be elided. Hence,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 422,11 ***</span>
      /// helper methods for validating various types of objects/values
  
      /**
       * Create an exception reflecting that some of the input was invalid
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 423,11 ---</span>
      /// helper methods for validating various types of objects/values
  
      /**
       * Create an exception reflecting that some of the input was invalid
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 580,18 ***</span>
      }
  
  
      /// wrappers for malloc, realloc, free:
  
      /**
       * Allocates a new block of native memory, of the given size in bytes.  The
       * contents of the memory are uninitialized; they will generally be
       * garbage.  The resulting native pointer will never be zero, and will be
       * aligned for all value types.  Dispose of this memory by calling {@link
       * #freeMemory}, or resize it with {@link #reallocateMemory}.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 581,29 ---</span>
      }
  
  
      /// wrappers for malloc, realloc, free:
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Round up allocation size to a multiple of HeapWordSize.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private long alignToHeapWordSize(long bytes) {</span>
<span class="line-added">+         if (bytes &gt;= 0) {</span>
<span class="line-added">+             return (bytes + ADDRESS_SIZE - 1) &amp; ~(ADDRESS_SIZE - 1);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             throw invalidInput();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Allocates a new block of native memory, of the given size in bytes.  The
       * contents of the memory are uninitialized; they will generally be
       * garbage.  The resulting native pointer will never be zero, and will be
       * aligned for all value types.  Dispose of this memory by calling {@link
       * #freeMemory}, or resize it with {@link #reallocateMemory}.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 605,10 ***</span>
<span class="line-new-header">--- 617,12 ---</span>
       *
       * @see #getByte(long)
       * @see #putByte(long, byte)
       */
      public long allocateMemory(long bytes) {
<span class="line-added">+         bytes = alignToHeapWordSize(bytes);</span>
<span class="line-added">+ </span>
          allocateMemoryChecks(bytes);
  
          if (bytes == 0) {
              return 0;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,11 ***</span>
       * resulting native pointer will be aligned for all value types.  Dispose
       * of this memory by calling {@link #freeMemory}, or resize it with {@link
       * #reallocateMemory}.  The address passed to this method may be null, in
       * which case an allocation will be performed.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 655,11 ---</span>
       * resulting native pointer will be aligned for all value types.  Dispose
       * of this memory by calling {@link #freeMemory}, or resize it with {@link
       * #reallocateMemory}.  The address passed to this method may be null, in
       * which case an allocation will be performed.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 658,10 ***</span>
<span class="line-new-header">--- 672,12 ---</span>
       * @throws OutOfMemoryError if the allocation is refused by the system
       *
       * @see #allocateMemory
       */
      public long reallocateMemory(long address, long bytes) {
<span class="line-added">+         bytes = alignToHeapWordSize(bytes);</span>
<span class="line-added">+ </span>
          reallocateMemoryChecks(address, bytes);
  
          if (bytes == 0) {
              freeMemory(address);
              return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,11 ***</span>
       * by the address and length parameters.  If the effective address and
       * length are all even modulo 8, the stores take place in &#39;long&#39; units.
       * If the effective address and length are (resp.) even modulo 4 or 2,
       * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 717,11 ---</span>
       * by the address and length parameters.  If the effective address and
       * length are all even modulo 8, the stores take place in &#39;long&#39; units.
       * If the effective address and length are (resp.) even modulo 4 or 2,
       * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 763,11 ***</span>
       * by the address and length parameters.  If the effective addresses and
       * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
       * If the effective addresses and length are (resp.) even modulo 4 or 2,
       * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 779,11 ---</span>
       * by the address and length parameters.  If the effective addresses and
       * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
       * If the effective addresses and length are (resp.) even modulo 4 or 2,
       * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 824,11 ***</span>
       * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
       * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
       * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
       * the offset supplies an absolute base address.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 840,11 ---</span>
       * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
       * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
       * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
       * the offset supplies an absolute base address.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 883,11 ***</span>
      /**
       * Disposes of a block of native memory, as obtained from {@link
       * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
       * this method may be null, in which case no action is taken.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
<span class="line-new-header">--- 899,11 ---</span>
      /**
       * Disposes of a block of native memory, as obtained from {@link
       * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
       * this method may be null, in which case no action is taken.
       *
<span class="line-modified">!      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make</span>
       * sure arguments are checked before the methods are called. While
       * some rudimentary checks are performed on the input, the checks
       * are best effort and when performance is an overriding priority,
       * as when methods of this class are optimized by the runtime
       * compiler, some or all checks (if any) may be elided. Hence, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,10 ***</span>
<span class="line-new-header">--- 934,105 ---</span>
       */
      private void freeMemoryChecks(long address) {
          checkPointer(null, address);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Ensure writeback of a specified virtual memory address range</span>
<span class="line-added">+      * from cache to physical memory. All bytes in the address range</span>
<span class="line-added">+      * are guaranteed to have been written back to physical memory on</span>
<span class="line-added">+      * return from this call i.e. subsequently executed store</span>
<span class="line-added">+      * instructions are guaranteed not to be visible before the</span>
<span class="line-added">+      * writeback is completed.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param address</span>
<span class="line-added">+      *        the lowest byte address that must be guaranteed written</span>
<span class="line-added">+      *        back to memory. bytes at lower addresses may also be</span>
<span class="line-added">+      *        written back.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param length</span>
<span class="line-added">+      *        the length in bytes of the region starting at address</span>
<span class="line-added">+      *        that must be guaranteed written back to memory.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws RuntimeException if memory writeback is not supported</span>
<span class="line-added">+      *         on the current hardware of if the arguments are invalid.</span>
<span class="line-added">+      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may</span>
<span class="line-added">+      *         go undetected, which will lead to unpredictable</span>
<span class="line-added">+      *         behavior)</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 14</span>
<span class="line-added">+      */</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void writebackMemory(long address, long length) {</span>
<span class="line-added">+         checkWritebackEnabled();</span>
<span class="line-added">+         checkWritebackMemory(address, length);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // perform any required pre-writeback barrier</span>
<span class="line-added">+         writebackPreSync0();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // write back one cache line at a time</span>
<span class="line-added">+         long line = dataCacheLineAlignDown(address);</span>
<span class="line-added">+         long end = address + length;</span>
<span class="line-added">+         while (line &lt; end) {</span>
<span class="line-added">+             writeback0(line);</span>
<span class="line-added">+             line += dataCacheLineFlushSize();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // perform any required post-writeback barrier</span>
<span class="line-added">+         writebackPostSync0();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Validate the arguments to writebackMemory</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws RuntimeException if the arguments are invalid</span>
<span class="line-added">+      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may</span>
<span class="line-added">+      *         go undetected, which will lead to unpredictable</span>
<span class="line-added">+      *         behavior)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void checkWritebackMemory(long address, long length) {</span>
<span class="line-added">+         checkNativeAddress(address);</span>
<span class="line-added">+         checkSize(length);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Validate that the current hardware supports memory writeback.</span>
<span class="line-added">+      * (&lt;em&gt;Note:&lt;/em&gt; this is a belt and braces check.  Clients are</span>
<span class="line-added">+      * expected to test whether writeback is enabled by calling</span>
<span class="line-added">+      * ({@link isWritebackEnabled #isWritebackEnabled} and avoid</span>
<span class="line-added">+      * calling method {@link writeback #writeback} if it is disabled).</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws RuntimeException if memory writeback is not supported</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void checkWritebackEnabled() {</span>
<span class="line-added">+         if (!isWritebackEnabled()) {</span>
<span class="line-added">+             throw new RuntimeException(&quot;writebackMemory not enabled!&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * force writeback of an individual cache line.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param address</span>
<span class="line-added">+      *        the start address of the cache line to be written back</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="line-added">+     private native void writeback0(long address);</span>
<span class="line-added">+ </span>
<span class="line-added">+      /**</span>
<span class="line-added">+       * Serialize writeback operations relative to preceding memory writes.</span>
<span class="line-added">+       */</span>
<span class="line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="line-added">+     private native void writebackPreSync0();</span>
<span class="line-added">+ </span>
<span class="line-added">+      /**</span>
<span class="line-added">+       * Serialize writeback operations relative to following memory writes.</span>
<span class="line-added">+       */</span>
<span class="line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="line-added">+     private native void writebackPostSync0();</span>
<span class="line-added">+ </span>
      /// random queries
  
      /**
       * This constant differs from all results that will ever be returned from
       * {@link #staticFieldOffset}, {@link #objectFieldOffset},
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1164,18 ***</span>
      public int addressSize() {
          return ADDRESS_SIZE;
      }
  
      /** The value of {@code addressSize()} */
<span class="line-modified">!     public static final int ADDRESS_SIZE = theUnsafe.addressSize0();</span>
  
      /**
       * Reports the size in bytes of a native memory page (whatever that is).
       * This value will always be a power of two.
       */
<span class="line-modified">!     public native int pageSize();</span>
  
  
      /// random trusted operations from JNI:
  
      /**
       * Tells the VM to define a class, without security checks.  By default, the
<span class="line-new-header">--- 1275,38 ---</span>
      public int addressSize() {
          return ADDRESS_SIZE;
      }
  
      /** The value of {@code addressSize()} */
<span class="line-modified">!     public static final int ADDRESS_SIZE = ADDRESS_SIZE0;</span>
  
      /**
       * Reports the size in bytes of a native memory page (whatever that is).
       * This value will always be a power of two.
       */
<span class="line-modified">!     public int pageSize() { return PAGE_SIZE; }</span>
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reports the size in bytes of a data cache line written back by</span>
<span class="line-added">+      * the hardware cache line flush operation available to the JVM or</span>
<span class="line-added">+      * 0 if data cache line flushing is not enabled.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public int dataCacheLineFlushSize() { return DATA_CACHE_LINE_FLUSH_SIZE; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Rounds down address to a data cache line boundary as</span>
<span class="line-added">+      * determined by {@link #dataCacheLineFlushSize}</span>
<span class="line-added">+      * @return the rounded down address</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public long dataCacheLineAlignDown(long address) {</span>
<span class="line-added">+         return (address &amp; ~(DATA_CACHE_LINE_FLUSH_SIZE - 1));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns true if data cache line writeback</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static boolean isWritebackEnabled() { return DATA_CACHE_LINE_FLUSH_SIZE != 0; }</span>
  
      /// random trusted operations from JNI:
  
      /**
       * Tells the VM to define a class, without security checks.  By default, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1415,11 ***</span>
      public final byte compareAndExchangeByte(Object o, long offset,
                                               byte expected,
                                               byte x) {
          long wordOffset = offset &amp; ~3;
          int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">!         if (BE) {</span>
              shift = 24 - shift;
          }
          int mask           = 0xFF &lt;&lt; shift;
          int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
          int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
<span class="line-new-header">--- 1546,11 ---</span>
      public final byte compareAndExchangeByte(Object o, long offset,
                                               byte expected,
                                               byte x) {
          long wordOffset = offset &amp; ~3;
          int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">!         if (BIG_ENDIAN) {</span>
              shift = 24 - shift;
          }
          int mask           = 0xFF &lt;&lt; shift;
          int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
          int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1489,11 ***</span>
          if ((offset &amp; 3) == 3) {
              throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
          }
          long wordOffset = offset &amp; ~3;
          int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">!         if (BE) {</span>
              shift = 16 - shift;
          }
          int mask           = 0xFFFF &lt;&lt; shift;
          int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
          int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
<span class="line-new-header">--- 1620,11 ---</span>
          if ((offset &amp; 3) == 3) {
              throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
          }
          long wordOffset = offset &amp; ~3;
          int shift = (int) (offset &amp; 3) &lt;&lt; 3;
<span class="line-modified">!         if (BIG_ENDIAN) {</span>
              shift = 16 - shift;
          }
          int mask           = 0xFFFF &lt;&lt; shift;
          int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
          int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3352,18 ***</span>
  
      /**
       * @return Returns true if the native byte ordering of this
       * platform is big-endian, false if it is little-endian.
       */
<span class="line-modified">!     public final boolean isBigEndian() { return BE; }</span>
  
      /**
       * @return Returns true if this platform is capable of performing
       * accesses at addresses which are not aligned for the type of the
       * primitive type being accessed, false otherwise.
       */
<span class="line-modified">!     public final boolean unalignedAccess() { return unalignedAccess; }</span>
  
      /**
       * Fetches a value at some byte offset into a given Java object.
       * More specifically, fetches a value within the given object
       * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
<span class="line-new-header">--- 3483,18 ---</span>
  
      /**
       * @return Returns true if the native byte ordering of this
       * platform is big-endian, false if it is little-endian.
       */
<span class="line-modified">!     public final boolean isBigEndian() { return BIG_ENDIAN; }</span>
  
      /**
       * @return Returns true if this platform is capable of performing
       * accesses at addresses which are not aligned for the type of the
       * primitive type being accessed, false otherwise.
       */
<span class="line-modified">!     public final boolean unalignedAccess() { return UNALIGNED_ACCESS; }</span>
  
      /**
       * Fetches a value at some byte offset into a given Java object.
       * More specifically, fetches a value within the given object
       * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3601,18 ***</span>
      /** @see #putLongUnaligned(Object, long, long, boolean) */
      public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
          putCharUnaligned(o, offset, convEndian(bigEndian, x));
      }
  
<span class="line-modified">!     // JVM interface methods</span>
<span class="line-removed">-     // BE is true iff the native endianness of this platform is big.</span>
<span class="line-removed">-     private static final boolean BE = theUnsafe.isBigEndian0();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // unalignedAccess is true iff this platform can perform unaligned accesses.</span>
<span class="line-removed">-     private static final boolean unalignedAccess = theUnsafe.unalignedAccess0();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static int pickPos(int top, int pos) { return BE ? top - pos : pos; }</span>
  
      // These methods construct integers from bytes.  The byte ordering
      // is the native endianness of this platform.
      private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
          return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
<span class="line-new-header">--- 3732,11 ---</span>
      /** @see #putLongUnaligned(Object, long, long, boolean) */
      public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
          putCharUnaligned(o, offset, convEndian(bigEndian, x));
      }
  
<span class="line-modified">!     private static int pickPos(int top, int pos) { return BIG_ENDIAN ? top - pos : pos; }</span>
  
      // These methods construct integers from bytes.  The byte ordering
      // is the native endianness of this platform.
      private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
          return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3647,13 ***</span>
      private static short makeShort(byte i0, byte i1) {
          return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
                       | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
      }
  
<span class="line-modified">!     private static byte  pick(byte  le, byte  be) { return BE ? be : le; }</span>
<span class="line-modified">!     private static short pick(short le, short be) { return BE ? be : le; }</span>
<span class="line-modified">!     private static int   pick(int   le, int   be) { return BE ? be : le; }</span>
  
      // These methods write integers to memory from smaller parts
      // provided by their caller.  The ordering in which these parts
      // are written is the native endianness of this platform.
      private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
<span class="line-new-header">--- 3771,13 ---</span>
      private static short makeShort(byte i0, byte i1) {
          return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
                       | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
      }
  
<span class="line-modified">!     private static byte  pick(byte  le, byte  be) { return BIG_ENDIAN ? be : le; }</span>
<span class="line-modified">!     private static short pick(short le, short be) { return BIG_ENDIAN ? be : le; }</span>
<span class="line-modified">!     private static int   pick(int   le, int   be) { return BIG_ENDIAN ? be : le; }</span>
  
      // These methods write integers to memory from smaller parts
      // provided by their caller.  The ordering in which these parts
      // are written is the native endianness of this platform.
      private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3697,14 ***</span>
      private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
      private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
      private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
  
      // Maybe byte-reverse an integer
<span class="line-modified">!     private static char convEndian(boolean big, char n)   { return big == BE ? n : Character.reverseBytes(n); }</span>
<span class="line-modified">!     private static short convEndian(boolean big, short n) { return big == BE ? n : Short.reverseBytes(n)    ; }</span>
<span class="line-modified">!     private static int convEndian(boolean big, int n)     { return big == BE ? n : Integer.reverseBytes(n)  ; }</span>
<span class="line-modified">!     private static long convEndian(boolean big, long n)   { return big == BE ? n : Long.reverseBytes(n)     ; }</span>
  
  
  
      private native long allocateMemory0(long bytes);
      private native long reallocateMemory0(long address, long bytes);
<span class="line-new-header">--- 3821,14 ---</span>
      private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
      private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
      private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
  
      // Maybe byte-reverse an integer
<span class="line-modified">!     private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }</span>
<span class="line-modified">!     private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }</span>
<span class="line-modified">!     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }</span>
<span class="line-modified">!     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }</span>
  
  
  
      private native long allocateMemory0(long bytes);
      private native long reallocateMemory0(long address, long bytes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3719,15 ***</span>
      private native Object staticFieldBase0(Field f);
      private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
      private native void ensureClassInitialized0(Class&lt;?&gt; c);
      private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
      private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
<span class="line-removed">-     private native int addressSize0();</span>
      private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
      private native int getLoadAverage0(double[] loadavg, int nelems);
<span class="line-removed">-     private native boolean unalignedAccess0();</span>
<span class="line-removed">-     private native boolean isBigEndian0();</span>
  
  
      /**
       * Invokes the given direct byte buffer&#39;s cleaner, if any.
       *
<span class="line-new-header">--- 3843,12 ---</span>
</pre>
<center><a href="../math/FloatingDecimal.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ArchivedModuleGraph.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BootLoader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Resource.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,12 ***</span>
   * questions.
   */
  
  package jdk.internal.loader;
  
<span class="line-removed">- import java.io.File;</span>
<span class="line-removed">- import java.io.FilePermission;</span>
  import java.io.IOException;
  import java.io.InputStream;
  import java.lang.module.ModuleDescriptor;
  import java.lang.module.ModuleReference;
  import java.lang.module.ModuleReader;
<span class="line-new-header">--- 23,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,11 ***</span>
  import java.net.URL;
  import java.nio.ByteBuffer;
  import java.security.AccessController;
  import java.security.CodeSigner;
  import java.security.CodeSource;
<span class="line-removed">- import java.security.Permission;</span>
  import java.security.PermissionCollection;
  import java.security.PrivilegedAction;
  import java.security.PrivilegedActionException;
  import java.security.PrivilegedExceptionAction;
  import java.security.SecureClassLoader;
<span class="line-new-header">--- 36,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,10 ***</span>
<span class="line-new-header">--- 59,12 ---</span>
  
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.misc.VM;
  import jdk.internal.module.ModulePatcher.PatchedModuleReader;
  import jdk.internal.module.Resources;
<span class="line-added">+ import jdk.internal.vm.annotation.Stable;</span>
<span class="line-added">+ import sun.security.util.LazyCodeSourcePermissionCollection;</span>
  
  
  /**
   * The platform or application class loader. Resources loaded from modules
   * defined to the boot class loader are also loaded via an instance of this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,28 ***</span>
       * URL to avoid needing to create this URL when defining classes.
       */
      private static class LoadedModule {
          private final BuiltinClassLoader loader;
          private final ModuleReference mref;
<span class="line-modified">!         private final URL codeSourceURL;          // may be null</span>
  
          LoadedModule(BuiltinClassLoader loader, ModuleReference mref) {
              URL url = null;
<span class="line-modified">!             if (mref.location().isPresent()) {</span>
<span class="line-modified">!                 try {</span>
<span class="line-modified">!                     url = mref.location().get().toURL();</span>
<span class="line-modified">!                 } catch (MalformedURLException | IllegalArgumentException e) { }</span>
              }
              this.loader = loader;
              this.mref = mref;
              this.codeSourceURL = url;
          }
  
          BuiltinClassLoader loader() { return loader; }
          ModuleReference mref() { return mref; }
          String name() { return mref.descriptor().name(); }
<span class="line-modified">!         URL codeSourceURL() { return codeSourceURL; }</span>
      }
  
  
      // maps package name to loaded module for modules in the boot layer
      private static final Map&lt;String, LoadedModule&gt; packageToModule
<span class="line-new-header">--- 114,48 ---</span>
       * URL to avoid needing to create this URL when defining classes.
       */
      private static class LoadedModule {
          private final BuiltinClassLoader loader;
          private final ModuleReference mref;
<span class="line-modified">!         private final URI uri;                      // may be null</span>
<span class="line-added">+         private @Stable URL codeSourceURL;          // may be null</span>
  
          LoadedModule(BuiltinClassLoader loader, ModuleReference mref) {
              URL url = null;
<span class="line-modified">!             this.uri = mref.location().orElse(null);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // for non-jrt schemes we need to resolve the codeSourceURL</span>
<span class="line-modified">!             // eagerly during bootstrap since the handler might be</span>
<span class="line-added">+             // overridden</span>
<span class="line-added">+             if (uri != null &amp;&amp; !&quot;jrt&quot;.equals(uri.getScheme())) {</span>
<span class="line-added">+                 url = createURL(uri);</span>
              }
              this.loader = loader;
              this.mref = mref;
              this.codeSourceURL = url;
          }
  
          BuiltinClassLoader loader() { return loader; }
          ModuleReference mref() { return mref; }
          String name() { return mref.descriptor().name(); }
<span class="line-modified">! </span>
<span class="line-added">+         URL codeSourceURL() {</span>
<span class="line-added">+             URL url = codeSourceURL;</span>
<span class="line-added">+             if (url == null &amp;&amp; uri != null) {</span>
<span class="line-added">+                 codeSourceURL = url = createURL(uri);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return url;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private URL createURL(URI uri) {</span>
<span class="line-added">+             URL url = null;</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 url = uri.toURL();</span>
<span class="line-added">+             } catch (MalformedURLException | IllegalArgumentException e) {</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return url;</span>
<span class="line-added">+         }</span>
      }
  
  
      // maps package name to loaded module for modules in the boot layer
      private static final Map&lt;String, LoadedModule&gt; packageToModule
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,11 ***</span>
          super(name, parent == null || parent == ClassLoaders.bootLoader() ? null : parent);
  
          this.parent = parent;
          this.ucp = ucp;
  
<span class="line-modified">!         this.nameToModule = new ConcurrentHashMap&lt;&gt;();</span>
          this.moduleToReader = new ConcurrentHashMap&lt;&gt;();
      }
  
      /**
       * Returns {@code true} if there is a class path associated with this
<span class="line-new-header">--- 179,11 ---</span>
          super(name, parent == null || parent == ClassLoaders.bootLoader() ? null : parent);
  
          this.parent = parent;
          this.ucp = ucp;
  
<span class="line-modified">!         this.nameToModule = new ConcurrentHashMap&lt;&gt;(32);</span>
          this.moduleToReader = new ConcurrentHashMap&lt;&gt;();
      }
  
      /**
       * Returns {@code true} if there is a class path associated with this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,26 ***</span>
      /**
       * Register a module this class loader. This has the effect of making the
       * types in the module visible.
       */
      public void loadModule(ModuleReference mref) {
<span class="line-modified">!         String mn = mref.descriptor().name();</span>
          if (nameToModule.putIfAbsent(mn, mref) != null) {
              throw new InternalError(mn + &quot; already defined to this loader&quot;);
          }
  
          LoadedModule loadedModule = new LoadedModule(this, mref);
<span class="line-modified">!         for (String pn : mref.descriptor().packages()) {</span>
              LoadedModule other = packageToModule.putIfAbsent(pn, loadedModule);
              if (other != null) {
                  throw new InternalError(pn + &quot; in modules &quot; + mn + &quot; and &quot;
<span class="line-modified">!                                         + other.mref().descriptor().name());</span>
              }
          }
  
          // clear resources cache if VM is already initialized
<span class="line-modified">!         if (VM.isModuleSystemInited() &amp;&amp; resourceCache != null) {</span>
              resourceCache = null;
          }
      }
  
      /**
<span class="line-new-header">--- 196,27 ---</span>
      /**
       * Register a module this class loader. This has the effect of making the
       * types in the module visible.
       */
      public void loadModule(ModuleReference mref) {
<span class="line-modified">!         ModuleDescriptor descriptor = mref.descriptor();</span>
<span class="line-added">+         String mn = descriptor.name();</span>
          if (nameToModule.putIfAbsent(mn, mref) != null) {
              throw new InternalError(mn + &quot; already defined to this loader&quot;);
          }
  
          LoadedModule loadedModule = new LoadedModule(this, mref);
<span class="line-modified">!         for (String pn : descriptor.packages()) {</span>
              LoadedModule other = packageToModule.putIfAbsent(pn, loadedModule);
              if (other != null) {
                  throw new InternalError(pn + &quot; in modules &quot; + mn + &quot; and &quot;
<span class="line-modified">!                                         + other.name());</span>
              }
          }
  
          // clear resources cache if VM is already initialized
<span class="line-modified">!         if (resourceCache != null &amp;&amp; VM.isModuleSystemInited()) {</span>
              resourceCache = null;
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 387,12 ***</span>
       */
      private List&lt;URL&gt; findMiscResource(String name) throws IOException {
          SoftReference&lt;Map&lt;String, List&lt;URL&gt;&gt;&gt; ref = this.resourceCache;
          Map&lt;String, List&lt;URL&gt;&gt; map = (ref != null) ? ref.get() : null;
          if (map == null) {
<span class="line-modified">!             map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified">!             this.resourceCache = new SoftReference&lt;&gt;(map);</span>
          } else {
              List&lt;URL&gt; urls = map.get(name);
              if (urls != null)
                  return urls;
          }
<span class="line-new-header">--- 407,15 ---</span>
       */
      private List&lt;URL&gt; findMiscResource(String name) throws IOException {
          SoftReference&lt;Map&lt;String, List&lt;URL&gt;&gt;&gt; ref = this.resourceCache;
          Map&lt;String, List&lt;URL&gt;&gt; map = (ref != null) ? ref.get() : null;
          if (map == null) {
<span class="line-modified">!             // only cache resources after VM is fully initialized</span>
<span class="line-modified">!             if (VM.isModuleSystemInited()) {</span>
<span class="line-added">+                 map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-added">+                 this.resourceCache = new SoftReference&lt;&gt;(map);</span>
<span class="line-added">+             }</span>
          } else {
              List&lt;URL&gt; urls = map.get(name);
              if (urls != null)
                  return urls;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,11 ***</span>
          } catch (PrivilegedActionException pae) {
              throw (IOException) pae.getCause();
          }
  
          // only cache resources after VM is fully initialized
<span class="line-modified">!         if (VM.isModuleSystemInited()) {</span>
              map.putIfAbsent(name, urls);
          }
  
          return urls;
      }
<span class="line-new-header">--- 446,11 ---</span>
          } catch (PrivilegedActionException pae) {
              throw (IOException) pae.getCause();
          }
  
          // only cache resources after VM is fully initialized
<span class="line-modified">!         if (map != null) {</span>
              map.putIfAbsent(name, urls);
          }
  
          return urls;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 943,43 ***</span>
      /**
       * Returns the permissions for the given CodeSource.
       */
      @Override
      protected PermissionCollection getPermissions(CodeSource cs) {
<span class="line-modified">!         PermissionCollection perms = super.getPermissions(cs);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // add the permission to access the resource</span>
<span class="line-removed">-         URL url = cs.getLocation();</span>
<span class="line-removed">-         if (url == null)</span>
<span class="line-removed">-             return perms;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // avoid opening connection when URL is to resource in run-time image</span>
<span class="line-removed">-         if (url.getProtocol().equals(&quot;jrt&quot;)) {</span>
<span class="line-removed">-             perms.add(new RuntimePermission(&quot;accessSystemModules&quot;));</span>
<span class="line-removed">-             return perms;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // open connection to determine the permission needed</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             Permission p = url.openConnection().getPermission();</span>
<span class="line-removed">-             if (p != null) {</span>
<span class="line-removed">-                 // for directories then need recursive access</span>
<span class="line-removed">-                 if (p instanceof FilePermission) {</span>
<span class="line-removed">-                     String path = p.getName();</span>
<span class="line-removed">-                     if (path.endsWith(File.separator)) {</span>
<span class="line-removed">-                         path += &quot;-&quot;;</span>
<span class="line-removed">-                         p = new FilePermission(path, &quot;read&quot;);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 perms.add(p);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } catch (IOException ioe) { }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return perms;</span>
      }
  
<span class="line-removed">- </span>
      // -- miscellaneous supporting methods
  
      /**
       * Returns the ModuleReader for the given module, creating it if needed.
       */
<span class="line-new-header">--- 966,13 ---</span>
      /**
       * Returns the permissions for the given CodeSource.
       */
      @Override
      protected PermissionCollection getPermissions(CodeSource cs) {
<span class="line-modified">!         return new LazyCodeSourcePermissionCollection(super.getPermissions(cs), cs);</span>
      }
  
      // -- miscellaneous supporting methods
  
      /**
       * Returns the ModuleReader for the given module, creating it if needed.
       */
</pre>
<center><a href="BootLoader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Resource.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
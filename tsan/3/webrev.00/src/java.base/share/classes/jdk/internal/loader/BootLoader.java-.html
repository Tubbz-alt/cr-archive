<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/jdk/internal/loader/BootLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.loader;
 26 
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.lang.module.ModuleReference;
 30 import java.net.MalformedURLException;
 31 import java.net.URI;
 32 import java.net.URL;
 33 import java.nio.file.Files;
 34 import java.nio.file.Path;
 35 import java.security.AccessController;
 36 import java.security.PrivilegedAction;
 37 import java.util.Arrays;
 38 import java.util.Enumeration;
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.jar.JarInputStream;
 41 import java.util.jar.Manifest;
 42 import java.util.stream.Stream;
 43 
 44 import jdk.internal.access.JavaLangAccess;
 45 import jdk.internal.access.SharedSecrets;
 46 import jdk.internal.module.Modules;
 47 import jdk.internal.module.ServicesCatalog;
 48 import jdk.internal.util.StaticProperty;
 49 
 50 /**
 51  * Find resources and packages in modules defined to the boot class loader or
 52  * resources and packages on the &quot;boot class path&quot; specified via -Xbootclasspath/a.
 53  */
 54 
 55 public class BootLoader {
 56     private BootLoader() { }
 57 
 58     // The unnamed module for the boot loader
 59     private static final Module UNNAMED_MODULE;
 60     private static final String JAVA_HOME = StaticProperty.javaHome();
 61 
 62     static {
 63         UNNAMED_MODULE = SharedSecrets.getJavaLangAccess().defineUnnamedModule(null);
 64         setBootLoaderUnnamedModule0(UNNAMED_MODULE);
 65     }
 66 
 67     // ServiceCatalog for the boot class loader
 68     private static final ServicesCatalog SERVICES_CATALOG = ServicesCatalog.create();
 69 
 70     // ClassLoaderValue map for the boot class loader
 71     private static final ConcurrentHashMap&lt;?, ?&gt; CLASS_LOADER_VALUE_MAP
 72         = new ConcurrentHashMap&lt;&gt;();
 73 
 74     /**
 75      * Returns the unnamed module for the boot loader.
 76      */
 77     public static Module getUnnamedModule() {
 78         return UNNAMED_MODULE;
 79     }
 80 
 81     /**
 82      * Returns the ServiceCatalog for modules defined to the boot class loader.
 83      */
 84     public static ServicesCatalog getServicesCatalog() {
 85         return SERVICES_CATALOG;
 86     }
 87 
 88     /**
 89      * Returns the ClassLoaderValue map for the boot class loader.
 90      */
 91     public static ConcurrentHashMap&lt;?, ?&gt; getClassLoaderValueMap() {
 92         return CLASS_LOADER_VALUE_MAP;
 93     }
 94 
 95     /**
 96      * Returns {@code true} if there is a class path associated with the
 97      * BootLoader.
 98      */
 99     public static boolean hasClassPath() {
100         return ClassLoaders.bootLoader().hasClassPath();
101     }
102 
103     /**
104      * Registers a module with this class loader so that its classes
105      * (and resources) become visible via this class loader.
106      */
107     public static void loadModule(ModuleReference mref) {
108         ClassLoaders.bootLoader().loadModule(mref);
109     }
110 
111     /**
112      * Loads the Class object with the given name defined to the boot loader.
113      */
114     public static Class&lt;?&gt; loadClassOrNull(String name) {
115         return ClassLoaders.bootLoader().loadClassOrNull(name);
116     }
117 
118     /**
119      * Loads the Class object with the given name in the given module
120      * defined to the boot loader. Returns {@code null} if not found.
121      */
122     public static Class&lt;?&gt; loadClass(Module module, String name) {
123         Class&lt;?&gt; c = loadClassOrNull(name);
124         if (c != null &amp;&amp; c.getModule() == module) {
125             return c;
126         } else {
127             return null;
128         }
129     }
130 
131     /**
132      * Returns a URL to a resource in a module defined to the boot loader.
133      */
134     public static URL findResource(String mn, String name) throws IOException {
135         return ClassLoaders.bootLoader().findResource(mn, name);
136     }
137 
138     /**
139      * Returns an input stream to a resource in a module defined to the
140      * boot loader.
141      */
142     public static InputStream findResourceAsStream(String mn, String name)
143         throws IOException
144     {
145         return ClassLoaders.bootLoader().findResourceAsStream(mn, name);
146     }
147 
148     /**
149      * Returns the URL to the given resource in any of the modules
150      * defined to the boot loader and the boot class path.
151      */
152     public static URL findResource(String name) {
153         return ClassLoaders.bootLoader().findResource(name);
154     }
155 
156     /**
157      * Returns an Iterator to iterate over the resources of the given name
158      * in any of the modules defined to the boot loader.
159      */
160     public static Enumeration&lt;URL&gt; findResources(String name) throws IOException {
161         return ClassLoaders.bootLoader().findResources(name);
162     }
163 
164     /**
165      * Define a package for the given class to the boot loader, if not already
166      * defined.
167      */
168     public static Package definePackage(Class&lt;?&gt; c) {
169         return getDefinedPackage(c.getPackageName());
170     }
171 
172     /**
173      * Returns the Package of the given name defined to the boot loader or null
174      * if the package has not been defined.
175      */
176     public static Package getDefinedPackage(String pn) {
177         Package pkg = ClassLoaders.bootLoader().getDefinedPackage(pn);
178         if (pkg == null) {
179             String location = getSystemPackageLocation(pn.replace(&#39;.&#39;, &#39;/&#39;));
180             if (location != null) {
181                 pkg = PackageHelper.definePackage(pn.intern(), location);
182             }
183         }
184         return pkg;
185     }
186 
187     /**
188      * Returns a stream of the packages defined to the boot loader.
189      */
190     public static Stream&lt;Package&gt; packages() {
191         return Arrays.stream(getSystemPackageNames())
192                      .map(name -&gt; getDefinedPackage(name.replace(&#39;/&#39;, &#39;.&#39;)));
193     }
194 
195     /**
196      * Helper class to define {@code Package} objects for packages in modules
197      * defined to the boot loader.
198      */
199     static class PackageHelper {
200         private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
201 
202         /**
203          * Define the {@code Package} with the given name. The specified
204          * location is a jrt URL to a named module in the run-time image,
205          * a file URL to a module in an exploded run-time image, or a file
206          * path to an entry on the boot class path (java agent Boot-Class-Path
207          * or -Xbootclasspath/a.
208          *
209          * &lt;p&gt; If the given location is a JAR file containing a manifest,
210          * the defined Package contains the versioning information from
211          * the manifest, if present.
212          *
213          * @param name     package name
214          * @param location location where the package is (jrt URL or file URL
215          *                 for a named module in the run-time or exploded image;
216          *                 a file path for a package from -Xbootclasspath/a)
217          */
218         static Package definePackage(String name, String location) {
219             Module module = findModule(location);
220             if (module != null) {
221                 // named module from runtime image or exploded module
222                 if (name.isEmpty())
223                     throw new InternalError(&quot;empty package in &quot; + location);
224                 return JLA.definePackage(ClassLoaders.bootLoader(), name, module);
225             }
226 
227             // package in unnamed module (-Xbootclasspath/a)
228             URL url = toFileURL(location);
229             Manifest man = url != null ? getManifest(location) : null;
230 
231             return ClassLoaders.bootLoader().defineOrCheckPackage(name, man, url);
232         }
233 
234         /**
235          * Finds the module at the given location defined to the boot loader.
236          * The module is either in runtime image or exploded image.
237          * Otherwise this method returns null.
238          */
239         private static Module findModule(String location) {
240             String mn = null;
241             if (location.startsWith(&quot;jrt:/&quot;)) {
242                 // named module in runtime image (&quot;jrt:/&quot;.length() == 5)
243                 mn = location.substring(5, location.length());
244             } else if (location.startsWith(&quot;file:/&quot;)) {
245                 // named module in exploded image
246                 Path path = Path.of(URI.create(location));
247                 Path modulesDir = Path.of(JAVA_HOME, &quot;modules&quot;);
248                 if (path.startsWith(modulesDir)) {
249                     mn = path.getFileName().toString();
250                 }
251             }
252 
253             // return the Module object for the module name. The Module may
254             // in the boot layer or a child layer for the case that the module
255             // is loaded into a running VM
256             if (mn != null) {
257                 String name = mn;
258                 return Modules.findLoadedModule(mn)
259                     .orElseThrow(() -&gt; new InternalError(name + &quot; not loaded&quot;));
260             } else {
261                 return null;
262             }
263         }
264 
265         /**
266          * Returns URL if the given location is a regular file path.
267          */
268         private static URL toFileURL(String location) {
269             return AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
270                 public URL run() {
271                     Path path = Path.of(location);
272                     if (Files.isRegularFile(path)) {
273                         try {
274                             return path.toUri().toURL();
275                         } catch (MalformedURLException e) {}
276                     }
277                     return null;
278                 }
279             });
280         }
281 
282         /**
283          * Returns the Manifest if the given location is a JAR file
284          * containing a manifest.
285          */
286         private static Manifest getManifest(String location) {
287             return AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
288                 public Manifest run() {
289                     Path jar = Path.of(location);
290                     try (InputStream in = Files.newInputStream(jar);
291                          JarInputStream jis = new JarInputStream(in, false)) {
292                         return jis.getManifest();
293                     } catch (IOException e) {
294                         return null;
295                     }
296                 }
297             });
298         }
299     }
300 
301     /**
302      * Returns an array of the binary name of the packages defined by
303      * the boot loader, in VM internal form (forward slashes instead of dot).
304      */
305     private static native String[] getSystemPackageNames();
306 
307     /**
308      * Returns the location of the package of the given name, if
309      * defined by the boot loader; otherwise {@code null} is returned.
310      *
311      * The location may be a module from the runtime image or exploded image,
312      * or from the boot class append path (i.e. -Xbootclasspath/a or
313      * BOOT-CLASS-PATH attribute specified in java agent).
314      */
315     private static native String getSystemPackageLocation(String name);
316     private static native void setBootLoaderUnnamedModule0(Module module);
317 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/perf/Perf.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../org/xml/sax/SAXParseException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../platform/Metrics.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/perf/Perf.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2006, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.perf;
 26 
 27 import java.nio.ByteBuffer;
 28 import java.security.Permission;
 29 import java.security.PrivilegedAction;
 30 import java.io.IOException;
<span class="line-modified"> 31 import java.io.UnsupportedEncodingException;</span>


 32 import jdk.internal.ref.CleanerFactory;
 33 
 34 /**
 35  * The Perf class provides the ability to attach to an instrumentation
 36  * buffer maintained by a Java virtual machine. The instrumentation
 37  * buffer may be for the Java virtual machine running the methods of
 38  * this class or it may be for another Java virtual machine on the
 39  * same system.
 40  * &lt;p&gt;
 41  * In addition, this class provides methods to create instrumentation
 42  * objects in the instrumentation buffer for the Java virtual machine
 43  * that is running these methods. It also contains methods for acquiring
 44  * the value of a platform specific high resolution clock for time
 45  * stamp and interval measurement purposes.
 46  *
 47  * @author   Brian Doherty
 48  * @since    1.4.2
 49  * @see      #getPerf
 50  * @see      jdk.internal.perf.Perf.GetPerfAction
 51  * @see      java.nio.ByteBuffer
</pre>
<hr />
<pre>
396      * Access to the instrument is provided through the returned &lt;code&gt;
397      * ByteBuffer&lt;/code&gt; object.
398      *
399      * @param   variability the variability characteristic for this entry.
400      * @param   units       the units for this entry.
401      * @param   name        the name of this entry.
402      * @param   value       the initial value for this entry.
403      * @param   maxLength   the maximum string length for this string
404      *                      instrument.
405      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
406      *                      write access to a native memory location
407      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
408      *
409      * see sun.misc.perf.Variability
410      * see sun.misc.perf.Units
411      * @see java.nio.ByteBuffer
412      */
413     public ByteBuffer createString(String name, int variability,
414                                    int units, String value, int maxLength)
415     {
<span class="line-modified">416         byte[] v = getBytes(value);</span>
417         byte[] v1 = new byte[v.length+1];
418         System.arraycopy(v, 0, v1, 0, v.length);
419         v1[v.length] = &#39;\0&#39;;
420         return createByteArray(name, variability, units, v1, Math.max(v1.length, maxLength));
421     }
422 
423     /**
424      * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
425      * the given variability characteristic, units, and initial value.
426      * &lt;p&gt;
427      * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
428      * instrument is implied by the length of the &lt;code&gt;value&lt;/code&gt; parameter.
429      * Subsequent updates to the value of this instrument will be truncated
430      * to this implied maximum length. The truncated value will be terminated
431      * by a null character.
432      * &lt;p&gt;
433      * The underlying implementation may further limit the length of the
434      * initial or subsequent value, but will continue to preserve the null
435      * terminator.
436      * &lt;p&gt;
437      * Access to the instrument is provided through the returned &lt;code&gt;
438      * ByteBuffer&lt;/code&gt; object.
439      *
440      * @param   variability the variability characteristic for this entry.
441      * @param   units       the units for this entry.
442      * @param   name        the name of this entry.
443      * @param   value       the initial value for this entry.
444      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
445      *                      write access to a native memory location
446      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
447      *
448      * see sun.misc.perf.Variability
449      * see sun.misc.perf.Units
450      * @see java.nio.ByteBuffer
451      */
452     public ByteBuffer createString(String name, int variability,
453                                    int units, String value)
454     {
<span class="line-modified">455         byte[] v = getBytes(value);</span>
456         byte[] v1 = new byte[v.length+1];
457         System.arraycopy(v, 0, v1, 0, v.length);
458         v1[v.length] = &#39;\0&#39;;
459         return createByteArray(name, variability, units, v1, v1.length);
460     }
461 
462     /**
463      * Create a &lt;code&gt;byte&lt;/code&gt; vector entry in the instrumentation buffer
464      * with the given variability characteristic, units, and initial value.
465      * &lt;p&gt;
466      * The &lt;code&gt;maxLength&lt;/code&gt; parameter limits the size of the byte
467      * array instrument such that the initial or subsequent updates beyond
468      * this length are silently ignored. No special handling of truncated
469      * updates is provided.
470      * &lt;p&gt;
471      * The underlying implementation may further limit the length of the
472      * length of the initial or subsequent value.
473      * &lt;p&gt;
474      * Access to the instrument is provided through the returned &lt;code&gt;
475      * ByteBuffer&lt;/code&gt; object.
476      *
477      * @param   variability the variability characteristic for this entry.
478      * @param   units       the units for this entry.
479      * @param   name        the name of this entry.
480      * @param   value       the initial value for this entry.
481      * @param   maxLength   the maximum length of this byte array.
482      * @return  ByteBuffer  a direct allocated byte buffer that allows
483      *                      write access to a native memory location
484      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
485      *
486      * see sun.misc.perf.Variability
487      * see sun.misc.perf.Units
488      * @see java.nio.ByteBuffer
489      */
490     public native ByteBuffer createByteArray(String name, int variability,
491                                              int units, byte[] value,
492                                              int maxLength);
493 
<span class="line-removed">494 </span>
<span class="line-removed">495     /**</span>
<span class="line-removed">496      * convert string to an array of UTF-8 bytes</span>
<span class="line-removed">497      */</span>
<span class="line-removed">498     private static byte[] getBytes(String s)</span>
<span class="line-removed">499     {</span>
<span class="line-removed">500         byte[] bytes = null;</span>
<span class="line-removed">501 </span>
<span class="line-removed">502         try {</span>
<span class="line-removed">503             bytes = s.getBytes(&quot;UTF-8&quot;);</span>
<span class="line-removed">504         }</span>
<span class="line-removed">505         catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">506             // ignore, UTF-8 encoding is always known</span>
<span class="line-removed">507         }</span>
<span class="line-removed">508 </span>
<span class="line-removed">509         return bytes;</span>
<span class="line-removed">510     }</span>
<span class="line-removed">511 </span>
512     /**
513      * Return the value of the High Resolution Counter.
514      *
515      * The High Resolution Counter returns the number of ticks since
516      * since the start of the Java virtual machine. The resolution of
517      * the counter is machine dependent and can be determined from the
518      * value return by the {@link #highResFrequency} method.
519      *
520      * @return  the number of ticks of machine dependent resolution since
521      *          the start of the Java virtual machine.
522      *
523      * @see #highResFrequency
524      * @see java.lang.System#currentTimeMillis()
525      */
526     public native long highResCounter();
527 
528     /**
529      * Returns the frequency of the High Resolution Counter, in ticks per
530      * second.
531      *
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.internal.perf;
 26 
 27 import java.nio.ByteBuffer;
 28 import java.security.Permission;
 29 import java.security.PrivilegedAction;
 30 import java.io.IOException;
<span class="line-modified"> 31 </span>
<span class="line-added"> 32 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 33 </span>
 34 import jdk.internal.ref.CleanerFactory;
 35 
 36 /**
 37  * The Perf class provides the ability to attach to an instrumentation
 38  * buffer maintained by a Java virtual machine. The instrumentation
 39  * buffer may be for the Java virtual machine running the methods of
 40  * this class or it may be for another Java virtual machine on the
 41  * same system.
 42  * &lt;p&gt;
 43  * In addition, this class provides methods to create instrumentation
 44  * objects in the instrumentation buffer for the Java virtual machine
 45  * that is running these methods. It also contains methods for acquiring
 46  * the value of a platform specific high resolution clock for time
 47  * stamp and interval measurement purposes.
 48  *
 49  * @author   Brian Doherty
 50  * @since    1.4.2
 51  * @see      #getPerf
 52  * @see      jdk.internal.perf.Perf.GetPerfAction
 53  * @see      java.nio.ByteBuffer
</pre>
<hr />
<pre>
398      * Access to the instrument is provided through the returned &lt;code&gt;
399      * ByteBuffer&lt;/code&gt; object.
400      *
401      * @param   variability the variability characteristic for this entry.
402      * @param   units       the units for this entry.
403      * @param   name        the name of this entry.
404      * @param   value       the initial value for this entry.
405      * @param   maxLength   the maximum string length for this string
406      *                      instrument.
407      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
408      *                      write access to a native memory location
409      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
410      *
411      * see sun.misc.perf.Variability
412      * see sun.misc.perf.Units
413      * @see java.nio.ByteBuffer
414      */
415     public ByteBuffer createString(String name, int variability,
416                                    int units, String value, int maxLength)
417     {
<span class="line-modified">418         byte[] v = value.getBytes(UTF_8.INSTANCE);</span>
419         byte[] v1 = new byte[v.length+1];
420         System.arraycopy(v, 0, v1, 0, v.length);
421         v1[v.length] = &#39;\0&#39;;
422         return createByteArray(name, variability, units, v1, Math.max(v1.length, maxLength));
423     }
424 
425     /**
426      * Create a &lt;code&gt;String&lt;/code&gt; entry in the instrumentation buffer with
427      * the given variability characteristic, units, and initial value.
428      * &lt;p&gt;
429      * The maximum length of the &lt;code&gt;String&lt;/code&gt; stored in this string
430      * instrument is implied by the length of the &lt;code&gt;value&lt;/code&gt; parameter.
431      * Subsequent updates to the value of this instrument will be truncated
432      * to this implied maximum length. The truncated value will be terminated
433      * by a null character.
434      * &lt;p&gt;
435      * The underlying implementation may further limit the length of the
436      * initial or subsequent value, but will continue to preserve the null
437      * terminator.
438      * &lt;p&gt;
439      * Access to the instrument is provided through the returned &lt;code&gt;
440      * ByteBuffer&lt;/code&gt; object.
441      *
442      * @param   variability the variability characteristic for this entry.
443      * @param   units       the units for this entry.
444      * @param   name        the name of this entry.
445      * @param   value       the initial value for this entry.
446      * @return  ByteBuffer  a direct allocated ByteBuffer that allows
447      *                      write access to a native memory location
448      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
449      *
450      * see sun.misc.perf.Variability
451      * see sun.misc.perf.Units
452      * @see java.nio.ByteBuffer
453      */
454     public ByteBuffer createString(String name, int variability,
455                                    int units, String value)
456     {
<span class="line-modified">457         byte[] v = value.getBytes(UTF_8.INSTANCE);</span>
458         byte[] v1 = new byte[v.length+1];
459         System.arraycopy(v, 0, v1, 0, v.length);
460         v1[v.length] = &#39;\0&#39;;
461         return createByteArray(name, variability, units, v1, v1.length);
462     }
463 
464     /**
465      * Create a &lt;code&gt;byte&lt;/code&gt; vector entry in the instrumentation buffer
466      * with the given variability characteristic, units, and initial value.
467      * &lt;p&gt;
468      * The &lt;code&gt;maxLength&lt;/code&gt; parameter limits the size of the byte
469      * array instrument such that the initial or subsequent updates beyond
470      * this length are silently ignored. No special handling of truncated
471      * updates is provided.
472      * &lt;p&gt;
473      * The underlying implementation may further limit the length of the
474      * length of the initial or subsequent value.
475      * &lt;p&gt;
476      * Access to the instrument is provided through the returned &lt;code&gt;
477      * ByteBuffer&lt;/code&gt; object.
478      *
479      * @param   variability the variability characteristic for this entry.
480      * @param   units       the units for this entry.
481      * @param   name        the name of this entry.
482      * @param   value       the initial value for this entry.
483      * @param   maxLength   the maximum length of this byte array.
484      * @return  ByteBuffer  a direct allocated byte buffer that allows
485      *                      write access to a native memory location
486      *                      containing a &lt;code&gt;long&lt;/code&gt; value.
487      *
488      * see sun.misc.perf.Variability
489      * see sun.misc.perf.Units
490      * @see java.nio.ByteBuffer
491      */
492     public native ByteBuffer createByteArray(String name, int variability,
493                                              int units, byte[] value,
494                                              int maxLength);
495 


















496     /**
497      * Return the value of the High Resolution Counter.
498      *
499      * The High Resolution Counter returns the number of ticks since
500      * since the start of the Java virtual machine. The resolution of
501      * the counter is machine dependent and can be determined from the
502      * value return by the {@link #highResFrequency} method.
503      *
504      * @return  the number of ticks of machine dependent resolution since
505      *          the start of the Java virtual machine.
506      *
507      * @see #highResFrequency
508      * @see java.lang.System#currentTimeMillis()
509      */
510     public native long highResCounter();
511 
512     /**
513      * Returns the frequency of the High Resolution Counter, in ticks per
514      * second.
515      *
</pre>
</td>
</tr>
</table>
<center><a href="../org/xml/sax/SAXParseException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../platform/Metrics.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
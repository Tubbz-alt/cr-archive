<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BootLoader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Resource.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/loader/BuiltinClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.loader;
  27 
<span class="line-removed">  28 import java.io.File;</span>
<span class="line-removed">  29 import java.io.FilePermission;</span>
  30 import java.io.IOException;
  31 import java.io.InputStream;
  32 import java.lang.module.ModuleDescriptor;
  33 import java.lang.module.ModuleReference;
  34 import java.lang.module.ModuleReader;
  35 import java.lang.ref.SoftReference;
  36 import java.net.MalformedURLException;
  37 import java.net.URI;
  38 import java.net.URL;
  39 import java.nio.ByteBuffer;
  40 import java.security.AccessController;
  41 import java.security.CodeSigner;
  42 import java.security.CodeSource;
<span class="line-removed">  43 import java.security.Permission;</span>
  44 import java.security.PermissionCollection;
  45 import java.security.PrivilegedAction;
  46 import java.security.PrivilegedActionException;
  47 import java.security.PrivilegedExceptionAction;
  48 import java.security.SecureClassLoader;
  49 import java.util.ArrayList;
  50 import java.util.Collections;
  51 import java.util.Enumeration;
  52 import java.util.Iterator;
  53 import java.util.List;
  54 import java.util.Map;
  55 import java.util.NoSuchElementException;
  56 import java.util.Optional;
  57 import java.util.concurrent.ConcurrentHashMap;
  58 import java.util.function.Function;
  59 import java.util.jar.Attributes;
  60 import java.util.jar.Manifest;
  61 import java.util.stream.Stream;
  62 
  63 import jdk.internal.access.SharedSecrets;
  64 import jdk.internal.misc.VM;
  65 import jdk.internal.module.ModulePatcher.PatchedModuleReader;
  66 import jdk.internal.module.Resources;


  67 
  68 
  69 /**
  70  * The platform or application class loader. Resources loaded from modules
  71  * defined to the boot class loader are also loaded via an instance of this
  72  * ClassLoader type.
  73  *
  74  * &lt;p&gt; This ClassLoader supports loading of classes and resources from modules.
  75  * Modules are defined to the ClassLoader by invoking the {@link #loadModule}
  76  * method. Defining a module to this ClassLoader has the effect of making the
  77  * types in the module visible. &lt;/p&gt;
  78  *
  79  * &lt;p&gt; This ClassLoader also supports loading of classes and resources from a
  80  * class path of URLs that are specified to the ClassLoader at construction
  81  * time. The class path may expand at runtime (the Class-Path attribute in JAR
  82  * files or via instrumentation agents). &lt;/p&gt;
  83  *
  84  * &lt;p&gt; The delegation model used by this ClassLoader differs to the regular
  85  * delegation model. When requested to load a class then this ClassLoader first
  86  * maps the class name to its package name. If there is a module defined to a
</pre>
<hr />
<pre>
 100         if (!ClassLoader.registerAsParallelCapable())
 101             throw new InternalError(&quot;Unable to register as parallel capable&quot;);
 102     }
 103 
 104     // parent ClassLoader
 105     private final BuiltinClassLoader parent;
 106 
 107     // the URL class path, or null if there is no class path
 108     private final URLClassPath ucp;
 109 
 110 
 111     /**
 112      * A module defined/loaded by a built-in class loader.
 113      *
 114      * A LoadedModule encapsulates a ModuleReference along with its CodeSource
 115      * URL to avoid needing to create this URL when defining classes.
 116      */
 117     private static class LoadedModule {
 118         private final BuiltinClassLoader loader;
 119         private final ModuleReference mref;
<span class="line-modified"> 120         private final URL codeSourceURL;          // may be null</span>

 121 
 122         LoadedModule(BuiltinClassLoader loader, ModuleReference mref) {
 123             URL url = null;
<span class="line-modified"> 124             if (mref.location().isPresent()) {</span>
<span class="line-modified"> 125                 try {</span>
<span class="line-modified"> 126                     url = mref.location().get().toURL();</span>
<span class="line-modified"> 127                 } catch (MalformedURLException | IllegalArgumentException e) { }</span>



 128             }
 129             this.loader = loader;
 130             this.mref = mref;
 131             this.codeSourceURL = url;
 132         }
 133 
 134         BuiltinClassLoader loader() { return loader; }
 135         ModuleReference mref() { return mref; }
 136         String name() { return mref.descriptor().name(); }
<span class="line-modified"> 137         URL codeSourceURL() { return codeSourceURL; }</span>
















 138     }
 139 
 140 
 141     // maps package name to loaded module for modules in the boot layer
 142     private static final Map&lt;String, LoadedModule&gt; packageToModule
 143         = new ConcurrentHashMap&lt;&gt;(1024);
 144 
 145     // maps a module name to a module reference
 146     private final Map&lt;String, ModuleReference&gt; nameToModule;
 147 
 148     // maps a module reference to a module reader
 149     private final Map&lt;ModuleReference, ModuleReader&gt; moduleToReader;
 150 
 151     // cache of resource name -&gt; list of URLs.
 152     // used only for resources that are not in module packages
 153     private volatile SoftReference&lt;Map&lt;String, List&lt;URL&gt;&gt;&gt; resourceCache;
 154 
 155     /**
 156      * Create a new instance.
 157      */
 158     BuiltinClassLoader(String name, BuiltinClassLoader parent, URLClassPath ucp) {
 159         // ensure getParent() returns null when the parent is the boot loader
 160         super(name, parent == null || parent == ClassLoaders.bootLoader() ? null : parent);
 161 
 162         this.parent = parent;
 163         this.ucp = ucp;
 164 
<span class="line-modified"> 165         this.nameToModule = new ConcurrentHashMap&lt;&gt;();</span>
 166         this.moduleToReader = new ConcurrentHashMap&lt;&gt;();
 167     }
 168 
 169     /**
 170      * Returns {@code true} if there is a class path associated with this
 171      * class loader.
 172      */
 173     boolean hasClassPath() {
 174         return ucp != null;
 175     }
 176 
 177     /**
 178      * Register a module this class loader. This has the effect of making the
 179      * types in the module visible.
 180      */
 181     public void loadModule(ModuleReference mref) {
<span class="line-modified"> 182         String mn = mref.descriptor().name();</span>

 183         if (nameToModule.putIfAbsent(mn, mref) != null) {
 184             throw new InternalError(mn + &quot; already defined to this loader&quot;);
 185         }
 186 
 187         LoadedModule loadedModule = new LoadedModule(this, mref);
<span class="line-modified"> 188         for (String pn : mref.descriptor().packages()) {</span>
 189             LoadedModule other = packageToModule.putIfAbsent(pn, loadedModule);
 190             if (other != null) {
 191                 throw new InternalError(pn + &quot; in modules &quot; + mn + &quot; and &quot;
<span class="line-modified"> 192                                         + other.mref().descriptor().name());</span>
 193             }
 194         }
 195 
 196         // clear resources cache if VM is already initialized
<span class="line-modified"> 197         if (VM.isModuleSystemInited() &amp;&amp; resourceCache != null) {</span>
 198             resourceCache = null;
 199         }
 200     }
 201 
 202     /**
 203      * Returns the {@code ModuleReference} for the named module defined to
 204      * this class loader; or {@code null} if not defined.
 205      *
 206      * @param name The name of the module to find
 207      */
 208     protected ModuleReference findModule(String name) {
 209         return nameToModule.get(name);
 210     }
 211 
 212 
 213     // -- finding resources
 214 
 215     /**
 216      * Returns a URL to a resource of the given name in a module defined to
 217      * this class loader.
</pre>
<hr />
<pre>
 372                     return result;
 373                 } else {
 374                     throw new NoSuchElementException();
 375                 }
 376             }
 377         };
 378 
 379     }
 380 
 381     /**
 382      * Returns the list of URLs to a &quot;miscellaneous&quot; resource in modules
 383      * defined to this loader. A miscellaneous resource is not in a module
 384      * package, e.g. META-INF/services/p.S.
 385      *
 386      * The cache used by this method avoids repeated searching of all modules.
 387      */
 388     private List&lt;URL&gt; findMiscResource(String name) throws IOException {
 389         SoftReference&lt;Map&lt;String, List&lt;URL&gt;&gt;&gt; ref = this.resourceCache;
 390         Map&lt;String, List&lt;URL&gt;&gt; map = (ref != null) ? ref.get() : null;
 391         if (map == null) {
<span class="line-modified"> 392             map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified"> 393             this.resourceCache = new SoftReference&lt;&gt;(map);</span>



 394         } else {
 395             List&lt;URL&gt; urls = map.get(name);
 396             if (urls != null)
 397                 return urls;
 398         }
 399 
 400         // search all modules for the resource
 401         List&lt;URL&gt; urls;
 402         try {
 403             urls = AccessController.doPrivileged(
 404                 new PrivilegedExceptionAction&lt;&gt;() {
 405                     @Override
 406                     public List&lt;URL&gt; run() throws IOException {
 407                         List&lt;URL&gt; result = null;
 408                         for (ModuleReference mref : nameToModule.values()) {
 409                             URI u = moduleReaderFor(mref).find(name).orElse(null);
 410                             if (u != null) {
 411                                 try {
 412                                     if (result == null)
 413                                         result = new ArrayList&lt;&gt;();
 414                                     result.add(u.toURL());
 415                                 } catch (MalformedURLException |
 416                                          IllegalArgumentException e) {
 417                                 }
 418                             }
 419                         }
 420                         return (result != null) ? result : Collections.emptyList();
 421                     }
 422                 });
 423         } catch (PrivilegedActionException pae) {
 424             throw (IOException) pae.getCause();
 425         }
 426 
 427         // only cache resources after VM is fully initialized
<span class="line-modified"> 428         if (VM.isModuleSystemInited()) {</span>
 429             map.putIfAbsent(name, urls);
 430         }
 431 
 432         return urls;
 433     }
 434 
 435     /**
 436      * Returns the URL to a resource in a module or {@code null} if not found.
 437      */
 438     private URL findResource(ModuleReference mref, String name) throws IOException {
 439         URI u;
 440         if (System.getSecurityManager() == null) {
 441             u = moduleReaderFor(mref).find(name).orElse(null);
 442         } else {
 443             try {
 444                 u = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt; () {
 445                     @Override
 446                     public URI run() throws IOException {
 447                         return moduleReaderFor(mref).find(name).orElse(null);
 448                     }
</pre>
<hr />
<pre>
 928      * @throws SecurityException if the package name is untrusted in the manifest
 929      */
 930     private boolean isSealed(String pn, Manifest man) {
 931         Attributes attr = SharedSecrets.javaUtilJarAccess()
 932                 .getTrustedAttributes(man, pn.replace(&#39;.&#39;, &#39;/&#39;).concat(&quot;/&quot;));
 933         String sealed = null;
 934         if (attr != null)
 935             sealed = attr.getValue(Attributes.Name.SEALED);
 936         if (sealed == null &amp;&amp; (attr = man.getMainAttributes()) != null)
 937             sealed = attr.getValue(Attributes.Name.SEALED);
 938         return &quot;true&quot;.equalsIgnoreCase(sealed);
 939     }
 940 
 941     // -- permissions
 942 
 943     /**
 944      * Returns the permissions for the given CodeSource.
 945      */
 946     @Override
 947     protected PermissionCollection getPermissions(CodeSource cs) {
<span class="line-modified"> 948         PermissionCollection perms = super.getPermissions(cs);</span>
<span class="line-removed"> 949 </span>
<span class="line-removed"> 950         // add the permission to access the resource</span>
<span class="line-removed"> 951         URL url = cs.getLocation();</span>
<span class="line-removed"> 952         if (url == null)</span>
<span class="line-removed"> 953             return perms;</span>
<span class="line-removed"> 954 </span>
<span class="line-removed"> 955         // avoid opening connection when URL is to resource in run-time image</span>
<span class="line-removed"> 956         if (url.getProtocol().equals(&quot;jrt&quot;)) {</span>
<span class="line-removed"> 957             perms.add(new RuntimePermission(&quot;accessSystemModules&quot;));</span>
<span class="line-removed"> 958             return perms;</span>
<span class="line-removed"> 959         }</span>
<span class="line-removed"> 960 </span>
<span class="line-removed"> 961         // open connection to determine the permission needed</span>
<span class="line-removed"> 962         try {</span>
<span class="line-removed"> 963             Permission p = url.openConnection().getPermission();</span>
<span class="line-removed"> 964             if (p != null) {</span>
<span class="line-removed"> 965                 // for directories then need recursive access</span>
<span class="line-removed"> 966                 if (p instanceof FilePermission) {</span>
<span class="line-removed"> 967                     String path = p.getName();</span>
<span class="line-removed"> 968                     if (path.endsWith(File.separator)) {</span>
<span class="line-removed"> 969                         path += &quot;-&quot;;</span>
<span class="line-removed"> 970                         p = new FilePermission(path, &quot;read&quot;);</span>
<span class="line-removed"> 971                     }</span>
<span class="line-removed"> 972                 }</span>
<span class="line-removed"> 973                 perms.add(p);</span>
<span class="line-removed"> 974             }</span>
<span class="line-removed"> 975         } catch (IOException ioe) { }</span>
<span class="line-removed"> 976 </span>
<span class="line-removed"> 977         return perms;</span>
 978     }
 979 
<span class="line-removed"> 980 </span>
 981     // -- miscellaneous supporting methods
 982 
 983     /**
 984      * Returns the ModuleReader for the given module, creating it if needed.
 985      */
 986     private ModuleReader moduleReaderFor(ModuleReference mref) {
 987         ModuleReader reader = moduleToReader.get(mref);
 988         if (reader == null) {
 989             // avoid method reference during startup
 990             Function&lt;ModuleReference, ModuleReader&gt; create = new Function&lt;&gt;() {
 991                 public ModuleReader apply(ModuleReference moduleReference) {
 992                     try {
 993                         return mref.open();
 994                     } catch (IOException e) {
 995                         // Return a null module reader to avoid a future class
 996                         // load attempting to open the module again.
 997                         return new NullModuleReader();
 998                     }
 999                 }
1000             };
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.loader;
  27 


  28 import java.io.IOException;
  29 import java.io.InputStream;
  30 import java.lang.module.ModuleDescriptor;
  31 import java.lang.module.ModuleReference;
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.net.MalformedURLException;
  35 import java.net.URI;
  36 import java.net.URL;
  37 import java.nio.ByteBuffer;
  38 import java.security.AccessController;
  39 import java.security.CodeSigner;
  40 import java.security.CodeSource;

  41 import java.security.PermissionCollection;
  42 import java.security.PrivilegedAction;
  43 import java.security.PrivilegedActionException;
  44 import java.security.PrivilegedExceptionAction;
  45 import java.security.SecureClassLoader;
  46 import java.util.ArrayList;
  47 import java.util.Collections;
  48 import java.util.Enumeration;
  49 import java.util.Iterator;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.NoSuchElementException;
  53 import java.util.Optional;
  54 import java.util.concurrent.ConcurrentHashMap;
  55 import java.util.function.Function;
  56 import java.util.jar.Attributes;
  57 import java.util.jar.Manifest;
  58 import java.util.stream.Stream;
  59 
  60 import jdk.internal.access.SharedSecrets;
  61 import jdk.internal.misc.VM;
  62 import jdk.internal.module.ModulePatcher.PatchedModuleReader;
  63 import jdk.internal.module.Resources;
<span class="line-added">  64 import jdk.internal.vm.annotation.Stable;</span>
<span class="line-added">  65 import sun.security.util.LazyCodeSourcePermissionCollection;</span>
  66 
  67 
  68 /**
  69  * The platform or application class loader. Resources loaded from modules
  70  * defined to the boot class loader are also loaded via an instance of this
  71  * ClassLoader type.
  72  *
  73  * &lt;p&gt; This ClassLoader supports loading of classes and resources from modules.
  74  * Modules are defined to the ClassLoader by invoking the {@link #loadModule}
  75  * method. Defining a module to this ClassLoader has the effect of making the
  76  * types in the module visible. &lt;/p&gt;
  77  *
  78  * &lt;p&gt; This ClassLoader also supports loading of classes and resources from a
  79  * class path of URLs that are specified to the ClassLoader at construction
  80  * time. The class path may expand at runtime (the Class-Path attribute in JAR
  81  * files or via instrumentation agents). &lt;/p&gt;
  82  *
  83  * &lt;p&gt; The delegation model used by this ClassLoader differs to the regular
  84  * delegation model. When requested to load a class then this ClassLoader first
  85  * maps the class name to its package name. If there is a module defined to a
</pre>
<hr />
<pre>
  99         if (!ClassLoader.registerAsParallelCapable())
 100             throw new InternalError(&quot;Unable to register as parallel capable&quot;);
 101     }
 102 
 103     // parent ClassLoader
 104     private final BuiltinClassLoader parent;
 105 
 106     // the URL class path, or null if there is no class path
 107     private final URLClassPath ucp;
 108 
 109 
 110     /**
 111      * A module defined/loaded by a built-in class loader.
 112      *
 113      * A LoadedModule encapsulates a ModuleReference along with its CodeSource
 114      * URL to avoid needing to create this URL when defining classes.
 115      */
 116     private static class LoadedModule {
 117         private final BuiltinClassLoader loader;
 118         private final ModuleReference mref;
<span class="line-modified"> 119         private final URI uri;                      // may be null</span>
<span class="line-added"> 120         private @Stable URL codeSourceURL;          // may be null</span>
 121 
 122         LoadedModule(BuiltinClassLoader loader, ModuleReference mref) {
 123             URL url = null;
<span class="line-modified"> 124             this.uri = mref.location().orElse(null);</span>
<span class="line-modified"> 125 </span>
<span class="line-modified"> 126             // for non-jrt schemes we need to resolve the codeSourceURL</span>
<span class="line-modified"> 127             // eagerly during bootstrap since the handler might be</span>
<span class="line-added"> 128             // overridden</span>
<span class="line-added"> 129             if (uri != null &amp;&amp; !&quot;jrt&quot;.equals(uri.getScheme())) {</span>
<span class="line-added"> 130                 url = createURL(uri);</span>
 131             }
 132             this.loader = loader;
 133             this.mref = mref;
 134             this.codeSourceURL = url;
 135         }
 136 
 137         BuiltinClassLoader loader() { return loader; }
 138         ModuleReference mref() { return mref; }
 139         String name() { return mref.descriptor().name(); }
<span class="line-modified"> 140 </span>
<span class="line-added"> 141         URL codeSourceURL() {</span>
<span class="line-added"> 142             URL url = codeSourceURL;</span>
<span class="line-added"> 143             if (url == null &amp;&amp; uri != null) {</span>
<span class="line-added"> 144                 codeSourceURL = url = createURL(uri);</span>
<span class="line-added"> 145             }</span>
<span class="line-added"> 146             return url;</span>
<span class="line-added"> 147         }</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149         private URL createURL(URI uri) {</span>
<span class="line-added"> 150             URL url = null;</span>
<span class="line-added"> 151             try {</span>
<span class="line-added"> 152                 url = uri.toURL();</span>
<span class="line-added"> 153             } catch (MalformedURLException | IllegalArgumentException e) {</span>
<span class="line-added"> 154             }</span>
<span class="line-added"> 155             return url;</span>
<span class="line-added"> 156         }</span>
 157     }
 158 
 159 
 160     // maps package name to loaded module for modules in the boot layer
 161     private static final Map&lt;String, LoadedModule&gt; packageToModule
 162         = new ConcurrentHashMap&lt;&gt;(1024);
 163 
 164     // maps a module name to a module reference
 165     private final Map&lt;String, ModuleReference&gt; nameToModule;
 166 
 167     // maps a module reference to a module reader
 168     private final Map&lt;ModuleReference, ModuleReader&gt; moduleToReader;
 169 
 170     // cache of resource name -&gt; list of URLs.
 171     // used only for resources that are not in module packages
 172     private volatile SoftReference&lt;Map&lt;String, List&lt;URL&gt;&gt;&gt; resourceCache;
 173 
 174     /**
 175      * Create a new instance.
 176      */
 177     BuiltinClassLoader(String name, BuiltinClassLoader parent, URLClassPath ucp) {
 178         // ensure getParent() returns null when the parent is the boot loader
 179         super(name, parent == null || parent == ClassLoaders.bootLoader() ? null : parent);
 180 
 181         this.parent = parent;
 182         this.ucp = ucp;
 183 
<span class="line-modified"> 184         this.nameToModule = new ConcurrentHashMap&lt;&gt;(32);</span>
 185         this.moduleToReader = new ConcurrentHashMap&lt;&gt;();
 186     }
 187 
 188     /**
 189      * Returns {@code true} if there is a class path associated with this
 190      * class loader.
 191      */
 192     boolean hasClassPath() {
 193         return ucp != null;
 194     }
 195 
 196     /**
 197      * Register a module this class loader. This has the effect of making the
 198      * types in the module visible.
 199      */
 200     public void loadModule(ModuleReference mref) {
<span class="line-modified"> 201         ModuleDescriptor descriptor = mref.descriptor();</span>
<span class="line-added"> 202         String mn = descriptor.name();</span>
 203         if (nameToModule.putIfAbsent(mn, mref) != null) {
 204             throw new InternalError(mn + &quot; already defined to this loader&quot;);
 205         }
 206 
 207         LoadedModule loadedModule = new LoadedModule(this, mref);
<span class="line-modified"> 208         for (String pn : descriptor.packages()) {</span>
 209             LoadedModule other = packageToModule.putIfAbsent(pn, loadedModule);
 210             if (other != null) {
 211                 throw new InternalError(pn + &quot; in modules &quot; + mn + &quot; and &quot;
<span class="line-modified"> 212                                         + other.name());</span>
 213             }
 214         }
 215 
 216         // clear resources cache if VM is already initialized
<span class="line-modified"> 217         if (resourceCache != null &amp;&amp; VM.isModuleSystemInited()) {</span>
 218             resourceCache = null;
 219         }
 220     }
 221 
 222     /**
 223      * Returns the {@code ModuleReference} for the named module defined to
 224      * this class loader; or {@code null} if not defined.
 225      *
 226      * @param name The name of the module to find
 227      */
 228     protected ModuleReference findModule(String name) {
 229         return nameToModule.get(name);
 230     }
 231 
 232 
 233     // -- finding resources
 234 
 235     /**
 236      * Returns a URL to a resource of the given name in a module defined to
 237      * this class loader.
</pre>
<hr />
<pre>
 392                     return result;
 393                 } else {
 394                     throw new NoSuchElementException();
 395                 }
 396             }
 397         };
 398 
 399     }
 400 
 401     /**
 402      * Returns the list of URLs to a &quot;miscellaneous&quot; resource in modules
 403      * defined to this loader. A miscellaneous resource is not in a module
 404      * package, e.g. META-INF/services/p.S.
 405      *
 406      * The cache used by this method avoids repeated searching of all modules.
 407      */
 408     private List&lt;URL&gt; findMiscResource(String name) throws IOException {
 409         SoftReference&lt;Map&lt;String, List&lt;URL&gt;&gt;&gt; ref = this.resourceCache;
 410         Map&lt;String, List&lt;URL&gt;&gt; map = (ref != null) ? ref.get() : null;
 411         if (map == null) {
<span class="line-modified"> 412             // only cache resources after VM is fully initialized</span>
<span class="line-modified"> 413             if (VM.isModuleSystemInited()) {</span>
<span class="line-added"> 414                 map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-added"> 415                 this.resourceCache = new SoftReference&lt;&gt;(map);</span>
<span class="line-added"> 416             }</span>
 417         } else {
 418             List&lt;URL&gt; urls = map.get(name);
 419             if (urls != null)
 420                 return urls;
 421         }
 422 
 423         // search all modules for the resource
 424         List&lt;URL&gt; urls;
 425         try {
 426             urls = AccessController.doPrivileged(
 427                 new PrivilegedExceptionAction&lt;&gt;() {
 428                     @Override
 429                     public List&lt;URL&gt; run() throws IOException {
 430                         List&lt;URL&gt; result = null;
 431                         for (ModuleReference mref : nameToModule.values()) {
 432                             URI u = moduleReaderFor(mref).find(name).orElse(null);
 433                             if (u != null) {
 434                                 try {
 435                                     if (result == null)
 436                                         result = new ArrayList&lt;&gt;();
 437                                     result.add(u.toURL());
 438                                 } catch (MalformedURLException |
 439                                          IllegalArgumentException e) {
 440                                 }
 441                             }
 442                         }
 443                         return (result != null) ? result : Collections.emptyList();
 444                     }
 445                 });
 446         } catch (PrivilegedActionException pae) {
 447             throw (IOException) pae.getCause();
 448         }
 449 
 450         // only cache resources after VM is fully initialized
<span class="line-modified"> 451         if (map != null) {</span>
 452             map.putIfAbsent(name, urls);
 453         }
 454 
 455         return urls;
 456     }
 457 
 458     /**
 459      * Returns the URL to a resource in a module or {@code null} if not found.
 460      */
 461     private URL findResource(ModuleReference mref, String name) throws IOException {
 462         URI u;
 463         if (System.getSecurityManager() == null) {
 464             u = moduleReaderFor(mref).find(name).orElse(null);
 465         } else {
 466             try {
 467                 u = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt; () {
 468                     @Override
 469                     public URI run() throws IOException {
 470                         return moduleReaderFor(mref).find(name).orElse(null);
 471                     }
</pre>
<hr />
<pre>
 951      * @throws SecurityException if the package name is untrusted in the manifest
 952      */
 953     private boolean isSealed(String pn, Manifest man) {
 954         Attributes attr = SharedSecrets.javaUtilJarAccess()
 955                 .getTrustedAttributes(man, pn.replace(&#39;.&#39;, &#39;/&#39;).concat(&quot;/&quot;));
 956         String sealed = null;
 957         if (attr != null)
 958             sealed = attr.getValue(Attributes.Name.SEALED);
 959         if (sealed == null &amp;&amp; (attr = man.getMainAttributes()) != null)
 960             sealed = attr.getValue(Attributes.Name.SEALED);
 961         return &quot;true&quot;.equalsIgnoreCase(sealed);
 962     }
 963 
 964     // -- permissions
 965 
 966     /**
 967      * Returns the permissions for the given CodeSource.
 968      */
 969     @Override
 970     protected PermissionCollection getPermissions(CodeSource cs) {
<span class="line-modified"> 971         return new LazyCodeSourcePermissionCollection(super.getPermissions(cs), cs);</span>





























 972     }
 973 

 974     // -- miscellaneous supporting methods
 975 
 976     /**
 977      * Returns the ModuleReader for the given module, creating it if needed.
 978      */
 979     private ModuleReader moduleReaderFor(ModuleReference mref) {
 980         ModuleReader reader = moduleToReader.get(mref);
 981         if (reader == null) {
 982             // avoid method reference during startup
 983             Function&lt;ModuleReference, ModuleReader&gt; create = new Function&lt;&gt;() {
 984                 public ModuleReader apply(ModuleReference moduleReference) {
 985                     try {
 986                         return mref.open();
 987                     } catch (IOException e) {
 988                         // Return a null module reader to avoid a future class
 989                         // load attempting to open the module again.
 990                         return new NullModuleReader();
 991                     }
 992                 }
 993             };
</pre>
</td>
</tr>
</table>
<center><a href="BootLoader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Resource.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
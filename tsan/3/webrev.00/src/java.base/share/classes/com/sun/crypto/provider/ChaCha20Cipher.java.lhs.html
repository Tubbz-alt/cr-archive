<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/ChaCha20Cipher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.crypto.provider;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.lang.invoke.MethodHandles;
  31 import java.lang.invoke.VarHandle;
  32 import java.nio.ByteBuffer;
  33 import java.nio.ByteOrder;
  34 import java.security.*;
  35 import java.security.spec.AlgorithmParameterSpec;
<a name="2" id="anc2"></a><span class="line-removed">  36 import java.util.Arrays;</span>
  37 import java.util.Objects;
<a name="3" id="anc3"></a>
  38 import javax.crypto.spec.ChaCha20ParameterSpec;
  39 import javax.crypto.spec.IvParameterSpec;
  40 import javax.crypto.spec.SecretKeySpec;
<a name="4" id="anc4"></a><span class="line-removed">  41 import javax.crypto.*;</span>
  42 import sun.security.util.DerValue;
  43 
  44 /**
  45  * Implementation of the ChaCha20 cipher, as described in RFC 7539.
  46  *
  47  * @since 11
  48  */
  49 abstract class ChaCha20Cipher extends CipherSpi {
  50     // Mode constants
  51     private static final int MODE_NONE = 0;
  52     private static final int MODE_AEAD = 1;
  53 
  54     // Constants used in setting up the initial state
  55     private static final int STATE_CONST_0 = 0x61707865;
  56     private static final int STATE_CONST_1 = 0x3320646e;
  57     private static final int STATE_CONST_2 = 0x79622d32;
  58     private static final int STATE_CONST_3 = 0x6b206574;
  59 
  60     // The keystream block size in bytes and as integers
  61     private static final int KEYSTREAM_SIZE = 64;
  62     private static final int KS_SIZE_INTS = KEYSTREAM_SIZE / Integer.BYTES;
  63     private static final int CIPHERBUF_BASE = 1024;
  64 
  65     // The initialization state of the cipher
  66     private boolean initialized;
  67 
  68     // The mode of operation for this object
  69     protected int mode;
  70 
  71     // The direction (encrypt vs. decrypt) for the data flow
  72     private int direction;
  73 
  74     // Has all AAD data been provided (i.e. have we called our first update)
  75     private boolean aadDone = false;
  76 
  77     // The key&#39;s encoding in bytes for this object
  78     private byte[] keyBytes;
  79 
  80     // The nonce used for this object
  81     private byte[] nonce;
  82 
  83     // The counter
  84     private static final long MAX_UINT32 = 0x00000000FFFFFFFFL;
  85     private long finalCounterValue;
  86     private long counter;
  87 
  88     // Two arrays, both implemented as 16-element integer arrays:
  89     // The base state, created at initialization time, and a working
  90     // state which is a clone of the start state, and is then modified
  91     // with the counter and the ChaCha20 block function.
  92     private final int[] startState = new int[KS_SIZE_INTS];
  93     private final byte[] keyStream = new byte[KEYSTREAM_SIZE];
  94 
  95     // The offset into the current keystream
  96     private int keyStrOffset;
  97 
  98     // AEAD-related fields and constants
  99     private static final int TAG_LENGTH = 16;
 100     private long aadLen;
 101     private long dataLen;
 102 
 103     // Have a buffer of zero padding that can be read all or in part
 104     // by the authenticator.
 105     private static final byte[] padBuf = new byte[TAG_LENGTH];
 106 
 107     // Create a buffer for holding the AAD and Ciphertext lengths
 108     private final byte[] lenBuf = new byte[TAG_LENGTH];
 109 
 110     // The authenticator (Poly1305) when running in AEAD mode
 111     protected String authAlgName;
 112     private Poly1305 authenticator;
 113 
 114     // The underlying engine for doing the ChaCha20/Poly1305 work
 115     private ChaChaEngine engine;
 116 
 117     // Use this VarHandle for converting the state elements into little-endian
 118     // integer values for the ChaCha20 block function.
 119     private static final VarHandle asIntLittleEndian =
 120             MethodHandles.byteArrayViewVarHandle(int[].class,
 121                     ByteOrder.LITTLE_ENDIAN);
 122 
 123     // Use this VarHandle for converting the AAD and data lengths into
 124     // little-endian long values for AEAD tag computations.
 125     private static final VarHandle asLongLittleEndian =
 126             MethodHandles.byteArrayViewVarHandle(long[].class,
 127                     ByteOrder.LITTLE_ENDIAN);
 128 
 129     // Use this for pulling in 8 bytes at a time as longs for XOR operations
 130     private static final VarHandle asLongView =
 131             MethodHandles.byteArrayViewVarHandle(long[].class,
 132                     ByteOrder.nativeOrder());
 133 
 134     /**
 135      * Default constructor.
 136      */
<a name="5" id="anc5"></a><span class="line-modified"> 137     protected ChaCha20Cipher() {</span>
<span class="line-removed"> 138     }</span>
 139 
 140     /**
 141      * Set the mode of operation.  Since this is a stream cipher, there
 142      * is no mode of operation in the block-cipher sense of things.  The
 143      * protected {@code mode} field will only accept a value of {@code None}
 144      * (case-insensitive).
 145      *
 146      * @param mode The mode value
 147      *
 148      * @throws NoSuchAlgorithmException if a mode of operation besides
 149      *      {@code None} is provided.
 150      */
 151     @Override
 152     protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
 153         if (mode.equalsIgnoreCase(&quot;None&quot;) == false) {
 154             throw new NoSuchAlgorithmException(&quot;Mode must be None&quot;);
 155         }
 156     }
 157 
 158     /**
 159      * Set the padding scheme.  Padding schemes do not make sense with stream
 160      * ciphers, but allow {@code NoPadding}.  See JCE spec.
 161      *
 162      * @param padding The padding type.  The only allowed value is
 163      *      {@code NoPadding} case insensitive).
 164      *
 165      * @throws NoSuchPaddingException if a padding scheme besides
 166      *      {@code NoPadding} is provided.
 167      */
 168     @Override
 169     protected void engineSetPadding(String padding)
 170             throws NoSuchPaddingException {
 171         if (padding.equalsIgnoreCase(&quot;NoPadding&quot;) == false) {
 172             throw new NoSuchPaddingException(&quot;Padding must be NoPadding&quot;);
 173         }
 174     }
 175 
 176     /**
 177      * Returns the block size.  For a stream cipher like ChaCha20, this
 178      * value will always be zero.
 179      *
 180      * @return This method always returns 0.  See the JCE Specification.
 181      */
 182     @Override
 183     protected int engineGetBlockSize() {
 184         return 0;
 185     }
 186 
 187     /**
<a name="6" id="anc6"></a><span class="line-modified"> 188      * Get the output size based on an input length.  In simple stream-cipher</span>

 189      * mode, the output size will equal the input size.  For ChaCha20-Poly1305
 190      * for encryption the output size will be the sum of the input length
<a name="7" id="anc7"></a><span class="line-modified"> 191      * and tag length.  For decryption, the output size will be the input</span>
<span class="line-modified"> 192      * length less the tag length or zero, whichever is larger.</span>

 193      *
 194      * @param inputLen the length in bytes of the input
 195      *
 196      * @return the output length in bytes.
 197      */
 198     @Override
 199     protected int engineGetOutputSize(int inputLen) {
<a name="8" id="anc8"></a><span class="line-modified"> 200         int outLen = 0;</span>
<span class="line-removed"> 201 </span>
<span class="line-removed"> 202         if (mode == MODE_NONE) {</span>
<span class="line-removed"> 203             outLen = inputLen;</span>
<span class="line-removed"> 204         } else if (mode == MODE_AEAD) {</span>
<span class="line-removed"> 205             outLen = (direction == Cipher.ENCRYPT_MODE) ?</span>
<span class="line-removed"> 206                     Math.addExact(inputLen, TAG_LENGTH) :</span>
<span class="line-removed"> 207                     Integer.max(inputLen - TAG_LENGTH, 0);</span>
<span class="line-removed"> 208         }</span>
<span class="line-removed"> 209 </span>
<span class="line-removed"> 210         return outLen;</span>
 211     }
 212 
 213     /**
 214      * Get the nonce value used.
 215      *
 216      * @return the nonce bytes.  For ChaCha20 this will be a 12-byte value.
 217      */
 218     @Override
 219     protected byte[] engineGetIV() {
 220         return nonce.clone();
 221     }
 222 
 223     /**
 224      * Get the algorithm parameters for this cipher.  For the ChaCha20
 225      * cipher, this will always return {@code null} as there currently is
 226      * no {@code AlgorithmParameters} implementation for ChaCha20.  For
 227      * ChaCha20-Poly1305, a {@code ChaCha20Poly1305Parameters} object will be
 228      * created and initialized with the configured nonce value and returned
 229      * to the caller.
 230      *
 231      * @return a {@code null} value if the ChaCha20 cipher is used (mode is
 232      * MODE_NONE), or a {@code ChaCha20Poly1305Parameters} object containing
 233      * the nonce if the mode is MODE_AEAD.
 234      */
 235     @Override
 236     protected AlgorithmParameters engineGetParameters() {
 237         AlgorithmParameters params = null;
 238         if (mode == MODE_AEAD) {
 239             try {
<a name="9" id="anc9"></a><span class="line-modified"> 240                 // Force the 12-byte nonce into a DER-encoded OCTET_STRING</span>
<span class="line-removed"> 241                 byte[] derNonce = new byte[nonce.length + 2];</span>
<span class="line-removed"> 242                 derNonce[0] = 0x04;                 // OCTET_STRING tag</span>
<span class="line-removed"> 243                 derNonce[1] = (byte)nonce.length;   // 12-byte length;</span>
<span class="line-removed"> 244                 System.arraycopy(nonce, 0, derNonce, 2, nonce.length);</span>
 245                 params = AlgorithmParameters.getInstance(&quot;ChaCha20-Poly1305&quot;);
<a name="10" id="anc10"></a><span class="line-modified"> 246                 params.init(derNonce);</span>

 247             } catch (NoSuchAlgorithmException | IOException exc) {
 248                 throw new RuntimeException(exc);
 249             }
 250         }
 251 
 252         return params;
 253     }
 254 
 255     /**
 256      * Initialize the engine using a key and secure random implementation.  If
 257      * a SecureRandom object is provided it will be used to create a random
 258      * nonce value.  If the {@code random} parameter is null an internal
 259      * secure random source will be used to create the random nonce.
 260      * The counter value will be set to 1.
 261      *
 262      * @param opmode the type of operation to do.  This value may not be
 263      *      {@code Cipher.DECRYPT_MODE} or {@code Cipher.UNWRAP_MODE} mode
 264      *      because it must generate random parameters like the nonce.
 265      * @param key a 256-bit key suitable for ChaCha20
 266      * @param random a {@code SecureRandom} implementation used to create the
 267      *      random nonce.  If {@code null} is used for the random object,
 268      *      then an internal secure random source will be used to create the
 269      *      nonce.
 270      *
 271      * @throws UnsupportedOperationException if the mode of operation
 272      *      is {@code Cipher.WRAP_MODE} or {@code Cipher.UNWRAP_MODE}
 273      *      (currently unsupported).
 274      * @throws InvalidKeyException if the key is of the wrong type or is
 275      *      not 256-bits in length.  This will also be thrown if the opmode
 276      *      parameter is {@code Cipher.DECRYPT_MODE}.
 277      *      {@code Cipher.UNWRAP_MODE} would normally be disallowed in this
 278      *      context but it is preempted by the UOE case above.
 279      */
 280     @Override
 281     protected void engineInit(int opmode, Key key, SecureRandom random)
 282             throws InvalidKeyException {
 283         if (opmode != Cipher.DECRYPT_MODE) {
 284             byte[] newNonce = createRandomNonce(random);
 285             counter = 1;
 286             init(opmode, key, newNonce);
 287         } else {
 288             throw new InvalidKeyException(&quot;Default parameter generation &quot; +
 289                 &quot;disallowed in DECRYPT and UNWRAP modes&quot;);
 290         }
 291     }
 292 
 293     /**
 294      * Initialize the engine using a key and secure random implementation.
 295      *
 296      * @param opmode the type of operation to do.  This value must be either
 297      *      {@code Cipher.ENCRYPT_MODE} or {@code Cipher.DECRYPT_MODE}
 298      * @param key a 256-bit key suitable for ChaCha20
 299      * @param params a {@code ChaCha20ParameterSpec} that will provide
 300      *      the nonce and initial block counter value.
 301      * @param random a {@code SecureRandom} implementation, this parameter
 302      *      is not used in this form of the initializer.
 303      *
 304      * @throws UnsupportedOperationException if the mode of operation
 305      *      is {@code Cipher.WRAP_MODE} or {@code Cipher.UNWRAP_MODE}
 306      *      (currently unsupported).
 307      * @throws InvalidKeyException if the key is of the wrong type or is
 308      *      not 256-bits in length.  This will also be thrown if the opmode
 309      *      parameter is not {@code Cipher.ENCRYPT_MODE} or
 310      *      {@code Cipher.DECRYPT_MODE} (excepting the UOE case above).
 311      * @throws InvalidAlgorithmParameterException if {@code params} is
 312      *      not a {@code ChaCha20ParameterSpec}
 313      * @throws NullPointerException if {@code params} is {@code null}
 314      */
 315     @Override
 316     protected void engineInit(int opmode, Key key,
 317             AlgorithmParameterSpec params, SecureRandom random)
 318             throws InvalidKeyException, InvalidAlgorithmParameterException {
 319 
 320         // If AlgorithmParameterSpec is null, then treat this like an init
 321         // of the form (int, Key, SecureRandom)
 322         if (params == null) {
 323             engineInit(opmode, key, random);
 324             return;
 325         }
 326 
 327         // We will ignore the secure random implementation and use the nonce
 328         // from the AlgorithmParameterSpec instead.
 329         byte[] newNonce = null;
 330         switch (mode) {
 331             case MODE_NONE:
 332                 if (!(params instanceof ChaCha20ParameterSpec)) {
 333                     throw new InvalidAlgorithmParameterException(
 334                         &quot;ChaCha20 algorithm requires ChaCha20ParameterSpec&quot;);
 335                 }
 336                 ChaCha20ParameterSpec chaParams = (ChaCha20ParameterSpec)params;
 337                 newNonce = chaParams.getNonce();
 338                 counter = ((long)chaParams.getCounter()) &amp; 0x00000000FFFFFFFFL;
 339                 break;
 340             case MODE_AEAD:
 341                 if (!(params instanceof IvParameterSpec)) {
 342                     throw new InvalidAlgorithmParameterException(
 343                         &quot;ChaCha20-Poly1305 requires IvParameterSpec&quot;);
 344                 }
 345                 IvParameterSpec ivParams = (IvParameterSpec)params;
 346                 newNonce = ivParams.getIV();
 347                 if (newNonce.length != 12) {
 348                     throw new InvalidAlgorithmParameterException(
 349                         &quot;ChaCha20-Poly1305 nonce must be 12 bytes in length&quot;);
 350                 }
 351                 break;
 352             default:
 353                 // Should never happen
 354                 throw new RuntimeException(&quot;ChaCha20 in unsupported mode&quot;);
 355         }
 356         init(opmode, key, newNonce);
 357     }
 358 
 359     /**
 360      * Initialize the engine using the {@code AlgorithmParameter} initialization
 361      * format.  This cipher does supports initialization with
 362      * {@code AlgorithmParameter} objects for ChaCha20-Poly1305 but not for
 363      * ChaCha20 as a simple stream cipher.  In the latter case, it will throw
 364      * an {@code InvalidAlgorithmParameterException} if the value is non-null.
 365      * If a null value is supplied for the {@code params} field
 366      * the cipher will be initialized with the counter value set to 1 and
 367      * a random nonce.  If {@code null} is used for the random object,
 368      * then an internal secure random source will be used to create the
 369      * nonce.
 370      *
 371      * @param opmode the type of operation to do.  This value must be either
 372      *      {@code Cipher.ENCRYPT_MODE} or {@code Cipher.DECRYPT_MODE}
 373      * @param key a 256-bit key suitable for ChaCha20
 374      * @param params a {@code null} value if the algorithm is ChaCha20, or
 375      *      the appropriate {@code AlgorithmParameters} object containing the
 376      *      nonce information if the algorithm is ChaCha20-Poly1305.
 377      * @param random a {@code SecureRandom} implementation, may be {@code null}.
 378      *
 379      * @throws UnsupportedOperationException if the mode of operation
 380      *      is {@code Cipher.WRAP_MODE} or {@code Cipher.UNWRAP_MODE}
 381      *      (currently unsupported).
 382      * @throws InvalidKeyException if the key is of the wrong type or is
 383      *      not 256-bits in length.  This will also be thrown if the opmode
 384      *      parameter is not {@code Cipher.ENCRYPT_MODE} or
 385      *      {@code Cipher.DECRYPT_MODE} (excepting the UOE case above).
 386      * @throws InvalidAlgorithmParameterException if {@code params} is
 387      *      non-null and the algorithm is ChaCha20.  This exception will be
 388      *      also thrown if the algorithm is ChaCha20-Poly1305 and an incorrect
 389      *      {@code AlgorithmParameters} object is supplied.
 390      */
 391     @Override
 392     protected void engineInit(int opmode, Key key,
 393             AlgorithmParameters params, SecureRandom random)
 394             throws InvalidKeyException, InvalidAlgorithmParameterException {
 395 
 396         // If AlgorithmParameters is null, then treat this like an init
 397         // of the form (int, Key, SecureRandom)
 398         if (params == null) {
 399             engineInit(opmode, key, random);
 400             return;
 401         }
 402 
 403         byte[] newNonce = null;
 404         switch (mode) {
 405             case MODE_NONE:
 406                 throw new InvalidAlgorithmParameterException(
 407                         &quot;AlgorithmParameters not supported&quot;);
 408             case MODE_AEAD:
 409                 String paramAlg = params.getAlgorithm();
 410                 if (!paramAlg.equalsIgnoreCase(&quot;ChaCha20-Poly1305&quot;)) {
 411                     throw new InvalidAlgorithmParameterException(
 412                             &quot;Invalid parameter type: &quot; + paramAlg);
 413                 }
 414                 try {
 415                     DerValue dv = new DerValue(params.getEncoded());
 416                     newNonce = dv.getOctetString();
 417                     if (newNonce.length != 12) {
 418                         throw new InvalidAlgorithmParameterException(
 419                                 &quot;ChaCha20-Poly1305 nonce must be &quot; +
 420                                 &quot;12 bytes in length&quot;);
 421                     }
 422                 } catch (IOException ioe) {
 423                     throw new InvalidAlgorithmParameterException(ioe);
 424                 }
 425                 break;
 426             default:
 427                 throw new RuntimeException(&quot;Invalid mode: &quot; + mode);
 428         }
 429 
 430         // If after all the above processing we still don&#39;t have a nonce value
 431         // then supply a random one provided a random source has been given.
 432         if (newNonce == null) {
 433             newNonce = createRandomNonce(random);
 434         }
 435 
 436         // Continue with initialization
 437         init(opmode, key, newNonce);
 438     }
 439 
 440     /**
 441      * Update additional authenticated data (AAD).
 442      *
 443      * @param src the byte array containing the authentication data.
 444      * @param offset the starting offset in the buffer to update.
 445      * @param len the amount of authentication data to update.
 446      *
 447      * @throws IllegalStateException if the cipher has not been initialized,
 448      *      {@code engineUpdate} has been called, or the cipher is running
 449      *      in a non-AEAD mode of operation.  It will also throw this
 450      *      exception if the submitted AAD would overflow a 64-bit length
 451      *      counter.
 452      */
 453     @Override
 454     protected void engineUpdateAAD(byte[] src, int offset, int len) {
 455         if (!initialized) {
 456             // We know that the cipher has not been initialized if the key
 457             // is still null.
 458             throw new IllegalStateException(
 459                     &quot;Attempted to update AAD on uninitialized Cipher&quot;);
 460         } else if (aadDone) {
 461             // No AAD updates allowed after the PT/CT update method is called
 462             throw new IllegalStateException(&quot;Attempted to update AAD on &quot; +
 463                     &quot;Cipher after plaintext/ciphertext update&quot;);
 464         } else if (mode != MODE_AEAD) {
 465             throw new IllegalStateException(
 466                     &quot;Cipher is running in non-AEAD mode&quot;);
 467         } else {
 468             try {
 469                 aadLen = Math.addExact(aadLen, len);
 470                 authUpdate(src, offset, len);
 471             } catch (ArithmeticException ae) {
 472                 throw new IllegalStateException(&quot;AAD overflow&quot;, ae);
 473             }
 474         }
 475     }
 476 
 477     /**
 478      * Update additional authenticated data (AAD).
 479      *
 480      * @param src the ByteBuffer containing the authentication data.
 481      *
 482      * @throws IllegalStateException if the cipher has not been initialized,
 483      *      {@code engineUpdate} has been called, or the cipher is running
 484      *      in a non-AEAD mode of operation.  It will also throw this
 485      *      exception if the submitted AAD would overflow a 64-bit length
 486      *      counter.
 487      */
 488     @Override
 489     protected void engineUpdateAAD(ByteBuffer src) {
 490         if (!initialized) {
 491             // We know that the cipher has not been initialized if the key
 492             // is still null.
 493             throw new IllegalStateException(
 494                     &quot;Attempted to update AAD on uninitialized Cipher&quot;);
 495         } else if (aadDone) {
 496             // No AAD updates allowed after the PT/CT update method  is called
 497             throw new IllegalStateException(&quot;Attempted to update AAD on &quot; +
 498                     &quot;Cipher after plaintext/ciphertext update&quot;);
 499         } else if (mode != MODE_AEAD) {
 500             throw new IllegalStateException(
 501                     &quot;Cipher is running in non-AEAD mode&quot;);
 502         } else {
 503             try {
 504                 aadLen = Math.addExact(aadLen, (src.limit() - src.position()));
 505                 authenticator.engineUpdate(src);
 506             } catch (ArithmeticException ae) {
 507                 throw new IllegalStateException(&quot;AAD overflow&quot;, ae);
 508             }
 509         }
 510     }
 511 
 512     /**
 513      * Create a random 12-byte nonce.
 514      *
 515      * @param random a {@code SecureRandom} object.  If {@code null} is
 516      * provided a new {@code SecureRandom} object will be instantiated.
 517      *
 518      * @return a 12-byte array containing the random nonce.
 519      */
 520     private byte[] createRandomNonce(SecureRandom random) {
 521         byte[] newNonce = new byte[12];
 522         SecureRandom rand = (random != null) ? random : new SecureRandom();
 523         rand.nextBytes(newNonce);
 524         return newNonce;
 525     }
 526 
 527     /**
 528      * Perform additional initialization actions based on the key and operation
 529      * type.
 530      *
 531      * @param opmode the type of operation to do.  This value must be either
 532      *      {@code Cipher.ENCRYPT_MODE} or {@code Cipher.DECRYPT_MODE}
 533      * @param key a 256-bit key suitable for ChaCha20
 534      * @param newNonce the new nonce value for this initialization.
 535      *
 536      * @throws UnsupportedOperationException if the {@code opmode} parameter
 537      *      is {@code Cipher.WRAP_MODE} or {@code Cipher.UNWRAP_MODE}
 538      *      (currently unsupported).
 539      * @throws InvalidKeyException if the {@code opmode} parameter is not
 540      *      {@code Cipher.ENCRYPT_MODE} or {@code Cipher.DECRYPT_MODE}, or
 541      *      if the key format is not {@code RAW}.
 542      */
 543     private void init(int opmode, Key key, byte[] newNonce)
 544             throws InvalidKeyException {
 545         if ((opmode == Cipher.WRAP_MODE) || (opmode == Cipher.UNWRAP_MODE)) {
 546             throw new UnsupportedOperationException(
 547                     &quot;WRAP_MODE and UNWRAP_MODE are not currently supported&quot;);
 548         } else if ((opmode != Cipher.ENCRYPT_MODE) &amp;&amp;
 549                 (opmode != Cipher.DECRYPT_MODE)) {
 550             throw new InvalidKeyException(&quot;Unknown opmode: &quot; + opmode);
 551         }
 552 
 553         // Make sure that the provided key and nonce are unique before
 554         // assigning them to the object.
 555         byte[] newKeyBytes = getEncodedKey(key);
 556         checkKeyAndNonce(newKeyBytes, newNonce);
 557         this.keyBytes = newKeyBytes;
 558         nonce = newNonce;
 559 
 560         // Now that we have the key and nonce, we can build the initial state
 561         setInitialState();
 562 
 563         if (mode == MODE_NONE) {
 564             engine = new EngineStreamOnly();
 565         } else if (mode == MODE_AEAD) {
 566             if (opmode == Cipher.ENCRYPT_MODE) {
 567                 engine = new EngineAEADEnc();
 568             } else if (opmode == Cipher.DECRYPT_MODE) {
 569                 engine = new EngineAEADDec();
 570             } else {
 571                 throw new InvalidKeyException(&quot;Not encrypt or decrypt mode&quot;);
 572             }
 573         }
 574 
 575         // We can also get one block&#39;s worth of keystream created
 576         finalCounterValue = counter + MAX_UINT32;
 577         generateKeystream();
 578         direction = opmode;
 579         aadDone = false;
 580         this.keyStrOffset = 0;
 581         initialized = true;
 582     }
 583 
 584     /**
 585      * Check the key and nonce bytes to make sure that they do not repeat
 586      * across reinitialization.
 587      *
 588      * @param newKeyBytes the byte encoding for the newly provided key
 589      * @param newNonce the new nonce to be used with this initialization
 590      *
 591      * @throws InvalidKeyException if both the key and nonce match the
 592      *      previous initialization.
 593      *
 594      */
 595     private void checkKeyAndNonce(byte[] newKeyBytes, byte[] newNonce)
 596             throws InvalidKeyException {
 597         // A new initialization must have either a different key or nonce
 598         // so the starting state for each block is not the same as the
 599         // previous initialization.
 600         if (MessageDigest.isEqual(newKeyBytes, keyBytes) &amp;&amp;
 601                 MessageDigest.isEqual(newNonce, nonce)) {
 602             throw new InvalidKeyException(
 603                     &quot;Matching key and nonce from previous initialization&quot;);
 604         }
 605     }
 606 
 607     /**
 608      * Return the encoded key as a byte array
 609      *
 610      * @param key the {@code Key} object used for this {@code Cipher}
 611      *
 612      * @return the key bytes
 613      *
 614      * @throws InvalidKeyException if the key is of the wrong type or length,
 615      *      or if the key encoding format is not {@code RAW}.
 616      */
 617     private static byte[] getEncodedKey(Key key) throws InvalidKeyException {
 618         if (&quot;RAW&quot;.equals(key.getFormat()) == false) {
 619             throw new InvalidKeyException(&quot;Key encoding format must be RAW&quot;);
 620         }
 621         byte[] encodedKey = key.getEncoded();
 622         if (encodedKey == null || encodedKey.length != 32) {
 623             throw new InvalidKeyException(&quot;Key length must be 256 bits&quot;);
 624         }
 625         return encodedKey;
 626     }
 627 
 628     /**
 629      * Update the currently running operation with additional data
 630      *
 631      * @param in the plaintext or ciphertext input bytes (depending on the
 632      *      operation type).
 633      * @param inOfs the offset into the input array
 634      * @param inLen the length of the data to use for the update operation.
 635      *
 636      * @return the resulting plaintext or ciphertext bytes (depending on
 637      *      the operation type)
 638      */
 639     @Override
 640     protected byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
<a name="11" id="anc11"></a><span class="line-modified"> 641         byte[] out = new byte[inLen];</span>
 642         try {
 643             engine.doUpdate(in, inOfs, inLen, out, 0);
 644         } catch (ShortBufferException | KeyException exc) {
 645             throw new RuntimeException(exc);
 646         }
 647 
 648         return out;
 649     }
 650 
 651     /**
 652      * Update the currently running operation with additional data
 653      *
 654      * @param in the plaintext or ciphertext input bytes (depending on the
 655      *      operation type).
 656      * @param inOfs the offset into the input array
 657      * @param inLen the length of the data to use for the update operation.
 658      * @param out the byte array that will hold the resulting data.  The array
 659      *      must be large enough to hold the resulting data.
 660      * @param outOfs the offset for the {@code out} buffer to begin writing
 661      *      the resulting data.
 662      *
 663      * @return the length in bytes of the data written into the {@code out}
 664      *      buffer.
 665      *
 666      * @throws ShortBufferException if the buffer {@code out} does not have
 667      *      enough space to hold the resulting data.
 668      */
 669     @Override
 670     protected int engineUpdate(byte[] in, int inOfs, int inLen,
 671             byte[] out, int outOfs) throws ShortBufferException {
 672         int bytesUpdated = 0;
 673         try {
 674             bytesUpdated = engine.doUpdate(in, inOfs, inLen, out, outOfs);
 675         } catch (KeyException ke) {
 676             throw new RuntimeException(ke);
 677         }
 678         return bytesUpdated;
 679     }
 680 
 681     /**
 682      * Complete the currently running operation using any final
 683      * data provided by the caller.
 684      *
 685      * @param in the plaintext or ciphertext input bytes (depending on the
 686      *      operation type).
 687      * @param inOfs the offset into the input array
 688      * @param inLen the length of the data to use for the update operation.
 689      *
 690      * @return the resulting plaintext or ciphertext bytes (depending on
 691      *      the operation type)
 692      *
 693      * @throws AEADBadTagException if, during decryption, the provided tag
 694      *      does not match the calculated tag.
 695      */
 696     @Override
 697     protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
 698             throws AEADBadTagException {
<a name="12" id="anc12"></a><span class="line-modified"> 699         byte[] output = new byte[engineGetOutputSize(inLen)];</span>
 700         try {
 701             engine.doFinal(in, inOfs, inLen, output, 0);
 702         } catch (ShortBufferException | KeyException exc) {
 703             throw new RuntimeException(exc);
 704         } finally {
 705             // Regardless of what happens, the cipher cannot be used for
 706             // further processing until it has been freshly initialized.
 707             initialized = false;
 708         }
 709         return output;
 710     }
 711 
 712     /**
 713      * Complete the currently running operation using any final
 714      * data provided by the caller.
 715      *
 716      * @param in the plaintext or ciphertext input bytes (depending on the
 717      *      operation type).
 718      * @param inOfs the offset into the input array
 719      * @param inLen the length of the data to use for the update operation.
 720      * @param out the byte array that will hold the resulting data.  The array
 721      *      must be large enough to hold the resulting data.
 722      * @param outOfs the offset for the {@code out} buffer to begin writing
 723      *      the resulting data.
 724      *
 725      * @return the length in bytes of the data written into the {@code out}
 726      *      buffer.
 727      *
 728      * @throws ShortBufferException if the buffer {@code out} does not have
 729      *      enough space to hold the resulting data.
 730      * @throws AEADBadTagException if, during decryption, the provided tag
 731      *      does not match the calculated tag.
 732      */
 733     @Override
 734     protected int engineDoFinal(byte[] in, int inOfs, int inLen, byte[] out,
 735             int outOfs) throws ShortBufferException, AEADBadTagException {
 736 
 737         int bytesUpdated = 0;
 738         try {
 739             bytesUpdated = engine.doFinal(in, inOfs, inLen, out, outOfs);
 740         } catch (KeyException ke) {
 741             throw new RuntimeException(ke);
 742         } finally {
 743             // Regardless of what happens, the cipher cannot be used for
 744             // further processing until it has been freshly initialized.
 745             initialized = false;
 746         }
 747         return bytesUpdated;
 748     }
 749 
 750     /**
 751      * Wrap a {@code Key} using this Cipher&#39;s current encryption parameters.
 752      *
 753      * @param key the key to wrap.  The data that will be encrypted will
 754      *      be the provided {@code Key} in its encoded form.
 755      *
 756      * @return a byte array consisting of the wrapped key.
 757      *
 758      * @throws UnsupportedOperationException this will (currently) always
 759      *      be thrown, as this method is not currently supported.
 760      */
 761     @Override
 762     protected byte[] engineWrap(Key key) throws IllegalBlockSizeException,
 763             InvalidKeyException {
 764         throw new UnsupportedOperationException(
 765                 &quot;Wrap operations are not supported&quot;);
 766     }
 767 
 768     /**
 769      * Unwrap a {@code Key} using this Cipher&#39;s current encryption parameters.
 770      *
 771      * @param wrappedKey the key to unwrap.
 772      * @param algorithm the algorithm associated with the wrapped key
 773      * @param type the type of the wrapped key. This is one of
 774      *      {@code SECRET_KEY}, {@code PRIVATE_KEY}, or {@code PUBLIC_KEY}.
 775      *
 776      * @return the unwrapped key as a {@code Key} object.
 777      *
 778      * @throws UnsupportedOperationException this will (currently) always
 779      *      be thrown, as this method is not currently supported.
 780      */
 781     @Override
 782     protected Key engineUnwrap(byte[] wrappedKey, String algorithm,
 783             int type) throws InvalidKeyException, NoSuchAlgorithmException {
 784         throw new UnsupportedOperationException(
 785                 &quot;Unwrap operations are not supported&quot;);
 786     }
 787 
 788     /**
 789      * Get the length of a provided key in bits.
 790      *
 791      * @param key the key to be evaluated
 792      *
 793      * @return the length of the key in bits
 794      *
 795      * @throws InvalidKeyException if the key is invalid or does not
 796      *      have an encoded form.
 797      */
 798     @Override
 799     protected int engineGetKeySize(Key key) throws InvalidKeyException {
 800         byte[] encodedKey = getEncodedKey(key);
 801         return encodedKey.length &lt;&lt; 3;
 802     }
 803 
 804     /**
 805      * Set the initial state.  This will populate the state array and put the
 806      * key and nonce into their proper locations.  The counter field is not
 807      * set here.
 808      *
 809      * @throws IllegalArgumentException if the key or nonce are not in
 810      *      their proper lengths (32 bytes for the key, 12 bytes for the
 811      *      nonce).
 812      * @throws InvalidKeyException if the key does not support an encoded form.
 813      */
 814     private void setInitialState() throws InvalidKeyException {
 815         // Apply constants to first 4 words
 816         startState[0] = STATE_CONST_0;
 817         startState[1] = STATE_CONST_1;
 818         startState[2] = STATE_CONST_2;
 819         startState[3] = STATE_CONST_3;
 820 
 821         // Apply the key bytes as 8 32-bit little endian ints (4 through 11)
 822         for (int i = 0; i &lt; 32; i += 4) {
 823             startState[(i / 4) + 4] = (keyBytes[i] &amp; 0x000000FF) |
 824                 ((keyBytes[i + 1] &lt;&lt; 8) &amp; 0x0000FF00) |
 825                 ((keyBytes[i + 2] &lt;&lt; 16) &amp; 0x00FF0000) |
 826                 ((keyBytes[i + 3] &lt;&lt; 24) &amp; 0xFF000000);
 827         }
 828 
 829         startState[12] = 0;
 830 
 831         // The final integers for the state are from the nonce
 832         // interpreted as 3 little endian integers
 833         for (int i = 0; i &lt; 12; i += 4) {
 834             startState[(i / 4) + 13] = (nonce[i] &amp; 0x000000FF) |
 835                 ((nonce[i + 1] &lt;&lt; 8) &amp; 0x0000FF00) |
 836                 ((nonce[i + 2] &lt;&lt; 16) &amp; 0x00FF0000) |
 837                 ((nonce[i + 3] &lt;&lt; 24) &amp; 0xFF000000);
 838         }
 839     }
 840 
 841     /**
 842      * Using the current state and counter create the next set of keystream
 843      * bytes.  This method will generate the next 512 bits of keystream and
 844      * return it in the {@code keyStream} parameter.  Following the
 845      * block function the counter will be incremented.
 846      */
 847     private void generateKeystream() {
 848         chaCha20Block(startState, counter, keyStream);
 849         counter++;
 850     }
 851 
 852     /**
 853      * Perform a full 20-round ChaCha20 transform on the initial state.
 854      *
 855      * @param initState the starting state, not including the counter
 856      *      value.
 857      * @param counter the counter value to apply
 858      * @param result  the array that will hold the result of the ChaCha20
 859      *      block function.
 860      *
 861      * @note it is the caller&#39;s responsibility to ensure that the workState
 862      * is sized the same as the initState, no checking is performed internally.
 863      */
 864     private static void chaCha20Block(int[] initState, long counter,
 865                                       byte[] result) {
 866         // Create an initial state and clone a working copy
 867         int ws00 = STATE_CONST_0;
 868         int ws01 = STATE_CONST_1;
 869         int ws02 = STATE_CONST_2;
 870         int ws03 = STATE_CONST_3;
 871         int ws04 = initState[4];
 872         int ws05 = initState[5];
 873         int ws06 = initState[6];
 874         int ws07 = initState[7];
 875         int ws08 = initState[8];
 876         int ws09 = initState[9];
 877         int ws10 = initState[10];
 878         int ws11 = initState[11];
 879         int ws12 = (int)counter;
 880         int ws13 = initState[13];
 881         int ws14 = initState[14];
 882         int ws15 = initState[15];
 883 
 884         // Peform 10 iterations of the 8 quarter round set
 885         for (int round = 0; round &lt; 10; round++) {
 886             ws00 += ws04;
 887             ws12 = Integer.rotateLeft(ws12 ^ ws00, 16);
 888 
 889             ws08 += ws12;
 890             ws04 = Integer.rotateLeft(ws04 ^ ws08, 12);
 891 
 892             ws00 += ws04;
 893             ws12 = Integer.rotateLeft(ws12 ^ ws00, 8);
 894 
 895             ws08 += ws12;
 896             ws04 = Integer.rotateLeft(ws04 ^ ws08, 7);
 897 
 898             ws01 += ws05;
 899             ws13 = Integer.rotateLeft(ws13 ^ ws01, 16);
 900 
 901             ws09 += ws13;
 902             ws05 = Integer.rotateLeft(ws05 ^ ws09, 12);
 903 
 904             ws01 += ws05;
 905             ws13 = Integer.rotateLeft(ws13 ^ ws01, 8);
 906 
 907             ws09 += ws13;
 908             ws05 = Integer.rotateLeft(ws05 ^ ws09, 7);
 909 
 910             ws02 += ws06;
 911             ws14 = Integer.rotateLeft(ws14 ^ ws02, 16);
 912 
 913             ws10 += ws14;
 914             ws06 = Integer.rotateLeft(ws06 ^ ws10, 12);
 915 
 916             ws02 += ws06;
 917             ws14 = Integer.rotateLeft(ws14 ^ ws02, 8);
 918 
 919             ws10 += ws14;
 920             ws06 = Integer.rotateLeft(ws06 ^ ws10, 7);
 921 
 922             ws03 += ws07;
 923             ws15 = Integer.rotateLeft(ws15 ^ ws03, 16);
 924 
 925             ws11 += ws15;
 926             ws07 = Integer.rotateLeft(ws07 ^ ws11, 12);
 927 
 928             ws03 += ws07;
 929             ws15 = Integer.rotateLeft(ws15 ^ ws03, 8);
 930 
 931             ws11 += ws15;
 932             ws07 = Integer.rotateLeft(ws07 ^ ws11, 7);
 933 
 934             ws00 += ws05;
 935             ws15 = Integer.rotateLeft(ws15 ^ ws00, 16);
 936 
 937             ws10 += ws15;
 938             ws05 = Integer.rotateLeft(ws05 ^ ws10, 12);
 939 
 940             ws00 += ws05;
 941             ws15 = Integer.rotateLeft(ws15 ^ ws00, 8);
 942 
 943             ws10 += ws15;
 944             ws05 = Integer.rotateLeft(ws05 ^ ws10, 7);
 945 
 946             ws01 += ws06;
 947             ws12 = Integer.rotateLeft(ws12 ^ ws01, 16);
 948 
 949             ws11 += ws12;
 950             ws06 = Integer.rotateLeft(ws06 ^ ws11, 12);
 951 
 952             ws01 += ws06;
 953             ws12 = Integer.rotateLeft(ws12 ^ ws01, 8);
 954 
 955             ws11 += ws12;
 956             ws06 = Integer.rotateLeft(ws06 ^ ws11, 7);
 957 
 958             ws02 += ws07;
 959             ws13 = Integer.rotateLeft(ws13 ^ ws02, 16);
 960 
 961             ws08 += ws13;
 962             ws07 = Integer.rotateLeft(ws07 ^ ws08, 12);
 963 
 964             ws02 += ws07;
 965             ws13 = Integer.rotateLeft(ws13 ^ ws02, 8);
 966 
 967             ws08 += ws13;
 968             ws07 = Integer.rotateLeft(ws07 ^ ws08, 7);
 969 
 970             ws03 += ws04;
 971             ws14 = Integer.rotateLeft(ws14 ^ ws03, 16);
 972 
 973             ws09 += ws14;
 974             ws04 = Integer.rotateLeft(ws04 ^ ws09, 12);
 975 
 976             ws03 += ws04;
 977             ws14 = Integer.rotateLeft(ws14 ^ ws03, 8);
 978 
 979             ws09 += ws14;
 980             ws04 = Integer.rotateLeft(ws04 ^ ws09, 7);
 981         }
 982 
 983         // Add the end working state back into the original state
 984         asIntLittleEndian.set(result, 0, ws00 + STATE_CONST_0);
 985         asIntLittleEndian.set(result, 4, ws01 + STATE_CONST_1);
 986         asIntLittleEndian.set(result, 8, ws02 + STATE_CONST_2);
 987         asIntLittleEndian.set(result, 12, ws03 + STATE_CONST_3);
 988         asIntLittleEndian.set(result, 16, ws04 + initState[4]);
 989         asIntLittleEndian.set(result, 20, ws05 + initState[5]);
 990         asIntLittleEndian.set(result, 24, ws06 + initState[6]);
 991         asIntLittleEndian.set(result, 28, ws07 + initState[7]);
 992         asIntLittleEndian.set(result, 32, ws08 + initState[8]);
 993         asIntLittleEndian.set(result, 36, ws09 + initState[9]);
 994         asIntLittleEndian.set(result, 40, ws10 + initState[10]);
 995         asIntLittleEndian.set(result, 44, ws11 + initState[11]);
 996         // Add the counter back into workState[12]
 997         asIntLittleEndian.set(result, 48, ws12 + (int)counter);
 998         asIntLittleEndian.set(result, 52, ws13 + initState[13]);
 999         asIntLittleEndian.set(result, 56, ws14 + initState[14]);
1000         asIntLittleEndian.set(result, 60, ws15 + initState[15]);
1001     }
1002 
1003     /**
1004      * Perform the ChaCha20 transform.
1005      *
1006      * @param in the array of bytes for the input
1007      * @param inOff the offset into the input array to start the transform
1008      * @param inLen the length of the data to perform the transform on.
1009      * @param out the output array.  It must be large enough to hold the
1010      *      resulting data
1011      * @param outOff the offset into the output array to place the resulting
1012      *      data.
1013      */
1014     private void chaCha20Transform(byte[] in, int inOff, int inLen,
1015             byte[] out, int outOff) throws KeyException {
1016         int remainingData = inLen;
1017 
1018         while (remainingData &gt; 0) {
1019             int ksRemain = keyStream.length - keyStrOffset;
1020             if (ksRemain &lt;= 0) {
1021                 if (counter &lt;= finalCounterValue) {
1022                     generateKeystream();
1023                     keyStrOffset = 0;
1024                     ksRemain = keyStream.length;
1025                 } else {
1026                     throw new KeyException(&quot;Counter exhausted.  &quot; +
1027                             &quot;Reinitialize with new key and/or nonce&quot;);
1028                 }
1029             }
1030 
1031             // XOR each byte in the keystream against the input
1032             int xformLen = Math.min(remainingData, ksRemain);
1033             xor(keyStream, keyStrOffset, in, inOff, out, outOff, xformLen);
1034             outOff += xformLen;
1035             inOff += xformLen;
1036             keyStrOffset += xformLen;
1037             remainingData -= xformLen;
1038         }
1039     }
1040 
1041     private static void xor(byte[] in1, int off1, byte[] in2, int off2,
1042             byte[] out, int outOff, int len) {
1043         while (len &gt;= 8) {
1044             long v1 = (long) asLongView.get(in1, off1);
1045             long v2 = (long) asLongView.get(in2, off2);
1046             asLongView.set(out, outOff, v1 ^ v2);
1047             off1 += 8;
1048             off2 += 8;
1049             outOff += 8;
1050             len -= 8;
1051         }
1052         while (len &gt; 0) {
1053             out[outOff] = (byte) (in1[off1] ^ in2[off2]);
1054             off1++;
1055             off2++;
1056             outOff++;
1057             len--;
1058         }
1059     }
1060 
1061     /**
1062      * Perform initialization steps for the authenticator
1063      *
1064      * @throws InvalidKeyException if the key is unusable for some reason
1065      *      (invalid length, etc.)
1066      */
1067     private void initAuthenticator() throws InvalidKeyException {
1068         authenticator = new Poly1305();
1069 
1070         // Derive the Poly1305 key from the starting state
1071         byte[] serializedKey = new byte[KEYSTREAM_SIZE];
1072         chaCha20Block(startState, 0, serializedKey);
1073 
1074         authenticator.engineInit(new SecretKeySpec(serializedKey, 0, 32,
1075                 authAlgName), null);
1076         aadLen = 0;
1077         dataLen = 0;
1078     }
1079 
1080     /**
1081      * Update the authenticator state with data.  This routine can be used
1082      * to add data to the authenticator, whether AAD or application data.
1083      *
1084      * @param data the data to stir into the authenticator.
1085      * @param offset the offset into the data.
1086      * @param length the length of data to add to the authenticator.
1087      *
1088      * @return the number of bytes processed by this method.
1089      */
1090     private int authUpdate(byte[] data, int offset, int length) {
1091         Objects.checkFromIndexSize(offset, length, data.length);
1092         authenticator.engineUpdate(data, offset, length);
1093         return length;
1094     }
1095 
1096     /**
1097      * Finalize the data and return the tag.
1098      *
1099      * @param data an array containing any remaining data to process.
1100      * @param dataOff the offset into the data.
1101      * @param length the length of the data to process.
1102      * @param out the array to write the resulting tag into
1103      * @param outOff the offset to begin writing the data.
1104      *
1105      * @throws ShortBufferException if there is insufficient room to
1106      *      write the tag.
1107      */
1108     private void authFinalizeData(byte[] data, int dataOff, int length,
1109             byte[] out, int outOff) throws ShortBufferException {
1110         // Update with the final chunk of ciphertext, then pad to a
1111         // multiple of 16.
1112         if (data != null) {
1113             dataLen += authUpdate(data, dataOff, length);
1114         }
1115         authPad16(dataLen);
1116 
1117         // Also write the AAD and ciphertext data lengths as little-endian
1118         // 64-bit values.
1119         authWriteLengths(aadLen, dataLen, lenBuf);
1120         authenticator.engineUpdate(lenBuf, 0, lenBuf.length);
1121         byte[] tag = authenticator.engineDoFinal();
1122         Objects.checkFromIndexSize(outOff, tag.length, out.length);
1123         System.arraycopy(tag, 0, out, outOff, tag.length);
1124         aadLen = 0;
1125         dataLen = 0;
1126     }
1127 
1128     /**
1129      * Based on a given length of data, make the authenticator process
1130      * zero bytes that will pad the length out to a multiple of 16.
1131      *
1132      * @param dataLen the starting length to be padded.
1133      */
1134     private void authPad16(long dataLen) {
1135         // Pad out the AAD or data to a multiple of 16 bytes
1136         authenticator.engineUpdate(padBuf, 0,
1137                 (TAG_LENGTH - ((int)dataLen &amp; 15)) &amp; 15);
1138     }
1139 
1140     /**
1141      * Write the two 64-bit little-endian length fields into an array
1142      * for processing by the poly1305 authenticator.
1143      *
1144      * @param aLen the length of the AAD.
1145      * @param dLen the length of the application data.
1146      * @param buf the buffer to write the two lengths into.
1147      *
1148      * @note it is the caller&#39;s responsibility to provide an array large
1149      *      enough to hold the two longs.
1150      */
1151     private void authWriteLengths(long aLen, long dLen, byte[] buf) {
1152         asLongLittleEndian.set(buf, 0, aLen);
1153         asLongLittleEndian.set(buf, Long.BYTES, dLen);
1154     }
1155 
1156     /**
1157      * Interface for the underlying processing engines for ChaCha20
1158      */
1159     interface ChaChaEngine {
<a name="13" id="anc13"></a>










1160         /**
1161          * Perform a multi-part update for ChaCha20.
1162          *
1163          * @param in the input data.
1164          * @param inOff the offset into the input.
1165          * @param inLen the length of the data to process.
1166          * @param out the output buffer.
1167          * @param outOff the offset at which to write the output data.
1168          *
1169          * @return the number of output bytes written.
1170          *
1171          * @throws ShortBufferException if the output buffer does not
1172          *      provide enough space.
1173          * @throws KeyException if the counter value has been exhausted.
1174          */
1175         int doUpdate(byte[] in, int inOff, int inLen, byte[] out, int outOff)
1176                 throws ShortBufferException, KeyException;
1177 
1178         /**
1179          * Finalize a multi-part or single-part ChaCha20 operation.
1180          *
1181          * @param in the input data.
1182          * @param inOff the offset into the input.
1183          * @param inLen the length of the data to process.
1184          * @param out the output buffer.
1185          * @param outOff the offset at which to write the output data.
1186          *
1187          * @return the number of output bytes written.
1188          *
1189          * @throws ShortBufferException if the output buffer does not
1190          *      provide enough space.
1191          * @throws AEADBadTagException if in decryption mode the provided
1192          *      tag and calculated tag do not match.
1193          * @throws KeyException if the counter value has been exhausted.
1194          */
1195         int doFinal(byte[] in, int inOff, int inLen, byte[] out, int outOff)
1196                 throws ShortBufferException, AEADBadTagException, KeyException;
1197     }
1198 
1199     private final class EngineStreamOnly implements ChaChaEngine {
1200 
1201         private EngineStreamOnly () { }
1202 
<a name="14" id="anc14"></a>





1203         @Override
1204         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1205                 int outOff) throws ShortBufferException, KeyException {
1206             if (initialized) {
1207                try {
1208                     if (out != null) {
1209                         Objects.checkFromIndexSize(outOff, inLen, out.length);
1210                     } else {
1211                         throw new ShortBufferException(
1212                                 &quot;Output buffer too small&quot;);
1213                     }
1214                 } catch (IndexOutOfBoundsException iobe) {
1215                     throw new ShortBufferException(&quot;Output buffer too small&quot;);
1216                 }
1217                 if (in != null) {
1218                     Objects.checkFromIndexSize(inOff, inLen, in.length);
1219                     chaCha20Transform(in, inOff, inLen, out, outOff);
1220                 }
1221                 return inLen;
1222             } else {
1223                 throw new IllegalStateException(
1224                         &quot;Must use either a different key or iv.&quot;);
1225             }
1226         }
1227 
1228         @Override
1229         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1230                 int outOff) throws ShortBufferException, KeyException {
1231             return doUpdate(in, inOff, inLen, out, outOff);
1232         }
1233     }
1234 
1235     private final class EngineAEADEnc implements ChaChaEngine {
1236 
<a name="15" id="anc15"></a>




1237         private EngineAEADEnc() throws InvalidKeyException {
1238             initAuthenticator();
1239             counter = 1;
1240         }
1241 
1242         @Override
1243         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1244                 int outOff) throws ShortBufferException, KeyException {
1245             if (initialized) {
1246                 // If this is the first update since AAD updates, signal that
1247                 // we&#39;re done processing AAD info and pad the AAD to a multiple
1248                 // of 16 bytes.
1249                 if (!aadDone) {
1250                     authPad16(aadLen);
1251                     aadDone = true;
1252                 }
1253                 try {
1254                     if (out != null) {
1255                         Objects.checkFromIndexSize(outOff, inLen, out.length);
1256                     } else {
1257                         throw new ShortBufferException(
1258                                 &quot;Output buffer too small&quot;);
1259                     }
1260                 } catch (IndexOutOfBoundsException iobe) {
1261                     throw new ShortBufferException(&quot;Output buffer too small&quot;);
1262                 }
1263                 if (in != null) {
1264                     Objects.checkFromIndexSize(inOff, inLen, in.length);
1265                     chaCha20Transform(in, inOff, inLen, out, outOff);
1266                     dataLen += authUpdate(out, outOff, inLen);
1267                 }
1268 
1269                 return inLen;
1270             } else {
1271                 throw new IllegalStateException(
1272                         &quot;Must use either a different key or iv.&quot;);
1273             }
1274         }
1275 
1276         @Override
1277         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1278                 int outOff) throws ShortBufferException, KeyException {
1279             // Make sure we have enough room for the remaining data (if any)
1280             // and the tag.
1281             if ((inLen + TAG_LENGTH) &gt; (out.length - outOff)) {
1282                 throw new ShortBufferException(&quot;Output buffer too small&quot;);
1283             }
1284 
1285             doUpdate(in, inOff, inLen, out, outOff);
1286             authFinalizeData(null, 0, 0, out, outOff + inLen);
1287             aadDone = false;
1288             return inLen + TAG_LENGTH;
1289         }
1290     }
1291 
1292     private final class EngineAEADDec implements ChaChaEngine {
1293 
1294         private final ByteArrayOutputStream cipherBuf;
1295         private final byte[] tag;
1296 
<a name="16" id="anc16"></a>











1297         private EngineAEADDec() throws InvalidKeyException {
1298             initAuthenticator();
1299             counter = 1;
1300             cipherBuf = new ByteArrayOutputStream(CIPHERBUF_BASE);
1301             tag = new byte[TAG_LENGTH];
1302         }
1303 
1304         @Override
1305         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1306                 int outOff) {
1307             if (initialized) {
1308                 // If this is the first update since AAD updates, signal that
1309                 // we&#39;re done processing AAD info and pad the AAD to a multiple
1310                 // of 16 bytes.
1311                 if (!aadDone) {
1312                     authPad16(aadLen);
1313                     aadDone = true;
1314                 }
1315 
1316                 if (in != null) {
1317                     Objects.checkFromIndexSize(inOff, inLen, in.length);
1318                     cipherBuf.write(in, inOff, inLen);
1319                 }
1320             } else {
1321                 throw new IllegalStateException(
1322                         &quot;Must use either a different key or iv.&quot;);
1323             }
1324 
1325             return 0;
1326         }
1327 
1328         @Override
1329         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1330                 int outOff) throws ShortBufferException, AEADBadTagException,
1331                 KeyException {
1332 
1333             byte[] ctPlusTag;
1334             int ctPlusTagLen;
1335             if (cipherBuf.size() == 0 &amp;&amp; inOff == 0) {
1336                 // No previous data has been seen before doFinal, so we do
1337                 // not need to hold any ciphertext in a buffer.  We can
1338                 // process it directly from the &quot;in&quot; parameter.
1339                 doUpdate(null, inOff, inLen, out, outOff);
1340                 ctPlusTag = in;
1341                 ctPlusTagLen = inLen;
1342             } else {
1343                 doUpdate(in, inOff, inLen, out, outOff);
1344                 ctPlusTag = cipherBuf.toByteArray();
1345                 ctPlusTagLen = ctPlusTag.length;
1346             }
1347             cipherBuf.reset();
1348 
1349             // There must at least be a tag length&#39;s worth of ciphertext
1350             // data in the buffered input.
1351             if (ctPlusTagLen &lt; TAG_LENGTH) {
1352                 throw new AEADBadTagException(&quot;Input too short - need tag&quot;);
1353             }
1354             int ctLen = ctPlusTagLen - TAG_LENGTH;
1355 
1356             // Make sure we will have enough room for the output buffer
1357             try {
1358                 Objects.checkFromIndexSize(outOff, ctLen, out.length);
1359             } catch (IndexOutOfBoundsException ioobe) {
1360                 throw new ShortBufferException(&quot;Output buffer too small&quot;);
1361             }
1362 
1363             // Calculate and compare the tag.  Only do the decryption
1364             // if and only if the tag matches.
1365             authFinalizeData(ctPlusTag, 0, ctLen, tag, 0);
<a name="17" id="anc17"></a><span class="line-modified">1366             if (Arrays.compare(ctPlusTag, ctLen, ctPlusTagLen,</span>
<span class="line-modified">1367                     tag, 0, tag.length) != 0) {</span>



1368                 throw new AEADBadTagException(&quot;Tag mismatch&quot;);
1369             }
1370             chaCha20Transform(ctPlusTag, 0, ctLen, out, outOff);
1371             aadDone = false;
1372 
1373             return ctLen;
1374         }
1375     }
1376 
1377     public static final class ChaCha20Only extends ChaCha20Cipher {
1378         public ChaCha20Only() {
1379             mode = MODE_NONE;
1380         }
1381     }
1382 
1383     public static final class ChaCha20Poly1305 extends ChaCha20Cipher {
1384         public ChaCha20Poly1305() {
1385             mode = MODE_AEAD;
1386             authAlgName = &quot;Poly1305&quot;;
1387         }
1388     }
1389 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/PBKDF2KeyImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.io.ObjectStreamException;
 29 import java.lang.ref.Reference;
 30 import java.nio.ByteBuffer;
 31 import java.nio.CharBuffer;
<a name="2" id="anc2"></a><span class="line-removed"> 32 import java.nio.charset.Charset;</span>
 33 import java.util.Arrays;
 34 import java.util.Locale;
 35 import java.security.MessageDigest;
 36 import java.security.KeyRep;
 37 import java.security.GeneralSecurityException;
 38 import java.security.NoSuchAlgorithmException;
 39 import java.security.spec.InvalidKeySpecException;
 40 import javax.crypto.Mac;
 41 import javax.crypto.SecretKey;
 42 import javax.crypto.spec.PBEKeySpec;
 43 
<a name="3" id="anc3"></a>

 44 import jdk.internal.ref.CleanerFactory;
 45 
 46 /**
 47  * This class represents a PBE key derived using PBKDF2 defined
 48  * in PKCS#5 v2.0. meaning that
 49  * 1) the password must consist of characters which will be converted
 50  *    to bytes using UTF-8 character encoding.
 51  * 2) salt, iteration count, and to be derived key length are supplied
 52  *
 53  * @author Valerie Peng
 54  *
 55  */
 56 final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {
 57 
<a name="4" id="anc4"></a>
 58     static final long serialVersionUID = -2234868909660948157L;
 59 
 60     private char[] passwd;
 61     private byte[] salt;
 62     private int iterCount;
 63     private byte[] key;
 64 
 65     private Mac prf;
 66 
 67     private static byte[] getPasswordBytes(char[] passwd) {
<a name="5" id="anc5"></a><span class="line-removed"> 68         Charset utf8 = Charset.forName(&quot;UTF-8&quot;);</span>
 69         CharBuffer cb = CharBuffer.wrap(passwd);
<a name="6" id="anc6"></a><span class="line-modified"> 70         ByteBuffer bb = utf8.encode(cb);</span>
 71 
 72         int len = bb.limit();
 73         byte[] passwdBytes = new byte[len];
 74         bb.get(passwdBytes, 0, len);
 75 
 76         return passwdBytes;
 77     }
 78 
 79     /**
 80      * Creates a PBE key from a given PBE key specification.
 81      *
 82      * @param keySpec the given PBE key specification
 83      * @param prfAlgo the given PBE key algorithm
 84      */
 85     PBKDF2KeyImpl(PBEKeySpec keySpec, String prfAlgo)
 86         throws InvalidKeySpecException {
 87         char[] passwd = keySpec.getPassword();
 88         if (passwd == null) {
 89             // Should allow an empty password.
 90             this.passwd = new char[0];
 91         } else {
 92             this.passwd = passwd.clone();
 93         }
 94         // Convert the password from char[] to byte[]
 95         byte[] passwdBytes = getPasswordBytes(this.passwd);
 96         // remove local copy
 97         if (passwd != null) Arrays.fill(passwd, &#39;\0&#39;);
 98 
 99         try {
100             this.salt = keySpec.getSalt();
101             if (salt == null) {
102                 throw new InvalidKeySpecException(&quot;Salt not found&quot;);
103             }
104             this.iterCount = keySpec.getIterationCount();
105             if (iterCount == 0) {
106                 throw new InvalidKeySpecException(&quot;Iteration count not found&quot;);
107             } else if (iterCount &lt; 0) {
108                 throw new InvalidKeySpecException(&quot;Iteration count is negative&quot;);
109             }
110             int keyLength = keySpec.getKeyLength();
111             if (keyLength == 0) {
112                 throw new InvalidKeySpecException(&quot;Key length not found&quot;);
113             } else if (keyLength &lt; 0) {
114                 throw new InvalidKeySpecException(&quot;Key length is negative&quot;);
115             }
<a name="7" id="anc7"></a><span class="line-modified">116             this.prf = Mac.getInstance(prfAlgo);</span>
<span class="line-removed">117             // SunPKCS11 requires a non-empty PBE password</span>
<span class="line-removed">118             if (passwdBytes.length == 0 &amp;&amp;</span>
<span class="line-removed">119                     this.prf.getProvider().getName().startsWith(&quot;SunPKCS11&quot;)) {</span>
<span class="line-removed">120                 this.prf = Mac.getInstance(prfAlgo, SunJCE.getInstance());</span>
<span class="line-removed">121             }</span>
122             this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);
123         } catch (NoSuchAlgorithmException nsae) {
124             // not gonna happen; re-throw just in case
125             InvalidKeySpecException ike = new InvalidKeySpecException();
126             ike.initCause(nsae);
127             throw ike;
128         } finally {
129             Arrays.fill(passwdBytes, (byte) 0x00);
130 
131             // Use the cleaner to zero the key when no longer referenced
132             final byte[] k = this.key;
133             final char[] p = this.passwd;
134             CleanerFactory.cleaner().register(this,
135                     () -&gt; {
136                         Arrays.fill(k, (byte) 0x00);
137                         Arrays.fill(p, &#39;\0&#39;);
138                     });
139         }
140     }
141 
142     private static byte[] deriveKey(final Mac prf, final byte[] password,
143             byte[] salt, int iterCount, int keyLengthInBit) {
144         int keyLength = keyLengthInBit/8;
145         byte[] key = new byte[keyLength];
146         try {
147             int hlen = prf.getMacLength();
148             int intL = (keyLength + hlen - 1)/hlen; // ceiling
149             int intR = keyLength - (intL - 1)*hlen; // residue
150             byte[] ui = new byte[hlen];
151             byte[] ti = new byte[hlen];
152             // SecretKeySpec cannot be used, since password can be empty here.
153             SecretKey macKey = new SecretKey() {
<a name="8" id="anc8"></a>
154                 private static final long serialVersionUID = 7874493593505141603L;
155                 @Override
156                 public String getAlgorithm() {
157                     return prf.getAlgorithm();
158                 }
159                 @Override
160                 public String getFormat() {
161                     return &quot;RAW&quot;;
162                 }
163                 @Override
164                 public byte[] getEncoded() {
165                     return password;
166                 }
167                 @Override
168                 public int hashCode() {
169                     return Arrays.hashCode(password) * 41 +
170                       prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();
171                 }
172                 @Override
173                 public boolean equals(Object obj) {
174                     if (this == obj) return true;
175                     if (this.getClass() != obj.getClass()) return false;
176                     SecretKey sk = (SecretKey)obj;
177                     return prf.getAlgorithm().equalsIgnoreCase(
178                         sk.getAlgorithm()) &amp;&amp;
179                         MessageDigest.isEqual(password, sk.getEncoded());
180                 }
181             };
182             prf.init(macKey);
183 
184             byte[] ibytes = new byte[4];
185             for (int i = 1; i &lt;= intL; i++) {
186                 prf.update(salt);
187                 ibytes[3] = (byte) i;
188                 ibytes[2] = (byte) ((i &gt;&gt; 8) &amp; 0xff);
189                 ibytes[1] = (byte) ((i &gt;&gt; 16) &amp; 0xff);
190                 ibytes[0] = (byte) ((i &gt;&gt; 24) &amp; 0xff);
191                 prf.update(ibytes);
192                 prf.doFinal(ui, 0);
193                 System.arraycopy(ui, 0, ti, 0, ui.length);
194 
195                 for (int j = 2; j &lt;= iterCount; j++) {
196                     prf.update(ui);
197                     prf.doFinal(ui, 0);
198                     // XOR the intermediate Ui&#39;s together.
199                     for (int k = 0; k &lt; ui.length; k++) {
200                         ti[k] ^= ui[k];
201                     }
202                 }
203                 if (i == intL) {
204                     System.arraycopy(ti, 0, key, (i-1)*hlen, intR);
205                 } else {
206                     System.arraycopy(ti, 0, key, (i-1)*hlen, hlen);
207                 }
208             }
209         } catch (GeneralSecurityException gse) {
<a name="9" id="anc9"></a><span class="line-modified">210             throw new RuntimeException(&quot;Error deriving PBKDF2 keys&quot;);</span>
211         }
212         return key;
213     }
214 
215     public byte[] getEncoded() {
216         // The key is zeroized by finalize()
217         // The reachability fence ensures finalize() isn&#39;t called early
218         byte[] result = key.clone();
219         Reference.reachabilityFence(this);
220         return result;
221     }
222 
223     public String getAlgorithm() {
224         return &quot;PBKDF2With&quot; + prf.getAlgorithm();
225     }
226 
227     public int getIterationCount() {
228         return iterCount;
229     }
230 
231     public char[] getPassword() {
232         // The password is zeroized by finalize()
233         // The reachability fence ensures finalize() isn&#39;t called early
234         char[] result = passwd.clone();
235         Reference.reachabilityFence(this);
236         return result;
237     }
238 
239     public byte[] getSalt() {
240         return salt.clone();
241     }
242 
243     public String getFormat() {
244         return &quot;RAW&quot;;
245     }
246 
247     /**
248      * Calculates a hash code value for the object.
249      * Objects that are equal will also have the same hashcode.
250      */
251     public int hashCode() {
252         int retval = 0;
253         for (int i = 1; i &lt; this.key.length; i++) {
254             retval += this.key[i] * i;
255         }
256         return(retval ^= getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode());
257     }
258 
259     public boolean equals(Object obj) {
260         if (obj == this)
261             return true;
262 
263         if (!(obj instanceof SecretKey))
264             return false;
265 
266         SecretKey that = (SecretKey) obj;
267 
268         if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm())))
269             return false;
270         if (!(that.getFormat().equalsIgnoreCase(&quot;RAW&quot;)))
271             return false;
272         byte[] thatEncoded = that.getEncoded();
273         boolean ret = MessageDigest.isEqual(key, thatEncoded);
274         Arrays.fill(thatEncoded, (byte)0x00);
275         return ret;
276     }
277 
278     /**
279      * Replace the PBE key to be serialized.
280      *
281      * @return the standard KeyRep object to be serialized
282      *
283      * @throws ObjectStreamException if a new object representing
284      * this PBE key could not be created
285      */
<a name="10" id="anc10"></a>
286     private Object writeReplace() throws ObjectStreamException {
287             return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),
288                               getFormat(), getEncoded());
289     }
290 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElectronicCodeBook.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import sun.security.util.Debug;

 29 
 30 import java.io.*;
 31 import java.util.*;
 32 import java.security.AccessController;
 33 import java.security.DigestInputStream;
 34 import java.security.DigestOutputStream;
 35 import java.security.MessageDigest;
 36 import java.security.NoSuchAlgorithmException;
 37 import java.security.Key;
 38 import java.security.PrivateKey;
 39 import java.security.PrivilegedAction;
 40 import java.security.KeyStoreSpi;
 41 import java.security.KeyStoreException;
 42 import java.security.UnrecoverableKeyException;
 43 import java.security.cert.Certificate;
 44 import java.security.cert.CertificateFactory;
 45 import java.security.cert.CertificateException;
 46 import javax.crypto.SealedObject;
 47 


 48 /**
 49  * This class provides the keystore implementation referred to as &quot;jceks&quot;.
 50  * This implementation strongly protects the keystore private keys using
 51  * triple-DES, where the triple-DES encryption/decryption key is derived from
 52  * the user&#39;s password.
 53  * The encrypted private keys are stored in the keystore in a standard format,
 54  * namely the &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; format defined in PKCS #8.
 55  *
 56  * @author Jan Luehe
 57  *
 58  *
 59  * @see java.security.KeyStoreSpi
 60  */
 61 
 62 public final class JceKeyStore extends KeyStoreSpi {
 63 
 64     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 65     private static final int JCEKS_MAGIC = 0xcececece;
 66     private static final int JKS_MAGIC = 0xfeedfeed;
 67     private static final int VERSION_1 = 0x01;
 68     private static final int VERSION_2 = 0x02;
 69 
 70     // Private key and supporting certificate chain
 71     private static final class PrivateKeyEntry {
 72         Date date; // the creation date of this entry
 73         byte[] protectedKey;
<span class="line-modified"> 74         Certificate chain[];</span>
 75     };
 76 
 77     // Secret key
 78     private static final class SecretKeyEntry {
 79         Date date; // the creation date of this entry
 80         SealedObject sealedKey;
 81     }
 82 
 83     // Trusted certificate
 84     private static final class TrustedCertEntry {
 85         Date date; // the creation date of this entry
 86         Certificate cert;
 87     };
 88 
 89     /**
 90      * Private keys and certificates are stored in a hashtable.
 91      * Hash entries are keyed by alias names.
 92      */
 93     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
 94 
</pre>
<hr />
<pre>
723                 entries.clear();
724                 int count = dis.readInt();
725 
726                 for (int i = 0; i &lt; count; i++) {
727                     int tag;
728                     String alias;
729 
730                     tag = dis.readInt();
731 
732                     if (tag == 1) { // private-key entry
733                         privateKeyCount++;
734                         PrivateKeyEntry entry = new PrivateKeyEntry();
735 
736                         // read the alias
737                         alias = dis.readUTF();
738 
739                         // read the (entry creation) date
740                         entry.date = new Date(dis.readLong());
741 
742                         // read the private key
<span class="line-modified">743                         try {</span>
<span class="line-removed">744                             entry.protectedKey = new byte[dis.readInt()];</span>
<span class="line-removed">745                         } catch (OutOfMemoryError e) {</span>
<span class="line-removed">746                             throw new IOException(&quot;Keysize too big&quot;);</span>
<span class="line-removed">747                         }</span>
<span class="line-removed">748                         dis.readFully(entry.protectedKey);</span>
749 
750                         // read the certificate chain
751                         int numOfCerts = dis.readInt();
<span class="line-modified">752                         try {</span>
<span class="line-removed">753                             if (numOfCerts &gt; 0) {</span>
<span class="line-removed">754                                 entry.chain = new Certificate[numOfCerts];</span>
<span class="line-removed">755                             }</span>
<span class="line-removed">756                         } catch (OutOfMemoryError e) {</span>
<span class="line-removed">757                             throw new IOException(&quot;Too many certificates in &quot;</span>
<span class="line-removed">758                                                   + &quot;chain&quot;);</span>
<span class="line-removed">759                         }</span>
760                         for (int j = 0; j &lt; numOfCerts; j++) {
761                             if (xVersion == 2) {
762                                 // read the certificate type, and instantiate a
763                                 // certificate factory of that type (reuse
764                                 // existing factory if possible)
765                                 String certType = dis.readUTF();
766                                 if (cfs.containsKey(certType)) {
<span class="line-modified">767                                 // reuse certificate factory</span>
768                                     cf = cfs.get(certType);
769                                 } else {
<span class="line-modified">770                                 // create new certificate factory</span>
771                                     cf = CertificateFactory.getInstance(
772                                         certType);
<span class="line-modified">773                                 // store the certificate factory so we can</span>
<span class="line-modified">774                                 // reuse it later</span>
775                                     cfs.put(certType, cf);
776                                 }
777                             }
778                             // instantiate the certificate
<span class="line-modified">779                             try {</span>
<span class="line-removed">780                                 encoded = new byte[dis.readInt()];</span>
<span class="line-removed">781                             } catch (OutOfMemoryError e) {</span>
<span class="line-removed">782                                 throw new IOException(&quot;Certificate too big&quot;);</span>
<span class="line-removed">783                             }</span>
<span class="line-removed">784                             dis.readFully(encoded);</span>
785                             bais = new ByteArrayInputStream(encoded);
<span class="line-modified">786                             entry.chain[j] = cf.generateCertificate(bais);</span>
787                         }


788 
789                         // Add the entry to the list
790                         entries.put(alias, entry);
791 
792                     } else if (tag == 2) { // trusted certificate entry
793                         trustedKeyCount++;
794                         TrustedCertEntry entry = new TrustedCertEntry();
795 
796                         // read the alias
797                         alias = dis.readUTF();
798 
799                         // read the (entry creation) date
800                         entry.date = new Date(dis.readLong());
801 
802                         // read the trusted certificate
803                         if (xVersion == 2) {
804                             // read the certificate type, and instantiate a
805                             // certificate factory of that type (reuse
806                             // existing factory if possible)
807                             String certType = dis.readUTF();
808                             if (cfs.containsKey(certType)) {
809                                 // reuse certificate factory
810                                 cf = cfs.get(certType);
811                             } else {
812                                 // create new certificate factory
813                                 cf = CertificateFactory.getInstance(certType);
814                                 // store the certificate factory so we can
815                                 // reuse it later
816                                 cfs.put(certType, cf);
817                             }
818                         }
<span class="line-modified">819                         try {</span>
<span class="line-removed">820                             encoded = new byte[dis.readInt()];</span>
<span class="line-removed">821                         } catch (OutOfMemoryError e) {</span>
<span class="line-removed">822                             throw new IOException(&quot;Certificate too big&quot;);</span>
<span class="line-removed">823                         }</span>
<span class="line-removed">824                         dis.readFully(encoded);</span>
825                         bais = new ByteArrayInputStream(encoded);
826                         entry.cert = cf.generateCertificate(bais);
827 
828                         // Add the entry to the list
829                         entries.put(alias, entry);
830 
831                     } else if (tag == 3) { // secret-key entry
832                         secretKeyCount++;
833                         SecretKeyEntry entry = new SecretKeyEntry();
834 
835                         // read the alias
836                         alias = dis.readUTF();
837 
838                         // read the (entry creation) date
839                         entry.date = new Date(dis.readLong());
840 
841                         // read the sealed key
842                         try {
843                             ois = new ObjectInputStream(dis);
844                             final ObjectInputStream ois2 = ois;
</pre>
<hr />
<pre>
863 
864                     } else {
865                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
866                                 tag);
867                     }
868                 }
869 
870                 if (debug != null) {
871                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
872                         privateKeyCount + &quot;. trusted key count: &quot; +
873                         trustedKeyCount + &quot;. secret key count: &quot; +
874                         secretKeyCount);
875                 }
876 
877                 /*
878                  * If a password has been provided, we check the keyed digest
879                  * at the end. If this check fails, the store has been tampered
880                  * with
881                  */
882                 if (password != null) {
<span class="line-modified">883                     byte computed[], actual[];</span>
<span class="line-modified">884                     computed = md.digest();</span>
<span class="line-modified">885                     actual = new byte[computed.length];</span>
<span class="line-modified">886                     dis.readFully(actual);</span>
<span class="line-removed">887                     for (int i = 0; i &lt; computed.length; i++) {</span>
<span class="line-removed">888                         if (computed[i] != actual[i]) {</span>
<span class="line-removed">889                             throw new IOException(</span>
890                                 &quot;Keystore was tampered with, or &quot;
891                                         + &quot;password was incorrect&quot;,
<span class="line-modified">892                                     new UnrecoverableKeyException(</span>
<span class="line-modified">893                                             &quot;Password verification failed&quot;));</span>
<span class="line-removed">894                         }</span>
895                     }
896                 }
897             }  finally {
898                 if (ois != null) {
899                     ois.close();
900                 } else {
901                     dis.close();
902                 }
903             }
904         }
905     }
906 
907     /**
908      * To guard against tampering with the keystore, we append a keyed
909      * hash with a bit of whitener.
910      */
911     private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">912     throws NoSuchAlgorithmException, UnsupportedEncodingException {</span>

913         int i, j;
914 
915         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
916         byte[] passwdBytes = new byte[password.length * 2];
917         for (i=0, j=0; i&lt;password.length; i++) {
918             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
919             passwdBytes[j++] = (byte)password[i];
920         }
921         md.update(passwdBytes);
922         for (i=0; i&lt;passwdBytes.length; i++)
923             passwdBytes[i] = 0;
<span class="line-modified">924         md.update(&quot;Mighty Aphrodite&quot;.getBytes(&quot;UTF8&quot;));</span>
925         return md;
926     }
927 
928     /**
929      * Probe the first few bytes of the keystore data stream for a valid
930      * JCEKS keystore encoding.
931      */
932     @Override
933     public boolean engineProbe(InputStream stream) throws IOException {
934         DataInputStream dataStream;
935         if (stream instanceof DataInputStream) {
936             dataStream = (DataInputStream)stream;
937         } else {
938             dataStream = new DataInputStream(stream);
939         }
940 
941         return JCEKS_MAGIC == dataStream.readInt();
942     }
943 
944     /*
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import sun.security.util.Debug;
<span class="line-added"> 29 import sun.security.util.IOUtils;</span>
 30 
 31 import java.io.*;
 32 import java.util.*;
 33 import java.security.AccessController;
 34 import java.security.DigestInputStream;
 35 import java.security.DigestOutputStream;
 36 import java.security.MessageDigest;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.Key;
 39 import java.security.PrivateKey;
 40 import java.security.PrivilegedAction;
 41 import java.security.KeyStoreSpi;
 42 import java.security.KeyStoreException;
 43 import java.security.UnrecoverableKeyException;
 44 import java.security.cert.Certificate;
 45 import java.security.cert.CertificateFactory;
 46 import java.security.cert.CertificateException;
 47 import javax.crypto.SealedObject;
 48 
<span class="line-added"> 49 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 50 </span>
 51 /**
 52  * This class provides the keystore implementation referred to as &quot;jceks&quot;.
 53  * This implementation strongly protects the keystore private keys using
 54  * triple-DES, where the triple-DES encryption/decryption key is derived from
 55  * the user&#39;s password.
 56  * The encrypted private keys are stored in the keystore in a standard format,
 57  * namely the &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; format defined in PKCS #8.
 58  *
 59  * @author Jan Luehe
 60  *
 61  *
 62  * @see java.security.KeyStoreSpi
 63  */
 64 
 65 public final class JceKeyStore extends KeyStoreSpi {
 66 
 67     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 68     private static final int JCEKS_MAGIC = 0xcececece;
 69     private static final int JKS_MAGIC = 0xfeedfeed;
 70     private static final int VERSION_1 = 0x01;
 71     private static final int VERSION_2 = 0x02;
 72 
 73     // Private key and supporting certificate chain
 74     private static final class PrivateKeyEntry {
 75         Date date; // the creation date of this entry
 76         byte[] protectedKey;
<span class="line-modified"> 77         Certificate[] chain;</span>
 78     };
 79 
 80     // Secret key
 81     private static final class SecretKeyEntry {
 82         Date date; // the creation date of this entry
 83         SealedObject sealedKey;
 84     }
 85 
 86     // Trusted certificate
 87     private static final class TrustedCertEntry {
 88         Date date; // the creation date of this entry
 89         Certificate cert;
 90     };
 91 
 92     /**
 93      * Private keys and certificates are stored in a hashtable.
 94      * Hash entries are keyed by alias names.
 95      */
 96     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
 97 
</pre>
<hr />
<pre>
726                 entries.clear();
727                 int count = dis.readInt();
728 
729                 for (int i = 0; i &lt; count; i++) {
730                     int tag;
731                     String alias;
732 
733                     tag = dis.readInt();
734 
735                     if (tag == 1) { // private-key entry
736                         privateKeyCount++;
737                         PrivateKeyEntry entry = new PrivateKeyEntry();
738 
739                         // read the alias
740                         alias = dis.readUTF();
741 
742                         // read the (entry creation) date
743                         entry.date = new Date(dis.readLong());
744 
745                         // read the private key
<span class="line-modified">746                         entry.protectedKey = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>





747 
748                         // read the certificate chain
749                         int numOfCerts = dis.readInt();
<span class="line-modified">750                         List&lt;Certificate&gt; tmpCerts = new ArrayList&lt;&gt;();</span>







751                         for (int j = 0; j &lt; numOfCerts; j++) {
752                             if (xVersion == 2) {
753                                 // read the certificate type, and instantiate a
754                                 // certificate factory of that type (reuse
755                                 // existing factory if possible)
756                                 String certType = dis.readUTF();
757                                 if (cfs.containsKey(certType)) {
<span class="line-modified">758                                     // reuse certificate factory</span>
759                                     cf = cfs.get(certType);
760                                 } else {
<span class="line-modified">761                                     // create new certificate factory</span>
762                                     cf = CertificateFactory.getInstance(
763                                         certType);
<span class="line-modified">764                                     // store the certificate factory so we can</span>
<span class="line-modified">765                                     // reuse it later</span>
766                                     cfs.put(certType, cf);
767                                 }
768                             }
769                             // instantiate the certificate
<span class="line-modified">770                             encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>





771                             bais = new ByteArrayInputStream(encoded);
<span class="line-modified">772                             tmpCerts.add(cf.generateCertificate(bais));</span>
773                         }
<span class="line-added">774                         entry.chain = tmpCerts.toArray(</span>
<span class="line-added">775                                 new Certificate[numOfCerts]);</span>
776 
777                         // Add the entry to the list
778                         entries.put(alias, entry);
779 
780                     } else if (tag == 2) { // trusted certificate entry
781                         trustedKeyCount++;
782                         TrustedCertEntry entry = new TrustedCertEntry();
783 
784                         // read the alias
785                         alias = dis.readUTF();
786 
787                         // read the (entry creation) date
788                         entry.date = new Date(dis.readLong());
789 
790                         // read the trusted certificate
791                         if (xVersion == 2) {
792                             // read the certificate type, and instantiate a
793                             // certificate factory of that type (reuse
794                             // existing factory if possible)
795                             String certType = dis.readUTF();
796                             if (cfs.containsKey(certType)) {
797                                 // reuse certificate factory
798                                 cf = cfs.get(certType);
799                             } else {
800                                 // create new certificate factory
801                                 cf = CertificateFactory.getInstance(certType);
802                                 // store the certificate factory so we can
803                                 // reuse it later
804                                 cfs.put(certType, cf);
805                             }
806                         }
<span class="line-modified">807                         encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>





808                         bais = new ByteArrayInputStream(encoded);
809                         entry.cert = cf.generateCertificate(bais);
810 
811                         // Add the entry to the list
812                         entries.put(alias, entry);
813 
814                     } else if (tag == 3) { // secret-key entry
815                         secretKeyCount++;
816                         SecretKeyEntry entry = new SecretKeyEntry();
817 
818                         // read the alias
819                         alias = dis.readUTF();
820 
821                         // read the (entry creation) date
822                         entry.date = new Date(dis.readLong());
823 
824                         // read the sealed key
825                         try {
826                             ois = new ObjectInputStream(dis);
827                             final ObjectInputStream ois2 = ois;
</pre>
<hr />
<pre>
846 
847                     } else {
848                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
849                                 tag);
850                     }
851                 }
852 
853                 if (debug != null) {
854                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
855                         privateKeyCount + &quot;. trusted key count: &quot; +
856                         trustedKeyCount + &quot;. secret key count: &quot; +
857                         secretKeyCount);
858                 }
859 
860                 /*
861                  * If a password has been provided, we check the keyed digest
862                  * at the end. If this check fails, the store has been tampered
863                  * with
864                  */
865                 if (password != null) {
<span class="line-modified">866                     byte[] computed = md.digest();</span>
<span class="line-modified">867                     byte[] actual = IOUtils.readExactlyNBytes(dis, computed.length);</span>
<span class="line-modified">868                     if (!MessageDigest.isEqual(computed, actual)) {</span>
<span class="line-modified">869                         throw new IOException(</span>



870                                 &quot;Keystore was tampered with, or &quot;
871                                         + &quot;password was incorrect&quot;,
<span class="line-modified">872                                 new UnrecoverableKeyException(</span>
<span class="line-modified">873                                         &quot;Password verification failed&quot;));</span>

874                     }
875                 }
876             }  finally {
877                 if (ois != null) {
878                     ois.close();
879                 } else {
880                     dis.close();
881                 }
882             }
883         }
884     }
885 
886     /**
887      * To guard against tampering with the keystore, we append a keyed
888      * hash with a bit of whitener.
889      */
890     private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">891         throws NoSuchAlgorithmException</span>
<span class="line-added">892     {</span>
893         int i, j;
894 
895         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
896         byte[] passwdBytes = new byte[password.length * 2];
897         for (i=0, j=0; i&lt;password.length; i++) {
898             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
899             passwdBytes[j++] = (byte)password[i];
900         }
901         md.update(passwdBytes);
902         for (i=0; i&lt;passwdBytes.length; i++)
903             passwdBytes[i] = 0;
<span class="line-modified">904         md.update(&quot;Mighty Aphrodite&quot;.getBytes(UTF_8));</span>
905         return md;
906     }
907 
908     /**
909      * Probe the first few bytes of the keystore data stream for a valid
910      * JCEKS keystore encoding.
911      */
912     @Override
913     public boolean engineProbe(InputStream stream) throws IOException {
914         DataInputStream dataStream;
915         if (stream instanceof DataInputStream) {
916             dataStream = (DataInputStream)stream;
917         } else {
918             dataStream = new DataInputStream(stream);
919         }
920 
921         return JCEKS_MAGIC == dataStream.readInt();
922     }
923 
924     /*
</pre>
</td>
</tr>
</table>
<center><a href="ElectronicCodeBook.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
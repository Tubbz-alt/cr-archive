<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/security/ntlm/NTLM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.ntlm;
 27 
 28 import sun.security.action.GetBooleanAction;
 29 
 30 import static com.sun.security.ntlm.Version.*;
 31 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-modified"> 32 import java.io.UnsupportedEncodingException;</span>
 33 import java.security.InvalidKeyException;
 34 import java.security.MessageDigest;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.spec.InvalidKeySpecException;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 import javax.crypto.BadPaddingException;
 40 import javax.crypto.Cipher;
 41 import javax.crypto.IllegalBlockSizeException;
 42 import javax.crypto.Mac;
 43 import javax.crypto.NoSuchPaddingException;
 44 import javax.crypto.SecretKey;
 45 import javax.crypto.SecretKeyFactory;
 46 import javax.crypto.spec.DESKeySpec;
 47 import javax.crypto.spec.SecretKeySpec;
 48 
 49 /**
 50  * NTLM authentication implemented according to MS-NLMP, version 12.1
 51  * @since 1.7
 52  */
 53 class NTLM {
 54 
 55     private final SecretKeyFactory fac;
 56     private final Cipher cipher;
 57     private final MessageDigest md4;
 58     private final Mac hmac;
 59     private final MessageDigest md5;
 60     private static final boolean DEBUG
 61             = GetBooleanAction.privilegedGetProperty(&quot;ntlm.debug&quot;);
 62 
 63     final Version v;
 64 
 65     final boolean writeLM;
 66     final boolean writeNTLM;
 67 
 68     protected NTLM(String version) throws NTLMException {
 69         if (version == null) version = &quot;LMv2/NTLMv2&quot;;
 70         switch (version) {
 71             case &quot;LM&quot;: v = NTLM; writeLM = true; writeNTLM = false; break;
 72             case &quot;NTLM&quot;: v = NTLM; writeLM = false; writeNTLM = true; break;
 73             case &quot;LM/NTLM&quot;: v = NTLM; writeLM = writeNTLM = true; break;
 74             case &quot;NTLM2&quot;: v = NTLM2; writeLM = writeNTLM = true; break;
 75             case &quot;LMv2&quot;: v = NTLMv2; writeLM = true; writeNTLM = false; break;
 76             case &quot;NTLMv2&quot;: v = NTLMv2; writeLM = false; writeNTLM = true; break;
 77             case &quot;LMv2/NTLMv2&quot;: v = NTLMv2; writeLM = writeNTLM = true; break;
 78             default: throw new NTLMException(NTLMException.BAD_VERSION,
 79                     &quot;Unknown version &quot; + version);
 80         }
 81         try {
 82             fac = SecretKeyFactory.getInstance (&quot;DES&quot;);
 83             cipher = Cipher.getInstance (&quot;DES/ECB/NoPadding&quot;);
 84             md4 = sun.security.provider.MD4.getInstance();
 85             hmac = Mac.getInstance(&quot;HmacMD5&quot;);
 86             md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 87         } catch (NoSuchPaddingException e) {
 88             throw new AssertionError();
 89         } catch (NoSuchAlgorithmException e) {
 90             throw new AssertionError();
 91         }
 92     }
 93 
 94     /**
 95      * Prints out a formatted string, called in various places inside then NTLM
 96      * implementation for debugging/logging purposes. When the system property
 97      * &quot;ntlm.debug&quot; is set, &lt;code&gt;System.out.printf(format, args)&lt;/code&gt; is
 98      * called. This method is designed to be overridden by child classes to
 99      * match their own debugging/logging mechanisms.
100      * @param format a format string
101      * @param args the arguments referenced by &lt;code&gt;format&lt;/code&gt;
102      * @see java.io.PrintStream#printf(java.lang.String, java.lang.Object[])
103      */
104     public void debug(String format, Object... args) {
105         if (DEBUG) {
106             System.out.printf(format, args);
107         }
108     }
109 
110     /**
111      * Prints out the content of a byte array, called in various places inside
112      * the NTLM implementation for debugging/logging purposes. When the system
113      * property &quot;ntlm.debug&quot; is set, the hexdump of the array is printed into
114      * System.out. This method is designed to be overridden by child classes to
115      * match their own debugging/logging mechanisms.
116      * @param bytes the byte array to print out
117      */
118     public void debug(byte[] bytes) {
119         if (DEBUG) {
120             try {
121                 new sun.security.util.HexDumpEncoder().encodeBuffer(bytes, System.out);
122             } catch (IOException ioe) {
123                 // Impossible
124             }
125         }
126     }
127 
128     /**
129      * Reading an NTLM packet
130      */
131     static class Reader {
132 
133         private final byte[] internal;
134 
135         Reader(byte[] data) {
136             internal = data;
137         }
138 
139         int readInt(int offset) throws NTLMException {
140             try {
141                 return (internal[offset] &amp; 0xff) +
142                         ((internal[offset+1] &amp; 0xff) &lt;&lt; 8) +
143                         ((internal[offset+2] &amp; 0xff) &lt;&lt; 16) +
144                         ((internal[offset+3] &amp; 0xff) &lt;&lt; 24);
145             } catch (ArrayIndexOutOfBoundsException ex) {
146                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
147                         &quot;Input message incorrect size&quot;);
148             }
149         }
150 
151         int readShort(int offset) throws NTLMException {
152             try {
153                 return (internal[offset] &amp; 0xff) +
154                         ((internal[offset+1] &amp; 0xff &lt;&lt; 8));
155             } catch (ArrayIndexOutOfBoundsException ex) {
156                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
157                         &quot;Input message incorrect size&quot;);
158             }
159         }
160 
161         byte[] readBytes(int offset, int len) throws NTLMException {
162             try {
163                 return Arrays.copyOfRange(internal, offset, offset + len);
164             } catch (ArrayIndexOutOfBoundsException ex) {
165                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
166                         &quot;Input message incorrect size&quot;);
167             }
168         }
169 
170         byte[] readSecurityBuffer(int offset) throws NTLMException {
171             int pos = readInt(offset+4);
172             if (pos == 0) return new byte[0];
173             try {
174                 return Arrays.copyOfRange(
175                         internal, pos, pos + readShort(offset));
176             } catch (ArrayIndexOutOfBoundsException ex) {
177                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
178                         &quot;Input message incorrect size&quot;);
179             }
180         }
181 
182         String readSecurityBuffer(int offset, boolean unicode)
183                 throws NTLMException {
184             byte[] raw = readSecurityBuffer(offset);
<a name="3" id="anc3"></a><span class="line-modified">185             try {</span>
<span class="line-modified">186                 return raw == null ? null : new String(</span>
<span class="line-modified">187                         raw, unicode ? &quot;UnicodeLittleUnmarked&quot; : &quot;ISO8859_1&quot;);</span>
<span class="line-removed">188             } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">189                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
<span class="line-removed">190                         &quot;Invalid input encoding&quot;);</span>
<span class="line-removed">191             }</span>
192         }
193     }
194 
195     /**
196      * Writing an NTLM packet
197      */
198     static class Writer {
199 
200         private byte[] internal;    // buffer
201         private int current;        // current written content interface buffer
202 
203         /**
204          * Starts writing a NTLM packet
205          * @param type NEGOTIATE || CHALLENGE || AUTHENTICATE
206          * @param len the base length, without security buffers
207          */
208         Writer(int type, int len) {
209             assert len &lt; 256;
210             internal = new byte[256];
211             current = len;
212             System.arraycopy (
213                     new byte[] {&#39;N&#39;,&#39;T&#39;,&#39;L&#39;,&#39;M&#39;,&#39;S&#39;,&#39;S&#39;,&#39;P&#39;,0,(byte)type},
214                     0, internal, 0, 9);
215         }
216 
217         void writeShort(int offset, int number) {
218             internal[offset] = (byte)(number);
219             internal[offset+1] = (byte)(number &gt;&gt; 8);
220         }
221 
222         void writeInt(int offset, int number) {
223             internal[offset] = (byte)(number);
224             internal[offset+1] = (byte)(number &gt;&gt; 8);
225             internal[offset+2] = (byte)(number &gt;&gt; 16);
226             internal[offset+3] = (byte)(number &gt;&gt; 24);
227         }
228 
229         void writeBytes(int offset, byte[] data) {
230             System.arraycopy(data, 0, internal, offset, data.length);
231         }
232 
233         void writeSecurityBuffer(int offset, byte[] data) {
234             if (data == null) {
235                 writeShort(offset+4, current);
236             } else {
237                 int len = data.length;
238                 if (current + len &gt; internal.length) {
239                     internal = Arrays.copyOf(internal, current + len + 256);
240                 }
241                 writeShort(offset, len);
242                 writeShort(offset+2, len);
243                 writeShort(offset+4, current);
244                 System.arraycopy(data, 0, internal, current, len);
245                 current += len;
246             }
247         }
248 
249         void writeSecurityBuffer(int offset, String str, boolean unicode) {
<a name="4" id="anc4"></a><span class="line-modified">250             try {</span>
<span class="line-modified">251                 writeSecurityBuffer(offset, str == null ? null : str.getBytes(</span>
<span class="line-modified">252                         unicode ? &quot;UnicodeLittleUnmarked&quot; : &quot;ISO8859_1&quot;));</span>
<span class="line-removed">253             } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">254                 assert false;</span>
<span class="line-removed">255             }</span>
256         }
257 
258         byte[] getBytes() {
259             return Arrays.copyOf(internal, current);
260         }
261     }
262 
263     // LM/NTLM
264 
265     /* Convert a 7 byte array to an 8 byte array (for a des key with parity)
266      * input starts at offset off
267      */
268     byte[] makeDesKey (byte[] input, int off) {
269         int[] in = new int [input.length];
270         for (int i=0; i&lt;in.length; i++ ) {
271             in[i] = input[i]&lt;0 ? input[i]+256: input[i];
272         }
273         byte[] out = new byte[8];
274         out[0] = (byte)in[off+0];
275         out[1] = (byte)(((in[off+0] &lt;&lt; 7) &amp; 0xFF) | (in[off+1] &gt;&gt; 1));
276         out[2] = (byte)(((in[off+1] &lt;&lt; 6) &amp; 0xFF) | (in[off+2] &gt;&gt; 2));
277         out[3] = (byte)(((in[off+2] &lt;&lt; 5) &amp; 0xFF) | (in[off+3] &gt;&gt; 3));
278         out[4] = (byte)(((in[off+3] &lt;&lt; 4) &amp; 0xFF) | (in[off+4] &gt;&gt; 4));
279         out[5] = (byte)(((in[off+4] &lt;&lt; 3) &amp; 0xFF) | (in[off+5] &gt;&gt; 5));
280         out[6] = (byte)(((in[off+5] &lt;&lt; 2) &amp; 0xFF) | (in[off+6] &gt;&gt; 6));
281         out[7] = (byte)((in[off+6] &lt;&lt; 1) &amp; 0xFF);
282         return out;
283     }
284 
285     byte[] calcLMHash (byte[] pwb) {
286         byte[] magic = {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};
287         byte[] pwb1 = new byte [14];
288         int len = pwb.length;
289         if (len &gt; 14)
290             len = 14;
291         System.arraycopy (pwb, 0, pwb1, 0, len); /* Zero padded */
292 
293         try {
294             DESKeySpec dks1 = new DESKeySpec (makeDesKey (pwb1, 0));
295             DESKeySpec dks2 = new DESKeySpec (makeDesKey (pwb1, 7));
296 
297             SecretKey key1 = fac.generateSecret (dks1);
298             SecretKey key2 = fac.generateSecret (dks2);
299             cipher.init (Cipher.ENCRYPT_MODE, key1);
300             byte[] out1 = cipher.doFinal (magic, 0, 8);
301             cipher.init (Cipher.ENCRYPT_MODE, key2);
302             byte[] out2 = cipher.doFinal (magic, 0, 8);
303             byte[] result = new byte [21];
304             System.arraycopy (out1, 0, result, 0, 8);
305             System.arraycopy (out2, 0, result, 8, 8);
306             return result;
307         } catch (InvalidKeyException ive) {
308             // Will not happen, all key material are 8 bytes
309             assert false;
310         } catch (InvalidKeySpecException ikse) {
311             // Will not happen, we only feed DESKeySpec to DES factory
312             assert false;
313         } catch (IllegalBlockSizeException ibse) {
314             // Will not happen, we encrypt 8 bytes
315             assert false;
316         } catch (BadPaddingException bpe) {
317             // Will not happen, this is encryption
318             assert false;
319         }
320         return null;    // will not happen, we returned already
321     }
322 
323     byte[] calcNTHash (byte[] pw) {
324         byte[] out = md4.digest (pw);
325         byte[] result = new byte [21];
326         System.arraycopy (out, 0, result, 0, 16);
327         return result;
328     }
329 
330     /* key is a 21 byte array. Split it into 3 7 byte chunks,
331      * Convert each to 8 byte DES keys, encrypt the text arg with
332      * each key and return the three results in a sequential []
333      */
334     byte[] calcResponse (byte[] key, byte[] text) {
335         try {
336             assert key.length == 21;
337             DESKeySpec dks1 = new DESKeySpec(makeDesKey(key, 0));
338             DESKeySpec dks2 = new DESKeySpec(makeDesKey(key, 7));
339             DESKeySpec dks3 = new DESKeySpec(makeDesKey(key, 14));
340             SecretKey key1 = fac.generateSecret(dks1);
341             SecretKey key2 = fac.generateSecret(dks2);
342             SecretKey key3 = fac.generateSecret(dks3);
343             cipher.init(Cipher.ENCRYPT_MODE, key1);
344             byte[] out1 = cipher.doFinal(text, 0, 8);
345             cipher.init(Cipher.ENCRYPT_MODE, key2);
346             byte[] out2 = cipher.doFinal(text, 0, 8);
347             cipher.init(Cipher.ENCRYPT_MODE, key3);
348             byte[] out3 = cipher.doFinal(text, 0, 8);
349             byte[] result = new byte[24];
350             System.arraycopy(out1, 0, result, 0, 8);
351             System.arraycopy(out2, 0, result, 8, 8);
352             System.arraycopy(out3, 0, result, 16, 8);
353             return result;
354         } catch (IllegalBlockSizeException ex) {    // None will happen
355             assert false;
356         } catch (BadPaddingException ex) {
357             assert false;
358         } catch (InvalidKeySpecException ex) {
359             assert false;
360         } catch (InvalidKeyException ex) {
361             assert false;
362         }
363         return null;
364     }
365 
366     // LMv2/NTLMv2
367 
368     byte[] hmacMD5(byte[] key, byte[] text) {
369         try {
370             SecretKeySpec skey =
371                     new SecretKeySpec(Arrays.copyOf(key, 16), &quot;HmacMD5&quot;);
372             hmac.init(skey);
373             return hmac.doFinal(text);
374         } catch (InvalidKeyException ex) {
375             assert false;
376         } catch (RuntimeException e) {
377             assert false;
378         }
379         return null;
380     }
381 
382     byte[] calcV2(byte[] nthash, String text, byte[] blob, byte[] challenge) {
<a name="5" id="anc5"></a><span class="line-modified">383         try {</span>
<span class="line-modified">384             byte[] ntlmv2hash = hmacMD5(nthash,</span>
<span class="line-modified">385                     text.getBytes(&quot;UnicodeLittleUnmarked&quot;));</span>
<span class="line-modified">386             byte[] cn = new byte[blob.length+8];</span>
<span class="line-modified">387             System.arraycopy(challenge, 0, cn, 0, 8);</span>
<span class="line-modified">388             System.arraycopy(blob, 0, cn, 8, blob.length);</span>
<span class="line-modified">389             byte[] result = new byte[16+blob.length];</span>
<span class="line-modified">390             System.arraycopy(hmacMD5(ntlmv2hash, cn), 0, result, 0, 16);</span>
<span class="line-removed">391             System.arraycopy(blob, 0, result, 16, blob.length);</span>
<span class="line-removed">392             return result;</span>
<span class="line-removed">393         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">394             assert false;</span>
<span class="line-removed">395         }</span>
<span class="line-removed">396         return null;</span>
397     }
398 
399     // NTLM2 LM/NTLM
400 
401     static byte[] ntlm2LM(byte[] nonce) {
402         return Arrays.copyOf(nonce, 24);
403     }
404 
405     byte[] ntlm2NTLM(byte[] ntlmHash, byte[] nonce, byte[] challenge) {
406         byte[] b = Arrays.copyOf(challenge, 16);
407         System.arraycopy(nonce, 0, b, 8, 8);
408         byte[] sesshash = Arrays.copyOf(md5.digest(b), 8);
409         return calcResponse(ntlmHash, sesshash);
410     }
411 
412     // Password in ASCII and UNICODE
413 
414     static byte[] getP1(char[] password) {
<a name="6" id="anc6"></a><span class="line-modified">415         try {</span>
<span class="line-modified">416             return new String(password).toUpperCase(</span>
<span class="line-removed">417                                     Locale.ENGLISH).getBytes(&quot;ISO8859_1&quot;);</span>
<span class="line-removed">418         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">419             return null;</span>
<span class="line-removed">420         }</span>
421     }
422 
423     static byte[] getP2(char[] password) {
<a name="7" id="anc7"></a><span class="line-modified">424         try {</span>
<span class="line-removed">425             return new String(password).getBytes(&quot;UnicodeLittleUnmarked&quot;);</span>
<span class="line-removed">426         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">427             return null;</span>
<span class="line-removed">428         }</span>
429     }
430 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
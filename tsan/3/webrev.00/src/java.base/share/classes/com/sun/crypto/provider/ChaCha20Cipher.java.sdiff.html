<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/crypto/provider/ChaCha20Cipher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../macosx/native/libosxsecurity/KeystoreImpl.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CipherCore.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/ChaCha20Cipher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.crypto.provider;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.lang.invoke.MethodHandles;
  31 import java.lang.invoke.VarHandle;
  32 import java.nio.ByteBuffer;
  33 import java.nio.ByteOrder;
  34 import java.security.*;
  35 import java.security.spec.AlgorithmParameterSpec;
<span class="line-removed">  36 import java.util.Arrays;</span>
  37 import java.util.Objects;

  38 import javax.crypto.spec.ChaCha20ParameterSpec;
  39 import javax.crypto.spec.IvParameterSpec;
  40 import javax.crypto.spec.SecretKeySpec;
<span class="line-removed">  41 import javax.crypto.*;</span>
  42 import sun.security.util.DerValue;
  43 
  44 /**
  45  * Implementation of the ChaCha20 cipher, as described in RFC 7539.
  46  *
  47  * @since 11
  48  */
  49 abstract class ChaCha20Cipher extends CipherSpi {
  50     // Mode constants
  51     private static final int MODE_NONE = 0;
  52     private static final int MODE_AEAD = 1;
  53 
  54     // Constants used in setting up the initial state
  55     private static final int STATE_CONST_0 = 0x61707865;
  56     private static final int STATE_CONST_1 = 0x3320646e;
  57     private static final int STATE_CONST_2 = 0x79622d32;
  58     private static final int STATE_CONST_3 = 0x6b206574;
  59 
  60     // The keystream block size in bytes and as integers
  61     private static final int KEYSTREAM_SIZE = 64;
</pre>
<hr />
<pre>
 117     // Use this VarHandle for converting the state elements into little-endian
 118     // integer values for the ChaCha20 block function.
 119     private static final VarHandle asIntLittleEndian =
 120             MethodHandles.byteArrayViewVarHandle(int[].class,
 121                     ByteOrder.LITTLE_ENDIAN);
 122 
 123     // Use this VarHandle for converting the AAD and data lengths into
 124     // little-endian long values for AEAD tag computations.
 125     private static final VarHandle asLongLittleEndian =
 126             MethodHandles.byteArrayViewVarHandle(long[].class,
 127                     ByteOrder.LITTLE_ENDIAN);
 128 
 129     // Use this for pulling in 8 bytes at a time as longs for XOR operations
 130     private static final VarHandle asLongView =
 131             MethodHandles.byteArrayViewVarHandle(long[].class,
 132                     ByteOrder.nativeOrder());
 133 
 134     /**
 135      * Default constructor.
 136      */
<span class="line-modified"> 137     protected ChaCha20Cipher() {</span>
<span class="line-removed"> 138     }</span>
 139 
 140     /**
 141      * Set the mode of operation.  Since this is a stream cipher, there
 142      * is no mode of operation in the block-cipher sense of things.  The
 143      * protected {@code mode} field will only accept a value of {@code None}
 144      * (case-insensitive).
 145      *
 146      * @param mode The mode value
 147      *
 148      * @throws NoSuchAlgorithmException if a mode of operation besides
 149      *      {@code None} is provided.
 150      */
 151     @Override
 152     protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
 153         if (mode.equalsIgnoreCase(&quot;None&quot;) == false) {
 154             throw new NoSuchAlgorithmException(&quot;Mode must be None&quot;);
 155         }
 156     }
 157 
 158     /**
</pre>
<hr />
<pre>
 168     @Override
 169     protected void engineSetPadding(String padding)
 170             throws NoSuchPaddingException {
 171         if (padding.equalsIgnoreCase(&quot;NoPadding&quot;) == false) {
 172             throw new NoSuchPaddingException(&quot;Padding must be NoPadding&quot;);
 173         }
 174     }
 175 
 176     /**
 177      * Returns the block size.  For a stream cipher like ChaCha20, this
 178      * value will always be zero.
 179      *
 180      * @return This method always returns 0.  See the JCE Specification.
 181      */
 182     @Override
 183     protected int engineGetBlockSize() {
 184         return 0;
 185     }
 186 
 187     /**
<span class="line-modified"> 188      * Get the output size based on an input length.  In simple stream-cipher</span>

 189      * mode, the output size will equal the input size.  For ChaCha20-Poly1305
 190      * for encryption the output size will be the sum of the input length
<span class="line-modified"> 191      * and tag length.  For decryption, the output size will be the input</span>
<span class="line-modified"> 192      * length less the tag length or zero, whichever is larger.</span>

 193      *
 194      * @param inputLen the length in bytes of the input
 195      *
 196      * @return the output length in bytes.
 197      */
 198     @Override
 199     protected int engineGetOutputSize(int inputLen) {
<span class="line-modified"> 200         int outLen = 0;</span>
<span class="line-removed"> 201 </span>
<span class="line-removed"> 202         if (mode == MODE_NONE) {</span>
<span class="line-removed"> 203             outLen = inputLen;</span>
<span class="line-removed"> 204         } else if (mode == MODE_AEAD) {</span>
<span class="line-removed"> 205             outLen = (direction == Cipher.ENCRYPT_MODE) ?</span>
<span class="line-removed"> 206                     Math.addExact(inputLen, TAG_LENGTH) :</span>
<span class="line-removed"> 207                     Integer.max(inputLen - TAG_LENGTH, 0);</span>
<span class="line-removed"> 208         }</span>
<span class="line-removed"> 209 </span>
<span class="line-removed"> 210         return outLen;</span>
 211     }
 212 
 213     /**
 214      * Get the nonce value used.
 215      *
 216      * @return the nonce bytes.  For ChaCha20 this will be a 12-byte value.
 217      */
 218     @Override
 219     protected byte[] engineGetIV() {
 220         return nonce.clone();
 221     }
 222 
 223     /**
 224      * Get the algorithm parameters for this cipher.  For the ChaCha20
 225      * cipher, this will always return {@code null} as there currently is
 226      * no {@code AlgorithmParameters} implementation for ChaCha20.  For
 227      * ChaCha20-Poly1305, a {@code ChaCha20Poly1305Parameters} object will be
 228      * created and initialized with the configured nonce value and returned
 229      * to the caller.
 230      *
 231      * @return a {@code null} value if the ChaCha20 cipher is used (mode is
 232      * MODE_NONE), or a {@code ChaCha20Poly1305Parameters} object containing
 233      * the nonce if the mode is MODE_AEAD.
 234      */
 235     @Override
 236     protected AlgorithmParameters engineGetParameters() {
 237         AlgorithmParameters params = null;
 238         if (mode == MODE_AEAD) {
 239             try {
<span class="line-modified"> 240                 // Force the 12-byte nonce into a DER-encoded OCTET_STRING</span>
<span class="line-removed"> 241                 byte[] derNonce = new byte[nonce.length + 2];</span>
<span class="line-removed"> 242                 derNonce[0] = 0x04;                 // OCTET_STRING tag</span>
<span class="line-removed"> 243                 derNonce[1] = (byte)nonce.length;   // 12-byte length;</span>
<span class="line-removed"> 244                 System.arraycopy(nonce, 0, derNonce, 2, nonce.length);</span>
 245                 params = AlgorithmParameters.getInstance(&quot;ChaCha20-Poly1305&quot;);
<span class="line-modified"> 246                 params.init(derNonce);</span>

 247             } catch (NoSuchAlgorithmException | IOException exc) {
 248                 throw new RuntimeException(exc);
 249             }
 250         }
 251 
 252         return params;
 253     }
 254 
 255     /**
 256      * Initialize the engine using a key and secure random implementation.  If
 257      * a SecureRandom object is provided it will be used to create a random
 258      * nonce value.  If the {@code random} parameter is null an internal
 259      * secure random source will be used to create the random nonce.
 260      * The counter value will be set to 1.
 261      *
 262      * @param opmode the type of operation to do.  This value may not be
 263      *      {@code Cipher.DECRYPT_MODE} or {@code Cipher.UNWRAP_MODE} mode
 264      *      because it must generate random parameters like the nonce.
 265      * @param key a 256-bit key suitable for ChaCha20
 266      * @param random a {@code SecureRandom} implementation used to create the
</pre>
<hr />
<pre>
 621         byte[] encodedKey = key.getEncoded();
 622         if (encodedKey == null || encodedKey.length != 32) {
 623             throw new InvalidKeyException(&quot;Key length must be 256 bits&quot;);
 624         }
 625         return encodedKey;
 626     }
 627 
 628     /**
 629      * Update the currently running operation with additional data
 630      *
 631      * @param in the plaintext or ciphertext input bytes (depending on the
 632      *      operation type).
 633      * @param inOfs the offset into the input array
 634      * @param inLen the length of the data to use for the update operation.
 635      *
 636      * @return the resulting plaintext or ciphertext bytes (depending on
 637      *      the operation type)
 638      */
 639     @Override
 640     protected byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
<span class="line-modified"> 641         byte[] out = new byte[inLen];</span>
 642         try {
 643             engine.doUpdate(in, inOfs, inLen, out, 0);
 644         } catch (ShortBufferException | KeyException exc) {
 645             throw new RuntimeException(exc);
 646         }
 647 
 648         return out;
 649     }
 650 
 651     /**
 652      * Update the currently running operation with additional data
 653      *
 654      * @param in the plaintext or ciphertext input bytes (depending on the
 655      *      operation type).
 656      * @param inOfs the offset into the input array
 657      * @param inLen the length of the data to use for the update operation.
 658      * @param out the byte array that will hold the resulting data.  The array
 659      *      must be large enough to hold the resulting data.
 660      * @param outOfs the offset for the {@code out} buffer to begin writing
 661      *      the resulting data.
</pre>
<hr />
<pre>
 679     }
 680 
 681     /**
 682      * Complete the currently running operation using any final
 683      * data provided by the caller.
 684      *
 685      * @param in the plaintext or ciphertext input bytes (depending on the
 686      *      operation type).
 687      * @param inOfs the offset into the input array
 688      * @param inLen the length of the data to use for the update operation.
 689      *
 690      * @return the resulting plaintext or ciphertext bytes (depending on
 691      *      the operation type)
 692      *
 693      * @throws AEADBadTagException if, during decryption, the provided tag
 694      *      does not match the calculated tag.
 695      */
 696     @Override
 697     protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
 698             throws AEADBadTagException {
<span class="line-modified"> 699         byte[] output = new byte[engineGetOutputSize(inLen)];</span>
 700         try {
 701             engine.doFinal(in, inOfs, inLen, output, 0);
 702         } catch (ShortBufferException | KeyException exc) {
 703             throw new RuntimeException(exc);
 704         } finally {
 705             // Regardless of what happens, the cipher cannot be used for
 706             // further processing until it has been freshly initialized.
 707             initialized = false;
 708         }
 709         return output;
 710     }
 711 
 712     /**
 713      * Complete the currently running operation using any final
 714      * data provided by the caller.
 715      *
 716      * @param in the plaintext or ciphertext input bytes (depending on the
 717      *      operation type).
 718      * @param inOfs the offset into the input array
 719      * @param inLen the length of the data to use for the update operation.
</pre>
<hr />
<pre>
1140     /**
1141      * Write the two 64-bit little-endian length fields into an array
1142      * for processing by the poly1305 authenticator.
1143      *
1144      * @param aLen the length of the AAD.
1145      * @param dLen the length of the application data.
1146      * @param buf the buffer to write the two lengths into.
1147      *
1148      * @note it is the caller&#39;s responsibility to provide an array large
1149      *      enough to hold the two longs.
1150      */
1151     private void authWriteLengths(long aLen, long dLen, byte[] buf) {
1152         asLongLittleEndian.set(buf, 0, aLen);
1153         asLongLittleEndian.set(buf, Long.BYTES, dLen);
1154     }
1155 
1156     /**
1157      * Interface for the underlying processing engines for ChaCha20
1158      */
1159     interface ChaChaEngine {











1160         /**
1161          * Perform a multi-part update for ChaCha20.
1162          *
1163          * @param in the input data.
1164          * @param inOff the offset into the input.
1165          * @param inLen the length of the data to process.
1166          * @param out the output buffer.
1167          * @param outOff the offset at which to write the output data.
1168          *
1169          * @return the number of output bytes written.
1170          *
1171          * @throws ShortBufferException if the output buffer does not
1172          *      provide enough space.
1173          * @throws KeyException if the counter value has been exhausted.
1174          */
1175         int doUpdate(byte[] in, int inOff, int inLen, byte[] out, int outOff)
1176                 throws ShortBufferException, KeyException;
1177 
1178         /**
1179          * Finalize a multi-part or single-part ChaCha20 operation.
</pre>
<hr />
<pre>
1183          * @param inLen the length of the data to process.
1184          * @param out the output buffer.
1185          * @param outOff the offset at which to write the output data.
1186          *
1187          * @return the number of output bytes written.
1188          *
1189          * @throws ShortBufferException if the output buffer does not
1190          *      provide enough space.
1191          * @throws AEADBadTagException if in decryption mode the provided
1192          *      tag and calculated tag do not match.
1193          * @throws KeyException if the counter value has been exhausted.
1194          */
1195         int doFinal(byte[] in, int inOff, int inLen, byte[] out, int outOff)
1196                 throws ShortBufferException, AEADBadTagException, KeyException;
1197     }
1198 
1199     private final class EngineStreamOnly implements ChaChaEngine {
1200 
1201         private EngineStreamOnly () { }
1202 






1203         @Override
1204         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1205                 int outOff) throws ShortBufferException, KeyException {
1206             if (initialized) {
1207                try {
1208                     if (out != null) {
1209                         Objects.checkFromIndexSize(outOff, inLen, out.length);
1210                     } else {
1211                         throw new ShortBufferException(
1212                                 &quot;Output buffer too small&quot;);
1213                     }
1214                 } catch (IndexOutOfBoundsException iobe) {
1215                     throw new ShortBufferException(&quot;Output buffer too small&quot;);
1216                 }
1217                 if (in != null) {
1218                     Objects.checkFromIndexSize(inOff, inLen, in.length);
1219                     chaCha20Transform(in, inOff, inLen, out, outOff);
1220                 }
1221                 return inLen;
1222             } else {
1223                 throw new IllegalStateException(
1224                         &quot;Must use either a different key or iv.&quot;);
1225             }
1226         }
1227 
1228         @Override
1229         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1230                 int outOff) throws ShortBufferException, KeyException {
1231             return doUpdate(in, inOff, inLen, out, outOff);
1232         }
1233     }
1234 
1235     private final class EngineAEADEnc implements ChaChaEngine {
1236 





1237         private EngineAEADEnc() throws InvalidKeyException {
1238             initAuthenticator();
1239             counter = 1;
1240         }
1241 
1242         @Override
1243         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1244                 int outOff) throws ShortBufferException, KeyException {
1245             if (initialized) {
1246                 // If this is the first update since AAD updates, signal that
1247                 // we&#39;re done processing AAD info and pad the AAD to a multiple
1248                 // of 16 bytes.
1249                 if (!aadDone) {
1250                     authPad16(aadLen);
1251                     aadDone = true;
1252                 }
1253                 try {
1254                     if (out != null) {
1255                         Objects.checkFromIndexSize(outOff, inLen, out.length);
1256                     } else {
</pre>
<hr />
<pre>
1277         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1278                 int outOff) throws ShortBufferException, KeyException {
1279             // Make sure we have enough room for the remaining data (if any)
1280             // and the tag.
1281             if ((inLen + TAG_LENGTH) &gt; (out.length - outOff)) {
1282                 throw new ShortBufferException(&quot;Output buffer too small&quot;);
1283             }
1284 
1285             doUpdate(in, inOff, inLen, out, outOff);
1286             authFinalizeData(null, 0, 0, out, outOff + inLen);
1287             aadDone = false;
1288             return inLen + TAG_LENGTH;
1289         }
1290     }
1291 
1292     private final class EngineAEADDec implements ChaChaEngine {
1293 
1294         private final ByteArrayOutputStream cipherBuf;
1295         private final byte[] tag;
1296 












1297         private EngineAEADDec() throws InvalidKeyException {
1298             initAuthenticator();
1299             counter = 1;
1300             cipherBuf = new ByteArrayOutputStream(CIPHERBUF_BASE);
1301             tag = new byte[TAG_LENGTH];
1302         }
1303 
1304         @Override
1305         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1306                 int outOff) {
1307             if (initialized) {
1308                 // If this is the first update since AAD updates, signal that
1309                 // we&#39;re done processing AAD info and pad the AAD to a multiple
1310                 // of 16 bytes.
1311                 if (!aadDone) {
1312                     authPad16(aadLen);
1313                     aadDone = true;
1314                 }
1315 
1316                 if (in != null) {
</pre>
<hr />
<pre>
1346             }
1347             cipherBuf.reset();
1348 
1349             // There must at least be a tag length&#39;s worth of ciphertext
1350             // data in the buffered input.
1351             if (ctPlusTagLen &lt; TAG_LENGTH) {
1352                 throw new AEADBadTagException(&quot;Input too short - need tag&quot;);
1353             }
1354             int ctLen = ctPlusTagLen - TAG_LENGTH;
1355 
1356             // Make sure we will have enough room for the output buffer
1357             try {
1358                 Objects.checkFromIndexSize(outOff, ctLen, out.length);
1359             } catch (IndexOutOfBoundsException ioobe) {
1360                 throw new ShortBufferException(&quot;Output buffer too small&quot;);
1361             }
1362 
1363             // Calculate and compare the tag.  Only do the decryption
1364             // if and only if the tag matches.
1365             authFinalizeData(ctPlusTag, 0, ctLen, tag, 0);
<span class="line-modified">1366             if (Arrays.compare(ctPlusTag, ctLen, ctPlusTagLen,</span>
<span class="line-modified">1367                     tag, 0, tag.length) != 0) {</span>



1368                 throw new AEADBadTagException(&quot;Tag mismatch&quot;);
1369             }
1370             chaCha20Transform(ctPlusTag, 0, ctLen, out, outOff);
1371             aadDone = false;
1372 
1373             return ctLen;
1374         }
1375     }
1376 
1377     public static final class ChaCha20Only extends ChaCha20Cipher {
1378         public ChaCha20Only() {
1379             mode = MODE_NONE;
1380         }
1381     }
1382 
1383     public static final class ChaCha20Poly1305 extends ChaCha20Cipher {
1384         public ChaCha20Poly1305() {
1385             mode = MODE_AEAD;
1386             authAlgName = &quot;Poly1305&quot;;
1387         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.crypto.provider;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.lang.invoke.MethodHandles;
  31 import java.lang.invoke.VarHandle;
  32 import java.nio.ByteBuffer;
  33 import java.nio.ByteOrder;
  34 import java.security.*;
  35 import java.security.spec.AlgorithmParameterSpec;

  36 import java.util.Objects;
<span class="line-added">  37 import javax.crypto.*;</span>
  38 import javax.crypto.spec.ChaCha20ParameterSpec;
  39 import javax.crypto.spec.IvParameterSpec;
  40 import javax.crypto.spec.SecretKeySpec;

  41 import sun.security.util.DerValue;
  42 
  43 /**
  44  * Implementation of the ChaCha20 cipher, as described in RFC 7539.
  45  *
  46  * @since 11
  47  */
  48 abstract class ChaCha20Cipher extends CipherSpi {
  49     // Mode constants
  50     private static final int MODE_NONE = 0;
  51     private static final int MODE_AEAD = 1;
  52 
  53     // Constants used in setting up the initial state
  54     private static final int STATE_CONST_0 = 0x61707865;
  55     private static final int STATE_CONST_1 = 0x3320646e;
  56     private static final int STATE_CONST_2 = 0x79622d32;
  57     private static final int STATE_CONST_3 = 0x6b206574;
  58 
  59     // The keystream block size in bytes and as integers
  60     private static final int KEYSTREAM_SIZE = 64;
</pre>
<hr />
<pre>
 116     // Use this VarHandle for converting the state elements into little-endian
 117     // integer values for the ChaCha20 block function.
 118     private static final VarHandle asIntLittleEndian =
 119             MethodHandles.byteArrayViewVarHandle(int[].class,
 120                     ByteOrder.LITTLE_ENDIAN);
 121 
 122     // Use this VarHandle for converting the AAD and data lengths into
 123     // little-endian long values for AEAD tag computations.
 124     private static final VarHandle asLongLittleEndian =
 125             MethodHandles.byteArrayViewVarHandle(long[].class,
 126                     ByteOrder.LITTLE_ENDIAN);
 127 
 128     // Use this for pulling in 8 bytes at a time as longs for XOR operations
 129     private static final VarHandle asLongView =
 130             MethodHandles.byteArrayViewVarHandle(long[].class,
 131                     ByteOrder.nativeOrder());
 132 
 133     /**
 134      * Default constructor.
 135      */
<span class="line-modified"> 136     protected ChaCha20Cipher() { }</span>

 137 
 138     /**
 139      * Set the mode of operation.  Since this is a stream cipher, there
 140      * is no mode of operation in the block-cipher sense of things.  The
 141      * protected {@code mode} field will only accept a value of {@code None}
 142      * (case-insensitive).
 143      *
 144      * @param mode The mode value
 145      *
 146      * @throws NoSuchAlgorithmException if a mode of operation besides
 147      *      {@code None} is provided.
 148      */
 149     @Override
 150     protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
 151         if (mode.equalsIgnoreCase(&quot;None&quot;) == false) {
 152             throw new NoSuchAlgorithmException(&quot;Mode must be None&quot;);
 153         }
 154     }
 155 
 156     /**
</pre>
<hr />
<pre>
 166     @Override
 167     protected void engineSetPadding(String padding)
 168             throws NoSuchPaddingException {
 169         if (padding.equalsIgnoreCase(&quot;NoPadding&quot;) == false) {
 170             throw new NoSuchPaddingException(&quot;Padding must be NoPadding&quot;);
 171         }
 172     }
 173 
 174     /**
 175      * Returns the block size.  For a stream cipher like ChaCha20, this
 176      * value will always be zero.
 177      *
 178      * @return This method always returns 0.  See the JCE Specification.
 179      */
 180     @Override
 181     protected int engineGetBlockSize() {
 182         return 0;
 183     }
 184 
 185     /**
<span class="line-modified"> 186      * Get the output size required to hold the result of the next update or</span>
<span class="line-added"> 187      * doFinal operation.  In simple stream-cipher</span>
 188      * mode, the output size will equal the input size.  For ChaCha20-Poly1305
 189      * for encryption the output size will be the sum of the input length
<span class="line-modified"> 190      * and tag length.  For decryption, the output size will be  the input</span>
<span class="line-modified"> 191      * length plus any previously unprocessed data minus the tag</span>
<span class="line-added"> 192      * length, minimum zero.</span>
 193      *
 194      * @param inputLen the length in bytes of the input
 195      *
 196      * @return the output length in bytes.
 197      */
 198     @Override
 199     protected int engineGetOutputSize(int inputLen) {
<span class="line-modified"> 200         return engine.getOutputSize(inputLen, true);</span>










 201     }
 202 
 203     /**
 204      * Get the nonce value used.
 205      *
 206      * @return the nonce bytes.  For ChaCha20 this will be a 12-byte value.
 207      */
 208     @Override
 209     protected byte[] engineGetIV() {
 210         return nonce.clone();
 211     }
 212 
 213     /**
 214      * Get the algorithm parameters for this cipher.  For the ChaCha20
 215      * cipher, this will always return {@code null} as there currently is
 216      * no {@code AlgorithmParameters} implementation for ChaCha20.  For
 217      * ChaCha20-Poly1305, a {@code ChaCha20Poly1305Parameters} object will be
 218      * created and initialized with the configured nonce value and returned
 219      * to the caller.
 220      *
 221      * @return a {@code null} value if the ChaCha20 cipher is used (mode is
 222      * MODE_NONE), or a {@code ChaCha20Poly1305Parameters} object containing
 223      * the nonce if the mode is MODE_AEAD.
 224      */
 225     @Override
 226     protected AlgorithmParameters engineGetParameters() {
 227         AlgorithmParameters params = null;
 228         if (mode == MODE_AEAD) {
 229             try {
<span class="line-modified"> 230                 // Place the 12-byte nonce into a DER-encoded OCTET_STRING</span>




 231                 params = AlgorithmParameters.getInstance(&quot;ChaCha20-Poly1305&quot;);
<span class="line-modified"> 232                 params.init((new DerValue(</span>
<span class="line-added"> 233                         DerValue.tag_OctetString, nonce).toByteArray()));</span>
 234             } catch (NoSuchAlgorithmException | IOException exc) {
 235                 throw new RuntimeException(exc);
 236             }
 237         }
 238 
 239         return params;
 240     }
 241 
 242     /**
 243      * Initialize the engine using a key and secure random implementation.  If
 244      * a SecureRandom object is provided it will be used to create a random
 245      * nonce value.  If the {@code random} parameter is null an internal
 246      * secure random source will be used to create the random nonce.
 247      * The counter value will be set to 1.
 248      *
 249      * @param opmode the type of operation to do.  This value may not be
 250      *      {@code Cipher.DECRYPT_MODE} or {@code Cipher.UNWRAP_MODE} mode
 251      *      because it must generate random parameters like the nonce.
 252      * @param key a 256-bit key suitable for ChaCha20
 253      * @param random a {@code SecureRandom} implementation used to create the
</pre>
<hr />
<pre>
 608         byte[] encodedKey = key.getEncoded();
 609         if (encodedKey == null || encodedKey.length != 32) {
 610             throw new InvalidKeyException(&quot;Key length must be 256 bits&quot;);
 611         }
 612         return encodedKey;
 613     }
 614 
 615     /**
 616      * Update the currently running operation with additional data
 617      *
 618      * @param in the plaintext or ciphertext input bytes (depending on the
 619      *      operation type).
 620      * @param inOfs the offset into the input array
 621      * @param inLen the length of the data to use for the update operation.
 622      *
 623      * @return the resulting plaintext or ciphertext bytes (depending on
 624      *      the operation type)
 625      */
 626     @Override
 627     protected byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
<span class="line-modified"> 628         byte[] out = new byte[engine.getOutputSize(inLen, false)];</span>
 629         try {
 630             engine.doUpdate(in, inOfs, inLen, out, 0);
 631         } catch (ShortBufferException | KeyException exc) {
 632             throw new RuntimeException(exc);
 633         }
 634 
 635         return out;
 636     }
 637 
 638     /**
 639      * Update the currently running operation with additional data
 640      *
 641      * @param in the plaintext or ciphertext input bytes (depending on the
 642      *      operation type).
 643      * @param inOfs the offset into the input array
 644      * @param inLen the length of the data to use for the update operation.
 645      * @param out the byte array that will hold the resulting data.  The array
 646      *      must be large enough to hold the resulting data.
 647      * @param outOfs the offset for the {@code out} buffer to begin writing
 648      *      the resulting data.
</pre>
<hr />
<pre>
 666     }
 667 
 668     /**
 669      * Complete the currently running operation using any final
 670      * data provided by the caller.
 671      *
 672      * @param in the plaintext or ciphertext input bytes (depending on the
 673      *      operation type).
 674      * @param inOfs the offset into the input array
 675      * @param inLen the length of the data to use for the update operation.
 676      *
 677      * @return the resulting plaintext or ciphertext bytes (depending on
 678      *      the operation type)
 679      *
 680      * @throws AEADBadTagException if, during decryption, the provided tag
 681      *      does not match the calculated tag.
 682      */
 683     @Override
 684     protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
 685             throws AEADBadTagException {
<span class="line-modified"> 686         byte[] output = new byte[engine.getOutputSize(inLen, true)];</span>
 687         try {
 688             engine.doFinal(in, inOfs, inLen, output, 0);
 689         } catch (ShortBufferException | KeyException exc) {
 690             throw new RuntimeException(exc);
 691         } finally {
 692             // Regardless of what happens, the cipher cannot be used for
 693             // further processing until it has been freshly initialized.
 694             initialized = false;
 695         }
 696         return output;
 697     }
 698 
 699     /**
 700      * Complete the currently running operation using any final
 701      * data provided by the caller.
 702      *
 703      * @param in the plaintext or ciphertext input bytes (depending on the
 704      *      operation type).
 705      * @param inOfs the offset into the input array
 706      * @param inLen the length of the data to use for the update operation.
</pre>
<hr />
<pre>
1127     /**
1128      * Write the two 64-bit little-endian length fields into an array
1129      * for processing by the poly1305 authenticator.
1130      *
1131      * @param aLen the length of the AAD.
1132      * @param dLen the length of the application data.
1133      * @param buf the buffer to write the two lengths into.
1134      *
1135      * @note it is the caller&#39;s responsibility to provide an array large
1136      *      enough to hold the two longs.
1137      */
1138     private void authWriteLengths(long aLen, long dLen, byte[] buf) {
1139         asLongLittleEndian.set(buf, 0, aLen);
1140         asLongLittleEndian.set(buf, Long.BYTES, dLen);
1141     }
1142 
1143     /**
1144      * Interface for the underlying processing engines for ChaCha20
1145      */
1146     interface ChaChaEngine {
<span class="line-added">1147         /**</span>
<span class="line-added">1148          * Size an output buffer based on the input and where applicable</span>
<span class="line-added">1149          * the current state of the engine in a multipart operation.</span>
<span class="line-added">1150          *</span>
<span class="line-added">1151          * @param inLength the input length.</span>
<span class="line-added">1152          * @param isFinal true if this is invoked from a doFinal call.</span>
<span class="line-added">1153          *</span>
<span class="line-added">1154          * @return the recommended size for the output buffer.</span>
<span class="line-added">1155          */</span>
<span class="line-added">1156         int getOutputSize(int inLength, boolean isFinal);</span>
<span class="line-added">1157 </span>
1158         /**
1159          * Perform a multi-part update for ChaCha20.
1160          *
1161          * @param in the input data.
1162          * @param inOff the offset into the input.
1163          * @param inLen the length of the data to process.
1164          * @param out the output buffer.
1165          * @param outOff the offset at which to write the output data.
1166          *
1167          * @return the number of output bytes written.
1168          *
1169          * @throws ShortBufferException if the output buffer does not
1170          *      provide enough space.
1171          * @throws KeyException if the counter value has been exhausted.
1172          */
1173         int doUpdate(byte[] in, int inOff, int inLen, byte[] out, int outOff)
1174                 throws ShortBufferException, KeyException;
1175 
1176         /**
1177          * Finalize a multi-part or single-part ChaCha20 operation.
</pre>
<hr />
<pre>
1181          * @param inLen the length of the data to process.
1182          * @param out the output buffer.
1183          * @param outOff the offset at which to write the output data.
1184          *
1185          * @return the number of output bytes written.
1186          *
1187          * @throws ShortBufferException if the output buffer does not
1188          *      provide enough space.
1189          * @throws AEADBadTagException if in decryption mode the provided
1190          *      tag and calculated tag do not match.
1191          * @throws KeyException if the counter value has been exhausted.
1192          */
1193         int doFinal(byte[] in, int inOff, int inLen, byte[] out, int outOff)
1194                 throws ShortBufferException, AEADBadTagException, KeyException;
1195     }
1196 
1197     private final class EngineStreamOnly implements ChaChaEngine {
1198 
1199         private EngineStreamOnly () { }
1200 
<span class="line-added">1201         @Override</span>
<span class="line-added">1202         public int getOutputSize(int inLength, boolean isFinal) {</span>
<span class="line-added">1203             // The isFinal parameter is not relevant in this kind of engine</span>
<span class="line-added">1204             return inLength;</span>
<span class="line-added">1205         }</span>
<span class="line-added">1206 </span>
1207         @Override
1208         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1209                 int outOff) throws ShortBufferException, KeyException {
1210             if (initialized) {
1211                try {
1212                     if (out != null) {
1213                         Objects.checkFromIndexSize(outOff, inLen, out.length);
1214                     } else {
1215                         throw new ShortBufferException(
1216                                 &quot;Output buffer too small&quot;);
1217                     }
1218                 } catch (IndexOutOfBoundsException iobe) {
1219                     throw new ShortBufferException(&quot;Output buffer too small&quot;);
1220                 }
1221                 if (in != null) {
1222                     Objects.checkFromIndexSize(inOff, inLen, in.length);
1223                     chaCha20Transform(in, inOff, inLen, out, outOff);
1224                 }
1225                 return inLen;
1226             } else {
1227                 throw new IllegalStateException(
1228                         &quot;Must use either a different key or iv.&quot;);
1229             }
1230         }
1231 
1232         @Override
1233         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1234                 int outOff) throws ShortBufferException, KeyException {
1235             return doUpdate(in, inOff, inLen, out, outOff);
1236         }
1237     }
1238 
1239     private final class EngineAEADEnc implements ChaChaEngine {
1240 
<span class="line-added">1241         @Override</span>
<span class="line-added">1242         public int getOutputSize(int inLength, boolean isFinal) {</span>
<span class="line-added">1243             return (isFinal ? Math.addExact(inLength, TAG_LENGTH) : inLength);</span>
<span class="line-added">1244         }</span>
<span class="line-added">1245 </span>
1246         private EngineAEADEnc() throws InvalidKeyException {
1247             initAuthenticator();
1248             counter = 1;
1249         }
1250 
1251         @Override
1252         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1253                 int outOff) throws ShortBufferException, KeyException {
1254             if (initialized) {
1255                 // If this is the first update since AAD updates, signal that
1256                 // we&#39;re done processing AAD info and pad the AAD to a multiple
1257                 // of 16 bytes.
1258                 if (!aadDone) {
1259                     authPad16(aadLen);
1260                     aadDone = true;
1261                 }
1262                 try {
1263                     if (out != null) {
1264                         Objects.checkFromIndexSize(outOff, inLen, out.length);
1265                     } else {
</pre>
<hr />
<pre>
1286         public int doFinal(byte[] in, int inOff, int inLen, byte[] out,
1287                 int outOff) throws ShortBufferException, KeyException {
1288             // Make sure we have enough room for the remaining data (if any)
1289             // and the tag.
1290             if ((inLen + TAG_LENGTH) &gt; (out.length - outOff)) {
1291                 throw new ShortBufferException(&quot;Output buffer too small&quot;);
1292             }
1293 
1294             doUpdate(in, inOff, inLen, out, outOff);
1295             authFinalizeData(null, 0, 0, out, outOff + inLen);
1296             aadDone = false;
1297             return inLen + TAG_LENGTH;
1298         }
1299     }
1300 
1301     private final class EngineAEADDec implements ChaChaEngine {
1302 
1303         private final ByteArrayOutputStream cipherBuf;
1304         private final byte[] tag;
1305 
<span class="line-added">1306         @Override</span>
<span class="line-added">1307         public int getOutputSize(int inLen, boolean isFinal) {</span>
<span class="line-added">1308             // If we are performing a decrypt-update we should always return</span>
<span class="line-added">1309             // zero length since we cannot return any data until the tag has</span>
<span class="line-added">1310             // been consumed and verified.  CipherSpi.engineGetOutputSize will</span>
<span class="line-added">1311             // always set isFinal to true to get the required output buffer</span>
<span class="line-added">1312             // size.</span>
<span class="line-added">1313             return (isFinal ?</span>
<span class="line-added">1314                     Integer.max(Math.addExact((inLen - TAG_LENGTH),</span>
<span class="line-added">1315                             cipherBuf.size()), 0) : 0);</span>
<span class="line-added">1316         }</span>
<span class="line-added">1317 </span>
1318         private EngineAEADDec() throws InvalidKeyException {
1319             initAuthenticator();
1320             counter = 1;
1321             cipherBuf = new ByteArrayOutputStream(CIPHERBUF_BASE);
1322             tag = new byte[TAG_LENGTH];
1323         }
1324 
1325         @Override
1326         public int doUpdate(byte[] in, int inOff, int inLen, byte[] out,
1327                 int outOff) {
1328             if (initialized) {
1329                 // If this is the first update since AAD updates, signal that
1330                 // we&#39;re done processing AAD info and pad the AAD to a multiple
1331                 // of 16 bytes.
1332                 if (!aadDone) {
1333                     authPad16(aadLen);
1334                     aadDone = true;
1335                 }
1336 
1337                 if (in != null) {
</pre>
<hr />
<pre>
1367             }
1368             cipherBuf.reset();
1369 
1370             // There must at least be a tag length&#39;s worth of ciphertext
1371             // data in the buffered input.
1372             if (ctPlusTagLen &lt; TAG_LENGTH) {
1373                 throw new AEADBadTagException(&quot;Input too short - need tag&quot;);
1374             }
1375             int ctLen = ctPlusTagLen - TAG_LENGTH;
1376 
1377             // Make sure we will have enough room for the output buffer
1378             try {
1379                 Objects.checkFromIndexSize(outOff, ctLen, out.length);
1380             } catch (IndexOutOfBoundsException ioobe) {
1381                 throw new ShortBufferException(&quot;Output buffer too small&quot;);
1382             }
1383 
1384             // Calculate and compare the tag.  Only do the decryption
1385             // if and only if the tag matches.
1386             authFinalizeData(ctPlusTag, 0, ctLen, tag, 0);
<span class="line-modified">1387             long tagCompare = ((long)asLongView.get(ctPlusTag, ctLen) ^</span>
<span class="line-modified">1388                     (long)asLongView.get(tag, 0)) |</span>
<span class="line-added">1389                     ((long)asLongView.get(ctPlusTag, ctLen + Long.BYTES) ^</span>
<span class="line-added">1390                     (long)asLongView.get(tag, Long.BYTES));</span>
<span class="line-added">1391             if (tagCompare != 0) {</span>
1392                 throw new AEADBadTagException(&quot;Tag mismatch&quot;);
1393             }
1394             chaCha20Transform(ctPlusTag, 0, ctLen, out, outOff);
1395             aadDone = false;
1396 
1397             return ctLen;
1398         }
1399     }
1400 
1401     public static final class ChaCha20Only extends ChaCha20Cipher {
1402         public ChaCha20Only() {
1403             mode = MODE_NONE;
1404         }
1405     }
1406 
1407     public static final class ChaCha20Poly1305 extends ChaCha20Cipher {
1408         public ChaCha20Poly1305() {
1409             mode = MODE_AEAD;
1410             authAlgName = &quot;Poly1305&quot;;
1411         }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../macosx/native/libosxsecurity/KeystoreImpl.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CipherCore.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
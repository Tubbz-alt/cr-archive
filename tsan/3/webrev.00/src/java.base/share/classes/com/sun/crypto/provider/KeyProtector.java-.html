<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/com/sun/crypto/provider/KeyProtector.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.io.IOException;
 29 import java.security.Key;
 30 import java.security.PrivateKey;
 31 import java.security.Provider;
 32 import java.security.KeyFactory;
 33 import java.security.MessageDigest;
 34 import java.security.GeneralSecurityException;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.UnrecoverableKeyException;
 37 import java.security.AlgorithmParameters;
 38 import java.security.spec.InvalidParameterSpecException;
 39 import java.security.spec.PKCS8EncodedKeySpec;
 40 import java.util.Arrays;
 41 
 42 import javax.crypto.Cipher;
 43 import javax.crypto.CipherSpi;
 44 import javax.crypto.SecretKey;
 45 import javax.crypto.SealedObject;
 46 import javax.crypto.spec.*;
 47 import javax.security.auth.DestroyFailedException;
 48 
 49 import sun.security.x509.AlgorithmId;
 50 import sun.security.util.ObjectIdentifier;
 51 
 52 /**
 53  * This class implements a protection mechanism for private keys. In JCE, we
 54  * use a stronger protection mechanism than in the JDK, because we can use
 55  * the &lt;code&gt;Cipher&lt;/code&gt; class.
 56  * Private keys are protected using the JCE mechanism, and are recovered using
 57  * either the JDK or JCE mechanism, depending on how the key has been
 58  * protected. This allows us to parse Sun&#39;s keystore implementation that ships
 59  * with JDK 1.2.
 60  *
 61  * @author Jan Luehe
 62  *
 63  *
 64  * @see JceKeyStore
 65  */
 66 
 67 final class KeyProtector {
 68 
 69     // defined by SunSoft (SKI project)
 70     private static final String PBE_WITH_MD5_AND_DES3_CBC_OID
 71             = &quot;1.3.6.1.4.1.42.2.19.1&quot;;
 72 
 73     // JavaSoft proprietary key-protection algorithm (used to protect private
 74     // keys in the keystore implementation that comes with JDK 1.2)
 75     private static final String KEY_PROTECTOR_OID = &quot;1.3.6.1.4.1.42.2.17.1.1&quot;;
 76 
 77     private static final int MAX_ITERATION_COUNT = 5000000;
 78     private static final int ITERATION_COUNT = 200000;
 79     private static final int SALT_LEN = 20; // the salt length
 80     private static final int DIGEST_LEN = 20;
 81 
 82     // the password used for protecting/recovering keys passed through this
 83     // key protector
 84     private char[] password;
 85 
 86     KeyProtector(char[] password) {
 87         if (password == null) {
 88            throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
 89         }
 90         this.password = password;
 91     }
 92 
 93     /**
 94      * Protects the given cleartext private key, using the password provided at
 95      * construction time.
 96      */
 97     byte[] protect(PrivateKey key)
 98         throws Exception
 99     {
100         // create a random salt (8 bytes)
101         byte[] salt = new byte[8];
102         SunJCE.getRandom().nextBytes(salt);
103 
104         // create PBE parameters from salt and iteration count
105         PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, ITERATION_COUNT);
106 
107         // create PBE key from password
108         PBEKeySpec pbeKeySpec = new PBEKeySpec(this.password);
109         SecretKey sKey = null;
110         PBEWithMD5AndTripleDESCipher cipher;
111         try {
112             sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
113             // encrypt private key
114             cipher = new PBEWithMD5AndTripleDESCipher();
115             cipher.engineInit(Cipher.ENCRYPT_MODE, sKey, pbeSpec, null);
116         } finally {
117             pbeKeySpec.clearPassword();
118             if (sKey != null) sKey.destroy();
119         }
120         byte[] plain = key.getEncoded();
121         byte[] encrKey = cipher.engineDoFinal(plain, 0, plain.length);
122         Arrays.fill(plain, (byte) 0x00);
123 
124         // wrap encrypted private key in EncryptedPrivateKeyInfo
125         // (as defined in PKCS#8)
126         AlgorithmParameters pbeParams =
127             AlgorithmParameters.getInstance(&quot;PBE&quot;, SunJCE.getInstance());
128         pbeParams.init(pbeSpec);
129 
130         AlgorithmId encrAlg = new AlgorithmId
131             (new ObjectIdentifier(PBE_WITH_MD5_AND_DES3_CBC_OID), pbeParams);
132         return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
133     }
134 
135     /*
136      * Recovers the cleartext version of the given key (in protected format),
137      * using the password provided at construction time.
138      */
139     Key recover(EncryptedPrivateKeyInfo encrInfo)
140         throws UnrecoverableKeyException, NoSuchAlgorithmException
141     {
142         byte[] plain = null;
143         SecretKey sKey = null;
144         try {
145             String encrAlg = encrInfo.getAlgorithm().getOID().toString();
146             if (!encrAlg.equals(PBE_WITH_MD5_AND_DES3_CBC_OID)
147                 &amp;&amp; !encrAlg.equals(KEY_PROTECTOR_OID)) {
148                 throw new UnrecoverableKeyException(&quot;Unsupported encryption &quot;
149                                                     + &quot;algorithm&quot;);
150             }
151 
152             if (encrAlg.equals(KEY_PROTECTOR_OID)) {
153                 // JDK 1.2 style recovery
154                 plain = recover(encrInfo.getEncryptedData());
155             } else {
156                 byte[] encodedParams =
157                     encrInfo.getAlgorithm().getEncodedParams();
158 
159                 // parse the PBE parameters into the corresponding spec
160                 AlgorithmParameters pbeParams =
161                     AlgorithmParameters.getInstance(&quot;PBE&quot;);
162                 pbeParams.init(encodedParams);
163                 PBEParameterSpec pbeSpec =
164                         pbeParams.getParameterSpec(PBEParameterSpec.class);
165                 if (pbeSpec.getIterationCount() &gt; MAX_ITERATION_COUNT) {
166                     throw new IOException(&quot;PBE iteration count too large&quot;);
167                 }
168 
169                 // create PBE key from password
170                 PBEKeySpec pbeKeySpec = new PBEKeySpec(this.password);
171                 sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
172                 pbeKeySpec.clearPassword();
173 
174                 // decrypt private key
175                 PBEWithMD5AndTripleDESCipher cipher;
176                 cipher = new PBEWithMD5AndTripleDESCipher();
177                 cipher.engineInit(Cipher.DECRYPT_MODE, sKey, pbeSpec, null);
178                 plain=cipher.engineDoFinal(encrInfo.getEncryptedData(), 0,
179                                            encrInfo.getEncryptedData().length);
180             }
181 
182             // determine the private-key algorithm, and parse private key
183             // using the appropriate key factory
184             String oidName = new AlgorithmId
185                 (new PrivateKeyInfo(plain).getAlgorithm().getOID()).getName();
186             KeyFactory kFac = KeyFactory.getInstance(oidName);
187             return kFac.generatePrivate(new PKCS8EncodedKeySpec(plain));
188         } catch (NoSuchAlgorithmException ex) {
189             // Note: this catch needed to be here because of the
190             // later catch of GeneralSecurityException
191             throw ex;
192         } catch (IOException ioe) {
193             throw new UnrecoverableKeyException(ioe.getMessage());
194         } catch (GeneralSecurityException gse) {
195             throw new UnrecoverableKeyException(gse.getMessage());
196         } finally {
197             if (plain != null) Arrays.fill(plain, (byte) 0x00);
198             if (sKey != null) {
199                 try {
200                     sKey.destroy();
201                 } catch (DestroyFailedException e) {
202                     //shouldn&#39;t happen
203                 }
204             }
205         }
206     }
207 
208     /*
209      * Recovers the cleartext version of the given key (in protected format),
210      * using the password provided at construction time. This method implements
211      * the recovery algorithm used by Sun&#39;s keystore implementation in
212      * JDK 1.2.
213      */
214     private byte[] recover(byte[] protectedKey)
215         throws UnrecoverableKeyException, NoSuchAlgorithmException
216     {
217         int i, j;
218         byte[] digest;
219         int numRounds;
220         int xorOffset; // offset in xorKey where next digest will be stored
221         int encrKeyLen; // the length of the encrpyted key
222 
223         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
224 
225         // Get the salt associated with this key (the first SALT_LEN bytes of
226         // &lt;code&gt;protectedKey&lt;/code&gt;)
227         byte[] salt = new byte[SALT_LEN];
228         System.arraycopy(protectedKey, 0, salt, 0, SALT_LEN);
229 
230         // Determine the number of digest rounds
231         encrKeyLen = protectedKey.length - SALT_LEN - DIGEST_LEN;
232         numRounds = encrKeyLen / DIGEST_LEN;
233         if ((encrKeyLen % DIGEST_LEN) != 0)
234             numRounds++;
235 
236         // Get the encrypted key portion and store it in &quot;encrKey&quot;
237         byte[] encrKey = new byte[encrKeyLen];
238         System.arraycopy(protectedKey, SALT_LEN, encrKey, 0, encrKeyLen);
239 
240         // Set up the byte array which will be XORed with &quot;encrKey&quot;
241         byte[] xorKey = new byte[encrKey.length];
242 
243         // Convert password to byte array, so that it can be digested
244         byte[] passwdBytes = new byte[password.length * 2];
245         for (i=0, j=0; i&lt;password.length; i++) {
246             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
247             passwdBytes[j++] = (byte)password[i];
248         }
249 
250         // Compute the digests, and store them in &quot;xorKey&quot;
251         for (i = 0, xorOffset = 0, digest = salt;
252              i &lt; numRounds;
253              i++, xorOffset += DIGEST_LEN) {
254             md.update(passwdBytes);
255             md.update(digest);
256             digest = md.digest();
257             md.reset();
258             // Copy the digest into &quot;xorKey&quot;
259             if (i &lt; numRounds - 1) {
260                 System.arraycopy(digest, 0, xorKey, xorOffset,
261                                  digest.length);
262             } else {
263                 System.arraycopy(digest, 0, xorKey, xorOffset,
264                                  xorKey.length - xorOffset);
265             }
266         }
267 
268         // XOR &quot;encrKey&quot; with &quot;xorKey&quot;, and store the result in &quot;plainKey&quot;
269         byte[] plainKey = new byte[encrKey.length];
270         for (i = 0; i &lt; plainKey.length; i++) {
271             plainKey[i] = (byte)(encrKey[i] ^ xorKey[i]);
272         }
273 
274         // Check the integrity of the recovered key by concatenating it with
275         // the password, digesting the concatenation, and comparing the
276         // result of the digest operation with the digest provided at the end
277         // of &lt;code&gt;protectedKey&lt;/code&gt;. If the two digest values are
278         // different, throw an exception.
279         md.update(passwdBytes);
280         Arrays.fill(passwdBytes, (byte)0x00);
281         passwdBytes = null;
282         md.update(plainKey);
283         digest = md.digest();
284         md.reset();
285         for (i = 0; i &lt; digest.length; i++) {
286             if (digest[i] != protectedKey[SALT_LEN + encrKeyLen + i]) {
287                 throw new UnrecoverableKeyException(&quot;Cannot recover key&quot;);
288             }
289         }
290         return plainKey;
291     }
292 
293     /**
294      * Seals the given cleartext key, using the password provided at
295      * construction time
296      */
297     SealedObject seal(Key key)
298         throws Exception
299     {
300         // create a random salt (8 bytes)
301         byte[] salt = new byte[8];
302         SunJCE.getRandom().nextBytes(salt);
303 
304         // create PBE parameters from salt and iteration count
305         PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, ITERATION_COUNT);
306 
307         // create PBE key from password
308         PBEKeySpec pbeKeySpec = new PBEKeySpec(this.password);
309         SecretKey sKey = null;
310         Cipher cipher;
311         try {
312             sKey = new PBEKey(pbeKeySpec, &quot;PBEWithMD5AndTripleDES&quot;, false);
313             pbeKeySpec.clearPassword();
314 
315             // seal key
316             PBEWithMD5AndTripleDESCipher cipherSpi;
317             cipherSpi = new PBEWithMD5AndTripleDESCipher();
318             cipher = new CipherForKeyProtector(cipherSpi, SunJCE.getInstance(),
319                                                &quot;PBEWithMD5AndTripleDES&quot;);
320             cipher.init(Cipher.ENCRYPT_MODE, sKey, pbeSpec);
321         } finally {
322             if (sKey != null) sKey.destroy();
323         }
324         return new SealedObjectForKeyProtector(key, cipher);
325     }
326 
327     /**
328      * Unseals the sealed key.
329      */
330     Key unseal(SealedObject so)
331         throws NoSuchAlgorithmException, UnrecoverableKeyException {
332         SecretKey sKey = null;
333         try {
334             // create PBE key from password
335             PBEKeySpec pbeKeySpec = new PBEKeySpec(this.password);
336             sKey = new PBEKey(pbeKeySpec,
337                     &quot;PBEWithMD5AndTripleDES&quot;, false);
338             pbeKeySpec.clearPassword();
339 
340             SealedObjectForKeyProtector soForKeyProtector = null;
341             if (!(so instanceof SealedObjectForKeyProtector)) {
342                 soForKeyProtector = new SealedObjectForKeyProtector(so);
343             } else {
344                 soForKeyProtector = (SealedObjectForKeyProtector)so;
345             }
346             AlgorithmParameters params = soForKeyProtector.getParameters();
347             if (params == null) {
348                 throw new UnrecoverableKeyException(&quot;Cannot get &quot; +
349                                                     &quot;algorithm parameters&quot;);
350             }
351             PBEParameterSpec pbeSpec;
352             try {
353                 pbeSpec = params.getParameterSpec(PBEParameterSpec.class);
354             } catch (InvalidParameterSpecException ipse) {
355                 throw new IOException(&quot;Invalid PBE algorithm parameters&quot;);
356             }
357             if (pbeSpec.getIterationCount() &gt; MAX_ITERATION_COUNT) {
358                 throw new IOException(&quot;PBE iteration count too large&quot;);
359             }
360             PBEWithMD5AndTripleDESCipher cipherSpi;
361             cipherSpi = new PBEWithMD5AndTripleDESCipher();
362             Cipher cipher = new CipherForKeyProtector(cipherSpi,
363                                                       SunJCE.getInstance(),
364                                                       &quot;PBEWithMD5AndTripleDES&quot;);
365             cipher.init(Cipher.DECRYPT_MODE, sKey, params);
366             return soForKeyProtector.getKey(cipher);
367         } catch (NoSuchAlgorithmException ex) {
368             // Note: this catch needed to be here because of the
369             // later catch of GeneralSecurityException
370             throw ex;
371         } catch (IOException ioe) {
372             throw new UnrecoverableKeyException(ioe.getMessage());
373         } catch (ClassNotFoundException cnfe) {
374             throw new UnrecoverableKeyException(cnfe.getMessage());
375         } catch (GeneralSecurityException gse) {
376             throw new UnrecoverableKeyException(gse.getMessage());
377         } finally {
378             if (sKey != null) {
379                 try {
380                     sKey.destroy();
381                 } catch (DestroyFailedException e) {
382                     //shouldn&#39;t happen
383                 }
384             }
385         }
386     }
387 }
388 
389 
390 final class CipherForKeyProtector extends javax.crypto.Cipher {
391     /**
392      * Creates a Cipher object.
393      *
394      * @param cipherSpi the delegate
395      * @param provider the provider
396      * @param transformation the transformation
397      */
398     protected CipherForKeyProtector(CipherSpi cipherSpi,
399                                     Provider provider,
400                                     String transformation) {
401         super(cipherSpi, provider, transformation);
402     }
403 }
    </pre>
  </body>
</html>
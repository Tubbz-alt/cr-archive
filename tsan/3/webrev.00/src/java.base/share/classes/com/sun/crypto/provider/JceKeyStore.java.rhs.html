<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import sun.security.util.Debug;
<a name="1" id="anc1"></a><span class="line-added"> 29 import sun.security.util.IOUtils;</span>
 30 
 31 import java.io.*;
 32 import java.util.*;
 33 import java.security.AccessController;
 34 import java.security.DigestInputStream;
 35 import java.security.DigestOutputStream;
 36 import java.security.MessageDigest;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.Key;
 39 import java.security.PrivateKey;
 40 import java.security.PrivilegedAction;
 41 import java.security.KeyStoreSpi;
 42 import java.security.KeyStoreException;
 43 import java.security.UnrecoverableKeyException;
 44 import java.security.cert.Certificate;
 45 import java.security.cert.CertificateFactory;
 46 import java.security.cert.CertificateException;
 47 import javax.crypto.SealedObject;
 48 
<a name="2" id="anc2"></a><span class="line-added"> 49 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 50 </span>
 51 /**
 52  * This class provides the keystore implementation referred to as &quot;jceks&quot;.
 53  * This implementation strongly protects the keystore private keys using
 54  * triple-DES, where the triple-DES encryption/decryption key is derived from
 55  * the user&#39;s password.
 56  * The encrypted private keys are stored in the keystore in a standard format,
 57  * namely the &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; format defined in PKCS #8.
 58  *
 59  * @author Jan Luehe
 60  *
 61  *
 62  * @see java.security.KeyStoreSpi
 63  */
 64 
 65 public final class JceKeyStore extends KeyStoreSpi {
 66 
 67     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 68     private static final int JCEKS_MAGIC = 0xcececece;
 69     private static final int JKS_MAGIC = 0xfeedfeed;
 70     private static final int VERSION_1 = 0x01;
 71     private static final int VERSION_2 = 0x02;
 72 
 73     // Private key and supporting certificate chain
 74     private static final class PrivateKeyEntry {
 75         Date date; // the creation date of this entry
 76         byte[] protectedKey;
<a name="3" id="anc3"></a><span class="line-modified"> 77         Certificate[] chain;</span>
 78     };
 79 
 80     // Secret key
 81     private static final class SecretKeyEntry {
 82         Date date; // the creation date of this entry
 83         SealedObject sealedKey;
 84     }
 85 
 86     // Trusted certificate
 87     private static final class TrustedCertEntry {
 88         Date date; // the creation date of this entry
 89         Certificate cert;
 90     };
 91 
 92     /**
 93      * Private keys and certificates are stored in a hashtable.
 94      * Hash entries are keyed by alias names.
 95      */
 96     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
 97 
 98     /**
 99      * Returns the key associated with the given alias, using the given
100      * password to recover it.
101      *
102      * @param alias the alias name
103      * @param password the password for recovering the key
104      *
105      * @return the requested key, or null if the given alias does not exist
106      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
107      *
108      * @exception NoSuchAlgorithmException if the algorithm for recovering the
109      * key cannot be found
110      * @exception UnrecoverableKeyException if the key cannot be recovered
111      * (e.g., the given password is wrong).
112      */
113     public Key engineGetKey(String alias, char[] password)
114         throws NoSuchAlgorithmException, UnrecoverableKeyException
115     {
116         Key key = null;
117 
118         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
119 
120         if (!((entry instanceof PrivateKeyEntry) ||
121               (entry instanceof SecretKeyEntry))) {
122             return null;
123         }
124 
125         KeyProtector keyProtector = new KeyProtector(password);
126 
127         if (entry instanceof PrivateKeyEntry) {
128             byte[] encrBytes = ((PrivateKeyEntry)entry).protectedKey;
129             EncryptedPrivateKeyInfo encrInfo;
130             try {
131                 encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
132             } catch (IOException ioe) {
133                 throw new UnrecoverableKeyException(&quot;Private key not stored &quot;
134                                                     + &quot;as PKCS #8 &quot; +
135                                                     &quot;EncryptedPrivateKeyInfo&quot;);
136             }
137             key = keyProtector.recover(encrInfo);
138         } else {
139             key =
140                 keyProtector.unseal(((SecretKeyEntry)entry).sealedKey);
141         }
142 
143         return key;
144     }
145 
146     /**
147      * Returns the certificate chain associated with the given alias.
148      *
149      * @param alias the alias name
150      *
151      * @return the certificate chain (ordered with the user&#39;s certificate first
152      * and the root certificate authority last), or null if the given alias
153      * does not exist or does not contain a certificate chain (i.e., the given
154      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
155      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
156      */
157     public Certificate[] engineGetCertificateChain(String alias)
158     {
159         Certificate[] chain = null;
160 
161         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
162 
163         if ((entry instanceof PrivateKeyEntry)
164             &amp;&amp; (((PrivateKeyEntry)entry).chain != null)) {
165             chain = ((PrivateKeyEntry)entry).chain.clone();
166         }
167 
168         return chain;
169     }
170 
171     /**
172      * Returns the certificate associated with the given alias.
173      *
174      * &lt;p&gt;If the given alias name identifies a
175      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
176      * entry is returned. If the given alias name identifies a
177      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
178      * entry is returned, or null if that entry does not have a certificate
179      * chain.
180      *
181      * @param alias the alias name
182      *
183      * @return the certificate, or null if the given alias does not exist or
184      * does not contain a certificate.
185      */
186     public Certificate engineGetCertificate(String alias) {
187         Certificate cert = null;
188 
189         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
190 
191         if (entry != null) {
192             if (entry instanceof TrustedCertEntry) {
193                 cert = ((TrustedCertEntry)entry).cert;
194             } else if ((entry instanceof PrivateKeyEntry) &amp;&amp;
195                        (((PrivateKeyEntry)entry).chain != null)) {
196                 cert = ((PrivateKeyEntry)entry).chain[0];
197             }
198         }
199 
200         return cert;
201     }
202 
203     /**
204      * Returns the creation date of the entry identified by the given alias.
205      *
206      * @param alias the alias name
207      *
208      * @return the creation date of this entry, or null if the given alias does
209      * not exist
210      */
211     public Date engineGetCreationDate(String alias) {
212         Date date = null;
213 
214         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
215 
216         if (entry != null) {
217             // We have to create a new instance of java.util.Date because
218             // dates are not immutable
219             if (entry instanceof TrustedCertEntry) {
220                 date = new Date(((TrustedCertEntry)entry).date.getTime());
221             } else if (entry instanceof PrivateKeyEntry) {
222                 date = new Date(((PrivateKeyEntry)entry).date.getTime());
223             } else {
224                 date = new Date(((SecretKeyEntry)entry).date.getTime());
225             }
226         }
227 
228         return date;
229     }
230 
231     /**
232      * Assigns the given key to the given alias, protecting it with the given
233      * password.
234      *
235      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
236      * it must be accompanied by a certificate chain certifying the
237      * corresponding public key.
238      *
239      * &lt;p&gt;If the given alias already exists, the keystore information
240      * associated with it is overridden by the given key (and possibly
241      * certificate chain).
242      *
243      * @param alias the alias name
244      * @param key the key to be associated with the alias
245      * @param password the password to protect the key
246      * @param chain the certificate chain for the corresponding public
247      * key (only required if the given key is of type
248      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
249      *
250      * @exception KeyStoreException if the given key cannot be protected, or
251      * this operation fails for some other reason
252      */
253     public void engineSetKeyEntry(String alias, Key key, char[] password,
254                                   Certificate[] chain)
255         throws KeyStoreException
256     {
257         synchronized(entries) {
258             try {
259                 KeyProtector keyProtector = new KeyProtector(password);
260 
261                 if (key instanceof PrivateKey) {
262                     PrivateKeyEntry entry = new PrivateKeyEntry();
263                     entry.date = new Date();
264 
265                     // protect the private key
266                     entry.protectedKey = keyProtector.protect((PrivateKey)key);
267 
268                     // clone the chain
269                     if ((chain != null) &amp;&amp;
270                         (chain.length !=0)) {
271                         entry.chain = chain.clone();
272                     } else {
273                         entry.chain = null;
274                     }
275 
276                     // store the entry
277                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
278 
279                 } else {
280                     SecretKeyEntry entry = new SecretKeyEntry();
281                     entry.date = new Date();
282 
283                     // seal and store the key
284                     entry.sealedKey = keyProtector.seal(key);
285                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
286                 }
287 
288             } catch (Exception e) {
289                 throw new KeyStoreException(e.getMessage());
290             }
291         }
292     }
293 
294     /**
295      * Assigns the given key (that has already been protected) to the given
296      * alias.
297      *
298      * &lt;p&gt;If the protected key is of type
299      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
300      * it must be accompanied by a certificate chain certifying the
301      * corresponding public key.
302      *
303      * &lt;p&gt;If the given alias already exists, the keystore information
304      * associated with it is overridden by the given key (and possibly
305      * certificate chain).
306      *
307      * @param alias the alias name
308      * @param key the key (in protected format) to be associated with the alias
309      * @param chain the certificate chain for the corresponding public
310      * key (only useful if the protected key is of type
311      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
312      *
313      * @exception KeyStoreException if this operation fails.
314      */
315     public void engineSetKeyEntry(String alias, byte[] key,
316                                   Certificate[] chain)
317         throws KeyStoreException
318     {
319         synchronized(entries) {
320             // We assume it&#39;s a private key, because there is no standard
321             // (ASN.1) encoding format for wrapped secret keys
322             PrivateKeyEntry entry = new PrivateKeyEntry();
323             entry.date = new Date();
324 
325             entry.protectedKey = key.clone();
326             if ((chain != null) &amp;&amp;
327                 (chain.length != 0)) {
328                 entry.chain = chain.clone();
329             } else {
330                 entry.chain = null;
331             }
332 
333             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
334         }
335     }
336 
337     /**
338      * Assigns the given certificate to the given alias.
339      *
340      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
341      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
342      * overridden by the given certificate.
343      *
344      * @param alias the alias name
345      * @param cert the certificate
346      *
347      * @exception KeyStoreException if the given alias already exists and does
348      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
349      * fails for some other reason.
350      */
351     public void engineSetCertificateEntry(String alias, Certificate cert)
352         throws KeyStoreException
353     {
354         synchronized(entries) {
355 
356             Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
357             if (entry != null) {
358                 if (entry instanceof PrivateKeyEntry) {
359                     throw new KeyStoreException(&quot;Cannot overwrite own &quot;
360                                                 + &quot;certificate&quot;);
361                 } else if (entry instanceof SecretKeyEntry) {
362                     throw new KeyStoreException(&quot;Cannot overwrite secret key&quot;);
363                 }
364             }
365 
366             TrustedCertEntry trustedCertEntry = new TrustedCertEntry();
367             trustedCertEntry.cert = cert;
368             trustedCertEntry.date = new Date();
369             entries.put(alias.toLowerCase(Locale.ENGLISH), trustedCertEntry);
370         }
371     }
372 
373     /**
374      * Deletes the entry identified by the given alias from this keystore.
375      *
376      * @param alias the alias name
377      *
378      * @exception KeyStoreException if the entry cannot be removed.
379      */
380     public void engineDeleteEntry(String alias)
381         throws KeyStoreException
382     {
383         synchronized(entries) {
384             entries.remove(alias.toLowerCase(Locale.ENGLISH));
385         }
386     }
387 
388     /**
389      * Lists all the alias names of this keystore.
390      *
391      * @return enumeration of the alias names
392      */
393     public Enumeration&lt;String&gt; engineAliases() {
394         return entries.keys();
395     }
396 
397     /**
398      * Checks if the given alias exists in this keystore.
399      *
400      * @param alias the alias name
401      *
402      * @return true if the alias exists, false otherwise
403      */
404     public boolean engineContainsAlias(String alias) {
405         return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));
406     }
407 
408     /**
409      * Retrieves the number of entries in this keystore.
410      *
411      * @return the number of entries in this keystore
412      */
413     public int engineSize() {
414         return entries.size();
415     }
416 
417     /**
418      * Returns true if the entry identified by the given alias is a
419      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
420      *
421      * @return true if the entry identified by the given alias is a
422      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
423      */
424     public boolean engineIsKeyEntry(String alias) {
425         boolean isKey = false;
426 
427         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
428         if ((entry instanceof PrivateKeyEntry)
429             || (entry instanceof SecretKeyEntry)) {
430             isKey = true;
431         }
432 
433         return isKey;
434     }
435 
436     /**
437      * Returns true if the entry identified by the given alias is a
438      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
439      *
440      * @return true if the entry identified by the given alias is a
441      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
442      */
443     public boolean engineIsCertificateEntry(String alias) {
444         boolean isCert = false;
445         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
446         if (entry instanceof TrustedCertEntry) {
447             isCert = true;
448         }
449         return isCert;
450     }
451 
452     /**
453      * Returns the (alias) name of the first keystore entry whose certificate
454      * matches the given certificate.
455      *
456      * &lt;p&gt;This method attempts to match the given certificate with each
457      * keystore entry. If the entry being considered
458      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
459      * compared to that entry&#39;s certificate. If the entry being considered is
460      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
461      * element of that entry&#39;s certificate chain (if a chain exists).
462      *
463      * @param cert the certificate to match with.
464      *
465      * @return the (alias) name of the first entry with matching certificate,
466      * or null if no such entry exists in this keystore.
467      */
468     public String engineGetCertificateAlias(Certificate cert) {
469         Certificate certElem;
470 
471         Enumeration&lt;String&gt; e = entries.keys();
472         while (e.hasMoreElements()) {
473             String alias = e.nextElement();
474             Object entry = entries.get(alias);
475             if (entry instanceof TrustedCertEntry) {
476                 certElem = ((TrustedCertEntry)entry).cert;
477             } else if ((entry instanceof PrivateKeyEntry) &amp;&amp;
478                        (((PrivateKeyEntry)entry).chain != null)) {
479                 certElem = ((PrivateKeyEntry)entry).chain[0];
480             } else {
481                 continue;
482             }
483             if (certElem.equals(cert)) {
484                 return alias;
485             }
486         }
487         return null;
488     }
489 
490     /**
491      * Stores this keystore to the given output stream, and protects its
492      * integrity with the given password.
493      *
494      * @param stream the output stream to which this keystore is written.
495      * @param password the password to generate the keystore integrity check
496      *
497      * @exception IOException if there was an I/O problem with data
498      * @exception NoSuchAlgorithmException if the appropriate data integrity
499      * algorithm could not be found
500      * @exception CertificateException if any of the certificates included in
501      * the keystore data could not be stored
502      */
503     public void engineStore(OutputStream stream, char[] password)
504         throws IOException, NoSuchAlgorithmException, CertificateException
505     {
506         synchronized(entries) {
507             /*
508              * KEYSTORE FORMAT:
509              *
510              * Magic number (big-endian integer),
511              * Version of this file format (big-endian integer),
512              *
513              * Count (big-endian integer),
514              * followed by &quot;count&quot; instances of either:
515              *
516              *     {
517              *      tag=1 (big-endian integer)
518              *      alias (UTF string)
519              *      timestamp
520              *      encrypted private-key info according to PKCS #8
521              *          (integer length followed by encoding)
522              *      cert chain (integer count followed by certs;
523              *          for each cert: type UTF string, followed by integer
524              *              length, followed by encoding)
525              *     }
526              *
527              * or:
528              *
529              *     {
530              *      tag=2 (big-endian integer)
531              *      alias (UTF string)
532              *      timestamp
533              *      cert (type UTF string, followed by integer length,
534              *          followed by encoding)
535              *     }
536              *
537              * or:
538              *
539              *     {
540              *      tag=3 (big-endian integer)
541              *      alias (UTF string)
542              *      timestamp
543              *      sealed secret key (in serialized form)
544              *     }
545              *
546              * ended by a keyed SHA1 hash (bytes only) of
547              *     { password + whitener + preceding body }
548              */
549 
550             // password is mandatory when storing
551             if (password == null) {
552                 throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
553             }
554 
555             byte[] encoded; // the certificate encoding
556 
557             MessageDigest md = getPreKeyedHash(password);
558             DataOutputStream dos
559                 = new DataOutputStream(new DigestOutputStream(stream, md));
560             // NOTE: don&#39;t pass dos to oos at this point or it&#39;ll corrupt
561             // the keystore!!!
562             ObjectOutputStream oos = null;
563             try {
564                 dos.writeInt(JCEKS_MAGIC);
565                 dos.writeInt(VERSION_2); // always write the latest version
566 
567                 dos.writeInt(entries.size());
568 
569                 Enumeration&lt;String&gt; e = entries.keys();
570                 while (e.hasMoreElements()) {
571 
572                     String alias = e.nextElement();
573                     Object entry = entries.get(alias);
574 
575                     if (entry instanceof PrivateKeyEntry) {
576 
577                         PrivateKeyEntry pentry = (PrivateKeyEntry)entry;
578 
579                         // write PrivateKeyEntry tag
580                         dos.writeInt(1);
581 
582                         // write the alias
583                         dos.writeUTF(alias);
584 
585                         // write the (entry creation) date
586                         dos.writeLong(pentry.date.getTime());
587 
588                         // write the protected private key
589                         dos.writeInt(pentry.protectedKey.length);
590                         dos.write(pentry.protectedKey);
591 
592                         // write the certificate chain
593                         int chainLen;
594                         if (pentry.chain == null) {
595                             chainLen = 0;
596                         } else {
597                             chainLen = pentry.chain.length;
598                         }
599                         dos.writeInt(chainLen);
600                         for (int i = 0; i &lt; chainLen; i++) {
601                             encoded = pentry.chain[i].getEncoded();
602                             dos.writeUTF(pentry.chain[i].getType());
603                             dos.writeInt(encoded.length);
604                             dos.write(encoded);
605                         }
606 
607                     } else if (entry instanceof TrustedCertEntry) {
608 
609                         // write TrustedCertEntry tag
610                         dos.writeInt(2);
611 
612                         // write the alias
613                         dos.writeUTF(alias);
614 
615                         // write the (entry creation) date
616                         dos.writeLong(((TrustedCertEntry)entry).date.getTime());
617 
618                         // write the trusted certificate
619                         encoded = ((TrustedCertEntry)entry).cert.getEncoded();
620                         dos.writeUTF(((TrustedCertEntry)entry).cert.getType());
621                         dos.writeInt(encoded.length);
622                         dos.write(encoded);
623 
624                     } else {
625 
626                         // write SecretKeyEntry tag
627                         dos.writeInt(3);
628 
629                         // write the alias
630                         dos.writeUTF(alias);
631 
632                         // write the (entry creation) date
633                         dos.writeLong(((SecretKeyEntry)entry).date.getTime());
634 
635                         // write the sealed key
636                         oos = new ObjectOutputStream(dos);
637                         oos.writeObject(((SecretKeyEntry)entry).sealedKey);
638                         // NOTE: don&#39;t close oos here since we are still
639                         // using dos!!!
640                     }
641                 }
642 
643                 /*
644                  * Write the keyed hash which is used to detect tampering with
645                  * the keystore (such as deleting or modifying key or
646                  * certificate entries).
647                  */
648                 byte digest[] = md.digest();
649 
650                 dos.write(digest);
651                 dos.flush();
652             } finally {
653                 if (oos != null) {
654                     oos.close();
655                 } else {
656                     dos.close();
657                 }
658             }
659         }
660     }
661 
662     /**
663      * Loads the keystore from the given input stream.
664      *
665      * &lt;p&gt;If a password is given, it is used to check the integrity of the
666      * keystore data. Otherwise, the integrity of the keystore is not checked.
667      *
668      * @param stream the input stream from which the keystore is loaded
669      * @param password the (optional) password used to check the integrity of
670      * the keystore.
671      *
672      * @exception IOException if there is an I/O or format problem with the
673      * keystore data
674      * @exception NoSuchAlgorithmException if the algorithm used to check
675      * the integrity of the keystore cannot be found
676      * @exception CertificateException if any of the certificates in the
677      * keystore could not be loaded
678      */
679     public void engineLoad(InputStream stream, char[] password)
680         throws IOException, NoSuchAlgorithmException, CertificateException
681     {
682         synchronized(entries) {
683             DataInputStream dis;
684             MessageDigest md = null;
685             CertificateFactory cf = null;
686             Hashtable&lt;String, CertificateFactory&gt; cfs = null;
687             ByteArrayInputStream bais = null;
688             byte[] encoded = null;
689             int trustedKeyCount = 0, privateKeyCount = 0, secretKeyCount = 0;
690 
691             if (stream == null)
692                 return;
693 
694             if (password != null) {
695                 md = getPreKeyedHash(password);
696                 dis = new DataInputStream(new DigestInputStream(stream, md));
697             } else {
698                 dis = new DataInputStream(stream);
699             }
700             // NOTE: don&#39;t pass dis to ois at this point or it&#39;ll fail to load
701             // the keystore!!!
702             ObjectInputStream ois = null;
703 
704             try {
705                 // Body format: see store method
706 
707                 int xMagic = dis.readInt();
708                 int xVersion = dis.readInt();
709 
710                 // Accept the following keystore implementations:
711                 // - JCEKS (this implementation), versions 1 and 2
712                 // - JKS (Sun&#39;s keystore implementation in JDK 1.2),
713                 //   versions 1 and 2
714                 if (((xMagic != JCEKS_MAGIC) &amp;&amp; (xMagic != JKS_MAGIC)) ||
715                     ((xVersion != VERSION_1) &amp;&amp; (xVersion != VERSION_2))) {
716                     throw new IOException(&quot;Invalid keystore format&quot;);
717                 }
718 
719                 if (xVersion == VERSION_1) {
720                     cf = CertificateFactory.getInstance(&quot;X509&quot;);
721                 } else {
722                     // version 2
723                     cfs = new Hashtable&lt;&gt;(3);
724                 }
725 
726                 entries.clear();
727                 int count = dis.readInt();
728 
729                 for (int i = 0; i &lt; count; i++) {
730                     int tag;
731                     String alias;
732 
733                     tag = dis.readInt();
734 
735                     if (tag == 1) { // private-key entry
736                         privateKeyCount++;
737                         PrivateKeyEntry entry = new PrivateKeyEntry();
738 
739                         // read the alias
740                         alias = dis.readUTF();
741 
742                         // read the (entry creation) date
743                         entry.date = new Date(dis.readLong());
744 
745                         // read the private key
<a name="4" id="anc4"></a><span class="line-modified">746                         entry.protectedKey = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>





747 
748                         // read the certificate chain
749                         int numOfCerts = dis.readInt();
<a name="5" id="anc5"></a><span class="line-modified">750                         List&lt;Certificate&gt; tmpCerts = new ArrayList&lt;&gt;();</span>







751                         for (int j = 0; j &lt; numOfCerts; j++) {
752                             if (xVersion == 2) {
753                                 // read the certificate type, and instantiate a
754                                 // certificate factory of that type (reuse
755                                 // existing factory if possible)
756                                 String certType = dis.readUTF();
757                                 if (cfs.containsKey(certType)) {
<a name="6" id="anc6"></a><span class="line-modified">758                                     // reuse certificate factory</span>
759                                     cf = cfs.get(certType);
760                                 } else {
<a name="7" id="anc7"></a><span class="line-modified">761                                     // create new certificate factory</span>
762                                     cf = CertificateFactory.getInstance(
763                                         certType);
<a name="8" id="anc8"></a><span class="line-modified">764                                     // store the certificate factory so we can</span>
<span class="line-modified">765                                     // reuse it later</span>
766                                     cfs.put(certType, cf);
767                                 }
768                             }
769                             // instantiate the certificate
<a name="9" id="anc9"></a><span class="line-modified">770                             encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>





771                             bais = new ByteArrayInputStream(encoded);
<a name="10" id="anc10"></a><span class="line-modified">772                             tmpCerts.add(cf.generateCertificate(bais));</span>
773                         }
<a name="11" id="anc11"></a><span class="line-added">774                         entry.chain = tmpCerts.toArray(</span>
<span class="line-added">775                                 new Certificate[numOfCerts]);</span>
776 
777                         // Add the entry to the list
778                         entries.put(alias, entry);
779 
780                     } else if (tag == 2) { // trusted certificate entry
781                         trustedKeyCount++;
782                         TrustedCertEntry entry = new TrustedCertEntry();
783 
784                         // read the alias
785                         alias = dis.readUTF();
786 
787                         // read the (entry creation) date
788                         entry.date = new Date(dis.readLong());
789 
790                         // read the trusted certificate
791                         if (xVersion == 2) {
792                             // read the certificate type, and instantiate a
793                             // certificate factory of that type (reuse
794                             // existing factory if possible)
795                             String certType = dis.readUTF();
796                             if (cfs.containsKey(certType)) {
797                                 // reuse certificate factory
798                                 cf = cfs.get(certType);
799                             } else {
800                                 // create new certificate factory
801                                 cf = CertificateFactory.getInstance(certType);
802                                 // store the certificate factory so we can
803                                 // reuse it later
804                                 cfs.put(certType, cf);
805                             }
806                         }
<a name="12" id="anc12"></a><span class="line-modified">807                         encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>





808                         bais = new ByteArrayInputStream(encoded);
809                         entry.cert = cf.generateCertificate(bais);
810 
811                         // Add the entry to the list
812                         entries.put(alias, entry);
813 
814                     } else if (tag == 3) { // secret-key entry
815                         secretKeyCount++;
816                         SecretKeyEntry entry = new SecretKeyEntry();
817 
818                         // read the alias
819                         alias = dis.readUTF();
820 
821                         // read the (entry creation) date
822                         entry.date = new Date(dis.readLong());
823 
824                         // read the sealed key
825                         try {
826                             ois = new ObjectInputStream(dis);
827                             final ObjectInputStream ois2 = ois;
828                             // Set a deserialization checker
829                             AccessController.doPrivileged(
830                                 (PrivilegedAction&lt;Void&gt;)() -&gt; {
831                                     ois2.setObjectInputFilter(
832                                         new DeserializationChecker());
833                                     return null;
834                             });
835                             entry.sealedKey = (SealedObject)ois.readObject();
836                             // NOTE: don&#39;t close ois here since we are still
837                             // using dis!!!
838                         } catch (ClassNotFoundException cnfe) {
839                             throw new IOException(cnfe.getMessage());
840                         } catch (InvalidClassException ice) {
841                             throw new IOException(&quot;Invalid secret key format&quot;);
842                         }
843 
844                         // Add the entry to the list
845                         entries.put(alias, entry);
846 
847                     } else {
848                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
849                                 tag);
850                     }
851                 }
852 
853                 if (debug != null) {
854                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
855                         privateKeyCount + &quot;. trusted key count: &quot; +
856                         trustedKeyCount + &quot;. secret key count: &quot; +
857                         secretKeyCount);
858                 }
859 
860                 /*
861                  * If a password has been provided, we check the keyed digest
862                  * at the end. If this check fails, the store has been tampered
863                  * with
864                  */
865                 if (password != null) {
<a name="13" id="anc13"></a><span class="line-modified">866                     byte[] computed = md.digest();</span>
<span class="line-modified">867                     byte[] actual = IOUtils.readExactlyNBytes(dis, computed.length);</span>
<span class="line-modified">868                     if (!MessageDigest.isEqual(computed, actual)) {</span>
<span class="line-modified">869                         throw new IOException(</span>



870                                 &quot;Keystore was tampered with, or &quot;
871                                         + &quot;password was incorrect&quot;,
<a name="14" id="anc14"></a><span class="line-modified">872                                 new UnrecoverableKeyException(</span>
<span class="line-modified">873                                         &quot;Password verification failed&quot;));</span>

874                     }
875                 }
876             }  finally {
877                 if (ois != null) {
878                     ois.close();
879                 } else {
880                     dis.close();
881                 }
882             }
883         }
884     }
885 
886     /**
887      * To guard against tampering with the keystore, we append a keyed
888      * hash with a bit of whitener.
889      */
890     private MessageDigest getPreKeyedHash(char[] password)
<a name="15" id="anc15"></a><span class="line-modified">891         throws NoSuchAlgorithmException</span>
<span class="line-added">892     {</span>
893         int i, j;
894 
895         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
896         byte[] passwdBytes = new byte[password.length * 2];
897         for (i=0, j=0; i&lt;password.length; i++) {
898             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
899             passwdBytes[j++] = (byte)password[i];
900         }
901         md.update(passwdBytes);
902         for (i=0; i&lt;passwdBytes.length; i++)
903             passwdBytes[i] = 0;
<a name="16" id="anc16"></a><span class="line-modified">904         md.update(&quot;Mighty Aphrodite&quot;.getBytes(UTF_8));</span>
905         return md;
906     }
907 
908     /**
909      * Probe the first few bytes of the keystore data stream for a valid
910      * JCEKS keystore encoding.
911      */
912     @Override
913     public boolean engineProbe(InputStream stream) throws IOException {
914         DataInputStream dataStream;
915         if (stream instanceof DataInputStream) {
916             dataStream = (DataInputStream)stream;
917         } else {
918             dataStream = new DataInputStream(stream);
919         }
920 
921         return JCEKS_MAGIC == dataStream.readInt();
922     }
923 
924     /*
925      * An ObjectInputFilter that checks the format of the secret key being
926      * deserialized.
927      */
928     private static class DeserializationChecker implements ObjectInputFilter {
929         private static final int MAX_NESTED_DEPTH = 2;
930 
931         @Override
932         public ObjectInputFilter.Status
933             checkInput(ObjectInputFilter.FilterInfo info) {
934 
935             // First run a custom filter
936             long nestedDepth = info.depth();
937             if ((nestedDepth == 1 &amp;&amp;
938                         info.serialClass() != SealedObjectForKeyProtector.class) ||
939                     (nestedDepth &gt; MAX_NESTED_DEPTH &amp;&amp;
940                         info.serialClass() != null &amp;&amp;
941                         info.serialClass() != Object.class)) {
942                 return Status.REJECTED;
943             }
944 
945             // Next run the default filter, if available
946             ObjectInputFilter defaultFilter =
947                 ObjectInputFilter.Config.getSerialFilter();
948             if (defaultFilter != null) {
949                 return defaultFilter.checkInput(info);
950             }
951 
952             return Status.UNDECIDED;
953         }
954     }
955 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/PBKDF2KeyImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.io.ObjectStreamException;
 29 import java.lang.ref.Reference;
 30 import java.nio.ByteBuffer;
 31 import java.nio.CharBuffer;
<a name="2" id="anc2"></a>
 32 import java.util.Arrays;
 33 import java.util.Locale;
 34 import java.security.MessageDigest;
 35 import java.security.KeyRep;
 36 import java.security.GeneralSecurityException;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.spec.InvalidKeySpecException;
 39 import javax.crypto.Mac;
 40 import javax.crypto.SecretKey;
 41 import javax.crypto.spec.PBEKeySpec;
 42 
<a name="3" id="anc3"></a><span class="line-added"> 43 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 44 </span>
 45 import jdk.internal.ref.CleanerFactory;
 46 
 47 /**
 48  * This class represents a PBE key derived using PBKDF2 defined
 49  * in PKCS#5 v2.0. meaning that
 50  * 1) the password must consist of characters which will be converted
 51  *    to bytes using UTF-8 character encoding.
 52  * 2) salt, iteration count, and to be derived key length are supplied
 53  *
 54  * @author Valerie Peng
 55  *
 56  */
 57 final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {
 58 
<a name="4" id="anc4"></a><span class="line-added"> 59     @java.io.Serial</span>
 60     static final long serialVersionUID = -2234868909660948157L;
 61 
 62     private char[] passwd;
 63     private byte[] salt;
 64     private int iterCount;
 65     private byte[] key;
 66 
 67     private Mac prf;
 68 
 69     private static byte[] getPasswordBytes(char[] passwd) {
<a name="5" id="anc5"></a>
 70         CharBuffer cb = CharBuffer.wrap(passwd);
<a name="6" id="anc6"></a><span class="line-modified"> 71         ByteBuffer bb = UTF_8.encode(cb);</span>
 72 
 73         int len = bb.limit();
 74         byte[] passwdBytes = new byte[len];
 75         bb.get(passwdBytes, 0, len);
 76 
 77         return passwdBytes;
 78     }
 79 
 80     /**
 81      * Creates a PBE key from a given PBE key specification.
 82      *
 83      * @param keySpec the given PBE key specification
 84      * @param prfAlgo the given PBE key algorithm
 85      */
 86     PBKDF2KeyImpl(PBEKeySpec keySpec, String prfAlgo)
 87         throws InvalidKeySpecException {
 88         char[] passwd = keySpec.getPassword();
 89         if (passwd == null) {
 90             // Should allow an empty password.
 91             this.passwd = new char[0];
 92         } else {
 93             this.passwd = passwd.clone();
 94         }
 95         // Convert the password from char[] to byte[]
 96         byte[] passwdBytes = getPasswordBytes(this.passwd);
 97         // remove local copy
 98         if (passwd != null) Arrays.fill(passwd, &#39;\0&#39;);
 99 
100         try {
101             this.salt = keySpec.getSalt();
102             if (salt == null) {
103                 throw new InvalidKeySpecException(&quot;Salt not found&quot;);
104             }
105             this.iterCount = keySpec.getIterationCount();
106             if (iterCount == 0) {
107                 throw new InvalidKeySpecException(&quot;Iteration count not found&quot;);
108             } else if (iterCount &lt; 0) {
109                 throw new InvalidKeySpecException(&quot;Iteration count is negative&quot;);
110             }
111             int keyLength = keySpec.getKeyLength();
112             if (keyLength == 0) {
113                 throw new InvalidKeySpecException(&quot;Key length not found&quot;);
114             } else if (keyLength &lt; 0) {
115                 throw new InvalidKeySpecException(&quot;Key length is negative&quot;);
116             }
<a name="7" id="anc7"></a><span class="line-modified">117             this.prf = Mac.getInstance(prfAlgo, SunJCE.getInstance());</span>





118             this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);
119         } catch (NoSuchAlgorithmException nsae) {
120             // not gonna happen; re-throw just in case
121             InvalidKeySpecException ike = new InvalidKeySpecException();
122             ike.initCause(nsae);
123             throw ike;
124         } finally {
125             Arrays.fill(passwdBytes, (byte) 0x00);
126 
127             // Use the cleaner to zero the key when no longer referenced
128             final byte[] k = this.key;
129             final char[] p = this.passwd;
130             CleanerFactory.cleaner().register(this,
131                     () -&gt; {
132                         Arrays.fill(k, (byte) 0x00);
133                         Arrays.fill(p, &#39;\0&#39;);
134                     });
135         }
136     }
137 
138     private static byte[] deriveKey(final Mac prf, final byte[] password,
139             byte[] salt, int iterCount, int keyLengthInBit) {
140         int keyLength = keyLengthInBit/8;
141         byte[] key = new byte[keyLength];
142         try {
143             int hlen = prf.getMacLength();
144             int intL = (keyLength + hlen - 1)/hlen; // ceiling
145             int intR = keyLength - (intL - 1)*hlen; // residue
146             byte[] ui = new byte[hlen];
147             byte[] ti = new byte[hlen];
148             // SecretKeySpec cannot be used, since password can be empty here.
149             SecretKey macKey = new SecretKey() {
<a name="8" id="anc8"></a><span class="line-added">150                 @java.io.Serial</span>
151                 private static final long serialVersionUID = 7874493593505141603L;
152                 @Override
153                 public String getAlgorithm() {
154                     return prf.getAlgorithm();
155                 }
156                 @Override
157                 public String getFormat() {
158                     return &quot;RAW&quot;;
159                 }
160                 @Override
161                 public byte[] getEncoded() {
162                     return password;
163                 }
164                 @Override
165                 public int hashCode() {
166                     return Arrays.hashCode(password) * 41 +
167                       prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();
168                 }
169                 @Override
170                 public boolean equals(Object obj) {
171                     if (this == obj) return true;
172                     if (this.getClass() != obj.getClass()) return false;
173                     SecretKey sk = (SecretKey)obj;
174                     return prf.getAlgorithm().equalsIgnoreCase(
175                         sk.getAlgorithm()) &amp;&amp;
176                         MessageDigest.isEqual(password, sk.getEncoded());
177                 }
178             };
179             prf.init(macKey);
180 
181             byte[] ibytes = new byte[4];
182             for (int i = 1; i &lt;= intL; i++) {
183                 prf.update(salt);
184                 ibytes[3] = (byte) i;
185                 ibytes[2] = (byte) ((i &gt;&gt; 8) &amp; 0xff);
186                 ibytes[1] = (byte) ((i &gt;&gt; 16) &amp; 0xff);
187                 ibytes[0] = (byte) ((i &gt;&gt; 24) &amp; 0xff);
188                 prf.update(ibytes);
189                 prf.doFinal(ui, 0);
190                 System.arraycopy(ui, 0, ti, 0, ui.length);
191 
192                 for (int j = 2; j &lt;= iterCount; j++) {
193                     prf.update(ui);
194                     prf.doFinal(ui, 0);
195                     // XOR the intermediate Ui&#39;s together.
196                     for (int k = 0; k &lt; ui.length; k++) {
197                         ti[k] ^= ui[k];
198                     }
199                 }
200                 if (i == intL) {
201                     System.arraycopy(ti, 0, key, (i-1)*hlen, intR);
202                 } else {
203                     System.arraycopy(ti, 0, key, (i-1)*hlen, hlen);
204                 }
205             }
206         } catch (GeneralSecurityException gse) {
<a name="9" id="anc9"></a><span class="line-modified">207             throw new RuntimeException(&quot;Error deriving PBKDF2 keys&quot;, gse);</span>
208         }
209         return key;
210     }
211 
212     public byte[] getEncoded() {
213         // The key is zeroized by finalize()
214         // The reachability fence ensures finalize() isn&#39;t called early
215         byte[] result = key.clone();
216         Reference.reachabilityFence(this);
217         return result;
218     }
219 
220     public String getAlgorithm() {
221         return &quot;PBKDF2With&quot; + prf.getAlgorithm();
222     }
223 
224     public int getIterationCount() {
225         return iterCount;
226     }
227 
228     public char[] getPassword() {
229         // The password is zeroized by finalize()
230         // The reachability fence ensures finalize() isn&#39;t called early
231         char[] result = passwd.clone();
232         Reference.reachabilityFence(this);
233         return result;
234     }
235 
236     public byte[] getSalt() {
237         return salt.clone();
238     }
239 
240     public String getFormat() {
241         return &quot;RAW&quot;;
242     }
243 
244     /**
245      * Calculates a hash code value for the object.
246      * Objects that are equal will also have the same hashcode.
247      */
248     public int hashCode() {
249         int retval = 0;
250         for (int i = 1; i &lt; this.key.length; i++) {
251             retval += this.key[i] * i;
252         }
253         return(retval ^= getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode());
254     }
255 
256     public boolean equals(Object obj) {
257         if (obj == this)
258             return true;
259 
260         if (!(obj instanceof SecretKey))
261             return false;
262 
263         SecretKey that = (SecretKey) obj;
264 
265         if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm())))
266             return false;
267         if (!(that.getFormat().equalsIgnoreCase(&quot;RAW&quot;)))
268             return false;
269         byte[] thatEncoded = that.getEncoded();
270         boolean ret = MessageDigest.isEqual(key, thatEncoded);
271         Arrays.fill(thatEncoded, (byte)0x00);
272         return ret;
273     }
274 
275     /**
276      * Replace the PBE key to be serialized.
277      *
278      * @return the standard KeyRep object to be serialized
279      *
280      * @throws ObjectStreamException if a new object representing
281      * this PBE key could not be created
282      */
<a name="10" id="anc10"></a><span class="line-added">283     @java.io.Serial</span>
284     private Object writeReplace() throws ObjectStreamException {
285             return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),
286                               getFormat(), getEncoded());
287     }
288 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
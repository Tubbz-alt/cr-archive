<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/com/sun/java/util/jar/pack/Fixups.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.java.util.jar.pack;
 27 
 28 import com.sun.java.util.jar.pack.ConstantPool.Entry;
 29 import java.util.AbstractCollection;
 30 import java.util.ArrayList;
 31 import java.util.Collection;
 32 import java.util.Iterator;
 33 import java.util.Objects;
 34 
 35 /**
 36  * Collection of relocatable constant pool references.
 37  * It operates with respect to a particular byte array,
 38  * and stores some of its state in the bytes themselves.
 39  * &lt;p&gt;
 40  * As a Collection, it can be iterated over, but it is not a List,
 41  * since it does not natively support indexed access.
 42  * &lt;p&gt;
 43  *
 44  * @author John Rose
 45  */
 46 final class Fixups extends AbstractCollection&lt;Fixups.Fixup&gt; {
 47     byte[] bytes;    // the subject of the relocations
 48     int head;        // desc locating first reloc
 49     int tail;        // desc locating last reloc
 50     int size;        // number of relocations
 51     Entry[] entries; // [0..size-1] relocations
 52     int[] bigDescs;  // descs which cannot be stored in the bytes
 53 
 54     // A &quot;desc&quot; (descriptor) is a bit-encoded pair of a location
 55     // and format.  Every fixup occurs at a &quot;desc&quot;.  Until final
 56     // patching, bytes addressed by descs may also be used to
 57     // link this data structure together.  If the bytes are missing,
 58     // or if the &quot;desc&quot; is too large to encode in the bytes,
 59     // it is kept in the bigDescs array.
 60 
 61     Fixups(byte[] bytes) {
 62         this.bytes = bytes;
 63         entries = new Entry[3];
 64         bigDescs = noBigDescs;
 65     }
 66     Fixups() {
 67         // If there are no bytes, all descs are kept in bigDescs.
 68         this((byte[])null);
 69     }
 70     Fixups(byte[] bytes, Collection&lt;Fixup&gt; fixups) {
 71         this(bytes);
 72         addAll(fixups);
 73     }
 74     Fixups(Collection&lt;Fixup&gt; fixups) {
 75         this((byte[])null);
 76         addAll(fixups);
 77     }
 78 
 79     private static final int MINBIGSIZE = 1;
 80     // cleverly share empty bigDescs:
 81     private static final int[] noBigDescs = {MINBIGSIZE};
 82 
 83     @Override
 84     public int size() {
 85         return size;
 86     }
 87 
 88     public void trimToSize() {
 89         if (size != entries.length) {
 90             Entry[] oldEntries = entries;
 91             entries = new Entry[size];
 92             System.arraycopy(oldEntries, 0, entries, 0, size);
 93         }
 94         int bigSize = bigDescs[BIGSIZE];
 95         if (bigSize == MINBIGSIZE) {
 96             bigDescs = noBigDescs;
 97         } else if (bigSize != bigDescs.length) {
 98             int[] oldBigDescs = bigDescs;
 99             bigDescs = new int[bigSize];
100             System.arraycopy(oldBigDescs, 0, bigDescs, 0, bigSize);
101         }
102     }
103 
104     public void visitRefs(Collection&lt;Entry&gt; refs) {
105         for (int i = 0; i &lt; size; i++) {
106             refs.add(entries[i]);
107         }
108     }
109 
110     @Override
111     public void clear() {
112         if (bytes != null) {
113             // Clean the bytes:
114             for (Fixup fx : this) {
115                 //System.out.println(&quot;clean &quot;+fx);
116                 storeIndex(fx.location(), fx.format(), 0);
117             }
118         }
119         size = 0;
120         if (bigDescs != noBigDescs)
121             bigDescs[BIGSIZE] = MINBIGSIZE;
122         // do not trim to size, however
123     }
124 
125     public byte[] getBytes() {
126         return bytes;
127     }
128 
129     public void setBytes(byte[] newBytes) {
130         if (bytes == newBytes)  return;
131         ArrayList&lt;Fixup&gt; old = null;
132         assert((old = new ArrayList&lt;&gt;(this)) != null);
133         if (bytes == null || newBytes == null) {
134             // One or the other representations is deficient.
135             // Construct a checkpoint.
136             ArrayList&lt;Fixup&gt; save = new ArrayList&lt;&gt;(this);
137             clear();
138             bytes = newBytes;
139             addAll(save);
140         } else {
141             // assume newBytes is some sort of bitwise copy of the old bytes
142             bytes = newBytes;
143         }
144         assert(old.equals(new ArrayList&lt;&gt;(this)));
145     }
146 
147     private static final int LOC_SHIFT = 1;
148     private static final int FMT_MASK = 0x1;
149     private static final byte UNUSED_BYTE = 0;
150     private static final byte OVERFLOW_BYTE = -1;
151     // fill pointer of bigDescs array is in element [0]
152     private static final int BIGSIZE = 0;
153 
154     // Format values:
155     private static final int U2_FORMAT = 0;
156     private static final int U1_FORMAT = 1;
157 
158     // Special values for the static methods.
159     private static final int SPECIAL_LOC = 0;
160     private static final int SPECIAL_FMT = U2_FORMAT;
161 
162     static int fmtLen(int fmt) { return 1+(fmt-U1_FORMAT)/(U2_FORMAT-U1_FORMAT); }
163     static int descLoc(int desc) { return desc &gt;&gt;&gt; LOC_SHIFT; }
164     static int descFmt(int desc) { return desc  &amp;  FMT_MASK; }
165     static int descEnd(int desc) { return descLoc(desc) + fmtLen(descFmt(desc)); }
166     static int makeDesc(int loc, int fmt) {
167         int desc = (loc &lt;&lt; LOC_SHIFT) | fmt;
168         assert(descLoc(desc) == loc);
169         assert(descFmt(desc) == fmt);
170         return desc;
171     }
172     int fetchDesc(int loc, int fmt) {
173         byte b1 = bytes[loc];
174         assert(b1 != OVERFLOW_BYTE);
175         int value;
176         if (fmt == U2_FORMAT) {
177             byte b2 = bytes[loc+1];
178             value = ((b1 &amp; 0xFF) &lt;&lt; 8) + (b2 &amp; 0xFF);
179         } else {
180             value = (b1 &amp; 0xFF);
181         }
182         // Stored loc field is difference between its own loc and next loc.
183         return value + (loc &lt;&lt; LOC_SHIFT);
184     }
185     boolean storeDesc(int loc, int fmt, int desc) {
186         if (bytes == null)
187             return false;
188         int value = desc - (loc &lt;&lt; LOC_SHIFT);
189         byte b1, b2;
190         switch (fmt) {
191         case U2_FORMAT:
192             assert(bytes[loc+0] == UNUSED_BYTE);
193             assert(bytes[loc+1] == UNUSED_BYTE);
194             b1 = (byte)(value &gt;&gt; 8);
195             b2 = (byte)(value &gt;&gt; 0);
196             if (value == (value &amp; 0xFFFF) &amp;&amp; b1 != OVERFLOW_BYTE) {
197                 bytes[loc+0] = b1;
198                 bytes[loc+1] = b2;
199                 assert(fetchDesc(loc, fmt) == desc);
200                 return true;
201             }
202             break;
203         case U1_FORMAT:
204             assert(bytes[loc] == UNUSED_BYTE);
205             b1 = (byte)value;
206             if (value == (value &amp; 0xFF) &amp;&amp; b1 != OVERFLOW_BYTE) {
207                 bytes[loc] = b1;
208                 assert(fetchDesc(loc, fmt) == desc);
209                 return true;
210             }
211             break;
212         default: assert(false);
213         }
214         // Failure.  Caller must allocate a bigDesc.
215         bytes[loc] = OVERFLOW_BYTE;
216         assert(fmt==U1_FORMAT || (bytes[loc+1]=(byte)bigDescs[BIGSIZE])!=999);
217         return false;
218     }
219     void storeIndex(int loc, int fmt, int value) {
220         storeIndex(bytes, loc, fmt, value);
221     }
222     static
223     void storeIndex(byte[] bytes, int loc, int fmt, int value) {
224         switch (fmt) {
225         case U2_FORMAT:
226             assert(value == (value &amp; 0xFFFF)) : (value);
227             bytes[loc+0] = (byte)(value &gt;&gt; 8);
228             bytes[loc+1] = (byte)(value &gt;&gt; 0);
229             break;
230         case U1_FORMAT:
231             assert(value == (value &amp; 0xFF)) : (value);
232             bytes[loc] = (byte)value;
233             break;
234         default: assert(false);
235         }
236     }
237 
238     void addU1(int pc, Entry ref) {
239         add(pc, U1_FORMAT, ref);
240     }
241 
242     void addU2(int pc, Entry ref) {
243         add(pc, U2_FORMAT, ref);
244     }
245 
246     /** Simple and necessary tuple to present each fixup. */
247     public static
248     class Fixup implements Comparable&lt;Fixup&gt; {
249         int desc;         // location and format of reloc
250         Entry entry;      // which entry to plug into the bytes
251         Fixup(int desc, Entry entry) {
252             this.desc = desc;
253             this.entry = entry;
254         }
255         public Fixup(int loc, int fmt, Entry entry) {
256             this.desc = makeDesc(loc, fmt);
257             this.entry = entry;
258         }
259         public int location() { return descLoc(desc); }
260         public int format() { return descFmt(desc); }
261         public Entry entry() { return entry; }
262         @Override
263         public int compareTo(Fixup that) {
264             // Ordering depends only on location.
265             return this.location() - that.location();
266         }
267         @Override
268         public boolean equals(Object x) {
269             if (!(x instanceof Fixup))  return false;
270             Fixup that = (Fixup) x;
271             return this.desc == that.desc &amp;&amp; this.entry == that.entry;
272         }
273         @Override
274         public int hashCode() {
275             int hash = 7;
276             hash = 59 * hash + this.desc;
277             hash = 59 * hash + Objects.hashCode(this.entry);
278             return hash;
279         }
280         @Override
281         public String toString() {
282             return &quot;@&quot;+location()+(format()==U1_FORMAT?&quot;.1&quot;:&quot;&quot;)+&quot;=&quot;+entry;
283         }
284     }
285 
286     private
287     class Itr implements Iterator&lt;Fixup&gt; {
288         int index = 0;               // index into entries
289         int bigIndex = BIGSIZE+1;    // index into bigDescs
290         int next = head;             // desc pointing to next fixup
291         @Override
292         public boolean hasNext() { return index &lt; size; }
293         @Override
294         public void remove() { throw new UnsupportedOperationException(); }
295         @Override
296         public Fixup next() {
297             int thisIndex = index;
298             return new Fixup(nextDesc(), entries[thisIndex]);
299         }
300         int nextDesc() {
301             index++;
302             int thisDesc = next;
303             if (index &lt; size) {
304                 // Fetch next desc eagerly, in case this fixup gets finalized.
305                 int loc = descLoc(thisDesc);
306                 int fmt = descFmt(thisDesc);
307                 if (bytes != null &amp;&amp; bytes[loc] != OVERFLOW_BYTE) {
308                     next = fetchDesc(loc, fmt);
309                 } else {
310                     // The unused extra byte is &quot;asserted&quot; to be equal to BI.
311                     // This helps keep the overflow descs in sync.
312                     assert(fmt==U1_FORMAT || bytes == null || bytes[loc+1]==(byte)bigIndex);
313                     next = bigDescs[bigIndex++];
314                 }
315             }
316             return thisDesc;
317         }
318     }
319 
320     @Override
321     public Iterator&lt;Fixup&gt; iterator() {
322         return new Itr();
323     }
324     public void add(int location, int format, Entry entry) {
325         addDesc(makeDesc(location, format), entry);
326     }
327     @Override
328     public boolean add(Fixup f) {
329         addDesc(f.desc, f.entry);
330         return true;
331     }
332 
333     @Override
334     public boolean addAll(Collection&lt;? extends Fixup&gt; c) {
335         if (c instanceof Fixups) {
336             // Use knowledge of Itr structure to avoid building little structs.
337             Fixups that = (Fixups) c;
338             if (that.size == 0)  return false;
339             if (this.size == 0 &amp;&amp; entries.length &lt; that.size)
340                 growEntries(that.size);  // presize exactly
341             Entry[] thatEntries = that.entries;
342             for (Itr i = that.new Itr(); i.hasNext(); ) {
343                 int ni = i.index;
344                 addDesc(i.nextDesc(), thatEntries[ni]);
345             }
346             return true;
347         } else {
348             return super.addAll(c);
349         }
350     }
351     // Here is how things get added:
352     private void addDesc(int thisDesc, Entry entry) {
353         if (entries.length == size)
354             growEntries(size * 2);
355         entries[size] = entry;
356         if (size == 0) {
357             head = tail = thisDesc;
358         } else {
359             int prevDesc = tail;
360             // Store new desc in previous tail.
361             int prevLoc = descLoc(prevDesc);
362             int prevFmt = descFmt(prevDesc);
363             int prevLen = fmtLen(prevFmt);
364             int thisLoc = descLoc(thisDesc);
365             // The collection must go in ascending order, and not overlap.
366             if (thisLoc &lt; prevLoc + prevLen)
367                 badOverlap(thisLoc);
368             tail = thisDesc;
369             if (!storeDesc(prevLoc, prevFmt, thisDesc)) {
370                 // overflow
371                 int bigSize = bigDescs[BIGSIZE];
372                 if (bigDescs.length == bigSize)
373                     growBigDescs();
374                 //System.out.println(&quot;bigDescs[&quot;+bigSize+&quot;] = &quot;+thisDesc);
375                 bigDescs[bigSize++] = thisDesc;
376                 bigDescs[BIGSIZE] = bigSize;
377             }
378         }
379         size += 1;
380     }
381     private void badOverlap(int thisLoc) {
382         throw new IllegalArgumentException(&quot;locs must be ascending and must not overlap:  &quot;+thisLoc+&quot; &gt;&gt; &quot;+this);
383     }
384 
385     private void growEntries(int newSize) {
386         Entry[] oldEntries = entries;
387         entries = new Entry[Math.max(3, newSize)];
388         System.arraycopy(oldEntries, 0, entries, 0, oldEntries.length);
389     }
390     private void growBigDescs() {
391         int[] oldBigDescs = bigDescs;
392         bigDescs = new int[oldBigDescs.length * 2];
393         System.arraycopy(oldBigDescs, 0, bigDescs, 0, oldBigDescs.length);
394     }
395 
396     /// Static methods that optimize the use of this class.
397     static Object addRefWithBytes(Object f, byte[] bytes, Entry e) {
398         return add(f, bytes, 0, U2_FORMAT, e);
399     }
400     static Object addRefWithLoc(Object f, int loc, Entry entry) {
401         return add(f, null, loc, U2_FORMAT, entry);
402     }
403     private static
404     Object add(Object prevFixups,
405                byte[] bytes, int loc, int fmt,
406                Entry e) {
407         Fixups f;
408         if (prevFixups == null) {
409             if (loc == SPECIAL_LOC &amp;&amp; fmt == SPECIAL_FMT) {
410                 // Special convention:  If the attribute has a
411                 // U2 relocation at position zero, store the Entry
412                 // rather than building a Fixups structure.
413                 return e;
414             }
415             f = new Fixups(bytes);
416         } else if (!(prevFixups instanceof Fixups)) {
417             // Recognize the special convention:
418             Entry firstEntry = (Entry) prevFixups;
419             f = new Fixups(bytes);
420             f.add(SPECIAL_LOC, SPECIAL_FMT, firstEntry);
421         } else {
422             f = (Fixups) prevFixups;
423             assert(f.bytes == bytes);
424         }
425         f.add(loc, fmt, e);
426         return f;
427     }
428 
429     public static
430     void setBytes(Object fixups, byte[] bytes) {
431         if (fixups instanceof Fixups) {
432             Fixups f = (Fixups) fixups;
433             f.setBytes(bytes);
434         }
435     }
436 
437     public static
438     Object trimToSize(Object fixups) {
439         if (fixups instanceof Fixups) {
440             Fixups f = (Fixups) fixups;
441             f.trimToSize();
442             if (f.size() == 0)
443                 fixups = null;
444         }
445         return fixups;
446     }
447 
448     // Iterate over all the references in this set of fixups.
449     public static
450     void visitRefs(Object fixups, Collection&lt;Entry&gt; refs) {
451         if (fixups == null) {
452         } else if (!(fixups instanceof Fixups)) {
453             // Special convention; see above.
454             refs.add((Entry) fixups);
455         } else {
456             Fixups f = (Fixups) fixups;
457             f.visitRefs(refs);
458         }
459     }
460 
461     // Clear out this set of fixups by replacing each reference
462     // by a hardcoded coding of its reference, drawn from ix.
463     public static
464     void finishRefs(Object fixups, byte[] bytes, ConstantPool.Index ix) {
465         if (fixups == null)
466             return;
467         if (!(fixups instanceof Fixups)) {
468             // Special convention; see above.
469             int index = ix.indexOf((Entry) fixups);
470             storeIndex(bytes, SPECIAL_LOC, SPECIAL_FMT, index);
471             return;
472         }
473         Fixups f = (Fixups) fixups;
474         assert(f.bytes == bytes);
475         f.finishRefs(ix);
476     }
477 
478     void finishRefs(ConstantPool.Index ix) {
479         if (isEmpty())
480             return;
481         for (Fixup fx : this) {
482             int index = ix.indexOf(fx.entry);
483             //System.out.println(&quot;finish &quot;+fx+&quot; = &quot;+index);
484             // Note that the iterator has already fetched the
485             // bytes we are about to overwrite.
486             storeIndex(fx.location(), fx.format(), index);
487         }
488         // Further iterations should do nothing:
489         bytes = null;  // do not clean them
490         clear();
491     }
492 
493 /*
494     /// Testing.
495     public static void main(String[] av) {
496         byte[] bytes = new byte[1 &lt;&lt; 20];
497         ConstantPool cp = new ConstantPool();
498         Fixups f = new Fixups(bytes);
499         boolean isU1 = false;
500         int span = 3;
501         int nextLoc = 0;
502         int[] locs = new int[100];
503         final int[] indexes = new int[100];
504         int iptr = 1;
505         for (int loc = 0; loc &lt; bytes.length; loc++) {
506             if (loc == nextLoc &amp;&amp; loc+1 &lt; bytes.length) {
507                 int fmt = (isU1 ? U1_FORMAT : U2_FORMAT);
508                 Entry e = ConstantPool.getUtf8Entry(&quot;L&quot;+loc);
509                 f.add(loc, fmt, e);
510                 isU1 ^= true;
511                 if (iptr &lt; 10) {
512                     // Make it close in.
513                     nextLoc += fmtLen(fmt) + (iptr &lt; 5 ? 0 : 1);
514                 } else {
515                     nextLoc += span;
516                     span = (int)(span * 1.77);
517                 }
518                 // Here are the bytes that would have gone here:
519                 locs[iptr] = loc;
520                 if (fmt == U1_FORMAT) {
521                     indexes[iptr++] = (loc &amp; 0xFF);
522                 } else {
523                     indexes[iptr++] = ((loc &amp; 0xFF) &lt;&lt; 8) | ((loc+1) &amp; 0xFF);
524                     ++loc;  // skip a byte
525                 }
526                 continue;
527             }
528             bytes[loc] = (byte)loc;
529         }
530         System.out.println(&quot;size=&quot;+f.size()
531                            +&quot; overflow=&quot;+(f.bigDescs[BIGSIZE]-1));
532         System.out.println(&quot;Fixups: &quot;+f);
533         // Test collection contents.
534         assert(iptr == 1+f.size());
535         List l = new ArrayList(f);
536         Collections.sort(l);  // should not change the order
537         if (!l.equals(new ArrayList(f)))  System.out.println(&quot;** disordered&quot;);
538         f.setBytes(null);
539         if (!l.equals(new ArrayList(f)))  System.out.println(&quot;** bad set 1&quot;);
540         f.setBytes(bytes);
541         if (!l.equals(new ArrayList(f)))  System.out.println(&quot;** bad set 2&quot;);
542         Fixups f3 = new Fixups(f);
543         if (!l.equals(new ArrayList(f3))) System.out.println(&quot;** bad set 3&quot;);
544         Iterator fi = f.iterator();
545         for (int i = 1; i &lt; iptr; i++) {
546             Fixup fx = (Fixup) fi.next();
547             if (fx.location() != locs[i]) {
548                 System.out.println(&quot;** &quot;+fx+&quot; != &quot;+locs[i]);
549             }
550             if (fx.format() == U1_FORMAT)
551                 System.out.println(fx+&quot; -&gt; &quot;+bytes[locs[i]]);
552             else
553                 System.out.println(fx+&quot; -&gt; &quot;+bytes[locs[i]]+&quot; &quot;+bytes[locs[i]+1]);
554         }
555         assert(!fi.hasNext());
556         indexes[0] = 1;  // like iptr
557         Index ix = new Index(&quot;ix&quot;) {
558             public int indexOf(Entry e) {
559                 return indexes[indexes[0]++];
560             }
561         };
562         f.finishRefs(ix);
563         for (int loc = 0; loc &lt; bytes.length; loc++) {
564             if (bytes[loc] != (byte)loc) {
565                 System.out.println(&quot;** [&quot;+loc+&quot;] = &quot;+bytes[loc]+&quot; != &quot;+(byte)loc);
566             }
567         }
568     }
569 //*/
570 }
    </pre>
  </body>
</html>
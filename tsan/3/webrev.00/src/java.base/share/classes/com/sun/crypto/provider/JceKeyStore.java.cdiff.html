<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElectronicCodeBook.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
   */
  
  package com.sun.crypto.provider;
  
  import sun.security.util.Debug;
<span class="line-added">+ import sun.security.util.IOUtils;</span>
  
  import java.io.*;
  import java.util.*;
  import java.security.AccessController;
  import java.security.DigestInputStream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,10 ***</span>
<span class="line-new-header">--- 44,12 ---</span>
  import java.security.cert.Certificate;
  import java.security.cert.CertificateFactory;
  import java.security.cert.CertificateException;
  import javax.crypto.SealedObject;
  
<span class="line-added">+ import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added">+ </span>
  /**
   * This class provides the keystore implementation referred to as &quot;jceks&quot;.
   * This implementation strongly protects the keystore private keys using
   * triple-DES, where the triple-DES encryption/decryption key is derived from
   * the user&#39;s password.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
  
      // Private key and supporting certificate chain
      private static final class PrivateKeyEntry {
          Date date; // the creation date of this entry
          byte[] protectedKey;
<span class="line-modified">!         Certificate chain[];</span>
      };
  
      // Secret key
      private static final class SecretKeyEntry {
          Date date; // the creation date of this entry
<span class="line-new-header">--- 72,11 ---</span>
  
      // Private key and supporting certificate chain
      private static final class PrivateKeyEntry {
          Date date; // the creation date of this entry
          byte[] protectedKey;
<span class="line-modified">!         Certificate[] chain;</span>
      };
  
      // Secret key
      private static final class SecretKeyEntry {
          Date date; // the creation date of this entry
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,55 ***</span>
  
                          // read the (entry creation) date
                          entry.date = new Date(dis.readLong());
  
                          // read the private key
<span class="line-modified">!                         try {</span>
<span class="line-removed">-                             entry.protectedKey = new byte[dis.readInt()];</span>
<span class="line-removed">-                         } catch (OutOfMemoryError e) {</span>
<span class="line-removed">-                             throw new IOException(&quot;Keysize too big&quot;);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         dis.readFully(entry.protectedKey);</span>
  
                          // read the certificate chain
                          int numOfCerts = dis.readInt();
<span class="line-modified">!                         try {</span>
<span class="line-removed">-                             if (numOfCerts &gt; 0) {</span>
<span class="line-removed">-                                 entry.chain = new Certificate[numOfCerts];</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         } catch (OutOfMemoryError e) {</span>
<span class="line-removed">-                             throw new IOException(&quot;Too many certificates in &quot;</span>
<span class="line-removed">-                                                   + &quot;chain&quot;);</span>
<span class="line-removed">-                         }</span>
                          for (int j = 0; j &lt; numOfCerts; j++) {
                              if (xVersion == 2) {
                                  // read the certificate type, and instantiate a
                                  // certificate factory of that type (reuse
                                  // existing factory if possible)
                                  String certType = dis.readUTF();
                                  if (cfs.containsKey(certType)) {
<span class="line-modified">!                                 // reuse certificate factory</span>
                                      cf = cfs.get(certType);
                                  } else {
<span class="line-modified">!                                 // create new certificate factory</span>
                                      cf = CertificateFactory.getInstance(
                                          certType);
<span class="line-modified">!                                 // store the certificate factory so we can</span>
<span class="line-modified">!                                 // reuse it later</span>
                                      cfs.put(certType, cf);
                                  }
                              }
                              // instantiate the certificate
<span class="line-modified">!                             try {</span>
<span class="line-removed">-                                 encoded = new byte[dis.readInt()];</span>
<span class="line-removed">-                             } catch (OutOfMemoryError e) {</span>
<span class="line-removed">-                                 throw new IOException(&quot;Certificate too big&quot;);</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             dis.readFully(encoded);</span>
                              bais = new ByteArrayInputStream(encoded);
<span class="line-modified">!                             entry.chain[j] = cf.generateCertificate(bais);</span>
                          }
  
                          // Add the entry to the list
                          entries.put(alias, entry);
  
                      } else if (tag == 2) { // trusted certificate entry
<span class="line-new-header">--- 741,40 ---</span>
  
                          // read the (entry creation) date
                          entry.date = new Date(dis.readLong());
  
                          // read the private key
<span class="line-modified">!                         entry.protectedKey = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
  
                          // read the certificate chain
                          int numOfCerts = dis.readInt();
<span class="line-modified">!                         List&lt;Certificate&gt; tmpCerts = new ArrayList&lt;&gt;();</span>
                          for (int j = 0; j &lt; numOfCerts; j++) {
                              if (xVersion == 2) {
                                  // read the certificate type, and instantiate a
                                  // certificate factory of that type (reuse
                                  // existing factory if possible)
                                  String certType = dis.readUTF();
                                  if (cfs.containsKey(certType)) {
<span class="line-modified">!                                     // reuse certificate factory</span>
                                      cf = cfs.get(certType);
                                  } else {
<span class="line-modified">!                                     // create new certificate factory</span>
                                      cf = CertificateFactory.getInstance(
                                          certType);
<span class="line-modified">!                                     // store the certificate factory so we can</span>
<span class="line-modified">!                                     // reuse it later</span>
                                      cfs.put(certType, cf);
                                  }
                              }
                              // instantiate the certificate
<span class="line-modified">!                             encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
                              bais = new ByteArrayInputStream(encoded);
<span class="line-modified">!                             tmpCerts.add(cf.generateCertificate(bais));</span>
                          }
<span class="line-added">+                         entry.chain = tmpCerts.toArray(</span>
<span class="line-added">+                                 new Certificate[numOfCerts]);</span>
  
                          // Add the entry to the list
                          entries.put(alias, entry);
  
                      } else if (tag == 2) { // trusted certificate entry
</pre>
<hr />
<pre>
<span class="line-old-header">*** 814,16 ***</span>
                                  // store the certificate factory so we can
                                  // reuse it later
                                  cfs.put(certType, cf);
                              }
                          }
<span class="line-modified">!                         try {</span>
<span class="line-removed">-                             encoded = new byte[dis.readInt()];</span>
<span class="line-removed">-                         } catch (OutOfMemoryError e) {</span>
<span class="line-removed">-                             throw new IOException(&quot;Certificate too big&quot;);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         dis.readFully(encoded);</span>
                          bais = new ByteArrayInputStream(encoded);
                          entry.cert = cf.generateCertificate(bais);
  
                          // Add the entry to the list
                          entries.put(alias, entry);
<span class="line-new-header">--- 802,11 ---</span>
                                  // store the certificate factory so we can
                                  // reuse it later
                                  cfs.put(certType, cf);
                              }
                          }
<span class="line-modified">!                         encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
                          bais = new ByteArrayInputStream(encoded);
                          entry.cert = cf.generateCertificate(bais);
  
                          // Add the entry to the list
                          entries.put(alias, entry);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 878,22 ***</span>
                   * If a password has been provided, we check the keyed digest
                   * at the end. If this check fails, the store has been tampered
                   * with
                   */
                  if (password != null) {
<span class="line-modified">!                     byte computed[], actual[];</span>
<span class="line-modified">!                     computed = md.digest();</span>
<span class="line-modified">!                     actual = new byte[computed.length];</span>
<span class="line-modified">!                     dis.readFully(actual);</span>
<span class="line-removed">-                     for (int i = 0; i &lt; computed.length; i++) {</span>
<span class="line-removed">-                         if (computed[i] != actual[i]) {</span>
<span class="line-removed">-                             throw new IOException(</span>
                                  &quot;Keystore was tampered with, or &quot;
                                          + &quot;password was incorrect&quot;,
<span class="line-modified">!                                     new UnrecoverableKeyException(</span>
<span class="line-modified">!                                             &quot;Password verification failed&quot;));</span>
<span class="line-removed">-                         }</span>
                      }
                  }
              }  finally {
                  if (ois != null) {
                      ois.close();
<span class="line-new-header">--- 861,18 ---</span>
                   * If a password has been provided, we check the keyed digest
                   * at the end. If this check fails, the store has been tampered
                   * with
                   */
                  if (password != null) {
<span class="line-modified">!                     byte[] computed = md.digest();</span>
<span class="line-modified">!                     byte[] actual = IOUtils.readExactlyNBytes(dis, computed.length);</span>
<span class="line-modified">!                     if (!MessageDigest.isEqual(computed, actual)) {</span>
<span class="line-modified">!                         throw new IOException(</span>
                                  &quot;Keystore was tampered with, or &quot;
                                          + &quot;password was incorrect&quot;,
<span class="line-modified">!                                 new UnrecoverableKeyException(</span>
<span class="line-modified">!                                         &quot;Password verification failed&quot;));</span>
                      }
                  }
              }  finally {
                  if (ois != null) {
                      ois.close();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 907,11 ***</span>
      /**
       * To guard against tampering with the keystore, we append a keyed
       * hash with a bit of whitener.
       */
      private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">!     throws NoSuchAlgorithmException, UnsupportedEncodingException {</span>
          int i, j;
  
          MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
          byte[] passwdBytes = new byte[password.length * 2];
          for (i=0, j=0; i&lt;password.length; i++) {
<span class="line-new-header">--- 886,12 ---</span>
      /**
       * To guard against tampering with the keystore, we append a keyed
       * hash with a bit of whitener.
       */
      private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">!         throws NoSuchAlgorithmException</span>
<span class="line-added">+     {</span>
          int i, j;
  
          MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
          byte[] passwdBytes = new byte[password.length * 2];
          for (i=0, j=0; i&lt;password.length; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 919,11 ***</span>
              passwdBytes[j++] = (byte)password[i];
          }
          md.update(passwdBytes);
          for (i=0; i&lt;passwdBytes.length; i++)
              passwdBytes[i] = 0;
<span class="line-modified">!         md.update(&quot;Mighty Aphrodite&quot;.getBytes(&quot;UTF8&quot;));</span>
          return md;
      }
  
      /**
       * Probe the first few bytes of the keystore data stream for a valid
<span class="line-new-header">--- 899,11 ---</span>
              passwdBytes[j++] = (byte)password[i];
          }
          md.update(passwdBytes);
          for (i=0; i&lt;passwdBytes.length; i++)
              passwdBytes[i] = 0;
<span class="line-modified">!         md.update(&quot;Mighty Aphrodite&quot;.getBytes(UTF_8));</span>
          return md;
      }
  
      /**
       * Probe the first few bytes of the keystore data stream for a valid
</pre>
<center><a href="ElectronicCodeBook.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
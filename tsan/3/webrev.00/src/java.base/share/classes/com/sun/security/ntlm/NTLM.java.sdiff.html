<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/security/ntlm/NTLM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../cert/internal/x509/X509V1CertImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NTLMException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/security/ntlm/NTLM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.ntlm;
 27 
 28 import sun.security.action.GetBooleanAction;
 29 
 30 import static com.sun.security.ntlm.Version.*;
 31 import java.io.IOException;
<span class="line-modified"> 32 import java.io.UnsupportedEncodingException;</span>
 33 import java.security.InvalidKeyException;
 34 import java.security.MessageDigest;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.spec.InvalidKeySpecException;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 import javax.crypto.BadPaddingException;
 40 import javax.crypto.Cipher;
 41 import javax.crypto.IllegalBlockSizeException;
 42 import javax.crypto.Mac;
 43 import javax.crypto.NoSuchPaddingException;
 44 import javax.crypto.SecretKey;
 45 import javax.crypto.SecretKeyFactory;
 46 import javax.crypto.spec.DESKeySpec;
 47 import javax.crypto.spec.SecretKeySpec;
 48 
 49 /**
 50  * NTLM authentication implemented according to MS-NLMP, version 12.1
 51  * @since 1.7
 52  */
</pre>
<hr />
<pre>
165                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
166                         &quot;Input message incorrect size&quot;);
167             }
168         }
169 
170         byte[] readSecurityBuffer(int offset) throws NTLMException {
171             int pos = readInt(offset+4);
172             if (pos == 0) return new byte[0];
173             try {
174                 return Arrays.copyOfRange(
175                         internal, pos, pos + readShort(offset));
176             } catch (ArrayIndexOutOfBoundsException ex) {
177                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
178                         &quot;Input message incorrect size&quot;);
179             }
180         }
181 
182         String readSecurityBuffer(int offset, boolean unicode)
183                 throws NTLMException {
184             byte[] raw = readSecurityBuffer(offset);
<span class="line-modified">185             try {</span>
<span class="line-modified">186                 return raw == null ? null : new String(</span>
<span class="line-modified">187                         raw, unicode ? &quot;UnicodeLittleUnmarked&quot; : &quot;ISO8859_1&quot;);</span>
<span class="line-removed">188             } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">189                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
<span class="line-removed">190                         &quot;Invalid input encoding&quot;);</span>
<span class="line-removed">191             }</span>
192         }
193     }
194 
195     /**
196      * Writing an NTLM packet
197      */
198     static class Writer {
199 
200         private byte[] internal;    // buffer
201         private int current;        // current written content interface buffer
202 
203         /**
204          * Starts writing a NTLM packet
205          * @param type NEGOTIATE || CHALLENGE || AUTHENTICATE
206          * @param len the base length, without security buffers
207          */
208         Writer(int type, int len) {
209             assert len &lt; 256;
210             internal = new byte[256];
211             current = len;
</pre>
<hr />
<pre>
230             System.arraycopy(data, 0, internal, offset, data.length);
231         }
232 
233         void writeSecurityBuffer(int offset, byte[] data) {
234             if (data == null) {
235                 writeShort(offset+4, current);
236             } else {
237                 int len = data.length;
238                 if (current + len &gt; internal.length) {
239                     internal = Arrays.copyOf(internal, current + len + 256);
240                 }
241                 writeShort(offset, len);
242                 writeShort(offset+2, len);
243                 writeShort(offset+4, current);
244                 System.arraycopy(data, 0, internal, current, len);
245                 current += len;
246             }
247         }
248 
249         void writeSecurityBuffer(int offset, String str, boolean unicode) {
<span class="line-modified">250             try {</span>
<span class="line-modified">251                 writeSecurityBuffer(offset, str == null ? null : str.getBytes(</span>
<span class="line-modified">252                         unicode ? &quot;UnicodeLittleUnmarked&quot; : &quot;ISO8859_1&quot;));</span>
<span class="line-removed">253             } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">254                 assert false;</span>
<span class="line-removed">255             }</span>
256         }
257 
258         byte[] getBytes() {
259             return Arrays.copyOf(internal, current);
260         }
261     }
262 
263     // LM/NTLM
264 
265     /* Convert a 7 byte array to an 8 byte array (for a des key with parity)
266      * input starts at offset off
267      */
268     byte[] makeDesKey (byte[] input, int off) {
269         int[] in = new int [input.length];
270         for (int i=0; i&lt;in.length; i++ ) {
271             in[i] = input[i]&lt;0 ? input[i]+256: input[i];
272         }
273         byte[] out = new byte[8];
274         out[0] = (byte)in[off+0];
275         out[1] = (byte)(((in[off+0] &lt;&lt; 7) &amp; 0xFF) | (in[off+1] &gt;&gt; 1));
</pre>
<hr />
<pre>
363         return null;
364     }
365 
366     // LMv2/NTLMv2
367 
368     byte[] hmacMD5(byte[] key, byte[] text) {
369         try {
370             SecretKeySpec skey =
371                     new SecretKeySpec(Arrays.copyOf(key, 16), &quot;HmacMD5&quot;);
372             hmac.init(skey);
373             return hmac.doFinal(text);
374         } catch (InvalidKeyException ex) {
375             assert false;
376         } catch (RuntimeException e) {
377             assert false;
378         }
379         return null;
380     }
381 
382     byte[] calcV2(byte[] nthash, String text, byte[] blob, byte[] challenge) {
<span class="line-modified">383         try {</span>
<span class="line-modified">384             byte[] ntlmv2hash = hmacMD5(nthash,</span>
<span class="line-modified">385                     text.getBytes(&quot;UnicodeLittleUnmarked&quot;));</span>
<span class="line-modified">386             byte[] cn = new byte[blob.length+8];</span>
<span class="line-modified">387             System.arraycopy(challenge, 0, cn, 0, 8);</span>
<span class="line-modified">388             System.arraycopy(blob, 0, cn, 8, blob.length);</span>
<span class="line-modified">389             byte[] result = new byte[16+blob.length];</span>
<span class="line-modified">390             System.arraycopy(hmacMD5(ntlmv2hash, cn), 0, result, 0, 16);</span>
<span class="line-removed">391             System.arraycopy(blob, 0, result, 16, blob.length);</span>
<span class="line-removed">392             return result;</span>
<span class="line-removed">393         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">394             assert false;</span>
<span class="line-removed">395         }</span>
<span class="line-removed">396         return null;</span>
397     }
398 
399     // NTLM2 LM/NTLM
400 
401     static byte[] ntlm2LM(byte[] nonce) {
402         return Arrays.copyOf(nonce, 24);
403     }
404 
405     byte[] ntlm2NTLM(byte[] ntlmHash, byte[] nonce, byte[] challenge) {
406         byte[] b = Arrays.copyOf(challenge, 16);
407         System.arraycopy(nonce, 0, b, 8, 8);
408         byte[] sesshash = Arrays.copyOf(md5.digest(b), 8);
409         return calcResponse(ntlmHash, sesshash);
410     }
411 
412     // Password in ASCII and UNICODE
413 
414     static byte[] getP1(char[] password) {
<span class="line-modified">415         try {</span>
<span class="line-modified">416             return new String(password).toUpperCase(</span>
<span class="line-removed">417                                     Locale.ENGLISH).getBytes(&quot;ISO8859_1&quot;);</span>
<span class="line-removed">418         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">419             return null;</span>
<span class="line-removed">420         }</span>
421     }
422 
423     static byte[] getP2(char[] password) {
<span class="line-modified">424         try {</span>
<span class="line-removed">425             return new String(password).getBytes(&quot;UnicodeLittleUnmarked&quot;);</span>
<span class="line-removed">426         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed">427             return null;</span>
<span class="line-removed">428         }</span>
429     }
430 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.ntlm;
 27 
 28 import sun.security.action.GetBooleanAction;
 29 
 30 import static com.sun.security.ntlm.Version.*;
 31 import java.io.IOException;
<span class="line-modified"> 32 import java.nio.charset.StandardCharsets;</span>
 33 import java.security.InvalidKeyException;
 34 import java.security.MessageDigest;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.spec.InvalidKeySpecException;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 import javax.crypto.BadPaddingException;
 40 import javax.crypto.Cipher;
 41 import javax.crypto.IllegalBlockSizeException;
 42 import javax.crypto.Mac;
 43 import javax.crypto.NoSuchPaddingException;
 44 import javax.crypto.SecretKey;
 45 import javax.crypto.SecretKeyFactory;
 46 import javax.crypto.spec.DESKeySpec;
 47 import javax.crypto.spec.SecretKeySpec;
 48 
 49 /**
 50  * NTLM authentication implemented according to MS-NLMP, version 12.1
 51  * @since 1.7
 52  */
</pre>
<hr />
<pre>
165                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
166                         &quot;Input message incorrect size&quot;);
167             }
168         }
169 
170         byte[] readSecurityBuffer(int offset) throws NTLMException {
171             int pos = readInt(offset+4);
172             if (pos == 0) return new byte[0];
173             try {
174                 return Arrays.copyOfRange(
175                         internal, pos, pos + readShort(offset));
176             } catch (ArrayIndexOutOfBoundsException ex) {
177                 throw new NTLMException(NTLMException.PACKET_READ_ERROR,
178                         &quot;Input message incorrect size&quot;);
179             }
180         }
181 
182         String readSecurityBuffer(int offset, boolean unicode)
183                 throws NTLMException {
184             byte[] raw = readSecurityBuffer(offset);
<span class="line-modified">185             return raw == null ? null : new String(</span>
<span class="line-modified">186                     raw, unicode ? StandardCharsets.UTF_16LE</span>
<span class="line-modified">187                                  : StandardCharsets.ISO_8859_1);</span>




188         }
189     }
190 
191     /**
192      * Writing an NTLM packet
193      */
194     static class Writer {
195 
196         private byte[] internal;    // buffer
197         private int current;        // current written content interface buffer
198 
199         /**
200          * Starts writing a NTLM packet
201          * @param type NEGOTIATE || CHALLENGE || AUTHENTICATE
202          * @param len the base length, without security buffers
203          */
204         Writer(int type, int len) {
205             assert len &lt; 256;
206             internal = new byte[256];
207             current = len;
</pre>
<hr />
<pre>
226             System.arraycopy(data, 0, internal, offset, data.length);
227         }
228 
229         void writeSecurityBuffer(int offset, byte[] data) {
230             if (data == null) {
231                 writeShort(offset+4, current);
232             } else {
233                 int len = data.length;
234                 if (current + len &gt; internal.length) {
235                     internal = Arrays.copyOf(internal, current + len + 256);
236                 }
237                 writeShort(offset, len);
238                 writeShort(offset+2, len);
239                 writeShort(offset+4, current);
240                 System.arraycopy(data, 0, internal, current, len);
241                 current += len;
242             }
243         }
244 
245         void writeSecurityBuffer(int offset, String str, boolean unicode) {
<span class="line-modified">246             writeSecurityBuffer(offset, str == null ? null : str.getBytes(</span>
<span class="line-modified">247                     unicode ? StandardCharsets.UTF_16LE</span>
<span class="line-modified">248                             : StandardCharsets.ISO_8859_1));</span>



249         }
250 
251         byte[] getBytes() {
252             return Arrays.copyOf(internal, current);
253         }
254     }
255 
256     // LM/NTLM
257 
258     /* Convert a 7 byte array to an 8 byte array (for a des key with parity)
259      * input starts at offset off
260      */
261     byte[] makeDesKey (byte[] input, int off) {
262         int[] in = new int [input.length];
263         for (int i=0; i&lt;in.length; i++ ) {
264             in[i] = input[i]&lt;0 ? input[i]+256: input[i];
265         }
266         byte[] out = new byte[8];
267         out[0] = (byte)in[off+0];
268         out[1] = (byte)(((in[off+0] &lt;&lt; 7) &amp; 0xFF) | (in[off+1] &gt;&gt; 1));
</pre>
<hr />
<pre>
356         return null;
357     }
358 
359     // LMv2/NTLMv2
360 
361     byte[] hmacMD5(byte[] key, byte[] text) {
362         try {
363             SecretKeySpec skey =
364                     new SecretKeySpec(Arrays.copyOf(key, 16), &quot;HmacMD5&quot;);
365             hmac.init(skey);
366             return hmac.doFinal(text);
367         } catch (InvalidKeyException ex) {
368             assert false;
369         } catch (RuntimeException e) {
370             assert false;
371         }
372         return null;
373     }
374 
375     byte[] calcV2(byte[] nthash, String text, byte[] blob, byte[] challenge) {
<span class="line-modified">376         byte[] ntlmv2hash = hmacMD5(nthash, text.getBytes(StandardCharsets.UTF_16LE));</span>
<span class="line-modified">377         byte[] cn = new byte[blob.length+8];</span>
<span class="line-modified">378         System.arraycopy(challenge, 0, cn, 0, 8);</span>
<span class="line-modified">379         System.arraycopy(blob, 0, cn, 8, blob.length);</span>
<span class="line-modified">380         byte[] result = new byte[16+blob.length];</span>
<span class="line-modified">381         System.arraycopy(hmacMD5(ntlmv2hash, cn), 0, result, 0, 16);</span>
<span class="line-modified">382         System.arraycopy(blob, 0, result, 16, blob.length);</span>
<span class="line-modified">383         return result;</span>






384     }
385 
386     // NTLM2 LM/NTLM
387 
388     static byte[] ntlm2LM(byte[] nonce) {
389         return Arrays.copyOf(nonce, 24);
390     }
391 
392     byte[] ntlm2NTLM(byte[] ntlmHash, byte[] nonce, byte[] challenge) {
393         byte[] b = Arrays.copyOf(challenge, 16);
394         System.arraycopy(nonce, 0, b, 8, 8);
395         byte[] sesshash = Arrays.copyOf(md5.digest(b), 8);
396         return calcResponse(ntlmHash, sesshash);
397     }
398 
399     // Password in ASCII and UNICODE
400 
401     static byte[] getP1(char[] password) {
<span class="line-modified">402         return new String(password).toUpperCase(Locale.ENGLISH)</span>
<span class="line-modified">403                                    .getBytes(StandardCharsets.ISO_8859_1);</span>




404     }
405 
406     static byte[] getP2(char[] password) {
<span class="line-modified">407         return new String(password).getBytes(StandardCharsets.UTF_16LE);</span>




408     }
409 }
</pre>
</td>
</tr>
</table>
<center><a href="../cert/internal/x509/X509V1CertImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NTLMException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
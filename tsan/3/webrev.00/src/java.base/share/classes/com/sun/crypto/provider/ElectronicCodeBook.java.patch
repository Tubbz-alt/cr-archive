diff a/src/java.base/share/classes/com/sun/crypto/provider/ElectronicCodeBook.java b/src/java.base/share/classes/com/sun/crypto/provider/ElectronicCodeBook.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/ElectronicCodeBook.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/ElectronicCodeBook.java
@@ -26,10 +26,12 @@
 package com.sun.crypto.provider;
 
 import java.security.InvalidKeyException;
 import java.security.ProviderException;
 import sun.security.util.ArrayUtil;
+import java.util.Objects;
+import jdk.internal.HotSpotIntrinsicCandidate;
 
 /**
  * This class represents ciphers in electronic codebook (ECB) mode.
  *
  * <p>This mode is implemented independently of a particular cipher.
@@ -93,10 +95,20 @@
             throw new InvalidKeyException("Internal error");
         }
         embeddedCipher.init(decrypting, algorithm, key);
     }
 
+    @HotSpotIntrinsicCandidate
+    private int implECBEncrypt(byte [] in, int inOff, int len, byte[] out, int outOff) {
+        for (int i = len; i >= blockSize; i -= blockSize) {
+            embeddedCipher.encryptBlock(in, inOff, out, outOff);
+            inOff += blockSize;
+            outOff += blockSize;
+        }
+        return len;
+    }
+
     /**
      * Performs encryption operation.
      *
      * <p>The input plain text <code>in</code>, starting at
      * <code>inOff</code> and ending at * <code>(inOff + len - 1)</code>,
@@ -114,13 +126,17 @@
      */
     int encrypt(byte[] in, int inOff, int len, byte[] out, int outOff) {
         ArrayUtil.blockSizeCheck(len, blockSize);
         ArrayUtil.nullAndBoundsCheck(in, inOff, len);
         ArrayUtil.nullAndBoundsCheck(out, outOff, len);
+        return implECBEncrypt(in, inOff, len, out, outOff);
+    }
 
+    @HotSpotIntrinsicCandidate
+    private int implECBDecrypt(byte [] in, int inOff, int len, byte[] out, int outOff) {
         for (int i = len; i >= blockSize; i -= blockSize) {
-            embeddedCipher.encryptBlock(in, inOff, out, outOff);
+            embeddedCipher.decryptBlock(in, inOff, out, outOff);
             inOff += blockSize;
             outOff += blockSize;
         }
         return len;
     }
@@ -144,14 +160,8 @@
      */
     int decrypt(byte[] in, int inOff, int len, byte[] out, int outOff) {
         ArrayUtil.blockSizeCheck(len, blockSize);
         ArrayUtil.nullAndBoundsCheck(in, inOff, len);
         ArrayUtil.nullAndBoundsCheck(out, outOff, len);
-
-        for (int i = len; i >= blockSize; i -= blockSize) {
-            embeddedCipher.decryptBlock(in, inOff, out, outOff);
-            inOff += blockSize;
-            outOff += blockSize;
-        }
-        return len;
-    }
+        return implECBDecrypt(in, inOff, len, out, outOff);
+   }
 }

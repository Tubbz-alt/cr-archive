diff a/src/java.base/share/classes/com/sun/security/ntlm/NTLM.java b/src/java.base/share/classes/com/sun/security/ntlm/NTLM.java
--- a/src/java.base/share/classes/com/sun/security/ntlm/NTLM.java
+++ b/src/java.base/share/classes/com/sun/security/ntlm/NTLM.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,11 +27,11 @@
 
 import sun.security.action.GetBooleanAction;
 
 import static com.sun.security.ntlm.Version.*;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
+import java.nio.charset.StandardCharsets;
 import java.security.InvalidKeyException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.spec.InvalidKeySpecException;
 import java.util.Arrays;
@@ -180,17 +180,13 @@
         }
 
         String readSecurityBuffer(int offset, boolean unicode)
                 throws NTLMException {
             byte[] raw = readSecurityBuffer(offset);
-            try {
-                return raw == null ? null : new String(
-                        raw, unicode ? "UnicodeLittleUnmarked" : "ISO8859_1");
-            } catch (UnsupportedEncodingException ex) {
-                throw new NTLMException(NTLMException.PACKET_READ_ERROR,
-                        "Invalid input encoding");
-            }
+            return raw == null ? null : new String(
+                    raw, unicode ? StandardCharsets.UTF_16LE
+                                 : StandardCharsets.ISO_8859_1);
         }
     }
 
     /**
      * Writing an NTLM packet
@@ -245,16 +241,13 @@
                 current += len;
             }
         }
 
         void writeSecurityBuffer(int offset, String str, boolean unicode) {
-            try {
-                writeSecurityBuffer(offset, str == null ? null : str.getBytes(
-                        unicode ? "UnicodeLittleUnmarked" : "ISO8859_1"));
-            } catch (UnsupportedEncodingException ex) {
-                assert false;
-            }
+            writeSecurityBuffer(offset, str == null ? null : str.getBytes(
+                    unicode ? StandardCharsets.UTF_16LE
+                            : StandardCharsets.ISO_8859_1));
         }
 
         byte[] getBytes() {
             return Arrays.copyOf(internal, current);
         }
@@ -378,24 +371,18 @@
         }
         return null;
     }
 
     byte[] calcV2(byte[] nthash, String text, byte[] blob, byte[] challenge) {
-        try {
-            byte[] ntlmv2hash = hmacMD5(nthash,
-                    text.getBytes("UnicodeLittleUnmarked"));
-            byte[] cn = new byte[blob.length+8];
-            System.arraycopy(challenge, 0, cn, 0, 8);
-            System.arraycopy(blob, 0, cn, 8, blob.length);
-            byte[] result = new byte[16+blob.length];
-            System.arraycopy(hmacMD5(ntlmv2hash, cn), 0, result, 0, 16);
-            System.arraycopy(blob, 0, result, 16, blob.length);
-            return result;
-        } catch (UnsupportedEncodingException ex) {
-            assert false;
-        }
-        return null;
+        byte[] ntlmv2hash = hmacMD5(nthash, text.getBytes(StandardCharsets.UTF_16LE));
+        byte[] cn = new byte[blob.length+8];
+        System.arraycopy(challenge, 0, cn, 0, 8);
+        System.arraycopy(blob, 0, cn, 8, blob.length);
+        byte[] result = new byte[16+blob.length];
+        System.arraycopy(hmacMD5(ntlmv2hash, cn), 0, result, 0, 16);
+        System.arraycopy(blob, 0, result, 16, blob.length);
+        return result;
     }
 
     // NTLM2 LM/NTLM
 
     static byte[] ntlm2LM(byte[] nonce) {
@@ -410,21 +397,13 @@
     }
 
     // Password in ASCII and UNICODE
 
     static byte[] getP1(char[] password) {
-        try {
-            return new String(password).toUpperCase(
-                                    Locale.ENGLISH).getBytes("ISO8859_1");
-        } catch (UnsupportedEncodingException ex) {
-            return null;
-        }
+        return new String(password).toUpperCase(Locale.ENGLISH)
+                                   .getBytes(StandardCharsets.ISO_8859_1);
     }
 
     static byte[] getP2(char[] password) {
-        try {
-            return new String(password).getBytes("UnicodeLittleUnmarked");
-        } catch (UnsupportedEncodingException ex) {
-            return null;
-        }
+        return new String(password).getBytes(StandardCharsets.UTF_16LE);
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/crypto/provider/PBES1Core.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PBEKey.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PBES2Parameters.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/PBES1Core.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
251         } finally {
252             if (passwdBytes != null) Arrays.fill(passwdBytes, (byte) 0x00);
253         }
254         // use all but the last 8 bytes as the key value
255         SecretKeySpec cipherKey = new SecretKeySpec(derivedKey, 0,
256                                                     derivedKey.length-8, algo);
257         // use the last 8 bytes as the IV
258         IvParameterSpec ivSpec = new IvParameterSpec(derivedKey,
259                                                      derivedKey.length-8,
260                                                      8);
261         // initialize the underlying cipher
262         cipher.init(opmode, cipherKey, ivSpec, random);
263     }
264 
265     private byte[] deriveCipherKey(byte[] passwdBytes) {
266 
267         byte[] result = null;
268 
269         if (algo.equals(&quot;DES&quot;)) {
270             // P || S (password concatenated with salt)
<span class="line-modified">271             byte[] concat = new byte[Math.addExact(passwdBytes.length, salt.length)];</span>
<span class="line-modified">272             System.arraycopy(passwdBytes, 0, concat, 0, passwdBytes.length);</span>
<span class="line-modified">273             System.arraycopy(salt, 0, concat, passwdBytes.length, salt.length);</span>
<span class="line-modified">274 </span>
<span class="line-modified">275             // digest P || S with c iterations</span>
<span class="line-modified">276             byte[] toBeHashed = concat;</span>
<span class="line-modified">277             for (int i = 0; i &lt; iCount; i++) {</span>
278                 md.update(toBeHashed);
<span class="line-modified">279                 toBeHashed = md.digest(); // this resets the digest</span>




280             }
<span class="line-removed">281             Arrays.fill(concat, (byte)0x00);</span>
282             result = toBeHashed;
283         } else if (algo.equals(&quot;DESede&quot;)) {
284             // if the 2 salt halves are the same, invert one of them
285             int i;
286             for (i=0; i&lt;4; i++) {
287                 if (salt[i] != salt[i+4])
288                     break;
289             }
290             if (i==4) { // same, invert 1st half
291                 for (i=0; i&lt;2; i++) {
292                     byte tmp = salt[i];
293                     salt[i] = salt[3-i];
294                     salt[3-i] = tmp;
295                 }
296             }
297 
298             // Now digest each half (concatenated with password). For each
299             // half, go through the loop as many times as specified by the
300             // iteration count parameter (inner for loop).
301             // Concatenate the output from each digest round with the
302             // password, and use the result as the input to the next digest
303             // operation.
304             byte[] toBeHashed = null;
305             result = new byte[DESedeKeySpec.DES_EDE_KEY_LEN +
306                               DESConstants.DES_BLOCK_SIZE];
307             for (i = 0; i &lt; 2; i++) {
<span class="line-modified">308                 toBeHashed = new byte[salt.length/2];</span>
<span class="line-modified">309                 System.arraycopy(salt, i*(salt.length/2), toBeHashed, 0,</span>
<span class="line-modified">310                                  toBeHashed.length);</span>
<span class="line-modified">311                 for (int j=0; j &lt; iCount; j++) {</span>


312                     md.update(toBeHashed);
313                     md.update(passwdBytes);
<span class="line-modified">314                     toBeHashed = md.digest();</span>




315                 }
316                 System.arraycopy(toBeHashed, 0, result, i*16,
317                                  toBeHashed.length);
318             }
319         }
320         // clear data used in message
321         md.reset();
322         return result;
323     }
324 
325     void init(int opmode, Key key, AlgorithmParameters params,
326               SecureRandom random)
327         throws InvalidKeyException, InvalidAlgorithmParameterException {
328         PBEParameterSpec pbeSpec = null;
329         if (params != null) {
330             try {
331                 pbeSpec = params.getParameterSpec(PBEParameterSpec.class);
332             } catch (InvalidParameterSpecException ipse) {
333                 throw new InvalidAlgorithmParameterException(&quot;Wrong parameter &quot;
334                                                              + &quot;type: PBE &quot;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
251         } finally {
252             if (passwdBytes != null) Arrays.fill(passwdBytes, (byte) 0x00);
253         }
254         // use all but the last 8 bytes as the key value
255         SecretKeySpec cipherKey = new SecretKeySpec(derivedKey, 0,
256                                                     derivedKey.length-8, algo);
257         // use the last 8 bytes as the IV
258         IvParameterSpec ivSpec = new IvParameterSpec(derivedKey,
259                                                      derivedKey.length-8,
260                                                      8);
261         // initialize the underlying cipher
262         cipher.init(opmode, cipherKey, ivSpec, random);
263     }
264 
265     private byte[] deriveCipherKey(byte[] passwdBytes) {
266 
267         byte[] result = null;
268 
269         if (algo.equals(&quot;DES&quot;)) {
270             // P || S (password concatenated with salt)
<span class="line-modified">271             md.update(passwdBytes);</span>
<span class="line-modified">272             md.update(salt);</span>
<span class="line-modified">273             // digest P || S with iCount iterations</span>
<span class="line-modified">274             // first iteration</span>
<span class="line-modified">275             byte[] toBeHashed = md.digest(); // this resets the digest</span>
<span class="line-modified">276             // remaining (iCount - 1) iterations</span>
<span class="line-modified">277             for (int i = 1; i &lt; iCount; ++i) {</span>
278                 md.update(toBeHashed);
<span class="line-modified">279                 try {</span>
<span class="line-added">280                     md.digest(toBeHashed, 0, toBeHashed.length);</span>
<span class="line-added">281                 } catch (DigestException e) {</span>
<span class="line-added">282                     throw new ProviderException(&quot;Internal error&quot;, e);</span>
<span class="line-added">283                 }</span>
284             }

285             result = toBeHashed;
286         } else if (algo.equals(&quot;DESede&quot;)) {
287             // if the 2 salt halves are the same, invert one of them
288             int i;
289             for (i=0; i&lt;4; i++) {
290                 if (salt[i] != salt[i+4])
291                     break;
292             }
293             if (i==4) { // same, invert 1st half
294                 for (i=0; i&lt;2; i++) {
295                     byte tmp = salt[i];
296                     salt[i] = salt[3-i];
297                     salt[3-i] = tmp;
298                 }
299             }
300 
301             // Now digest each half (concatenated with password). For each
302             // half, go through the loop as many times as specified by the
303             // iteration count parameter (inner for loop).
304             // Concatenate the output from each digest round with the
305             // password, and use the result as the input to the next digest
306             // operation.
307             byte[] toBeHashed = null;
308             result = new byte[DESedeKeySpec.DES_EDE_KEY_LEN +
309                               DESConstants.DES_BLOCK_SIZE];
310             for (i = 0; i &lt; 2; i++) {
<span class="line-modified">311                 // first iteration</span>
<span class="line-modified">312                 md.update(salt, i * (salt.length / 2), salt.length / 2);</span>
<span class="line-modified">313                 md.update(passwdBytes);</span>
<span class="line-modified">314                 toBeHashed = md.digest();</span>
<span class="line-added">315                 // remaining (iCount - 1) iterations</span>
<span class="line-added">316                 for (int j = 1; j &lt; iCount; ++j) {</span>
317                     md.update(toBeHashed);
318                     md.update(passwdBytes);
<span class="line-modified">319                     try {</span>
<span class="line-added">320                         md.digest(toBeHashed, 0, toBeHashed.length);</span>
<span class="line-added">321                     } catch (DigestException e) {</span>
<span class="line-added">322                         throw new ProviderException(&quot;Internal error&quot;, e);</span>
<span class="line-added">323                     }</span>
324                 }
325                 System.arraycopy(toBeHashed, 0, result, i*16,
326                                  toBeHashed.length);
327             }
328         }
329         // clear data used in message
330         md.reset();
331         return result;
332     }
333 
334     void init(int opmode, Key key, AlgorithmParameters params,
335               SecureRandom random)
336         throws InvalidKeyException, InvalidAlgorithmParameterException {
337         PBEParameterSpec pbeSpec = null;
338         if (params != null) {
339             try {
340                 pbeSpec = params.getParameterSpec(PBEParameterSpec.class);
341             } catch (InvalidParameterSpecException ipse) {
342                 throw new InvalidAlgorithmParameterException(&quot;Wrong parameter &quot;
343                                                              + &quot;type: PBE &quot;
</pre>
</td>
</tr>
</table>
<center><a href="PBEKey.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PBES2Parameters.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
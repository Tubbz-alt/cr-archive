<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/com/sun/crypto/provider/JceKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import sun.security.util.Debug;
 29 
 30 import java.io.*;
 31 import java.util.*;
 32 import java.security.AccessController;
 33 import java.security.DigestInputStream;
 34 import java.security.DigestOutputStream;
 35 import java.security.MessageDigest;
 36 import java.security.NoSuchAlgorithmException;
 37 import java.security.Key;
 38 import java.security.PrivateKey;
 39 import java.security.PrivilegedAction;
 40 import java.security.KeyStoreSpi;
 41 import java.security.KeyStoreException;
 42 import java.security.UnrecoverableKeyException;
 43 import java.security.cert.Certificate;
 44 import java.security.cert.CertificateFactory;
 45 import java.security.cert.CertificateException;
 46 import javax.crypto.SealedObject;
 47 
 48 /**
 49  * This class provides the keystore implementation referred to as &quot;jceks&quot;.
 50  * This implementation strongly protects the keystore private keys using
 51  * triple-DES, where the triple-DES encryption/decryption key is derived from
 52  * the user&#39;s password.
 53  * The encrypted private keys are stored in the keystore in a standard format,
 54  * namely the &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; format defined in PKCS #8.
 55  *
 56  * @author Jan Luehe
 57  *
 58  *
 59  * @see java.security.KeyStoreSpi
 60  */
 61 
 62 public final class JceKeyStore extends KeyStoreSpi {
 63 
 64     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 65     private static final int JCEKS_MAGIC = 0xcececece;
 66     private static final int JKS_MAGIC = 0xfeedfeed;
 67     private static final int VERSION_1 = 0x01;
 68     private static final int VERSION_2 = 0x02;
 69 
 70     // Private key and supporting certificate chain
 71     private static final class PrivateKeyEntry {
 72         Date date; // the creation date of this entry
 73         byte[] protectedKey;
 74         Certificate chain[];
 75     };
 76 
 77     // Secret key
 78     private static final class SecretKeyEntry {
 79         Date date; // the creation date of this entry
 80         SealedObject sealedKey;
 81     }
 82 
 83     // Trusted certificate
 84     private static final class TrustedCertEntry {
 85         Date date; // the creation date of this entry
 86         Certificate cert;
 87     };
 88 
 89     /**
 90      * Private keys and certificates are stored in a hashtable.
 91      * Hash entries are keyed by alias names.
 92      */
 93     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;String, Object&gt;();
 94 
 95     /**
 96      * Returns the key associated with the given alias, using the given
 97      * password to recover it.
 98      *
 99      * @param alias the alias name
100      * @param password the password for recovering the key
101      *
102      * @return the requested key, or null if the given alias does not exist
103      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
104      *
105      * @exception NoSuchAlgorithmException if the algorithm for recovering the
106      * key cannot be found
107      * @exception UnrecoverableKeyException if the key cannot be recovered
108      * (e.g., the given password is wrong).
109      */
110     public Key engineGetKey(String alias, char[] password)
111         throws NoSuchAlgorithmException, UnrecoverableKeyException
112     {
113         Key key = null;
114 
115         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
116 
117         if (!((entry instanceof PrivateKeyEntry) ||
118               (entry instanceof SecretKeyEntry))) {
119             return null;
120         }
121 
122         KeyProtector keyProtector = new KeyProtector(password);
123 
124         if (entry instanceof PrivateKeyEntry) {
125             byte[] encrBytes = ((PrivateKeyEntry)entry).protectedKey;
126             EncryptedPrivateKeyInfo encrInfo;
127             try {
128                 encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
129             } catch (IOException ioe) {
130                 throw new UnrecoverableKeyException(&quot;Private key not stored &quot;
131                                                     + &quot;as PKCS #8 &quot; +
132                                                     &quot;EncryptedPrivateKeyInfo&quot;);
133             }
134             key = keyProtector.recover(encrInfo);
135         } else {
136             key =
137                 keyProtector.unseal(((SecretKeyEntry)entry).sealedKey);
138         }
139 
140         return key;
141     }
142 
143     /**
144      * Returns the certificate chain associated with the given alias.
145      *
146      * @param alias the alias name
147      *
148      * @return the certificate chain (ordered with the user&#39;s certificate first
149      * and the root certificate authority last), or null if the given alias
150      * does not exist or does not contain a certificate chain (i.e., the given
151      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
152      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
153      */
154     public Certificate[] engineGetCertificateChain(String alias)
155     {
156         Certificate[] chain = null;
157 
158         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
159 
160         if ((entry instanceof PrivateKeyEntry)
161             &amp;&amp; (((PrivateKeyEntry)entry).chain != null)) {
162             chain = ((PrivateKeyEntry)entry).chain.clone();
163         }
164 
165         return chain;
166     }
167 
168     /**
169      * Returns the certificate associated with the given alias.
170      *
171      * &lt;p&gt;If the given alias name identifies a
172      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
173      * entry is returned. If the given alias name identifies a
174      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
175      * entry is returned, or null if that entry does not have a certificate
176      * chain.
177      *
178      * @param alias the alias name
179      *
180      * @return the certificate, or null if the given alias does not exist or
181      * does not contain a certificate.
182      */
183     public Certificate engineGetCertificate(String alias) {
184         Certificate cert = null;
185 
186         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
187 
188         if (entry != null) {
189             if (entry instanceof TrustedCertEntry) {
190                 cert = ((TrustedCertEntry)entry).cert;
191             } else if ((entry instanceof PrivateKeyEntry) &amp;&amp;
192                        (((PrivateKeyEntry)entry).chain != null)) {
193                 cert = ((PrivateKeyEntry)entry).chain[0];
194             }
195         }
196 
197         return cert;
198     }
199 
200     /**
201      * Returns the creation date of the entry identified by the given alias.
202      *
203      * @param alias the alias name
204      *
205      * @return the creation date of this entry, or null if the given alias does
206      * not exist
207      */
208     public Date engineGetCreationDate(String alias) {
209         Date date = null;
210 
211         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
212 
213         if (entry != null) {
214             // We have to create a new instance of java.util.Date because
215             // dates are not immutable
216             if (entry instanceof TrustedCertEntry) {
217                 date = new Date(((TrustedCertEntry)entry).date.getTime());
218             } else if (entry instanceof PrivateKeyEntry) {
219                 date = new Date(((PrivateKeyEntry)entry).date.getTime());
220             } else {
221                 date = new Date(((SecretKeyEntry)entry).date.getTime());
222             }
223         }
224 
225         return date;
226     }
227 
228     /**
229      * Assigns the given key to the given alias, protecting it with the given
230      * password.
231      *
232      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
233      * it must be accompanied by a certificate chain certifying the
234      * corresponding public key.
235      *
236      * &lt;p&gt;If the given alias already exists, the keystore information
237      * associated with it is overridden by the given key (and possibly
238      * certificate chain).
239      *
240      * @param alias the alias name
241      * @param key the key to be associated with the alias
242      * @param password the password to protect the key
243      * @param chain the certificate chain for the corresponding public
244      * key (only required if the given key is of type
245      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
246      *
247      * @exception KeyStoreException if the given key cannot be protected, or
248      * this operation fails for some other reason
249      */
250     public void engineSetKeyEntry(String alias, Key key, char[] password,
251                                   Certificate[] chain)
252         throws KeyStoreException
253     {
254         synchronized(entries) {
255             try {
256                 KeyProtector keyProtector = new KeyProtector(password);
257 
258                 if (key instanceof PrivateKey) {
259                     PrivateKeyEntry entry = new PrivateKeyEntry();
260                     entry.date = new Date();
261 
262                     // protect the private key
263                     entry.protectedKey = keyProtector.protect((PrivateKey)key);
264 
265                     // clone the chain
266                     if ((chain != null) &amp;&amp;
267                         (chain.length !=0)) {
268                         entry.chain = chain.clone();
269                     } else {
270                         entry.chain = null;
271                     }
272 
273                     // store the entry
274                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
275 
276                 } else {
277                     SecretKeyEntry entry = new SecretKeyEntry();
278                     entry.date = new Date();
279 
280                     // seal and store the key
281                     entry.sealedKey = keyProtector.seal(key);
282                     entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
283                 }
284 
285             } catch (Exception e) {
286                 throw new KeyStoreException(e.getMessage());
287             }
288         }
289     }
290 
291     /**
292      * Assigns the given key (that has already been protected) to the given
293      * alias.
294      *
295      * &lt;p&gt;If the protected key is of type
296      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
297      * it must be accompanied by a certificate chain certifying the
298      * corresponding public key.
299      *
300      * &lt;p&gt;If the given alias already exists, the keystore information
301      * associated with it is overridden by the given key (and possibly
302      * certificate chain).
303      *
304      * @param alias the alias name
305      * @param key the key (in protected format) to be associated with the alias
306      * @param chain the certificate chain for the corresponding public
307      * key (only useful if the protected key is of type
308      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
309      *
310      * @exception KeyStoreException if this operation fails.
311      */
312     public void engineSetKeyEntry(String alias, byte[] key,
313                                   Certificate[] chain)
314         throws KeyStoreException
315     {
316         synchronized(entries) {
317             // We assume it&#39;s a private key, because there is no standard
318             // (ASN.1) encoding format for wrapped secret keys
319             PrivateKeyEntry entry = new PrivateKeyEntry();
320             entry.date = new Date();
321 
322             entry.protectedKey = key.clone();
323             if ((chain != null) &amp;&amp;
324                 (chain.length != 0)) {
325                 entry.chain = chain.clone();
326             } else {
327                 entry.chain = null;
328             }
329 
330             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
331         }
332     }
333 
334     /**
335      * Assigns the given certificate to the given alias.
336      *
337      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
338      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
339      * overridden by the given certificate.
340      *
341      * @param alias the alias name
342      * @param cert the certificate
343      *
344      * @exception KeyStoreException if the given alias already exists and does
345      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
346      * fails for some other reason.
347      */
348     public void engineSetCertificateEntry(String alias, Certificate cert)
349         throws KeyStoreException
350     {
351         synchronized(entries) {
352 
353             Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
354             if (entry != null) {
355                 if (entry instanceof PrivateKeyEntry) {
356                     throw new KeyStoreException(&quot;Cannot overwrite own &quot;
357                                                 + &quot;certificate&quot;);
358                 } else if (entry instanceof SecretKeyEntry) {
359                     throw new KeyStoreException(&quot;Cannot overwrite secret key&quot;);
360                 }
361             }
362 
363             TrustedCertEntry trustedCertEntry = new TrustedCertEntry();
364             trustedCertEntry.cert = cert;
365             trustedCertEntry.date = new Date();
366             entries.put(alias.toLowerCase(Locale.ENGLISH), trustedCertEntry);
367         }
368     }
369 
370     /**
371      * Deletes the entry identified by the given alias from this keystore.
372      *
373      * @param alias the alias name
374      *
375      * @exception KeyStoreException if the entry cannot be removed.
376      */
377     public void engineDeleteEntry(String alias)
378         throws KeyStoreException
379     {
380         synchronized(entries) {
381             entries.remove(alias.toLowerCase(Locale.ENGLISH));
382         }
383     }
384 
385     /**
386      * Lists all the alias names of this keystore.
387      *
388      * @return enumeration of the alias names
389      */
390     public Enumeration&lt;String&gt; engineAliases() {
391         return entries.keys();
392     }
393 
394     /**
395      * Checks if the given alias exists in this keystore.
396      *
397      * @param alias the alias name
398      *
399      * @return true if the alias exists, false otherwise
400      */
401     public boolean engineContainsAlias(String alias) {
402         return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));
403     }
404 
405     /**
406      * Retrieves the number of entries in this keystore.
407      *
408      * @return the number of entries in this keystore
409      */
410     public int engineSize() {
411         return entries.size();
412     }
413 
414     /**
415      * Returns true if the entry identified by the given alias is a
416      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
417      *
418      * @return true if the entry identified by the given alias is a
419      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
420      */
421     public boolean engineIsKeyEntry(String alias) {
422         boolean isKey = false;
423 
424         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
425         if ((entry instanceof PrivateKeyEntry)
426             || (entry instanceof SecretKeyEntry)) {
427             isKey = true;
428         }
429 
430         return isKey;
431     }
432 
433     /**
434      * Returns true if the entry identified by the given alias is a
435      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
436      *
437      * @return true if the entry identified by the given alias is a
438      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
439      */
440     public boolean engineIsCertificateEntry(String alias) {
441         boolean isCert = false;
442         Object entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
443         if (entry instanceof TrustedCertEntry) {
444             isCert = true;
445         }
446         return isCert;
447     }
448 
449     /**
450      * Returns the (alias) name of the first keystore entry whose certificate
451      * matches the given certificate.
452      *
453      * &lt;p&gt;This method attempts to match the given certificate with each
454      * keystore entry. If the entry being considered
455      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
456      * compared to that entry&#39;s certificate. If the entry being considered is
457      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
458      * element of that entry&#39;s certificate chain (if a chain exists).
459      *
460      * @param cert the certificate to match with.
461      *
462      * @return the (alias) name of the first entry with matching certificate,
463      * or null if no such entry exists in this keystore.
464      */
465     public String engineGetCertificateAlias(Certificate cert) {
466         Certificate certElem;
467 
468         Enumeration&lt;String&gt; e = entries.keys();
469         while (e.hasMoreElements()) {
470             String alias = e.nextElement();
471             Object entry = entries.get(alias);
472             if (entry instanceof TrustedCertEntry) {
473                 certElem = ((TrustedCertEntry)entry).cert;
474             } else if ((entry instanceof PrivateKeyEntry) &amp;&amp;
475                        (((PrivateKeyEntry)entry).chain != null)) {
476                 certElem = ((PrivateKeyEntry)entry).chain[0];
477             } else {
478                 continue;
479             }
480             if (certElem.equals(cert)) {
481                 return alias;
482             }
483         }
484         return null;
485     }
486 
487     /**
488      * Stores this keystore to the given output stream, and protects its
489      * integrity with the given password.
490      *
491      * @param stream the output stream to which this keystore is written.
492      * @param password the password to generate the keystore integrity check
493      *
494      * @exception IOException if there was an I/O problem with data
495      * @exception NoSuchAlgorithmException if the appropriate data integrity
496      * algorithm could not be found
497      * @exception CertificateException if any of the certificates included in
498      * the keystore data could not be stored
499      */
500     public void engineStore(OutputStream stream, char[] password)
501         throws IOException, NoSuchAlgorithmException, CertificateException
502     {
503         synchronized(entries) {
504             /*
505              * KEYSTORE FORMAT:
506              *
507              * Magic number (big-endian integer),
508              * Version of this file format (big-endian integer),
509              *
510              * Count (big-endian integer),
511              * followed by &quot;count&quot; instances of either:
512              *
513              *     {
514              *      tag=1 (big-endian integer)
515              *      alias (UTF string)
516              *      timestamp
517              *      encrypted private-key info according to PKCS #8
518              *          (integer length followed by encoding)
519              *      cert chain (integer count followed by certs;
520              *          for each cert: type UTF string, followed by integer
521              *              length, followed by encoding)
522              *     }
523              *
524              * or:
525              *
526              *     {
527              *      tag=2 (big-endian integer)
528              *      alias (UTF string)
529              *      timestamp
530              *      cert (type UTF string, followed by integer length,
531              *          followed by encoding)
532              *     }
533              *
534              * or:
535              *
536              *     {
537              *      tag=3 (big-endian integer)
538              *      alias (UTF string)
539              *      timestamp
540              *      sealed secret key (in serialized form)
541              *     }
542              *
543              * ended by a keyed SHA1 hash (bytes only) of
544              *     { password + whitener + preceding body }
545              */
546 
547             // password is mandatory when storing
548             if (password == null) {
549                 throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
550             }
551 
552             byte[] encoded; // the certificate encoding
553 
554             MessageDigest md = getPreKeyedHash(password);
555             DataOutputStream dos
556                 = new DataOutputStream(new DigestOutputStream(stream, md));
557             // NOTE: don&#39;t pass dos to oos at this point or it&#39;ll corrupt
558             // the keystore!!!
559             ObjectOutputStream oos = null;
560             try {
561                 dos.writeInt(JCEKS_MAGIC);
562                 dos.writeInt(VERSION_2); // always write the latest version
563 
564                 dos.writeInt(entries.size());
565 
566                 Enumeration&lt;String&gt; e = entries.keys();
567                 while (e.hasMoreElements()) {
568 
569                     String alias = e.nextElement();
570                     Object entry = entries.get(alias);
571 
572                     if (entry instanceof PrivateKeyEntry) {
573 
574                         PrivateKeyEntry pentry = (PrivateKeyEntry)entry;
575 
576                         // write PrivateKeyEntry tag
577                         dos.writeInt(1);
578 
579                         // write the alias
580                         dos.writeUTF(alias);
581 
582                         // write the (entry creation) date
583                         dos.writeLong(pentry.date.getTime());
584 
585                         // write the protected private key
586                         dos.writeInt(pentry.protectedKey.length);
587                         dos.write(pentry.protectedKey);
588 
589                         // write the certificate chain
590                         int chainLen;
591                         if (pentry.chain == null) {
592                             chainLen = 0;
593                         } else {
594                             chainLen = pentry.chain.length;
595                         }
596                         dos.writeInt(chainLen);
597                         for (int i = 0; i &lt; chainLen; i++) {
598                             encoded = pentry.chain[i].getEncoded();
599                             dos.writeUTF(pentry.chain[i].getType());
600                             dos.writeInt(encoded.length);
601                             dos.write(encoded);
602                         }
603 
604                     } else if (entry instanceof TrustedCertEntry) {
605 
606                         // write TrustedCertEntry tag
607                         dos.writeInt(2);
608 
609                         // write the alias
610                         dos.writeUTF(alias);
611 
612                         // write the (entry creation) date
613                         dos.writeLong(((TrustedCertEntry)entry).date.getTime());
614 
615                         // write the trusted certificate
616                         encoded = ((TrustedCertEntry)entry).cert.getEncoded();
617                         dos.writeUTF(((TrustedCertEntry)entry).cert.getType());
618                         dos.writeInt(encoded.length);
619                         dos.write(encoded);
620 
621                     } else {
622 
623                         // write SecretKeyEntry tag
624                         dos.writeInt(3);
625 
626                         // write the alias
627                         dos.writeUTF(alias);
628 
629                         // write the (entry creation) date
630                         dos.writeLong(((SecretKeyEntry)entry).date.getTime());
631 
632                         // write the sealed key
633                         oos = new ObjectOutputStream(dos);
634                         oos.writeObject(((SecretKeyEntry)entry).sealedKey);
635                         // NOTE: don&#39;t close oos here since we are still
636                         // using dos!!!
637                     }
638                 }
639 
640                 /*
641                  * Write the keyed hash which is used to detect tampering with
642                  * the keystore (such as deleting or modifying key or
643                  * certificate entries).
644                  */
645                 byte digest[] = md.digest();
646 
647                 dos.write(digest);
648                 dos.flush();
649             } finally {
650                 if (oos != null) {
651                     oos.close();
652                 } else {
653                     dos.close();
654                 }
655             }
656         }
657     }
658 
659     /**
660      * Loads the keystore from the given input stream.
661      *
662      * &lt;p&gt;If a password is given, it is used to check the integrity of the
663      * keystore data. Otherwise, the integrity of the keystore is not checked.
664      *
665      * @param stream the input stream from which the keystore is loaded
666      * @param password the (optional) password used to check the integrity of
667      * the keystore.
668      *
669      * @exception IOException if there is an I/O or format problem with the
670      * keystore data
671      * @exception NoSuchAlgorithmException if the algorithm used to check
672      * the integrity of the keystore cannot be found
673      * @exception CertificateException if any of the certificates in the
674      * keystore could not be loaded
675      */
676     public void engineLoad(InputStream stream, char[] password)
677         throws IOException, NoSuchAlgorithmException, CertificateException
678     {
679         synchronized(entries) {
680             DataInputStream dis;
681             MessageDigest md = null;
682             CertificateFactory cf = null;
683             Hashtable&lt;String, CertificateFactory&gt; cfs = null;
684             ByteArrayInputStream bais = null;
685             byte[] encoded = null;
686             int trustedKeyCount = 0, privateKeyCount = 0, secretKeyCount = 0;
687 
688             if (stream == null)
689                 return;
690 
691             if (password != null) {
692                 md = getPreKeyedHash(password);
693                 dis = new DataInputStream(new DigestInputStream(stream, md));
694             } else {
695                 dis = new DataInputStream(stream);
696             }
697             // NOTE: don&#39;t pass dis to ois at this point or it&#39;ll fail to load
698             // the keystore!!!
699             ObjectInputStream ois = null;
700 
701             try {
702                 // Body format: see store method
703 
704                 int xMagic = dis.readInt();
705                 int xVersion = dis.readInt();
706 
707                 // Accept the following keystore implementations:
708                 // - JCEKS (this implementation), versions 1 and 2
709                 // - JKS (Sun&#39;s keystore implementation in JDK 1.2),
710                 //   versions 1 and 2
711                 if (((xMagic != JCEKS_MAGIC) &amp;&amp; (xMagic != JKS_MAGIC)) ||
712                     ((xVersion != VERSION_1) &amp;&amp; (xVersion != VERSION_2))) {
713                     throw new IOException(&quot;Invalid keystore format&quot;);
714                 }
715 
716                 if (xVersion == VERSION_1) {
717                     cf = CertificateFactory.getInstance(&quot;X509&quot;);
718                 } else {
719                     // version 2
720                     cfs = new Hashtable&lt;&gt;(3);
721                 }
722 
723                 entries.clear();
724                 int count = dis.readInt();
725 
726                 for (int i = 0; i &lt; count; i++) {
727                     int tag;
728                     String alias;
729 
730                     tag = dis.readInt();
731 
732                     if (tag == 1) { // private-key entry
733                         privateKeyCount++;
734                         PrivateKeyEntry entry = new PrivateKeyEntry();
735 
736                         // read the alias
737                         alias = dis.readUTF();
738 
739                         // read the (entry creation) date
740                         entry.date = new Date(dis.readLong());
741 
742                         // read the private key
743                         try {
744                             entry.protectedKey = new byte[dis.readInt()];
745                         } catch (OutOfMemoryError e) {
746                             throw new IOException(&quot;Keysize too big&quot;);
747                         }
748                         dis.readFully(entry.protectedKey);
749 
750                         // read the certificate chain
751                         int numOfCerts = dis.readInt();
752                         try {
753                             if (numOfCerts &gt; 0) {
754                                 entry.chain = new Certificate[numOfCerts];
755                             }
756                         } catch (OutOfMemoryError e) {
757                             throw new IOException(&quot;Too many certificates in &quot;
758                                                   + &quot;chain&quot;);
759                         }
760                         for (int j = 0; j &lt; numOfCerts; j++) {
761                             if (xVersion == 2) {
762                                 // read the certificate type, and instantiate a
763                                 // certificate factory of that type (reuse
764                                 // existing factory if possible)
765                                 String certType = dis.readUTF();
766                                 if (cfs.containsKey(certType)) {
767                                 // reuse certificate factory
768                                     cf = cfs.get(certType);
769                                 } else {
770                                 // create new certificate factory
771                                     cf = CertificateFactory.getInstance(
772                                         certType);
773                                 // store the certificate factory so we can
774                                 // reuse it later
775                                     cfs.put(certType, cf);
776                                 }
777                             }
778                             // instantiate the certificate
779                             try {
780                                 encoded = new byte[dis.readInt()];
781                             } catch (OutOfMemoryError e) {
782                                 throw new IOException(&quot;Certificate too big&quot;);
783                             }
784                             dis.readFully(encoded);
785                             bais = new ByteArrayInputStream(encoded);
786                             entry.chain[j] = cf.generateCertificate(bais);
787                         }
788 
789                         // Add the entry to the list
790                         entries.put(alias, entry);
791 
792                     } else if (tag == 2) { // trusted certificate entry
793                         trustedKeyCount++;
794                         TrustedCertEntry entry = new TrustedCertEntry();
795 
796                         // read the alias
797                         alias = dis.readUTF();
798 
799                         // read the (entry creation) date
800                         entry.date = new Date(dis.readLong());
801 
802                         // read the trusted certificate
803                         if (xVersion == 2) {
804                             // read the certificate type, and instantiate a
805                             // certificate factory of that type (reuse
806                             // existing factory if possible)
807                             String certType = dis.readUTF();
808                             if (cfs.containsKey(certType)) {
809                                 // reuse certificate factory
810                                 cf = cfs.get(certType);
811                             } else {
812                                 // create new certificate factory
813                                 cf = CertificateFactory.getInstance(certType);
814                                 // store the certificate factory so we can
815                                 // reuse it later
816                                 cfs.put(certType, cf);
817                             }
818                         }
819                         try {
820                             encoded = new byte[dis.readInt()];
821                         } catch (OutOfMemoryError e) {
822                             throw new IOException(&quot;Certificate too big&quot;);
823                         }
824                         dis.readFully(encoded);
825                         bais = new ByteArrayInputStream(encoded);
826                         entry.cert = cf.generateCertificate(bais);
827 
828                         // Add the entry to the list
829                         entries.put(alias, entry);
830 
831                     } else if (tag == 3) { // secret-key entry
832                         secretKeyCount++;
833                         SecretKeyEntry entry = new SecretKeyEntry();
834 
835                         // read the alias
836                         alias = dis.readUTF();
837 
838                         // read the (entry creation) date
839                         entry.date = new Date(dis.readLong());
840 
841                         // read the sealed key
842                         try {
843                             ois = new ObjectInputStream(dis);
844                             final ObjectInputStream ois2 = ois;
845                             // Set a deserialization checker
846                             AccessController.doPrivileged(
847                                 (PrivilegedAction&lt;Void&gt;)() -&gt; {
848                                     ois2.setObjectInputFilter(
849                                         new DeserializationChecker());
850                                     return null;
851                             });
852                             entry.sealedKey = (SealedObject)ois.readObject();
853                             // NOTE: don&#39;t close ois here since we are still
854                             // using dis!!!
855                         } catch (ClassNotFoundException cnfe) {
856                             throw new IOException(cnfe.getMessage());
857                         } catch (InvalidClassException ice) {
858                             throw new IOException(&quot;Invalid secret key format&quot;);
859                         }
860 
861                         // Add the entry to the list
862                         entries.put(alias, entry);
863 
864                     } else {
865                         throw new IOException(&quot;Unrecognized keystore entry: &quot; +
866                                 tag);
867                     }
868                 }
869 
870                 if (debug != null) {
871                     debug.println(&quot;JceKeyStore load: private key count: &quot; +
872                         privateKeyCount + &quot;. trusted key count: &quot; +
873                         trustedKeyCount + &quot;. secret key count: &quot; +
874                         secretKeyCount);
875                 }
876 
877                 /*
878                  * If a password has been provided, we check the keyed digest
879                  * at the end. If this check fails, the store has been tampered
880                  * with
881                  */
882                 if (password != null) {
883                     byte computed[], actual[];
884                     computed = md.digest();
885                     actual = new byte[computed.length];
886                     dis.readFully(actual);
887                     for (int i = 0; i &lt; computed.length; i++) {
888                         if (computed[i] != actual[i]) {
889                             throw new IOException(
890                                 &quot;Keystore was tampered with, or &quot;
891                                         + &quot;password was incorrect&quot;,
892                                     new UnrecoverableKeyException(
893                                             &quot;Password verification failed&quot;));
894                         }
895                     }
896                 }
897             }  finally {
898                 if (ois != null) {
899                     ois.close();
900                 } else {
901                     dis.close();
902                 }
903             }
904         }
905     }
906 
907     /**
908      * To guard against tampering with the keystore, we append a keyed
909      * hash with a bit of whitener.
910      */
911     private MessageDigest getPreKeyedHash(char[] password)
912     throws NoSuchAlgorithmException, UnsupportedEncodingException {
913         int i, j;
914 
915         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
916         byte[] passwdBytes = new byte[password.length * 2];
917         for (i=0, j=0; i&lt;password.length; i++) {
918             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
919             passwdBytes[j++] = (byte)password[i];
920         }
921         md.update(passwdBytes);
922         for (i=0; i&lt;passwdBytes.length; i++)
923             passwdBytes[i] = 0;
924         md.update(&quot;Mighty Aphrodite&quot;.getBytes(&quot;UTF8&quot;));
925         return md;
926     }
927 
928     /**
929      * Probe the first few bytes of the keystore data stream for a valid
930      * JCEKS keystore encoding.
931      */
932     @Override
933     public boolean engineProbe(InputStream stream) throws IOException {
934         DataInputStream dataStream;
935         if (stream instanceof DataInputStream) {
936             dataStream = (DataInputStream)stream;
937         } else {
938             dataStream = new DataInputStream(stream);
939         }
940 
941         return JCEKS_MAGIC == dataStream.readInt();
942     }
943 
944     /*
945      * An ObjectInputFilter that checks the format of the secret key being
946      * deserialized.
947      */
948     private static class DeserializationChecker implements ObjectInputFilter {
949         private static final int MAX_NESTED_DEPTH = 2;
950 
951         @Override
952         public ObjectInputFilter.Status
953             checkInput(ObjectInputFilter.FilterInfo info) {
954 
955             // First run a custom filter
956             long nestedDepth = info.depth();
957             if ((nestedDepth == 1 &amp;&amp;
958                         info.serialClass() != SealedObjectForKeyProtector.class) ||
959                     (nestedDepth &gt; MAX_NESTED_DEPTH &amp;&amp;
960                         info.serialClass() != null &amp;&amp;
961                         info.serialClass() != Object.class)) {
962                 return Status.REJECTED;
963             }
964 
965             // Next run the default filter, if available
966             ObjectInputFilter defaultFilter =
967                 ObjectInputFilter.Config.getSerialFilter();
968             if (defaultFilter != null) {
969                 return defaultFilter.checkInput(info);
970             }
971 
972             return Status.UNDECIDED;
973         }
974     }
975 }
    </pre>
  </body>
</html>
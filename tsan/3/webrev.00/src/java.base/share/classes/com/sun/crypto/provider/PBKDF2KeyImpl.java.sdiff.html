<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/com/sun/crypto/provider/PBKDF2KeyImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PBEWithMD5AndTripleDESCipher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RSACipher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/com/sun/crypto/provider/PBKDF2KeyImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.io.ObjectStreamException;
 29 import java.lang.ref.Reference;
 30 import java.nio.ByteBuffer;
 31 import java.nio.CharBuffer;
<span class="line-removed"> 32 import java.nio.charset.Charset;</span>
 33 import java.util.Arrays;
 34 import java.util.Locale;
 35 import java.security.MessageDigest;
 36 import java.security.KeyRep;
 37 import java.security.GeneralSecurityException;
 38 import java.security.NoSuchAlgorithmException;
 39 import java.security.spec.InvalidKeySpecException;
 40 import javax.crypto.Mac;
 41 import javax.crypto.SecretKey;
 42 import javax.crypto.spec.PBEKeySpec;
 43 


 44 import jdk.internal.ref.CleanerFactory;
 45 
 46 /**
 47  * This class represents a PBE key derived using PBKDF2 defined
 48  * in PKCS#5 v2.0. meaning that
 49  * 1) the password must consist of characters which will be converted
 50  *    to bytes using UTF-8 character encoding.
 51  * 2) salt, iteration count, and to be derived key length are supplied
 52  *
 53  * @author Valerie Peng
 54  *
 55  */
 56 final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {
 57 

 58     static final long serialVersionUID = -2234868909660948157L;
 59 
 60     private char[] passwd;
 61     private byte[] salt;
 62     private int iterCount;
 63     private byte[] key;
 64 
 65     private Mac prf;
 66 
 67     private static byte[] getPasswordBytes(char[] passwd) {
<span class="line-removed"> 68         Charset utf8 = Charset.forName(&quot;UTF-8&quot;);</span>
 69         CharBuffer cb = CharBuffer.wrap(passwd);
<span class="line-modified"> 70         ByteBuffer bb = utf8.encode(cb);</span>
 71 
 72         int len = bb.limit();
 73         byte[] passwdBytes = new byte[len];
 74         bb.get(passwdBytes, 0, len);
 75 
 76         return passwdBytes;
 77     }
 78 
 79     /**
 80      * Creates a PBE key from a given PBE key specification.
 81      *
 82      * @param keySpec the given PBE key specification
 83      * @param prfAlgo the given PBE key algorithm
 84      */
 85     PBKDF2KeyImpl(PBEKeySpec keySpec, String prfAlgo)
 86         throws InvalidKeySpecException {
 87         char[] passwd = keySpec.getPassword();
 88         if (passwd == null) {
 89             // Should allow an empty password.
 90             this.passwd = new char[0];
</pre>
<hr />
<pre>
 96         // remove local copy
 97         if (passwd != null) Arrays.fill(passwd, &#39;\0&#39;);
 98 
 99         try {
100             this.salt = keySpec.getSalt();
101             if (salt == null) {
102                 throw new InvalidKeySpecException(&quot;Salt not found&quot;);
103             }
104             this.iterCount = keySpec.getIterationCount();
105             if (iterCount == 0) {
106                 throw new InvalidKeySpecException(&quot;Iteration count not found&quot;);
107             } else if (iterCount &lt; 0) {
108                 throw new InvalidKeySpecException(&quot;Iteration count is negative&quot;);
109             }
110             int keyLength = keySpec.getKeyLength();
111             if (keyLength == 0) {
112                 throw new InvalidKeySpecException(&quot;Key length not found&quot;);
113             } else if (keyLength &lt; 0) {
114                 throw new InvalidKeySpecException(&quot;Key length is negative&quot;);
115             }
<span class="line-modified">116             this.prf = Mac.getInstance(prfAlgo);</span>
<span class="line-removed">117             // SunPKCS11 requires a non-empty PBE password</span>
<span class="line-removed">118             if (passwdBytes.length == 0 &amp;&amp;</span>
<span class="line-removed">119                     this.prf.getProvider().getName().startsWith(&quot;SunPKCS11&quot;)) {</span>
<span class="line-removed">120                 this.prf = Mac.getInstance(prfAlgo, SunJCE.getInstance());</span>
<span class="line-removed">121             }</span>
122             this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);
123         } catch (NoSuchAlgorithmException nsae) {
124             // not gonna happen; re-throw just in case
125             InvalidKeySpecException ike = new InvalidKeySpecException();
126             ike.initCause(nsae);
127             throw ike;
128         } finally {
129             Arrays.fill(passwdBytes, (byte) 0x00);
130 
131             // Use the cleaner to zero the key when no longer referenced
132             final byte[] k = this.key;
133             final char[] p = this.passwd;
134             CleanerFactory.cleaner().register(this,
135                     () -&gt; {
136                         Arrays.fill(k, (byte) 0x00);
137                         Arrays.fill(p, &#39;\0&#39;);
138                     });
139         }
140     }
141 
142     private static byte[] deriveKey(final Mac prf, final byte[] password,
143             byte[] salt, int iterCount, int keyLengthInBit) {
144         int keyLength = keyLengthInBit/8;
145         byte[] key = new byte[keyLength];
146         try {
147             int hlen = prf.getMacLength();
148             int intL = (keyLength + hlen - 1)/hlen; // ceiling
149             int intR = keyLength - (intL - 1)*hlen; // residue
150             byte[] ui = new byte[hlen];
151             byte[] ti = new byte[hlen];
152             // SecretKeySpec cannot be used, since password can be empty here.
153             SecretKey macKey = new SecretKey() {

154                 private static final long serialVersionUID = 7874493593505141603L;
155                 @Override
156                 public String getAlgorithm() {
157                     return prf.getAlgorithm();
158                 }
159                 @Override
160                 public String getFormat() {
161                     return &quot;RAW&quot;;
162                 }
163                 @Override
164                 public byte[] getEncoded() {
165                     return password;
166                 }
167                 @Override
168                 public int hashCode() {
169                     return Arrays.hashCode(password) * 41 +
170                       prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();
171                 }
172                 @Override
173                 public boolean equals(Object obj) {
</pre>
<hr />
<pre>
190                 ibytes[0] = (byte) ((i &gt;&gt; 24) &amp; 0xff);
191                 prf.update(ibytes);
192                 prf.doFinal(ui, 0);
193                 System.arraycopy(ui, 0, ti, 0, ui.length);
194 
195                 for (int j = 2; j &lt;= iterCount; j++) {
196                     prf.update(ui);
197                     prf.doFinal(ui, 0);
198                     // XOR the intermediate Ui&#39;s together.
199                     for (int k = 0; k &lt; ui.length; k++) {
200                         ti[k] ^= ui[k];
201                     }
202                 }
203                 if (i == intL) {
204                     System.arraycopy(ti, 0, key, (i-1)*hlen, intR);
205                 } else {
206                     System.arraycopy(ti, 0, key, (i-1)*hlen, hlen);
207                 }
208             }
209         } catch (GeneralSecurityException gse) {
<span class="line-modified">210             throw new RuntimeException(&quot;Error deriving PBKDF2 keys&quot;);</span>
211         }
212         return key;
213     }
214 
215     public byte[] getEncoded() {
216         // The key is zeroized by finalize()
217         // The reachability fence ensures finalize() isn&#39;t called early
218         byte[] result = key.clone();
219         Reference.reachabilityFence(this);
220         return result;
221     }
222 
223     public String getAlgorithm() {
224         return &quot;PBKDF2With&quot; + prf.getAlgorithm();
225     }
226 
227     public int getIterationCount() {
228         return iterCount;
229     }
230 
</pre>
<hr />
<pre>
266         SecretKey that = (SecretKey) obj;
267 
268         if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm())))
269             return false;
270         if (!(that.getFormat().equalsIgnoreCase(&quot;RAW&quot;)))
271             return false;
272         byte[] thatEncoded = that.getEncoded();
273         boolean ret = MessageDigest.isEqual(key, thatEncoded);
274         Arrays.fill(thatEncoded, (byte)0x00);
275         return ret;
276     }
277 
278     /**
279      * Replace the PBE key to be serialized.
280      *
281      * @return the standard KeyRep object to be serialized
282      *
283      * @throws ObjectStreamException if a new object representing
284      * this PBE key could not be created
285      */

286     private Object writeReplace() throws ObjectStreamException {
287             return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),
288                               getFormat(), getEncoded());
289     }
290 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.io.ObjectStreamException;
 29 import java.lang.ref.Reference;
 30 import java.nio.ByteBuffer;
 31 import java.nio.CharBuffer;

 32 import java.util.Arrays;
 33 import java.util.Locale;
 34 import java.security.MessageDigest;
 35 import java.security.KeyRep;
 36 import java.security.GeneralSecurityException;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.spec.InvalidKeySpecException;
 39 import javax.crypto.Mac;
 40 import javax.crypto.SecretKey;
 41 import javax.crypto.spec.PBEKeySpec;
 42 
<span class="line-added"> 43 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 44 </span>
 45 import jdk.internal.ref.CleanerFactory;
 46 
 47 /**
 48  * This class represents a PBE key derived using PBKDF2 defined
 49  * in PKCS#5 v2.0. meaning that
 50  * 1) the password must consist of characters which will be converted
 51  *    to bytes using UTF-8 character encoding.
 52  * 2) salt, iteration count, and to be derived key length are supplied
 53  *
 54  * @author Valerie Peng
 55  *
 56  */
 57 final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {
 58 
<span class="line-added"> 59     @java.io.Serial</span>
 60     static final long serialVersionUID = -2234868909660948157L;
 61 
 62     private char[] passwd;
 63     private byte[] salt;
 64     private int iterCount;
 65     private byte[] key;
 66 
 67     private Mac prf;
 68 
 69     private static byte[] getPasswordBytes(char[] passwd) {

 70         CharBuffer cb = CharBuffer.wrap(passwd);
<span class="line-modified"> 71         ByteBuffer bb = UTF_8.encode(cb);</span>
 72 
 73         int len = bb.limit();
 74         byte[] passwdBytes = new byte[len];
 75         bb.get(passwdBytes, 0, len);
 76 
 77         return passwdBytes;
 78     }
 79 
 80     /**
 81      * Creates a PBE key from a given PBE key specification.
 82      *
 83      * @param keySpec the given PBE key specification
 84      * @param prfAlgo the given PBE key algorithm
 85      */
 86     PBKDF2KeyImpl(PBEKeySpec keySpec, String prfAlgo)
 87         throws InvalidKeySpecException {
 88         char[] passwd = keySpec.getPassword();
 89         if (passwd == null) {
 90             // Should allow an empty password.
 91             this.passwd = new char[0];
</pre>
<hr />
<pre>
 97         // remove local copy
 98         if (passwd != null) Arrays.fill(passwd, &#39;\0&#39;);
 99 
100         try {
101             this.salt = keySpec.getSalt();
102             if (salt == null) {
103                 throw new InvalidKeySpecException(&quot;Salt not found&quot;);
104             }
105             this.iterCount = keySpec.getIterationCount();
106             if (iterCount == 0) {
107                 throw new InvalidKeySpecException(&quot;Iteration count not found&quot;);
108             } else if (iterCount &lt; 0) {
109                 throw new InvalidKeySpecException(&quot;Iteration count is negative&quot;);
110             }
111             int keyLength = keySpec.getKeyLength();
112             if (keyLength == 0) {
113                 throw new InvalidKeySpecException(&quot;Key length not found&quot;);
114             } else if (keyLength &lt; 0) {
115                 throw new InvalidKeySpecException(&quot;Key length is negative&quot;);
116             }
<span class="line-modified">117             this.prf = Mac.getInstance(prfAlgo, SunJCE.getInstance());</span>





118             this.key = deriveKey(prf, passwdBytes, salt, iterCount, keyLength);
119         } catch (NoSuchAlgorithmException nsae) {
120             // not gonna happen; re-throw just in case
121             InvalidKeySpecException ike = new InvalidKeySpecException();
122             ike.initCause(nsae);
123             throw ike;
124         } finally {
125             Arrays.fill(passwdBytes, (byte) 0x00);
126 
127             // Use the cleaner to zero the key when no longer referenced
128             final byte[] k = this.key;
129             final char[] p = this.passwd;
130             CleanerFactory.cleaner().register(this,
131                     () -&gt; {
132                         Arrays.fill(k, (byte) 0x00);
133                         Arrays.fill(p, &#39;\0&#39;);
134                     });
135         }
136     }
137 
138     private static byte[] deriveKey(final Mac prf, final byte[] password,
139             byte[] salt, int iterCount, int keyLengthInBit) {
140         int keyLength = keyLengthInBit/8;
141         byte[] key = new byte[keyLength];
142         try {
143             int hlen = prf.getMacLength();
144             int intL = (keyLength + hlen - 1)/hlen; // ceiling
145             int intR = keyLength - (intL - 1)*hlen; // residue
146             byte[] ui = new byte[hlen];
147             byte[] ti = new byte[hlen];
148             // SecretKeySpec cannot be used, since password can be empty here.
149             SecretKey macKey = new SecretKey() {
<span class="line-added">150                 @java.io.Serial</span>
151                 private static final long serialVersionUID = 7874493593505141603L;
152                 @Override
153                 public String getAlgorithm() {
154                     return prf.getAlgorithm();
155                 }
156                 @Override
157                 public String getFormat() {
158                     return &quot;RAW&quot;;
159                 }
160                 @Override
161                 public byte[] getEncoded() {
162                     return password;
163                 }
164                 @Override
165                 public int hashCode() {
166                     return Arrays.hashCode(password) * 41 +
167                       prf.getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();
168                 }
169                 @Override
170                 public boolean equals(Object obj) {
</pre>
<hr />
<pre>
187                 ibytes[0] = (byte) ((i &gt;&gt; 24) &amp; 0xff);
188                 prf.update(ibytes);
189                 prf.doFinal(ui, 0);
190                 System.arraycopy(ui, 0, ti, 0, ui.length);
191 
192                 for (int j = 2; j &lt;= iterCount; j++) {
193                     prf.update(ui);
194                     prf.doFinal(ui, 0);
195                     // XOR the intermediate Ui&#39;s together.
196                     for (int k = 0; k &lt; ui.length; k++) {
197                         ti[k] ^= ui[k];
198                     }
199                 }
200                 if (i == intL) {
201                     System.arraycopy(ti, 0, key, (i-1)*hlen, intR);
202                 } else {
203                     System.arraycopy(ti, 0, key, (i-1)*hlen, hlen);
204                 }
205             }
206         } catch (GeneralSecurityException gse) {
<span class="line-modified">207             throw new RuntimeException(&quot;Error deriving PBKDF2 keys&quot;, gse);</span>
208         }
209         return key;
210     }
211 
212     public byte[] getEncoded() {
213         // The key is zeroized by finalize()
214         // The reachability fence ensures finalize() isn&#39;t called early
215         byte[] result = key.clone();
216         Reference.reachabilityFence(this);
217         return result;
218     }
219 
220     public String getAlgorithm() {
221         return &quot;PBKDF2With&quot; + prf.getAlgorithm();
222     }
223 
224     public int getIterationCount() {
225         return iterCount;
226     }
227 
</pre>
<hr />
<pre>
263         SecretKey that = (SecretKey) obj;
264 
265         if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm())))
266             return false;
267         if (!(that.getFormat().equalsIgnoreCase(&quot;RAW&quot;)))
268             return false;
269         byte[] thatEncoded = that.getEncoded();
270         boolean ret = MessageDigest.isEqual(key, thatEncoded);
271         Arrays.fill(thatEncoded, (byte)0x00);
272         return ret;
273     }
274 
275     /**
276      * Replace the PBE key to be serialized.
277      *
278      * @return the standard KeyRep object to be serialized
279      *
280      * @throws ObjectStreamException if a new object representing
281      * this PBE key could not be created
282      */
<span class="line-added">283     @java.io.Serial</span>
284     private Object writeReplace() throws ObjectStreamException {
285             return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),
286                               getFormat(), getEncoded());
287     }
288 }
</pre>
</td>
</tr>
</table>
<center><a href="PBEWithMD5AndTripleDESCipher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RSACipher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
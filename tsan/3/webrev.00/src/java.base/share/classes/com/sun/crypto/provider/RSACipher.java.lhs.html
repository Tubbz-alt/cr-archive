<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/com/sun/crypto/provider/RSACipher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.crypto.provider;
 27 
 28 import java.util.Locale;
 29 
 30 import java.security.*;
 31 import java.security.interfaces.*;
 32 import java.security.spec.AlgorithmParameterSpec;
 33 import java.security.spec.InvalidParameterSpecException;
 34 import java.security.spec.MGF1ParameterSpec;
 35 
 36 import javax.crypto.*;
 37 import javax.crypto.spec.PSource;
 38 import javax.crypto.spec.OAEPParameterSpec;
 39 
 40 import sun.security.rsa.*;
 41 import sun.security.jca.Providers;
 42 import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;
 43 import sun.security.util.KeyUtil;
 44 
 45 /**
 46  * RSA cipher implementation. Supports RSA en/decryption and signing/verifying
 47  * using both PKCS#1 v1.5 and OAEP (v2.2) paddings and without padding (raw RSA).
 48  * Note that raw RSA is supported mostly for completeness and should only be
 49  * used in rare cases.
 50  *
 51  * Objects should be instantiated by calling Cipher.getInstance() using the
 52  * following algorithm names:
 53  *  . &quot;RSA/ECB/PKCS1Padding&quot; (or &quot;RSA&quot;) for PKCS#1 v1.5 padding.
 54  *  . &quot;RSA/ECB/OAEPwith&lt;hash&gt;andMGF1Padding&quot; (or &quot;RSA/ECB/OAEPPadding&quot;) for
 55  *    PKCS#1 v2.2 padding.
 56  *  . &quot;RSA/ECB/NoPadding&quot; for rsa RSA.
 57  *
 58  * We only do one RSA operation per doFinal() call. If the application passes
 59  * more data via calls to update() or doFinal(), we throw an
 60  * IllegalBlockSizeException when doFinal() is called (see JCE API spec).
 61  * Bulk encryption using RSA does not make sense and is not standardized.
 62  *
 63  * Note: RSA keys should be at least 512 bits long
 64  *
 65  * @since   1.5
 66  * @author  Andreas Sterbenz
 67  */
 68 public final class RSACipher extends CipherSpi {
 69 
 70     // constant for an empty byte array
 71     private static final byte[] B0 = new byte[0];
 72 
 73     // mode constant for public key encryption
 74     private static final int MODE_ENCRYPT = 1;
 75     // mode constant for private key decryption
 76     private static final int MODE_DECRYPT = 2;
 77     // mode constant for private key encryption (signing)
 78     private static final int MODE_SIGN    = 3;
 79     // mode constant for public key decryption (verifying)
 80     private static final int MODE_VERIFY  = 4;
 81 
 82     // constant for raw RSA
 83     private static final String PAD_NONE  = &quot;NoPadding&quot;;
 84     // constant for PKCS#1 v1.5 RSA
 85     private static final String PAD_PKCS1 = &quot;PKCS1Padding&quot;;
 86     // constant for PKCS#2 v2.2 OAEP with MGF1
 87     private static final String PAD_OAEP_MGF1  = &quot;OAEP&quot;;
 88 
 89     // current mode, one of MODE_* above. Set when init() is called
 90     private int mode;
 91 
 92     // active padding type, one of PAD_* above. Set by setPadding()
 93     private String paddingType;
 94 
 95     // padding object
 96     private RSAPadding padding;
 97 
 98     // cipher parameter for OAEP padding and TLS RSA premaster secret
 99     private AlgorithmParameterSpec spec = null;
100 
101     // buffer for the data
102     private byte[] buffer;
103     // offset into the buffer (number of bytes buffered)
104     private int bufOfs;
105 
106     // size of the output
107     private int outputSize;
108 
109     // the public key, if we were initialized using a public key
110     private RSAPublicKey publicKey;
111     // the private key, if we were initialized using a private key
112     private RSAPrivateKey privateKey;
113 
114     // hash algorithm for OAEP
115     private String oaepHashAlgorithm = &quot;SHA-1&quot;;
116 
117     // the source of randomness
118     private SecureRandom random;
119 
120     public RSACipher() {
121         paddingType = PAD_PKCS1;
122     }
123 
124     // modes do not make sense for RSA, but allow ECB
125     // see JCE spec
126     protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
127         if (mode.equalsIgnoreCase(&quot;ECB&quot;) == false) {
128             throw new NoSuchAlgorithmException(&quot;Unsupported mode &quot; + mode);
129         }
130     }
131 
132     // set the padding type
133     // see JCE spec
134     protected void engineSetPadding(String paddingName)
135             throws NoSuchPaddingException {
136         if (paddingName.equalsIgnoreCase(PAD_NONE)) {
137             paddingType = PAD_NONE;
138         } else if (paddingName.equalsIgnoreCase(PAD_PKCS1)) {
139             paddingType = PAD_PKCS1;
140         } else {
141             String lowerPadding = paddingName.toLowerCase(Locale.ENGLISH);
142             if (lowerPadding.equals(&quot;oaeppadding&quot;)) {
143                 paddingType = PAD_OAEP_MGF1;
144             } else if (lowerPadding.startsWith(&quot;oaepwith&quot;) &amp;&amp;
145                        lowerPadding.endsWith(&quot;andmgf1padding&quot;)) {
146                 paddingType = PAD_OAEP_MGF1;
147                 // &quot;oaepwith&quot;.length() == 8
148                 // &quot;andmgf1padding&quot;.length() == 14
149                 oaepHashAlgorithm =
150                         paddingName.substring(8, paddingName.length() - 14);
151                 // check if MessageDigest appears to be available
152                 // avoid getInstance() call here
153                 if (Providers.getProviderList().getService
154                         (&quot;MessageDigest&quot;, oaepHashAlgorithm) == null) {
155                     throw new NoSuchPaddingException
156                         (&quot;MessageDigest not available for &quot; + paddingName);
157                 }
158             } else {
159                 throw new NoSuchPaddingException
160                     (&quot;Padding &quot; + paddingName + &quot; not supported&quot;);
161             }
162         }
163     }
164 
165     // return 0 as block size, we are not a block cipher
166     // see JCE spec
167     protected int engineGetBlockSize() {
168         return 0;
169     }
170 
171     // return the output size
172     // see JCE spec
173     protected int engineGetOutputSize(int inputLen) {
174         return outputSize;
175     }
176 
177     // no iv, return null
178     // see JCE spec
179     protected byte[] engineGetIV() {
180         return null;
181     }
182 
183     // see JCE spec
184     protected AlgorithmParameters engineGetParameters() {
185         if (spec != null &amp;&amp; spec instanceof OAEPParameterSpec) {
186             try {
187                 AlgorithmParameters params =
188                     AlgorithmParameters.getInstance(&quot;OAEP&quot;,
189                         SunJCE.getInstance());
190                 params.init(spec);
191                 return params;
192             } catch (NoSuchAlgorithmException nsae) {
193                 // should never happen
194                 throw new RuntimeException(&quot;Cannot find OAEP &quot; +
195                     &quot; AlgorithmParameters implementation in SunJCE provider&quot;);
196             } catch (InvalidParameterSpecException ipse) {
197                 // should never happen
198                 throw new RuntimeException(&quot;OAEPParameterSpec not supported&quot;);
199             }
200         } else {
201             return null;
202         }
203     }
204 
205     // see JCE spec
206     protected void engineInit(int opmode, Key key, SecureRandom random)
207             throws InvalidKeyException {
208         try {
209             init(opmode, key, random, null);
210         } catch (InvalidAlgorithmParameterException iape) {
211             // never thrown when null parameters are used;
212             // but re-throw it just in case
213             InvalidKeyException ike =
214                 new InvalidKeyException(&quot;Wrong parameters&quot;);
215             ike.initCause(iape);
216             throw ike;
217         }
218     }
219 
220     // see JCE spec
221     protected void engineInit(int opmode, Key key,
222             AlgorithmParameterSpec params, SecureRandom random)
223             throws InvalidKeyException, InvalidAlgorithmParameterException {
224         init(opmode, key, random, params);
225     }
226 
227     // see JCE spec
228     protected void engineInit(int opmode, Key key,
229             AlgorithmParameters params, SecureRandom random)
230             throws InvalidKeyException, InvalidAlgorithmParameterException {
231         if (params == null) {
232             init(opmode, key, random, null);
233         } else {
234             try {
235                 OAEPParameterSpec spec =
236                         params.getParameterSpec(OAEPParameterSpec.class);
237                 init(opmode, key, random, spec);
238             } catch (InvalidParameterSpecException ipse) {
239                 InvalidAlgorithmParameterException iape =
240                     new InvalidAlgorithmParameterException(&quot;Wrong parameter&quot;);
241                 iape.initCause(ipse);
242                 throw iape;
243             }
244         }
245     }
246 
247     // initialize this cipher
248     @SuppressWarnings(&quot;deprecation&quot;)
249     private void init(int opmode, Key key, SecureRandom random,
250             AlgorithmParameterSpec params)
251             throws InvalidKeyException, InvalidAlgorithmParameterException {
252         boolean encrypt;
253         switch (opmode) {
254         case Cipher.ENCRYPT_MODE:
255         case Cipher.WRAP_MODE:
256             encrypt = true;
257             break;
258         case Cipher.DECRYPT_MODE:
259         case Cipher.UNWRAP_MODE:
260             encrypt = false;
261             break;
262         default:
263             throw new InvalidKeyException(&quot;Unknown mode: &quot; + opmode);
264         }
265         RSAKey rsaKey = RSAKeyFactory.toRSAKey(key);
<a name="1" id="anc1"></a><span class="line-modified">266         if (key instanceof RSAPublicKey) {</span>
267             mode = encrypt ? MODE_ENCRYPT : MODE_VERIFY;
<a name="2" id="anc2"></a><span class="line-modified">268             publicKey = (RSAPublicKey)key;</span>
269             privateKey = null;
270         } else { // must be RSAPrivateKey per check in toRSAKey
271             mode = encrypt ? MODE_SIGN : MODE_DECRYPT;
<a name="3" id="anc3"></a><span class="line-modified">272             privateKey = (RSAPrivateKey)key;</span>
273             publicKey = null;
274         }
275         int n = RSACore.getByteLength(rsaKey.getModulus());
276         outputSize = n;
277         bufOfs = 0;
278         if (paddingType == PAD_NONE) {
279             if (params != null) {
280                 throw new InvalidAlgorithmParameterException
281                 (&quot;Parameters not supported&quot;);
282             }
283             padding = RSAPadding.getInstance(RSAPadding.PAD_NONE, n, random);
284             buffer = new byte[n];
285         } else if (paddingType == PAD_PKCS1) {
286             if (params != null) {
287                 if (!(params instanceof TlsRsaPremasterSecretParameterSpec)) {
288                     throw new InvalidAlgorithmParameterException(
289                             &quot;Parameters not supported&quot;);
290                 }
291 
292                 spec = params;
293                 this.random = random;   // for TLS RSA premaster secret
294             }
295             int blockType = (mode &lt;= MODE_DECRYPT) ? RSAPadding.PAD_BLOCKTYPE_2
296                                                    : RSAPadding.PAD_BLOCKTYPE_1;
297             padding = RSAPadding.getInstance(blockType, n, random);
298             if (encrypt) {
299                 int k = padding.getMaxDataSize();
300                 buffer = new byte[k];
301             } else {
302                 buffer = new byte[n];
303             }
304         } else { // PAD_OAEP_MGF1
305             if ((mode == MODE_SIGN) || (mode == MODE_VERIFY)) {
306                 throw new InvalidKeyException
307                         (&quot;OAEP cannot be used to sign or verify signatures&quot;);
308             }
309             if (params != null) {
310                 if (!(params instanceof OAEPParameterSpec)) {
311                     throw new InvalidAlgorithmParameterException
312                         (&quot;Wrong Parameters for OAEP Padding&quot;);
313                 }
314                 spec = params;
315             } else {
316                 spec = new OAEPParameterSpec(oaepHashAlgorithm, &quot;MGF1&quot;,
317                     MGF1ParameterSpec.SHA1, PSource.PSpecified.DEFAULT);
318             }
319             padding = RSAPadding.getInstance(RSAPadding.PAD_OAEP_MGF1, n,
320                 random, (OAEPParameterSpec)spec);
321             if (encrypt) {
322                 int k = padding.getMaxDataSize();
323                 buffer = new byte[k];
324             } else {
325                 buffer = new byte[n];
326             }
327         }
328     }
329 
330     // internal update method
331     private void update(byte[] in, int inOfs, int inLen) {
332         if ((inLen == 0) || (in == null)) {
333             return;
334         }
335         if (inLen &gt; (buffer.length - bufOfs)) {
336             bufOfs = buffer.length + 1;
337             return;
338         }
339         System.arraycopy(in, inOfs, buffer, bufOfs, inLen);
340         bufOfs += inLen;
341     }
342 
343     // internal doFinal() method. Here we perform the actual RSA operation
344     private byte[] doFinal() throws BadPaddingException,
345             IllegalBlockSizeException {
346         if (bufOfs &gt; buffer.length) {
347             throw new IllegalBlockSizeException(&quot;Data must not be longer &quot;
348                 + &quot;than &quot; + buffer.length + &quot; bytes&quot;);
349         }
350         try {
351             byte[] data;
352             switch (mode) {
353             case MODE_SIGN:
354                 data = padding.pad(buffer, 0, bufOfs);
355                 return RSACore.rsa(data, privateKey, true);
356             case MODE_VERIFY:
357                 byte[] verifyBuffer = RSACore.convert(buffer, 0, bufOfs);
358                 data = RSACore.rsa(verifyBuffer, publicKey);
359                 return padding.unpad(data);
360             case MODE_ENCRYPT:
361                 data = padding.pad(buffer, 0, bufOfs);
362                 return RSACore.rsa(data, publicKey);
363             case MODE_DECRYPT:
364                 byte[] decryptBuffer = RSACore.convert(buffer, 0, bufOfs);
365                 data = RSACore.rsa(decryptBuffer, privateKey, false);
366                 return padding.unpad(data);
367             default:
368                 throw new AssertionError(&quot;Internal error&quot;);
369             }
370         } finally {
371             bufOfs = 0;
372         }
373     }
374 
375     // see JCE spec
376     protected byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
377         update(in, inOfs, inLen);
378         return B0;
379     }
380 
381     // see JCE spec
382     protected int engineUpdate(byte[] in, int inOfs, int inLen, byte[] out,
383             int outOfs) {
384         update(in, inOfs, inLen);
385         return 0;
386     }
387 
388     // see JCE spec
389     protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
390             throws BadPaddingException, IllegalBlockSizeException {
391         update(in, inOfs, inLen);
392         return doFinal();
393     }
394 
395     // see JCE spec
396     protected int engineDoFinal(byte[] in, int inOfs, int inLen, byte[] out,
397             int outOfs) throws ShortBufferException, BadPaddingException,
398             IllegalBlockSizeException {
399         if (outputSize &gt; out.length - outOfs) {
400             throw new ShortBufferException
401                 (&quot;Need &quot; + outputSize + &quot; bytes for output&quot;);
402         }
403         update(in, inOfs, inLen);
404         byte[] result = doFinal();
405         int n = result.length;
406         System.arraycopy(result, 0, out, outOfs, n);
407         return n;
408     }
409 
410     // see JCE spec
411     protected byte[] engineWrap(Key key) throws InvalidKeyException,
412             IllegalBlockSizeException {
413         byte[] encoded = key.getEncoded();
414         if ((encoded == null) || (encoded.length == 0)) {
415             throw new InvalidKeyException(&quot;Could not obtain encoded key&quot;);
416         }
417         if (encoded.length &gt; buffer.length) {
418             throw new InvalidKeyException(&quot;Key is too long for wrapping&quot;);
419         }
420         update(encoded, 0, encoded.length);
421         try {
422             return doFinal();
423         } catch (BadPaddingException e) {
424             // should not occur
425             throw new InvalidKeyException(&quot;Wrapping failed&quot;, e);
426         }
427     }
428 
429     // see JCE spec
430     @SuppressWarnings(&quot;deprecation&quot;)
431     protected Key engineUnwrap(byte[] wrappedKey, String algorithm,
432             int type) throws InvalidKeyException, NoSuchAlgorithmException {
433         if (wrappedKey.length &gt; buffer.length) {
434             throw new InvalidKeyException(&quot;Key is too long for unwrapping&quot;);
435         }
436 
437         boolean isTlsRsaPremasterSecret =
438                 algorithm.equals(&quot;TlsRsaPremasterSecret&quot;);
439         Exception failover = null;
440         byte[] encoded = null;
441 
442         update(wrappedKey, 0, wrappedKey.length);
443         try {
444             encoded = doFinal();
445         } catch (BadPaddingException e) {
446             if (isTlsRsaPremasterSecret) {
447                 failover = e;
448             } else {
449                 throw new InvalidKeyException(&quot;Unwrapping failed&quot;, e);
450             }
451         } catch (IllegalBlockSizeException e) {
452             // should not occur, handled with length check above
453             throw new InvalidKeyException(&quot;Unwrapping failed&quot;, e);
454         }
455 
456         if (isTlsRsaPremasterSecret) {
457             if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {
458                 throw new IllegalStateException(
459                         &quot;No TlsRsaPremasterSecretParameterSpec specified&quot;);
460             }
461 
462             // polish the TLS premaster secret
463             encoded = KeyUtil.checkTlsPreMasterSecretKey(
464                 ((TlsRsaPremasterSecretParameterSpec)spec).getClientVersion(),
465                 ((TlsRsaPremasterSecretParameterSpec)spec).getServerVersion(),
466                 random, encoded, (failover != null));
467         }
468 
469         return ConstructKeys.constructKey(encoded, algorithm, type);
470     }
471 
472     // see JCE spec
473     protected int engineGetKeySize(Key key) throws InvalidKeyException {
474         RSAKey rsaKey = RSAKeyFactory.toRSAKey(key);
475         return rsaKey.getModulus().bitLength();
476     }
477 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
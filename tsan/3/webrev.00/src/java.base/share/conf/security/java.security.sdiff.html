<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/conf/security/java.security</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classes/sun/util/resources/TimeZoneNames.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../legal/cldr.md.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/conf/security/java.security</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  44 # by 2, and so on.
  45 #
  46 # &lt;provName&gt; must specify the name of the Provider as passed to its super
  47 # class java.security.Provider constructor. This is for providers loaded
  48 # through the ServiceLoader mechanism.
  49 #
  50 # &lt;className&gt; must specify the subclass of the Provider class whose
  51 # constructor sets the values of various properties that are required
  52 # for the Java Security API to look up the algorithms or other
  53 # facilities implemented by the provider. This is for providers loaded
  54 # through classpath.
  55 #
  56 # Note: Providers can be dynamically registered instead by calls to
  57 # either the addProvider or insertProviderAt method in the Security
  58 # class.
  59 
  60 #
  61 # List of providers and their preference orders (see above):
  62 #
  63 #ifdef solaris


  64 security.provider.tbd=OracleUcrypto
  65 security.provider.tbd=SunPKCS11 ${java.home}/conf/security/sunpkcs11-solaris.cfg
  66 #endif
  67 security.provider.tbd=SUN
  68 security.provider.tbd=SunRsaSign
  69 security.provider.tbd=SunEC
  70 security.provider.tbd=SunJSSE
  71 security.provider.tbd=SunJCE
  72 security.provider.tbd=SunJGSS
  73 security.provider.tbd=SunSASL
  74 security.provider.tbd=XMLDSig
  75 security.provider.tbd=SunPCSC
  76 security.provider.tbd=JdkLDAP
  77 security.provider.tbd=JdkSASL
  78 #ifdef windows
  79 security.provider.tbd=SunMSCAPI
  80 #endif
  81 #ifdef macosx
  82 security.provider.tbd=Apple
  83 #endif
</pre>
<hr />
<pre>
 257 login.configuration.provider=sun.security.provider.ConfigFile
 258 
 259 #
 260 # Default login configuration file
 261 #
 262 #login.config.url.1=file:${user.home}/.java.login.config
 263 
 264 #
 265 # Class to instantiate as the system Policy. This is the name of the class
 266 # that will be used as the Policy object. The system class loader is used to
 267 # locate this class.
 268 #
 269 policy.provider=sun.security.provider.PolicyFile
 270 
 271 # The default is to have a single system-wide policy file,
 272 # and a policy file in the user&#39;s home directory.
 273 #
 274 policy.url.1=file:${java.home}/conf/security/java.policy
 275 policy.url.2=file:${user.home}/.java.policy
 276 
<span class="line-modified"> 277 # whether or not we expand properties in the policy file</span>
<span class="line-modified"> 278 # if this is set to false, properties (${...}) will not be expanded in policy</span>
<span class="line-modified"> 279 # files.</span>


 280 #
 281 policy.expandProperties=true
 282 
<span class="line-modified"> 283 # whether or not we allow an extra policy to be passed on the command line</span>
<span class="line-modified"> 284 # with -Djava.security.policy=somefile. Comment out this line to disable</span>
<span class="line-modified"> 285 # this feature.</span>

 286 #
 287 policy.allowSystemProperty=true
 288 
 289 # whether or not we look into the IdentityScope for trusted Identities
 290 # when encountering a 1.1 signed JAR file. If the identity is found
 291 # and is trusted, we grant it AllPermission. Note: the default policy
 292 # provider (sun.security.provider.PolicyFile) does not support this property.
 293 #
 294 policy.ignoreIdentityScope=false
 295 
 296 #
 297 # Default keystore type.
 298 #
 299 keystore.type=pkcs12
 300 
 301 #
 302 # Controls compatibility mode for JKS and PKCS12 keystore types.
 303 #
 304 # When set to &#39;true&#39;, both JKS and PKCS12 keystore types support loading
 305 # keystore files in either JKS or PKCS12 format. When set to &#39;false&#39; the
</pre>
<hr />
<pre>
 457 #    KDCs in the blacklist are always tried after those not on the list.
 458 #
 459 # tryLess[:max_retries,timeout]
 460 #    KDCs in the blacklist are still tried by their order in the configuration,
 461 #    but with smaller max_retries and timeout values. max_retries and timeout
 462 #    are optional numerical parameters (default 1 and 5000, which means once
 463 #    and 5 seconds). Please notes that if any of the values defined here is
 464 #    more than what is defined in krb5.conf, it will be ignored.
 465 #
 466 # Whenever a KDC is detected as available, it is removed from the blacklist.
 467 # The blacklist is reset when krb5.conf is reloaded. You can add
 468 # refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
 469 # reloaded whenever a JAAS authentication is attempted.
 470 #
 471 # Example,
 472 #   krb5.kdc.bad.policy = tryLast
 473 #   krb5.kdc.bad.policy = tryLess:2,2000
 474 #
 475 krb5.kdc.bad.policy = tryLast
 476 









































 477 #
 478 # Algorithm restrictions for certification path (CertPath) processing
 479 #
 480 # In some environments, certain algorithms or key lengths may be undesirable
 481 # for certification path building and validation.  For example, &quot;MD2&quot; is
 482 # generally no longer considered to be a secure hash algorithm.  This section
 483 # describes the mechanism for disabling algorithms based on algorithm name
 484 # and/or key length.  This includes algorithms used in certificates, as well
 485 # as revocation information such as CRLs and signed OCSP Responses.
 486 # The syntax of the disabled algorithm string is described as follows:
 487 #   DisabledAlgorithms:
 488 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 489 #
 490 #   DisabledAlgorithm:
<span class="line-modified"> 491 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }</span>
 492 #
 493 #   AlgorithmName:
 494 #       (see below)
 495 #
 496 #   Constraint:
 497 #       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
 498 #       UsageConstraint
 499 #
 500 #   KeySizeConstraint:
 501 #       keySize Operator KeyLength
 502 #
 503 #   Operator:
 504 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 505 #
 506 #   KeyLength:
 507 #       Integer value of the algorithm&#39;s key length in bits
 508 #
 509 #   CAConstraint:
 510 #       jdkCA
 511 #
 512 #   DenyAfterConstraint:
 513 #       denyAfter YYYY-MM-DD
 514 #
 515 #   UsageConstraint:
 516 #       usage [TLSServer] [TLSClient] [SignedJAR]
 517 #



 518 # The &quot;AlgorithmName&quot; is the standard algorithm name of the disabled
<span class="line-modified"> 519 # algorithm. See &quot;Java Cryptography Architecture Standard Algorithm Name</span>
<span class="line-modified"> 520 # Documentation&quot; for information about Standard Algorithm Names.  Matching</span>
<span class="line-modified"> 521 # is performed using a case-insensitive sub-element matching rule.  (For</span>
 522 # example, in &quot;SHA1withECDSA&quot; the sub-elements are &quot;SHA1&quot; for hashing and
 523 # &quot;ECDSA&quot; for signatures.)  If the assertion &quot;AlgorithmName&quot; is a
 524 # sub-element of the certificate algorithm name, the algorithm will be
 525 # rejected during certification path building and validation.  For example,
 526 # the assertion algorithm name &quot;DSA&quot; will disable all certificate algorithms
 527 # that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
 528 # will not disable algorithms related to &quot;ECDSA&quot;.
 529 #








 530 # A &quot;Constraint&quot; defines restrictions on the keys and/or certificates for
 531 # a specified AlgorithmName:
 532 #
 533 #   KeySizeConstraint:
 534 #     keySize Operator KeyLength
 535 #       The constraint requires a key of a valid size range if the
 536 #       &quot;AlgorithmName&quot; is of a key algorithm.  The &quot;KeyLength&quot; indicates
 537 #       the key size specified in number of bits.  For example,
 538 #       &quot;RSA keySize &lt;= 1024&quot; indicates that any RSA key with key size less
 539 #       than or equal to 1024 bits should be disabled, and
 540 #       &quot;RSA keySize &lt; 1024, RSA keySize &gt; 2048&quot; indicates that any RSA key
 541 #       with key size less than 1024 or greater than 2048 should be disabled.
 542 #       This constraint is only used on algorithms that have a key size.
 543 #
 544 #   CAConstraint:
 545 #     jdkCA
 546 #       This constraint prohibits the specified algorithm only if the
 547 #       algorithm is used in a certificate chain that terminates at a marked
 548 #       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
 549 #       constraint is not set, then all chains using the specified algorithm
</pre>
<hr />
<pre>
 582 # chain that terminate at a distribution provided trust anchor and contain
 583 # RSA keys that are less than or equal to 1024 bits, add the following
 584 # constraint:  &quot;RSA keySize &lt;= 1024 &amp; jdkCA&quot;.
 585 #
 586 # All DisabledAlgorithms expressions are processed in the order defined in the
 587 # property.  This requires lower keysize constraints to be specified
 588 # before larger keysize constraints of the same algorithm.  For example:
 589 # &quot;RSA keySize &lt; 1024 &amp; jdkCA, RSA keySize &lt; 2048&quot;.
 590 #
 591 # Note: The algorithm restrictions do not apply to trust anchors or
 592 # self-signed certificates.
 593 #
 594 # Note: This property is currently used by Oracle&#39;s PKIX implementation. It
 595 # is not guaranteed to be examined and used by other implementations.
 596 #
 597 # Example:
 598 #   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
 599 #
 600 #
 601 jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
<span class="line-modified"> 602     RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224</span>

 603 
 604 #
 605 # Algorithm restrictions for signed JAR files
 606 #
 607 # In some environments, certain algorithms or key lengths may be undesirable
 608 # for signed JAR validation.  For example, &quot;MD2&quot; is generally no longer
 609 # considered to be a secure hash algorithm.  This section describes the
 610 # mechanism for disabling algorithms based on algorithm name and/or key length.
 611 # JARs signed with any of the disabled algorithms or key sizes will be treated
 612 # as unsigned.
 613 #
 614 # The syntax of the disabled algorithm string is described as follows:
 615 #   DisabledAlgorithms:
 616 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 617 #
 618 #   DisabledAlgorithm:
 619 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 620 #
 621 #   AlgorithmName:
 622 #       (see below)
</pre>
<hr />
<pre>
 626 #
 627 #   KeySizeConstraint:
 628 #       keySize Operator KeyLength
 629 #
 630 #   DenyAfterConstraint:
 631 #       denyAfter YYYY-MM-DD
 632 #
 633 #   Operator:
 634 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 635 #
 636 #   KeyLength:
 637 #       Integer value of the algorithm&#39;s key length in bits
 638 #
 639 # Note: This property is currently used by the JDK Reference
 640 # implementation. It is not guaranteed to be examined and used by other
 641 # implementations.
 642 #
 643 # See &quot;jdk.certpath.disabledAlgorithms&quot; for syntax descriptions.
 644 #
 645 jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &lt; 1024, \
<span class="line-modified"> 646       DSA keySize &lt; 1024</span>
 647 
 648 #
 649 # Algorithm restrictions for Secure Socket Layer/Transport Layer Security
 650 # (SSL/TLS/DTLS) processing
 651 #
 652 # In some environments, certain algorithms or key lengths may be undesirable
 653 # when using SSL/TLS/DTLS.  This section describes the mechanism for disabling
 654 # algorithms during SSL/TLS/DTLS security parameters negotiation, including
<span class="line-modified"> 655 # protocol version negotiation, cipher suites selection, peer authentication</span>
<span class="line-modified"> 656 # and key exchange mechanisms.</span>

 657 #
 658 # Disabled algorithms will not be negotiated for SSL/TLS connections, even
 659 # if they are enabled explicitly in an application.
 660 #
 661 # For PKI-based peer authentication and key exchange mechanisms, this list
 662 # of disabled algorithms will also be checked during certification path
 663 # building and validation, including algorithms used in certificates, as
 664 # well as revocation information such as CRLs and signed OCSP Responses.
 665 # This is in addition to the jdk.certpath.disabledAlgorithms property above.
 666 #
 667 # See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the
 668 # syntax of the disabled algorithm string.
 669 #
 670 # Note: The algorithm restrictions do not apply to trust anchors or
 671 # self-signed certificates.
 672 #
 673 # Note: This property is currently used by the JDK Reference implementation.
 674 # It is not guaranteed to be examined and used by other implementations.
 675 #
 676 # Example:
<span class="line-modified"> 677 #   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048</span>

 678 jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \
<span class="line-modified"> 679     EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL</span>

 680 
 681 #
 682 # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
 683 # processing in JSSE implementation.
 684 #
 685 # In some environments, a certain algorithm may be undesirable but it
 686 # cannot be disabled because of its use in legacy applications.  Legacy
 687 # algorithms may still be supported, but applications should not use them
 688 # as the security strength of legacy algorithms are usually not strong enough
 689 # in practice.
 690 #
 691 # During SSL/TLS security parameters negotiation, legacy algorithms will
 692 # not be negotiated unless there are no other candidates.
 693 #
 694 # The syntax of the legacy algorithms string is described as this Java
 695 # BNF-style:
 696 #   LegacyAlgorithms:
 697 #       &quot; LegacyAlgorithm { , LegacyAlgorithm } &quot;
 698 #
 699 #   LegacyAlgorithm:
</pre>
<hr />
<pre>
 701 #
 702 # See the specification of security property &quot;jdk.certpath.disabledAlgorithms&quot;
 703 # for the syntax and description of the &quot;AlgorithmName&quot; notation.
 704 #
 705 # Per SSL/TLS specifications, cipher suites have the form:
 706 #       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 707 # or
 708 #       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 709 #
 710 # For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
 711 # key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
 712 # mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
 713 # algorithm for HMAC.
 714 #
 715 # The LegacyAlgorithm can be one of the following standard algorithm names:
 716 #     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
 717 #     2. JSSE key exchange algorithm name, e.g., RSA
 718 #     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
 719 #     4. JSSE message digest algorithm name, e.g., SHA
 720 #
<span class="line-modified"> 721 # See SSL/TLS specifications and &quot;Java Cryptography Architecture Standard</span>
<span class="line-modified"> 722 # Algorithm Name Documentation&quot; for information about the algorithm names.</span>
 723 #
 724 # Note: If a legacy algorithm is also restricted through the
 725 # jdk.tls.disabledAlgorithms property or the
 726 # java.security.AlgorithmConstraints API (See
 727 # javax.net.ssl.SSLParameters.setAlgorithmConstraints()),
 728 # then the algorithm is completely disabled and will not be negotiated.
 729 #
 730 # Note: This property is currently used by the JDK Reference implementation.
 731 # It is not guaranteed to be examined and used by other implementations.
 732 # There is no guarantee the property will continue to exist or be of the
 733 # same syntax in future releases.
 734 #
 735 # Example:
 736 #   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
 737 #
 738 jdk.tls.legacyAlgorithms= \
 739         K_NULL, C_NULL, M_NULL, \
 740         DH_anon, ECDH_anon, \
 741         RC4_128, RC4_40, DES_CBC, DES40_CBC, \
 742         3DES_EDE_CBC
</pre>
<hr />
<pre>
1005 #    java.rmi.server.UID
1006 #
1007 # RMI Distributed Garbage Collector (DGC) Serial Filter
1008 #
1009 # The filter pattern uses the same format as jdk.serialFilter.
1010 # This filter can override the builtin filter if additional types need to be
1011 # allowed or rejected from the RMI DGC.
1012 #
1013 # Note: This property is currently used by the JDK Reference implementation.
1014 # It is not guaranteed to be examined and used by other implementations.
1015 #
1016 # The builtin DGC filter can approximately be represented as the filter pattern:
1017 #
1018 #sun.rmi.transport.dgcFilter=\
1019 #    java.rmi.server.ObjID;\
1020 #    java.rmi.server.UID;\
1021 #    java.rmi.dgc.VMID;\
1022 #    java.rmi.dgc.Lease;\
1023 #    maxdepth=5;maxarray=10000
1024 
<span class="line-removed">1025 # CORBA ORBIorTypeCheckRegistryFilter</span>
<span class="line-removed">1026 # Type check enhancement for ORB::string_to_object processing</span>
<span class="line-removed">1027 #</span>
<span class="line-removed">1028 # An IOR type check filter, if configured, is used by an ORB during</span>
<span class="line-removed">1029 # an ORB::string_to_object invocation to check the veracity of the type encoded</span>
<span class="line-removed">1030 # in the ior string.</span>
<span class="line-removed">1031 #</span>
<span class="line-removed">1032 # The filter pattern consists of a semi-colon separated list of class names.</span>
<span class="line-removed">1033 # The configured list contains the binary class names of the IDL interface types</span>
<span class="line-removed">1034 # corresponding to the IDL stub class to be instantiated.</span>
<span class="line-removed">1035 # As such, a filter specifies a list of IDL stub classes that will be</span>
<span class="line-removed">1036 # allowed by an ORB when an ORB::string_to_object is invoked.</span>
<span class="line-removed">1037 # It is used to specify a white list configuration of acceptable</span>
<span class="line-removed">1038 # IDL stub types which may be contained in a stringified IOR</span>
<span class="line-removed">1039 # parameter passed as input to an ORB::string_to_object method.</span>
<span class="line-removed">1040 #</span>
<span class="line-removed">1041 # Note: This property is currently used by the JDK Reference implementation.</span>
<span class="line-removed">1042 # It is not guaranteed to be examined and used by other implementations.</span>
<span class="line-removed">1043 #</span>
<span class="line-removed">1044 #com.sun.CORBA.ORBIorTypeCheckRegistryFilter=binary_class_name;binary_class_name</span>
<span class="line-removed">1045 </span>
1046 #
1047 # JCEKS Encrypted Key Serial Filter
1048 #
1049 # This filter, if configured, is used by the JCEKS KeyStore during the
1050 # deserialization of the encrypted Key object stored inside a key entry.
1051 # If not configured or the filter result is UNDECIDED (i.e. none of the patterns
1052 # matches), the filter configured by jdk.serialFilter will be consulted.
1053 #
1054 # If the system property jceks.key.serialFilter is also specified, it supersedes
1055 # the security property value defined here.
1056 #
1057 # The filter pattern uses the same format as jdk.serialFilter. The default
1058 # pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
1059 # and javax.crypto.spec.SecretKeySpec and rejects all the others.
1060 jceks.key.serialFilter = java.base/java.lang.Enum;java.base/java.security.KeyRep;\
1061   java.base/java.security.KeyRep$Type;java.base/javax.crypto.spec.SecretKeySpec;!*
1062 










1063 #
1064 # PKCS12 KeyStore properties
1065 #
1066 # The following properties, if configured, are used by the PKCS12 KeyStore
1067 # implementation during the creation of a new keystore. Several of the
1068 # properties may also be used when modifying an existing keystore. The
1069 # properties can be overridden by a KeyStore API that specifies its own
1070 # algorithms and parameters.
1071 #
1072 # If an existing PKCS12 keystore is loaded and then stored, the algorithm and
1073 # parameter used to generate the existing Mac will be reused. If the existing
1074 # keystore does not have a Mac, no Mac will be created while storing. If there
1075 # is at least one certificate in the existing keystore, the algorithm and
1076 # parameters used to encrypt the last certificate in the existing keystore will
1077 # be reused to encrypt all certificates while storing. If the last certificate
1078 # in the existing keystore is not encrypted, all certificates will be stored
1079 # unencrypted. If there is no certificate in the existing keystore, any newly
1080 # added certificate will be encrypted (or stored unencrypted if algorithm
1081 # value is &quot;NONE&quot;) using the &quot;keystore.pkcs12.certProtectionAlgorithm&quot; and
1082 # &quot;keystore.pkcs12.certPbeIterationCount&quot; values defined here. Existing private
</pre>
<hr />
<pre>
1143 #
1144 # NOTE: Use caution before setting this property. Setting this property
1145 # exposes sensitive information in Exceptions, which could, for example,
1146 # propagate to untrusted code or be emitted in stack traces that are
1147 # inadvertently disclosed and made accessible over a public network.
1148 #
1149 # The categories are:
1150 #
1151 #  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the
1152 #             java.nio.channels package will contain enhanced exception
1153 #             message information
1154 #
1155 #  jar      - enables more detailed information in the IOExceptions thrown
1156 #             by classes in the java.util.jar package
1157 #
1158 # The property setting in this file can be overridden by a system property of
1159 # the same name, with the same syntax and possible values.
1160 #
1161 #jdk.includeInExceptions=hostInfo,jar
1162 


















1163 #
1164 # Policies for distrusting Certificate Authorities (CAs).
1165 #
1166 # This is a comma separated value of one or more case-sensitive strings, each
1167 # of which represents a policy for determining if a CA should be distrusted.
1168 # The supported values are:
1169 #
1170 #   SYMANTEC_TLS : Distrust TLS Server certificates anchored by a Symantec
1171 #   root CA and issued after April 16, 2019 unless issued by one of the
1172 #   following subordinate CAs which have a later distrust date:
1173 #     1. Apple IST CA 2 - G1, SHA-256 fingerprint:
1174 #        AC2B922ECFD5E01711772FEA8ED372DE9D1E2245FCE3F57A9CDBEC77296A424B
1175 #        Distrust after December 31, 2019.
1176 #     2. Apple IST CA 8 - G1, SHA-256 fingerprint:
1177 #        A4FE7C7F15155F3F0AEF7AAA83CF6E06DEB97CA3F909DF920AC1490882D488ED
1178 #        Distrust after December 31, 2019.
1179 #
1180 # Leading and trailing whitespace surrounding each value are ignored.
1181 # Unknown values are ignored. If the property is commented out or set to the
1182 # empty String, no policies are enforced.
1183 #
1184 # Note: This property is currently used by the JDK Reference implementation.
1185 # It is not guaranteed to be supported by other SE implementations. Also, this
1186 # property does not override other security properties which can restrict
1187 # certificates such as jdk.tls.disabledAlgorithms or
1188 # jdk.certpath.disabledAlgorithms; those restrictions are still enforced even
1189 # if this property is not enabled.
1190 #
1191 jdk.security.caDistrustPolicies=SYMANTEC_TLS
















































</pre>
</td>
<td>
<hr />
<pre>
  44 # by 2, and so on.
  45 #
  46 # &lt;provName&gt; must specify the name of the Provider as passed to its super
  47 # class java.security.Provider constructor. This is for providers loaded
  48 # through the ServiceLoader mechanism.
  49 #
  50 # &lt;className&gt; must specify the subclass of the Provider class whose
  51 # constructor sets the values of various properties that are required
  52 # for the Java Security API to look up the algorithms or other
  53 # facilities implemented by the provider. This is for providers loaded
  54 # through classpath.
  55 #
  56 # Note: Providers can be dynamically registered instead by calls to
  57 # either the addProvider or insertProviderAt method in the Security
  58 # class.
  59 
  60 #
  61 # List of providers and their preference orders (see above):
  62 #
  63 #ifdef solaris
<span class="line-added">  64 # Note: The OracleUcrypto provider is deprecated and subject to removal in</span>
<span class="line-added">  65 # a future version of the JDK.</span>
  66 security.provider.tbd=OracleUcrypto
  67 security.provider.tbd=SunPKCS11 ${java.home}/conf/security/sunpkcs11-solaris.cfg
  68 #endif
  69 security.provider.tbd=SUN
  70 security.provider.tbd=SunRsaSign
  71 security.provider.tbd=SunEC
  72 security.provider.tbd=SunJSSE
  73 security.provider.tbd=SunJCE
  74 security.provider.tbd=SunJGSS
  75 security.provider.tbd=SunSASL
  76 security.provider.tbd=XMLDSig
  77 security.provider.tbd=SunPCSC
  78 security.provider.tbd=JdkLDAP
  79 security.provider.tbd=JdkSASL
  80 #ifdef windows
  81 security.provider.tbd=SunMSCAPI
  82 #endif
  83 #ifdef macosx
  84 security.provider.tbd=Apple
  85 #endif
</pre>
<hr />
<pre>
 259 login.configuration.provider=sun.security.provider.ConfigFile
 260 
 261 #
 262 # Default login configuration file
 263 #
 264 #login.config.url.1=file:${user.home}/.java.login.config
 265 
 266 #
 267 # Class to instantiate as the system Policy. This is the name of the class
 268 # that will be used as the Policy object. The system class loader is used to
 269 # locate this class.
 270 #
 271 policy.provider=sun.security.provider.PolicyFile
 272 
 273 # The default is to have a single system-wide policy file,
 274 # and a policy file in the user&#39;s home directory.
 275 #
 276 policy.url.1=file:${java.home}/conf/security/java.policy
 277 policy.url.2=file:${user.home}/.java.policy
 278 
<span class="line-modified"> 279 # Controls whether or not properties are expanded in policy and login</span>
<span class="line-modified"> 280 # configuration files. If set to false, properties (${...}) will not</span>
<span class="line-modified"> 281 # be expanded in policy and login configuration files. If commented out or</span>
<span class="line-added"> 282 # set to an empty string, the default value is &quot;false&quot; for policy files and</span>
<span class="line-added"> 283 # &quot;true&quot; for login configuration files.</span>
 284 #
 285 policy.expandProperties=true
 286 
<span class="line-modified"> 287 # Controls whether or not an extra policy or login configuration file is</span>
<span class="line-modified"> 288 # allowed to be passed on the command line with -Djava.security.policy=somefile</span>
<span class="line-modified"> 289 # or -Djava.security.auth.login.config=somefile. If commented out or set to</span>
<span class="line-added"> 290 # an empty string, the default value is &quot;false&quot;.</span>
 291 #
 292 policy.allowSystemProperty=true
 293 
 294 # whether or not we look into the IdentityScope for trusted Identities
 295 # when encountering a 1.1 signed JAR file. If the identity is found
 296 # and is trusted, we grant it AllPermission. Note: the default policy
 297 # provider (sun.security.provider.PolicyFile) does not support this property.
 298 #
 299 policy.ignoreIdentityScope=false
 300 
 301 #
 302 # Default keystore type.
 303 #
 304 keystore.type=pkcs12
 305 
 306 #
 307 # Controls compatibility mode for JKS and PKCS12 keystore types.
 308 #
 309 # When set to &#39;true&#39;, both JKS and PKCS12 keystore types support loading
 310 # keystore files in either JKS or PKCS12 format. When set to &#39;false&#39; the
</pre>
<hr />
<pre>
 462 #    KDCs in the blacklist are always tried after those not on the list.
 463 #
 464 # tryLess[:max_retries,timeout]
 465 #    KDCs in the blacklist are still tried by their order in the configuration,
 466 #    but with smaller max_retries and timeout values. max_retries and timeout
 467 #    are optional numerical parameters (default 1 and 5000, which means once
 468 #    and 5 seconds). Please notes that if any of the values defined here is
 469 #    more than what is defined in krb5.conf, it will be ignored.
 470 #
 471 # Whenever a KDC is detected as available, it is removed from the blacklist.
 472 # The blacklist is reset when krb5.conf is reloaded. You can add
 473 # refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
 474 # reloaded whenever a JAAS authentication is attempted.
 475 #
 476 # Example,
 477 #   krb5.kdc.bad.policy = tryLast
 478 #   krb5.kdc.bad.policy = tryLess:2,2000
 479 #
 480 krb5.kdc.bad.policy = tryLast
 481 
<span class="line-added"> 482 #</span>
<span class="line-added"> 483 # Kerberos cross-realm referrals (RFC 6806)</span>
<span class="line-added"> 484 #</span>
<span class="line-added"> 485 # OpenJDK&#39;s Kerberos client supports cross-realm referrals as defined in</span>
<span class="line-added"> 486 # RFC 6806. This allows to setup more dynamic environments in which clients</span>
<span class="line-added"> 487 # do not need to know in advance how to reach the realm of a target principal</span>
<span class="line-added"> 488 # (either a user or service).</span>
<span class="line-added"> 489 #</span>
<span class="line-added"> 490 # When a client issues an AS or a TGS request, the &quot;canonicalize&quot; option</span>
<span class="line-added"> 491 # is set to announce support of this feature. A KDC server may fulfill the</span>
<span class="line-added"> 492 # request or reply referring the client to a different one. If referred,</span>
<span class="line-added"> 493 # the client will issue a new request and the cycle repeats.</span>
<span class="line-added"> 494 #</span>
<span class="line-added"> 495 # In addition to referrals, the &quot;canonicalize&quot; option allows the KDC server</span>
<span class="line-added"> 496 # to change the client name in response to an AS request. For security reasons,</span>
<span class="line-added"> 497 # RFC 6806 (section 11) FAST scheme is enforced.</span>
<span class="line-added"> 498 #</span>
<span class="line-added"> 499 # Disable Kerberos cross-realm referrals. Value may be overwritten with a</span>
<span class="line-added"> 500 # System property (-Dsun.security.krb5.disableReferrals).</span>
<span class="line-added"> 501 sun.security.krb5.disableReferrals=false</span>
<span class="line-added"> 502 </span>
<span class="line-added"> 503 # Maximum number of AS or TGS referrals to avoid infinite loops. Value may</span>
<span class="line-added"> 504 # be overwritten with a System property (-Dsun.security.krb5.maxReferrals).</span>
<span class="line-added"> 505 sun.security.krb5.maxReferrals=5</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507 #</span>
<span class="line-added"> 508 # This property contains a list of disabled EC Named Curves that can be included</span>
<span class="line-added"> 509 # in the jdk.[tls|certpath|jar].disabledAlgorithms properties.  To include this</span>
<span class="line-added"> 510 # list in any of the disabledAlgorithms properties, add the property name as</span>
<span class="line-added"> 511 # an entry.</span>
<span class="line-added"> 512 jdk.disabled.namedCurves = secp112r1, secp112r2, secp128r1, secp128r2, \</span>
<span class="line-added"> 513     secp160k1, secp160r1, secp160r2, secp192k1, secp192r1, secp224k1, \</span>
<span class="line-added"> 514     secp224r1, secp256k1, sect113r1, sect113r2, sect131r1, sect131r2, \</span>
<span class="line-added"> 515     sect163k1, sect163r1, sect163r2, sect193r1, sect193r2, sect233k1, \</span>
<span class="line-added"> 516     sect233r1, sect239k1, sect283k1, sect283r1, sect409k1, sect409r1, \</span>
<span class="line-added"> 517     sect571k1, sect571r1, X9.62 c2tnb191v1, X9.62 c2tnb191v2, \</span>
<span class="line-added"> 518     X9.62 c2tnb191v3, X9.62 c2tnb239v1, X9.62 c2tnb239v2, X9.62 c2tnb239v3, \</span>
<span class="line-added"> 519     X9.62 c2tnb359v1, X9.62 c2tnb431r1, X9.62 prime192v2, X9.62 prime192v3, \</span>
<span class="line-added"> 520     X9.62 prime239v1, X9.62 prime239v2, X9.62 prime239v3, brainpoolP256r1, \</span>
<span class="line-added"> 521     brainpoolP320r1, brainpoolP384r1, brainpoolP512r1</span>
<span class="line-added"> 522 </span>
 523 #
 524 # Algorithm restrictions for certification path (CertPath) processing
 525 #
 526 # In some environments, certain algorithms or key lengths may be undesirable
 527 # for certification path building and validation.  For example, &quot;MD2&quot; is
 528 # generally no longer considered to be a secure hash algorithm.  This section
 529 # describes the mechanism for disabling algorithms based on algorithm name
 530 # and/or key length.  This includes algorithms used in certificates, as well
 531 # as revocation information such as CRLs and signed OCSP Responses.
 532 # The syntax of the disabled algorithm string is described as follows:
 533 #   DisabledAlgorithms:
 534 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 535 #
 536 #   DisabledAlgorithm:
<span class="line-modified"> 537 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint } | IncludeProperty</span>
 538 #
 539 #   AlgorithmName:
 540 #       (see below)
 541 #
 542 #   Constraint:
 543 #       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
 544 #       UsageConstraint
 545 #
 546 #   KeySizeConstraint:
 547 #       keySize Operator KeyLength
 548 #
 549 #   Operator:
 550 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 551 #
 552 #   KeyLength:
 553 #       Integer value of the algorithm&#39;s key length in bits
 554 #
 555 #   CAConstraint:
 556 #       jdkCA
 557 #
 558 #   DenyAfterConstraint:
 559 #       denyAfter YYYY-MM-DD
 560 #
 561 #   UsageConstraint:
 562 #       usage [TLSServer] [TLSClient] [SignedJAR]
 563 #
<span class="line-added"> 564 #   IncludeProperty:</span>
<span class="line-added"> 565 #       include &lt;security property&gt;</span>
<span class="line-added"> 566 #</span>
 567 # The &quot;AlgorithmName&quot; is the standard algorithm name of the disabled
<span class="line-modified"> 568 # algorithm. See the Java Security Standard Algorithm Names Specification</span>
<span class="line-modified"> 569 # for information about Standard Algorithm Names.  Matching is</span>
<span class="line-modified"> 570 # performed using a case-insensitive sub-element matching rule.  (For</span>
 571 # example, in &quot;SHA1withECDSA&quot; the sub-elements are &quot;SHA1&quot; for hashing and
 572 # &quot;ECDSA&quot; for signatures.)  If the assertion &quot;AlgorithmName&quot; is a
 573 # sub-element of the certificate algorithm name, the algorithm will be
 574 # rejected during certification path building and validation.  For example,
 575 # the assertion algorithm name &quot;DSA&quot; will disable all certificate algorithms
 576 # that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
 577 # will not disable algorithms related to &quot;ECDSA&quot;.
 578 #
<span class="line-added"> 579 # The &quot;IncludeProperty&quot; allows a implementation-defined security property that</span>
<span class="line-added"> 580 # can be included in the disabledAlgorithms properties.  These properties are</span>
<span class="line-added"> 581 # to help manage common actions easier across multiple disabledAlgorithm</span>
<span class="line-added"> 582 # properties.</span>
<span class="line-added"> 583 # There is one defined security property:  jdk.disabled.NamedCurves</span>
<span class="line-added"> 584 # See the property for more specific details.</span>
<span class="line-added"> 585 #</span>
<span class="line-added"> 586 #</span>
 587 # A &quot;Constraint&quot; defines restrictions on the keys and/or certificates for
 588 # a specified AlgorithmName:
 589 #
 590 #   KeySizeConstraint:
 591 #     keySize Operator KeyLength
 592 #       The constraint requires a key of a valid size range if the
 593 #       &quot;AlgorithmName&quot; is of a key algorithm.  The &quot;KeyLength&quot; indicates
 594 #       the key size specified in number of bits.  For example,
 595 #       &quot;RSA keySize &lt;= 1024&quot; indicates that any RSA key with key size less
 596 #       than or equal to 1024 bits should be disabled, and
 597 #       &quot;RSA keySize &lt; 1024, RSA keySize &gt; 2048&quot; indicates that any RSA key
 598 #       with key size less than 1024 or greater than 2048 should be disabled.
 599 #       This constraint is only used on algorithms that have a key size.
 600 #
 601 #   CAConstraint:
 602 #     jdkCA
 603 #       This constraint prohibits the specified algorithm only if the
 604 #       algorithm is used in a certificate chain that terminates at a marked
 605 #       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
 606 #       constraint is not set, then all chains using the specified algorithm
</pre>
<hr />
<pre>
 639 # chain that terminate at a distribution provided trust anchor and contain
 640 # RSA keys that are less than or equal to 1024 bits, add the following
 641 # constraint:  &quot;RSA keySize &lt;= 1024 &amp; jdkCA&quot;.
 642 #
 643 # All DisabledAlgorithms expressions are processed in the order defined in the
 644 # property.  This requires lower keysize constraints to be specified
 645 # before larger keysize constraints of the same algorithm.  For example:
 646 # &quot;RSA keySize &lt; 1024 &amp; jdkCA, RSA keySize &lt; 2048&quot;.
 647 #
 648 # Note: The algorithm restrictions do not apply to trust anchors or
 649 # self-signed certificates.
 650 #
 651 # Note: This property is currently used by Oracle&#39;s PKIX implementation. It
 652 # is not guaranteed to be examined and used by other implementations.
 653 #
 654 # Example:
 655 #   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
 656 #
 657 #
 658 jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
<span class="line-modified"> 659     RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224, \</span>
<span class="line-added"> 660     include jdk.disabled.namedCurves</span>
 661 
 662 #
 663 # Algorithm restrictions for signed JAR files
 664 #
 665 # In some environments, certain algorithms or key lengths may be undesirable
 666 # for signed JAR validation.  For example, &quot;MD2&quot; is generally no longer
 667 # considered to be a secure hash algorithm.  This section describes the
 668 # mechanism for disabling algorithms based on algorithm name and/or key length.
 669 # JARs signed with any of the disabled algorithms or key sizes will be treated
 670 # as unsigned.
 671 #
 672 # The syntax of the disabled algorithm string is described as follows:
 673 #   DisabledAlgorithms:
 674 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 675 #
 676 #   DisabledAlgorithm:
 677 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 678 #
 679 #   AlgorithmName:
 680 #       (see below)
</pre>
<hr />
<pre>
 684 #
 685 #   KeySizeConstraint:
 686 #       keySize Operator KeyLength
 687 #
 688 #   DenyAfterConstraint:
 689 #       denyAfter YYYY-MM-DD
 690 #
 691 #   Operator:
 692 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 693 #
 694 #   KeyLength:
 695 #       Integer value of the algorithm&#39;s key length in bits
 696 #
 697 # Note: This property is currently used by the JDK Reference
 698 # implementation. It is not guaranteed to be examined and used by other
 699 # implementations.
 700 #
 701 # See &quot;jdk.certpath.disabledAlgorithms&quot; for syntax descriptions.
 702 #
 703 jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &lt; 1024, \
<span class="line-modified"> 704       DSA keySize &lt; 1024, include jdk.disabled.namedCurves</span>
 705 
 706 #
 707 # Algorithm restrictions for Secure Socket Layer/Transport Layer Security
 708 # (SSL/TLS/DTLS) processing
 709 #
 710 # In some environments, certain algorithms or key lengths may be undesirable
 711 # when using SSL/TLS/DTLS.  This section describes the mechanism for disabling
 712 # algorithms during SSL/TLS/DTLS security parameters negotiation, including
<span class="line-modified"> 713 # protocol version negotiation, cipher suites selection, named groups</span>
<span class="line-modified"> 714 # selection, signature schemes selection, peer authentication and key</span>
<span class="line-added"> 715 # exchange mechanisms.</span>
 716 #
 717 # Disabled algorithms will not be negotiated for SSL/TLS connections, even
 718 # if they are enabled explicitly in an application.
 719 #
 720 # For PKI-based peer authentication and key exchange mechanisms, this list
 721 # of disabled algorithms will also be checked during certification path
 722 # building and validation, including algorithms used in certificates, as
 723 # well as revocation information such as CRLs and signed OCSP Responses.
 724 # This is in addition to the jdk.certpath.disabledAlgorithms property above.
 725 #
 726 # See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the
 727 # syntax of the disabled algorithm string.
 728 #
 729 # Note: The algorithm restrictions do not apply to trust anchors or
 730 # self-signed certificates.
 731 #
 732 # Note: This property is currently used by the JDK Reference implementation.
 733 # It is not guaranteed to be examined and used by other implementations.
 734 #
 735 # Example:
<span class="line-modified"> 736 #   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048, \</span>
<span class="line-added"> 737 #       rsa_pkcs1_sha1, secp224r1</span>
 738 jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \
<span class="line-modified"> 739     EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span>
<span class="line-added"> 740     include jdk.disabled.namedCurves</span>
 741 
 742 #
 743 # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
 744 # processing in JSSE implementation.
 745 #
 746 # In some environments, a certain algorithm may be undesirable but it
 747 # cannot be disabled because of its use in legacy applications.  Legacy
 748 # algorithms may still be supported, but applications should not use them
 749 # as the security strength of legacy algorithms are usually not strong enough
 750 # in practice.
 751 #
 752 # During SSL/TLS security parameters negotiation, legacy algorithms will
 753 # not be negotiated unless there are no other candidates.
 754 #
 755 # The syntax of the legacy algorithms string is described as this Java
 756 # BNF-style:
 757 #   LegacyAlgorithms:
 758 #       &quot; LegacyAlgorithm { , LegacyAlgorithm } &quot;
 759 #
 760 #   LegacyAlgorithm:
</pre>
<hr />
<pre>
 762 #
 763 # See the specification of security property &quot;jdk.certpath.disabledAlgorithms&quot;
 764 # for the syntax and description of the &quot;AlgorithmName&quot; notation.
 765 #
 766 # Per SSL/TLS specifications, cipher suites have the form:
 767 #       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 768 # or
 769 #       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 770 #
 771 # For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
 772 # key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
 773 # mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
 774 # algorithm for HMAC.
 775 #
 776 # The LegacyAlgorithm can be one of the following standard algorithm names:
 777 #     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
 778 #     2. JSSE key exchange algorithm name, e.g., RSA
 779 #     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
 780 #     4. JSSE message digest algorithm name, e.g., SHA
 781 #
<span class="line-modified"> 782 # See SSL/TLS specifications and the Java Security Standard Algorithm Names</span>
<span class="line-modified"> 783 # Specification for information about the algorithm names.</span>
 784 #
 785 # Note: If a legacy algorithm is also restricted through the
 786 # jdk.tls.disabledAlgorithms property or the
 787 # java.security.AlgorithmConstraints API (See
 788 # javax.net.ssl.SSLParameters.setAlgorithmConstraints()),
 789 # then the algorithm is completely disabled and will not be negotiated.
 790 #
 791 # Note: This property is currently used by the JDK Reference implementation.
 792 # It is not guaranteed to be examined and used by other implementations.
 793 # There is no guarantee the property will continue to exist or be of the
 794 # same syntax in future releases.
 795 #
 796 # Example:
 797 #   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
 798 #
 799 jdk.tls.legacyAlgorithms= \
 800         K_NULL, C_NULL, M_NULL, \
 801         DH_anon, ECDH_anon, \
 802         RC4_128, RC4_40, DES_CBC, DES40_CBC, \
 803         3DES_EDE_CBC
</pre>
<hr />
<pre>
1066 #    java.rmi.server.UID
1067 #
1068 # RMI Distributed Garbage Collector (DGC) Serial Filter
1069 #
1070 # The filter pattern uses the same format as jdk.serialFilter.
1071 # This filter can override the builtin filter if additional types need to be
1072 # allowed or rejected from the RMI DGC.
1073 #
1074 # Note: This property is currently used by the JDK Reference implementation.
1075 # It is not guaranteed to be examined and used by other implementations.
1076 #
1077 # The builtin DGC filter can approximately be represented as the filter pattern:
1078 #
1079 #sun.rmi.transport.dgcFilter=\
1080 #    java.rmi.server.ObjID;\
1081 #    java.rmi.server.UID;\
1082 #    java.rmi.dgc.VMID;\
1083 #    java.rmi.dgc.Lease;\
1084 #    maxdepth=5;maxarray=10000
1085 





















1086 #
1087 # JCEKS Encrypted Key Serial Filter
1088 #
1089 # This filter, if configured, is used by the JCEKS KeyStore during the
1090 # deserialization of the encrypted Key object stored inside a key entry.
1091 # If not configured or the filter result is UNDECIDED (i.e. none of the patterns
1092 # matches), the filter configured by jdk.serialFilter will be consulted.
1093 #
1094 # If the system property jceks.key.serialFilter is also specified, it supersedes
1095 # the security property value defined here.
1096 #
1097 # The filter pattern uses the same format as jdk.serialFilter. The default
1098 # pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
1099 # and javax.crypto.spec.SecretKeySpec and rejects all the others.
1100 jceks.key.serialFilter = java.base/java.lang.Enum;java.base/java.security.KeyRep;\
1101   java.base/java.security.KeyRep$Type;java.base/javax.crypto.spec.SecretKeySpec;!*
1102 
<span class="line-added">1103 # The iteration count used for password-based encryption (PBE) in JCEKS</span>
<span class="line-added">1104 # keystores. Values in the range 10000 to 5000000 are considered valid.</span>
<span class="line-added">1105 # If the value is out of this range, or is not a number, or is unspecified;</span>
<span class="line-added">1106 # a default of 200000 is used.</span>
<span class="line-added">1107 #</span>
<span class="line-added">1108 # If the system property jdk.jceks.iterationCount is also specified, it</span>
<span class="line-added">1109 # supersedes the security property value defined here.</span>
<span class="line-added">1110 #</span>
<span class="line-added">1111 #jdk.jceks.iterationCount = 200000</span>
<span class="line-added">1112 </span>
1113 #
1114 # PKCS12 KeyStore properties
1115 #
1116 # The following properties, if configured, are used by the PKCS12 KeyStore
1117 # implementation during the creation of a new keystore. Several of the
1118 # properties may also be used when modifying an existing keystore. The
1119 # properties can be overridden by a KeyStore API that specifies its own
1120 # algorithms and parameters.
1121 #
1122 # If an existing PKCS12 keystore is loaded and then stored, the algorithm and
1123 # parameter used to generate the existing Mac will be reused. If the existing
1124 # keystore does not have a Mac, no Mac will be created while storing. If there
1125 # is at least one certificate in the existing keystore, the algorithm and
1126 # parameters used to encrypt the last certificate in the existing keystore will
1127 # be reused to encrypt all certificates while storing. If the last certificate
1128 # in the existing keystore is not encrypted, all certificates will be stored
1129 # unencrypted. If there is no certificate in the existing keystore, any newly
1130 # added certificate will be encrypted (or stored unencrypted if algorithm
1131 # value is &quot;NONE&quot;) using the &quot;keystore.pkcs12.certProtectionAlgorithm&quot; and
1132 # &quot;keystore.pkcs12.certPbeIterationCount&quot; values defined here. Existing private
</pre>
<hr />
<pre>
1193 #
1194 # NOTE: Use caution before setting this property. Setting this property
1195 # exposes sensitive information in Exceptions, which could, for example,
1196 # propagate to untrusted code or be emitted in stack traces that are
1197 # inadvertently disclosed and made accessible over a public network.
1198 #
1199 # The categories are:
1200 #
1201 #  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the
1202 #             java.nio.channels package will contain enhanced exception
1203 #             message information
1204 #
1205 #  jar      - enables more detailed information in the IOExceptions thrown
1206 #             by classes in the java.util.jar package
1207 #
1208 # The property setting in this file can be overridden by a system property of
1209 # the same name, with the same syntax and possible values.
1210 #
1211 #jdk.includeInExceptions=hostInfo,jar
1212 
<span class="line-added">1213 #</span>
<span class="line-added">1214 # Disabled mechanisms for the Simple Authentication and Security Layer (SASL)</span>
<span class="line-added">1215 #</span>
<span class="line-added">1216 # Disabled mechanisms will not be negotiated by both SASL clients and servers.</span>
<span class="line-added">1217 # These mechanisms will be ignored if they are specified in the &quot;mechanisms&quot;</span>
<span class="line-added">1218 # argument of &quot;Sasl.createSaslClient&quot; or the &quot;mechanism&quot; argument of</span>
<span class="line-added">1219 # &quot;Sasl.createSaslServer&quot;.</span>
<span class="line-added">1220 #</span>
<span class="line-added">1221 # The value of this property is a comma-separated list of SASL mechanisms.</span>
<span class="line-added">1222 # The mechanisms are case-sensitive. Whitespaces around the commas are ignored.</span>
<span class="line-added">1223 #</span>
<span class="line-added">1224 # Note: This property is currently used by the JDK Reference implementation.</span>
<span class="line-added">1225 # It is not guaranteed to be examined and used by other implementations.</span>
<span class="line-added">1226 #</span>
<span class="line-added">1227 # Example:</span>
<span class="line-added">1228 #   jdk.sasl.disabledMechanisms=PLAIN, CRAM-MD5, DIGEST-MD5</span>
<span class="line-added">1229 jdk.sasl.disabledMechanisms=</span>
<span class="line-added">1230 </span>
1231 #
1232 # Policies for distrusting Certificate Authorities (CAs).
1233 #
1234 # This is a comma separated value of one or more case-sensitive strings, each
1235 # of which represents a policy for determining if a CA should be distrusted.
1236 # The supported values are:
1237 #
1238 #   SYMANTEC_TLS : Distrust TLS Server certificates anchored by a Symantec
1239 #   root CA and issued after April 16, 2019 unless issued by one of the
1240 #   following subordinate CAs which have a later distrust date:
1241 #     1. Apple IST CA 2 - G1, SHA-256 fingerprint:
1242 #        AC2B922ECFD5E01711772FEA8ED372DE9D1E2245FCE3F57A9CDBEC77296A424B
1243 #        Distrust after December 31, 2019.
1244 #     2. Apple IST CA 8 - G1, SHA-256 fingerprint:
1245 #        A4FE7C7F15155F3F0AEF7AAA83CF6E06DEB97CA3F909DF920AC1490882D488ED
1246 #        Distrust after December 31, 2019.
1247 #
1248 # Leading and trailing whitespace surrounding each value are ignored.
1249 # Unknown values are ignored. If the property is commented out or set to the
1250 # empty String, no policies are enforced.
1251 #
1252 # Note: This property is currently used by the JDK Reference implementation.
1253 # It is not guaranteed to be supported by other SE implementations. Also, this
1254 # property does not override other security properties which can restrict
1255 # certificates such as jdk.tls.disabledAlgorithms or
1256 # jdk.certpath.disabledAlgorithms; those restrictions are still enforced even
1257 # if this property is not enabled.
1258 #
1259 jdk.security.caDistrustPolicies=SYMANTEC_TLS
<span class="line-added">1260 </span>
<span class="line-added">1261 #</span>
<span class="line-added">1262 # FilePermission path canonicalization</span>
<span class="line-added">1263 #</span>
<span class="line-added">1264 # This security property dictates how the path argument is processed and stored</span>
<span class="line-added">1265 # while constructing a FilePermission object. If the value is set to true, the</span>
<span class="line-added">1266 # path argument is canonicalized and FilePermission methods (such as implies,</span>
<span class="line-added">1267 # equals, and hashCode) are implemented based on this canonicalized result.</span>
<span class="line-added">1268 # Otherwise, the path argument is not canonicalized and FilePermission methods are</span>
<span class="line-added">1269 # implemented based on the original input. See the implementation note of the</span>
<span class="line-added">1270 # FilePermission class for more details.</span>
<span class="line-added">1271 #</span>
<span class="line-added">1272 # If a system property of the same name is also specified, it supersedes the</span>
<span class="line-added">1273 # security property value defined here.</span>
<span class="line-added">1274 #</span>
<span class="line-added">1275 # The default value for this property is false.</span>
<span class="line-added">1276 #</span>
<span class="line-added">1277 jdk.io.permissionsUseCanonicalPath=false</span>
<span class="line-added">1278 </span>
<span class="line-added">1279 </span>
<span class="line-added">1280 #</span>
<span class="line-added">1281 # Policies for the proxy_impersonator Kerberos ccache configuration entry</span>
<span class="line-added">1282 #</span>
<span class="line-added">1283 # The proxy_impersonator ccache configuration entry indicates that the ccache</span>
<span class="line-added">1284 # is a synthetic delegated credential for use with S4U2Proxy by an intermediate</span>
<span class="line-added">1285 # server. The ccache file should also contain the TGT of this server and</span>
<span class="line-added">1286 # an evidence ticket from the default principal of the ccache to this server.</span>
<span class="line-added">1287 #</span>
<span class="line-added">1288 # This security property determines how Java uses this configuration entry.</span>
<span class="line-added">1289 # There are 3 possible values:</span>
<span class="line-added">1290 #</span>
<span class="line-added">1291 #  no-impersonate     - Ignore this configuration entry, and always act as</span>
<span class="line-added">1292 #                       the owner of the TGT (if it exists).</span>
<span class="line-added">1293 #</span>
<span class="line-added">1294 #  try-impersonate    - Try impersonation when this configuration entry exists.</span>
<span class="line-added">1295 #                       If no matching TGT or evidence ticket is found,</span>
<span class="line-added">1296 #                       fallback to no-impersonate.</span>
<span class="line-added">1297 #</span>
<span class="line-added">1298 #  always-impersonate - Always impersonate when this configuration entry exists.</span>
<span class="line-added">1299 #                       If no matching TGT or evidence ticket is found,</span>
<span class="line-added">1300 #                       no initial credential is read from the ccache.</span>
<span class="line-added">1301 #</span>
<span class="line-added">1302 # The default value is &quot;always-impersonate&quot;.</span>
<span class="line-added">1303 #</span>
<span class="line-added">1304 # If a system property of the same name is also specified, it supersedes the</span>
<span class="line-added">1305 # security property value defined here.</span>
<span class="line-added">1306 #</span>
<span class="line-added">1307 #jdk.security.krb5.default.initiate.credential=always-impersonate</span>
</pre>
</td>
</tr>
</table>
<center><a href="../../classes/sun/util/resources/TimeZoneNames.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../legal/cldr.md.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
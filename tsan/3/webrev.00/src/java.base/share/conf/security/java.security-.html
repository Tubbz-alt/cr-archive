<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/conf/security/java.security</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # This is the &quot;master security properties file&quot;.
   3 #
   4 # An alternate java.security properties file may be specified
   5 # from the command line via the system property
   6 #
   7 #    -Djava.security.properties=&lt;URL&gt;
   8 #
   9 # This properties file appends to the master security properties file.
  10 # If both properties files specify values for the same key, the value
  11 # from the command-line properties file is selected, as it is the last
  12 # one loaded.
  13 #
  14 # Also, if you specify
  15 #
  16 #    -Djava.security.properties==&lt;URL&gt; (2 equals),
  17 #
  18 # then that properties file completely overrides the master security
  19 # properties file.
  20 #
  21 # To disable the ability to specify an additional properties file from
  22 # the command line, set the key security.overridePropertiesFile
  23 # to false in the master security properties file. It is set to true
  24 # by default.
  25 
  26 # In this file, various security properties are set for use by
  27 # java.security classes. This is where users can statically register
  28 # Cryptography Package Providers (&quot;providers&quot; for short). The term
  29 # &quot;provider&quot; refers to a package or set of packages that supply a
  30 # concrete implementation of a subset of the cryptography aspects of
  31 # the Java Security API. A provider may, for example, implement one or
  32 # more digital signature algorithms or message digest algorithms.
  33 #
  34 # Each provider must implement a subclass of the Provider class.
  35 # To register a provider in this master security properties file,
  36 # specify the provider and priority in the format
  37 #
  38 #    security.provider.&lt;n&gt;=&lt;provName | className&gt;
  39 #
  40 # This declares a provider, and specifies its preference
  41 # order n. The preference order is the order in which providers are
  42 # searched for requested algorithms (when no specific provider is
  43 # requested). The order is 1-based; 1 is the most preferred, followed
  44 # by 2, and so on.
  45 #
  46 # &lt;provName&gt; must specify the name of the Provider as passed to its super
  47 # class java.security.Provider constructor. This is for providers loaded
  48 # through the ServiceLoader mechanism.
  49 #
  50 # &lt;className&gt; must specify the subclass of the Provider class whose
  51 # constructor sets the values of various properties that are required
  52 # for the Java Security API to look up the algorithms or other
  53 # facilities implemented by the provider. This is for providers loaded
  54 # through classpath.
  55 #
  56 # Note: Providers can be dynamically registered instead by calls to
  57 # either the addProvider or insertProviderAt method in the Security
  58 # class.
  59 
  60 #
  61 # List of providers and their preference orders (see above):
  62 #
  63 #ifdef solaris
  64 security.provider.tbd=OracleUcrypto
  65 security.provider.tbd=SunPKCS11 ${java.home}/conf/security/sunpkcs11-solaris.cfg
  66 #endif
  67 security.provider.tbd=SUN
  68 security.provider.tbd=SunRsaSign
  69 security.provider.tbd=SunEC
  70 security.provider.tbd=SunJSSE
  71 security.provider.tbd=SunJCE
  72 security.provider.tbd=SunJGSS
  73 security.provider.tbd=SunSASL
  74 security.provider.tbd=XMLDSig
  75 security.provider.tbd=SunPCSC
  76 security.provider.tbd=JdkLDAP
  77 security.provider.tbd=JdkSASL
  78 #ifdef windows
  79 security.provider.tbd=SunMSCAPI
  80 #endif
  81 #ifdef macosx
  82 security.provider.tbd=Apple
  83 #endif
  84 #ifndef solaris
  85 security.provider.tbd=SunPKCS11
  86 #endif
  87 
  88 #
  89 # A list of preferred providers for specific algorithms. These providers will
  90 # be searched for matching algorithms before the list of registered providers.
  91 # Entries containing errors (parsing, etc) will be ignored. Use the
  92 # -Djava.security.debug=jca property to debug these errors.
  93 #
  94 # The property is a comma-separated list of serviceType.algorithm:provider
  95 # entries. The serviceType (example: &quot;MessageDigest&quot;) is optional, and if
  96 # not specified, the algorithm applies to all service types that support it.
  97 # The algorithm is the standard algorithm name or transformation.
  98 # Transformations can be specified in their full standard name
  99 # (ex: AES/CBC/PKCS5Padding), or as partial matches (ex: AES, AES/CBC).
 100 # The provider is the name of the provider. Any provider that does not
 101 # also appear in the registered list will be ignored.
 102 #
 103 # There is a special serviceType for this property only to group a set of
 104 # algorithms together. The type is &quot;Group&quot; and is followed by an algorithm
 105 # keyword. Groups are to simplify and lessen the entries on the property
 106 # line. Current groups are:
 107 #   Group.SHA2 = SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256
 108 #   Group.HmacSHA2 = HmacSHA224, HmacSHA256, HmacSHA384, HmacSHA512
 109 #   Group.SHA2RSA = SHA224withRSA, SHA256withRSA, SHA384withRSA, SHA512withRSA
 110 #   Group.SHA2DSA = SHA224withDSA, SHA256withDSA, SHA384withDSA, SHA512withDSA
 111 #   Group.SHA2ECDSA = SHA224withECDSA, SHA256withECDSA, SHA384withECDSA, \
 112 #                     SHA512withECDSA
 113 #   Group.SHA3 = SHA3-224, SHA3-256, SHA3-384, SHA3-512
 114 #   Group.HmacSHA3 = HmacSHA3-224, HmacSHA3-256, HmacSHA3-384, HmacSHA3-512
 115 #
 116 # Example:
 117 #   jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, \
 118 #         MessageDigest.SHA-256:SUN, Group.HmacSHA2:SunJCE
 119 #
 120 #ifdef solaris-sparc
 121 # Optional Solaris-SPARC configuration for non-FIPS 140 configurations.
 122 #   jdk.security.provider.preferred=AES:SunJCE, SHA1:SUN, Group.SHA2:SUN, \
 123 #   HmacSHA1:SunJCE, Group.HmacSHA2:SunJCE
 124 #
 125 #endif
 126 #jdk.security.provider.preferred=
 127 
 128 
 129 #
 130 # Sun Provider SecureRandom seed source.
 131 #
 132 # Select the primary source of seed data for the &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot;
 133 # and &quot;DRBG&quot; SecureRandom implementations in the &quot;Sun&quot; provider.
 134 # (Other SecureRandom implementations might also use this property.)
 135 #
 136 # On Unix-like systems (for example, Solaris/Linux/MacOS), the
 137 # &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot; and &quot;DRBG&quot; implementations obtains seed data from
 138 # special device files such as file:/dev/random.
 139 #
 140 # On Windows systems, specifying the URLs &quot;file:/dev/random&quot; or
 141 # &quot;file:/dev/urandom&quot; will enable the native Microsoft CryptoAPI seeding
 142 # mechanism for SHA1PRNG and DRBG.
 143 #
 144 # By default, an attempt is made to use the entropy gathering device
 145 # specified by the &quot;securerandom.source&quot; Security property.  If an
 146 # exception occurs while accessing the specified URL:
 147 #
 148 #     NativePRNG:
 149 #         a default value of /dev/random will be used.  If neither
 150 #         are available, the implementation will be disabled.
 151 #         &quot;file&quot; is the only currently supported protocol type.
 152 #
 153 #     SHA1PRNG and DRBG:
 154 #         the traditional system/thread activity algorithm will be used.
 155 #
 156 # The entropy gathering device can also be specified with the System
 157 # property &quot;java.security.egd&quot;. For example:
 158 #
 159 #   % java -Djava.security.egd=file:/dev/random MainClass
 160 #
 161 # Specifying this System property will override the
 162 # &quot;securerandom.source&quot; Security property.
 163 #
 164 # In addition, if &quot;file:/dev/random&quot; or &quot;file:/dev/urandom&quot; is
 165 # specified, the &quot;NativePRNG&quot; implementation will be more preferred than
 166 # DRBG and SHA1PRNG in the Sun provider.
 167 #
 168 securerandom.source=file:/dev/random
 169 
 170 #
 171 # A list of known strong SecureRandom implementations.
 172 #
 173 # To help guide applications in selecting a suitable strong
 174 # java.security.SecureRandom implementation, Java distributions should
 175 # indicate a list of known strong implementations using the property.
 176 #
 177 # This is a comma-separated list of algorithm and/or algorithm:provider
 178 # entries.
 179 #
 180 #ifdef windows
 181 securerandom.strongAlgorithms=Windows-PRNG:SunMSCAPI,DRBG:SUN
 182 #endif
 183 #ifndef windows
 184 securerandom.strongAlgorithms=NativePRNGBlocking:SUN,DRBG:SUN
 185 #endif
 186 
 187 #
 188 # Sun provider DRBG configuration and default instantiation request.
 189 #
 190 # NIST SP 800-90Ar1 lists several DRBG mechanisms. Each can be configured
 191 # with a DRBG algorithm name, and can be instantiated with a security strength,
 192 # prediction resistance support, etc. This property defines the configuration
 193 # and the default instantiation request of &quot;DRBG&quot; SecureRandom implementations
 194 # in the SUN provider. (Other DRBG implementations can also use this property.)
 195 # Applications can request different instantiation parameters like security
 196 # strength, capability, personalization string using one of the
 197 # getInstance(...,SecureRandomParameters,...) methods with a
 198 # DrbgParameters.Instantiation argument, but other settings such as the
 199 # mechanism and DRBG algorithm names are not currently configurable by any API.
 200 #
 201 # Please note that the SUN implementation of DRBG always supports reseeding.
 202 #
 203 # The value of this property is a comma-separated list of all configurable
 204 # aspects. The aspects can appear in any order but the same aspect can only
 205 # appear at most once. Its BNF-style definition is:
 206 #
 207 #   Value:
 208 #     aspect { &quot;,&quot; aspect }
 209 #
 210 #   aspect:
 211 #     mech_name | algorithm_name | strength | capability | df
 212 #
 213 #   // The DRBG mechanism to use. Default &quot;Hash_DRBG&quot;
 214 #   mech_name:
 215 #     &quot;Hash_DRBG&quot; | &quot;HMAC_DRBG&quot; | &quot;CTR_DRBG&quot;
 216 #
 217 #   // The DRBG algorithm name. The &quot;SHA-***&quot; names are for Hash_DRBG and
 218 #   // HMAC_DRBG, default &quot;SHA-256&quot;. The &quot;AES-***&quot; names are for CTR_DRBG,
 219 #   // default &quot;AES-128&quot; when using the limited cryptographic or &quot;AES-256&quot;
 220 #   // when using the unlimited.
 221 #   algorithm_name:
 222 #     &quot;SHA-224&quot; | &quot;SHA-512/224&quot; | &quot;SHA-256&quot; |
 223 #     &quot;SHA-512/256&quot; | &quot;SHA-384&quot; | &quot;SHA-512&quot; |
 224 #     &quot;AES-128&quot; | &quot;AES-192&quot; | &quot;AES-256&quot;
 225 #
 226 #   // Security strength requested. Default &quot;128&quot;
 227 #   strength:
 228 #     &quot;112&quot; | &quot;128&quot; | &quot;192&quot; | &quot;256&quot;
 229 #
 230 #   // Prediction resistance and reseeding request. Default &quot;none&quot;
 231 #   //  &quot;pr_and_reseed&quot; - Both prediction resistance and reseeding
 232 #   //                    support requested
 233 #   //  &quot;reseed_only&quot;   - Only reseeding support requested
 234 #   //  &quot;none&quot;          - Neither prediction resistance not reseeding
 235 #   //                    support requested
 236 #   pr:
 237 #     &quot;pr_and_reseed&quot; | &quot;reseed_only&quot; | &quot;none&quot;
 238 #
 239 #   // Whether a derivation function should be used. only applicable
 240 #   // to CTR_DRBG. Default &quot;use_df&quot;
 241 #   df:
 242 #     &quot;use_df&quot; | &quot;no_df&quot;
 243 #
 244 # Examples,
 245 #   securerandom.drbg.config=Hash_DRBG,SHA-224,112,none
 246 #   securerandom.drbg.config=CTR_DRBG,AES-256,192,pr_and_reseed,use_df
 247 #
 248 # The default value is an empty string, which is equivalent to
 249 #   securerandom.drbg.config=Hash_DRBG,SHA-256,128,none
 250 #
 251 securerandom.drbg.config=
 252 
 253 #
 254 # Class to instantiate as the javax.security.auth.login.Configuration
 255 # provider.
 256 #
 257 login.configuration.provider=sun.security.provider.ConfigFile
 258 
 259 #
 260 # Default login configuration file
 261 #
 262 #login.config.url.1=file:${user.home}/.java.login.config
 263 
 264 #
 265 # Class to instantiate as the system Policy. This is the name of the class
 266 # that will be used as the Policy object. The system class loader is used to
 267 # locate this class.
 268 #
 269 policy.provider=sun.security.provider.PolicyFile
 270 
 271 # The default is to have a single system-wide policy file,
 272 # and a policy file in the user&#39;s home directory.
 273 #
 274 policy.url.1=file:${java.home}/conf/security/java.policy
 275 policy.url.2=file:${user.home}/.java.policy
 276 
 277 # whether or not we expand properties in the policy file
 278 # if this is set to false, properties (${...}) will not be expanded in policy
 279 # files.
 280 #
 281 policy.expandProperties=true
 282 
 283 # whether or not we allow an extra policy to be passed on the command line
 284 # with -Djava.security.policy=somefile. Comment out this line to disable
 285 # this feature.
 286 #
 287 policy.allowSystemProperty=true
 288 
 289 # whether or not we look into the IdentityScope for trusted Identities
 290 # when encountering a 1.1 signed JAR file. If the identity is found
 291 # and is trusted, we grant it AllPermission. Note: the default policy
 292 # provider (sun.security.provider.PolicyFile) does not support this property.
 293 #
 294 policy.ignoreIdentityScope=false
 295 
 296 #
 297 # Default keystore type.
 298 #
 299 keystore.type=pkcs12
 300 
 301 #
 302 # Controls compatibility mode for JKS and PKCS12 keystore types.
 303 #
 304 # When set to &#39;true&#39;, both JKS and PKCS12 keystore types support loading
 305 # keystore files in either JKS or PKCS12 format. When set to &#39;false&#39; the
 306 # JKS keystore type supports loading only JKS keystore files and the PKCS12
 307 # keystore type supports loading only PKCS12 keystore files.
 308 #
 309 keystore.type.compat=true
 310 
 311 #
 312 # List of comma-separated packages that start with or equal this string
 313 # will cause a security exception to be thrown when passed to the
 314 # SecurityManager::checkPackageAccess method unless the corresponding
 315 # RuntimePermission(&quot;accessClassInPackage.&quot;+package) has been granted.
 316 #
 317 package.access=sun.misc.,\
 318                sun.reflect.,\
 319 
 320 #
 321 # List of comma-separated packages that start with or equal this string
 322 # will cause a security exception to be thrown when passed to the
 323 # SecurityManager::checkPackageDefinition method unless the corresponding
 324 # RuntimePermission(&quot;defineClassInPackage.&quot;+package) has been granted.
 325 #
 326 # By default, none of the class loaders supplied with the JDK call
 327 # checkPackageDefinition.
 328 #
 329 package.definition=sun.misc.,\
 330                    sun.reflect.,\
 331 
 332 #
 333 # Determines whether this properties file can be appended to
 334 # or overridden on the command line via -Djava.security.properties
 335 #
 336 security.overridePropertiesFile=true
 337 
 338 #
 339 # Determines the default key and trust manager factory algorithms for
 340 # the javax.net.ssl package.
 341 #
 342 ssl.KeyManagerFactory.algorithm=SunX509
 343 ssl.TrustManagerFactory.algorithm=PKIX
 344 
 345 #
 346 # The Java-level namelookup cache policy for successful lookups:
 347 #
 348 # any negative value: caching forever
 349 # any positive value: the number of seconds to cache an address for
 350 # zero: do not cache
 351 #
 352 # default value is forever (FOREVER). For security reasons, this
 353 # caching is made forever when a security manager is set. When a security
 354 # manager is not set, the default behavior in this implementation
 355 # is to cache for 30 seconds.
 356 #
 357 # NOTE: setting this to anything other than the default value can have
 358 #       serious security implications. Do not set it unless
 359 #       you are sure you are not exposed to DNS spoofing attack.
 360 #
 361 #networkaddress.cache.ttl=-1
 362 
 363 # The Java-level namelookup cache policy for failed lookups:
 364 #
 365 # any negative value: cache forever
 366 # any positive value: the number of seconds to cache negative lookup results
 367 # zero: do not cache
 368 #
 369 # In some Microsoft Windows networking environments that employ
 370 # the WINS name service in addition to DNS, name service lookups
 371 # that fail may take a noticeably long time to return (approx. 5 seconds).
 372 # For this reason the default caching policy is to maintain these
 373 # results for 10 seconds.
 374 #
 375 networkaddress.cache.negative.ttl=10
 376 
 377 #
 378 # Properties to configure OCSP for certificate revocation checking
 379 #
 380 
 381 # Enable OCSP
 382 #
 383 # By default, OCSP is not used for certificate revocation checking.
 384 # This property enables the use of OCSP when set to the value &quot;true&quot;.
 385 #
 386 # NOTE: SocketPermission is required to connect to an OCSP responder.
 387 #
 388 # Example,
 389 #   ocsp.enable=true
 390 
 391 #
 392 # Location of the OCSP responder
 393 #
 394 # By default, the location of the OCSP responder is determined implicitly
 395 # from the certificate being validated. This property explicitly specifies
 396 # the location of the OCSP responder. The property is used when the
 397 # Authority Information Access extension (defined in RFC 5280) is absent
 398 # from the certificate or when it requires overriding.
 399 #
 400 # Example,
 401 #   ocsp.responderURL=http://ocsp.example.net:80
 402 
 403 #
 404 # Subject name of the OCSP responder&#39;s certificate
 405 #
 406 # By default, the certificate of the OCSP responder is that of the issuer
 407 # of the certificate being validated. This property identifies the certificate
 408 # of the OCSP responder when the default does not apply. Its value is a string
 409 # distinguished name (defined in RFC 2253) which identifies a certificate in
 410 # the set of certificates supplied during cert path validation. In cases where
 411 # the subject name alone is not sufficient to uniquely identify the certificate
 412 # then both the &quot;ocsp.responderCertIssuerName&quot; and
 413 # &quot;ocsp.responderCertSerialNumber&quot; properties must be used instead. When this
 414 # property is set then those two properties are ignored.
 415 #
 416 # Example,
 417 #   ocsp.responderCertSubjectName=CN=OCSP Responder, O=XYZ Corp
 418 
 419 #
 420 # Issuer name of the OCSP responder&#39;s certificate
 421 #
 422 # By default, the certificate of the OCSP responder is that of the issuer
 423 # of the certificate being validated. This property identifies the certificate
 424 # of the OCSP responder when the default does not apply. Its value is a string
 425 # distinguished name (defined in RFC 2253) which identifies a certificate in
 426 # the set of certificates supplied during cert path validation. When this
 427 # property is set then the &quot;ocsp.responderCertSerialNumber&quot; property must also
 428 # be set. When the &quot;ocsp.responderCertSubjectName&quot; property is set then this
 429 # property is ignored.
 430 #
 431 # Example,
 432 #   ocsp.responderCertIssuerName=CN=Enterprise CA, O=XYZ Corp
 433 
 434 #
 435 # Serial number of the OCSP responder&#39;s certificate
 436 #
 437 # By default, the certificate of the OCSP responder is that of the issuer
 438 # of the certificate being validated. This property identifies the certificate
 439 # of the OCSP responder when the default does not apply. Its value is a string
 440 # of hexadecimal digits (colon or space separators may be present) which
 441 # identifies a certificate in the set of certificates supplied during cert path
 442 # validation. When this property is set then the &quot;ocsp.responderCertIssuerName&quot;
 443 # property must also be set. When the &quot;ocsp.responderCertSubjectName&quot; property
 444 # is set then this property is ignored.
 445 #
 446 # Example,
 447 #   ocsp.responderCertSerialNumber=2A:FF:00
 448 
 449 #
 450 # Policy for failed Kerberos KDC lookups:
 451 #
 452 # When a KDC is unavailable (network error, service failure, etc), it is
 453 # put inside a blacklist and accessed less often for future requests. The
 454 # value (case-insensitive) for this policy can be:
 455 #
 456 # tryLast
 457 #    KDCs in the blacklist are always tried after those not on the list.
 458 #
 459 # tryLess[:max_retries,timeout]
 460 #    KDCs in the blacklist are still tried by their order in the configuration,
 461 #    but with smaller max_retries and timeout values. max_retries and timeout
 462 #    are optional numerical parameters (default 1 and 5000, which means once
 463 #    and 5 seconds). Please notes that if any of the values defined here is
 464 #    more than what is defined in krb5.conf, it will be ignored.
 465 #
 466 # Whenever a KDC is detected as available, it is removed from the blacklist.
 467 # The blacklist is reset when krb5.conf is reloaded. You can add
 468 # refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
 469 # reloaded whenever a JAAS authentication is attempted.
 470 #
 471 # Example,
 472 #   krb5.kdc.bad.policy = tryLast
 473 #   krb5.kdc.bad.policy = tryLess:2,2000
 474 #
 475 krb5.kdc.bad.policy = tryLast
 476 
 477 #
 478 # Algorithm restrictions for certification path (CertPath) processing
 479 #
 480 # In some environments, certain algorithms or key lengths may be undesirable
 481 # for certification path building and validation.  For example, &quot;MD2&quot; is
 482 # generally no longer considered to be a secure hash algorithm.  This section
 483 # describes the mechanism for disabling algorithms based on algorithm name
 484 # and/or key length.  This includes algorithms used in certificates, as well
 485 # as revocation information such as CRLs and signed OCSP Responses.
 486 # The syntax of the disabled algorithm string is described as follows:
 487 #   DisabledAlgorithms:
 488 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 489 #
 490 #   DisabledAlgorithm:
 491 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 492 #
 493 #   AlgorithmName:
 494 #       (see below)
 495 #
 496 #   Constraint:
 497 #       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
 498 #       UsageConstraint
 499 #
 500 #   KeySizeConstraint:
 501 #       keySize Operator KeyLength
 502 #
 503 #   Operator:
 504 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 505 #
 506 #   KeyLength:
 507 #       Integer value of the algorithm&#39;s key length in bits
 508 #
 509 #   CAConstraint:
 510 #       jdkCA
 511 #
 512 #   DenyAfterConstraint:
 513 #       denyAfter YYYY-MM-DD
 514 #
 515 #   UsageConstraint:
 516 #       usage [TLSServer] [TLSClient] [SignedJAR]
 517 #
 518 # The &quot;AlgorithmName&quot; is the standard algorithm name of the disabled
 519 # algorithm. See &quot;Java Cryptography Architecture Standard Algorithm Name
 520 # Documentation&quot; for information about Standard Algorithm Names.  Matching
 521 # is performed using a case-insensitive sub-element matching rule.  (For
 522 # example, in &quot;SHA1withECDSA&quot; the sub-elements are &quot;SHA1&quot; for hashing and
 523 # &quot;ECDSA&quot; for signatures.)  If the assertion &quot;AlgorithmName&quot; is a
 524 # sub-element of the certificate algorithm name, the algorithm will be
 525 # rejected during certification path building and validation.  For example,
 526 # the assertion algorithm name &quot;DSA&quot; will disable all certificate algorithms
 527 # that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
 528 # will not disable algorithms related to &quot;ECDSA&quot;.
 529 #
 530 # A &quot;Constraint&quot; defines restrictions on the keys and/or certificates for
 531 # a specified AlgorithmName:
 532 #
 533 #   KeySizeConstraint:
 534 #     keySize Operator KeyLength
 535 #       The constraint requires a key of a valid size range if the
 536 #       &quot;AlgorithmName&quot; is of a key algorithm.  The &quot;KeyLength&quot; indicates
 537 #       the key size specified in number of bits.  For example,
 538 #       &quot;RSA keySize &lt;= 1024&quot; indicates that any RSA key with key size less
 539 #       than or equal to 1024 bits should be disabled, and
 540 #       &quot;RSA keySize &lt; 1024, RSA keySize &gt; 2048&quot; indicates that any RSA key
 541 #       with key size less than 1024 or greater than 2048 should be disabled.
 542 #       This constraint is only used on algorithms that have a key size.
 543 #
 544 #   CAConstraint:
 545 #     jdkCA
 546 #       This constraint prohibits the specified algorithm only if the
 547 #       algorithm is used in a certificate chain that terminates at a marked
 548 #       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
 549 #       constraint is not set, then all chains using the specified algorithm
 550 #       are restricted.  jdkCA may only be used once in a DisabledAlgorithm
 551 #       expression.
 552 #       Example:  To apply this constraint to SHA-1 certificates, include
 553 #       the following:  &quot;SHA1 jdkCA&quot;
 554 #
 555 #   DenyAfterConstraint:
 556 #     denyAfter YYYY-MM-DD
 557 #       This constraint prohibits a certificate with the specified algorithm
 558 #       from being used after the date regardless of the certificate&#39;s
 559 #       validity.  JAR files that are signed and timestamped before the
 560 #       constraint date with certificates containing the disabled algorithm
 561 #       will not be restricted.  The date is processed in the UTC timezone.
 562 #       This constraint can only be used once in a DisabledAlgorithm
 563 #       expression.
 564 #       Example:  To deny usage of RSA 2048 bit certificates after Feb 3 2020,
 565 #       use the following:  &quot;RSA keySize == 2048 &amp; denyAfter 2020-02-03&quot;
 566 #
 567 #   UsageConstraint:
 568 #     usage [TLSServer] [TLSClient] [SignedJAR]
 569 #       This constraint prohibits the specified algorithm for
 570 #       a specified usage.  This should be used when disabling an algorithm
 571 #       for all usages is not practical. &#39;TLSServer&#39; restricts the algorithm
 572 #       in TLS server certificate chains when server authentication is
 573 #       performed. &#39;TLSClient&#39; restricts the algorithm in TLS client
 574 #       certificate chains when client authentication is performed.
 575 #       &#39;SignedJAR&#39; constrains use of certificates in signed jar files.
 576 #       The usage type follows the keyword and more than one usage type can
 577 #       be specified with a whitespace delimiter.
 578 #       Example:  &quot;SHA1 usage TLSServer TLSClient&quot;
 579 #
 580 # When an algorithm must satisfy more than one constraint, it must be
 581 # delimited by an ampersand &#39;&amp;&#39;.  For example, to restrict certificates in a
 582 # chain that terminate at a distribution provided trust anchor and contain
 583 # RSA keys that are less than or equal to 1024 bits, add the following
 584 # constraint:  &quot;RSA keySize &lt;= 1024 &amp; jdkCA&quot;.
 585 #
 586 # All DisabledAlgorithms expressions are processed in the order defined in the
 587 # property.  This requires lower keysize constraints to be specified
 588 # before larger keysize constraints of the same algorithm.  For example:
 589 # &quot;RSA keySize &lt; 1024 &amp; jdkCA, RSA keySize &lt; 2048&quot;.
 590 #
 591 # Note: The algorithm restrictions do not apply to trust anchors or
 592 # self-signed certificates.
 593 #
 594 # Note: This property is currently used by Oracle&#39;s PKIX implementation. It
 595 # is not guaranteed to be examined and used by other implementations.
 596 #
 597 # Example:
 598 #   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
 599 #
 600 #
 601 jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
 602     RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224
 603 
 604 #
 605 # Algorithm restrictions for signed JAR files
 606 #
 607 # In some environments, certain algorithms or key lengths may be undesirable
 608 # for signed JAR validation.  For example, &quot;MD2&quot; is generally no longer
 609 # considered to be a secure hash algorithm.  This section describes the
 610 # mechanism for disabling algorithms based on algorithm name and/or key length.
 611 # JARs signed with any of the disabled algorithms or key sizes will be treated
 612 # as unsigned.
 613 #
 614 # The syntax of the disabled algorithm string is described as follows:
 615 #   DisabledAlgorithms:
 616 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 617 #
 618 #   DisabledAlgorithm:
 619 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 620 #
 621 #   AlgorithmName:
 622 #       (see below)
 623 #
 624 #   Constraint:
 625 #       KeySizeConstraint | DenyAfterConstraint
 626 #
 627 #   KeySizeConstraint:
 628 #       keySize Operator KeyLength
 629 #
 630 #   DenyAfterConstraint:
 631 #       denyAfter YYYY-MM-DD
 632 #
 633 #   Operator:
 634 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 635 #
 636 #   KeyLength:
 637 #       Integer value of the algorithm&#39;s key length in bits
 638 #
 639 # Note: This property is currently used by the JDK Reference
 640 # implementation. It is not guaranteed to be examined and used by other
 641 # implementations.
 642 #
 643 # See &quot;jdk.certpath.disabledAlgorithms&quot; for syntax descriptions.
 644 #
 645 jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &lt; 1024, \
 646       DSA keySize &lt; 1024
 647 
 648 #
 649 # Algorithm restrictions for Secure Socket Layer/Transport Layer Security
 650 # (SSL/TLS/DTLS) processing
 651 #
 652 # In some environments, certain algorithms or key lengths may be undesirable
 653 # when using SSL/TLS/DTLS.  This section describes the mechanism for disabling
 654 # algorithms during SSL/TLS/DTLS security parameters negotiation, including
 655 # protocol version negotiation, cipher suites selection, peer authentication
 656 # and key exchange mechanisms.
 657 #
 658 # Disabled algorithms will not be negotiated for SSL/TLS connections, even
 659 # if they are enabled explicitly in an application.
 660 #
 661 # For PKI-based peer authentication and key exchange mechanisms, this list
 662 # of disabled algorithms will also be checked during certification path
 663 # building and validation, including algorithms used in certificates, as
 664 # well as revocation information such as CRLs and signed OCSP Responses.
 665 # This is in addition to the jdk.certpath.disabledAlgorithms property above.
 666 #
 667 # See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the
 668 # syntax of the disabled algorithm string.
 669 #
 670 # Note: The algorithm restrictions do not apply to trust anchors or
 671 # self-signed certificates.
 672 #
 673 # Note: This property is currently used by the JDK Reference implementation.
 674 # It is not guaranteed to be examined and used by other implementations.
 675 #
 676 # Example:
 677 #   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048
 678 jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \
 679     EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL
 680 
 681 #
 682 # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
 683 # processing in JSSE implementation.
 684 #
 685 # In some environments, a certain algorithm may be undesirable but it
 686 # cannot be disabled because of its use in legacy applications.  Legacy
 687 # algorithms may still be supported, but applications should not use them
 688 # as the security strength of legacy algorithms are usually not strong enough
 689 # in practice.
 690 #
 691 # During SSL/TLS security parameters negotiation, legacy algorithms will
 692 # not be negotiated unless there are no other candidates.
 693 #
 694 # The syntax of the legacy algorithms string is described as this Java
 695 # BNF-style:
 696 #   LegacyAlgorithms:
 697 #       &quot; LegacyAlgorithm { , LegacyAlgorithm } &quot;
 698 #
 699 #   LegacyAlgorithm:
 700 #       AlgorithmName (standard JSSE algorithm name)
 701 #
 702 # See the specification of security property &quot;jdk.certpath.disabledAlgorithms&quot;
 703 # for the syntax and description of the &quot;AlgorithmName&quot; notation.
 704 #
 705 # Per SSL/TLS specifications, cipher suites have the form:
 706 #       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 707 # or
 708 #       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 709 #
 710 # For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
 711 # key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
 712 # mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
 713 # algorithm for HMAC.
 714 #
 715 # The LegacyAlgorithm can be one of the following standard algorithm names:
 716 #     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
 717 #     2. JSSE key exchange algorithm name, e.g., RSA
 718 #     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
 719 #     4. JSSE message digest algorithm name, e.g., SHA
 720 #
 721 # See SSL/TLS specifications and &quot;Java Cryptography Architecture Standard
 722 # Algorithm Name Documentation&quot; for information about the algorithm names.
 723 #
 724 # Note: If a legacy algorithm is also restricted through the
 725 # jdk.tls.disabledAlgorithms property or the
 726 # java.security.AlgorithmConstraints API (See
 727 # javax.net.ssl.SSLParameters.setAlgorithmConstraints()),
 728 # then the algorithm is completely disabled and will not be negotiated.
 729 #
 730 # Note: This property is currently used by the JDK Reference implementation.
 731 # It is not guaranteed to be examined and used by other implementations.
 732 # There is no guarantee the property will continue to exist or be of the
 733 # same syntax in future releases.
 734 #
 735 # Example:
 736 #   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
 737 #
 738 jdk.tls.legacyAlgorithms= \
 739         K_NULL, C_NULL, M_NULL, \
 740         DH_anon, ECDH_anon, \
 741         RC4_128, RC4_40, DES_CBC, DES40_CBC, \
 742         3DES_EDE_CBC
 743 
 744 #
 745 # The pre-defined default finite field Diffie-Hellman ephemeral (DHE)
 746 # parameters for Transport Layer Security (SSL/TLS/DTLS) processing.
 747 #
 748 # In traditional SSL/TLS/DTLS connections where finite field DHE parameters
 749 # negotiation mechanism is not used, the server offers the client group
 750 # parameters, base generator g and prime modulus p, for DHE key exchange.
 751 # It is recommended to use dynamic group parameters.  This property defines
 752 # a mechanism that allows you to specify custom group parameters.
 753 #
 754 # The syntax of this property string is described as this Java BNF-style:
 755 #   DefaultDHEParameters:
 756 #       DefinedDHEParameters { , DefinedDHEParameters }
 757 #
 758 #   DefinedDHEParameters:
 759 #       &quot;{&quot; DHEPrimeModulus , DHEBaseGenerator &quot;}&quot;
 760 #
 761 #   DHEPrimeModulus:
 762 #       HexadecimalDigits
 763 #
 764 #   DHEBaseGenerator:
 765 #       HexadecimalDigits
 766 #
 767 #   HexadecimalDigits:
 768 #       HexadecimalDigit { HexadecimalDigit }
 769 #
 770 #   HexadecimalDigit: one of
 771 #       0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
 772 #
 773 # Whitespace characters are ignored.
 774 #
 775 # The &quot;DefinedDHEParameters&quot; defines the custom group parameters, prime
 776 # modulus p and base generator g, for a particular size of prime modulus p.
 777 # The &quot;DHEPrimeModulus&quot; defines the hexadecimal prime modulus p, and the
 778 # &quot;DHEBaseGenerator&quot; defines the hexadecimal base generator g of a group
 779 # parameter.  It is recommended to use safe primes for the custom group
 780 # parameters.
 781 #
 782 # If this property is not defined or the value is empty, the underlying JSSE
 783 # provider&#39;s default group parameter is used for each connection.
 784 #
 785 # If the property value does not follow the grammar, or a particular group
 786 # parameter is not valid, the connection will fall back and use the
 787 # underlying JSSE provider&#39;s default group parameter.
 788 #
 789 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 790 # is not guaranteed to be examined and used by other implementations.
 791 #
 792 # Example:
 793 #   jdk.tls.server.defaultDHEParameters=
 794 #       { \
 795 #       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 \
 796 #       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD \
 797 #       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245 \
 798 #       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED \
 799 #       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381 \
 800 #       FFFFFFFF FFFFFFFF, 2}
 801 
 802 #
 803 # TLS key limits on symmetric cryptographic algorithms
 804 #
 805 # This security property sets limits on algorithms key usage in TLS 1.3.
 806 # When the amount of data encrypted exceeds the algorithm value listed below,
 807 # a KeyUpdate message will trigger a key change.  This is for symmetric ciphers
 808 # with TLS 1.3 only.
 809 #
 810 # The syntax for the property is described below:
 811 #   KeyLimits:
 812 #       &quot; KeyLimit { , KeyLimit } &quot;
 813 #
 814 #   WeakKeyLimit:
 815 #       AlgorithmName Action Length
 816 #
 817 #   AlgorithmName:
 818 #       A full algorithm transformation.
 819 #
 820 #   Action:
 821 #       KeyUpdate
 822 #
 823 #   Length:
 824 #       The amount of encrypted data in a session before the Action occurs
 825 #       This value may be an integer value in bytes, or as a power of two, 2^29.
 826 #
 827 #   KeyUpdate:
 828 #       The TLS 1.3 KeyUpdate handshake process begins when the Length amount
 829 #       is fulfilled.
 830 #
 831 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 832 # is not guaranteed to be examined and used by other implementations.
 833 #
 834 jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37
 835 
 836 #
 837 # Cryptographic Jurisdiction Policy defaults
 838 #
 839 # Import and export control rules on cryptographic software vary from
 840 # country to country.  By default, Java provides two different sets of
 841 # cryptographic policy files[1]:
 842 #
 843 #     unlimited:  These policy files contain no restrictions on cryptographic
 844 #                 strengths or algorithms
 845 #
 846 #     limited:    These policy files contain more restricted cryptographic
 847 #                 strengths
 848 #
 849 # The default setting is determined by the value of the &quot;crypto.policy&quot;
 850 # Security property below. If your country or usage requires the
 851 # traditional restrictive policy, the &quot;limited&quot; Java cryptographic
 852 # policy is still available and may be appropriate for your environment.
 853 #
 854 # If you have restrictions that do not fit either use case mentioned
 855 # above, Java provides the capability to customize these policy files.
 856 # The &quot;crypto.policy&quot; security property points to a subdirectory
 857 # within &lt;java-home&gt;/conf/security/policy/ which can be customized.
 858 # Please see the &lt;java-home&gt;/conf/security/policy/README.txt file or consult
 859 # the Java Security Guide/JCA documentation for more information.
 860 #
 861 # YOU ARE ADVISED TO CONSULT YOUR EXPORT/IMPORT CONTROL COUNSEL OR ATTORNEY
 862 # TO DETERMINE THE EXACT REQUIREMENTS.
 863 #
 864 # [1] Please note that the JCE for Java SE, including the JCE framework,
 865 # cryptographic policy files, and standard JCE providers provided with
 866 # the Java SE, have been reviewed and approved for export as mass market
 867 # encryption item by the US Bureau of Industry and Security.
 868 #
 869 # Note: This property is currently used by the JDK Reference implementation.
 870 # It is not guaranteed to be examined and used by other implementations.
 871 #
 872 crypto.policy=crypto.policydir-tbd
 873 
 874 #
 875 # The policy for the XML Signature secure validation mode. The mode is
 876 # enabled by setting the property &quot;org.jcp.xml.dsig.secureValidation&quot; to
 877 # true with the javax.xml.crypto.XMLCryptoContext.setProperty() method,
 878 # or by running the code with a SecurityManager.
 879 #
 880 #   Policy:
 881 #       Constraint {&quot;,&quot; Constraint }
 882 #   Constraint:
 883 #       AlgConstraint | MaxTransformsConstraint | MaxReferencesConstraint |
 884 #       ReferenceUriSchemeConstraint | KeySizeConstraint | OtherConstraint
 885 #   AlgConstraint
 886 #       &quot;disallowAlg&quot; Uri
 887 #   MaxTransformsConstraint:
 888 #       &quot;maxTransforms&quot; Integer
 889 #   MaxReferencesConstraint:
 890 #       &quot;maxReferences&quot; Integer
 891 #   ReferenceUriSchemeConstraint:
 892 #       &quot;disallowReferenceUriSchemes&quot; String { String }
 893 #   KeySizeConstraint:
 894 #       &quot;minKeySize&quot; KeyAlg Integer
 895 #   OtherConstraint:
 896 #       &quot;noDuplicateIds&quot; | &quot;noRetrievalMethodLoops&quot;
 897 #
 898 # For AlgConstraint, Uri is the algorithm URI String that is not allowed.
 899 # See the XML Signature Recommendation for more information on algorithm
 900 # URI Identifiers. For KeySizeConstraint, KeyAlg is the standard algorithm
 901 # name of the key type (ex: &quot;RSA&quot;). If the MaxTransformsConstraint,
 902 # MaxReferencesConstraint or KeySizeConstraint (for the same key type) is
 903 # specified more than once, only the last entry is enforced.
 904 #
 905 # Note: This property is currently used by the JDK Reference implementation. It
 906 # is not guaranteed to be examined and used by other implementations.
 907 #
 908 jdk.xml.dsig.secureValidationPolicy=\
 909     disallowAlg http://www.w3.org/TR/1999/REC-xslt-19991116,\
 910     disallowAlg http://www.w3.org/2001/04/xmldsig-more#rsa-md5,\
 911     disallowAlg http://www.w3.org/2001/04/xmldsig-more#hmac-md5,\
 912     disallowAlg http://www.w3.org/2001/04/xmldsig-more#md5,\
 913     maxTransforms 5,\
 914     maxReferences 30,\
 915     disallowReferenceUriSchemes file http https,\
 916     minKeySize RSA 1024,\
 917     minKeySize DSA 1024,\
 918     minKeySize EC 224,\
 919     noDuplicateIds,\
 920     noRetrievalMethodLoops
 921 
 922 #
 923 # Serialization system-wide filter
 924 #
 925 # A filter, if configured, is used by java.io.ObjectInputStream during
 926 # deserialization to check the contents of the stream.
 927 # A filter is configured as a sequence of patterns, each pattern is either
 928 # matched against the name of a class in the stream or defines a limit.
 929 # Patterns are separated by &quot;;&quot; (semicolon).
 930 # Whitespace is significant and is considered part of the pattern.
 931 #
 932 # If the system property jdk.serialFilter is also specified, it supersedes
 933 # the security property value defined here.
 934 #
 935 # If a pattern includes a &quot;=&quot;, it sets a limit.
 936 # If a limit appears more than once the last value is used.
 937 # Limits are checked before classes regardless of the order in the
 938 # sequence of patterns.
 939 # If any of the limits are exceeded, the filter status is REJECTED.
 940 #
 941 #   maxdepth=value - the maximum depth of a graph
 942 #   maxrefs=value  - the maximum number of internal references
 943 #   maxbytes=value - the maximum number of bytes in the input stream
 944 #   maxarray=value - the maximum array length allowed
 945 #
 946 # Other patterns, from left to right, match the class or package name as
 947 # returned from Class.getName.
 948 # If the class is an array type, the class or package to be matched is the
 949 # element type.
 950 # Arrays of any number of dimensions are treated the same as the element type.
 951 # For example, a pattern of &quot;!example.Foo&quot;, rejects creation of any instance or
 952 # array of example.Foo.
 953 #
 954 # If the pattern starts with &quot;!&quot;, the status is REJECTED if the remaining
 955 # pattern is matched; otherwise the status is ALLOWED if the pattern matches.
 956 # If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the
 957 # module name;
 958 #   if the module name matches the module name of the class then
 959 #   the remaining pattern is matched with the class name.
 960 #   If there is no &quot;/&quot;, the module name is not compared.
 961 # If the pattern ends with &quot;.**&quot; it matches any class in the package and all
 962 # subpackages.
 963 # If the pattern ends with &quot;.*&quot; it matches any class in the package.
 964 # If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a
 965 # prefix.
 966 # If the pattern is equal to the class name, it matches.
 967 # Otherwise, the status is UNDECIDED.
 968 #
 969 #jdk.serialFilter=pattern;pattern
 970 
 971 #
 972 # RMI Registry Serial Filter
 973 #
 974 # The filter pattern uses the same format as jdk.serialFilter.
 975 # This filter can override the builtin filter if additional types need to be
 976 # allowed or rejected from the RMI Registry or to decrease limits but not
 977 # to increase limits.
 978 # If the limits (maxdepth, maxrefs, or maxbytes) are exceeded, the object is rejected.
 979 #
 980 # Each non-array type is allowed or rejected if it matches one of the patterns,
 981 # evaluated from left to right, and is otherwise allowed. Arrays of any
 982 # component type, including subarrays and arrays of primitives, are allowed.
 983 #
 984 # Array construction of any component type, including subarrays and arrays of
 985 # primitives, are allowed unless the length is greater than the maxarray limit.
 986 # The filter is applied to each array element.
 987 #
 988 # Note: This property is currently used by the JDK Reference implementation.
 989 # It is not guaranteed to be examined and used by other implementations.
 990 #
 991 # The built-in filter allows subclasses of allowed classes and
 992 # can approximately be represented as the pattern:
 993 #
 994 #sun.rmi.registry.registryFilter=\
 995 #    maxarray=1000000;\
 996 #    maxdepth=20;\
 997 #    java.lang.String;\
 998 #    java.lang.Number;\
 999 #    java.lang.reflect.Proxy;\
1000 #    java.rmi.Remote;\
1001 #    sun.rmi.server.UnicastRef;\
1002 #    sun.rmi.server.RMIClientSocketFactory;\
1003 #    sun.rmi.server.RMIServerSocketFactory;\
1004 #    java.rmi.activation.ActivationID;\
1005 #    java.rmi.server.UID
1006 #
1007 # RMI Distributed Garbage Collector (DGC) Serial Filter
1008 #
1009 # The filter pattern uses the same format as jdk.serialFilter.
1010 # This filter can override the builtin filter if additional types need to be
1011 # allowed or rejected from the RMI DGC.
1012 #
1013 # Note: This property is currently used by the JDK Reference implementation.
1014 # It is not guaranteed to be examined and used by other implementations.
1015 #
1016 # The builtin DGC filter can approximately be represented as the filter pattern:
1017 #
1018 #sun.rmi.transport.dgcFilter=\
1019 #    java.rmi.server.ObjID;\
1020 #    java.rmi.server.UID;\
1021 #    java.rmi.dgc.VMID;\
1022 #    java.rmi.dgc.Lease;\
1023 #    maxdepth=5;maxarray=10000
1024 
1025 # CORBA ORBIorTypeCheckRegistryFilter
1026 # Type check enhancement for ORB::string_to_object processing
1027 #
1028 # An IOR type check filter, if configured, is used by an ORB during
1029 # an ORB::string_to_object invocation to check the veracity of the type encoded
1030 # in the ior string.
1031 #
1032 # The filter pattern consists of a semi-colon separated list of class names.
1033 # The configured list contains the binary class names of the IDL interface types
1034 # corresponding to the IDL stub class to be instantiated.
1035 # As such, a filter specifies a list of IDL stub classes that will be
1036 # allowed by an ORB when an ORB::string_to_object is invoked.
1037 # It is used to specify a white list configuration of acceptable
1038 # IDL stub types which may be contained in a stringified IOR
1039 # parameter passed as input to an ORB::string_to_object method.
1040 #
1041 # Note: This property is currently used by the JDK Reference implementation.
1042 # It is not guaranteed to be examined and used by other implementations.
1043 #
1044 #com.sun.CORBA.ORBIorTypeCheckRegistryFilter=binary_class_name;binary_class_name
1045 
1046 #
1047 # JCEKS Encrypted Key Serial Filter
1048 #
1049 # This filter, if configured, is used by the JCEKS KeyStore during the
1050 # deserialization of the encrypted Key object stored inside a key entry.
1051 # If not configured or the filter result is UNDECIDED (i.e. none of the patterns
1052 # matches), the filter configured by jdk.serialFilter will be consulted.
1053 #
1054 # If the system property jceks.key.serialFilter is also specified, it supersedes
1055 # the security property value defined here.
1056 #
1057 # The filter pattern uses the same format as jdk.serialFilter. The default
1058 # pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
1059 # and javax.crypto.spec.SecretKeySpec and rejects all the others.
1060 jceks.key.serialFilter = java.base/java.lang.Enum;java.base/java.security.KeyRep;\
1061   java.base/java.security.KeyRep$Type;java.base/javax.crypto.spec.SecretKeySpec;!*
1062 
1063 #
1064 # PKCS12 KeyStore properties
1065 #
1066 # The following properties, if configured, are used by the PKCS12 KeyStore
1067 # implementation during the creation of a new keystore. Several of the
1068 # properties may also be used when modifying an existing keystore. The
1069 # properties can be overridden by a KeyStore API that specifies its own
1070 # algorithms and parameters.
1071 #
1072 # If an existing PKCS12 keystore is loaded and then stored, the algorithm and
1073 # parameter used to generate the existing Mac will be reused. If the existing
1074 # keystore does not have a Mac, no Mac will be created while storing. If there
1075 # is at least one certificate in the existing keystore, the algorithm and
1076 # parameters used to encrypt the last certificate in the existing keystore will
1077 # be reused to encrypt all certificates while storing. If the last certificate
1078 # in the existing keystore is not encrypted, all certificates will be stored
1079 # unencrypted. If there is no certificate in the existing keystore, any newly
1080 # added certificate will be encrypted (or stored unencrypted if algorithm
1081 # value is &quot;NONE&quot;) using the &quot;keystore.pkcs12.certProtectionAlgorithm&quot; and
1082 # &quot;keystore.pkcs12.certPbeIterationCount&quot; values defined here. Existing private
1083 # and secret key(s) are not changed. Newly set private and secret key(s) will
1084 # be encrypted using the &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
1085 # &quot;keystore.pkcs12.keyPbeIterationCount&quot; values defined here.
1086 #
1087 # In order to apply new algorithms and parameters to all entries in an
1088 # existing keystore, one can create a new keystore and add entries in the
1089 # existing keystore into the new keystore. This can be achieved by calling the
1090 # &quot;keytool -importkeystore&quot; command.
1091 #
1092 # If a system property of the same name is also specified, it supersedes the
1093 # security property value defined here.
1094 #
1095 # If the property is set to an illegal value,
1096 # an iteration count that is not a positive integer, or an unknown algorithm
1097 # name, an exception will be thrown when the property is used.
1098 # If the property is not set or empty, a default value will be used.
1099 #
1100 # Note: These properties are currently used by the JDK Reference implementation.
1101 # They are not guaranteed to be examined and used by other implementations.
1102 
1103 # The algorithm used to encrypt a certificate. This can be any non-Hmac PBE
1104 # algorithm defined in the Cipher section of the Java Security Standard
1105 # Algorithm Names Specification. When set to &quot;NONE&quot;, the certificate
1106 # is not encrypted. The default value is &quot;PBEWithSHA1AndRC2_40&quot;.
1107 #keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40
1108 
1109 # The iteration count used by the PBE algorithm when encrypting a certificate.
1110 # This value must be a positive integer. The default value is 50000.
1111 #keystore.pkcs12.certPbeIterationCount = 50000
1112 
1113 # The algorithm used to encrypt a private key or secret key. This can be
1114 # any non-Hmac PBE algorithm defined in the Cipher section of the Java
1115 # Security Standard Algorithm Names Specification. The value must not be &quot;NONE&quot;.
1116 # The default value is &quot;PBEWithSHA1AndDESede&quot;.
1117 #keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede
1118 
1119 # The iteration count used by the PBE algorithm when encrypting a private key
1120 # or a secret key. This value must be a positive integer. The default value
1121 # is 50000.
1122 #keystore.pkcs12.keyPbeIterationCount = 50000
1123 
1124 # The algorithm used to calculate the optional MacData at the end of a PKCS12
1125 # file. This can be any HmacPBE algorithm defined in the Mac section of the
1126 # Java Security Standard Algorithm Names Specification. When set to &quot;NONE&quot;,
1127 # no Mac is generated. The default value is &quot;HmacPBESHA1&quot;.
1128 #keystore.pkcs12.macAlgorithm = HmacPBESHA1
1129 
1130 # The iteration count used by the MacData algorithm. This value must be a
1131 # positive integer. The default value is 100000.
1132 #keystore.pkcs12.macIterationCount = 100000
1133 
1134 #
1135 # Enhanced exception message information
1136 #
1137 # By default, exception messages should not include potentially sensitive
1138 # information such as file names, host names, or port numbers. This property
1139 # accepts one or more comma separated values, each of which represents a
1140 # category of enhanced exception message information to enable. Values are
1141 # case-insensitive. Leading and trailing whitespaces, surrounding each value,
1142 # are ignored. Unknown values are ignored.
1143 #
1144 # NOTE: Use caution before setting this property. Setting this property
1145 # exposes sensitive information in Exceptions, which could, for example,
1146 # propagate to untrusted code or be emitted in stack traces that are
1147 # inadvertently disclosed and made accessible over a public network.
1148 #
1149 # The categories are:
1150 #
1151 #  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the
1152 #             java.nio.channels package will contain enhanced exception
1153 #             message information
1154 #
1155 #  jar      - enables more detailed information in the IOExceptions thrown
1156 #             by classes in the java.util.jar package
1157 #
1158 # The property setting in this file can be overridden by a system property of
1159 # the same name, with the same syntax and possible values.
1160 #
1161 #jdk.includeInExceptions=hostInfo,jar
1162 
1163 #
1164 # Policies for distrusting Certificate Authorities (CAs).
1165 #
1166 # This is a comma separated value of one or more case-sensitive strings, each
1167 # of which represents a policy for determining if a CA should be distrusted.
1168 # The supported values are:
1169 #
1170 #   SYMANTEC_TLS : Distrust TLS Server certificates anchored by a Symantec
1171 #   root CA and issued after April 16, 2019 unless issued by one of the
1172 #   following subordinate CAs which have a later distrust date:
1173 #     1. Apple IST CA 2 - G1, SHA-256 fingerprint:
1174 #        AC2B922ECFD5E01711772FEA8ED372DE9D1E2245FCE3F57A9CDBEC77296A424B
1175 #        Distrust after December 31, 2019.
1176 #     2. Apple IST CA 8 - G1, SHA-256 fingerprint:
1177 #        A4FE7C7F15155F3F0AEF7AAA83CF6E06DEB97CA3F909DF920AC1490882D488ED
1178 #        Distrust after December 31, 2019.
1179 #
1180 # Leading and trailing whitespace surrounding each value are ignored.
1181 # Unknown values are ignored. If the property is commented out or set to the
1182 # empty String, no policies are enforced.
1183 #
1184 # Note: This property is currently used by the JDK Reference implementation.
1185 # It is not guaranteed to be supported by other SE implementations. Also, this
1186 # property does not override other security properties which can restrict
1187 # certificates such as jdk.tls.disabledAlgorithms or
1188 # jdk.certpath.disabledAlgorithms; those restrictions are still enforced even
1189 # if this property is not enabled.
1190 #
1191 jdk.security.caDistrustPolicies=SYMANTEC_TLS
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/native/libjli/java.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Shared source for &#39;java&#39; command line tool.
  28  *
  29  * If JAVA_ARGS is defined, then acts as a launcher for applications. For
  30  * instance, the JDK command line tools such as javac and javadoc (see
  31  * makefiles for more details) are built with this program.  Any arguments
  32  * prefixed with &#39;-J&#39; will be passed directly to the &#39;java&#39; command.
  33  */
  34 
  35 /*
  36  * One job of the launcher is to remove command line options which the
  37  * vm does not understand and will not process.  These options include
  38  * options which select which style of vm is run (e.g. -client and
  39  * -server) as well as options which select the data model to use.
  40  * Additionally, for tools which invoke an underlying vm &quot;-J-foo&quot;
  41  * options are turned into &quot;-foo&quot; options to the vm.  This option
  42  * filtering is handled in a number of places in the launcher, some of
  43  * it in machine-dependent code.  In this file, the function
  44  * CheckJvmType removes vm style options and TranslateApplicationArgs
  45  * removes &quot;-J&quot; prefixes.  The CreateExecutionEnvironment function processes
  46  * and removes -d&lt;n&gt; options. On unix, there is a possibility that the running
  47  * data model may not match to the desired data model, in this case an exec is
  48  * required to start the desired model. If the data models match, then
  49  * ParseArguments will remove the -d&lt;n&gt; flags. If the data models do not match
  50  * the CreateExecutionEnviroment will remove the -d&lt;n&gt; flags.
  51  */
  52 
  53 
  54 #include &quot;java.h&quot;
  55 #include &quot;jni.h&quot;
  56 
  57 /*
  58  * A NOTE TO DEVELOPERS: For performance reasons it is important that
  59  * the program image remain relatively small until after SelectVersion
  60  * CreateExecutionEnvironment have finished their possibly recursive
  61  * processing. Watch everything, but resist all temptations to use Java
  62  * interfaces.
  63  */
  64 
  65 #define USE_STDERR JNI_TRUE     /* we usually print to stderr */
  66 #define USE_STDOUT JNI_FALSE
  67 
  68 static jboolean printVersion = JNI_FALSE; /* print and exit */
  69 static jboolean showVersion = JNI_FALSE;  /* print but continue */
  70 static jboolean printUsage = JNI_FALSE;   /* print and exit*/
  71 static jboolean printTo = USE_STDERR;     /* where to print version/usage */
  72 static jboolean printXUsage = JNI_FALSE;  /* print and exit*/
  73 static jboolean dryRun = JNI_FALSE;       /* initialize VM and exit */
  74 static char     *showSettings = NULL;     /* print but continue */
  75 static jboolean showResolvedModules = JNI_FALSE;
  76 static jboolean listModules = JNI_FALSE;
  77 static char     *describeModule = NULL;
  78 static jboolean validateModules = JNI_FALSE;
  79 
  80 static const char *_program_name;
  81 static const char *_launcher_name;
  82 static jboolean _is_java_args = JNI_FALSE;
  83 static jboolean _have_classpath = JNI_FALSE;
  84 static const char *_fVersion;
  85 static jboolean _wc_enabled = JNI_FALSE;
  86 
  87 /*
  88  * Entries for splash screen environment variables.
  89  * putenv is performed in SelectVersion. We need
  90  * them in memory until UnsetEnv, so they are made static
  91  * global instead of auto local.
  92  */
  93 static char* splash_file_entry = NULL;
  94 static char* splash_jar_entry = NULL;
  95 
  96 /*
  97  * List of VM options to be specified when the VM is created.
  98  */
  99 static JavaVMOption *options;
 100 static int numOptions, maxOptions;
 101 
 102 /*
 103  * Prototypes for functions internal to launcher.
 104  */
<a name="1" id="anc1"></a>


 105 static void SetClassPath(const char *s);
 106 static void SetMainModule(const char *s);
 107 static void SelectVersion(int argc, char **argv, char **main_class);
 108 static void SetJvmEnvironment(int argc, char **argv);
 109 static jboolean ParseArguments(int *pargc, char ***pargv,
 110                                int *pmode, char **pwhat,
 111                                int *pret, const char *jrepath);
 112 static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv,
 113                               InvocationFunctions *ifn);
 114 static jstring NewPlatformString(JNIEnv *env, char *s);
 115 static jclass LoadMainClass(JNIEnv *env, int mode, char *name);
 116 static jclass GetApplicationClass(JNIEnv *env);
 117 
 118 static void TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv);
 119 static jboolean AddApplicationOptions(int cpathc, const char **cpathv);
 120 static void SetApplicationClassPath(const char**);
 121 
 122 static void PrintJavaVersion(JNIEnv *env, jboolean extraLF);
 123 static void PrintUsage(JNIEnv* env, jboolean doXUsage);
 124 static void ShowSettings(JNIEnv* env, char *optString);
 125 static void ShowResolvedModules(JNIEnv* env);
 126 static void ListModules(JNIEnv* env);
 127 static void DescribeModule(JNIEnv* env, char* optString);
 128 static jboolean ValidateModules(JNIEnv* env);
 129 
 130 static void SetPaths(int argc, char **argv);
 131 
 132 static void DumpState();
 133 
 134 enum OptionKind {
 135     LAUNCHER_OPTION = 0,
 136     LAUNCHER_OPTION_WITH_ARGUMENT,
 137     LAUNCHER_MAIN_OPTION,
 138     VM_LONG_OPTION,
 139     VM_LONG_OPTION_WITH_ARGUMENT,
 140     VM_OPTION
 141 };
 142 
 143 static int GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue);
 144 static jboolean IsOptionWithArgument(int argc, char **argv);
 145 
 146 /* Maximum supported entries from jvm.cfg. */
 147 #define INIT_MAX_KNOWN_VMS      10
 148 
 149 /* Values for vmdesc.flag */
 150 enum vmdesc_flag {
 151     VM_UNKNOWN = -1,
 152     VM_KNOWN,
 153     VM_ALIASED_TO,
 154     VM_WARN,
 155     VM_ERROR,
 156     VM_IF_SERVER_CLASS,
 157     VM_IGNORE
 158 };
 159 
 160 struct vmdesc {
 161     char *name;
 162     int flag;
 163     char *alias;
 164     char *server_class;
 165 };
 166 static struct vmdesc *knownVMs = NULL;
 167 static int knownVMsCount = 0;
 168 static int knownVMsLimit = 0;
 169 
 170 static void GrowKnownVMs(int minimum);
 171 static int  KnownVMIndex(const char* name);
 172 static void FreeKnownVMs();
 173 static jboolean IsWildCardEnabled();
 174 
 175 
 176 #define SOURCE_LAUNCHER_MAIN_ENTRY &quot;jdk.compiler/com.sun.tools.javac.launcher.Main&quot;
 177 
 178 /*
 179  * This reports error.  VM will not be created and no usage is printed.
 180  */
 181 #define REPORT_ERROR(AC_ok, AC_failure_message, AC_questionable_arg) \
 182     do { \
 183         if (!AC_ok) { \
 184             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 185             printUsage = JNI_FALSE; \
 186             *pret = 1; \
 187             return JNI_FALSE; \
 188         } \
 189     } while (JNI_FALSE)
 190 
 191 #define ARG_CHECK(AC_arg_count, AC_failure_message, AC_questionable_arg) \
 192     do { \
 193         if (AC_arg_count &lt; 1) { \
 194             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 195             printUsage = JNI_TRUE; \
 196             *pret = 1; \
 197             return JNI_TRUE; \
 198         } \
 199     } while (JNI_FALSE)
 200 
 201 /*
 202  * Running Java code in primordial thread caused many problems. We will
 203  * create a new thread to invoke JVM. See 6316197 for more information.
 204  */
 205 static jlong threadStackSize    = 0;  /* stack size of the new thread */
 206 static jlong maxHeapSize        = 0;  /* max heap size */
<a name="2" id="anc2"></a><span class="line-modified"> 207 static jlong initialHeapSize    = 0;  /* inital heap size */</span>
 208 
 209 /*
<a name="3" id="anc3"></a><span class="line-modified"> 210  * A minimum -Xss stack size suitable for all platforms.</span>
<span class="line-modified"> 211  */</span>



 212 #ifndef STACK_SIZE_MINIMUM
 213 #define STACK_SIZE_MINIMUM (64 * KB)
 214 #endif
 215 
 216 #ifdef INCLUDE_TSAN
 217 /*
 218  * Function pointer to JVM&#39;s TSAN symbolize function.
 219  */
 220 __attribute__((visibility(&quot;default&quot;)))
 221 TsanSymbolize_t tsan_symbolize_func = NULL;
 222 #endif
 223 
 224 /*
 225  * Entry point.
 226  */
 227 JNIEXPORT int JNICALL
 228 JLI_Launch(int argc, char ** argv,              /* main argc, argv */
 229         int jargc, const char** jargv,          /* java args */
 230         int appclassc, const char** appclassv,  /* app classpath */
 231         const char* fullversion,                /* full version defined */
 232         const char* dotversion,                 /* UNUSED dot version defined */
 233         const char* pname,                      /* program name */
 234         const char* lname,                      /* launcher name */
 235         jboolean javaargs,                      /* JAVA_ARGS */
 236         jboolean cpwildcard,                    /* classpath wildcard*/
 237         jboolean javaw,                         /* windows-only javaw */
 238         jint ergo                               /* unused */
 239 )
 240 {
 241     int mode = LM_UNKNOWN;
 242     char *what = NULL;
 243     char *main_class = NULL;
 244     int ret;
 245     InvocationFunctions ifn;
 246     jlong start, end;
 247     char jvmpath[MAXPATHLEN];
 248     char jrepath[MAXPATHLEN];
 249     char jvmcfg[MAXPATHLEN];
 250 
 251     _fVersion = fullversion;
 252     _launcher_name = lname;
 253     _program_name = pname;
 254     _is_java_args = javaargs;
 255     _wc_enabled = cpwildcard;
 256 
 257     InitLauncher(javaw);
 258     DumpState();
 259     if (JLI_IsTraceLauncher()) {
 260         int i;
 261         printf(&quot;Java args:\n&quot;);
 262         for (i = 0; i &lt; jargc ; i++) {
 263             printf(&quot;jargv[%d] = %s\n&quot;, i, jargv[i]);
 264         }
 265         printf(&quot;Command line args:\n&quot;);
 266         for (i = 0; i &lt; argc ; i++) {
 267             printf(&quot;argv[%d] = %s\n&quot;, i, argv[i]);
 268         }
 269         AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
 270     }
 271 
 272     /*
 273      * SelectVersion() has several responsibilities:
 274      *
 275      *  1) Disallow specification of another JRE.  With 1.9, another
 276      *     version of the JRE cannot be invoked.
 277      *  2) Allow for a JRE version to invoke JDK 1.9 or later.  Since
 278      *     all mJRE directives have been stripped from the request but
 279      *     the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been
 280      *     invoked from the command line.
 281      */
 282     SelectVersion(argc, argv, &amp;main_class);
 283 
 284     CreateExecutionEnvironment(&amp;argc, &amp;argv,
 285                                jrepath, sizeof(jrepath),
 286                                jvmpath, sizeof(jvmpath),
 287                                jvmcfg,  sizeof(jvmcfg));
 288 
 289     if (!IsJavaArgs()) {
 290         SetJvmEnvironment(argc,argv);
 291     }
 292 
 293     ifn.CreateJavaVM = 0;
 294     ifn.GetDefaultJavaVMInitArgs = 0;
 295 
 296     if (JLI_IsTraceLauncher()) {
 297         start = CounterGet();
 298     }
 299 
 300     if (!LoadJavaVM(jvmpath, &amp;ifn)) {
 301         return(6);
 302     }
 303 #ifdef INCLUDE_TSAN
 304     tsan_symbolize_func = ifn.TsanSymbolize;
 305 #endif
 306 
 307     if (JLI_IsTraceLauncher()) {
 308         end   = CounterGet();
 309     }
 310 
 311     JLI_TraceLauncher(&quot;%ld micro seconds to LoadJavaVM\n&quot;,
 312              (long)(jint)Counter2Micros(end-start));
 313 
 314     ++argv;
 315     --argc;
 316 
 317     if (IsJavaArgs()) {
 318         /* Preprocess wrapper arguments */
 319         TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv);
 320         if (!AddApplicationOptions(appclassc, appclassv)) {
 321             return(1);
 322         }
 323     } else {
 324         /* Set default CLASSPATH */
 325         char* cpath = getenv(&quot;CLASSPATH&quot;);
 326         if (cpath != NULL) {
 327             SetClassPath(cpath);
 328         }
 329     }
 330 
 331     /* Parse command line options; if the return value of
 332      * ParseArguments is false, the program should exit.
 333      */
 334     if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) {
 335         return(ret);
 336     }
 337 
 338     /* Override class path if -jar flag was specified */
 339     if (mode == LM_JAR) {
 340         SetClassPath(what);     /* Override class path */
 341     }
 342 
 343     /* set the -Dsun.java.command pseudo property */
 344     SetJavaCommandLineProp(what, argc, argv);
 345 
 346     /* Set the -Dsun.java.launcher pseudo property */
 347     SetJavaLauncherProp();
 348 
<a name="4" id="anc4"></a><span class="line-removed"> 349     /* set the -Dsun.java.launcher.* platform properties */</span>
<span class="line-removed"> 350     SetJavaLauncherPlatformProps();</span>
<span class="line-removed"> 351 </span>
 352     return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
 353 }
 354 /*
 355  * Always detach the main thread so that it appears to have ended when
 356  * the application&#39;s main method exits.  This will invoke the
 357  * uncaught exception handler machinery if main threw an
 358  * exception.  An uncaught exception handler cannot change the
 359  * launcher&#39;s return code except by calling System.exit.
 360  *
 361  * Wait for all non-daemon threads to end, then destroy the VM.
 362  * This will actually create a trivial new Java waiter thread
 363  * named &quot;DestroyJavaVM&quot;, but this will be seen as a different
 364  * thread from the one that executed main, even though they are
 365  * the same C thread.  This allows mainThread.join() and
 366  * mainThread.isAlive() to work as expected.
 367  */
 368 #define LEAVE() \
 369     do { \
 370         if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) { \
 371             JLI_ReportErrorMessage(JVM_ERROR2); \
 372             ret = 1; \
 373         } \
 374         if (JNI_TRUE) { \
 375             (*vm)-&gt;DestroyJavaVM(vm); \
 376             return ret; \
 377         } \
 378     } while (JNI_FALSE)
 379 
 380 #define CHECK_EXCEPTION_NULL_LEAVE(CENL_exception) \
 381     do { \
 382         if ((*env)-&gt;ExceptionOccurred(env)) { \
 383             JLI_ReportExceptionDescription(env); \
 384             LEAVE(); \
 385         } \
 386         if ((CENL_exception) == NULL) { \
 387             JLI_ReportErrorMessage(JNI_ERROR); \
 388             LEAVE(); \
 389         } \
 390     } while (JNI_FALSE)
 391 
 392 #define CHECK_EXCEPTION_LEAVE(CEL_return_value) \
 393     do { \
 394         if ((*env)-&gt;ExceptionOccurred(env)) { \
 395             JLI_ReportExceptionDescription(env); \
 396             ret = (CEL_return_value); \
 397             LEAVE(); \
 398         } \
 399     } while (JNI_FALSE)
 400 
 401 
 402 int
 403 JavaMain(void* _args)
 404 {
 405     JavaMainArgs *args = (JavaMainArgs *)_args;
 406     int argc = args-&gt;argc;
 407     char **argv = args-&gt;argv;
 408     int mode = args-&gt;mode;
 409     char *what = args-&gt;what;
 410     InvocationFunctions ifn = args-&gt;ifn;
 411 
 412     JavaVM *vm = 0;
 413     JNIEnv *env = 0;
 414     jclass mainClass = NULL;
 415     jclass appClass = NULL; // actual application class being launched
 416     jmethodID mainID;
 417     jobjectArray mainArgs;
 418     int ret = 0;
 419     jlong start, end;
 420 
 421     RegisterThread();
 422 
 423     /* Initialize the virtual machine */
 424     start = CounterGet();
 425     if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) {
 426         JLI_ReportErrorMessage(JVM_ERROR1);
 427         exit(1);
 428     }
 429 
 430     if (showSettings != NULL) {
 431         ShowSettings(env, showSettings);
 432         CHECK_EXCEPTION_LEAVE(1);
 433     }
 434 
 435     // show resolved modules and continue
 436     if (showResolvedModules) {
 437         ShowResolvedModules(env);
 438         CHECK_EXCEPTION_LEAVE(1);
 439     }
 440 
 441     // list observable modules, then exit
 442     if (listModules) {
 443         ListModules(env);
 444         CHECK_EXCEPTION_LEAVE(1);
 445         LEAVE();
 446     }
 447 
 448     // describe a module, then exit
 449     if (describeModule != NULL) {
 450         DescribeModule(env, describeModule);
 451         CHECK_EXCEPTION_LEAVE(1);
 452         LEAVE();
 453     }
 454 
 455     if (printVersion || showVersion) {
 456         PrintJavaVersion(env, showVersion);
 457         CHECK_EXCEPTION_LEAVE(0);
 458         if (printVersion) {
 459             LEAVE();
 460         }
 461     }
 462 
 463     // modules have been validated at startup so exit
 464     if (validateModules) {
 465         LEAVE();
 466     }
 467 
 468     /* If the user specified neither a class name nor a JAR file */
 469     if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {
 470         PrintUsage(env, printXUsage);
 471         CHECK_EXCEPTION_LEAVE(1);
 472         LEAVE();
 473     }
 474 
 475     FreeKnownVMs(); /* after last possible PrintUsage */
 476 
 477     if (JLI_IsTraceLauncher()) {
 478         end = CounterGet();
 479         JLI_TraceLauncher(&quot;%ld micro seconds to InitializeJVM\n&quot;,
 480                (long)(jint)Counter2Micros(end-start));
 481     }
 482 
 483     /* At this stage, argc/argv have the application&#39;s arguments */
 484     if (JLI_IsTraceLauncher()){
 485         int i;
 486         printf(&quot;%s is &#39;%s&#39;\n&quot;, launchModeNames[mode], what);
 487         printf(&quot;App&#39;s argc is %d\n&quot;, argc);
 488         for (i=0; i &lt; argc; i++) {
 489             printf(&quot;    argv[%2d] = &#39;%s&#39;\n&quot;, i, argv[i]);
 490         }
 491     }
 492 
 493     ret = 1;
 494 
 495     /*
 496      * Get the application&#39;s main class. It also checks if the main
 497      * method exists.
 498      *
 499      * See bugid 5030265.  The Main-Class name has already been parsed
 500      * from the manifest, but not parsed properly for UTF-8 support.
 501      * Hence the code here ignores the value previously extracted and
 502      * uses the pre-existing code to reextract the value.  This is
 503      * possibly an end of release cycle expedient.  However, it has
 504      * also been discovered that passing some character sets through
 505      * the environment has &quot;strange&quot; behavior on some variants of
 506      * Windows.  Hence, maybe the manifest parsing code local to the
 507      * launcher should never be enhanced.
 508      *
 509      * Hence, future work should either:
 510      *     1)   Correct the local parsing code and verify that the
 511      *          Main-Class attribute gets properly passed through
 512      *          all environments,
 513      *     2)   Remove the vestages of maintaining main_class through
 514      *          the environment (and remove these comments).
 515      *
 516      * This method also correctly handles launching existing JavaFX
 517      * applications that may or may not have a Main-Class manifest entry.
 518      */
 519     mainClass = LoadMainClass(env, mode, what);
 520     CHECK_EXCEPTION_NULL_LEAVE(mainClass);
 521     /*
 522      * In some cases when launching an application that needs a helper, e.g., a
 523      * JavaFX application with no main method, the mainClass will not be the
 524      * applications own main class but rather a helper class. To keep things
 525      * consistent in the UI we need to track and report the application main class.
 526      */
 527     appClass = GetApplicationClass(env);
 528     NULL_CHECK_RETURN_VALUE(appClass, -1);
 529 
 530     /* Build platform specific argument array */
 531     mainArgs = CreateApplicationArgs(env, argv, argc);
 532     CHECK_EXCEPTION_NULL_LEAVE(mainArgs);
 533 
 534     if (dryRun) {
 535         ret = 0;
 536         LEAVE();
 537     }
 538 
 539     /*
 540      * PostJVMInit uses the class name as the application name for GUI purposes,
 541      * for example, on OSX this sets the application name in the menu bar for
 542      * both SWT and JavaFX. So we&#39;ll pass the actual application class here
 543      * instead of mainClass as that may be a launcher or helper class instead
 544      * of the application class.
 545      */
 546     PostJVMInit(env, appClass, vm);
 547     CHECK_EXCEPTION_LEAVE(1);
 548 
 549     /*
 550      * The LoadMainClass not only loads the main class, it will also ensure
 551      * that the main method&#39;s signature is correct, therefore further checking
 552      * is not required. The main method is invoked here so that extraneous java
 553      * stacks are not in the application stack trace.
 554      */
 555     mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;,
 556                                        &quot;([Ljava/lang/String;)V&quot;);
 557     CHECK_EXCEPTION_NULL_LEAVE(mainID);
 558 
 559     /* Invoke main method. */
 560     (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);
 561 
 562     /*
 563      * The launcher&#39;s exit code (in the absence of calls to
 564      * System.exit) will be non-zero if main threw an exception.
 565      */
 566     ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;
 567 
 568     LEAVE();
 569 }
 570 
 571 /*
 572  * Test if the given name is one of the class path options.
 573  */
 574 static jboolean
 575 IsClassPathOption(const char* name) {
 576     return JLI_StrCmp(name, &quot;-classpath&quot;) == 0 ||
 577            JLI_StrCmp(name, &quot;-cp&quot;) == 0 ||
 578            JLI_StrCmp(name, &quot;--class-path&quot;) == 0;
 579 }
 580 
 581 /*
 582  * Test if the given name is a launcher option taking the main entry point.
 583  */
 584 static jboolean
 585 IsLauncherMainOption(const char* name) {
 586     return JLI_StrCmp(name, &quot;--module&quot;) == 0 ||
 587            JLI_StrCmp(name, &quot;-m&quot;) == 0;
 588 }
 589 
 590 /*
 591  * Test if the given name is a white-space launcher option.
 592  */
 593 static jboolean
 594 IsLauncherOption(const char* name) {
 595     return IsClassPathOption(name) ||
 596            IsLauncherMainOption(name) ||
 597            JLI_StrCmp(name, &quot;--describe-module&quot;) == 0 ||
 598            JLI_StrCmp(name, &quot;-d&quot;) == 0 ||
 599            JLI_StrCmp(name, &quot;--source&quot;) == 0;
 600 }
 601 
 602 /*
 603  * Test if the given name is a module-system white-space option that
 604  * will be passed to the VM with its corresponding long-form option
 605  * name and &quot;=&quot; delimiter.
 606  */
 607 static jboolean
 608 IsModuleOption(const char* name) {
 609     return JLI_StrCmp(name, &quot;--module-path&quot;) == 0 ||
 610            JLI_StrCmp(name, &quot;-p&quot;) == 0 ||
 611            JLI_StrCmp(name, &quot;--upgrade-module-path&quot;) == 0 ||
 612            JLI_StrCmp(name, &quot;--add-modules&quot;) == 0 ||
 613            JLI_StrCmp(name, &quot;--limit-modules&quot;) == 0 ||
 614            JLI_StrCmp(name, &quot;--add-exports&quot;) == 0 ||
 615            JLI_StrCmp(name, &quot;--add-opens&quot;) == 0 ||
 616            JLI_StrCmp(name, &quot;--add-reads&quot;) == 0 ||
 617            JLI_StrCmp(name, &quot;--patch-module&quot;) == 0;
 618 }
 619 
 620 static jboolean
 621 IsLongFormModuleOption(const char* name) {
 622     return JLI_StrCCmp(name, &quot;--module-path=&quot;) == 0 ||
 623            JLI_StrCCmp(name, &quot;--upgrade-module-path=&quot;) == 0 ||
 624            JLI_StrCCmp(name, &quot;--add-modules=&quot;) == 0 ||
 625            JLI_StrCCmp(name, &quot;--limit-modules=&quot;) == 0 ||
 626            JLI_StrCCmp(name, &quot;--add-exports=&quot;) == 0 ||
 627            JLI_StrCCmp(name, &quot;--add-reads=&quot;) == 0 ||
 628            JLI_StrCCmp(name, &quot;--patch-module=&quot;) == 0;
 629 }
 630 
 631 /*
 632  * Test if the given name has a white space option.
 633  */
 634 jboolean
 635 IsWhiteSpaceOption(const char* name) {
 636     return IsModuleOption(name) ||
 637            IsLauncherOption(name);
 638 }
 639 
 640 /*
 641  * Check if it is OK to set the mode.
 642  * If the mode was previously set, and should not be changed,
 643  * a fatal error is reported.
 644  */
 645 static int
 646 checkMode(int mode, int newMode, const char *arg) {
 647     if (mode == LM_SOURCE) {
 648         JLI_ReportErrorMessage(ARG_ERROR14, arg);
 649         exit(1);
 650     }
 651     return newMode;
 652 }
 653 
 654 /*
 655  * Test if an arg identifies a source file.
 656  */
<a name="5" id="anc5"></a><span class="line-modified"> 657 jboolean</span>
<span class="line-removed"> 658 IsSourceFile(const char *arg) {</span>
 659     struct stat st;
 660     return (JLI_HasSuffix(arg, &quot;.java&quot;) &amp;&amp; stat(arg, &amp;st) == 0);
 661 }
 662 
 663 /*
 664  * Checks the command line options to find which JVM type was
 665  * specified.  If no command line option was given for the JVM type,
 666  * the default type is used.  The environment variable
 667  * JDK_ALTERNATE_VM and the command line option -XXaltjvm= are also
 668  * checked as ways of specifying which JVM type to invoke.
 669  */
 670 char *
 671 CheckJvmType(int *pargc, char ***argv, jboolean speculative) {
 672     int i, argi;
 673     int argc;
 674     char **newArgv;
 675     int newArgvIdx = 0;
 676     int isVMType;
 677     int jvmidx = -1;
 678     char *jvmtype = getenv(&quot;JDK_ALTERNATE_VM&quot;);
 679 
 680     argc = *pargc;
 681 
 682     /* To make things simpler we always copy the argv array */
 683     newArgv = JLI_MemAlloc((argc + 1) * sizeof(char *));
 684 
 685     /* The program name is always present */
 686     newArgv[newArgvIdx++] = (*argv)[0];
 687 
 688     for (argi = 1; argi &lt; argc; argi++) {
 689         char *arg = (*argv)[argi];
 690         isVMType = 0;
 691 
 692         if (IsJavaArgs()) {
 693             if (arg[0] != &#39;-&#39;) {
 694                 newArgv[newArgvIdx++] = arg;
 695                 continue;
 696             }
 697         } else {
 698             if (IsWhiteSpaceOption(arg)) {
 699                 newArgv[newArgvIdx++] = arg;
 700                 argi++;
 701                 if (argi &lt; argc) {
 702                     newArgv[newArgvIdx++] = (*argv)[argi];
 703                 }
 704                 continue;
 705             }
 706             if (arg[0] != &#39;-&#39;) break;
 707         }
 708 
 709         /* Did the user pass an explicit VM type? */
 710         i = KnownVMIndex(arg);
 711         if (i &gt;= 0) {
 712             jvmtype = knownVMs[jvmidx = i].name + 1; /* skip the - */
 713             isVMType = 1;
 714             *pargc = *pargc - 1;
 715         }
 716 
 717         /* Did the user specify an &quot;alternate&quot; VM? */
 718         else if (JLI_StrCCmp(arg, &quot;-XXaltjvm=&quot;) == 0 || JLI_StrCCmp(arg, &quot;-J-XXaltjvm=&quot;) == 0) {
 719             isVMType = 1;
 720             jvmtype = arg+((arg[1]==&#39;X&#39;)? 10 : 12);
 721             jvmidx = -1;
 722         }
 723 
 724         if (!isVMType) {
 725             newArgv[newArgvIdx++] = arg;
 726         }
 727     }
 728 
 729     /*
 730      * Finish copying the arguments if we aborted the above loop.
 731      * NOTE that if we aborted via &quot;break&quot; then we did NOT copy the
 732      * last argument above, and in addition argi will be less than
 733      * argc.
 734      */
 735     while (argi &lt; argc) {
 736         newArgv[newArgvIdx++] = (*argv)[argi];
 737         argi++;
 738     }
 739 
 740     /* argv is null-terminated */
 741     newArgv[newArgvIdx] = 0;
 742 
 743     /* Copy back argv */
 744     *argv = newArgv;
 745     *pargc = newArgvIdx;
 746 
 747     /* use the default VM type if not specified (no alias processing) */
 748     if (jvmtype == NULL) {
 749       char* result = knownVMs[0].name+1;
 750       JLI_TraceLauncher(&quot;Default VM: %s\n&quot;, result);
 751       return result;
 752     }
 753 
 754     /* if using an alternate VM, no alias processing */
 755     if (jvmidx &lt; 0)
 756       return jvmtype;
 757 
 758     /* Resolve aliases first */
 759     {
 760       int loopCount = 0;
 761       while (knownVMs[jvmidx].flag == VM_ALIASED_TO) {
 762         int nextIdx = KnownVMIndex(knownVMs[jvmidx].alias);
 763 
 764         if (loopCount &gt; knownVMsCount) {
 765           if (!speculative) {
 766             JLI_ReportErrorMessage(CFG_ERROR1);
 767             exit(1);
 768           } else {
 769             return &quot;ERROR&quot;;
 770             /* break; */
 771           }
 772         }
 773 
 774         if (nextIdx &lt; 0) {
 775           if (!speculative) {
 776             JLI_ReportErrorMessage(CFG_ERROR2, knownVMs[jvmidx].alias);
 777             exit(1);
 778           } else {
 779             return &quot;ERROR&quot;;
 780           }
 781         }
 782         jvmidx = nextIdx;
 783         jvmtype = knownVMs[jvmidx].name+1;
 784         loopCount++;
 785       }
 786     }
 787 
 788     switch (knownVMs[jvmidx].flag) {
 789     case VM_WARN:
 790         if (!speculative) {
 791             JLI_ReportErrorMessage(CFG_WARN1, jvmtype, knownVMs[0].name + 1);
 792         }
 793         /* fall through */
 794     case VM_IGNORE:
 795         jvmtype = knownVMs[jvmidx=0].name + 1;
 796         /* fall through */
 797     case VM_KNOWN:
 798         break;
 799     case VM_ERROR:
 800         if (!speculative) {
 801             JLI_ReportErrorMessage(CFG_ERROR3, jvmtype);
 802             exit(1);
 803         } else {
 804             return &quot;ERROR&quot;;
 805         }
 806     }
 807 
 808     return jvmtype;
 809 }
 810 
 811 /*
 812  * This method must be called before the VM is loaded, primarily
 813  * used to parse and set any VM related options or env variables.
 814  * This function is non-destructive leaving the argument list intact.
 815  */
 816 static void
 817 SetJvmEnvironment(int argc, char **argv) {
 818 
 819     static const char*  NMT_Env_Name    = &quot;NMT_LEVEL_&quot;;
 820     int i;
 821     /* process only the launcher arguments */
 822     for (i = 0; i &lt; argc; i++) {
 823         char *arg = argv[i];
 824         /*
 825          * Since this must be a VM flag we stop processing once we see
 826          * an argument the launcher would not have processed beyond (such
 827          * as -version or -h), or an argument that indicates the following
 828          * arguments are for the application (i.e. the main class name, or
 829          * the -jar argument).
 830          */
 831         if (i &gt; 0) {
 832             char *prev = argv[i - 1];
 833             // skip non-dash arg preceded by class path specifiers
 834             if (*arg != &#39;-&#39; &amp;&amp; IsWhiteSpaceOption(prev)) {
 835                 continue;
 836             }
 837 
 838             if (*arg != &#39;-&#39; || isTerminalOpt(arg)) {
 839                 return;
 840             }
 841         }
 842         /*
 843          * The following case checks for &quot;-XX:NativeMemoryTracking=value&quot;.
 844          * If value is non null, an environmental variable set to this value
 845          * will be created to be used by the JVM.
 846          * The argument is passed to the JVM, which will check validity.
 847          * The JVM is responsible for removing the env variable.
 848          */
 849         if (JLI_StrCCmp(arg, &quot;-XX:NativeMemoryTracking=&quot;) == 0) {
 850             int retval;
 851             // get what follows this parameter, include &quot;=&quot;
 852             size_t pnlen = JLI_StrLen(&quot;-XX:NativeMemoryTracking=&quot;);
 853             if (JLI_StrLen(arg) &gt; pnlen) {
 854                 char* value = arg + pnlen;
 855                 size_t pbuflen = pnlen + JLI_StrLen(value) + 10; // 10 max pid digits
 856 
 857                 /*
 858                  * ensures that malloc successful
 859                  * DONT JLI_MemFree() pbuf.  JLI_PutEnv() uses system call
 860                  *   that could store the address.
 861                  */
 862                 char * pbuf = (char*)JLI_MemAlloc(pbuflen);
 863 
 864                 JLI_Snprintf(pbuf, pbuflen, &quot;%s%d=%s&quot;, NMT_Env_Name, JLI_GetPid(), value);
 865                 retval = JLI_PutEnv(pbuf);
 866                 if (JLI_IsTraceLauncher()) {
 867                     char* envName;
 868                     char* envBuf;
 869 
 870                     // ensures that malloc successful
 871                     envName = (char*)JLI_MemAlloc(pbuflen);
 872                     JLI_Snprintf(envName, pbuflen, &quot;%s%d&quot;, NMT_Env_Name, JLI_GetPid());
 873 
 874                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: env var is %s\n&quot;,envName);
 875                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: putenv arg %s\n&quot;,pbuf);
 876                     envBuf = getenv(envName);
 877                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: got value %s\n&quot;,envBuf);
 878                     free(envName);
 879                 }
 880             }
 881         }
 882     }
 883 }
 884 
 885 /* copied from HotSpot function &quot;atomll()&quot; */
 886 static int
 887 parse_size(const char *s, jlong *result) {
 888   jlong n = 0;
 889   int args_read = sscanf(s, JLONG_FORMAT_SPECIFIER, &amp;n);
 890   if (args_read != 1) {
 891     return 0;
 892   }
 893   while (*s != &#39;\0&#39; &amp;&amp; *s &gt;= &#39;0&#39; &amp;&amp; *s &lt;= &#39;9&#39;) {
 894     s++;
 895   }
 896   // 4705540: illegal if more characters are found after the first non-digit
 897   if (JLI_StrLen(s) &gt; 1) {
 898     return 0;
 899   }
 900   switch (*s) {
 901     case &#39;T&#39;: case &#39;t&#39;:
 902       *result = n * GB * KB;
 903       return 1;
 904     case &#39;G&#39;: case &#39;g&#39;:
 905       *result = n * GB;
 906       return 1;
 907     case &#39;M&#39;: case &#39;m&#39;:
 908       *result = n * MB;
 909       return 1;
 910     case &#39;K&#39;: case &#39;k&#39;:
 911       *result = n * KB;
 912       return 1;
 913     case &#39;\0&#39;:
 914       *result = n;
 915       return 1;
 916     default:
 917       /* Create JVM with default stack and let VM handle malformed -Xss string*/
 918       return 0;
 919   }
 920 }
 921 
 922 /*
 923  * Adds a new VM option with the given name and value.
 924  */
 925 void
 926 AddOption(char *str, void *info)
 927 {
 928     /*
 929      * Expand options array if needed to accommodate at least one more
 930      * VM option.
 931      */
 932     if (numOptions &gt;= maxOptions) {
 933         if (options == 0) {
 934             maxOptions = 4;
 935             options = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 936         } else {
 937             JavaVMOption *tmp;
 938             maxOptions *= 2;
 939             tmp = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 940             memcpy(tmp, options, numOptions * sizeof(JavaVMOption));
 941             JLI_MemFree(options);
 942             options = tmp;
 943         }
 944     }
 945     options[numOptions].optionString = str;
 946     options[numOptions++].extraInfo = info;
 947 
<a name="6" id="anc6"></a>






 948     if (JLI_StrCCmp(str, &quot;-Xss&quot;) == 0) {
 949         jlong tmp;
 950         if (parse_size(str + 4, &amp;tmp)) {
 951             threadStackSize = tmp;
<a name="7" id="anc7"></a><span class="line-modified"> 952             /*</span>
<span class="line-removed"> 953              * Make sure the thread stack size is big enough that we won&#39;t get a stack</span>
<span class="line-removed"> 954              * overflow before the JVM startup code can check to make sure the stack</span>
<span class="line-removed"> 955              * is big enough.</span>
<span class="line-removed"> 956              */</span>
<span class="line-removed"> 957             if (threadStackSize &lt; (jlong)STACK_SIZE_MINIMUM) {</span>
 958                 threadStackSize = STACK_SIZE_MINIMUM;
 959             }
 960         }
 961     }
 962 
 963     if (JLI_StrCCmp(str, &quot;-Xmx&quot;) == 0) {
 964         jlong tmp;
 965         if (parse_size(str + 4, &amp;tmp)) {
 966             maxHeapSize = tmp;
 967         }
 968     }
 969 
 970     if (JLI_StrCCmp(str, &quot;-Xms&quot;) == 0) {
 971         jlong tmp;
 972         if (parse_size(str + 4, &amp;tmp)) {
 973            initialHeapSize = tmp;
 974         }
 975     }
 976 }
 977 
 978 static void
 979 SetClassPath(const char *s)
 980 {
 981     char *def;
 982     const char *orig = s;
 983     static const char format[] = &quot;-Djava.class.path=%s&quot;;
 984     /*
 985      * usually we should not get a null pointer, but there are cases where
 986      * we might just get one, in which case we simply ignore it, and let the
 987      * caller deal with it
 988      */
 989     if (s == NULL)
 990         return;
 991     s = JLI_WildcardExpandClasspath(s);
 992     if (sizeof(format) - 2 + JLI_StrLen(s) &lt; JLI_StrLen(s))
 993         // s is became corrupted after expanding wildcards
 994         return;
 995     def = JLI_MemAlloc(sizeof(format)
 996                        - 2 /* strlen(&quot;%s&quot;) */
 997                        + JLI_StrLen(s));
 998     sprintf(def, format, s);
 999     AddOption(def, NULL);
1000     if (s != orig)
1001         JLI_MemFree((char *) s);
1002     _have_classpath = JNI_TRUE;
1003 }
1004 
1005 static void
1006 AddLongFormOption(const char *option, const char *arg)
1007 {
1008     static const char format[] = &quot;%s=%s&quot;;
1009     char *def;
1010     size_t def_len;
1011 
1012     def_len = JLI_StrLen(option) + 1 + JLI_StrLen(arg) + 1;
1013     def = JLI_MemAlloc(def_len);
1014     JLI_Snprintf(def, def_len, format, option, arg);
1015     AddOption(def, NULL);
1016 }
1017 
1018 static void
1019 SetMainModule(const char *s)
1020 {
1021     static const char format[] = &quot;-Djdk.module.main=%s&quot;;
1022     char* slash = JLI_StrChr(s, &#39;/&#39;);
1023     size_t s_len, def_len;
1024     char *def;
1025 
1026     /* value may be &lt;module&gt; or &lt;module&gt;/&lt;mainclass&gt; */
1027     if (slash == NULL) {
1028         s_len = JLI_StrLen(s);
1029     } else {
1030         s_len = (size_t) (slash - s);
1031     }
1032     def_len = sizeof(format)
1033                - 2 /* strlen(&quot;%s&quot;) */
1034                + s_len;
1035     def = JLI_MemAlloc(def_len);
1036     JLI_Snprintf(def, def_len, format, s);
1037     AddOption(def, NULL);
1038 }
1039 
1040 /*
1041  * The SelectVersion() routine ensures that an appropriate version of
1042  * the JRE is running.  The specification for the appropriate version
1043  * is obtained from either the manifest of a jar file (preferred) or
1044  * from command line options.
1045  * The routine also parses splash screen command line options and
1046  * passes on their values in private environment variables.
1047  */
1048 static void
1049 SelectVersion(int argc, char **argv, char **main_class)
1050 {
1051     char    *arg;
1052     char    *operand;
1053     char    *version = NULL;
1054     char    *jre = NULL;
1055     int     jarflag = 0;
1056     int     headlessflag = 0;
1057     int     restrict_search = -1;               /* -1 implies not known */
1058     manifest_info info;
1059     char    env_entry[MAXNAMELEN + 24] = ENV_ENTRY &quot;=&quot;;
1060     char    *splash_file_name = NULL;
1061     char    *splash_jar_name = NULL;
1062     char    *env_in;
1063     int     res;
1064     jboolean has_arg;
1065 
1066     /*
1067      * If the version has already been selected, set *main_class
1068      * with the value passed through the environment (if any) and
1069      * simply return.
1070      */
1071 
1072     /*
1073      * This environmental variable can be set by mJRE capable JREs
1074      * [ 1.5 thru 1.8 ].  All other aspects of mJRE processing have been
1075      * stripped by those JREs.  This environmental variable allows 1.9+
1076      * JREs to be started by these mJRE capable JREs.
1077      * Note that mJRE directives in the jar manifest file would have been
1078      * ignored for a JRE started by another JRE...
1079      * .. skipped for JRE 1.5 and beyond.
1080      * .. not even checked for pre 1.5.
1081      */
1082     if ((env_in = getenv(ENV_ENTRY)) != NULL) {
1083         if (*env_in != &#39;\0&#39;)
1084             *main_class = JLI_StringDup(env_in);
1085         return;
1086     }
1087 
1088     /*
1089      * Scan through the arguments for options relevant to multiple JRE
1090      * support.  Multiple JRE support existed in JRE versions 1.5 thru 1.8.
1091      *
1092      * This capability is no longer available with JRE versions 1.9 and later.
1093      * These command line options are reported as errors.
1094      */
1095 
1096     argc--;
1097     argv++;
1098     while ((arg = *argv) != 0 &amp;&amp; *arg == &#39;-&#39;) {
1099         has_arg = IsOptionWithArgument(argc, argv);
1100         if (JLI_StrCCmp(arg, &quot;-version:&quot;) == 0) {
1101             JLI_ReportErrorMessage(SPC_ERROR1);
1102         } else if (JLI_StrCmp(arg, &quot;-jre-restrict-search&quot;) == 0) {
1103             JLI_ReportErrorMessage(SPC_ERROR2);
1104         } else if (JLI_StrCmp(arg, &quot;-jre-no-restrict-search&quot;) == 0) {
1105             JLI_ReportErrorMessage(SPC_ERROR2);
1106         } else {
1107             if (JLI_StrCmp(arg, &quot;-jar&quot;) == 0)
1108                 jarflag = 1;
1109             if (IsWhiteSpaceOption(arg)) {
1110                 if (has_arg) {
1111                     argc--;
1112                     argv++;
1113                     arg = *argv;
1114                 }
1115             }
1116 
1117             /*
1118              * Checking for headless toolkit option in the some way as AWT does:
1119              * &quot;true&quot; means true and any other value means false
1120              */
1121             if (JLI_StrCmp(arg, &quot;-Djava.awt.headless=true&quot;) == 0) {
1122                 headlessflag = 1;
1123             } else if (JLI_StrCCmp(arg, &quot;-Djava.awt.headless=&quot;) == 0) {
1124                 headlessflag = 0;
1125             } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1126                 splash_file_name = arg+8;
1127             }
1128         }
1129         argc--;
1130         argv++;
1131     }
1132     if (argc &lt;= 0) {    /* No operand? Possibly legit with -[full]version */
1133         operand = NULL;
1134     } else {
1135         argc--;
1136         operand = *argv++;
1137     }
1138 
1139     /*
1140      * If there is a jar file, read the manifest. If the jarfile can&#39;t be
1141      * read, the manifest can&#39;t be read from the jar file, or the manifest
1142      * is corrupt, issue the appropriate error messages and exit.
1143      *
1144      * Even if there isn&#39;t a jar file, construct a manifest_info structure
1145      * containing the command line information.  It&#39;s a convenient way to carry
1146      * this data around.
1147      */
1148     if (jarflag &amp;&amp; operand) {
1149         if ((res = JLI_ParseManifest(operand, &amp;info)) != 0) {
1150             if (res == -1)
1151                 JLI_ReportErrorMessage(JAR_ERROR2, operand);
1152             else
1153                 JLI_ReportErrorMessage(JAR_ERROR3, operand);
1154             exit(1);
1155         }
1156 
1157         /*
1158          * Command line splash screen option should have precedence
1159          * over the manifest, so the manifest data is used only if
1160          * splash_file_name has not been initialized above during command
1161          * line parsing
1162          */
1163         if (!headlessflag &amp;&amp; !splash_file_name &amp;&amp; info.splashscreen_image_file_name) {
1164             splash_file_name = info.splashscreen_image_file_name;
1165             splash_jar_name = operand;
1166         }
1167     } else {
1168         info.manifest_version = NULL;
1169         info.main_class = NULL;
1170         info.jre_version = NULL;
1171         info.jre_restrict_search = 0;
1172     }
1173 
1174     /*
1175      * Passing on splash screen info in environment variables
1176      */
1177     if (splash_file_name &amp;&amp; !headlessflag) {
<a name="8" id="anc8"></a><span class="line-modified">1178         char* splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_file_name)+1);</span>
1179         JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY &quot;=&quot;);
1180         JLI_StrCat(splash_file_entry, splash_file_name);
1181         putenv(splash_file_entry);
1182     }
1183     if (splash_jar_name &amp;&amp; !headlessflag) {
<a name="9" id="anc9"></a><span class="line-modified">1184         char* splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_jar_name)+1);</span>
1185         JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY &quot;=&quot;);
1186         JLI_StrCat(splash_jar_entry, splash_jar_name);
1187         putenv(splash_jar_entry);
1188     }
1189 
1190 
1191     /*
1192      * &quot;Valid&quot; returns (other than unrecoverable errors) follow.  Set
1193      * main_class as a side-effect of this routine.
1194      */
1195     if (info.main_class != NULL)
1196         *main_class = JLI_StringDup(info.main_class);
1197 
1198     if (info.jre_version == NULL) {
1199         JLI_FreeManifest();
1200         return;
1201     }
1202 
1203 }
1204 
1205 /*
1206  * Test if the current argv is an option, i.e. with a leading `-`
1207  * and followed with an argument without a leading `-`.
1208  */
1209 static jboolean
1210 IsOptionWithArgument(int argc, char** argv) {
1211     char* option;
1212     char* arg;
1213 
1214     if (argc &lt;= 1)
1215         return JNI_FALSE;
1216 
1217     option = *argv;
1218     arg = *(argv+1);
1219     return *option == &#39;-&#39; &amp;&amp; *arg != &#39;-&#39;;
1220 }
1221 
1222 /*
1223  * Gets the option, and its argument if the option has an argument.
1224  * It will update *pargc, **pargv to the next option.
1225  */
1226 static int
1227 GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue) {
1228     int argc = *pargc;
1229     char** argv = *pargv;
1230     char* arg = *argv;
1231 
1232     char* option = arg;
1233     char* value = NULL;
1234     char* equals = NULL;
1235     int kind = LAUNCHER_OPTION;
1236     jboolean has_arg = JNI_FALSE;
1237 
1238     // check if this option may be a white-space option with an argument
1239     has_arg = IsOptionWithArgument(argc, argv);
1240 
1241     argv++; --argc;
1242     if (IsLauncherOption(arg)) {
1243         if (has_arg) {
1244             value = *argv;
1245             argv++; --argc;
1246         }
1247         kind = IsLauncherMainOption(arg) ? LAUNCHER_MAIN_OPTION
1248                                          : LAUNCHER_OPTION_WITH_ARGUMENT;
1249     } else if (IsModuleOption(arg)) {
1250         kind = VM_LONG_OPTION_WITH_ARGUMENT;
1251         if (has_arg) {
1252             value = *argv;
1253             argv++; --argc;
1254         }
1255 
1256         /*
1257          * Support short form alias
1258          */
1259         if (JLI_StrCmp(arg, &quot;-p&quot;) == 0) {
1260             option = &quot;--module-path&quot;;
1261         }
1262 
1263     } else if (JLI_StrCCmp(arg, &quot;--&quot;) == 0 &amp;&amp; (equals = JLI_StrChr(arg, &#39;=&#39;)) != NULL) {
1264         value = equals+1;
1265         if (JLI_StrCCmp(arg, &quot;--describe-module=&quot;) == 0 ||
1266             JLI_StrCCmp(arg, &quot;--module=&quot;) == 0 ||
1267             JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0||
1268             JLI_StrCCmp(arg, &quot;--source=&quot;) == 0) {
1269             kind = LAUNCHER_OPTION_WITH_ARGUMENT;
1270         } else {
1271             kind = VM_LONG_OPTION;
1272         }
1273     }
1274 
1275     *pargc = argc;
1276     *pargv = argv;
1277     *poption = option;
1278     *pvalue = value;
1279     return kind;
1280 }
1281 
1282 /*
1283  * Parses command line arguments.  Returns JNI_FALSE if launcher
1284  * should exit without starting vm, returns JNI_TRUE if vm needs
1285  * to be started to process given options.  *pret (the launcher
1286  * process return value) is set to 0 for a normal exit.
1287  */
1288 static jboolean
1289 ParseArguments(int *pargc, char ***pargv,
1290                int *pmode, char **pwhat,
1291                int *pret, const char *jrepath)
1292 {
1293     int argc = *pargc;
1294     char **argv = *pargv;
1295     int mode = LM_UNKNOWN;
1296     char *arg;
1297 
1298     *pret = 0;
1299 
1300     while ((arg = *argv) != 0 &amp;&amp; *arg == &#39;-&#39;) {
1301         char *option = NULL;
1302         char *value = NULL;
1303         int kind = GetOpt(&amp;argc, &amp;argv, &amp;option, &amp;value);
1304         jboolean has_arg = value != NULL &amp;&amp; JLI_StrLen(value) &gt; 0;
1305         jboolean has_arg_any_len = value != NULL;
1306 
1307 /*
1308  * Option to set main entry point
1309  */
1310         if (JLI_StrCmp(arg, &quot;-jar&quot;) == 0) {
1311             ARG_CHECK(argc, ARG_ERROR2, arg);
1312             mode = checkMode(mode, LM_JAR, arg);
1313         } else if (JLI_StrCmp(arg, &quot;--module&quot;) == 0 ||
1314                    JLI_StrCCmp(arg, &quot;--module=&quot;) == 0 ||
1315                    JLI_StrCmp(arg, &quot;-m&quot;) == 0) {
1316             REPORT_ERROR (has_arg, ARG_ERROR5, arg);
1317             SetMainModule(value);
1318             mode = checkMode(mode, LM_MODULE, arg);
1319             if (has_arg) {
1320                *pwhat = value;
1321                 break;
1322             }
1323         } else if (JLI_StrCmp(arg, &quot;--source&quot;) == 0 ||
1324                    JLI_StrCCmp(arg, &quot;--source=&quot;) == 0) {
1325             REPORT_ERROR (has_arg, ARG_ERROR13, arg);
1326             mode = LM_SOURCE;
1327             if (has_arg) {
1328                 const char *prop = &quot;-Djdk.internal.javac.source=&quot;;
1329                 size_t size = JLI_StrLen(prop) + JLI_StrLen(value) + 1;
1330                 char *propValue = (char *)JLI_MemAlloc(size);
1331                 JLI_Snprintf(propValue, size, &quot;%s%s&quot;, prop, value);
1332                 AddOption(propValue, NULL);
1333             }
1334         } else if (JLI_StrCmp(arg, &quot;--class-path&quot;) == 0 ||
1335                    JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0 ||
1336                    JLI_StrCmp(arg, &quot;-classpath&quot;) == 0 ||
1337                    JLI_StrCmp(arg, &quot;-cp&quot;) == 0) {
1338             REPORT_ERROR (has_arg_any_len, ARG_ERROR1, arg);
1339             SetClassPath(value);
1340             if (mode != LM_SOURCE) {
1341                 mode = LM_CLASS;
1342             }
1343         } else if (JLI_StrCmp(arg, &quot;--list-modules&quot;) == 0) {
1344             listModules = JNI_TRUE;
1345         } else if (JLI_StrCmp(arg, &quot;--show-resolved-modules&quot;) == 0) {
1346             showResolvedModules = JNI_TRUE;
1347         } else if (JLI_StrCmp(arg, &quot;--validate-modules&quot;) == 0) {
1348             AddOption(&quot;-Djdk.module.validation=true&quot;, NULL);
1349             validateModules = JNI_TRUE;
1350         } else if (JLI_StrCmp(arg, &quot;--describe-module&quot;) == 0 ||
1351                    JLI_StrCCmp(arg, &quot;--describe-module=&quot;) == 0 ||
1352                    JLI_StrCmp(arg, &quot;-d&quot;) == 0) {
1353             REPORT_ERROR (has_arg_any_len, ARG_ERROR12, arg);
1354             describeModule = value;
1355 /*
1356  * Parse white-space options
1357  */
1358         } else if (has_arg) {
1359             if (kind == VM_LONG_OPTION) {
1360                 AddOption(option, NULL);
1361             } else if (kind == VM_LONG_OPTION_WITH_ARGUMENT) {
1362                 AddLongFormOption(option, value);
1363             }
1364 /*
1365  * Error missing argument
1366  */
1367         } else if (!has_arg &amp;&amp; (JLI_StrCmp(arg, &quot;--module-path&quot;) == 0 ||
1368                                 JLI_StrCmp(arg, &quot;-p&quot;) == 0 ||
1369                                 JLI_StrCmp(arg, &quot;--upgrade-module-path&quot;) == 0)) {
1370             REPORT_ERROR (has_arg, ARG_ERROR4, arg);
1371 
1372         } else if (!has_arg &amp;&amp; (IsModuleOption(arg) || IsLongFormModuleOption(arg))) {
1373             REPORT_ERROR (has_arg, ARG_ERROR6, arg);
1374 /*
1375  * The following cases will cause the argument parsing to stop
1376  */
1377         } else if (JLI_StrCmp(arg, &quot;-help&quot;) == 0 ||
1378                    JLI_StrCmp(arg, &quot;-h&quot;) == 0 ||
1379                    JLI_StrCmp(arg, &quot;-?&quot;) == 0) {
1380             printUsage = JNI_TRUE;
1381             return JNI_TRUE;
1382         } else if (JLI_StrCmp(arg, &quot;--help&quot;) == 0) {
1383             printUsage = JNI_TRUE;
1384             printTo = USE_STDOUT;
1385             return JNI_TRUE;
1386         } else if (JLI_StrCmp(arg, &quot;-version&quot;) == 0) {
1387             printVersion = JNI_TRUE;
1388             return JNI_TRUE;
1389         } else if (JLI_StrCmp(arg, &quot;--version&quot;) == 0) {
1390             printVersion = JNI_TRUE;
1391             printTo = USE_STDOUT;
1392             return JNI_TRUE;
1393         } else if (JLI_StrCmp(arg, &quot;-showversion&quot;) == 0) {
1394             showVersion = JNI_TRUE;
1395         } else if (JLI_StrCmp(arg, &quot;--show-version&quot;) == 0) {
1396             showVersion = JNI_TRUE;
1397             printTo = USE_STDOUT;
1398         } else if (JLI_StrCmp(arg, &quot;--dry-run&quot;) == 0) {
1399             dryRun = JNI_TRUE;
1400         } else if (JLI_StrCmp(arg, &quot;-X&quot;) == 0) {
1401             printXUsage = JNI_TRUE;
1402             return JNI_TRUE;
1403         } else if (JLI_StrCmp(arg, &quot;--help-extra&quot;) == 0) {
1404             printXUsage = JNI_TRUE;
1405             printTo = USE_STDOUT;
1406             return JNI_TRUE;
1407 /*
1408  * The following case checks for -XshowSettings OR -XshowSetting:SUBOPT.
1409  * In the latter case, any SUBOPT value not recognized will default to &quot;all&quot;
1410  */
1411         } else if (JLI_StrCmp(arg, &quot;-XshowSettings&quot;) == 0 ||
1412                    JLI_StrCCmp(arg, &quot;-XshowSettings:&quot;) == 0) {
1413             showSettings = arg;
1414         } else if (JLI_StrCmp(arg, &quot;-Xdiag&quot;) == 0) {
1415             AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
1416         } else if (JLI_StrCmp(arg, &quot;--show-module-resolution&quot;) == 0) {
1417             AddOption(&quot;-Djdk.module.showModuleResolution=true&quot;, NULL);
1418 /*
1419  * The following case provide backward compatibility with old-style
1420  * command line options.
1421  */
1422         } else if (JLI_StrCmp(arg, &quot;-fullversion&quot;) == 0) {
1423             JLI_ReportMessage(&quot;%s full version \&quot;%s\&quot;&quot;, _launcher_name, GetFullVersion());
1424             return JNI_FALSE;
1425         } else if (JLI_StrCmp(arg, &quot;--full-version&quot;) == 0) {
1426             JLI_ShowMessage(&quot;%s %s&quot;, _launcher_name, GetFullVersion());
1427             return JNI_FALSE;
1428         } else if (JLI_StrCmp(arg, &quot;-verbosegc&quot;) == 0) {
1429             AddOption(&quot;-verbose:gc&quot;, NULL);
1430         } else if (JLI_StrCmp(arg, &quot;-t&quot;) == 0) {
1431             AddOption(&quot;-Xt&quot;, NULL);
1432         } else if (JLI_StrCmp(arg, &quot;-tm&quot;) == 0) {
1433             AddOption(&quot;-Xtm&quot;, NULL);
1434         } else if (JLI_StrCmp(arg, &quot;-debug&quot;) == 0) {
1435             AddOption(&quot;-Xdebug&quot;, NULL);
1436         } else if (JLI_StrCmp(arg, &quot;-noclassgc&quot;) == 0) {
1437             AddOption(&quot;-Xnoclassgc&quot;, NULL);
1438         } else if (JLI_StrCmp(arg, &quot;-Xfuture&quot;) == 0) {
<a name="10" id="anc10"></a>
1439             AddOption(&quot;-Xverify:all&quot;, NULL);
1440         } else if (JLI_StrCmp(arg, &quot;-verify&quot;) == 0) {
1441             AddOption(&quot;-Xverify:all&quot;, NULL);
1442         } else if (JLI_StrCmp(arg, &quot;-verifyremote&quot;) == 0) {
1443             AddOption(&quot;-Xverify:remote&quot;, NULL);
1444         } else if (JLI_StrCmp(arg, &quot;-noverify&quot;) == 0) {
<a name="11" id="anc11"></a>



1445             AddOption(&quot;-Xverify:none&quot;, NULL);
1446         } else if (JLI_StrCCmp(arg, &quot;-ss&quot;) == 0 ||
1447                    JLI_StrCCmp(arg, &quot;-oss&quot;) == 0 ||
1448                    JLI_StrCCmp(arg, &quot;-ms&quot;) == 0 ||
1449                    JLI_StrCCmp(arg, &quot;-mx&quot;) == 0) {
1450             char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);
1451             sprintf(tmp, &quot;-X%s&quot;, arg + 1); /* skip &#39;-&#39; */
1452             AddOption(tmp, NULL);
1453         } else if (JLI_StrCmp(arg, &quot;-checksource&quot;) == 0 ||
1454                    JLI_StrCmp(arg, &quot;-cs&quot;) == 0 ||
1455                    JLI_StrCmp(arg, &quot;-noasyncgc&quot;) == 0) {
1456             /* No longer supported */
1457             JLI_ReportErrorMessage(ARG_WARN, arg);
1458         } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1459             ; /* Ignore machine independent options already handled */
1460         } else if (ProcessPlatformOption(arg)) {
1461             ; /* Processing of platform dependent options */
1462         } else {
1463             /* java.class.path set on the command line */
1464             if (JLI_StrCCmp(arg, &quot;-Djava.class.path=&quot;) == 0) {
1465                 _have_classpath = JNI_TRUE;
1466             }
1467             AddOption(arg, NULL);
1468         }
1469     }
1470 
1471     if (*pwhat == NULL &amp;&amp; --argc &gt;= 0) {
1472         *pwhat = *argv++;
1473     }
1474 
1475     if (*pwhat == NULL) {
1476         /* LM_UNKNOWN okay for options that exit */
1477         if (!listModules &amp;&amp; !describeModule &amp;&amp; !validateModules) {
1478             *pret = 1;
1479         }
1480     } else if (mode == LM_UNKNOWN) {
1481         /* default to LM_CLASS if -m, -jar and -cp options are
1482          * not specified */
1483         if (!_have_classpath) {
1484             SetClassPath(&quot;.&quot;);
1485         }
1486         mode = IsSourceFile(arg) ? LM_SOURCE : LM_CLASS;
1487     } else if (mode == LM_CLASS &amp;&amp; IsSourceFile(arg)) {
1488         /* override LM_CLASS mode if given a source file */
1489         mode = LM_SOURCE;
1490     }
1491 
1492     if (mode == LM_SOURCE) {
1493         AddOption(&quot;--add-modules=ALL-DEFAULT&quot;, NULL);
1494         *pwhat = SOURCE_LAUNCHER_MAIN_ENTRY;
1495         // adjust (argc, argv) so that the name of the source file
1496         // is included in the args passed to the source launcher
1497         // main entry class
1498         *pargc = argc + 1;
1499         *pargv = argv - 1;
1500     } else {
1501         if (argc &gt;= 0) {
1502             *pargc = argc;
1503             *pargv = argv;
1504         }
1505     }
1506 
1507     *pmode = mode;
1508 
1509     return JNI_TRUE;
1510 }
1511 
1512 /*
1513  * Initializes the Java Virtual Machine. Also frees options array when
1514  * finished.
1515  */
1516 static jboolean
1517 InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
1518 {
1519     JavaVMInitArgs args;
1520     jint r;
1521 
1522     memset(&amp;args, 0, sizeof(args));
1523     args.version  = JNI_VERSION_1_2;
1524     args.nOptions = numOptions;
1525     args.options  = options;
1526     args.ignoreUnrecognized = JNI_FALSE;
1527 
1528     if (JLI_IsTraceLauncher()) {
1529         int i = 0;
1530         printf(&quot;JavaVM args:\n    &quot;);
1531         printf(&quot;version 0x%08lx, &quot;, (long)args.version);
1532         printf(&quot;ignoreUnrecognized is %s, &quot;,
1533                args.ignoreUnrecognized ? &quot;JNI_TRUE&quot; : &quot;JNI_FALSE&quot;);
1534         printf(&quot;nOptions is %ld\n&quot;, (long)args.nOptions);
1535         for (i = 0; i &lt; numOptions; i++)
1536             printf(&quot;    option[%2d] = &#39;%s&#39;\n&quot;,
1537                    i, args.options[i].optionString);
1538     }
1539 
1540     r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args);
1541     JLI_MemFree(options);
1542     return r == JNI_OK;
1543 }
1544 
1545 static jclass helperClass = NULL;
1546 
1547 jclass
1548 GetLauncherHelperClass(JNIEnv *env)
1549 {
1550     if (helperClass == NULL) {
1551         NULL_CHECK0(helperClass = FindBootStrapClass(env,
1552                 &quot;sun/launcher/LauncherHelper&quot;));
1553     }
1554     return helperClass;
1555 }
1556 
1557 static jmethodID makePlatformStringMID = NULL;
1558 /*
1559  * Returns a new Java string object for the specified platform string.
1560  */
1561 static jstring
1562 NewPlatformString(JNIEnv *env, char *s)
1563 {
1564     int len = (int)JLI_StrLen(s);
1565     jbyteArray ary;
1566     jclass cls = GetLauncherHelperClass(env);
1567     NULL_CHECK0(cls);
1568     if (s == NULL)
1569         return 0;
1570 
1571     ary = (*env)-&gt;NewByteArray(env, len);
1572     if (ary != 0) {
1573         jstring str = 0;
1574         (*env)-&gt;SetByteArrayRegion(env, ary, 0, len, (jbyte *)s);
1575         if (!(*env)-&gt;ExceptionOccurred(env)) {
1576             if (makePlatformStringMID == NULL) {
1577                 NULL_CHECK0(makePlatformStringMID = (*env)-&gt;GetStaticMethodID(env,
1578                         cls, &quot;makePlatformString&quot;, &quot;(Z[B)Ljava/lang/String;&quot;));
1579             }
1580             str = (*env)-&gt;CallStaticObjectMethod(env, cls,
1581                     makePlatformStringMID, USE_STDERR, ary);
1582             CHECK_EXCEPTION_RETURN_VALUE(0);
1583             (*env)-&gt;DeleteLocalRef(env, ary);
1584             return str;
1585         }
1586     }
1587     return 0;
1588 }
1589 
1590 /*
1591  * Returns a new array of Java string objects for the specified
1592  * array of platform strings.
1593  */
1594 jobjectArray
1595 NewPlatformStringArray(JNIEnv *env, char **strv, int strc)
1596 {
1597     jarray cls;
1598     jarray ary;
1599     int i;
1600 
1601     NULL_CHECK0(cls = FindBootStrapClass(env, &quot;java/lang/String&quot;));
1602     NULL_CHECK0(ary = (*env)-&gt;NewObjectArray(env, strc, cls, 0));
1603     CHECK_EXCEPTION_RETURN_VALUE(0);
1604     for (i = 0; i &lt; strc; i++) {
1605         jstring str = NewPlatformString(env, *strv++);
1606         NULL_CHECK0(str);
1607         (*env)-&gt;SetObjectArrayElement(env, ary, i, str);
1608         (*env)-&gt;DeleteLocalRef(env, str);
1609     }
1610     return ary;
1611 }
1612 
1613 /*
1614  * Loads a class and verifies that the main class is present and it is ok to
1615  * call it for more details refer to the java implementation.
1616  */
1617 static jclass
1618 LoadMainClass(JNIEnv *env, int mode, char *name)
1619 {
1620     jmethodID mid;
1621     jstring str;
1622     jobject result;
1623     jlong start, end;
1624     jclass cls = GetLauncherHelperClass(env);
1625     NULL_CHECK0(cls);
1626     if (JLI_IsTraceLauncher()) {
1627         start = CounterGet();
1628     }
1629     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1630                 &quot;checkAndLoadMain&quot;,
1631                 &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;));
1632 
1633     NULL_CHECK0(str = NewPlatformString(env, name));
1634     NULL_CHECK0(result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid,
1635                                                         USE_STDERR, mode, str));
1636 
1637     if (JLI_IsTraceLauncher()) {
1638         end   = CounterGet();
1639         printf(&quot;%ld micro seconds to load main class\n&quot;,
1640                (long)(jint)Counter2Micros(end-start));
1641         printf(&quot;----%s----\n&quot;, JLDEBUG_ENV_ENTRY);
1642     }
1643 
1644     return (jclass)result;
1645 }
1646 
1647 static jclass
1648 GetApplicationClass(JNIEnv *env)
1649 {
1650     jmethodID mid;
1651     jclass appClass;
1652     jclass cls = GetLauncherHelperClass(env);
1653     NULL_CHECK0(cls);
1654     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1655                 &quot;getApplicationClass&quot;,
1656                 &quot;()Ljava/lang/Class;&quot;));
1657 
1658     appClass = (*env)-&gt;CallStaticObjectMethod(env, cls, mid);
1659     CHECK_EXCEPTION_RETURN_VALUE(0);
1660     return appClass;
1661 }
1662 
1663 static char* expandWildcardOnLongOpt(char* arg) {
1664     char *p, *value;
1665     size_t optLen, valueLen;
1666     p = JLI_StrChr(arg, &#39;=&#39;);
1667 
1668     if (p == NULL || p[1] == &#39;\0&#39;) {
1669         JLI_ReportErrorMessage(ARG_ERROR1, arg);
1670         exit(1);
1671     }
1672     p++;
1673     value = (char *) JLI_WildcardExpandClasspath(p);
1674     if (p == value) {
1675         // no wildcard
1676         return arg;
1677     }
1678 
1679     optLen = p - arg;
1680     valueLen = JLI_StrLen(value);
1681     p = JLI_MemAlloc(optLen + valueLen + 1);
1682     memcpy(p, arg, optLen);
1683     memcpy(p + optLen, value, valueLen);
1684     p[optLen + valueLen] = &#39;\0&#39;;
1685     return p;
1686 }
1687 
1688 /*
1689  * For tools, convert command line args thus:
1690  *   javac -cp foo:foo/&quot;*&quot; -J-ms32m ...
1691  *   java -ms32m -cp JLI_WildcardExpandClasspath(foo:foo/&quot;*&quot;) ...
1692  *
1693  * Takes 4 parameters, and returns the populated arguments
1694  */
1695 static void
1696 TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv)
1697 {
1698     int argc = *pargc;
1699     char **argv = *pargv;
1700     int nargc = argc + jargc;
1701     char **nargv = JLI_MemAlloc((nargc + 1) * sizeof(char *));
1702     int i;
1703 
1704     *pargc = nargc;
1705     *pargv = nargv;
1706 
1707     /* Copy the VM arguments (i.e. prefixed with -J) */
1708     for (i = 0; i &lt; jargc; i++) {
1709         const char *arg = jargv[i];
1710         if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1711             *nargv++ = ((arg + 2) == NULL) ? NULL : JLI_StringDup(arg + 2);
1712         }
1713     }
1714 
1715     for (i = 0; i &lt; argc; i++) {
1716         char *arg = argv[i];
1717         if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1718             if (arg[2] == &#39;\0&#39;) {
1719                 JLI_ReportErrorMessage(ARG_ERROR3);
1720                 exit(1);
1721             }
1722             *nargv++ = arg + 2;
1723         }
1724     }
1725 
1726     /* Copy the rest of the arguments */
1727     for (i = 0; i &lt; jargc ; i++) {
1728         const char *arg = jargv[i];
1729         if (arg[0] != &#39;-&#39; || arg[1] != &#39;J&#39;) {
1730             *nargv++ = (arg == NULL) ? NULL : JLI_StringDup(arg);
1731         }
1732     }
1733     for (i = 0; i &lt; argc; i++) {
1734         char *arg = argv[i];
1735         if (arg[0] == &#39;-&#39;) {
1736             if (arg[1] == &#39;J&#39;)
1737                 continue;
1738             if (IsWildCardEnabled()) {
1739                 if (IsClassPathOption(arg) &amp;&amp; i &lt; argc - 1) {
1740                     *nargv++ = arg;
1741                     *nargv++ = (char *) JLI_WildcardExpandClasspath(argv[i+1]);
1742                     i++;
1743                     continue;
1744                 }
1745                 if (JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0) {
1746                     *nargv++ = expandWildcardOnLongOpt(arg);
1747                     continue;
1748                 }
1749             }
1750         }
1751         *nargv++ = arg;
1752     }
1753     *nargv = 0;
1754 }
1755 
1756 /*
1757  * For our tools, we try to add 3 VM options:
1758  *      -Denv.class.path=&lt;envcp&gt;
1759  *      -Dapplication.home=&lt;apphome&gt;
1760  *      -Djava.class.path=&lt;appcp&gt;
1761  * &lt;envcp&gt;   is the user&#39;s setting of CLASSPATH -- for instance the user
1762  *           tells javac where to find binary classes through this environment
1763  *           variable.  Notice that users will be able to compile against our
1764  *           tools classes (sun.tools.javac.Main) only if they explicitly add
1765  *           tools.jar to CLASSPATH.
1766  * &lt;apphome&gt; is the directory where the application is installed.
1767  * &lt;appcp&gt;   is the classpath to where our apps&#39; classfiles are.
1768  */
1769 static jboolean
1770 AddApplicationOptions(int cpathc, const char **cpathv)
1771 {
1772     char *envcp, *appcp, *apphome;
1773     char home[MAXPATHLEN]; /* application home */
1774     char separator[] = { PATH_SEPARATOR, &#39;\0&#39; };
1775     int size, i;
1776 
1777     {
1778         const char *s = getenv(&quot;CLASSPATH&quot;);
1779         if (s) {
1780             s = (char *) JLI_WildcardExpandClasspath(s);
1781             /* 40 for -Denv.class.path= */
1782             if (JLI_StrLen(s) + 40 &gt; JLI_StrLen(s)) { // Safeguard from overflow
1783                 envcp = (char *)JLI_MemAlloc(JLI_StrLen(s) + 40);
1784                 sprintf(envcp, &quot;-Denv.class.path=%s&quot;, s);
1785                 AddOption(envcp, NULL);
1786             }
1787         }
1788     }
1789 
1790     if (!GetApplicationHome(home, sizeof(home))) {
1791         JLI_ReportErrorMessage(CFG_ERROR5);
1792         return JNI_FALSE;
1793     }
1794 
1795     /* 40 for &#39;-Dapplication.home=&#39; */
1796     apphome = (char *)JLI_MemAlloc(JLI_StrLen(home) + 40);
1797     sprintf(apphome, &quot;-Dapplication.home=%s&quot;, home);
1798     AddOption(apphome, NULL);
1799 
1800     /* How big is the application&#39;s classpath? */
1801     if (cpathc &gt; 0) {
1802         size = 40;                                 /* 40: &quot;-Djava.class.path=&quot; */
1803         for (i = 0; i &lt; cpathc; i++) {
1804             size += (int)JLI_StrLen(home) + (int)JLI_StrLen(cpathv[i]) + 1; /* 1: separator */
1805         }
1806         appcp = (char *)JLI_MemAlloc(size + 1);
1807         JLI_StrCpy(appcp, &quot;-Djava.class.path=&quot;);
1808         for (i = 0; i &lt; cpathc; i++) {
1809             JLI_StrCat(appcp, home);                        /* c:\program files\myapp */
1810             JLI_StrCat(appcp, cpathv[i]);           /* \lib\myapp.jar         */
1811             JLI_StrCat(appcp, separator);           /* ;                      */
1812         }
1813         appcp[JLI_StrLen(appcp)-1] = &#39;\0&#39;;  /* remove trailing path separator */
1814         AddOption(appcp, NULL);
1815     }
1816     return JNI_TRUE;
1817 }
1818 
1819 /*
1820  * inject the -Dsun.java.command pseudo property into the args structure
1821  * this pseudo property is used in the HotSpot VM to expose the
1822  * Java class name and arguments to the main method to the VM. The
1823  * HotSpot VM uses this pseudo property to store the Java class name
1824  * (or jar file name) and the arguments to the class&#39;s main method
1825  * to the instrumentation memory region. The sun.java.command pseudo
1826  * property is not exported by HotSpot to the Java layer.
1827  */
1828 void
1829 SetJavaCommandLineProp(char *what, int argc, char **argv)
1830 {
1831 
1832     int i = 0;
1833     size_t len = 0;
1834     char* javaCommand = NULL;
1835     char* dashDstr = &quot;-Dsun.java.command=&quot;;
1836 
1837     if (what == NULL) {
1838         /* unexpected, one of these should be set. just return without
1839          * setting the property
1840          */
1841         return;
1842     }
1843 
1844     /* determine the amount of memory to allocate assuming
1845      * the individual components will be space separated
1846      */
1847     len = JLI_StrLen(what);
1848     for (i = 0; i &lt; argc; i++) {
1849         len += JLI_StrLen(argv[i]) + 1;
1850     }
1851 
1852     /* allocate the memory */
1853     javaCommand = (char*) JLI_MemAlloc(len + JLI_StrLen(dashDstr) + 1);
1854 
1855     /* build the -D string */
1856     *javaCommand = &#39;\0&#39;;
1857     JLI_StrCat(javaCommand, dashDstr);
1858     JLI_StrCat(javaCommand, what);
1859 
1860     for (i = 0; i &lt; argc; i++) {
1861         /* the components of the string are space separated. In
1862          * the case of embedded white space, the relationship of
1863          * the white space separated components to their true
1864          * positional arguments will be ambiguous. This issue may
1865          * be addressed in a future release.
1866          */
1867         JLI_StrCat(javaCommand, &quot; &quot;);
1868         JLI_StrCat(javaCommand, argv[i]);
1869     }
1870 
1871     AddOption(javaCommand, NULL);
1872 }
1873 
1874 /*
1875  * JVM would like to know if it&#39;s created by a standard Sun launcher, or by
1876  * user native application, the following property indicates the former.
1877  */
<a name="12" id="anc12"></a><span class="line-modified">1878 void</span>
<span class="line-removed">1879 SetJavaLauncherProp() {</span>
1880   AddOption(&quot;-Dsun.java.launcher=SUN_STANDARD&quot;, NULL);
1881 }
1882 
1883 /*
1884  * Prints the version information from the java.version and other properties.
1885  */
1886 static void
1887 PrintJavaVersion(JNIEnv *env, jboolean extraLF)
1888 {
1889     jclass ver;
1890     jmethodID print;
1891 
1892     NULL_CHECK(ver = FindBootStrapClass(env, &quot;java/lang/VersionProps&quot;));
1893     NULL_CHECK(print = (*env)-&gt;GetStaticMethodID(env,
1894                                                  ver,
1895                                                  (extraLF == JNI_TRUE) ? &quot;println&quot; : &quot;print&quot;,
1896                                                  &quot;(Z)V&quot;
1897                                                  )
1898               );
1899 
1900     (*env)-&gt;CallStaticVoidMethod(env, ver, print, printTo);
1901 }
1902 
1903 /*
1904  * Prints all the Java settings, see the java implementation for more details.
1905  */
1906 static void
1907 ShowSettings(JNIEnv *env, char *optString)
1908 {
1909     jmethodID showSettingsID;
1910     jstring joptString;
1911     jclass cls = GetLauncherHelperClass(env);
1912     NULL_CHECK(cls);
1913     NULL_CHECK(showSettingsID = (*env)-&gt;GetStaticMethodID(env, cls,
1914             &quot;showSettings&quot;, &quot;(ZLjava/lang/String;JJJ)V&quot;));
1915     NULL_CHECK(joptString = (*env)-&gt;NewStringUTF(env, optString));
1916     (*env)-&gt;CallStaticVoidMethod(env, cls, showSettingsID,
1917                                  USE_STDERR,
1918                                  joptString,
1919                                  (jlong)initialHeapSize,
1920                                  (jlong)maxHeapSize,
1921                                  (jlong)threadStackSize);
1922 }
1923 
1924 /**
1925  * Show resolved modules
1926  */
1927 static void
1928 ShowResolvedModules(JNIEnv *env)
1929 {
1930     jmethodID showResolvedModulesID;
1931     jclass cls = GetLauncherHelperClass(env);
1932     NULL_CHECK(cls);
1933     NULL_CHECK(showResolvedModulesID = (*env)-&gt;GetStaticMethodID(env, cls,
1934             &quot;showResolvedModules&quot;, &quot;()V&quot;));
1935     (*env)-&gt;CallStaticVoidMethod(env, cls, showResolvedModulesID);
1936 }
1937 
1938 /**
1939  * List observable modules
1940  */
1941 static void
1942 ListModules(JNIEnv *env)
1943 {
1944     jmethodID listModulesID;
1945     jclass cls = GetLauncherHelperClass(env);
1946     NULL_CHECK(cls);
1947     NULL_CHECK(listModulesID = (*env)-&gt;GetStaticMethodID(env, cls,
1948             &quot;listModules&quot;, &quot;()V&quot;));
1949     (*env)-&gt;CallStaticVoidMethod(env, cls, listModulesID);
1950 }
1951 
1952 /**
1953  * Describe a module
1954  */
1955 static void
1956 DescribeModule(JNIEnv *env, char *optString)
1957 {
1958     jmethodID describeModuleID;
1959     jstring joptString = NULL;
1960     jclass cls = GetLauncherHelperClass(env);
1961     NULL_CHECK(cls);
1962     NULL_CHECK(describeModuleID = (*env)-&gt;GetStaticMethodID(env, cls,
1963             &quot;describeModule&quot;, &quot;(Ljava/lang/String;)V&quot;));
1964     NULL_CHECK(joptString = (*env)-&gt;NewStringUTF(env, optString));
1965     (*env)-&gt;CallStaticVoidMethod(env, cls, describeModuleID, joptString);
1966 }
1967 
1968 /*
1969  * Prints default usage or the Xusage message, see sun.launcher.LauncherHelper.java
1970  */
1971 static void
1972 PrintUsage(JNIEnv* env, jboolean doXUsage)
1973 {
1974   jmethodID initHelp, vmSelect, vmSynonym, printHelp, printXUsageMessage;
1975   jstring jprogname, vm1, vm2;
1976   int i;
1977   jclass cls = GetLauncherHelperClass(env);
1978   NULL_CHECK(cls);
1979   if (doXUsage) {
1980     NULL_CHECK(printXUsageMessage = (*env)-&gt;GetStaticMethodID(env, cls,
1981                                         &quot;printXUsageMessage&quot;, &quot;(Z)V&quot;));
1982     (*env)-&gt;CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);
1983   } else {
1984     NULL_CHECK(initHelp = (*env)-&gt;GetStaticMethodID(env, cls,
1985                                         &quot;initHelpMessage&quot;, &quot;(Ljava/lang/String;)V&quot;));
1986 
1987     NULL_CHECK(vmSelect = (*env)-&gt;GetStaticMethodID(env, cls, &quot;appendVmSelectMessage&quot;,
1988                                         &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;));
1989 
1990     NULL_CHECK(vmSynonym = (*env)-&gt;GetStaticMethodID(env, cls,
1991                                         &quot;appendVmSynonymMessage&quot;,
1992                                         &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;));
1993 
1994     NULL_CHECK(printHelp = (*env)-&gt;GetStaticMethodID(env, cls,
1995                                         &quot;printHelpMessage&quot;, &quot;(Z)V&quot;));
1996 
1997     NULL_CHECK(jprogname = (*env)-&gt;NewStringUTF(env, _program_name));
1998 
1999     /* Initialize the usage message with the usual preamble */
2000     (*env)-&gt;CallStaticVoidMethod(env, cls, initHelp, jprogname);
2001     CHECK_EXCEPTION_RETURN();
2002 
2003 
2004     /* Assemble the other variant part of the usage */
2005     for (i=1; i&lt;knownVMsCount; i++) {
2006       if (knownVMs[i].flag == VM_KNOWN) {
2007         NULL_CHECK(vm1 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name));
2008         NULL_CHECK(vm2 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name+1));
2009         (*env)-&gt;CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);
2010         CHECK_EXCEPTION_RETURN();
2011       }
2012     }
2013     for (i=1; i&lt;knownVMsCount; i++) {
2014       if (knownVMs[i].flag == VM_ALIASED_TO) {
2015         NULL_CHECK(vm1 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name));
2016         NULL_CHECK(vm2 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].alias+1));
2017         (*env)-&gt;CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);
2018         CHECK_EXCEPTION_RETURN();
2019       }
2020     }
2021 
2022     /* Complete the usage message and print to stderr*/
2023     (*env)-&gt;CallStaticVoidMethod(env, cls, printHelp, printTo);
2024   }
2025   return;
2026 }
2027 
2028 /*
2029  * Read the jvm.cfg file and fill the knownJVMs[] array.
2030  *
2031  * The functionality of the jvm.cfg file is subject to change without
2032  * notice and the mechanism will be removed in the future.
2033  *
2034  * The lexical structure of the jvm.cfg file is as follows:
2035  *
2036  *     jvmcfg         :=  { vmLine }
2037  *     vmLine         :=  knownLine
2038  *                    |   aliasLine
2039  *                    |   warnLine
2040  *                    |   ignoreLine
2041  *                    |   errorLine
2042  *                    |   predicateLine
2043  *                    |   commentLine
2044  *     knownLine      :=  flag  &quot;KNOWN&quot;                  EOL
2045  *     warnLine       :=  flag  &quot;WARN&quot;                   EOL
2046  *     ignoreLine     :=  flag  &quot;IGNORE&quot;                 EOL
2047  *     errorLine      :=  flag  &quot;ERROR&quot;                  EOL
2048  *     aliasLine      :=  flag  &quot;ALIASED_TO&quot;       flag  EOL
2049  *     predicateLine  :=  flag  &quot;IF_SERVER_CLASS&quot;  flag  EOL
2050  *     commentLine    :=  &quot;#&quot; text                       EOL
2051  *     flag           :=  &quot;-&quot; identifier
2052  *
2053  * The semantics are that when someone specifies a flag on the command line:
2054  * - if the flag appears on a knownLine, then the identifier is used as
2055  *   the name of the directory holding the JVM library (the name of the JVM).
2056  * - if the flag appears as the first flag on an aliasLine, the identifier
2057  *   of the second flag is used as the name of the JVM.
2058  * - if the flag appears on a warnLine, the identifier is used as the
2059  *   name of the JVM, but a warning is generated.
2060  * - if the flag appears on an ignoreLine, the identifier is recognized as the
2061  *   name of a JVM, but the identifier is ignored and the default vm used
2062  * - if the flag appears on an errorLine, an error is generated.
2063  * - if the flag appears as the first flag on a predicateLine, and
2064  *   the machine on which you are running passes the predicate indicated,
2065  *   then the identifier of the second flag is used as the name of the JVM,
2066  *   otherwise the identifier of the first flag is used as the name of the JVM.
2067  * If no flag is given on the command line, the first vmLine of the jvm.cfg
2068  * file determines the name of the JVM.
2069  * PredicateLines are only interpreted on first vmLine of a jvm.cfg file,
2070  * since they only make sense if someone hasn&#39;t specified the name of the
2071  * JVM on the command line.
2072  *
2073  * The intent of the jvm.cfg file is to allow several JVM libraries to
2074  * be installed in different subdirectories of a single JRE installation,
2075  * for space-savings and convenience in testing.
2076  * The intent is explicitly not to provide a full aliasing or predicate
2077  * mechanism.
2078  */
2079 jint
2080 ReadKnownVMs(const char *jvmCfgName, jboolean speculative)
2081 {
2082     FILE *jvmCfg;
2083     char line[MAXPATHLEN+20];
2084     int cnt = 0;
2085     int lineno = 0;
2086     jlong start, end;
2087     int vmType;
2088     char *tmpPtr;
2089     char *altVMName = NULL;
2090     char *serverClassVMName = NULL;
2091     static char *whiteSpace = &quot; \t&quot;;
2092     if (JLI_IsTraceLauncher()) {
2093         start = CounterGet();
2094     }
2095 
2096     jvmCfg = fopen(jvmCfgName, &quot;r&quot;);
2097     if (jvmCfg == NULL) {
2098       if (!speculative) {
2099         JLI_ReportErrorMessage(CFG_ERROR6, jvmCfgName);
2100         exit(1);
2101       } else {
2102         return -1;
2103       }
2104     }
2105     while (fgets(line, sizeof(line), jvmCfg) != NULL) {
2106         vmType = VM_UNKNOWN;
2107         lineno++;
2108         if (line[0] == &#39;#&#39;)
2109             continue;
2110         if (line[0] != &#39;-&#39;) {
2111             JLI_ReportErrorMessage(CFG_WARN2, lineno, jvmCfgName);
2112         }
2113         if (cnt &gt;= knownVMsLimit) {
2114             GrowKnownVMs(cnt);
2115         }
2116         line[JLI_StrLen(line)-1] = &#39;\0&#39;; /* remove trailing newline */
2117         tmpPtr = line + JLI_StrCSpn(line, whiteSpace);
2118         if (*tmpPtr == 0) {
2119             JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2120         } else {
2121             /* Null-terminate this string for JLI_StringDup below */
2122             *tmpPtr++ = 0;
2123             tmpPtr += JLI_StrSpn(tmpPtr, whiteSpace);
2124             if (*tmpPtr == 0) {
2125                 JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2126             } else {
2127                 if (!JLI_StrCCmp(tmpPtr, &quot;KNOWN&quot;)) {
2128                     vmType = VM_KNOWN;
2129                 } else if (!JLI_StrCCmp(tmpPtr, &quot;ALIASED_TO&quot;)) {
2130                     tmpPtr += JLI_StrCSpn(tmpPtr, whiteSpace);
2131                     if (*tmpPtr != 0) {
2132                         tmpPtr += JLI_StrSpn(tmpPtr, whiteSpace);
2133                     }
2134                     if (*tmpPtr == 0) {
2135                         JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2136                     } else {
2137                         /* Null terminate altVMName */
2138                         altVMName = tmpPtr;
2139                         tmpPtr += JLI_StrCSpn(tmpPtr, whiteSpace);
2140                         *tmpPtr = 0;
2141                         vmType = VM_ALIASED_TO;
2142                     }
2143                 } else if (!JLI_StrCCmp(tmpPtr, &quot;WARN&quot;)) {
2144                     vmType = VM_WARN;
2145                 } else if (!JLI_StrCCmp(tmpPtr, &quot;IGNORE&quot;)) {
2146                     vmType = VM_IGNORE;
2147                 } else if (!JLI_StrCCmp(tmpPtr, &quot;ERROR&quot;)) {
2148                     vmType = VM_ERROR;
2149                 } else if (!JLI_StrCCmp(tmpPtr, &quot;IF_SERVER_CLASS&quot;)) {
2150                     /* ignored */
2151                 } else {
2152                     JLI_ReportErrorMessage(CFG_WARN5, lineno, &amp;jvmCfgName[0]);
2153                     vmType = VM_KNOWN;
2154                 }
2155             }
2156         }
2157 
2158         JLI_TraceLauncher(&quot;jvm.cfg[%d] = -&gt;%s&lt;-\n&quot;, cnt, line);
2159         if (vmType != VM_UNKNOWN) {
2160             knownVMs[cnt].name = JLI_StringDup(line);
2161             knownVMs[cnt].flag = vmType;
2162             switch (vmType) {
2163             default:
2164                 break;
2165             case VM_ALIASED_TO:
2166                 knownVMs[cnt].alias = JLI_StringDup(altVMName);
2167                 JLI_TraceLauncher(&quot;    name: %s  vmType: %s  alias: %s\n&quot;,
2168                    knownVMs[cnt].name, &quot;VM_ALIASED_TO&quot;, knownVMs[cnt].alias);
2169                 break;
2170             }
2171             cnt++;
2172         }
2173     }
2174     fclose(jvmCfg);
2175     knownVMsCount = cnt;
2176 
2177     if (JLI_IsTraceLauncher()) {
2178         end   = CounterGet();
2179         printf(&quot;%ld micro seconds to parse jvm.cfg\n&quot;,
2180                (long)(jint)Counter2Micros(end-start));
2181     }
2182 
2183     return cnt;
2184 }
2185 
2186 
2187 static void
2188 GrowKnownVMs(int minimum)
2189 {
2190     struct vmdesc* newKnownVMs;
2191     int newMax;
2192 
2193     newMax = (knownVMsLimit == 0 ? INIT_MAX_KNOWN_VMS : (2 * knownVMsLimit));
2194     if (newMax &lt;= minimum) {
2195         newMax = minimum;
2196     }
2197     newKnownVMs = (struct vmdesc*) JLI_MemAlloc(newMax * sizeof(struct vmdesc));
2198     if (knownVMs != NULL) {
2199         memcpy(newKnownVMs, knownVMs, knownVMsLimit * sizeof(struct vmdesc));
2200     }
2201     JLI_MemFree(knownVMs);
2202     knownVMs = newKnownVMs;
2203     knownVMsLimit = newMax;
2204 }
2205 
2206 
2207 /* Returns index of VM or -1 if not found */
2208 static int
2209 KnownVMIndex(const char* name)
2210 {
2211     int i;
2212     if (JLI_StrCCmp(name, &quot;-J&quot;) == 0) name += 2;
2213     for (i = 0; i &lt; knownVMsCount; i++) {
2214         if (!JLI_StrCmp(name, knownVMs[i].name)) {
2215             return i;
2216         }
2217     }
2218     return -1;
2219 }
2220 
2221 static void
2222 FreeKnownVMs()
2223 {
2224     int i;
2225     for (i = 0; i &lt; knownVMsCount; i++) {
2226         JLI_MemFree(knownVMs[i].name);
2227         knownVMs[i].name = NULL;
2228     }
2229     JLI_MemFree(knownVMs);
2230 }
2231 
2232 /*
2233  * Displays the splash screen according to the jar file name
2234  * and image file names stored in environment variables
2235  */
2236 void
2237 ShowSplashScreen()
2238 {
2239     const char *jar_name = getenv(SPLASH_JAR_ENV_ENTRY);
2240     const char *file_name = getenv(SPLASH_FILE_ENV_ENTRY);
2241     int data_size;
2242     void *image_data = NULL;
2243     float scale_factor = 1;
2244     char *scaled_splash_name = NULL;
2245     jboolean isImageScaled = JNI_FALSE;
2246     size_t maxScaledImgNameLength = 0;
2247     if (file_name == NULL){
2248         return;
2249     }
<a name="13" id="anc13"></a>




2250     maxScaledImgNameLength = DoSplashGetScaledImgNameMaxPstfixLen(file_name);
2251 
2252     scaled_splash_name = JLI_MemAlloc(
2253                             maxScaledImgNameLength * sizeof(char));
2254     isImageScaled = DoSplashGetScaledImageName(jar_name, file_name,
2255                             &amp;scale_factor,
2256                             scaled_splash_name, maxScaledImgNameLength);
2257     if (jar_name) {
2258 
2259         if (isImageScaled) {
2260             image_data = JLI_JarUnpackFile(
2261                     jar_name, scaled_splash_name, &amp;data_size);
2262         }
2263 
2264         if (!image_data) {
2265             scale_factor = 1;
2266             image_data = JLI_JarUnpackFile(
2267                             jar_name, file_name, &amp;data_size);
2268         }
2269         if (image_data) {
<a name="14" id="anc14"></a><span class="line-removed">2270             DoSplashInit();</span>
2271             DoSplashSetScaleFactor(scale_factor);
2272             DoSplashLoadMemory(image_data, data_size);
2273             JLI_MemFree(image_data);
<a name="15" id="anc15"></a>

2274         }
2275     } else {
<a name="16" id="anc16"></a><span class="line-removed">2276         DoSplashInit();</span>
2277         if (isImageScaled) {
2278             DoSplashSetScaleFactor(scale_factor);
2279             DoSplashLoadFile(scaled_splash_name);
2280         } else {
2281             DoSplashLoadFile(file_name);
2282         }
2283     }
2284     JLI_MemFree(scaled_splash_name);
2285 
2286     DoSplashSetFileJarName(file_name, jar_name);
2287 
<a name="17" id="anc17"></a>
2288     /*
2289      * Done with all command line processing and potential re-execs so
2290      * clean up the environment.
2291      */
2292     (void)UnsetEnv(ENV_ENTRY);
2293     (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
2294     (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
2295 
2296     JLI_MemFree(splash_jar_entry);
2297     JLI_MemFree(splash_file_entry);
2298 
2299 }
2300 
<a name="18" id="anc18"></a><span class="line-modified">2301 const char*</span>
<span class="line-removed">2302 GetFullVersion()</span>
2303 {
2304     return _fVersion;
2305 }
2306 
<a name="19" id="anc19"></a><span class="line-modified">2307 const char*</span>
<span class="line-removed">2308 GetProgramName()</span>
2309 {
2310     return _program_name;
2311 }
2312 
<a name="20" id="anc20"></a><span class="line-modified">2313 const char*</span>
<span class="line-removed">2314 GetLauncherName()</span>
2315 {
2316     return _launcher_name;
2317 }
2318 
<a name="21" id="anc21"></a><span class="line-modified">2319 jboolean</span>
<span class="line-removed">2320 IsJavaArgs()</span>
2321 {
2322     return _is_java_args;
2323 }
2324 
2325 static jboolean
2326 IsWildCardEnabled()
2327 {
2328     return _wc_enabled;
2329 }
2330 
2331 int
2332 ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
2333                     int argc, char **argv,
2334                     int mode, char *what, int ret)
2335 {
<a name="22" id="anc22"></a><span class="line-removed">2336 </span>
<span class="line-removed">2337     /*</span>
<span class="line-removed">2338      * If user doesn&#39;t specify stack size, check if VM has a preference.</span>
<span class="line-removed">2339      * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will</span>
<span class="line-removed">2340      * return its default stack size through the init args structure.</span>
<span class="line-removed">2341      */</span>
2342     if (threadStackSize == 0) {
<a name="23" id="anc23"></a><span class="line-modified">2343       struct JDK1_1InitArgs args1_1;</span>
<span class="line-modified">2344       memset((void*)&amp;args1_1, 0, sizeof(args1_1));</span>
<span class="line-modified">2345       args1_1.version = JNI_VERSION_1_1;</span>
<span class="line-modified">2346       ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1);  /* ignore return value */</span>
<span class="line-modified">2347       if (args1_1.javaStackSize &gt; 0) {</span>
<span class="line-modified">2348          threadStackSize = args1_1.javaStackSize;</span>
<span class="line-modified">2349       }</span>






2350     }
2351 
2352     { /* Create a new thread to create JVM and invoke main method */
<a name="24" id="anc24"></a><span class="line-modified">2353       JavaMainArgs args;</span>
<span class="line-modified">2354       int rslt;</span>
<span class="line-modified">2355 </span>
<span class="line-modified">2356       args.argc = argc;</span>
<span class="line-modified">2357       args.argv = argv;</span>
<span class="line-modified">2358       args.mode = mode;</span>
<span class="line-modified">2359       args.what = what;</span>
<span class="line-modified">2360       args.ifn = *ifn;</span>
<span class="line-modified">2361 </span>
<span class="line-modified">2362       rslt = CallJavaMainInNewThread(threadStackSize, (void*)&amp;args);</span>
<span class="line-modified">2363       /* If the caller has deemed there is an error we</span>
<span class="line-modified">2364        * simply return that, otherwise we return the value of</span>
<span class="line-modified">2365        * the callee</span>
<span class="line-modified">2366        */</span>
<span class="line-modified">2367       return (ret != 0) ? ret : rslt;</span>
2368     }
2369 }
2370 
2371 static void
2372 DumpState()
2373 {
2374     if (!JLI_IsTraceLauncher()) return ;
2375     printf(&quot;Launcher state:\n&quot;);
2376     printf(&quot;\tFirst application arg index: %d\n&quot;, JLI_GetAppArgIndex());
2377     printf(&quot;\tdebug:%s\n&quot;, (JLI_IsTraceLauncher() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2378     printf(&quot;\tjavargs:%s\n&quot;, (_is_java_args == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2379     printf(&quot;\tprogram name:%s\n&quot;, GetProgramName());
2380     printf(&quot;\tlauncher name:%s\n&quot;, GetLauncherName());
2381     printf(&quot;\tjavaw:%s\n&quot;, (IsJavaw() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2382     printf(&quot;\tfullversion:%s\n&quot;, GetFullVersion());
2383 }
2384 
2385 /*
2386  * A utility procedure to always print to stderr
2387  */
2388 JNIEXPORT void JNICALL
2389 JLI_ReportMessage(const char* fmt, ...)
2390 {
2391     va_list vl;
2392     va_start(vl, fmt);
2393     vfprintf(stderr, fmt, vl);
2394     fprintf(stderr, &quot;\n&quot;);
2395     va_end(vl);
2396 }
2397 
2398 /*
2399  * A utility procedure to always print to stdout
2400  */
2401 void
2402 JLI_ShowMessage(const char* fmt, ...)
2403 {
2404     va_list vl;
2405     va_start(vl, fmt);
2406     vfprintf(stdout, fmt, vl);
2407     fprintf(stdout, &quot;\n&quot;);
2408     va_end(vl);
2409 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
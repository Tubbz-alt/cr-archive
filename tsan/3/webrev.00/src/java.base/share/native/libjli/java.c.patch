diff a/src/java.base/share/native/libjli/java.c b/src/java.base/share/native/libjli/java.c
--- a/src/java.base/share/native/libjli/java.c
+++ b/src/java.base/share/native/libjli/java.c
@@ -100,10 +100,13 @@
 static int numOptions, maxOptions;
 
 /*
  * Prototypes for functions internal to launcher.
  */
+static const char* GetFullVersion();
+static jboolean IsJavaArgs();
+static void SetJavaLauncherProp();
 static void SetClassPath(const char *s);
 static void SetMainModule(const char *s);
 static void SelectVersion(int argc, char **argv, char **main_class);
 static void SetJvmEnvironment(int argc, char **argv);
 static jboolean ParseArguments(int *pargc, char ***pargv,
@@ -202,15 +205,18 @@
  * Running Java code in primordial thread caused many problems. We will
  * create a new thread to invoke JVM. See 6316197 for more information.
  */
 static jlong threadStackSize    = 0;  /* stack size of the new thread */
 static jlong maxHeapSize        = 0;  /* max heap size */
-static jlong initialHeapSize    = 0;  /* inital heap size */
+static jlong initialHeapSize    = 0;  /* initial heap size */
 
 /*
- * A minimum -Xss stack size suitable for all platforms.
- */
+ * A minimum initial-thread stack size suitable for most platforms.
+ * This is the minimum amount of stack needed to load the JVM such
+ * that it can reject a too small -Xss value. If this is too small
+ * JVM initialization would cause a StackOverflowError.
+  */
 #ifndef STACK_SIZE_MINIMUM
 #define STACK_SIZE_MINIMUM (64 * KB)
 #endif
 
 #ifdef INCLUDE_TSAN
@@ -344,13 +350,10 @@
     SetJavaCommandLineProp(what, argc, argv);
 
     /* Set the -Dsun.java.launcher pseudo property */
     SetJavaLauncherProp();
 
-    /* set the -Dsun.java.launcher.* platform properties */
-    SetJavaLauncherPlatformProps();
-
     return JVMInit(&ifn, threadStackSize, argc, argv, mode, what, ret);
 }
 /*
  * Always detach the main thread so that it appears to have ended when
  * the application's main method exits.  This will invoke the
@@ -652,12 +655,11 @@
 }
 
 /*
  * Test if an arg identifies a source file.
  */
-jboolean
-IsSourceFile(const char *arg) {
+static jboolean IsSourceFile(const char *arg) {
     struct stat st;
     return (JLI_HasSuffix(arg, ".java") && stat(arg, &st) == 0);
 }
 
 /*
@@ -943,20 +945,22 @@
         }
     }
     options[numOptions].optionString = str;
     options[numOptions++].extraInfo = info;
 
+    /*
+     * -Xss is used both by the JVM and here to establish the stack size of the thread
+     * created to launch the JVM. In the latter case we need to ensure we don't go
+     * below the minimum stack size allowed. If -Xss is zero that tells the JVM to use
+     * 'default' sizes (either from JVM or system configuration, e.g. 'ulimit -s' on linux),
+     * and is not itself a small stack size that will be rejected. So we ignore -Xss0 here.
+     */
     if (JLI_StrCCmp(str, "-Xss") == 0) {
         jlong tmp;
         if (parse_size(str + 4, &tmp)) {
             threadStackSize = tmp;
-            /*
-             * Make sure the thread stack size is big enough that we won't get a stack
-             * overflow before the JVM startup code can check to make sure the stack
-             * is big enough.
-             */
-            if (threadStackSize < (jlong)STACK_SIZE_MINIMUM) {
+            if (threadStackSize > 0 && threadStackSize < (jlong)STACK_SIZE_MINIMUM) {
                 threadStackSize = STACK_SIZE_MINIMUM;
             }
         }
     }
 
@@ -1173,17 +1177,17 @@
 
     /*
      * Passing on splash screen info in environment variables
      */
     if (splash_file_name && !headlessflag) {
-        char* splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY "=")+JLI_StrLen(splash_file_name)+1);
+        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY "=")+JLI_StrLen(splash_file_name)+1);
         JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY "=");
         JLI_StrCat(splash_file_entry, splash_file_name);
         putenv(splash_file_entry);
     }
     if (splash_jar_name && !headlessflag) {
-        char* splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY "=")+JLI_StrLen(splash_jar_name)+1);
+        splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY "=")+JLI_StrLen(splash_jar_name)+1);
         JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY "=");
         JLI_StrCat(splash_jar_entry, splash_jar_name);
         putenv(splash_jar_entry);
     }
 
@@ -1434,16 +1438,21 @@
         } else if (JLI_StrCmp(arg, "-debug") == 0) {
             AddOption("-Xdebug", NULL);
         } else if (JLI_StrCmp(arg, "-noclassgc") == 0) {
             AddOption("-Xnoclassgc", NULL);
         } else if (JLI_StrCmp(arg, "-Xfuture") == 0) {
+            JLI_ReportErrorMessage(ARG_DEPRECATED, "-Xfuture");
             AddOption("-Xverify:all", NULL);
         } else if (JLI_StrCmp(arg, "-verify") == 0) {
             AddOption("-Xverify:all", NULL);
         } else if (JLI_StrCmp(arg, "-verifyremote") == 0) {
             AddOption("-Xverify:remote", NULL);
         } else if (JLI_StrCmp(arg, "-noverify") == 0) {
+            /*
+             * Note that no 'deprecated' message is needed here because the VM
+             * issues 'deprecated' messages for -noverify and -Xverify:none.
+             */
             AddOption("-Xverify:none", NULL);
         } else if (JLI_StrCCmp(arg, "-ss") == 0 ||
                    JLI_StrCCmp(arg, "-oss") == 0 ||
                    JLI_StrCCmp(arg, "-ms") == 0 ||
                    JLI_StrCCmp(arg, "-mx") == 0) {
@@ -1873,12 +1882,11 @@
 
 /*
  * JVM would like to know if it's created by a standard Sun launcher, or by
  * user native application, the following property indicates the former.
  */
-void
-SetJavaLauncherProp() {
+static void SetJavaLauncherProp() {
   AddOption("-Dsun.java.launcher=SUN_STANDARD", NULL);
 }
 
 /*
  * Prints the version information from the java.version and other properties.
@@ -2245,10 +2253,15 @@
     jboolean isImageScaled = JNI_FALSE;
     size_t maxScaledImgNameLength = 0;
     if (file_name == NULL){
         return;
     }
+
+    if (!DoSplashInit()) {
+        goto exit;
+    }
+
     maxScaledImgNameLength = DoSplashGetScaledImgNameMaxPstfixLen(file_name);
 
     scaled_splash_name = JLI_MemAlloc(
                             maxScaledImgNameLength * sizeof(char));
     isImageScaled = DoSplashGetScaledImageName(jar_name, file_name,
@@ -2265,17 +2278,17 @@
             scale_factor = 1;
             image_data = JLI_JarUnpackFile(
                             jar_name, file_name, &data_size);
         }
         if (image_data) {
-            DoSplashInit();
             DoSplashSetScaleFactor(scale_factor);
             DoSplashLoadMemory(image_data, data_size);
             JLI_MemFree(image_data);
+        } else {
+            DoSplashClose();
         }
     } else {
-        DoSplashInit();
         if (isImageScaled) {
             DoSplashSetScaleFactor(scale_factor);
             DoSplashLoadFile(scaled_splash_name);
         } else {
             DoSplashLoadFile(file_name);
@@ -2283,10 +2296,11 @@
     }
     JLI_MemFree(scaled_splash_name);
 
     DoSplashSetFileJarName(file_name, jar_name);
 
+    exit:
     /*
      * Done with all command line processing and potential re-execs so
      * clean up the environment.
      */
     (void)UnsetEnv(ENV_ENTRY);
@@ -2296,30 +2310,26 @@
     JLI_MemFree(splash_jar_entry);
     JLI_MemFree(splash_file_entry);
 
 }
 
-const char*
-GetFullVersion()
+static const char* GetFullVersion()
 {
     return _fVersion;
 }
 
-const char*
-GetProgramName()
+static const char* GetProgramName()
 {
     return _program_name;
 }
 
-const char*
-GetLauncherName()
+static const char* GetLauncherName()
 {
     return _launcher_name;
 }
 
-jboolean
-IsJavaArgs()
+static jboolean IsJavaArgs()
 {
     return _is_java_args;
 }
 
 static jboolean
@@ -2331,42 +2341,42 @@
 int
 ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
                     int argc, char **argv,
                     int mode, char *what, int ret)
 {
-
-    /*
-     * If user doesn't specify stack size, check if VM has a preference.
-     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
-     * return its default stack size through the init args structure.
-     */
     if (threadStackSize == 0) {
-      struct JDK1_1InitArgs args1_1;
-      memset((void*)&args1_1, 0, sizeof(args1_1));
-      args1_1.version = JNI_VERSION_1_1;
-      ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
-      if (args1_1.javaStackSize > 0) {
-         threadStackSize = args1_1.javaStackSize;
-      }
+        /*
+         * If the user hasn't specified a non-zero stack size ask the JVM for its default.
+         * A returned 0 means 'use the system default' for a platform, e.g., Windows.
+         * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+         * return its default stack size through the init args structure.
+         */
+        struct JDK1_1InitArgs args1_1;
+        memset((void*)&args1_1, 0, sizeof(args1_1));
+        args1_1.version = JNI_VERSION_1_1;
+        ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+        if (args1_1.javaStackSize > 0) {
+            threadStackSize = args1_1.javaStackSize;
+        }
     }
 
     { /* Create a new thread to create JVM and invoke main method */
-      JavaMainArgs args;
-      int rslt;
-
-      args.argc = argc;
-      args.argv = argv;
-      args.mode = mode;
-      args.what = what;
-      args.ifn = *ifn;
-
-      rslt = CallJavaMainInNewThread(threadStackSize, (void*)&args);
-      /* If the caller has deemed there is an error we
-       * simply return that, otherwise we return the value of
-       * the callee
-       */
-      return (ret != 0) ? ret : rslt;
+        JavaMainArgs args;
+        int rslt;
+
+        args.argc = argc;
+        args.argv = argv;
+        args.mode = mode;
+        args.what = what;
+        args.ifn = *ifn;
+
+        rslt = CallJavaMainInNewThread(threadStackSize, (void*)&args);
+        /* If the caller has deemed there is an error we
+         * simply return that, otherwise we return the value of
+         * the callee
+         */
+        return (ret != 0) ? ret : rslt;
     }
 }
 
 static void
 DumpState()

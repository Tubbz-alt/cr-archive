<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/native/libjava/jni_util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;stdlib.h&gt;
  27 #include &lt;string.h&gt;
  28 
  29 #include &quot;jvm.h&quot;
  30 #include &quot;jni.h&quot;
  31 #include &quot;jni_util.h&quot;
  32 #include &quot;java_lang_String.h&quot;
  33 
  34 /* Due to a bug in the win32 C runtime library strings
  35  * such as &quot;z:&quot; need to be appended with a &quot;.&quot; so we
  36  * must allocate at least 4 bytes to allow room for
  37  * this expansion. See 4235353 for details.
  38  */
  39 #define MALLOC_MIN4(len) ((char *)malloc((len) + 1 &lt; 4 ? 4 : (len) + 1))
  40 
  41 /**
  42  * Throw a Java exception by name. Similar to SignalError.
  43  */
  44 JNIEXPORT void JNICALL
  45 JNU_ThrowByName(JNIEnv *env, const char *name, const char *msg)
  46 {
  47     jclass cls = (*env)-&gt;FindClass(env, name);
  48 
  49     if (cls != 0) /* Otherwise an exception has already been thrown */
  50         (*env)-&gt;ThrowNew(env, cls, msg);
  51 }
  52 
  53 /* JNU_Throw common exceptions */
  54 
  55 JNIEXPORT void JNICALL
  56 JNU_ThrowNullPointerException(JNIEnv *env, const char *msg)
  57 {
  58     JNU_ThrowByName(env, &quot;java/lang/NullPointerException&quot;, msg);
  59 }
  60 
  61 JNIEXPORT void JNICALL
  62 JNU_ThrowArrayIndexOutOfBoundsException(JNIEnv *env, const char *msg)
  63 {
  64     JNU_ThrowByName(env, &quot;java/lang/ArrayIndexOutOfBoundsException&quot;, msg);
  65 }
  66 
  67 JNIEXPORT void JNICALL
  68 JNU_ThrowOutOfMemoryError(JNIEnv *env, const char *msg)
  69 {
  70     JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;, msg);
  71 }
  72 
  73 JNIEXPORT void JNICALL
  74 JNU_ThrowIllegalArgumentException(JNIEnv *env, const char *msg)
  75 {
  76     JNU_ThrowByName(env, &quot;java/lang/IllegalArgumentException&quot;, msg);
  77 }
  78 
  79 JNIEXPORT void JNICALL
  80 JNU_ThrowIllegalAccessError(JNIEnv *env, const char *msg)
  81 {
  82     JNU_ThrowByName(env, &quot;java/lang/IllegalAccessError&quot;, msg);
  83 }
  84 
  85 JNIEXPORT void JNICALL
  86 JNU_ThrowIllegalAccessException(JNIEnv *env, const char *msg)
  87 {
  88     JNU_ThrowByName(env, &quot;java/lang/IllegalAccessException&quot;, msg);
  89 }
  90 
  91 JNIEXPORT void JNICALL
  92 JNU_ThrowInternalError(JNIEnv *env, const char *msg)
  93 {
  94     JNU_ThrowByName(env, &quot;java/lang/InternalError&quot;, msg);
  95 }
  96 
  97 JNIEXPORT void JNICALL
  98 JNU_ThrowNoSuchFieldException(JNIEnv *env, const char *msg)
  99 {
 100     JNU_ThrowByName(env, &quot;java/lang/NoSuchFieldException&quot;, msg);
 101 }
 102 
 103 JNIEXPORT void JNICALL
 104 JNU_ThrowNoSuchMethodException(JNIEnv *env, const char *msg)
 105 {
 106     JNU_ThrowByName(env, &quot;java/lang/NoSuchMethodException&quot;, msg);
 107 }
 108 
 109 JNIEXPORT void JNICALL
 110 JNU_ThrowClassNotFoundException(JNIEnv *env, const char *msg)
 111 {
 112     JNU_ThrowByName(env, &quot;java/lang/ClassNotFoundException&quot;, msg);
 113 }
 114 
 115 JNIEXPORT void JNICALL
 116 JNU_ThrowNumberFormatException(JNIEnv *env, const char *msg)
 117 {
 118     JNU_ThrowByName(env, &quot;java/lang/NumberFormatException&quot;, msg);
 119 }
 120 
 121 JNIEXPORT void JNICALL
 122 JNU_ThrowIOException(JNIEnv *env, const char *msg)
 123 {
 124     JNU_ThrowByName(env, &quot;java/io/IOException&quot;, msg);
 125 }
 126 
 127 JNIEXPORT void JNICALL
 128 JNU_ThrowNoSuchFieldError(JNIEnv *env, const char *msg)
 129 {
 130     JNU_ThrowByName(env, &quot;java/lang/NoSuchFieldError&quot;, msg);
 131 }
 132 
 133 JNIEXPORT void JNICALL
 134 JNU_ThrowNoSuchMethodError(JNIEnv *env, const char *msg)
 135 {
 136     JNU_ThrowByName(env, &quot;java/lang/NoSuchMethodError&quot;, msg);
 137 }
 138 
 139 JNIEXPORT void JNICALL
 140 JNU_ThrowStringIndexOutOfBoundsException(JNIEnv *env, const char *msg)
 141 {
 142     JNU_ThrowByName(env, &quot;java/lang/StringIndexOutOfBoundsException&quot;, msg);
 143 }
 144 
 145 JNIEXPORT void JNICALL
 146 JNU_ThrowInstantiationException(JNIEnv *env, const char *msg)
 147 {
 148     JNU_ThrowByName(env, &quot;java/lang/InstantiationException&quot;, msg);
 149 }
 150 
 151 /*
 152  * Throw an exception by name, using the string returned by
 153  * getLastErrorString for the detail string. If the last-error
 154  * string is NULL, use the given default detail string.
 155  */
 156 JNIEXPORT void JNICALL
 157 JNU_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 158                              const char *defaultDetail)
 159 {
 160     char buf[256];
 161     size_t n = getLastErrorString(buf, sizeof(buf));
 162 
 163     if (n &gt; 0) {
 164         jstring s = JNU_NewStringPlatform(env, buf);
 165         if (s != NULL) {
 166             jobject x = JNU_NewObjectByName(env, name,
 167                                             &quot;(Ljava/lang/String;)V&quot;, s);
 168             if (x != NULL) {
 169                 (*env)-&gt;Throw(env, x);
 170             }
 171         }
 172     }
 173     if (!(*env)-&gt;ExceptionOccurred(env)) {
 174         JNU_ThrowByName(env, name, defaultDetail);
 175     }
 176 }
 177 
 178 /*
 179  * Throw an exception by name, using a given message and the string
 180  * returned by getLastErrorString to construct the detail string.
 181  */
 182 JNIEXPORT void JNICALL
 183 JNU_ThrowByNameWithMessageAndLastError
 184   (JNIEnv *env, const char *name, const char *message)
 185 {
 186     char buf[256];
 187     size_t n = getLastErrorString(buf, sizeof(buf));
 188     size_t messagelen = message == NULL ? 0 : strlen(message);
 189 
 190     if (n &gt; 0) {
 191         jstring s = JNU_NewStringPlatform(env, buf);
 192         if (s != NULL) {
 193             jobject x = NULL;
 194             if (messagelen) {
 195                 jstring s2 = NULL;
 196                 size_t messageextlen = messagelen + 4;
 197                 char *str1 = (char *)malloc((messageextlen) * sizeof(char));
 198                 if (str1 == 0) {
 199                     JNU_ThrowOutOfMemoryError(env, 0);
 200                     return;
 201                 }
 202                 jio_snprintf(str1, messageextlen, &quot; (%s)&quot;, message);
 203                 s2 = (*env)-&gt;NewStringUTF(env, str1);
 204                 free(str1);
 205                 JNU_CHECK_EXCEPTION(env);
 206                 if (s2 != NULL) {
 207                     jstring s3 = JNU_CallMethodByName(
 208                                      env, NULL, s, &quot;concat&quot;,
 209                                      &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
 210                                      s2).l;
 211                     (*env)-&gt;DeleteLocalRef(env, s2);
 212                     JNU_CHECK_EXCEPTION(env);
 213                     if (s3 != NULL) {
 214                         (*env)-&gt;DeleteLocalRef(env, s);
 215                         s = s3;
 216                     }
 217                 }
 218             }
 219             x = JNU_NewObjectByName(env, name, &quot;(Ljava/lang/String;)V&quot;, s);
 220             if (x != NULL) {
 221                 (*env)-&gt;Throw(env, x);
 222             }
 223         }
 224     }
 225 
 226     if (!(*env)-&gt;ExceptionOccurred(env)) {
 227         if (messagelen) {
 228             JNU_ThrowByName(env, name, message);
 229         } else {
 230             JNU_ThrowByName(env, name, &quot;no further information&quot;);
 231         }
 232     }
 233 }
 234 
 235 /*
 236  * Convenience method.
 237  * Call JNU_ThrowByNameWithLastError for java.io.IOException.
 238  */
 239 JNIEXPORT void JNICALL
 240 JNU_ThrowIOExceptionWithLastError(JNIEnv *env, const char *defaultDetail)
 241 {
 242     JNU_ThrowByNameWithLastError(env, &quot;java/io/IOException&quot;, defaultDetail);
 243 }
 244 
 245 
 246 JNIEXPORT jvalue JNICALL
 247 JNU_CallStaticMethodByName(JNIEnv *env,
 248                            jboolean *hasException,
 249                            const char *class_name,
 250                            const char *name,
 251                            const char *signature,
 252                            ...)
 253 {
 254     jclass clazz;
 255     jmethodID mid;
 256     va_list args;
 257     jvalue result;
 258     const char *p = signature;
 259 
 260     /* find out the return type */
 261     while (*p &amp;&amp; *p != &#39;)&#39;)
 262         p++;
 263     p++;
 264 
 265     result.i = 0;
 266 
 267     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
 268         goto done2;
 269 
 270     clazz = (*env)-&gt;FindClass(env, class_name);
 271     if (clazz == 0)
 272         goto done2;
 273     mid = (*env)-&gt;GetStaticMethodID(env, clazz, name, signature);
 274     if (mid == 0)
 275         goto done1;
 276     va_start(args, signature);
 277     switch (*p) {
 278     case &#39;V&#39;:
 279         (*env)-&gt;CallStaticVoidMethodV(env, clazz, mid, args);
 280         break;
 281     case &#39;[&#39;:
 282     case &#39;L&#39;:
 283         result.l = (*env)-&gt;CallStaticObjectMethodV(env, clazz, mid, args);
 284         break;
 285     case &#39;Z&#39;:
 286         result.z = (*env)-&gt;CallStaticBooleanMethodV(env, clazz, mid, args);
 287         break;
 288     case &#39;B&#39;:
 289         result.b = (*env)-&gt;CallStaticByteMethodV(env, clazz, mid, args);
 290         break;
 291     case &#39;C&#39;:
 292         result.c = (*env)-&gt;CallStaticCharMethodV(env, clazz, mid, args);
 293         break;
 294     case &#39;S&#39;:
 295         result.s = (*env)-&gt;CallStaticShortMethodV(env, clazz, mid, args);
 296         break;
 297     case &#39;I&#39;:
 298         result.i = (*env)-&gt;CallStaticIntMethodV(env, clazz, mid, args);
 299         break;
 300     case &#39;J&#39;:
 301         result.j = (*env)-&gt;CallStaticLongMethodV(env, clazz, mid, args);
 302         break;
 303     case &#39;F&#39;:
 304         result.f = (*env)-&gt;CallStaticFloatMethodV(env, clazz, mid, args);
 305         break;
 306     case &#39;D&#39;:
 307         result.d = (*env)-&gt;CallStaticDoubleMethodV(env, clazz, mid, args);
 308         break;
 309     default:
 310         (*env)-&gt;FatalError(env, &quot;JNU_CallStaticMethodByName: illegal signature&quot;);
 311     }
 312     va_end(args);
 313 
 314  done1:
 315     (*env)-&gt;DeleteLocalRef(env, clazz);
 316  done2:
 317     if (hasException) {
 318         *hasException = (*env)-&gt;ExceptionCheck(env);
 319     }
 320     return result;
 321 }
 322 
 323 JNIEXPORT jvalue JNICALL
 324 JNU_CallMethodByName(JNIEnv *env,
 325                      jboolean *hasException,
 326                      jobject obj,
 327                      const char *name,
 328                      const char *signature,
 329                      ...)
 330 {
 331     jvalue result;
 332     va_list args;
 333 
 334     va_start(args, signature);
 335     result = JNU_CallMethodByNameV(env, hasException, obj, name, signature,
 336                                    args);
 337     va_end(args);
 338 
 339     return result;
 340 }
 341 
 342 
 343 JNIEXPORT jvalue JNICALL
 344 JNU_CallMethodByNameV(JNIEnv *env,
 345                       jboolean *hasException,
 346                       jobject obj,
 347                       const char *name,
 348                       const char *signature,
 349                       va_list args)
 350 {
 351     jclass clazz;
 352     jmethodID mid;
 353     jvalue result;
 354     const char *p = signature;
 355 
 356     /* find out the return type */
 357     while (*p &amp;&amp; *p != &#39;)&#39;)
 358         p++;
 359     p++;
 360 
 361     result.i = 0;
 362 
 363     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
 364         goto done2;
 365 
 366     clazz = (*env)-&gt;GetObjectClass(env, obj);
 367     mid = (*env)-&gt;GetMethodID(env, clazz, name, signature);
 368     if (mid == 0)
 369         goto done1;
 370 
 371     switch (*p) {
 372     case &#39;V&#39;:
 373         (*env)-&gt;CallVoidMethodV(env, obj, mid, args);
 374         break;
 375     case &#39;[&#39;:
 376     case &#39;L&#39;:
 377         result.l = (*env)-&gt;CallObjectMethodV(env, obj, mid, args);
 378         break;
 379     case &#39;Z&#39;:
 380         result.z = (*env)-&gt;CallBooleanMethodV(env, obj, mid, args);
 381         break;
 382     case &#39;B&#39;:
 383         result.b = (*env)-&gt;CallByteMethodV(env, obj, mid, args);
 384         break;
 385     case &#39;C&#39;:
 386         result.c = (*env)-&gt;CallCharMethodV(env, obj, mid, args);
 387         break;
 388     case &#39;S&#39;:
 389         result.s = (*env)-&gt;CallShortMethodV(env, obj, mid, args);
 390         break;
 391     case &#39;I&#39;:
 392         result.i = (*env)-&gt;CallIntMethodV(env, obj, mid, args);
 393         break;
 394     case &#39;J&#39;:
 395         result.j = (*env)-&gt;CallLongMethodV(env, obj, mid, args);
 396         break;
 397     case &#39;F&#39;:
 398         result.f = (*env)-&gt;CallFloatMethodV(env, obj, mid, args);
 399         break;
 400     case &#39;D&#39;:
 401         result.d = (*env)-&gt;CallDoubleMethodV(env, obj, mid, args);
 402         break;
 403     default:
 404         (*env)-&gt;FatalError(env, &quot;JNU_CallMethodByNameV: illegal signature&quot;);
 405     }
 406  done1:
 407     (*env)-&gt;DeleteLocalRef(env, clazz);
 408  done2:
 409     if (hasException) {
 410         *hasException = (*env)-&gt;ExceptionCheck(env);
 411     }
 412     return result;
 413 }
 414 
 415 JNIEXPORT jobject JNICALL
 416 JNU_NewObjectByName(JNIEnv *env, const char *class_name,
 417                     const char *constructor_sig, ...)
 418 {
 419     jobject obj = NULL;
 420 
 421     jclass cls = 0;
 422     jmethodID cls_initMID;
 423     va_list args;
 424 
 425     if ((*env)-&gt;EnsureLocalCapacity(env, 2) &lt; 0)
 426         goto done;
 427 
 428     cls = (*env)-&gt;FindClass(env, class_name);
 429     if (cls == 0) {
 430         goto done;
 431     }
 432     cls_initMID  = (*env)-&gt;GetMethodID(env, cls,
 433                                        &quot;&lt;init&gt;&quot;, constructor_sig);
 434     if (cls_initMID == NULL) {
 435         goto done;
 436     }
 437     va_start(args, constructor_sig);
 438     obj = (*env)-&gt;NewObjectV(env, cls, cls_initMID, args);
 439     va_end(args);
 440 
 441  done:
 442     (*env)-&gt;DeleteLocalRef(env, cls);
 443     return obj;
 444 }
 445 
 446 /* Optimized for charset ISO_8559_1 */
 447 static jstring
 448 newSizedString8859_1(JNIEnv *env, const char *str, const int len)
 449 {
 450     jchar buf[512];
 451     jchar *str1;
 452     jstring result;
 453     int i;
 454 
 455     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
 456         return NULL;
 457 
 458     if (len &gt; 512) {
 459         str1 = (jchar *)malloc(len * sizeof(jchar));
 460         if (str1 == 0) {
 461             JNU_ThrowOutOfMemoryError(env, 0);
 462             return 0;
 463         }
 464     } else
 465         str1 = buf;
 466 
 467     for (i=0;i&lt;len;i++)
 468         str1[i] = (unsigned char)str[i];
 469     result = (*env)-&gt;NewString(env, str1, len);
 470     if (str1 != buf)
 471         free(str1);
 472     return result;
 473 }
 474 
 475 static jstring
 476 newString8859_1(JNIEnv *env, const char *str)
 477 {
 478     int len = (int)strlen(str);
 479     return newSizedString8859_1(env, str, len);
 480 }
 481 
 482 static const char*
 483 getString8859_1Chars(JNIEnv *env, jstring jstr)
 484 {
 485     int i;
 486     char *result;
 487     jint len = (*env)-&gt;GetStringLength(env, jstr);
 488     const jchar *str = (*env)-&gt;GetStringCritical(env, jstr, 0);
 489     if (str == 0) {
 490         return 0;
 491     }
 492 
 493     result = MALLOC_MIN4(len);
 494     if (result == 0) {
 495         (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 496         JNU_ThrowOutOfMemoryError(env, 0);
 497         return 0;
 498     }
 499 
 500     for (i=0; i&lt;len; i++) {
 501         jchar unicode = str[i];
 502         if (unicode &lt;= 0x00ff)
 503             result[i] = (char)unicode;
 504         else
 505             result[i] = &#39;?&#39;;
 506     }
 507 
 508     result[len] = 0;
 509     (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 510     return result;
 511 }
 512 
 513 
 514 /* Optimized for charset ISO646-US (us-ascii) */
 515 static jstring
 516 newString646_US(JNIEnv *env, const char *str)
 517 {
 518     int len = (int)strlen(str);
 519     jchar buf[512];
 520     jchar *str1;
 521     jstring result;
 522     int i;
 523 
 524     if (len &gt; 512) {
 525         str1 = (jchar *)malloc(len * sizeof(jchar));
 526         if (str1 == 0) {
 527             JNU_ThrowOutOfMemoryError(env, 0);
 528             return 0;
 529         }
 530     } else
 531         str1 = buf;
 532 
 533     for (i=0; i&lt;len; i++) {
 534         unsigned char c = (unsigned char)str[i];
 535         if (c &lt;= 0x7f)
 536             str1[i] = c;
 537         else
 538             str1[i] = &#39;?&#39;;
 539     }
 540 
 541     result = (*env)-&gt;NewString(env, str1, len);
 542     if (str1 != buf)
 543         free(str1);
 544     return result;
 545 }
 546 
 547 static const char*
 548 getString646_USChars(JNIEnv *env, jstring jstr)
 549 {
 550     int i;
 551     char *result;
 552     jint len = (*env)-&gt;GetStringLength(env, jstr);
 553     const jchar *str = (*env)-&gt;GetStringCritical(env, jstr, 0);
 554     if (str == 0) {
 555         return 0;
 556     }
 557 
 558     result = MALLOC_MIN4(len);
 559     if (result == 0) {
 560         (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 561         JNU_ThrowOutOfMemoryError(env, 0);
 562         return 0;
 563     }
 564 
 565     for (i=0; i&lt;len; i++) {
 566         jchar unicode = str[i];
 567         if (unicode &lt;= 0x007f )
 568             result[i] = (char)unicode;
 569         else
 570             result[i] = &#39;?&#39;;
 571     }
 572 
 573     result[len] = 0;
 574     (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 575     return result;
 576 }
 577 
 578 /* enumeration of c1 row from Cp1252 */
 579 static int cp1252c1chars[32] = {
 580     0x20AC,0xFFFD,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,
 581     0x02C6,0x2030,0x0160,0x2039,0x0152,0xFFFD,0x017D,0xFFFD,
 582     0xFFFD,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,
 583     0x02Dc,0x2122,0x0161,0x203A,0x0153,0xFFFD,0x017E,0x0178
 584 };
 585 
 586 /* Optimized for charset Cp1252 */
 587 static jstring
 588 newStringCp1252(JNIEnv *env, const char *str)
 589 {
 590     int len = (int) strlen(str);
 591     jchar buf[512];
 592     jchar *str1;
 593     jstring result;
 594     int i;
 595 
 596     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
 597         return NULL;
 598 
 599     if (len &gt; 512) {
 600         str1 = (jchar *)malloc(len * sizeof(jchar));
 601         if (str1 == 0) {
 602             JNU_ThrowOutOfMemoryError(env, 0);
 603             return 0;
 604         }
 605     } else
 606         str1 = buf;
 607 
 608     for (i=0; i&lt;len; i++) {
 609         unsigned char c = (unsigned char)str[i];
 610         if ((c &gt;= 0x80) &amp;&amp; (c &lt;= 0x9f))
 611             str1[i] = cp1252c1chars[c-128];
 612         else
 613             str1[i] = c;
 614     }
 615 
 616     result = (*env)-&gt;NewString(env, str1, len);
 617     if (str1 != buf)
 618         free(str1);
 619     return result;
 620 }
 621 
 622 static const char*
 623 getStringCp1252Chars(JNIEnv *env, jstring jstr)
 624 {
 625     int i;
 626     char *result;
 627     jint len = (*env)-&gt;GetStringLength(env, jstr);
 628     const jchar *str = (*env)-&gt;GetStringCritical(env, jstr, 0);
 629     if (str == 0) {
 630         return 0;
 631     }
 632 
 633     result = MALLOC_MIN4(len);
 634     if (result == 0) {
 635         (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 636         JNU_ThrowOutOfMemoryError(env, 0);
 637         return 0;
 638     }
 639 
 640     for (i=0; i&lt;len; i++) {
 641         jchar c = str[i];
 642         if (c &lt; 256) {
 643             if ((c &gt;= 0x80) &amp;&amp; (c &lt;= 0x9f)) {
 644                 result[i] = &#39;?&#39;;
 645             } else {
 646                 result[i] = (char)c;
 647             }
 648         } else switch(c) {
 649             case 0x20AC: result[i] = (char)0x80; break;
 650             case 0x201A: result[i] = (char)0x82; break;
 651             case 0x0192: result[i] = (char)0x83; break;
 652             case 0x201E: result[i] = (char)0x84; break;
 653             case 0x2026: result[i] = (char)0x85; break;
 654             case 0x2020: result[i] = (char)0x86; break;
 655             case 0x2021: result[i] = (char)0x87; break;
 656             case 0x02C6: result[i] = (char)0x88; break;
 657             case 0x2030: result[i] = (char)0x89; break;
 658             case 0x0160: result[i] = (char)0x8A; break;
 659             case 0x2039: result[i] = (char)0x8B; break;
 660             case 0x0152: result[i] = (char)0x8C; break;
 661             case 0x017D: result[i] = (char)0x8E; break;
 662             case 0x2018: result[i] = (char)0x91; break;
 663             case 0x2019: result[i] = (char)0x92; break;
 664             case 0x201C: result[i] = (char)0x93; break;
 665             case 0x201D: result[i] = (char)0x94; break;
 666             case 0x2022: result[i] = (char)0x95; break;
 667             case 0x2013: result[i] = (char)0x96; break;
 668             case 0x2014: result[i] = (char)0x97; break;
 669             case 0x02DC: result[i] = (char)0x98; break;
 670             case 0x2122: result[i] = (char)0x99; break;
 671             case 0x0161: result[i] = (char)0x9A; break;
 672             case 0x203A: result[i] = (char)0x9B; break;
 673             case 0x0153: result[i] = (char)0x9C; break;
 674             case 0x017E: result[i] = (char)0x9E; break;
 675             case 0x0178: result[i] = (char)0x9F; break;
 676             default:     result[i] = &#39;?&#39;;  break;
 677         }
 678     }
 679 
 680     result[len] = 0;
 681     (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 682     return result;
 683 }
 684 
 685 static int fastEncoding = NO_ENCODING_YET;
 686 static jstring jnuEncoding = NULL;
 687 
 688 /* Cached method IDs */
 689 static jmethodID String_init_ID;        /* String(byte[], enc) */
 690 static jmethodID String_getBytes_ID;    /* String.getBytes(enc) */
 691 
 692 /* Cached field IDs */
 693 static jfieldID String_coder_ID;        /* String.coder */
 694 static jfieldID String_value_ID;        /* String.value */
 695 
 696 static jboolean isJNUEncodingSupported = JNI_FALSE;
 697 static jboolean jnuEncodingSupported(JNIEnv *env) {
 698     jboolean exe;
 699     if (isJNUEncodingSupported == JNI_TRUE) {
 700         return JNI_TRUE;
 701     }
 702     isJNUEncodingSupported = (jboolean) JNU_CallStaticMethodByName (
 703                                     env, &amp;exe,
 704                                     &quot;java/nio/charset/Charset&quot;,
 705                                     &quot;isSupported&quot;,
 706                                     &quot;(Ljava/lang/String;)Z&quot;,
 707                                     jnuEncoding).z;
 708     return isJNUEncodingSupported;
 709 }
 710 
 711 /* Create a new string by converting str to a heap-allocated byte array and
 712  * calling the appropriate String constructor.
 713  */
 714 static jstring
 715 newSizedStringJava(JNIEnv *env, const char *str, const int len)
 716 {
 717     jstring result = NULL;
 718     jbyteArray bytes = 0;
 719 
 720     if ((*env)-&gt;EnsureLocalCapacity(env, 2) &lt; 0)
 721         return NULL;
 722 
 723     bytes = (*env)-&gt;NewByteArray(env, len);
 724     if (bytes != NULL) {
 725         jclass strClazz = JNU_ClassString(env);
 726         CHECK_NULL_RETURN(strClazz, 0);
 727         (*env)-&gt;SetByteArrayRegion(env, bytes, 0, len, (jbyte *)str);
 728         if (jnuEncodingSupported(env)) {
 729             result = (*env)-&gt;NewObject(env, strClazz,
 730                                        String_init_ID, bytes, jnuEncoding);
 731         } else {
 732             /*If the encoding specified in sun.jnu.encoding is not endorsed
 733               by &quot;Charset.isSupported&quot; we have to fall back to use String(byte[])
 734               explicitly here without specifying the encoding name, in which the
 735               StringCoding class will pickup the iso-8859-1 as the fallback
 736               converter for us.
 737              */
 738             jmethodID mid = (*env)-&gt;GetMethodID(env, strClazz,
 739                                                 &quot;&lt;init&gt;&quot;, &quot;([B)V&quot;);
 740             if (mid != NULL) {
 741                 result = (*env)-&gt;NewObject(env, strClazz, mid, bytes);
 742             }
 743         }
 744         (*env)-&gt;DeleteLocalRef(env, bytes);
 745         return result;
 746     }
 747     return NULL;
 748 }
 749 
 750 static jstring
 751 newStringJava(JNIEnv *env, const char *str)
 752 {
 753     int len = (int)strlen(str);
 754     return newSizedStringJava(env, str, len);
 755 }
 756 
 757 /* Optimized for charset UTF-8 */
 758 static jstring
 759 newStringUTF8(JNIEnv *env, const char *str)
 760 {
 761     int len;
 762     const unsigned char *p;
 763     unsigned char asciiCheck;
 764     for (asciiCheck = 0, p = (const unsigned char*)str; *p != &#39;\0&#39;; p++) {
 765         asciiCheck |= *p;
 766     }
 767     len = (int)((const char*)p - str);
 768 
 769     if (asciiCheck &lt; 0x80) {
 770         // ascii fast-path
 771         return newSizedString8859_1(env, str, len);
 772     }
 773 
 774     return newSizedStringJava(env, str, len);
 775 }
 776 
 777 /* Initialize the fast encoding from the encoding name.
 778  * Export InitializeEncoding so that the VM can initialize it if required.
 779  */
 780 JNIEXPORT void
 781 InitializeEncoding(JNIEnv *env, const char *encname)
 782 {
 783     jclass strClazz = NULL;
 784 
 785     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
 786         return;
 787 
 788     strClazz = JNU_ClassString(env);
 789     CHECK_NULL(strClazz);
 790 
 791     if (encname) {
 792         /*
 793          * On Solaris with nl_langinfo() called in GetJavaProperties():
 794          *
 795          *   locale undefined -&gt; NULL -&gt; hardcoded default
 796          *   &quot;C&quot; locale       -&gt; &quot;&quot; -&gt; hardcoded default     (on 2.6)
 797          *   &quot;C&quot; locale       -&gt; &quot;ISO646-US&quot;                 (on Sol 7/8)
 798          *   &quot;en_US&quot; locale -&gt; &quot;ISO8859-1&quot;
 799          *   &quot;en_GB&quot; locale -&gt; &quot;ISO8859-1&quot;                   (on Sol 7/8)
 800          *   &quot;en_UK&quot; locale -&gt; &quot;ISO8859-1&quot;                   (on 2.6)
 801          */
 802         if ((strcmp(encname, &quot;8859_1&quot;) == 0) ||
 803             (strcmp(encname, &quot;ISO8859-1&quot;) == 0) ||
 804             (strcmp(encname, &quot;ISO8859_1&quot;) == 0) ||
 805             (strcmp(encname, &quot;ISO-8859-1&quot;) == 0)) {
 806             fastEncoding = FAST_8859_1;
 807         } else if (strcmp(encname, &quot;UTF-8&quot;) == 0) {
 808             jstring enc = (*env)-&gt;NewStringUTF(env, encname);
 809             if (enc == NULL)
 810                 return;
 811             fastEncoding = FAST_UTF_8;
 812             jnuEncoding = (jstring)(*env)-&gt;NewGlobalRef(env, enc);
 813             (*env)-&gt;DeleteLocalRef(env, enc);
 814         } else if (strcmp(encname, &quot;ISO646-US&quot;) == 0) {
 815             fastEncoding = FAST_646_US;
 816         } else if (strcmp(encname, &quot;Cp1252&quot;) == 0 ||
 817             /* This is a temporary fix until we move */
 818             /* to wide character versions of all Windows */
 819             /* calls. */
 820             strcmp(encname, &quot;utf-16le&quot;) == 0) {
 821             fastEncoding = FAST_CP1252;
 822         } else {
 823             jstring enc = (*env)-&gt;NewStringUTF(env, encname);
 824             if (enc == NULL)
 825                 return;
 826             fastEncoding = NO_FAST_ENCODING;
 827             jnuEncoding = (jstring)(*env)-&gt;NewGlobalRef(env, enc);
 828             (*env)-&gt;DeleteLocalRef(env, enc);
 829         }
 830     } else {
 831         JNU_ThrowInternalError(env, &quot;platform encoding undefined&quot;);
 832         return;
 833     }
 834 
 835     /* Initialize method-id cache */
 836     String_getBytes_ID = (*env)-&gt;GetMethodID(env, strClazz,
 837                                              &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);
 838     CHECK_NULL(String_getBytes_ID);
 839     String_init_ID = (*env)-&gt;GetMethodID(env, strClazz,
 840                                          &quot;&lt;init&gt;&quot;, &quot;([BLjava/lang/String;)V&quot;);
 841     CHECK_NULL(String_init_ID);
 842     String_coder_ID = (*env)-&gt;GetFieldID(env, strClazz, &quot;coder&quot;, &quot;B&quot;);
 843     CHECK_NULL(String_coder_ID);
 844     String_value_ID = (*env)-&gt;GetFieldID(env, strClazz, &quot;value&quot;, &quot;[B&quot;);
 845     CHECK_NULL(String_value_ID);
 846 }
 847 
 848 JNIEXPORT jstring
 849 NewStringPlatform(JNIEnv *env, const char *str)
 850 {
 851     return JNU_NewStringPlatform(env, str);
 852 }
 853 
 854 JNIEXPORT jstring JNICALL
 855 JNU_NewStringPlatform(JNIEnv *env, const char *str)
 856 {
 857     if (fastEncoding == FAST_UTF_8)
 858         return newStringUTF8(env, str);
 859     if (fastEncoding == FAST_8859_1)
 860         return newString8859_1(env, str);
 861     if (fastEncoding == FAST_646_US)
 862         return newString646_US(env, str);
 863     if (fastEncoding == FAST_CP1252)
 864         return newStringCp1252(env, str);
 865     if (fastEncoding == NO_ENCODING_YET) {
 866         JNU_ThrowInternalError(env, &quot;platform encoding not initialized&quot;);
 867         return NULL;
 868     }
 869     return newStringJava(env, str);
 870 }
 871 
 872 JNIEXPORT const char *
 873 GetStringPlatformChars(JNIEnv *env, jstring jstr, jboolean *isCopy)
 874 {
 875     return JNU_GetStringPlatformChars(env, jstr, isCopy);
 876 }
 877 
 878 static const char* getStringBytes(JNIEnv *env, jstring jstr) {
 879     char *result = NULL;
 880     jbyteArray hab = 0;
 881 
 882     if ((*env)-&gt;EnsureLocalCapacity(env, 2) &lt; 0)
 883         return 0;
 884 
 885     if (jnuEncodingSupported(env)) {
 886         hab = (*env)-&gt;CallObjectMethod(env, jstr, String_getBytes_ID, jnuEncoding);
 887     } else {
 888         jmethodID mid;
 889         jclass strClazz = JNU_ClassString(env);
 890         CHECK_NULL_RETURN(strClazz, 0);
 891         mid = (*env)-&gt;GetMethodID(env, strClazz,
 892                                        &quot;getBytes&quot;, &quot;()[B&quot;);
 893         if (mid != NULL) {
 894             hab = (*env)-&gt;CallObjectMethod(env, jstr, mid);
 895         }
 896     }
 897 
 898     if (!(*env)-&gt;ExceptionCheck(env)) {
 899         jint len = (*env)-&gt;GetArrayLength(env, hab);
 900         result = MALLOC_MIN4(len);
 901         if (result == 0) {
 902             JNU_ThrowOutOfMemoryError(env, 0);
 903             (*env)-&gt;DeleteLocalRef(env, hab);
 904             return 0;
 905         }
 906         (*env)-&gt;GetByteArrayRegion(env, hab, 0, len, (jbyte *)result);
 907         result[len] = 0; /* NULL-terminate */
 908     }
 909 
 910     (*env)-&gt;DeleteLocalRef(env, hab);
 911     return result;
 912 }
 913 
 914 static const char*
 915 getStringUTF8(JNIEnv *env, jstring jstr)
 916 {
 917     int i;
 918     char *result;
 919     jbyteArray value;
 920     jint len;
 921     jbyte *str;
 922     jint rlen;
 923     int ri;
 924     jbyte coder = (*env)-&gt;GetByteField(env, jstr, String_coder_ID);
 925     if (coder != java_lang_String_LATIN1) {
 926         return getStringBytes(env, jstr);
 927     }
 928     if ((*env)-&gt;EnsureLocalCapacity(env, 2) &lt; 0) {
 929         return NULL;
 930     }
 931     value = (*env)-&gt;GetObjectField(env, jstr, String_value_ID);
 932     if (value == NULL)
 933         return NULL;
 934     len = (*env)-&gt;GetArrayLength(env, value);
 935     str = (*env)-&gt;GetPrimitiveArrayCritical(env, value, NULL);
 936     if (str == NULL) {
 937         return NULL;
 938     }
 939 
 940     rlen = len;
 941     // we need two bytes for each latin-1 char above 127 (negative jbytes)
 942     for (i = 0; i &lt; len; i++) {
 943         if (str[i] &lt; 0) {
 944             rlen++;
 945         }
 946     }
 947 
 948     result = MALLOC_MIN4(rlen);
 949     if (result == NULL) {
 950         (*env)-&gt;ReleasePrimitiveArrayCritical(env, value, str, 0);
 951         JNU_ThrowOutOfMemoryError(env, 0);
 952         return NULL;
 953     }
 954 
 955     for (ri = 0, i = 0; i &lt; len; i++) {
 956         jbyte c = str[i];
 957         if (c &lt; 0) {
 958             result[ri++] = (char)(0xc0 | ((c &amp; 0xff) &gt;&gt; 6));
 959             result[ri++] = (char)(0x80 | (c &amp; 0x3f));
 960         } else {
 961             result[ri++] = c;
 962         }
 963     }
 964     (*env)-&gt;ReleasePrimitiveArrayCritical(env, value, str, 0);
 965     result[rlen] = &#39;\0&#39;;
 966     return result;
 967 }
 968 
 969 JNIEXPORT const char * JNICALL
 970 JNU_GetStringPlatformChars(JNIEnv *env, jstring jstr, jboolean *isCopy)
 971 {
 972 
 973     if (isCopy)
 974         *isCopy = JNI_TRUE;
 975 
 976     if (fastEncoding == FAST_UTF_8)
 977         return getStringUTF8(env, jstr);
 978     if (fastEncoding == FAST_8859_1)
 979         return getString8859_1Chars(env, jstr);
 980     if (fastEncoding == FAST_646_US)
 981         return getString646_USChars(env, jstr);
 982     if (fastEncoding == FAST_CP1252)
 983         return getStringCp1252Chars(env, jstr);
 984     if (fastEncoding == NO_ENCODING_YET) {
 985         JNU_ThrowInternalError(env, &quot;platform encoding not initialized&quot;);
 986         return 0;
 987     } else
 988         return getStringBytes(env, jstr);
 989 }
 990 
 991 JNIEXPORT void JNICALL
 992 JNU_ReleaseStringPlatformChars(JNIEnv *env, jstring jstr, const char *str)
 993 {
 994     free((void *)str);
 995 }
 996 
 997 /*
 998  * Export the platform dependent path canonicalization so that
 999  * VM can find it when loading system classes.
1000  * This function is also used by the instrumentation agent.
1001  */
1002 extern int canonicalize(char *path, const char *out, int len);
1003 
1004 JNIEXPORT int
1005 Canonicalize(JNIEnv *unused, char *orig, char *out, int len)
1006 {
1007     /* canonicalize an already natived path */
1008     return canonicalize(orig, out, len);
1009 }
1010 
1011 JNIEXPORT jclass JNICALL
1012 JNU_ClassString(JNIEnv *env)
1013 {
1014     static jclass cls = 0;
1015     if (cls == 0) {
1016         jclass c;
1017         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1018             return 0;
1019         c = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
1020         CHECK_NULL_RETURN(c, NULL);
1021         cls = (*env)-&gt;NewGlobalRef(env, c);
1022         (*env)-&gt;DeleteLocalRef(env, c);
1023     }
1024     return cls;
1025 }
1026 
1027 JNIEXPORT jclass JNICALL
1028 JNU_ClassClass(JNIEnv *env)
1029 {
1030     static jclass cls = 0;
1031     if (cls == 0) {
1032         jclass c;
1033         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1034             return 0;
1035         c = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
1036         CHECK_NULL_RETURN(c, NULL);
1037         cls = (*env)-&gt;NewGlobalRef(env, c);
1038         (*env)-&gt;DeleteLocalRef(env, c);
1039     }
1040     return cls;
1041 }
1042 
1043 JNIEXPORT jclass JNICALL
1044 JNU_ClassObject(JNIEnv *env)
1045 {
1046     static jclass cls = 0;
1047     if (cls == 0) {
1048         jclass c;
1049         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1050             return 0;
1051         c = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
1052         CHECK_NULL_RETURN(c, NULL);
1053         cls = (*env)-&gt;NewGlobalRef(env, c);
1054         (*env)-&gt;DeleteLocalRef(env, c);
1055     }
1056     return cls;
1057 }
1058 
1059 JNIEXPORT jclass JNICALL
1060 JNU_ClassThrowable(JNIEnv *env)
1061 {
1062     static jclass cls = 0;
1063     if (cls == 0) {
1064         jclass c;
1065         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1066             return 0;
1067         c = (*env)-&gt;FindClass(env, &quot;java/lang/Throwable&quot;);
1068         CHECK_NULL_RETURN(c, NULL);
1069         cls = (*env)-&gt;NewGlobalRef(env, c);
1070         (*env)-&gt;DeleteLocalRef(env, c);
1071     }
1072     return cls;
1073 }
1074 
1075 JNIEXPORT jint JNICALL
1076 JNU_CopyObjectArray(JNIEnv *env, jobjectArray dst, jobjectArray src,
1077                          jint count)
1078 {
1079     int i;
1080     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1081         return -1;
1082     for (i=0; i&lt;count; i++) {
1083         jstring p = (*env)-&gt;GetObjectArrayElement(env, src, i);
1084         (*env)-&gt;SetObjectArrayElement(env, dst, i, p);
1085         (*env)-&gt;DeleteLocalRef(env, p);
1086     }
1087     return 0;
1088 }
1089 
1090 JNIEXPORT void * JNICALL
1091 JNU_GetEnv(JavaVM *vm, jint version)
1092 {
1093     void *env;
1094     (*vm)-&gt;GetEnv(vm, &amp;env, version);
1095     return env;
1096 }
1097 
1098 JNIEXPORT jint JNICALL
1099 JNU_IsInstanceOfByName(JNIEnv *env, jobject object, char* classname)
1100 {
1101     jclass cls;
1102     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1103         return JNI_ERR;
1104     cls = (*env)-&gt;FindClass(env, classname);
1105     if (cls != NULL) {
1106         jint result = (*env)-&gt;IsInstanceOf(env, object, cls);
1107         (*env)-&gt;DeleteLocalRef(env, cls);
1108         return result;
1109     }
1110     return JNI_ERR;
1111 }
1112 
1113 JNIEXPORT jboolean JNICALL
1114 JNU_Equals(JNIEnv *env, jobject object1, jobject object2)
1115 {
1116     static jmethodID mid = NULL;
1117     if (mid == NULL) {
1118         jclass objClazz = JNU_ClassObject(env);
1119         CHECK_NULL_RETURN(objClazz, JNI_FALSE);
1120         mid = (*env)-&gt;GetMethodID(env, objClazz, &quot;equals&quot;,
1121                                   &quot;(Ljava/lang/Object;)Z&quot;);
1122         CHECK_NULL_RETURN(mid, JNI_FALSE);
1123     }
1124     return (*env)-&gt;CallBooleanMethod(env, object1, mid, object2);
1125 }
1126 
1127 
1128 /************************************************************************
1129  * Thread calls
1130  */
1131 
1132 static jmethodID Object_waitMID;
1133 static jmethodID Object_notifyMID;
1134 static jmethodID Object_notifyAllMID;
1135 
1136 JNIEXPORT void JNICALL
1137 JNU_MonitorWait(JNIEnv *env, jobject object, jlong timeout)
1138 {
1139     if (object == NULL) {
1140         JNU_ThrowNullPointerException(env, &quot;JNU_MonitorWait argument&quot;);
1141         return;
1142     }
1143     if (Object_waitMID == NULL) {
1144         jclass cls = JNU_ClassObject(env);
1145         if (cls == NULL) {
1146             return;
1147         }
1148         Object_waitMID = (*env)-&gt;GetMethodID(env, cls, &quot;wait&quot;, &quot;(J)V&quot;);
1149         if (Object_waitMID == NULL) {
1150             return;
1151         }
1152     }
1153     (*env)-&gt;CallVoidMethod(env, object, Object_waitMID, timeout);
1154 }
1155 
1156 JNIEXPORT void JNICALL
1157 JNU_Notify(JNIEnv *env, jobject object)
1158 {
1159     if (object == NULL) {
1160         JNU_ThrowNullPointerException(env, &quot;JNU_Notify argument&quot;);
1161         return;
1162     }
1163     if (Object_notifyMID == NULL) {
1164         jclass cls = JNU_ClassObject(env);
1165         if (cls == NULL) {
1166             return;
1167         }
1168         Object_notifyMID = (*env)-&gt;GetMethodID(env, cls, &quot;notify&quot;, &quot;()V&quot;);
1169         if (Object_notifyMID == NULL) {
1170             return;
1171         }
1172     }
1173     (*env)-&gt;CallVoidMethod(env, object, Object_notifyMID);
1174 }
1175 
1176 JNIEXPORT void JNICALL
1177 JNU_NotifyAll(JNIEnv *env, jobject object)
1178 {
1179     if (object == NULL) {
1180         JNU_ThrowNullPointerException(env, &quot;JNU_NotifyAll argument&quot;);
1181         return;
1182     }
1183     if (Object_notifyAllMID == NULL) {
1184         jclass cls = JNU_ClassObject(env);
1185         if (cls == NULL) {
1186             return;
1187         }
1188         Object_notifyAllMID = (*env)-&gt;GetMethodID(env, cls,&quot;notifyAll&quot;, &quot;()V&quot;);
1189         if (Object_notifyAllMID == NULL) {
1190             return;
1191         }
1192     }
1193     (*env)-&gt;CallVoidMethod(env, object, Object_notifyAllMID);
1194 }
1195 
1196 
1197 /************************************************************************
1198  * Debugging utilities
1199  */
1200 
1201 JNIEXPORT void JNICALL
1202 JNU_PrintString(JNIEnv *env, char *hdr, jstring string)
1203 {
1204     if (string == NULL) {
1205         fprintf(stderr, &quot;%s: is NULL\n&quot;, hdr);
1206     } else {
1207         const char *stringPtr = JNU_GetStringPlatformChars(env, string, 0);
1208         if (stringPtr == 0)
1209             return;
1210         fprintf(stderr, &quot;%s: %s\n&quot;, hdr, stringPtr);
1211         JNU_ReleaseStringPlatformChars(env, string, stringPtr);
1212     }
1213 }
1214 
1215 JNIEXPORT void JNICALL
1216 JNU_PrintClass(JNIEnv *env, char* hdr, jobject object)
1217 {
1218     if (object == NULL) {
1219         fprintf(stderr, &quot;%s: object is NULL\n&quot;, hdr);
1220         return;
1221     } else {
1222         jclass cls = (*env)-&gt;GetObjectClass(env, object);
1223         jstring clsName = JNU_ToString(env, cls);
1224         if (clsName == NULL) {
1225             JNU_PrintString(env, hdr, clsName);
1226         }
1227         (*env)-&gt;DeleteLocalRef(env, cls);
1228         (*env)-&gt;DeleteLocalRef(env, clsName);
1229     }
1230 }
1231 
1232 JNIEXPORT jstring JNICALL
1233 JNU_ToString(JNIEnv *env, jobject object)
1234 {
1235     if (object == NULL) {
1236         return (*env)-&gt;NewStringUTF(env, &quot;NULL&quot;);
1237     } else {
1238         return (jstring)JNU_CallMethodByName(env,
1239                                              NULL,
1240                                              object,
1241                                              &quot;toString&quot;,
1242                                              &quot;()Ljava/lang/String;&quot;).l;
1243     }
1244 }
1245 
1246 JNIEXPORT jvalue JNICALL
1247 JNU_GetFieldByName(JNIEnv *env,
1248                    jboolean *hasException,
1249                    jobject obj,
1250                    const char *name,
1251                    const char *signature)
1252 {
1253     jclass cls;
1254     jfieldID fid;
1255     jvalue result;
1256 
1257     result.i = 0;
1258 
1259     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
1260         goto done2;
1261 
1262     cls = (*env)-&gt;GetObjectClass(env, obj);
1263     fid = (*env)-&gt;GetFieldID(env, cls, name, signature);
1264     if (fid == 0)
1265         goto done1;
1266 
1267     switch (*signature) {
1268     case &#39;[&#39;:
1269     case &#39;L&#39;:
1270         result.l = (*env)-&gt;GetObjectField(env, obj, fid);
1271         break;
1272     case &#39;Z&#39;:
1273         result.z = (*env)-&gt;GetBooleanField(env, obj, fid);
1274         break;
1275     case &#39;B&#39;:
1276         result.b = (*env)-&gt;GetByteField(env, obj, fid);
1277         break;
1278     case &#39;C&#39;:
1279         result.c = (*env)-&gt;GetCharField(env, obj, fid);
1280         break;
1281     case &#39;S&#39;:
1282         result.s = (*env)-&gt;GetShortField(env, obj, fid);
1283         break;
1284     case &#39;I&#39;:
1285         result.i = (*env)-&gt;GetIntField(env, obj, fid);
1286         break;
1287     case &#39;J&#39;:
1288         result.j = (*env)-&gt;GetLongField(env, obj, fid);
1289         break;
1290     case &#39;F&#39;:
1291         result.f = (*env)-&gt;GetFloatField(env, obj, fid);
1292         break;
1293     case &#39;D&#39;:
1294         result.d = (*env)-&gt;GetDoubleField(env, obj, fid);
1295         break;
1296 
1297     default:
1298         (*env)-&gt;FatalError(env, &quot;JNU_GetFieldByName: illegal signature&quot;);
1299     }
1300 
1301  done1:
1302     (*env)-&gt;DeleteLocalRef(env, cls);
1303  done2:
1304     if (hasException) {
1305         *hasException = (*env)-&gt;ExceptionCheck(env);
1306     }
1307     return result;
1308 }
1309 
1310 JNIEXPORT void JNICALL
1311 JNU_SetFieldByName(JNIEnv *env,
1312                    jboolean *hasException,
1313                    jobject obj,
1314                    const char *name,
1315                    const char *signature,
1316                    ...)
1317 {
1318     jclass cls;
1319     jfieldID fid;
1320     va_list args;
1321 
1322     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
1323         goto done2;
1324 
1325     cls = (*env)-&gt;GetObjectClass(env, obj);
1326     fid = (*env)-&gt;GetFieldID(env, cls, name, signature);
1327     if (fid == 0)
1328         goto done1;
1329 
1330     va_start(args, signature);
1331     switch (*signature) {
1332     case &#39;[&#39;:
1333     case &#39;L&#39;:
1334         (*env)-&gt;SetObjectField(env, obj, fid, va_arg(args, jobject));
1335         break;
1336     case &#39;Z&#39;:
1337         (*env)-&gt;SetBooleanField(env, obj, fid, (jboolean)va_arg(args, int));
1338         break;
1339     case &#39;B&#39;:
1340         (*env)-&gt;SetByteField(env, obj, fid, (jbyte)va_arg(args, int));
1341         break;
1342     case &#39;C&#39;:
1343         (*env)-&gt;SetCharField(env, obj, fid, (jchar)va_arg(args, int));
1344         break;
1345     case &#39;S&#39;:
1346         (*env)-&gt;SetShortField(env, obj, fid, (jshort)va_arg(args, int));
1347         break;
1348     case &#39;I&#39;:
1349         (*env)-&gt;SetIntField(env, obj, fid, va_arg(args, jint));
1350         break;
1351     case &#39;J&#39;:
1352         (*env)-&gt;SetLongField(env, obj, fid, va_arg(args, jlong));
1353         break;
1354     case &#39;F&#39;:
1355         (*env)-&gt;SetFloatField(env, obj, fid, (jfloat)va_arg(args, jdouble));
1356         break;
1357     case &#39;D&#39;:
1358         (*env)-&gt;SetDoubleField(env, obj, fid, va_arg(args, jdouble));
1359         break;
1360 
1361     default:
1362         (*env)-&gt;FatalError(env, &quot;JNU_SetFieldByName: illegal signature&quot;);
1363     }
1364     va_end(args);
1365 
1366  done1:
1367     (*env)-&gt;DeleteLocalRef(env, cls);
1368  done2:
1369     if (hasException) {
1370         *hasException = (*env)-&gt;ExceptionCheck(env);
1371     }
1372 }
1373 
1374 JNIEXPORT jvalue JNICALL
1375 JNU_GetStaticFieldByName(JNIEnv *env,
1376                          jboolean *hasException,
1377                          const char *classname,
1378                          const char *name,
1379                          const char *signature)
1380 {
1381     jclass cls;
1382     jfieldID fid;
1383     jvalue result;
1384 
1385     result.i = 0;
1386 
1387     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
1388         goto done2;
1389 
1390     cls = (*env)-&gt;FindClass(env, classname);
1391     if (cls == 0)
1392         goto done2;
1393 
1394     fid = (*env)-&gt;GetStaticFieldID(env, cls, name, signature);
1395     if (fid == 0)
1396         goto done1;
1397 
1398     switch (*signature) {
1399     case &#39;[&#39;:
1400     case &#39;L&#39;:
1401         result.l = (*env)-&gt;GetStaticObjectField(env, cls, fid);
1402         break;
1403     case &#39;Z&#39;:
1404         result.z = (*env)-&gt;GetStaticBooleanField(env, cls, fid);
1405         break;
1406     case &#39;B&#39;:
1407         result.b = (*env)-&gt;GetStaticByteField(env, cls, fid);
1408         break;
1409     case &#39;C&#39;:
1410         result.c = (*env)-&gt;GetStaticCharField(env, cls, fid);
1411         break;
1412     case &#39;S&#39;:
1413         result.s = (*env)-&gt;GetStaticShortField(env, cls, fid);
1414         break;
1415     case &#39;I&#39;:
1416         result.i = (*env)-&gt;GetStaticIntField(env, cls, fid);
1417         break;
1418     case &#39;J&#39;:
1419         result.j = (*env)-&gt;GetStaticLongField(env, cls, fid);
1420         break;
1421     case &#39;F&#39;:
1422         result.f = (*env)-&gt;GetStaticFloatField(env, cls, fid);
1423         break;
1424     case &#39;D&#39;:
1425         result.d = (*env)-&gt;GetStaticDoubleField(env, cls, fid);
1426         break;
1427 
1428     default:
1429         (*env)-&gt;FatalError(env, &quot;JNU_GetStaticFieldByName: illegal signature&quot;);
1430     }
1431 
1432  done1:
1433     (*env)-&gt;DeleteLocalRef(env, cls);
1434  done2:
1435     if (hasException) {
1436         *hasException = (*env)-&gt;ExceptionCheck(env);
1437     }
1438     return result;
1439 }
1440 
1441 JNIEXPORT void JNICALL
1442 JNU_SetStaticFieldByName(JNIEnv *env,
1443                          jboolean *hasException,
1444                          const char *classname,
1445                          const char *name,
1446                          const char *signature,
1447                          ...)
1448 {
1449     jclass cls;
1450     jfieldID fid;
1451     va_list args;
1452 
1453     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)
1454         goto done2;
1455 
1456     cls = (*env)-&gt;FindClass(env, classname);
1457     if (cls == 0)
1458         goto done2;
1459 
1460     fid = (*env)-&gt;GetStaticFieldID(env, cls, name, signature);
1461     if (fid == 0)
1462         goto done1;
1463 
1464     va_start(args, signature);
1465     switch (*signature) {
1466     case &#39;[&#39;:
1467     case &#39;L&#39;:
1468         (*env)-&gt;SetStaticObjectField(env, cls, fid, va_arg(args, jobject));
1469         break;
1470     case &#39;Z&#39;:
1471         (*env)-&gt;SetStaticBooleanField(env, cls, fid, (jboolean)va_arg(args, int));
1472         break;
1473     case &#39;B&#39;:
1474         (*env)-&gt;SetStaticByteField(env, cls, fid, (jbyte)va_arg(args, int));
1475         break;
1476     case &#39;C&#39;:
1477         (*env)-&gt;SetStaticCharField(env, cls, fid, (jchar)va_arg(args, int));
1478         break;
1479     case &#39;S&#39;:
1480         (*env)-&gt;SetStaticShortField(env, cls, fid, (jshort)va_arg(args, int));
1481         break;
1482     case &#39;I&#39;:
1483         (*env)-&gt;SetStaticIntField(env, cls, fid, va_arg(args, jint));
1484         break;
1485     case &#39;J&#39;:
1486         (*env)-&gt;SetStaticLongField(env, cls, fid, va_arg(args, jlong));
1487         break;
1488     case &#39;F&#39;:
1489         (*env)-&gt;SetStaticFloatField(env, cls, fid, (jfloat)va_arg(args, jdouble));
1490         break;
1491     case &#39;D&#39;:
1492         (*env)-&gt;SetStaticDoubleField(env, cls, fid, va_arg(args, jdouble));
1493         break;
1494 
1495     default:
1496         (*env)-&gt;FatalError(env, &quot;JNU_SetStaticFieldByName: illegal signature&quot;);
1497     }
1498     va_end(args);
1499 
1500  done1:
1501     (*env)-&gt;DeleteLocalRef(env, cls);
1502  done2:
1503     if (hasException) {
1504         *hasException = (*env)-&gt;ExceptionCheck(env);
1505     }
1506 }
    </pre>
  </body>
</html>
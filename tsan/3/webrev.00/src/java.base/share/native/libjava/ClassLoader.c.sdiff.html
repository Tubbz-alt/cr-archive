<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/native/libjava/ClassLoader.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Class.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Object.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/native/libjava/ClassLoader.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;assert.h&gt;
 28 
 29 #include &quot;jni.h&quot;
 30 #include &quot;jni_util.h&quot;
 31 #include &quot;jlong.h&quot;
 32 #include &quot;jvm.h&quot;

 33 #include &quot;java_lang_ClassLoader.h&quot;
 34 #include &quot;java_lang_ClassLoader_NativeLibrary.h&quot;
 35 #include &lt;string.h&gt;
 36 
<span class="line-removed"> 37 /* defined in libverify.so/verify.dll (src file common/check_format.c) */</span>
<span class="line-removed"> 38 extern jboolean VerifyClassname(char *utf_name, jboolean arrayAllowed);</span>
<span class="line-removed"> 39 extern jboolean VerifyFixClassname(char *utf_name);</span>
<span class="line-removed"> 40 </span>
 41 static JNINativeMethod methods[] = {
 42     {&quot;retrieveDirectives&quot;,  &quot;()Ljava/lang/AssertionStatusDirectives;&quot;, (void *)&amp;JVM_AssertionStatusDirectives}
 43 };
 44 
 45 JNIEXPORT void JNICALL
 46 Java_java_lang_ClassLoader_registerNatives(JNIEnv *env, jclass cls)
 47 {
 48     (*env)-&gt;RegisterNatives(env, cls, methods,
 49                             sizeof(methods)/sizeof(JNINativeMethod));
 50 }
 51 
 52 /* Convert java string to UTF char*. Use local buffer if possible,
 53    otherwise malloc new memory. Returns null IFF malloc failed. */
 54 static char*
 55 getUTF(JNIEnv *env, jstring str, char* localBuf, int bufSize)
 56 {
 57     char* utfStr = NULL;
 58 
 59     int len = (*env)-&gt;GetStringUTFLength(env, str);
 60     int unicode_len = (*env)-&gt;GetStringLength(env, str);
</pre>
<hr />
<pre>
103         return 0;
104     }
105 
106     body = (jbyte *)malloc(length);
107 
108     if (body == 0) {
109         JNU_ThrowOutOfMemoryError(env, 0);
110         return 0;
111     }
112 
113     (*env)-&gt;GetByteArrayRegion(env, data, offset, length, body);
114 
115     if ((*env)-&gt;ExceptionOccurred(env))
116         goto free_body;
117 
118     if (name != NULL) {
119         utfName = getUTF(env, name, buf, sizeof(buf));
120         if (utfName == NULL) {
121             goto free_body;
122         }
<span class="line-modified">123         VerifyFixClassname(utfName);</span>
124     } else {
125         utfName = NULL;
126     }
127 
128     if (source != NULL) {
129         utfSource = getUTF(env, source, sourceBuf, sizeof(sourceBuf));
130         if (utfSource == NULL) {
131             goto free_utfName;
132         }
133     } else {
134         utfSource = NULL;
135     }
136     result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);
137 
138     if (utfSource &amp;&amp; utfSource != sourceBuf)
139         free(utfSource);
140 
141  free_utfName:
142     if (utfName &amp;&amp; utfName != buf)
143         free(utfName);
</pre>
<hr />
<pre>
168     assert(data != NULL); // caller fails if data is null.
169     assert(length &gt;= 0);  // caller passes ByteBuffer.remaining() for length, so never neg.
170     // caller passes ByteBuffer.position() for offset, and capacity() &gt;= position() + remaining()
171     assert((*env)-&gt;GetDirectBufferCapacity(env, data) &gt;= (offset + length));
172 
173     body = (*env)-&gt;GetDirectBufferAddress(env, data);
174 
175     if (body == 0) {
176         JNU_ThrowNullPointerException(env, 0);
177         return 0;
178     }
179 
180     body += offset;
181 
182     if (name != NULL) {
183         utfName = getUTF(env, name, buf, sizeof(buf));
184         if (utfName == NULL) {
185             JNU_ThrowOutOfMemoryError(env, NULL);
186             return result;
187         }
<span class="line-modified">188         VerifyFixClassname(utfName);</span>
189     } else {
190         utfName = NULL;
191     }
192 
193     if (source != NULL) {
194         utfSource = getUTF(env, source, sourceBuf, sizeof(sourceBuf));
195         if (utfSource == NULL) {
196             JNU_ThrowOutOfMemoryError(env, NULL);
197             goto free_utfName;
198         }
199     } else {
200         utfSource = NULL;
201     }
202     result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);
203 
204     if (utfSource &amp;&amp; utfSource != sourceBuf)
205         free(utfSource);
206 
207  free_utfName:
208     if (utfName &amp;&amp; utfName != buf)
</pre>
<hr />
<pre>
214 /*
215  * Returns NULL if class not found.
216  */
217 JNIEXPORT jclass JNICALL
218 Java_java_lang_ClassLoader_findBootstrapClass(JNIEnv *env, jobject loader,
219                                               jstring classname)
220 {
221     char *clname;
222     jclass cls = 0;
223     char buf[128];
224 
225     if (classname == NULL) {
226         return 0;
227     }
228 
229     clname = getUTF(env, classname, buf, sizeof(buf));
230     if (clname == NULL) {
231         JNU_ThrowOutOfMemoryError(env, NULL);
232         return NULL;
233     }
<span class="line-modified">234     VerifyFixClassname(clname);</span>
235 
<span class="line-modified">236     if (!VerifyClassname(clname, JNI_TRUE)) {  /* expects slashed name */</span>
237         goto done;
238     }
239 
240     cls = JVM_FindClassFromBootLoader(env, clname);
241 
242  done:
243     if (clname != buf) {
244         free(clname);
245     }
246 
247     return cls;
248 }
249 
250 JNIEXPORT jclass JNICALL
251 Java_java_lang_ClassLoader_findLoadedClass0(JNIEnv *env, jobject loader,
252                                            jstring name)
253 {
254     if (name == NULL) {
255         return 0;
256     } else {
</pre>
</td>
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;assert.h&gt;
 28 
 29 #include &quot;jni.h&quot;
 30 #include &quot;jni_util.h&quot;
 31 #include &quot;jlong.h&quot;
 32 #include &quot;jvm.h&quot;
<span class="line-added"> 33 #include &quot;check_classname.h&quot;</span>
 34 #include &quot;java_lang_ClassLoader.h&quot;
 35 #include &quot;java_lang_ClassLoader_NativeLibrary.h&quot;
 36 #include &lt;string.h&gt;
 37 




 38 static JNINativeMethod methods[] = {
 39     {&quot;retrieveDirectives&quot;,  &quot;()Ljava/lang/AssertionStatusDirectives;&quot;, (void *)&amp;JVM_AssertionStatusDirectives}
 40 };
 41 
 42 JNIEXPORT void JNICALL
 43 Java_java_lang_ClassLoader_registerNatives(JNIEnv *env, jclass cls)
 44 {
 45     (*env)-&gt;RegisterNatives(env, cls, methods,
 46                             sizeof(methods)/sizeof(JNINativeMethod));
 47 }
 48 
 49 /* Convert java string to UTF char*. Use local buffer if possible,
 50    otherwise malloc new memory. Returns null IFF malloc failed. */
 51 static char*
 52 getUTF(JNIEnv *env, jstring str, char* localBuf, int bufSize)
 53 {
 54     char* utfStr = NULL;
 55 
 56     int len = (*env)-&gt;GetStringUTFLength(env, str);
 57     int unicode_len = (*env)-&gt;GetStringLength(env, str);
</pre>
<hr />
<pre>
100         return 0;
101     }
102 
103     body = (jbyte *)malloc(length);
104 
105     if (body == 0) {
106         JNU_ThrowOutOfMemoryError(env, 0);
107         return 0;
108     }
109 
110     (*env)-&gt;GetByteArrayRegion(env, data, offset, length, body);
111 
112     if ((*env)-&gt;ExceptionOccurred(env))
113         goto free_body;
114 
115     if (name != NULL) {
116         utfName = getUTF(env, name, buf, sizeof(buf));
117         if (utfName == NULL) {
118             goto free_body;
119         }
<span class="line-modified">120         fixClassname(utfName);</span>
121     } else {
122         utfName = NULL;
123     }
124 
125     if (source != NULL) {
126         utfSource = getUTF(env, source, sourceBuf, sizeof(sourceBuf));
127         if (utfSource == NULL) {
128             goto free_utfName;
129         }
130     } else {
131         utfSource = NULL;
132     }
133     result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);
134 
135     if (utfSource &amp;&amp; utfSource != sourceBuf)
136         free(utfSource);
137 
138  free_utfName:
139     if (utfName &amp;&amp; utfName != buf)
140         free(utfName);
</pre>
<hr />
<pre>
165     assert(data != NULL); // caller fails if data is null.
166     assert(length &gt;= 0);  // caller passes ByteBuffer.remaining() for length, so never neg.
167     // caller passes ByteBuffer.position() for offset, and capacity() &gt;= position() + remaining()
168     assert((*env)-&gt;GetDirectBufferCapacity(env, data) &gt;= (offset + length));
169 
170     body = (*env)-&gt;GetDirectBufferAddress(env, data);
171 
172     if (body == 0) {
173         JNU_ThrowNullPointerException(env, 0);
174         return 0;
175     }
176 
177     body += offset;
178 
179     if (name != NULL) {
180         utfName = getUTF(env, name, buf, sizeof(buf));
181         if (utfName == NULL) {
182             JNU_ThrowOutOfMemoryError(env, NULL);
183             return result;
184         }
<span class="line-modified">185         fixClassname(utfName);</span>
186     } else {
187         utfName = NULL;
188     }
189 
190     if (source != NULL) {
191         utfSource = getUTF(env, source, sourceBuf, sizeof(sourceBuf));
192         if (utfSource == NULL) {
193             JNU_ThrowOutOfMemoryError(env, NULL);
194             goto free_utfName;
195         }
196     } else {
197         utfSource = NULL;
198     }
199     result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource);
200 
201     if (utfSource &amp;&amp; utfSource != sourceBuf)
202         free(utfSource);
203 
204  free_utfName:
205     if (utfName &amp;&amp; utfName != buf)
</pre>
<hr />
<pre>
211 /*
212  * Returns NULL if class not found.
213  */
214 JNIEXPORT jclass JNICALL
215 Java_java_lang_ClassLoader_findBootstrapClass(JNIEnv *env, jobject loader,
216                                               jstring classname)
217 {
218     char *clname;
219     jclass cls = 0;
220     char buf[128];
221 
222     if (classname == NULL) {
223         return 0;
224     }
225 
226     clname = getUTF(env, classname, buf, sizeof(buf));
227     if (clname == NULL) {
228         JNU_ThrowOutOfMemoryError(env, NULL);
229         return NULL;
230     }
<span class="line-modified">231     fixClassname(clname);</span>
232 
<span class="line-modified">233     if (!verifyClassname(clname, JNI_TRUE)) {  /* expects slashed name */</span>
234         goto done;
235     }
236 
237     cls = JVM_FindClassFromBootLoader(env, clname);
238 
239  done:
240     if (clname != buf) {
241         free(clname);
242     }
243 
244     return cls;
245 }
246 
247 JNIEXPORT jclass JNICALL
248 Java_java_lang_ClassLoader_findLoadedClass0(JNIEnv *env, jobject loader,
249                                            jstring name)
250 {
251     if (name == NULL) {
252         return 0;
253     } else {
</pre>
</td>
</tr>
</table>
<center><a href="Class.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Object.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
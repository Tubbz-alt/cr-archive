<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/native/libjava/jni_util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jdk_util.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jni_util.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/native/libjava/jni_util.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  59 }
  60 
  61 JNIEXPORT void JNICALL
  62 JNU_ThrowArrayIndexOutOfBoundsException(JNIEnv *env, const char *msg)
  63 {
  64     JNU_ThrowByName(env, &quot;java/lang/ArrayIndexOutOfBoundsException&quot;, msg);
  65 }
  66 
  67 JNIEXPORT void JNICALL
  68 JNU_ThrowOutOfMemoryError(JNIEnv *env, const char *msg)
  69 {
  70     JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;, msg);
  71 }
  72 
  73 JNIEXPORT void JNICALL
  74 JNU_ThrowIllegalArgumentException(JNIEnv *env, const char *msg)
  75 {
  76     JNU_ThrowByName(env, &quot;java/lang/IllegalArgumentException&quot;, msg);
  77 }
  78 
<span class="line-removed">  79 JNIEXPORT void JNICALL</span>
<span class="line-removed">  80 JNU_ThrowIllegalAccessError(JNIEnv *env, const char *msg)</span>
<span class="line-removed">  81 {</span>
<span class="line-removed">  82     JNU_ThrowByName(env, &quot;java/lang/IllegalAccessError&quot;, msg);</span>
<span class="line-removed">  83 }</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85 JNIEXPORT void JNICALL</span>
<span class="line-removed">  86 JNU_ThrowIllegalAccessException(JNIEnv *env, const char *msg)</span>
<span class="line-removed">  87 {</span>
<span class="line-removed">  88     JNU_ThrowByName(env, &quot;java/lang/IllegalAccessException&quot;, msg);</span>
<span class="line-removed">  89 }</span>
<span class="line-removed">  90 </span>
  91 JNIEXPORT void JNICALL
  92 JNU_ThrowInternalError(JNIEnv *env, const char *msg)
  93 {
  94     JNU_ThrowByName(env, &quot;java/lang/InternalError&quot;, msg);
  95 }
  96 
<span class="line-removed">  97 JNIEXPORT void JNICALL</span>
<span class="line-removed">  98 JNU_ThrowNoSuchFieldException(JNIEnv *env, const char *msg)</span>
<span class="line-removed">  99 {</span>
<span class="line-removed"> 100     JNU_ThrowByName(env, &quot;java/lang/NoSuchFieldException&quot;, msg);</span>
<span class="line-removed"> 101 }</span>
<span class="line-removed"> 102 </span>
<span class="line-removed"> 103 JNIEXPORT void JNICALL</span>
<span class="line-removed"> 104 JNU_ThrowNoSuchMethodException(JNIEnv *env, const char *msg)</span>
<span class="line-removed"> 105 {</span>
<span class="line-removed"> 106     JNU_ThrowByName(env, &quot;java/lang/NoSuchMethodException&quot;, msg);</span>
<span class="line-removed"> 107 }</span>
<span class="line-removed"> 108 </span>
 109 JNIEXPORT void JNICALL
 110 JNU_ThrowClassNotFoundException(JNIEnv *env, const char *msg)
 111 {
 112     JNU_ThrowByName(env, &quot;java/lang/ClassNotFoundException&quot;, msg);
 113 }
 114 
<span class="line-removed"> 115 JNIEXPORT void JNICALL</span>
<span class="line-removed"> 116 JNU_ThrowNumberFormatException(JNIEnv *env, const char *msg)</span>
<span class="line-removed"> 117 {</span>
<span class="line-removed"> 118     JNU_ThrowByName(env, &quot;java/lang/NumberFormatException&quot;, msg);</span>
<span class="line-removed"> 119 }</span>
<span class="line-removed"> 120 </span>
 121 JNIEXPORT void JNICALL
 122 JNU_ThrowIOException(JNIEnv *env, const char *msg)
 123 {
 124     JNU_ThrowByName(env, &quot;java/io/IOException&quot;, msg);
 125 }
 126 
<span class="line-removed"> 127 JNIEXPORT void JNICALL</span>
<span class="line-removed"> 128 JNU_ThrowNoSuchFieldError(JNIEnv *env, const char *msg)</span>
<span class="line-removed"> 129 {</span>
<span class="line-removed"> 130     JNU_ThrowByName(env, &quot;java/lang/NoSuchFieldError&quot;, msg);</span>
<span class="line-removed"> 131 }</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133 JNIEXPORT void JNICALL</span>
<span class="line-removed"> 134 JNU_ThrowNoSuchMethodError(JNIEnv *env, const char *msg)</span>
<span class="line-removed"> 135 {</span>
<span class="line-removed"> 136     JNU_ThrowByName(env, &quot;java/lang/NoSuchMethodError&quot;, msg);</span>
<span class="line-removed"> 137 }</span>
<span class="line-removed"> 138 </span>
<span class="line-removed"> 139 JNIEXPORT void JNICALL</span>
<span class="line-removed"> 140 JNU_ThrowStringIndexOutOfBoundsException(JNIEnv *env, const char *msg)</span>
<span class="line-removed"> 141 {</span>
<span class="line-removed"> 142     JNU_ThrowByName(env, &quot;java/lang/StringIndexOutOfBoundsException&quot;, msg);</span>
<span class="line-removed"> 143 }</span>
<span class="line-removed"> 144 </span>
<span class="line-removed"> 145 JNIEXPORT void JNICALL</span>
<span class="line-removed"> 146 JNU_ThrowInstantiationException(JNIEnv *env, const char *msg)</span>
<span class="line-removed"> 147 {</span>
<span class="line-removed"> 148     JNU_ThrowByName(env, &quot;java/lang/InstantiationException&quot;, msg);</span>
<span class="line-removed"> 149 }</span>
<span class="line-removed"> 150 </span>
 151 /*
 152  * Throw an exception by name, using the string returned by
 153  * getLastErrorString for the detail string. If the last-error
 154  * string is NULL, use the given default detail string.
 155  */
 156 JNIEXPORT void JNICALL
 157 JNU_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 158                              const char *defaultDetail)
 159 {
 160     char buf[256];
 161     size_t n = getLastErrorString(buf, sizeof(buf));
 162 
 163     if (n &gt; 0) {
 164         jstring s = JNU_NewStringPlatform(env, buf);
 165         if (s != NULL) {
 166             jobject x = JNU_NewObjectByName(env, name,
 167                                             &quot;(Ljava/lang/String;)V&quot;, s);
 168             if (x != NULL) {
 169                 (*env)-&gt;Throw(env, x);
 170             }
</pre>
<hr />
<pre>
 828             (*env)-&gt;DeleteLocalRef(env, enc);
 829         }
 830     } else {
 831         JNU_ThrowInternalError(env, &quot;platform encoding undefined&quot;);
 832         return;
 833     }
 834 
 835     /* Initialize method-id cache */
 836     String_getBytes_ID = (*env)-&gt;GetMethodID(env, strClazz,
 837                                              &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);
 838     CHECK_NULL(String_getBytes_ID);
 839     String_init_ID = (*env)-&gt;GetMethodID(env, strClazz,
 840                                          &quot;&lt;init&gt;&quot;, &quot;([BLjava/lang/String;)V&quot;);
 841     CHECK_NULL(String_init_ID);
 842     String_coder_ID = (*env)-&gt;GetFieldID(env, strClazz, &quot;coder&quot;, &quot;B&quot;);
 843     CHECK_NULL(String_coder_ID);
 844     String_value_ID = (*env)-&gt;GetFieldID(env, strClazz, &quot;value&quot;, &quot;[B&quot;);
 845     CHECK_NULL(String_value_ID);
 846 }
 847 
<span class="line-removed"> 848 JNIEXPORT jstring</span>
<span class="line-removed"> 849 NewStringPlatform(JNIEnv *env, const char *str)</span>
<span class="line-removed"> 850 {</span>
<span class="line-removed"> 851     return JNU_NewStringPlatform(env, str);</span>
<span class="line-removed"> 852 }</span>
<span class="line-removed"> 853 </span>
 854 JNIEXPORT jstring JNICALL
 855 JNU_NewStringPlatform(JNIEnv *env, const char *str)
 856 {
 857     if (fastEncoding == FAST_UTF_8)
 858         return newStringUTF8(env, str);
 859     if (fastEncoding == FAST_8859_1)
 860         return newString8859_1(env, str);
 861     if (fastEncoding == FAST_646_US)
 862         return newString646_US(env, str);
 863     if (fastEncoding == FAST_CP1252)
 864         return newStringCp1252(env, str);
 865     if (fastEncoding == NO_ENCODING_YET) {
 866         JNU_ThrowInternalError(env, &quot;platform encoding not initialized&quot;);
 867         return NULL;
 868     }
 869     return newStringJava(env, str);
 870 }
 871 
 872 JNIEXPORT const char *
 873 GetStringPlatformChars(JNIEnv *env, jstring jstr, jboolean *isCopy)
</pre>
<hr />
<pre>
 977         return getStringUTF8(env, jstr);
 978     if (fastEncoding == FAST_8859_1)
 979         return getString8859_1Chars(env, jstr);
 980     if (fastEncoding == FAST_646_US)
 981         return getString646_USChars(env, jstr);
 982     if (fastEncoding == FAST_CP1252)
 983         return getStringCp1252Chars(env, jstr);
 984     if (fastEncoding == NO_ENCODING_YET) {
 985         JNU_ThrowInternalError(env, &quot;platform encoding not initialized&quot;);
 986         return 0;
 987     } else
 988         return getStringBytes(env, jstr);
 989 }
 990 
 991 JNIEXPORT void JNICALL
 992 JNU_ReleaseStringPlatformChars(JNIEnv *env, jstring jstr, const char *str)
 993 {
 994     free((void *)str);
 995 }
 996 
<span class="line-removed"> 997 /*</span>
<span class="line-removed"> 998  * Export the platform dependent path canonicalization so that</span>
<span class="line-removed"> 999  * VM can find it when loading system classes.</span>
<span class="line-removed">1000  * This function is also used by the instrumentation agent.</span>
<span class="line-removed">1001  */</span>
<span class="line-removed">1002 extern int canonicalize(char *path, const char *out, int len);</span>
<span class="line-removed">1003 </span>
<span class="line-removed">1004 JNIEXPORT int</span>
<span class="line-removed">1005 Canonicalize(JNIEnv *unused, char *orig, char *out, int len)</span>
<span class="line-removed">1006 {</span>
<span class="line-removed">1007     /* canonicalize an already natived path */</span>
<span class="line-removed">1008     return canonicalize(orig, out, len);</span>
<span class="line-removed">1009 }</span>
<span class="line-removed">1010 </span>
1011 JNIEXPORT jclass JNICALL
1012 JNU_ClassString(JNIEnv *env)
1013 {
1014     static jclass cls = 0;
1015     if (cls == 0) {
1016         jclass c;
1017         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1018             return 0;
1019         c = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
1020         CHECK_NULL_RETURN(c, NULL);
1021         cls = (*env)-&gt;NewGlobalRef(env, c);
1022         (*env)-&gt;DeleteLocalRef(env, c);
1023     }
1024     return cls;
1025 }
1026 
<span class="line-removed">1027 JNIEXPORT jclass JNICALL</span>
<span class="line-removed">1028 JNU_ClassClass(JNIEnv *env)</span>
<span class="line-removed">1029 {</span>
<span class="line-removed">1030     static jclass cls = 0;</span>
<span class="line-removed">1031     if (cls == 0) {</span>
<span class="line-removed">1032         jclass c;</span>
<span class="line-removed">1033         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)</span>
<span class="line-removed">1034             return 0;</span>
<span class="line-removed">1035         c = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);</span>
<span class="line-removed">1036         CHECK_NULL_RETURN(c, NULL);</span>
<span class="line-removed">1037         cls = (*env)-&gt;NewGlobalRef(env, c);</span>
<span class="line-removed">1038         (*env)-&gt;DeleteLocalRef(env, c);</span>
<span class="line-removed">1039     }</span>
<span class="line-removed">1040     return cls;</span>
<span class="line-removed">1041 }</span>
<span class="line-removed">1042 </span>
<span class="line-removed">1043 JNIEXPORT jclass JNICALL</span>
<span class="line-removed">1044 JNU_ClassObject(JNIEnv *env)</span>
<span class="line-removed">1045 {</span>
<span class="line-removed">1046     static jclass cls = 0;</span>
<span class="line-removed">1047     if (cls == 0) {</span>
<span class="line-removed">1048         jclass c;</span>
<span class="line-removed">1049         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)</span>
<span class="line-removed">1050             return 0;</span>
<span class="line-removed">1051         c = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);</span>
<span class="line-removed">1052         CHECK_NULL_RETURN(c, NULL);</span>
<span class="line-removed">1053         cls = (*env)-&gt;NewGlobalRef(env, c);</span>
<span class="line-removed">1054         (*env)-&gt;DeleteLocalRef(env, c);</span>
<span class="line-removed">1055     }</span>
<span class="line-removed">1056     return cls;</span>
<span class="line-removed">1057 }</span>
<span class="line-removed">1058 </span>
<span class="line-removed">1059 JNIEXPORT jclass JNICALL</span>
<span class="line-removed">1060 JNU_ClassThrowable(JNIEnv *env)</span>
<span class="line-removed">1061 {</span>
<span class="line-removed">1062     static jclass cls = 0;</span>
<span class="line-removed">1063     if (cls == 0) {</span>
<span class="line-removed">1064         jclass c;</span>
<span class="line-removed">1065         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)</span>
<span class="line-removed">1066             return 0;</span>
<span class="line-removed">1067         c = (*env)-&gt;FindClass(env, &quot;java/lang/Throwable&quot;);</span>
<span class="line-removed">1068         CHECK_NULL_RETURN(c, NULL);</span>
<span class="line-removed">1069         cls = (*env)-&gt;NewGlobalRef(env, c);</span>
<span class="line-removed">1070         (*env)-&gt;DeleteLocalRef(env, c);</span>
<span class="line-removed">1071     }</span>
<span class="line-removed">1072     return cls;</span>
<span class="line-removed">1073 }</span>
<span class="line-removed">1074 </span>
1075 JNIEXPORT jint JNICALL
1076 JNU_CopyObjectArray(JNIEnv *env, jobjectArray dst, jobjectArray src,
1077                          jint count)
1078 {
1079     int i;
1080     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1081         return -1;
1082     for (i=0; i&lt;count; i++) {
1083         jstring p = (*env)-&gt;GetObjectArrayElement(env, src, i);
1084         (*env)-&gt;SetObjectArrayElement(env, dst, i, p);
1085         (*env)-&gt;DeleteLocalRef(env, p);
1086     }
1087     return 0;
1088 }
1089 
1090 JNIEXPORT void * JNICALL
1091 JNU_GetEnv(JavaVM *vm, jint version)
1092 {
1093     void *env;
1094     (*vm)-&gt;GetEnv(vm, &amp;env, version);
1095     return env;
1096 }
1097 
1098 JNIEXPORT jint JNICALL
<span class="line-modified">1099 JNU_IsInstanceOfByName(JNIEnv *env, jobject object, char* classname)</span>
1100 {
1101     jclass cls;
1102     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
1103         return JNI_ERR;
1104     cls = (*env)-&gt;FindClass(env, classname);
1105     if (cls != NULL) {
1106         jint result = (*env)-&gt;IsInstanceOf(env, object, cls);
1107         (*env)-&gt;DeleteLocalRef(env, cls);
1108         return result;
1109     }
1110     return JNI_ERR;
1111 }
1112 
<span class="line-removed">1113 JNIEXPORT jboolean JNICALL</span>
<span class="line-removed">1114 JNU_Equals(JNIEnv *env, jobject object1, jobject object2)</span>
<span class="line-removed">1115 {</span>
<span class="line-removed">1116     static jmethodID mid = NULL;</span>
<span class="line-removed">1117     if (mid == NULL) {</span>
<span class="line-removed">1118         jclass objClazz = JNU_ClassObject(env);</span>
<span class="line-removed">1119         CHECK_NULL_RETURN(objClazz, JNI_FALSE);</span>
<span class="line-removed">1120         mid = (*env)-&gt;GetMethodID(env, objClazz, &quot;equals&quot;,</span>
<span class="line-removed">1121                                   &quot;(Ljava/lang/Object;)Z&quot;);</span>
<span class="line-removed">1122         CHECK_NULL_RETURN(mid, JNI_FALSE);</span>
<span class="line-removed">1123     }</span>
<span class="line-removed">1124     return (*env)-&gt;CallBooleanMethod(env, object1, mid, object2);</span>
<span class="line-removed">1125 }</span>
<span class="line-removed">1126 </span>
<span class="line-removed">1127 </span>
<span class="line-removed">1128 /************************************************************************</span>
<span class="line-removed">1129  * Thread calls</span>
<span class="line-removed">1130  */</span>
<span class="line-removed">1131 </span>
<span class="line-removed">1132 static jmethodID Object_waitMID;</span>
<span class="line-removed">1133 static jmethodID Object_notifyMID;</span>
<span class="line-removed">1134 static jmethodID Object_notifyAllMID;</span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136 JNIEXPORT void JNICALL</span>
<span class="line-removed">1137 JNU_MonitorWait(JNIEnv *env, jobject object, jlong timeout)</span>
<span class="line-removed">1138 {</span>
<span class="line-removed">1139     if (object == NULL) {</span>
<span class="line-removed">1140         JNU_ThrowNullPointerException(env, &quot;JNU_MonitorWait argument&quot;);</span>
<span class="line-removed">1141         return;</span>
<span class="line-removed">1142     }</span>
<span class="line-removed">1143     if (Object_waitMID == NULL) {</span>
<span class="line-removed">1144         jclass cls = JNU_ClassObject(env);</span>
<span class="line-removed">1145         if (cls == NULL) {</span>
<span class="line-removed">1146             return;</span>
<span class="line-removed">1147         }</span>
<span class="line-removed">1148         Object_waitMID = (*env)-&gt;GetMethodID(env, cls, &quot;wait&quot;, &quot;(J)V&quot;);</span>
<span class="line-removed">1149         if (Object_waitMID == NULL) {</span>
<span class="line-removed">1150             return;</span>
<span class="line-removed">1151         }</span>
<span class="line-removed">1152     }</span>
<span class="line-removed">1153     (*env)-&gt;CallVoidMethod(env, object, Object_waitMID, timeout);</span>
<span class="line-removed">1154 }</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156 JNIEXPORT void JNICALL</span>
<span class="line-removed">1157 JNU_Notify(JNIEnv *env, jobject object)</span>
<span class="line-removed">1158 {</span>
<span class="line-removed">1159     if (object == NULL) {</span>
<span class="line-removed">1160         JNU_ThrowNullPointerException(env, &quot;JNU_Notify argument&quot;);</span>
<span class="line-removed">1161         return;</span>
<span class="line-removed">1162     }</span>
<span class="line-removed">1163     if (Object_notifyMID == NULL) {</span>
<span class="line-removed">1164         jclass cls = JNU_ClassObject(env);</span>
<span class="line-removed">1165         if (cls == NULL) {</span>
<span class="line-removed">1166             return;</span>
<span class="line-removed">1167         }</span>
<span class="line-removed">1168         Object_notifyMID = (*env)-&gt;GetMethodID(env, cls, &quot;notify&quot;, &quot;()V&quot;);</span>
<span class="line-removed">1169         if (Object_notifyMID == NULL) {</span>
<span class="line-removed">1170             return;</span>
<span class="line-removed">1171         }</span>
<span class="line-removed">1172     }</span>
<span class="line-removed">1173     (*env)-&gt;CallVoidMethod(env, object, Object_notifyMID);</span>
<span class="line-removed">1174 }</span>
<span class="line-removed">1175 </span>
<span class="line-removed">1176 JNIEXPORT void JNICALL</span>
<span class="line-removed">1177 JNU_NotifyAll(JNIEnv *env, jobject object)</span>
<span class="line-removed">1178 {</span>
<span class="line-removed">1179     if (object == NULL) {</span>
<span class="line-removed">1180         JNU_ThrowNullPointerException(env, &quot;JNU_NotifyAll argument&quot;);</span>
<span class="line-removed">1181         return;</span>
<span class="line-removed">1182     }</span>
<span class="line-removed">1183     if (Object_notifyAllMID == NULL) {</span>
<span class="line-removed">1184         jclass cls = JNU_ClassObject(env);</span>
<span class="line-removed">1185         if (cls == NULL) {</span>
<span class="line-removed">1186             return;</span>
<span class="line-removed">1187         }</span>
<span class="line-removed">1188         Object_notifyAllMID = (*env)-&gt;GetMethodID(env, cls,&quot;notifyAll&quot;, &quot;()V&quot;);</span>
<span class="line-removed">1189         if (Object_notifyAllMID == NULL) {</span>
<span class="line-removed">1190             return;</span>
<span class="line-removed">1191         }</span>
<span class="line-removed">1192     }</span>
<span class="line-removed">1193     (*env)-&gt;CallVoidMethod(env, object, Object_notifyAllMID);</span>
<span class="line-removed">1194 }</span>
<span class="line-removed">1195 </span>
<span class="line-removed">1196 </span>
1197 /************************************************************************
1198  * Debugging utilities
1199  */
1200 
<span class="line-removed">1201 JNIEXPORT void JNICALL</span>
<span class="line-removed">1202 JNU_PrintString(JNIEnv *env, char *hdr, jstring string)</span>
<span class="line-removed">1203 {</span>
<span class="line-removed">1204     if (string == NULL) {</span>
<span class="line-removed">1205         fprintf(stderr, &quot;%s: is NULL\n&quot;, hdr);</span>
<span class="line-removed">1206     } else {</span>
<span class="line-removed">1207         const char *stringPtr = JNU_GetStringPlatformChars(env, string, 0);</span>
<span class="line-removed">1208         if (stringPtr == 0)</span>
<span class="line-removed">1209             return;</span>
<span class="line-removed">1210         fprintf(stderr, &quot;%s: %s\n&quot;, hdr, stringPtr);</span>
<span class="line-removed">1211         JNU_ReleaseStringPlatformChars(env, string, stringPtr);</span>
<span class="line-removed">1212     }</span>
<span class="line-removed">1213 }</span>
<span class="line-removed">1214 </span>
<span class="line-removed">1215 JNIEXPORT void JNICALL</span>
<span class="line-removed">1216 JNU_PrintClass(JNIEnv *env, char* hdr, jobject object)</span>
<span class="line-removed">1217 {</span>
<span class="line-removed">1218     if (object == NULL) {</span>
<span class="line-removed">1219         fprintf(stderr, &quot;%s: object is NULL\n&quot;, hdr);</span>
<span class="line-removed">1220         return;</span>
<span class="line-removed">1221     } else {</span>
<span class="line-removed">1222         jclass cls = (*env)-&gt;GetObjectClass(env, object);</span>
<span class="line-removed">1223         jstring clsName = JNU_ToString(env, cls);</span>
<span class="line-removed">1224         if (clsName == NULL) {</span>
<span class="line-removed">1225             JNU_PrintString(env, hdr, clsName);</span>
<span class="line-removed">1226         }</span>
<span class="line-removed">1227         (*env)-&gt;DeleteLocalRef(env, cls);</span>
<span class="line-removed">1228         (*env)-&gt;DeleteLocalRef(env, clsName);</span>
<span class="line-removed">1229     }</span>
<span class="line-removed">1230 }</span>
<span class="line-removed">1231 </span>
1232 JNIEXPORT jstring JNICALL
1233 JNU_ToString(JNIEnv *env, jobject object)
1234 {
1235     if (object == NULL) {
1236         return (*env)-&gt;NewStringUTF(env, &quot;NULL&quot;);
1237     } else {
1238         return (jstring)JNU_CallMethodByName(env,
1239                                              NULL,
1240                                              object,
1241                                              &quot;toString&quot;,
1242                                              &quot;()Ljava/lang/String;&quot;).l;
1243     }
1244 }
1245 
1246 JNIEXPORT jvalue JNICALL
1247 JNU_GetFieldByName(JNIEnv *env,
1248                    jboolean *hasException,
1249                    jobject obj,
1250                    const char *name,
1251                    const char *signature)
</pre>
<hr />
<pre>
1420         break;
1421     case &#39;F&#39;:
1422         result.f = (*env)-&gt;GetStaticFloatField(env, cls, fid);
1423         break;
1424     case &#39;D&#39;:
1425         result.d = (*env)-&gt;GetStaticDoubleField(env, cls, fid);
1426         break;
1427 
1428     default:
1429         (*env)-&gt;FatalError(env, &quot;JNU_GetStaticFieldByName: illegal signature&quot;);
1430     }
1431 
1432  done1:
1433     (*env)-&gt;DeleteLocalRef(env, cls);
1434  done2:
1435     if (hasException) {
1436         *hasException = (*env)-&gt;ExceptionCheck(env);
1437     }
1438     return result;
1439 }
<span class="line-removed">1440 </span>
<span class="line-removed">1441 JNIEXPORT void JNICALL</span>
<span class="line-removed">1442 JNU_SetStaticFieldByName(JNIEnv *env,</span>
<span class="line-removed">1443                          jboolean *hasException,</span>
<span class="line-removed">1444                          const char *classname,</span>
<span class="line-removed">1445                          const char *name,</span>
<span class="line-removed">1446                          const char *signature,</span>
<span class="line-removed">1447                          ...)</span>
<span class="line-removed">1448 {</span>
<span class="line-removed">1449     jclass cls;</span>
<span class="line-removed">1450     jfieldID fid;</span>
<span class="line-removed">1451     va_list args;</span>
<span class="line-removed">1452 </span>
<span class="line-removed">1453     if ((*env)-&gt;EnsureLocalCapacity(env, 3) &lt; 0)</span>
<span class="line-removed">1454         goto done2;</span>
<span class="line-removed">1455 </span>
<span class="line-removed">1456     cls = (*env)-&gt;FindClass(env, classname);</span>
<span class="line-removed">1457     if (cls == 0)</span>
<span class="line-removed">1458         goto done2;</span>
<span class="line-removed">1459 </span>
<span class="line-removed">1460     fid = (*env)-&gt;GetStaticFieldID(env, cls, name, signature);</span>
<span class="line-removed">1461     if (fid == 0)</span>
<span class="line-removed">1462         goto done1;</span>
<span class="line-removed">1463 </span>
<span class="line-removed">1464     va_start(args, signature);</span>
<span class="line-removed">1465     switch (*signature) {</span>
<span class="line-removed">1466     case &#39;[&#39;:</span>
<span class="line-removed">1467     case &#39;L&#39;:</span>
<span class="line-removed">1468         (*env)-&gt;SetStaticObjectField(env, cls, fid, va_arg(args, jobject));</span>
<span class="line-removed">1469         break;</span>
<span class="line-removed">1470     case &#39;Z&#39;:</span>
<span class="line-removed">1471         (*env)-&gt;SetStaticBooleanField(env, cls, fid, (jboolean)va_arg(args, int));</span>
<span class="line-removed">1472         break;</span>
<span class="line-removed">1473     case &#39;B&#39;:</span>
<span class="line-removed">1474         (*env)-&gt;SetStaticByteField(env, cls, fid, (jbyte)va_arg(args, int));</span>
<span class="line-removed">1475         break;</span>
<span class="line-removed">1476     case &#39;C&#39;:</span>
<span class="line-removed">1477         (*env)-&gt;SetStaticCharField(env, cls, fid, (jchar)va_arg(args, int));</span>
<span class="line-removed">1478         break;</span>
<span class="line-removed">1479     case &#39;S&#39;:</span>
<span class="line-removed">1480         (*env)-&gt;SetStaticShortField(env, cls, fid, (jshort)va_arg(args, int));</span>
<span class="line-removed">1481         break;</span>
<span class="line-removed">1482     case &#39;I&#39;:</span>
<span class="line-removed">1483         (*env)-&gt;SetStaticIntField(env, cls, fid, va_arg(args, jint));</span>
<span class="line-removed">1484         break;</span>
<span class="line-removed">1485     case &#39;J&#39;:</span>
<span class="line-removed">1486         (*env)-&gt;SetStaticLongField(env, cls, fid, va_arg(args, jlong));</span>
<span class="line-removed">1487         break;</span>
<span class="line-removed">1488     case &#39;F&#39;:</span>
<span class="line-removed">1489         (*env)-&gt;SetStaticFloatField(env, cls, fid, (jfloat)va_arg(args, jdouble));</span>
<span class="line-removed">1490         break;</span>
<span class="line-removed">1491     case &#39;D&#39;:</span>
<span class="line-removed">1492         (*env)-&gt;SetStaticDoubleField(env, cls, fid, va_arg(args, jdouble));</span>
<span class="line-removed">1493         break;</span>
<span class="line-removed">1494 </span>
<span class="line-removed">1495     default:</span>
<span class="line-removed">1496         (*env)-&gt;FatalError(env, &quot;JNU_SetStaticFieldByName: illegal signature&quot;);</span>
<span class="line-removed">1497     }</span>
<span class="line-removed">1498     va_end(args);</span>
<span class="line-removed">1499 </span>
<span class="line-removed">1500  done1:</span>
<span class="line-removed">1501     (*env)-&gt;DeleteLocalRef(env, cls);</span>
<span class="line-removed">1502  done2:</span>
<span class="line-removed">1503     if (hasException) {</span>
<span class="line-removed">1504         *hasException = (*env)-&gt;ExceptionCheck(env);</span>
<span class="line-removed">1505     }</span>
<span class="line-removed">1506 }</span>
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  59 }
  60 
  61 JNIEXPORT void JNICALL
  62 JNU_ThrowArrayIndexOutOfBoundsException(JNIEnv *env, const char *msg)
  63 {
  64     JNU_ThrowByName(env, &quot;java/lang/ArrayIndexOutOfBoundsException&quot;, msg);
  65 }
  66 
  67 JNIEXPORT void JNICALL
  68 JNU_ThrowOutOfMemoryError(JNIEnv *env, const char *msg)
  69 {
  70     JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;, msg);
  71 }
  72 
  73 JNIEXPORT void JNICALL
  74 JNU_ThrowIllegalArgumentException(JNIEnv *env, const char *msg)
  75 {
  76     JNU_ThrowByName(env, &quot;java/lang/IllegalArgumentException&quot;, msg);
  77 }
  78 












  79 JNIEXPORT void JNICALL
  80 JNU_ThrowInternalError(JNIEnv *env, const char *msg)
  81 {
  82     JNU_ThrowByName(env, &quot;java/lang/InternalError&quot;, msg);
  83 }
  84 












  85 JNIEXPORT void JNICALL
  86 JNU_ThrowClassNotFoundException(JNIEnv *env, const char *msg)
  87 {
  88     JNU_ThrowByName(env, &quot;java/lang/ClassNotFoundException&quot;, msg);
  89 }
  90 






  91 JNIEXPORT void JNICALL
  92 JNU_ThrowIOException(JNIEnv *env, const char *msg)
  93 {
  94     JNU_ThrowByName(env, &quot;java/io/IOException&quot;, msg);
  95 }
  96 
























  97 /*
  98  * Throw an exception by name, using the string returned by
  99  * getLastErrorString for the detail string. If the last-error
 100  * string is NULL, use the given default detail string.
 101  */
 102 JNIEXPORT void JNICALL
 103 JNU_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 104                              const char *defaultDetail)
 105 {
 106     char buf[256];
 107     size_t n = getLastErrorString(buf, sizeof(buf));
 108 
 109     if (n &gt; 0) {
 110         jstring s = JNU_NewStringPlatform(env, buf);
 111         if (s != NULL) {
 112             jobject x = JNU_NewObjectByName(env, name,
 113                                             &quot;(Ljava/lang/String;)V&quot;, s);
 114             if (x != NULL) {
 115                 (*env)-&gt;Throw(env, x);
 116             }
</pre>
<hr />
<pre>
 774             (*env)-&gt;DeleteLocalRef(env, enc);
 775         }
 776     } else {
 777         JNU_ThrowInternalError(env, &quot;platform encoding undefined&quot;);
 778         return;
 779     }
 780 
 781     /* Initialize method-id cache */
 782     String_getBytes_ID = (*env)-&gt;GetMethodID(env, strClazz,
 783                                              &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);
 784     CHECK_NULL(String_getBytes_ID);
 785     String_init_ID = (*env)-&gt;GetMethodID(env, strClazz,
 786                                          &quot;&lt;init&gt;&quot;, &quot;([BLjava/lang/String;)V&quot;);
 787     CHECK_NULL(String_init_ID);
 788     String_coder_ID = (*env)-&gt;GetFieldID(env, strClazz, &quot;coder&quot;, &quot;B&quot;);
 789     CHECK_NULL(String_coder_ID);
 790     String_value_ID = (*env)-&gt;GetFieldID(env, strClazz, &quot;value&quot;, &quot;[B&quot;);
 791     CHECK_NULL(String_value_ID);
 792 }
 793 






 794 JNIEXPORT jstring JNICALL
 795 JNU_NewStringPlatform(JNIEnv *env, const char *str)
 796 {
 797     if (fastEncoding == FAST_UTF_8)
 798         return newStringUTF8(env, str);
 799     if (fastEncoding == FAST_8859_1)
 800         return newString8859_1(env, str);
 801     if (fastEncoding == FAST_646_US)
 802         return newString646_US(env, str);
 803     if (fastEncoding == FAST_CP1252)
 804         return newStringCp1252(env, str);
 805     if (fastEncoding == NO_ENCODING_YET) {
 806         JNU_ThrowInternalError(env, &quot;platform encoding not initialized&quot;);
 807         return NULL;
 808     }
 809     return newStringJava(env, str);
 810 }
 811 
 812 JNIEXPORT const char *
 813 GetStringPlatformChars(JNIEnv *env, jstring jstr, jboolean *isCopy)
</pre>
<hr />
<pre>
 917         return getStringUTF8(env, jstr);
 918     if (fastEncoding == FAST_8859_1)
 919         return getString8859_1Chars(env, jstr);
 920     if (fastEncoding == FAST_646_US)
 921         return getString646_USChars(env, jstr);
 922     if (fastEncoding == FAST_CP1252)
 923         return getStringCp1252Chars(env, jstr);
 924     if (fastEncoding == NO_ENCODING_YET) {
 925         JNU_ThrowInternalError(env, &quot;platform encoding not initialized&quot;);
 926         return 0;
 927     } else
 928         return getStringBytes(env, jstr);
 929 }
 930 
 931 JNIEXPORT void JNICALL
 932 JNU_ReleaseStringPlatformChars(JNIEnv *env, jstring jstr, const char *str)
 933 {
 934     free((void *)str);
 935 }
 936 














 937 JNIEXPORT jclass JNICALL
 938 JNU_ClassString(JNIEnv *env)
 939 {
 940     static jclass cls = 0;
 941     if (cls == 0) {
 942         jclass c;
 943         if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
 944             return 0;
 945         c = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
 946         CHECK_NULL_RETURN(c, NULL);
 947         cls = (*env)-&gt;NewGlobalRef(env, c);
 948         (*env)-&gt;DeleteLocalRef(env, c);
 949     }
 950     return cls;
 951 }
 952 
















































 953 JNIEXPORT jint JNICALL
 954 JNU_CopyObjectArray(JNIEnv *env, jobjectArray dst, jobjectArray src,
 955                          jint count)
 956 {
 957     int i;
 958     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
 959         return -1;
 960     for (i=0; i&lt;count; i++) {
 961         jstring p = (*env)-&gt;GetObjectArrayElement(env, src, i);
 962         (*env)-&gt;SetObjectArrayElement(env, dst, i, p);
 963         (*env)-&gt;DeleteLocalRef(env, p);
 964     }
 965     return 0;
 966 }
 967 
 968 JNIEXPORT void * JNICALL
 969 JNU_GetEnv(JavaVM *vm, jint version)
 970 {
 971     void *env;
 972     (*vm)-&gt;GetEnv(vm, &amp;env, version);
 973     return env;
 974 }
 975 
 976 JNIEXPORT jint JNICALL
<span class="line-modified"> 977 JNU_IsInstanceOfByName(JNIEnv *env, jobject object, const char* classname)</span>
 978 {
 979     jclass cls;
 980     if ((*env)-&gt;EnsureLocalCapacity(env, 1) &lt; 0)
 981         return JNI_ERR;
 982     cls = (*env)-&gt;FindClass(env, classname);
 983     if (cls != NULL) {
 984         jint result = (*env)-&gt;IsInstanceOf(env, object, cls);
 985         (*env)-&gt;DeleteLocalRef(env, cls);
 986         return result;
 987     }
 988     return JNI_ERR;
 989 }
 990 




















































































 991 /************************************************************************
 992  * Debugging utilities
 993  */
 994 































 995 JNIEXPORT jstring JNICALL
 996 JNU_ToString(JNIEnv *env, jobject object)
 997 {
 998     if (object == NULL) {
 999         return (*env)-&gt;NewStringUTF(env, &quot;NULL&quot;);
1000     } else {
1001         return (jstring)JNU_CallMethodByName(env,
1002                                              NULL,
1003                                              object,
1004                                              &quot;toString&quot;,
1005                                              &quot;()Ljava/lang/String;&quot;).l;
1006     }
1007 }
1008 
1009 JNIEXPORT jvalue JNICALL
1010 JNU_GetFieldByName(JNIEnv *env,
1011                    jboolean *hasException,
1012                    jobject obj,
1013                    const char *name,
1014                    const char *signature)
</pre>
<hr />
<pre>
1183         break;
1184     case &#39;F&#39;:
1185         result.f = (*env)-&gt;GetStaticFloatField(env, cls, fid);
1186         break;
1187     case &#39;D&#39;:
1188         result.d = (*env)-&gt;GetStaticDoubleField(env, cls, fid);
1189         break;
1190 
1191     default:
1192         (*env)-&gt;FatalError(env, &quot;JNU_GetStaticFieldByName: illegal signature&quot;);
1193     }
1194 
1195  done1:
1196     (*env)-&gt;DeleteLocalRef(env, cls);
1197  done2:
1198     if (hasException) {
1199         *hasException = (*env)-&gt;ExceptionCheck(env);
1200     }
1201     return result;
1202 }



































































</pre>
</td>
</tr>
</table>
<center><a href="jdk_util.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jni_util.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/native/libzip/Deflater.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libverify/check_code.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Inflater.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/native/libzip/Deflater.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 59             free(strm);
 60             JNU_ThrowOutOfMemoryError(env, 0);
 61             return jlong_zero;
 62           case Z_STREAM_ERROR:
 63             free(strm);
 64             JNU_ThrowIllegalArgumentException(env, 0);
 65             return jlong_zero;
 66           default:
 67             msg = ((strm-&gt;msg != NULL) ? strm-&gt;msg :
 68                    (ret == Z_VERSION_ERROR) ?
 69                    &quot;zlib returned Z_VERSION_ERROR: &quot;
 70                    &quot;compile time and runtime zlib implementations differ&quot; :
 71                    &quot;unknown error initializing zlib library&quot;);
 72             free(strm);
 73             JNU_ThrowInternalError(env, msg);
 74             return jlong_zero;
 75         }
 76     }
 77 }
 78 
<span class="line-modified"> 79 static void doSetDictionary(JNIEnv *env, jlong addr, jbyte *buf, jint len)</span>
 80 {
<span class="line-removed"> 81     int res = deflateSetDictionary(jlong_to_ptr(addr), (Bytef *) buf, len);</span>
 82     switch (res) {
 83     case Z_OK:
 84         break;
 85     case Z_STREAM_ERROR:
 86         JNU_ThrowIllegalArgumentException(env, 0);
 87         break;
 88     default:
 89         JNU_ThrowInternalError(env, ((z_stream *)jlong_to_ptr(addr))-&gt;msg);
 90         break;
 91     }
 92 }
 93 
 94 JNIEXPORT void JNICALL
 95 Java_java_util_zip_Deflater_setDictionary(JNIEnv *env, jclass cls, jlong addr,
 96                                           jbyteArray b, jint off, jint len)
 97 {
<span class="line-modified"> 98     jbyte *buf = (*env)-&gt;GetPrimitiveArrayCritical(env, b, 0);</span>

 99     if (buf == NULL) /* out of memory */
100         return;
<span class="line-modified">101     doSetDictionary(env, addr, buf + off, len);</span>
102     (*env)-&gt;ReleasePrimitiveArrayCritical(env, b, buf, 0);

103 }
104 
105 JNIEXPORT void JNICALL
106 Java_java_util_zip_Deflater_setDictionaryBuffer(JNIEnv *env, jclass cls, jlong addr,
107                                           jlong bufferAddr, jint len)
108 {
<span class="line-modified">109     jbyte *buf = jlong_to_ptr(bufferAddr);</span>
<span class="line-modified">110     doSetDictionary(env, addr, buf, len);</span>


111 }
112 
<span class="line-modified">113 static jlong doDeflate(JNIEnv *env, jobject this, jlong addr,</span>
114                        jbyte *input, jint inputLen,
115                        jbyte *output, jint outputLen,
116                        jint flush, jint params)
117 {
118     z_stream *strm = jlong_to_ptr(addr);
<span class="line-removed">119     jint inputUsed = 0, outputUsed = 0;</span>
<span class="line-removed">120     int finished = 0;</span>
121     int setParams = params &amp; 1;

122 
123     strm-&gt;next_in  = (Bytef *) input;
124     strm-&gt;next_out = (Bytef *) output;
125     strm-&gt;avail_in  = inputLen;
126     strm-&gt;avail_out = outputLen;
127 
128     if (setParams) {
129         int strategy = (params &gt;&gt; 1) &amp; 3;
130         int level = params &gt;&gt; 3;
<span class="line-modified">131         int res = deflateParams(strm, level, strategy);</span>

















132         switch (res) {
133         case Z_OK:
134             setParams = 0;
135             /* fall through */
136         case Z_BUF_ERROR:
137             inputUsed = inputLen - strm-&gt;avail_in;
138             outputUsed = outputLen - strm-&gt;avail_out;
139             break;
140         default:
141             JNU_ThrowInternalError(env, strm-&gt;msg);
142             return 0;
143         }
144     } else {
<span class="line-removed">145         int res = deflate(strm, flush);</span>
146         switch (res) {
147         case Z_STREAM_END:
148             finished = 1;
149             /* fall through */
150         case Z_OK:
151         case Z_BUF_ERROR:
152             inputUsed = inputLen - strm-&gt;avail_in;
153             outputUsed = outputLen - strm-&gt;avail_out;
154             break;
155         default:
156             JNU_ThrowInternalError(env, strm-&gt;msg);
157             return 0;
158         }
159     }
160     return ((jlong)inputUsed) | (((jlong)outputUsed) &lt;&lt; 31) | (((jlong)finished) &lt;&lt; 62) | (((jlong)setParams) &lt;&lt; 63);
161 }
162 
163 JNIEXPORT jlong JNICALL
164 Java_java_util_zip_Deflater_deflateBytesBytes(JNIEnv *env, jobject this, jlong addr,
165                                          jbyteArray inputArray, jint inputOff, jint inputLen,
166                                          jbyteArray outputArray, jint outputOff, jint outputLen,
167                                          jint flush, jint params)
168 {
169     jbyte *input = (*env)-&gt;GetPrimitiveArrayCritical(env, inputArray, 0);
170     jbyte *output;
171     jlong retVal;


172     if (input == NULL) {
173         if (inputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
174             JNU_ThrowOutOfMemoryError(env, 0);
175         return 0L;
176     }
177     output = (*env)-&gt;GetPrimitiveArrayCritical(env, outputArray, 0);
178     if (output == NULL) {
179         (*env)-&gt;ReleasePrimitiveArrayCritical(env, inputArray, input, 0);
180         if (outputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
181             JNU_ThrowOutOfMemoryError(env, 0);
182         return 0L;
183     }
184 
<span class="line-modified">185     retVal = doDeflate(env, this, addr,</span>
<span class="line-modified">186             input + inputOff, inputLen,</span>
<span class="line-removed">187             output + outputOff, outputLen,</span>
<span class="line-removed">188             flush, params);</span>
189 
190     (*env)-&gt;ReleasePrimitiveArrayCritical(env, outputArray, output, 0);
191     (*env)-&gt;ReleasePrimitiveArrayCritical(env, inputArray, input, 0);
192 

193     return retVal;
194 }
195 
196 
197 JNIEXPORT jlong JNICALL
198 Java_java_util_zip_Deflater_deflateBytesBuffer(JNIEnv *env, jobject this, jlong addr,
199                                          jbyteArray inputArray, jint inputOff, jint inputLen,
200                                          jlong outputBuffer, jint outputLen,
201                                          jint flush, jint params)
202 {
203     jbyte *input = (*env)-&gt;GetPrimitiveArrayCritical(env, inputArray, 0);
204     jbyte *output;
205     jlong retVal;

206     if (input == NULL) {
207         if (inputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
208             JNU_ThrowOutOfMemoryError(env, 0);
209         return 0L;
210     }
211     output = jlong_to_ptr(outputBuffer);
212 
<span class="line-modified">213     retVal = doDeflate(env, this, addr,</span>
<span class="line-modified">214             input + inputOff, inputLen,</span>
<span class="line-removed">215             output, outputLen,</span>
<span class="line-removed">216             flush, params);</span>
217 
218     (*env)-&gt;ReleasePrimitiveArrayCritical(env, inputArray, input, 0);
219 

220     return retVal;
221 }
222 
223 JNIEXPORT jlong JNICALL
224 Java_java_util_zip_Deflater_deflateBufferBytes(JNIEnv *env, jobject this, jlong addr,
225                                          jlong inputBuffer, jint inputLen,
226                                          jbyteArray outputArray, jint outputOff, jint outputLen,
227                                          jint flush, jint params)
228 {
229     jbyte *input = jlong_to_ptr(inputBuffer);
230     jbyte *output = (*env)-&gt;GetPrimitiveArrayCritical(env, outputArray, 0);
231     jlong retVal;

232     if (output == NULL) {
233         if (outputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
234             JNU_ThrowOutOfMemoryError(env, 0);
235         return 0L;
236     }
237 
<span class="line-modified">238     retVal = doDeflate(env, this, addr,</span>
<span class="line-modified">239             input, inputLen,</span>
<span class="line-modified">240             output + outputOff, outputLen,</span>
<span class="line-removed">241             flush, params);</span>
<span class="line-removed">242 </span>
<span class="line-removed">243     (*env)-&gt;ReleasePrimitiveArrayCritical(env, outputArray, input, 0);</span>
244 

245     return retVal;
246 }
247 
248 JNIEXPORT jlong JNICALL
249 Java_java_util_zip_Deflater_deflateBufferBuffer(JNIEnv *env, jobject this, jlong addr,
250                                          jlong inputBuffer, jint inputLen,
251                                          jlong outputBuffer, jint outputLen,
252                                          jint flush, jint params)
253 {
254     jbyte *input = jlong_to_ptr(inputBuffer);
255     jbyte *output = jlong_to_ptr(outputBuffer);


256 
<span class="line-modified">257     return doDeflate(env, this, addr,</span>
<span class="line-modified">258             input, inputLen,</span>
<span class="line-modified">259             output, outputLen,</span>
<span class="line-removed">260             flush, params);</span>
261 }
262 
263 JNIEXPORT jint JNICALL
264 Java_java_util_zip_Deflater_getAdler(JNIEnv *env, jclass cls, jlong addr)
265 {
266     return ((z_stream *)jlong_to_ptr(addr))-&gt;adler;
267 }
268 
269 JNIEXPORT void JNICALL
270 Java_java_util_zip_Deflater_reset(JNIEnv *env, jclass cls, jlong addr)
271 {
272     if (deflateReset((z_stream *)jlong_to_ptr(addr)) != Z_OK) {
273         JNU_ThrowInternalError(env, 0);
274     }
275 }
276 
277 JNIEXPORT void JNICALL
278 Java_java_util_zip_Deflater_end(JNIEnv *env, jclass cls, jlong addr)
279 {
280     if (deflateEnd((z_stream *)jlong_to_ptr(addr)) == Z_STREAM_ERROR) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 59             free(strm);
 60             JNU_ThrowOutOfMemoryError(env, 0);
 61             return jlong_zero;
 62           case Z_STREAM_ERROR:
 63             free(strm);
 64             JNU_ThrowIllegalArgumentException(env, 0);
 65             return jlong_zero;
 66           default:
 67             msg = ((strm-&gt;msg != NULL) ? strm-&gt;msg :
 68                    (ret == Z_VERSION_ERROR) ?
 69                    &quot;zlib returned Z_VERSION_ERROR: &quot;
 70                    &quot;compile time and runtime zlib implementations differ&quot; :
 71                    &quot;unknown error initializing zlib library&quot;);
 72             free(strm);
 73             JNU_ThrowInternalError(env, msg);
 74             return jlong_zero;
 75         }
 76     }
 77 }
 78 
<span class="line-modified"> 79 static void checkSetDictionaryResult(JNIEnv *env, jlong addr, jint res)</span>
 80 {

 81     switch (res) {
 82     case Z_OK:
 83         break;
 84     case Z_STREAM_ERROR:
 85         JNU_ThrowIllegalArgumentException(env, 0);
 86         break;
 87     default:
 88         JNU_ThrowInternalError(env, ((z_stream *)jlong_to_ptr(addr))-&gt;msg);
 89         break;
 90     }
 91 }
 92 
 93 JNIEXPORT void JNICALL
 94 Java_java_util_zip_Deflater_setDictionary(JNIEnv *env, jclass cls, jlong addr,
 95                                           jbyteArray b, jint off, jint len)
 96 {
<span class="line-modified"> 97     int res;</span>
<span class="line-added"> 98     Bytef *buf = (*env)-&gt;GetPrimitiveArrayCritical(env, b, 0);</span>
 99     if (buf == NULL) /* out of memory */
100         return;
<span class="line-modified">101     res = deflateSetDictionary(jlong_to_ptr(addr), buf, len);</span>
102     (*env)-&gt;ReleasePrimitiveArrayCritical(env, b, buf, 0);
<span class="line-added">103     checkSetDictionaryResult(env, addr, res);</span>
104 }
105 
106 JNIEXPORT void JNICALL
107 Java_java_util_zip_Deflater_setDictionaryBuffer(JNIEnv *env, jclass cls, jlong addr,
108                                           jlong bufferAddr, jint len)
109 {
<span class="line-modified">110     int res;</span>
<span class="line-modified">111     Bytef *buf = jlong_to_ptr(bufferAddr);</span>
<span class="line-added">112     res = deflateSetDictionary(jlong_to_ptr(addr), buf, len);</span>
<span class="line-added">113     checkSetDictionaryResult(env, addr, res);</span>
114 }
115 
<span class="line-modified">116 static jint doDeflate(JNIEnv *env, jlong addr,</span>
117                        jbyte *input, jint inputLen,
118                        jbyte *output, jint outputLen,
119                        jint flush, jint params)
120 {
121     z_stream *strm = jlong_to_ptr(addr);


122     int setParams = params &amp; 1;
<span class="line-added">123     int res;</span>
124 
125     strm-&gt;next_in  = (Bytef *) input;
126     strm-&gt;next_out = (Bytef *) output;
127     strm-&gt;avail_in  = inputLen;
128     strm-&gt;avail_out = outputLen;
129 
130     if (setParams) {
131         int strategy = (params &gt;&gt; 1) &amp; 3;
132         int level = params &gt;&gt; 3;
<span class="line-modified">133         res = deflateParams(strm, level, strategy);</span>
<span class="line-added">134     } else {</span>
<span class="line-added">135         res = deflate(strm, flush);</span>
<span class="line-added">136     }</span>
<span class="line-added">137     return res;</span>
<span class="line-added">138 }</span>
<span class="line-added">139 </span>
<span class="line-added">140 static jlong checkDeflateStatus(JNIEnv *env, jlong addr,</span>
<span class="line-added">141                         jint inputLen,</span>
<span class="line-added">142                         jint outputLen,</span>
<span class="line-added">143                         jint params, int res)</span>
<span class="line-added">144 {</span>
<span class="line-added">145     z_stream *strm = jlong_to_ptr(addr);</span>
<span class="line-added">146     jint inputUsed = 0, outputUsed = 0;</span>
<span class="line-added">147     int finished = 0;</span>
<span class="line-added">148     int setParams = params &amp; 1;</span>
<span class="line-added">149 </span>
<span class="line-added">150     if (setParams) {</span>
151         switch (res) {
152         case Z_OK:
153             setParams = 0;
154             /* fall through */
155         case Z_BUF_ERROR:
156             inputUsed = inputLen - strm-&gt;avail_in;
157             outputUsed = outputLen - strm-&gt;avail_out;
158             break;
159         default:
160             JNU_ThrowInternalError(env, strm-&gt;msg);
161             return 0;
162         }
163     } else {

164         switch (res) {
165         case Z_STREAM_END:
166             finished = 1;
167             /* fall through */
168         case Z_OK:
169         case Z_BUF_ERROR:
170             inputUsed = inputLen - strm-&gt;avail_in;
171             outputUsed = outputLen - strm-&gt;avail_out;
172             break;
173         default:
174             JNU_ThrowInternalError(env, strm-&gt;msg);
175             return 0;
176         }
177     }
178     return ((jlong)inputUsed) | (((jlong)outputUsed) &lt;&lt; 31) | (((jlong)finished) &lt;&lt; 62) | (((jlong)setParams) &lt;&lt; 63);
179 }
180 
181 JNIEXPORT jlong JNICALL
182 Java_java_util_zip_Deflater_deflateBytesBytes(JNIEnv *env, jobject this, jlong addr,
183                                          jbyteArray inputArray, jint inputOff, jint inputLen,
184                                          jbyteArray outputArray, jint outputOff, jint outputLen,
185                                          jint flush, jint params)
186 {
187     jbyte *input = (*env)-&gt;GetPrimitiveArrayCritical(env, inputArray, 0);
188     jbyte *output;
189     jlong retVal;
<span class="line-added">190     jint res;</span>
<span class="line-added">191 </span>
192     if (input == NULL) {
193         if (inputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
194             JNU_ThrowOutOfMemoryError(env, 0);
195         return 0L;
196     }
197     output = (*env)-&gt;GetPrimitiveArrayCritical(env, outputArray, 0);
198     if (output == NULL) {
199         (*env)-&gt;ReleasePrimitiveArrayCritical(env, inputArray, input, 0);
200         if (outputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
201             JNU_ThrowOutOfMemoryError(env, 0);
202         return 0L;
203     }
204 
<span class="line-modified">205      res = doDeflate(env, addr, input + inputOff, inputLen,output + outputOff,</span>
<span class="line-modified">206                      outputLen, flush, params);</span>


207 
208     (*env)-&gt;ReleasePrimitiveArrayCritical(env, outputArray, output, 0);
209     (*env)-&gt;ReleasePrimitiveArrayCritical(env, inputArray, input, 0);
210 
<span class="line-added">211     retVal = checkDeflateStatus(env, addr, inputLen, outputLen, params, res);</span>
212     return retVal;
213 }
214 
215 
216 JNIEXPORT jlong JNICALL
217 Java_java_util_zip_Deflater_deflateBytesBuffer(JNIEnv *env, jobject this, jlong addr,
218                                          jbyteArray inputArray, jint inputOff, jint inputLen,
219                                          jlong outputBuffer, jint outputLen,
220                                          jint flush, jint params)
221 {
222     jbyte *input = (*env)-&gt;GetPrimitiveArrayCritical(env, inputArray, 0);
223     jbyte *output;
224     jlong retVal;
<span class="line-added">225     jint res;</span>
226     if (input == NULL) {
227         if (inputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
228             JNU_ThrowOutOfMemoryError(env, 0);
229         return 0L;
230     }
231     output = jlong_to_ptr(outputBuffer);
232 
<span class="line-modified">233     res = doDeflate(env, addr, input + inputOff, inputLen, output, outputLen,</span>
<span class="line-modified">234                     flush, params);</span>


235 
236     (*env)-&gt;ReleasePrimitiveArrayCritical(env, inputArray, input, 0);
237 
<span class="line-added">238     retVal = checkDeflateStatus(env, addr, inputLen, outputLen, params, res);</span>
239     return retVal;
240 }
241 
242 JNIEXPORT jlong JNICALL
243 Java_java_util_zip_Deflater_deflateBufferBytes(JNIEnv *env, jobject this, jlong addr,
244                                          jlong inputBuffer, jint inputLen,
245                                          jbyteArray outputArray, jint outputOff, jint outputLen,
246                                          jint flush, jint params)
247 {
248     jbyte *input = jlong_to_ptr(inputBuffer);
249     jbyte *output = (*env)-&gt;GetPrimitiveArrayCritical(env, outputArray, 0);
250     jlong retVal;
<span class="line-added">251     jint res;</span>
252     if (output == NULL) {
253         if (outputLen != 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env) == NULL)
254             JNU_ThrowOutOfMemoryError(env, 0);
255         return 0L;
256     }
257 
<span class="line-modified">258     res = doDeflate(env, addr, input, inputLen, output + outputOff, outputLen,</span>
<span class="line-modified">259                     flush, params);</span>
<span class="line-modified">260     (*env)-&gt;ReleasePrimitiveArrayCritical(env, outputArray, output, 0);</span>



261 
<span class="line-added">262     retVal = checkDeflateStatus(env, addr, inputLen, outputLen, params, res);</span>
263     return retVal;
264 }
265 
266 JNIEXPORT jlong JNICALL
267 Java_java_util_zip_Deflater_deflateBufferBuffer(JNIEnv *env, jobject this, jlong addr,
268                                          jlong inputBuffer, jint inputLen,
269                                          jlong outputBuffer, jint outputLen,
270                                          jint flush, jint params)
271 {
272     jbyte *input = jlong_to_ptr(inputBuffer);
273     jbyte *output = jlong_to_ptr(outputBuffer);
<span class="line-added">274     jlong retVal;</span>
<span class="line-added">275     jint res;</span>
276 
<span class="line-modified">277     res = doDeflate(env, addr, input, inputLen, output, outputLen, flush, params);</span>
<span class="line-modified">278     retVal = checkDeflateStatus(env, addr, inputLen, outputLen, params, res);</span>
<span class="line-modified">279     return retVal;</span>

280 }
281 
282 JNIEXPORT jint JNICALL
283 Java_java_util_zip_Deflater_getAdler(JNIEnv *env, jclass cls, jlong addr)
284 {
285     return ((z_stream *)jlong_to_ptr(addr))-&gt;adler;
286 }
287 
288 JNIEXPORT void JNICALL
289 Java_java_util_zip_Deflater_reset(JNIEnv *env, jclass cls, jlong addr)
290 {
291     if (deflateReset((z_stream *)jlong_to_ptr(addr)) != Z_OK) {
292         JNU_ThrowInternalError(env, 0);
293     }
294 }
295 
296 JNIEXPORT void JNICALL
297 Java_java_util_zip_Deflater_end(JNIEnv *env, jclass cls, jlong addr)
298 {
299     if (deflateEnd((z_stream *)jlong_to_ptr(addr)) == Z_STREAM_ERROR) {
</pre>
</td>
</tr>
</table>
<center><a href="../libverify/check_code.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Inflater.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
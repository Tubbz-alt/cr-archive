<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classes/sun/security/mscapi/CSignature.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/Config.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 485                 PP(&quot;bHasNoPrivateKey = TRUE!&quot;);
 486                 bHasNoPrivateKey = TRUE;
 487             }
 488             else
 489             {
 490                 if (bCallerFreeProv == TRUE) {
 491                     ::CryptReleaseContext(hCryptProv, NULL); // deprecated
 492                     bCallerFreeProv = FALSE;
 493                 }
 494 
 495                 // Second, acquire the key normally (not silently)
 496                 if (::CryptAcquireCertificatePrivateKey(pCertContext, CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG, NULL,
 497                         &amp;hCryptProv, &amp;dwKeySpec, &amp;bCallerFreeProv) == FALSE)
 498                 {
 499                     PP(&quot;bHasNoPrivateKey = TRUE!!&quot;);
 500                     bHasNoPrivateKey = TRUE;
 501                 }
 502                 else
 503                 {
 504                     if ((dwKeySpec &amp; CERT_NCRYPT_KEY_SPEC) == CERT_NCRYPT_KEY_SPEC) {
<span class="line-modified"> 505                         PP(&quot;CNG %I64d&quot;, hCryptProv);</span>
 506                     } else {
 507                         // Private key is available
 508                         BOOL bGetUserKey = ::CryptGetUserKey(hCryptProv, dwKeySpec, &amp;hUserKey); //deprecated
 509 
 510                         // Skip certificate if cannot find private key
 511                         if (bGetUserKey == FALSE) {
 512                             if (bCallerFreeProv)
 513                                 ::CryptReleaseContext(hCryptProv, NULL); // deprecated
 514                             continue;
 515                         }
 516 
 517                         // Set cipher mode to ECB
 518                         DWORD dwCipherMode = CRYPT_MODE_ECB;
 519                         ::CryptSetKeyParam(hUserKey, KP_MODE, (BYTE*)&amp;dwCipherMode, NULL); //deprecated
<span class="line-modified"> 520                         PP(&quot;CAPI %I64d %I64d&quot;, hCryptProv, hUserKey);</span>
 521                     }
 522                     // If the private key is present in smart card, we may not be able to
 523                     // determine the key length by using the private key handle. However,
 524                     // since public/private key pairs must have the same length, we could
 525                     // determine the key length of the private key by using the public key
 526                     // in the certificate.
 527                     dwPublicKeyLength = ::CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
 528                             &amp;(pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo));
 529                 }
 530             }
 531             PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
 532 
 533             // Build certificate chain by using system certificate store.
 534             // Add cert chain into collection for any key usage.
 535             //
 536             if (GetCertificateChain(OID_EKU_ANY, pCertContext, &amp;pCertChainContext))
 537             {
 538                 for (DWORD i = 0; i &lt; pCertChainContext-&gt;cChain; i++)
 539                 {
 540                     // Found cert chain
</pre>
<hr />
<pre>
 632                                 {
 633                                     // Generate RSA certificate chain and store into cert
 634                                     // chain collection
 635                                     jstring name = env-&gt;NewStringUTF(pszNameString);
 636                                     if (name == NULL) {
 637                                         __leave;
 638                                     }
 639                                     env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
 640                                             1,
 641                                             name,
 642                                             (jlong) hCryptProv, (jlong) hUserKey,
 643                                             dwPublicKeyLength, jArrayList);
 644                                 }
 645                             } else {
 646                                 // Only accept EC for CNG
 647                                 BYTE buffer[32];
 648                                 DWORD len = 0;
 649                                 if (::NCryptGetProperty(
 650                                         hCryptProv, NCRYPT_ALGORITHM_PROPERTY,
 651                                         (PBYTE)buffer, 32, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {




 652                                     if (buffer[0] == &#39;E&#39; &amp;&amp; buffer[2] == &#39;C&#39;
 653                                             &amp;&amp; (dwPublicKeyLength == 256
 654                                                     || dwPublicKeyLength == 384
 655                                                     || dwPublicKeyLength == 521)) {
<span class="line-removed"> 656                                         jstring name = env-&gt;NewStringUTF(pszNameString);</span>
<span class="line-removed"> 657                                         if (name == NULL) {</span>
<span class="line-removed"> 658                                             __leave;</span>
<span class="line-removed"> 659                                         }</span>
 660                                         env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
 661                                             0,
 662                                             name,
<span class="line-modified"> 663                                             (jlong) hCryptProv, 0,</span>
 664                                             dwPublicKeyLength, jArrayList);









 665                                     }
 666                                 }
 667                             }
 668                         }
 669                     }
 670                 }
 671 
 672                 // Free cert chain
 673                 if (pCertChainContext)
 674                     ::CertFreeCertificateChain(pCertChainContext);
 675             } else {
 676                 PP(&quot;GetCertificateChain failed %d&quot;, GetLastError());
 677             }
 678         }
 679     }
 680     __finally
 681     {
 682         if (hCertStore)
 683             ::CertCloseStore(hCertStore, 0);
 684 
 685         if (pszCertStoreName)
 686             env-&gt;ReleaseStringUTFChars(jCertStoreName, pszCertStoreName);
 687 
 688         if (pszNameString)
 689             delete [] pszNameString;
 690     }
 691 }
 692 
 693 
 694 /*
<span class="line-modified"> 695  * Class:     sun_security_mscapi_Key</span>
 696  * Method:    cleanUp
 697  * Signature: (JJ)V
 698  */
<span class="line-modified"> 699 JNIEXPORT void JNICALL Java_sun_security_mscapi_Key_cleanUp</span>
 700   (JNIEnv *env, jclass clazz, jlong hCryptProv, jlong hCryptKey)
 701 {
<span class="line-modified"> 702     if (hCryptKey != NULL)</span>
<span class="line-modified"> 703         ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated</span>
<span class="line-modified"> 704 </span>
<span class="line-modified"> 705     if (hCryptProv != NULL)</span>
<span class="line-modified"> 706         ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated</span>




 707 }
 708 
 709 /*
 710  * Class:     sun_security_mscapi_CSignature
 711  * Method:    signHash
 712  * Signature: (Z[BILjava/lang/String;JJ)[B
 713  */
 714 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_signHash
 715   (JNIEnv *env, jclass clazz, jboolean noHashOID, jbyteArray jHash,
 716         jint jHashSize, jstring jHashAlgorithm, jlong hCryptProv,
 717         jlong hCryptKey)
 718 {
 719     HCRYPTHASH hHash = NULL;
 720     jbyte* pHashBuffer = NULL;
 721     jbyte* pSignedHashBuffer = NULL;
 722     jbyteArray jSignedHash = NULL;
 723     HCRYPTPROV hCryptProvAlt = NULL;
 724 
 725     __try
 726     {
</pre>
<hr />
<pre>
 846  */
 847 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_signCngHash
 848   (JNIEnv *env, jclass clazz, jint type, jbyteArray jHash,
 849         jint jHashSize, jint saltLen, jstring jHashAlgorithm, jlong hCryptProv,
 850         jlong hCryptKey)
 851 {
 852     jbyteArray jSignedHash = NULL;
 853 
 854     jbyte* pHashBuffer = NULL;
 855     jbyte* pSignedHashBuffer = NULL;
 856     NCRYPT_KEY_HANDLE hk = NULL;
 857 
 858     __try
 859     {
 860         if (hCryptKey == 0) {
 861             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
 862         } else {
 863             SS_CHECK(::NCryptTranslateHandle(
 864                 NULL,
 865                 &amp;hk,
<span class="line-modified"> 866                 hCryptProv,</span>
<span class="line-modified"> 867                 hCryptKey,</span>
 868                 NULL,
 869                 0));
 870         }
 871 
 872         // Copy hash from Java to native buffer
 873         pHashBuffer = new (env) jbyte[jHashSize];
 874         if (pHashBuffer == NULL) {
 875             __leave;
 876         }
 877         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
 878 
 879         VOID* param;
 880         DWORD dwFlags;
 881 
 882         switch (type) {
 883         case 0:
 884             param = NULL;
 885             dwFlags = 0;
 886             break;
 887         case 1:
 888             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified"> 889             pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified"> 890             if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified"> 891                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified"> 892                         &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-modified"> 893                 __leave;</span>




 894             }
 895             param = &amp;pkcs1Info;
 896             dwFlags = BCRYPT_PAD_PKCS1;
 897             break;
 898         case 2:
 899             BCRYPT_PSS_PADDING_INFO pssInfo;
 900             pssInfo.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
 901             pssInfo.cbSalt = saltLen;
 902             if (pssInfo.pszAlgId == NULL) {
 903                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
 904                         &quot;Unrecognised hash algorithm&quot;);
 905                 __leave;
 906             }
 907             param = &amp;pssInfo;
 908             dwFlags = BCRYPT_PAD_PSS;
 909             break;
 910         }
 911 
 912         DWORD jSignedHashSize = 0;
 913         SS_CHECK(::NCryptSignHash(
</pre>
<hr />
<pre>
1070 JNIEXPORT jboolean JNICALL Java_sun_security_mscapi_CSignature_verifyCngSignedHash
1071   (JNIEnv *env, jclass clazz, jint type,
1072         jbyteArray jHash, jint jHashSize,
1073         jbyteArray jSignedHash, jint jSignedHashSize,
1074         jint saltLen, jstring jHashAlgorithm,
1075         jlong hCryptProv, jlong hCryptKey)
1076 {
1077     jbyte* pHashBuffer = NULL;
1078     jbyte* pSignedHashBuffer = NULL;
1079     jboolean result = JNI_FALSE;
1080     NCRYPT_KEY_HANDLE hk = NULL;
1081 
1082     __try
1083     {
1084         if (hCryptKey == 0) {
1085             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
1086         } else {
1087             SS_CHECK(::NCryptTranslateHandle(
1088                 NULL,
1089                 &amp;hk,
<span class="line-modified">1090                 hCryptProv,</span>
<span class="line-modified">1091                 hCryptKey,</span>
1092                 NULL,
1093                 0));
1094         }
1095 
1096         // Copy hash and signedHash from Java to native buffer
1097         pHashBuffer = new (env) jbyte[jHashSize];
1098         if (pHashBuffer == NULL) {
1099             __leave;
1100         }
1101         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
1102 
1103         pSignedHashBuffer = new (env) jbyte[jSignedHashSize];
1104         if (pSignedHashBuffer == NULL) {
1105             __leave;
1106         }
1107         env-&gt;GetByteArrayRegion(jSignedHash, 0, jSignedHashSize,
1108             pSignedHashBuffer);
1109 
1110         VOID* param;
1111         DWORD dwFlags;
1112 
1113         switch (type) {
1114         case 0:
1115             param = NULL;
1116             dwFlags = 0;
1117             break;
1118         case 1:
1119             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified">1120             pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified">1121             if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified">1122                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified">1123                         &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-modified">1124                 __leave;</span>




1125             }
1126             param = &amp;pkcs1Info;
1127             dwFlags = NCRYPT_PAD_PKCS1_FLAG;
1128             break;
1129         case 2:
1130             BCRYPT_PSS_PADDING_INFO pssInfo;
1131             pssInfo.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
1132             pssInfo.cbSalt = saltLen;
1133             if (pssInfo.pszAlgId == NULL) {
1134                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
1135                         &quot;Unrecognised hash algorithm&quot;);
1136                 __leave;
1137             }
1138             param = &amp;pssInfo;
1139             dwFlags = NCRYPT_PAD_PSS_FLAG;
1140             break;
1141         }
1142 
1143         if (::NCryptVerifySignature(hk, param,
1144                 (BYTE *) pHashBuffer, jHashSize,
</pre>
<hr />
<pre>
1903 }
1904 
1905 /*
1906  * Class:     sun_security_mscapi_CPublicKey
1907  * Method:    getPublicKeyBlob
1908  * Signature: (JJ)[B
1909  */
1910 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CPublicKey_getPublicKeyBlob
1911     (JNIEnv *env, jobject clazz, jlong hCryptProv, jlong hCryptKey) {
1912 
1913     jbyteArray blob = NULL;
1914     DWORD dwBlobLen;
1915     BYTE* pbKeyBlob = NULL;
1916 
1917     __try
1918     {
1919 
1920         // Determine the size of the blob
1921         if (hCryptKey == 0) {
1922             SS_CHECK(::NCryptExportKey(
<span class="line-modified">1923                 hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
1924                 NULL, NULL, 0, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
1925         } else {
1926             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, NULL, //deprecated
1927                 &amp;dwBlobLen)) {
1928 
1929                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1930                 __leave;
1931             }
1932         }
1933 
1934         pbKeyBlob = new (env) BYTE[dwBlobLen];
1935         if (pbKeyBlob == NULL) {
1936             __leave;
1937         }
1938 
1939         // Generate key blob
1940         if (hCryptKey == 0) {
1941             SS_CHECK(::NCryptExportKey(
<span class="line-modified">1942                 hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
1943                 NULL, pbKeyBlob, dwBlobLen, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
1944         } else {
1945             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, //deprecated
1946                 pbKeyBlob, &amp;dwBlobLen)) {
1947 
1948                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1949                 __leave;
1950             }
1951         }
1952 
1953         // Create new byte array
1954         if ((blob = env-&gt;NewByteArray(dwBlobLen)) == NULL) {
1955             __leave;
1956         }
1957 
1958         // Copy data from native buffer to Java buffer
1959         env-&gt;SetByteArrayRegion(blob, 0, dwBlobLen, (jbyte*) pbKeyBlob);
1960     }
1961     __finally
1962     {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 485                 PP(&quot;bHasNoPrivateKey = TRUE!&quot;);
 486                 bHasNoPrivateKey = TRUE;
 487             }
 488             else
 489             {
 490                 if (bCallerFreeProv == TRUE) {
 491                     ::CryptReleaseContext(hCryptProv, NULL); // deprecated
 492                     bCallerFreeProv = FALSE;
 493                 }
 494 
 495                 // Second, acquire the key normally (not silently)
 496                 if (::CryptAcquireCertificatePrivateKey(pCertContext, CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG, NULL,
 497                         &amp;hCryptProv, &amp;dwKeySpec, &amp;bCallerFreeProv) == FALSE)
 498                 {
 499                     PP(&quot;bHasNoPrivateKey = TRUE!!&quot;);
 500                     bHasNoPrivateKey = TRUE;
 501                 }
 502                 else
 503                 {
 504                     if ((dwKeySpec &amp; CERT_NCRYPT_KEY_SPEC) == CERT_NCRYPT_KEY_SPEC) {
<span class="line-modified"> 505                         PP(&quot;CNG %I64d&quot;, (__int64)hCryptProv);</span>
 506                     } else {
 507                         // Private key is available
 508                         BOOL bGetUserKey = ::CryptGetUserKey(hCryptProv, dwKeySpec, &amp;hUserKey); //deprecated
 509 
 510                         // Skip certificate if cannot find private key
 511                         if (bGetUserKey == FALSE) {
 512                             if (bCallerFreeProv)
 513                                 ::CryptReleaseContext(hCryptProv, NULL); // deprecated
 514                             continue;
 515                         }
 516 
 517                         // Set cipher mode to ECB
 518                         DWORD dwCipherMode = CRYPT_MODE_ECB;
 519                         ::CryptSetKeyParam(hUserKey, KP_MODE, (BYTE*)&amp;dwCipherMode, NULL); //deprecated
<span class="line-modified"> 520                         PP(&quot;CAPI %I64d %I64d&quot;, (__int64)hCryptProv, (__int64)hUserKey);</span>
 521                     }
 522                     // If the private key is present in smart card, we may not be able to
 523                     // determine the key length by using the private key handle. However,
 524                     // since public/private key pairs must have the same length, we could
 525                     // determine the key length of the private key by using the public key
 526                     // in the certificate.
 527                     dwPublicKeyLength = ::CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
 528                             &amp;(pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo));
 529                 }
 530             }
 531             PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
 532 
 533             // Build certificate chain by using system certificate store.
 534             // Add cert chain into collection for any key usage.
 535             //
 536             if (GetCertificateChain(OID_EKU_ANY, pCertContext, &amp;pCertChainContext))
 537             {
 538                 for (DWORD i = 0; i &lt; pCertChainContext-&gt;cChain; i++)
 539                 {
 540                     // Found cert chain
</pre>
<hr />
<pre>
 632                                 {
 633                                     // Generate RSA certificate chain and store into cert
 634                                     // chain collection
 635                                     jstring name = env-&gt;NewStringUTF(pszNameString);
 636                                     if (name == NULL) {
 637                                         __leave;
 638                                     }
 639                                     env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
 640                                             1,
 641                                             name,
 642                                             (jlong) hCryptProv, (jlong) hUserKey,
 643                                             dwPublicKeyLength, jArrayList);
 644                                 }
 645                             } else {
 646                                 // Only accept EC for CNG
 647                                 BYTE buffer[32];
 648                                 DWORD len = 0;
 649                                 if (::NCryptGetProperty(
 650                                         hCryptProv, NCRYPT_ALGORITHM_PROPERTY,
 651                                         (PBYTE)buffer, 32, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {
<span class="line-added"> 652                                     jstring name = env-&gt;NewStringUTF(pszNameString);</span>
<span class="line-added"> 653                                     if (name == NULL) {</span>
<span class="line-added"> 654                                         __leave;</span>
<span class="line-added"> 655                                     }</span>
 656                                     if (buffer[0] == &#39;E&#39; &amp;&amp; buffer[2] == &#39;C&#39;
 657                                             &amp;&amp; (dwPublicKeyLength == 256
 658                                                     || dwPublicKeyLength == 384
 659                                                     || dwPublicKeyLength == 521)) {




 660                                         env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
 661                                             0,
 662                                             name,
<span class="line-modified"> 663                                             (jlong) hCryptProv, (jlong) 0,</span>
 664                                             dwPublicKeyLength, jArrayList);
<span class="line-added"> 665                                     } else if (buffer[0] == &#39;R&#39; &amp;&amp; buffer[2] == &#39;S&#39;</span>
<span class="line-added"> 666                                             &amp;&amp; buffer[4] == &#39;A&#39;) {</span>
<span class="line-added"> 667                                         env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,</span>
<span class="line-added"> 668                                             1,</span>
<span class="line-added"> 669                                             name,</span>
<span class="line-added"> 670                                             (jlong) hCryptProv, (jlong) 0,</span>
<span class="line-added"> 671                                             dwPublicKeyLength, jArrayList);</span>
<span class="line-added"> 672                                     } else {</span>
<span class="line-added"> 673                                         dump(&quot;Unknown NCRYPT_ALGORITHM_PROPERTY&quot;, buffer, len);</span>
 674                                     }
 675                                 }
 676                             }
 677                         }
 678                     }
 679                 }
 680 
 681                 // Free cert chain
 682                 if (pCertChainContext)
 683                     ::CertFreeCertificateChain(pCertChainContext);
 684             } else {
 685                 PP(&quot;GetCertificateChain failed %d&quot;, GetLastError());
 686             }
 687         }
 688     }
 689     __finally
 690     {
 691         if (hCertStore)
 692             ::CertCloseStore(hCertStore, 0);
 693 
 694         if (pszCertStoreName)
 695             env-&gt;ReleaseStringUTFChars(jCertStoreName, pszCertStoreName);
 696 
 697         if (pszNameString)
 698             delete [] pszNameString;
 699     }
 700 }
 701 
 702 
 703 /*
<span class="line-modified"> 704  * Class:     sun_security_mscapi_CKey</span>
 705  * Method:    cleanUp
 706  * Signature: (JJ)V
 707  */
<span class="line-modified"> 708 JNIEXPORT void JNICALL Java_sun_security_mscapi_CKey_cleanUp</span>
 709   (JNIEnv *env, jclass clazz, jlong hCryptProv, jlong hCryptKey)
 710 {
<span class="line-modified"> 711     if (hCryptKey == NULL &amp;&amp; hCryptProv != NULL) {</span>
<span class="line-modified"> 712         NCryptFreeObject((NCRYPT_HANDLE)hCryptProv);</span>
<span class="line-modified"> 713     } else {</span>
<span class="line-modified"> 714         if (hCryptKey != NULL)</span>
<span class="line-modified"> 715             ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated</span>
<span class="line-added"> 716 </span>
<span class="line-added"> 717         if (hCryptProv != NULL)</span>
<span class="line-added"> 718             ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated</span>
<span class="line-added"> 719     }</span>
 720 }
 721 
 722 /*
 723  * Class:     sun_security_mscapi_CSignature
 724  * Method:    signHash
 725  * Signature: (Z[BILjava/lang/String;JJ)[B
 726  */
 727 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_signHash
 728   (JNIEnv *env, jclass clazz, jboolean noHashOID, jbyteArray jHash,
 729         jint jHashSize, jstring jHashAlgorithm, jlong hCryptProv,
 730         jlong hCryptKey)
 731 {
 732     HCRYPTHASH hHash = NULL;
 733     jbyte* pHashBuffer = NULL;
 734     jbyte* pSignedHashBuffer = NULL;
 735     jbyteArray jSignedHash = NULL;
 736     HCRYPTPROV hCryptProvAlt = NULL;
 737 
 738     __try
 739     {
</pre>
<hr />
<pre>
 859  */
 860 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_signCngHash
 861   (JNIEnv *env, jclass clazz, jint type, jbyteArray jHash,
 862         jint jHashSize, jint saltLen, jstring jHashAlgorithm, jlong hCryptProv,
 863         jlong hCryptKey)
 864 {
 865     jbyteArray jSignedHash = NULL;
 866 
 867     jbyte* pHashBuffer = NULL;
 868     jbyte* pSignedHashBuffer = NULL;
 869     NCRYPT_KEY_HANDLE hk = NULL;
 870 
 871     __try
 872     {
 873         if (hCryptKey == 0) {
 874             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
 875         } else {
 876             SS_CHECK(::NCryptTranslateHandle(
 877                 NULL,
 878                 &amp;hk,
<span class="line-modified"> 879                 (HCRYPTPROV)hCryptProv,</span>
<span class="line-modified"> 880                 (HCRYPTKEY)hCryptKey,</span>
 881                 NULL,
 882                 0));
 883         }
 884 
 885         // Copy hash from Java to native buffer
 886         pHashBuffer = new (env) jbyte[jHashSize];
 887         if (pHashBuffer == NULL) {
 888             __leave;
 889         }
 890         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
 891 
 892         VOID* param;
 893         DWORD dwFlags;
 894 
 895         switch (type) {
 896         case 0:
 897             param = NULL;
 898             dwFlags = 0;
 899             break;
 900         case 1:
 901             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified"> 902             if (jHashAlgorithm) {</span>
<span class="line-modified"> 903                 pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified"> 904                 if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified"> 905                     ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified"> 906                             &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-added"> 907                     __leave;</span>
<span class="line-added"> 908                 }</span>
<span class="line-added"> 909             } else {</span>
<span class="line-added"> 910                 pkcs1Info.pszAlgId = NULL;</span>
 911             }
 912             param = &amp;pkcs1Info;
 913             dwFlags = BCRYPT_PAD_PKCS1;
 914             break;
 915         case 2:
 916             BCRYPT_PSS_PADDING_INFO pssInfo;
 917             pssInfo.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
 918             pssInfo.cbSalt = saltLen;
 919             if (pssInfo.pszAlgId == NULL) {
 920                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
 921                         &quot;Unrecognised hash algorithm&quot;);
 922                 __leave;
 923             }
 924             param = &amp;pssInfo;
 925             dwFlags = BCRYPT_PAD_PSS;
 926             break;
 927         }
 928 
 929         DWORD jSignedHashSize = 0;
 930         SS_CHECK(::NCryptSignHash(
</pre>
<hr />
<pre>
1087 JNIEXPORT jboolean JNICALL Java_sun_security_mscapi_CSignature_verifyCngSignedHash
1088   (JNIEnv *env, jclass clazz, jint type,
1089         jbyteArray jHash, jint jHashSize,
1090         jbyteArray jSignedHash, jint jSignedHashSize,
1091         jint saltLen, jstring jHashAlgorithm,
1092         jlong hCryptProv, jlong hCryptKey)
1093 {
1094     jbyte* pHashBuffer = NULL;
1095     jbyte* pSignedHashBuffer = NULL;
1096     jboolean result = JNI_FALSE;
1097     NCRYPT_KEY_HANDLE hk = NULL;
1098 
1099     __try
1100     {
1101         if (hCryptKey == 0) {
1102             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
1103         } else {
1104             SS_CHECK(::NCryptTranslateHandle(
1105                 NULL,
1106                 &amp;hk,
<span class="line-modified">1107                 (HCRYPTPROV)hCryptProv,</span>
<span class="line-modified">1108                 (HCRYPTKEY)hCryptKey,</span>
1109                 NULL,
1110                 0));
1111         }
1112 
1113         // Copy hash and signedHash from Java to native buffer
1114         pHashBuffer = new (env) jbyte[jHashSize];
1115         if (pHashBuffer == NULL) {
1116             __leave;
1117         }
1118         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
1119 
1120         pSignedHashBuffer = new (env) jbyte[jSignedHashSize];
1121         if (pSignedHashBuffer == NULL) {
1122             __leave;
1123         }
1124         env-&gt;GetByteArrayRegion(jSignedHash, 0, jSignedHashSize,
1125             pSignedHashBuffer);
1126 
1127         VOID* param;
1128         DWORD dwFlags;
1129 
1130         switch (type) {
1131         case 0:
1132             param = NULL;
1133             dwFlags = 0;
1134             break;
1135         case 1:
1136             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified">1137             if (jHashAlgorithm) {</span>
<span class="line-modified">1138                 pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified">1139                 if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified">1140                     ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified">1141                             &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-added">1142                     __leave;</span>
<span class="line-added">1143                 }</span>
<span class="line-added">1144             } else {</span>
<span class="line-added">1145                 pkcs1Info.pszAlgId = NULL;</span>
1146             }
1147             param = &amp;pkcs1Info;
1148             dwFlags = NCRYPT_PAD_PKCS1_FLAG;
1149             break;
1150         case 2:
1151             BCRYPT_PSS_PADDING_INFO pssInfo;
1152             pssInfo.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
1153             pssInfo.cbSalt = saltLen;
1154             if (pssInfo.pszAlgId == NULL) {
1155                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
1156                         &quot;Unrecognised hash algorithm&quot;);
1157                 __leave;
1158             }
1159             param = &amp;pssInfo;
1160             dwFlags = NCRYPT_PAD_PSS_FLAG;
1161             break;
1162         }
1163 
1164         if (::NCryptVerifySignature(hk, param,
1165                 (BYTE *) pHashBuffer, jHashSize,
</pre>
<hr />
<pre>
1924 }
1925 
1926 /*
1927  * Class:     sun_security_mscapi_CPublicKey
1928  * Method:    getPublicKeyBlob
1929  * Signature: (JJ)[B
1930  */
1931 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CPublicKey_getPublicKeyBlob
1932     (JNIEnv *env, jobject clazz, jlong hCryptProv, jlong hCryptKey) {
1933 
1934     jbyteArray blob = NULL;
1935     DWORD dwBlobLen;
1936     BYTE* pbKeyBlob = NULL;
1937 
1938     __try
1939     {
1940 
1941         // Determine the size of the blob
1942         if (hCryptKey == 0) {
1943             SS_CHECK(::NCryptExportKey(
<span class="line-modified">1944                 (NCRYPT_KEY_HANDLE)hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
1945                 NULL, NULL, 0, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
1946         } else {
1947             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, NULL, //deprecated
1948                 &amp;dwBlobLen)) {
1949 
1950                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1951                 __leave;
1952             }
1953         }
1954 
1955         pbKeyBlob = new (env) BYTE[dwBlobLen];
1956         if (pbKeyBlob == NULL) {
1957             __leave;
1958         }
1959 
1960         // Generate key blob
1961         if (hCryptKey == 0) {
1962             SS_CHECK(::NCryptExportKey(
<span class="line-modified">1963                 (NCRYPT_KEY_HANDLE)hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
1964                 NULL, pbKeyBlob, dwBlobLen, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
1965         } else {
1966             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, //deprecated
1967                 pbKeyBlob, &amp;dwBlobLen)) {
1968 
1969                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1970                 __leave;
1971             }
1972         }
1973 
1974         // Create new byte array
1975         if ((blob = env-&gt;NewByteArray(dwBlobLen)) == NULL) {
1976             __leave;
1977         }
1978 
1979         // Copy data from native buffer to Java buffer
1980         env-&gt;SetByteArrayRegion(blob, 0, dwBlobLen, (jbyte*) pbKeyBlob);
1981     }
1982     __finally
1983     {
</pre>
</td>
</tr>
</table>
<center><a href="../../classes/sun/security/mscapi/CSignature.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/Config.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
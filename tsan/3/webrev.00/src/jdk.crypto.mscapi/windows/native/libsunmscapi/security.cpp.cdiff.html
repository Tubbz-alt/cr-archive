<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classes/sun/security/mscapi/CSignature.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/Config.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,11 ***</span>
                      bHasNoPrivateKey = TRUE;
                  }
                  else
                  {
                      if ((dwKeySpec &amp; CERT_NCRYPT_KEY_SPEC) == CERT_NCRYPT_KEY_SPEC) {
<span class="line-modified">!                         PP(&quot;CNG %I64d&quot;, hCryptProv);</span>
                      } else {
                          // Private key is available
                          BOOL bGetUserKey = ::CryptGetUserKey(hCryptProv, dwKeySpec, &amp;hUserKey); //deprecated
  
                          // Skip certificate if cannot find private key
<span class="line-new-header">--- 500,11 ---</span>
                      bHasNoPrivateKey = TRUE;
                  }
                  else
                  {
                      if ((dwKeySpec &amp; CERT_NCRYPT_KEY_SPEC) == CERT_NCRYPT_KEY_SPEC) {
<span class="line-modified">!                         PP(&quot;CNG %I64d&quot;, (__int64)hCryptProv);</span>
                      } else {
                          // Private key is available
                          BOOL bGetUserKey = ::CryptGetUserKey(hCryptProv, dwKeySpec, &amp;hUserKey); //deprecated
  
                          // Skip certificate if cannot find private key
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,11 ***</span>
                          }
  
                          // Set cipher mode to ECB
                          DWORD dwCipherMode = CRYPT_MODE_ECB;
                          ::CryptSetKeyParam(hUserKey, KP_MODE, (BYTE*)&amp;dwCipherMode, NULL); //deprecated
<span class="line-modified">!                         PP(&quot;CAPI %I64d %I64d&quot;, hCryptProv, hUserKey);</span>
                      }
                      // If the private key is present in smart card, we may not be able to
                      // determine the key length by using the private key handle. However,
                      // since public/private key pairs must have the same length, we could
                      // determine the key length of the private key by using the public key
<span class="line-new-header">--- 515,11 ---</span>
                          }
  
                          // Set cipher mode to ECB
                          DWORD dwCipherMode = CRYPT_MODE_ECB;
                          ::CryptSetKeyParam(hUserKey, KP_MODE, (BYTE*)&amp;dwCipherMode, NULL); //deprecated
<span class="line-modified">!                         PP(&quot;CAPI %I64d %I64d&quot;, (__int64)hCryptProv, (__int64)hUserKey);</span>
                      }
                      // If the private key is present in smart card, we may not be able to
                      // determine the key length by using the private key handle. However,
                      // since public/private key pairs must have the same length, we could
                      // determine the key length of the private key by using the public key
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,23 ***</span>
                                  BYTE buffer[32];
                                  DWORD len = 0;
                                  if (::NCryptGetProperty(
                                          hCryptProv, NCRYPT_ALGORITHM_PROPERTY,
                                          (PBYTE)buffer, 32, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {
                                      if (buffer[0] == &#39;E&#39; &amp;&amp; buffer[2] == &#39;C&#39;
                                              &amp;&amp; (dwPublicKeyLength == 256
                                                      || dwPublicKeyLength == 384
                                                      || dwPublicKeyLength == 521)) {
<span class="line-removed">-                                         jstring name = env-&gt;NewStringUTF(pszNameString);</span>
<span class="line-removed">-                                         if (name == NULL) {</span>
<span class="line-removed">-                                             __leave;</span>
<span class="line-removed">-                                         }</span>
                                          env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
                                              0,
                                              name,
<span class="line-modified">!                                             (jlong) hCryptProv, 0,</span>
                                              dwPublicKeyLength, jArrayList);
                                      }
                                  }
                              }
                          }
                      }
<span class="line-new-header">--- 647,32 ---</span>
                                  BYTE buffer[32];
                                  DWORD len = 0;
                                  if (::NCryptGetProperty(
                                          hCryptProv, NCRYPT_ALGORITHM_PROPERTY,
                                          (PBYTE)buffer, 32, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {
<span class="line-added">+                                     jstring name = env-&gt;NewStringUTF(pszNameString);</span>
<span class="line-added">+                                     if (name == NULL) {</span>
<span class="line-added">+                                         __leave;</span>
<span class="line-added">+                                     }</span>
                                      if (buffer[0] == &#39;E&#39; &amp;&amp; buffer[2] == &#39;C&#39;
                                              &amp;&amp; (dwPublicKeyLength == 256
                                                      || dwPublicKeyLength == 384
                                                      || dwPublicKeyLength == 521)) {
                                          env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
                                              0,
                                              name,
<span class="line-modified">!                                             (jlong) hCryptProv, (jlong) 0,</span>
                                              dwPublicKeyLength, jArrayList);
<span class="line-added">+                                     } else if (buffer[0] == &#39;R&#39; &amp;&amp; buffer[2] == &#39;S&#39;</span>
<span class="line-added">+                                             &amp;&amp; buffer[4] == &#39;A&#39;) {</span>
<span class="line-added">+                                         env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,</span>
<span class="line-added">+                                             1,</span>
<span class="line-added">+                                             name,</span>
<span class="line-added">+                                             (jlong) hCryptProv, (jlong) 0,</span>
<span class="line-added">+                                             dwPublicKeyLength, jArrayList);</span>
<span class="line-added">+                                     } else {</span>
<span class="line-added">+                                         dump(&quot;Unknown NCRYPT_ALGORITHM_PROPERTY&quot;, buffer, len);</span>
                                      }
                                  }
                              }
                          }
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 690,22 ***</span>
      }
  }
  
  
  /*
<span class="line-modified">!  * Class:     sun_security_mscapi_Key</span>
   * Method:    cleanUp
   * Signature: (JJ)V
   */
<span class="line-modified">! JNIEXPORT void JNICALL Java_sun_security_mscapi_Key_cleanUp</span>
    (JNIEnv *env, jclass clazz, jlong hCryptProv, jlong hCryptKey)
  {
<span class="line-modified">!     if (hCryptKey != NULL)</span>
<span class="line-modified">!         ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (hCryptProv != NULL)</span>
<span class="line-modified">!         ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated</span>
  }
  
  /*
   * Class:     sun_security_mscapi_CSignature
   * Method:    signHash
<span class="line-new-header">--- 699,26 ---</span>
      }
  }
  
  
  /*
<span class="line-modified">!  * Class:     sun_security_mscapi_CKey</span>
   * Method:    cleanUp
   * Signature: (JJ)V
   */
<span class="line-modified">! JNIEXPORT void JNICALL Java_sun_security_mscapi_CKey_cleanUp</span>
    (JNIEnv *env, jclass clazz, jlong hCryptProv, jlong hCryptKey)
  {
<span class="line-modified">!     if (hCryptKey == NULL &amp;&amp; hCryptProv != NULL) {</span>
<span class="line-modified">!         NCryptFreeObject((NCRYPT_HANDLE)hCryptProv);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         if (hCryptKey != NULL)</span>
<span class="line-modified">!             ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (hCryptProv != NULL)</span>
<span class="line-added">+             ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated</span>
<span class="line-added">+     }</span>
  }
  
  /*
   * Class:     sun_security_mscapi_CSignature
   * Method:    signHash
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,12 ***</span>
              hk = (NCRYPT_KEY_HANDLE)hCryptProv;
          } else {
              SS_CHECK(::NCryptTranslateHandle(
                  NULL,
                  &amp;hk,
<span class="line-modified">!                 hCryptProv,</span>
<span class="line-modified">!                 hCryptKey,</span>
                  NULL,
                  0));
          }
  
          // Copy hash from Java to native buffer
<span class="line-new-header">--- 874,12 ---</span>
              hk = (NCRYPT_KEY_HANDLE)hCryptProv;
          } else {
              SS_CHECK(::NCryptTranslateHandle(
                  NULL,
                  &amp;hk,
<span class="line-modified">!                 (HCRYPTPROV)hCryptProv,</span>
<span class="line-modified">!                 (HCRYPTKEY)hCryptKey,</span>
                  NULL,
                  0));
          }
  
          // Copy hash from Java to native buffer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,15 ***</span>
              param = NULL;
              dwFlags = 0;
              break;
          case 1:
              BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified">!             pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified">!             if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified">!                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified">!                         &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-modified">!                 __leave;</span>
              }
              param = &amp;pkcs1Info;
              dwFlags = BCRYPT_PAD_PKCS1;
              break;
          case 2:
<span class="line-new-header">--- 897,19 ---</span>
              param = NULL;
              dwFlags = 0;
              break;
          case 1:
              BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified">!             if (jHashAlgorithm) {</span>
<span class="line-modified">!                 pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified">!                 if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified">!                     ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified">!                             &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-added">+                     __leave;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 pkcs1Info.pszAlgId = NULL;</span>
              }
              param = &amp;pkcs1Info;
              dwFlags = BCRYPT_PAD_PKCS1;
              break;
          case 2:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1085,12 ***</span>
              hk = (NCRYPT_KEY_HANDLE)hCryptProv;
          } else {
              SS_CHECK(::NCryptTranslateHandle(
                  NULL,
                  &amp;hk,
<span class="line-modified">!                 hCryptProv,</span>
<span class="line-modified">!                 hCryptKey,</span>
                  NULL,
                  0));
          }
  
          // Copy hash and signedHash from Java to native buffer
<span class="line-new-header">--- 1102,12 ---</span>
              hk = (NCRYPT_KEY_HANDLE)hCryptProv;
          } else {
              SS_CHECK(::NCryptTranslateHandle(
                  NULL,
                  &amp;hk,
<span class="line-modified">!                 (HCRYPTPROV)hCryptProv,</span>
<span class="line-modified">!                 (HCRYPTKEY)hCryptKey,</span>
                  NULL,
                  0));
          }
  
          // Copy hash and signedHash from Java to native buffer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1115,15 ***</span>
              param = NULL;
              dwFlags = 0;
              break;
          case 1:
              BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified">!             pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified">!             if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified">!                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified">!                         &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-modified">!                 __leave;</span>
              }
              param = &amp;pkcs1Info;
              dwFlags = NCRYPT_PAD_PKCS1_FLAG;
              break;
          case 2:
<span class="line-new-header">--- 1132,19 ---</span>
              param = NULL;
              dwFlags = 0;
              break;
          case 1:
              BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
<span class="line-modified">!             if (jHashAlgorithm) {</span>
<span class="line-modified">!                 pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);</span>
<span class="line-modified">!                 if (pkcs1Info.pszAlgId == NULL) {</span>
<span class="line-modified">!                     ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,</span>
<span class="line-modified">!                             &quot;Unrecognised hash algorithm&quot;);</span>
<span class="line-added">+                     __leave;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 pkcs1Info.pszAlgId = NULL;</span>
              }
              param = &amp;pkcs1Info;
              dwFlags = NCRYPT_PAD_PKCS1_FLAG;
              break;
          case 2:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1918,11 ***</span>
      {
  
          // Determine the size of the blob
          if (hCryptKey == 0) {
              SS_CHECK(::NCryptExportKey(
<span class="line-modified">!                 hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
                  NULL, NULL, 0, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
          } else {
              if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, NULL, //deprecated
                  &amp;dwBlobLen)) {
  
<span class="line-new-header">--- 1939,11 ---</span>
      {
  
          // Determine the size of the blob
          if (hCryptKey == 0) {
              SS_CHECK(::NCryptExportKey(
<span class="line-modified">!                 (NCRYPT_KEY_HANDLE)hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
                  NULL, NULL, 0, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
          } else {
              if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, NULL, //deprecated
                  &amp;dwBlobLen)) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1937,11 ***</span>
          }
  
          // Generate key blob
          if (hCryptKey == 0) {
              SS_CHECK(::NCryptExportKey(
<span class="line-modified">!                 hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
                  NULL, pbKeyBlob, dwBlobLen, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
          } else {
              if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, //deprecated
                  pbKeyBlob, &amp;dwBlobLen)) {
  
<span class="line-new-header">--- 1958,11 ---</span>
          }
  
          // Generate key blob
          if (hCryptKey == 0) {
              SS_CHECK(::NCryptExportKey(
<span class="line-modified">!                 (NCRYPT_KEY_HANDLE)hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,</span>
                  NULL, pbKeyBlob, dwBlobLen, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
          } else {
              if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, //deprecated
                  pbKeyBlob, &amp;dwBlobLen)) {
  
</pre>
<center><a href="../../classes/sun/security/mscapi/CSignature.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.crypto.ucrypto/solaris/classes/com/oracle/security/ucrypto/Config.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
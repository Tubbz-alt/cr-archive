diff a/src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp b/src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp
--- a/src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp
+++ b/src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -500,11 +500,11 @@
                     bHasNoPrivateKey = TRUE;
                 }
                 else
                 {
                     if ((dwKeySpec & CERT_NCRYPT_KEY_SPEC) == CERT_NCRYPT_KEY_SPEC) {
-                        PP("CNG %I64d", hCryptProv);
+                        PP("CNG %I64d", (__int64)hCryptProv);
                     } else {
                         // Private key is available
                         BOOL bGetUserKey = ::CryptGetUserKey(hCryptProv, dwKeySpec, &hUserKey); //deprecated
 
                         // Skip certificate if cannot find private key
@@ -515,11 +515,11 @@
                         }
 
                         // Set cipher mode to ECB
                         DWORD dwCipherMode = CRYPT_MODE_ECB;
                         ::CryptSetKeyParam(hUserKey, KP_MODE, (BYTE*)&dwCipherMode, NULL); //deprecated
-                        PP("CAPI %I64d %I64d", hCryptProv, hUserKey);
+                        PP("CAPI %I64d %I64d", (__int64)hCryptProv, (__int64)hUserKey);
                     }
                     // If the private key is present in smart card, we may not be able to
                     // determine the key length by using the private key handle. However,
                     // since public/private key pairs must have the same length, we could
                     // determine the key length of the private key by using the public key
@@ -647,23 +647,32 @@
                                 BYTE buffer[32];
                                 DWORD len = 0;
                                 if (::NCryptGetProperty(
                                         hCryptProv, NCRYPT_ALGORITHM_PROPERTY,
                                         (PBYTE)buffer, 32, &len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {
+                                    jstring name = env->NewStringUTF(pszNameString);
+                                    if (name == NULL) {
+                                        __leave;
+                                    }
                                     if (buffer[0] == 'E' && buffer[2] == 'C'
                                             && (dwPublicKeyLength == 256
                                                     || dwPublicKeyLength == 384
                                                     || dwPublicKeyLength == 521)) {
-                                        jstring name = env->NewStringUTF(pszNameString);
-                                        if (name == NULL) {
-                                            __leave;
-                                        }
                                         env->CallVoidMethod(obj, mGenKeyAndCertChain,
                                             0,
                                             name,
-                                            (jlong) hCryptProv, 0,
+                                            (jlong) hCryptProv, (jlong) 0,
                                             dwPublicKeyLength, jArrayList);
+                                    } else if (buffer[0] == 'R' && buffer[2] == 'S'
+                                            && buffer[4] == 'A') {
+                                        env->CallVoidMethod(obj, mGenKeyAndCertChain,
+                                            1,
+                                            name,
+                                            (jlong) hCryptProv, (jlong) 0,
+                                            dwPublicKeyLength, jArrayList);
+                                    } else {
+                                        dump("Unknown NCRYPT_ALGORITHM_PROPERTY", buffer, len);
                                     }
                                 }
                             }
                         }
                     }
@@ -690,22 +699,26 @@
     }
 }
 
 
 /*
- * Class:     sun_security_mscapi_Key
+ * Class:     sun_security_mscapi_CKey
  * Method:    cleanUp
  * Signature: (JJ)V
  */
-JNIEXPORT void JNICALL Java_sun_security_mscapi_Key_cleanUp
+JNIEXPORT void JNICALL Java_sun_security_mscapi_CKey_cleanUp
   (JNIEnv *env, jclass clazz, jlong hCryptProv, jlong hCryptKey)
 {
-    if (hCryptKey != NULL)
-        ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated
-
-    if (hCryptProv != NULL)
-        ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated
+    if (hCryptKey == NULL && hCryptProv != NULL) {
+        NCryptFreeObject((NCRYPT_HANDLE)hCryptProv);
+    } else {
+        if (hCryptKey != NULL)
+            ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated
+
+        if (hCryptProv != NULL)
+            ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated
+    }
 }
 
 /*
  * Class:     sun_security_mscapi_CSignature
  * Method:    signHash
@@ -861,12 +874,12 @@
             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
         } else {
             SS_CHECK(::NCryptTranslateHandle(
                 NULL,
                 &hk,
-                hCryptProv,
-                hCryptKey,
+                (HCRYPTPROV)hCryptProv,
+                (HCRYPTKEY)hCryptKey,
                 NULL,
                 0));
         }
 
         // Copy hash from Java to native buffer
@@ -884,15 +897,19 @@
             param = NULL;
             dwFlags = 0;
             break;
         case 1:
             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
-            pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
-            if (pkcs1Info.pszAlgId == NULL) {
-                ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
-                        "Unrecognised hash algorithm");
-                __leave;
+            if (jHashAlgorithm) {
+                pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
+                if (pkcs1Info.pszAlgId == NULL) {
+                    ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
+                            "Unrecognised hash algorithm");
+                    __leave;
+                }
+            } else {
+                pkcs1Info.pszAlgId = NULL;
             }
             param = &pkcs1Info;
             dwFlags = BCRYPT_PAD_PKCS1;
             break;
         case 2:
@@ -1085,12 +1102,12 @@
             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
         } else {
             SS_CHECK(::NCryptTranslateHandle(
                 NULL,
                 &hk,
-                hCryptProv,
-                hCryptKey,
+                (HCRYPTPROV)hCryptProv,
+                (HCRYPTKEY)hCryptKey,
                 NULL,
                 0));
         }
 
         // Copy hash and signedHash from Java to native buffer
@@ -1115,15 +1132,19 @@
             param = NULL;
             dwFlags = 0;
             break;
         case 1:
             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
-            pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
-            if (pkcs1Info.pszAlgId == NULL) {
-                ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
-                        "Unrecognised hash algorithm");
-                __leave;
+            if (jHashAlgorithm) {
+                pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
+                if (pkcs1Info.pszAlgId == NULL) {
+                    ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
+                            "Unrecognised hash algorithm");
+                    __leave;
+                }
+            } else {
+                pkcs1Info.pszAlgId = NULL;
             }
             param = &pkcs1Info;
             dwFlags = NCRYPT_PAD_PKCS1_FLAG;
             break;
         case 2:
@@ -1918,11 +1939,11 @@
     {
 
         // Determine the size of the blob
         if (hCryptKey == 0) {
             SS_CHECK(::NCryptExportKey(
-                hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,
+                (NCRYPT_KEY_HANDLE)hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,
                 NULL, NULL, 0, &dwBlobLen, NCRYPT_SILENT_FLAG));
         } else {
             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, NULL, //deprecated
                 &dwBlobLen)) {
 
@@ -1937,11 +1958,11 @@
         }
 
         // Generate key blob
         if (hCryptKey == 0) {
             SS_CHECK(::NCryptExportKey(
-                hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,
+                (NCRYPT_KEY_HANDLE)hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,
                 NULL, pbKeyBlob, dwBlobLen, &dwBlobLen, NCRYPT_SILENT_FLAG));
         } else {
             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, //deprecated
                 pbKeyBlob, &dwBlobLen)) {
 

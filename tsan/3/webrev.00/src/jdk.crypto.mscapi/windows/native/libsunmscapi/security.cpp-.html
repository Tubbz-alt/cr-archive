<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.crypto.mscapi/windows/native/libsunmscapi/security.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //=--------------------------------------------------------------------------=
  27 // security.cpp    by Stanley Man-Kit Ho
  28 //=--------------------------------------------------------------------------=
  29 //
  30 
  31 #include &lt;jni.h&gt;
  32 #include &quot;jni_util.h&quot;
  33 #include &lt;stdlib.h&gt;
  34 #include &lt;string.h&gt;
  35 #include &lt;windows.h&gt;
  36 #include &lt;BaseTsd.h&gt;
  37 #include &lt;wincrypt.h&gt;
  38 #include &lt;stdio.h&gt;
  39 #include &lt;memory&gt;
  40 #include &quot;sun_security_mscapi_CKey.h&quot;
  41 #include &quot;sun_security_mscapi_CKeyStore.h&quot;
  42 #include &quot;sun_security_mscapi_PRNG.h&quot;
  43 #include &quot;sun_security_mscapi_CRSACipher.h&quot;
  44 #include &quot;sun_security_mscapi_CKeyPairGenerator_RSA.h&quot;
  45 #include &quot;sun_security_mscapi_CPublicKey.h&quot;
  46 #include &quot;sun_security_mscapi_CPublicKey_CRSAPublicKey.h&quot;
  47 #include &quot;sun_security_mscapi_CSignature.h&quot;
  48 #include &quot;sun_security_mscapi_CSignature_RSA.h&quot;
  49 
  50 #define OID_EKU_ANY         &quot;2.5.29.37.0&quot;
  51 
  52 #define CERTIFICATE_PARSING_EXCEPTION \
  53                             &quot;java/security/cert/CertificateParsingException&quot;
  54 #define INVALID_KEY_EXCEPTION \
  55                             &quot;java/security/InvalidKeyException&quot;
  56 #define KEY_EXCEPTION       &quot;java/security/KeyException&quot;
  57 #define KEYSTORE_EXCEPTION  &quot;java/security/KeyStoreException&quot;
  58 #define PROVIDER_EXCEPTION  &quot;java/security/ProviderException&quot;
  59 #define SIGNATURE_EXCEPTION &quot;java/security/SignatureException&quot;
  60 #define OUT_OF_MEMORY_ERROR &quot;java/lang/OutOfMemoryError&quot;
  61 
  62 #define SS_CHECK(Status) \
  63         if (Status != ERROR_SUCCESS) { \
  64             ThrowException(env, SIGNATURE_EXCEPTION, Status); \
  65             __leave; \
  66         }
  67 
  68 #define PP(fmt, ...) \
  69         if (trace) { \
  70             fprintf(stdout, &quot;MSCAPI (%ld): &quot;, __LINE__); \
  71             fprintf(stdout, fmt, ##__VA_ARGS__); \
  72             fprintf(stdout, &quot;\n&quot;); \
  73             fflush(stdout); \
  74         }
  75 
  76 extern &quot;C&quot; {
  77 
  78 char* trace = getenv(&quot;CAPI_TRACE&quot;);
  79 
  80 /*
  81  * Declare library specific JNI_Onload entry if static build
  82  */
  83 DEF_STATIC_JNI_OnLoad
  84 
  85 void showProperty(NCRYPT_HANDLE hKey);
  86 
  87 void dump(LPSTR title, PBYTE data, DWORD len)
  88 {
  89     if (trace) {
  90         printf(&quot;==== %s ====\n&quot;, title);
  91         for (DWORD i = 0; i &lt; len; i+=16) {
  92             printf(&quot;%04x: &quot;, i);
  93             for (int j = 0; j &lt; 16; j++) {
  94                 if (j == 8) {
  95                     printf(&quot;  &quot;);
  96                 }
  97                 if (i + j &lt; len) {
  98                     printf(&quot;%02X &quot;, *(data + i + j) &amp; 0xff);
  99                 } else {
 100                     printf(&quot;   &quot;);
 101                 }
 102             }
 103             for (int j = 0; j &lt; 16; j++) {
 104                 if (i + j &lt; len) {
 105                     int k = *(data + i + j) &amp; 0xff;
 106                     if (k &lt; 32 || k &gt; 127) printf(&quot;.&quot;);
 107                     else printf(&quot;%c&quot;, (char)k);
 108                 }
 109             }
 110             printf(&quot;\n&quot;);
 111         }
 112         fflush(stdout);
 113     }
 114 }
 115 
 116 /*
 117  * Throws an arbitrary Java exception with the given message.
 118  */
 119 void ThrowExceptionWithMessage(JNIEnv *env, const char *exceptionName,
 120                                const char *szMessage)
 121 {
 122     jclass exceptionClazz = env-&gt;FindClass(exceptionName);
 123     if (exceptionClazz != NULL) {
 124         env-&gt;ThrowNew(exceptionClazz, szMessage);
 125     }
 126 }
 127 
 128 /*
 129  * Throws an arbitrary Java exception.
 130  * The exception message is a Windows system error message.
 131  */
 132 void ThrowException(JNIEnv *env, const char *exceptionName, DWORD dwError)
 133 {
 134     char szMessage[1024];
 135     szMessage[0] = &#39;\0&#39;;
 136 
 137     DWORD res = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError,
 138         NULL, szMessage, sizeof(szMessage), NULL);
 139     if (res == 0) {
 140         strcpy(szMessage, &quot;Unknown error&quot;);
 141     }
 142 
 143     ThrowExceptionWithMessage(env, exceptionName, szMessage);
 144 }
 145 
 146 /*
 147  * Overloaded &#39;operator new[]&#39; variant, which will raise Java&#39;s
 148  * OutOfMemoryError in the case of a failure.
 149  */
 150 void* operator new[](std::size_t size, JNIEnv *env)
 151 {
 152     void* buf = ::operator new[](size, std::nothrow);
 153     if (buf == NULL) {
 154         ThrowExceptionWithMessage(env, OUT_OF_MEMORY_ERROR,
 155                 &quot;Native memory allocation failed&quot;);
 156     }
 157     return buf;
 158 }
 159 
 160 /*
 161  * Maps the name of a hash algorithm to an algorithm identifier.
 162  */
 163 ALG_ID MapHashAlgorithm(JNIEnv *env, jstring jHashAlgorithm) {
 164 
 165     const char* pszHashAlgorithm = NULL;
 166     ALG_ID algId = 0;
 167 
 168     if ((pszHashAlgorithm = env-&gt;GetStringUTFChars(jHashAlgorithm, NULL))
 169         == NULL) {
 170         return algId;
 171     }
 172 
 173     if ((strcmp(&quot;SHA&quot;, pszHashAlgorithm) == 0) ||
 174         (strcmp(&quot;SHA1&quot;, pszHashAlgorithm) == 0) ||
 175         (strcmp(&quot;SHA-1&quot;, pszHashAlgorithm) == 0)) {
 176 
 177         algId = CALG_SHA1;
 178     } else if (strcmp(&quot;SHA1+MD5&quot;, pszHashAlgorithm) == 0) {
 179         algId = CALG_SSL3_SHAMD5; // a 36-byte concatenation of SHA-1 and MD5
 180     } else if (strcmp(&quot;SHA-256&quot;, pszHashAlgorithm) == 0) {
 181         algId = CALG_SHA_256;
 182     } else if (strcmp(&quot;SHA-384&quot;, pszHashAlgorithm) == 0) {
 183         algId = CALG_SHA_384;
 184     } else if (strcmp(&quot;SHA-512&quot;, pszHashAlgorithm) == 0) {
 185         algId = CALG_SHA_512;
 186     } else if (strcmp(&quot;MD5&quot;, pszHashAlgorithm) == 0) {
 187         algId = CALG_MD5;
 188     } else if (strcmp(&quot;MD2&quot;, pszHashAlgorithm) == 0) {
 189         algId = CALG_MD2;
 190     }
 191 
 192     if (pszHashAlgorithm)
 193         env-&gt;ReleaseStringUTFChars(jHashAlgorithm, pszHashAlgorithm);
 194 
 195    return algId;
 196 }
 197 
 198 /*
 199  * Maps the name of a hash algorithm to a CNG Algorithm Identifier.
 200  */
 201 LPCWSTR MapHashIdentifier(JNIEnv *env, jstring jHashAlgorithm) {
 202 
 203     const char* pszHashAlgorithm = NULL;
 204     LPCWSTR id = NULL;
 205 
 206     if ((pszHashAlgorithm = env-&gt;GetStringUTFChars(jHashAlgorithm, NULL))
 207             == NULL) {
 208         return id;
 209     }
 210 
 211     if ((strcmp(&quot;SHA&quot;, pszHashAlgorithm) == 0) ||
 212         (strcmp(&quot;SHA1&quot;, pszHashAlgorithm) == 0) ||
 213         (strcmp(&quot;SHA-1&quot;, pszHashAlgorithm) == 0)) {
 214 
 215         id = BCRYPT_SHA1_ALGORITHM;
 216     } else if (strcmp(&quot;SHA-256&quot;, pszHashAlgorithm) == 0) {
 217         id = BCRYPT_SHA256_ALGORITHM;
 218     } else if (strcmp(&quot;SHA-384&quot;, pszHashAlgorithm) == 0) {
 219         id = BCRYPT_SHA384_ALGORITHM;
 220     } else if (strcmp(&quot;SHA-512&quot;, pszHashAlgorithm) == 0) {
 221         id = BCRYPT_SHA512_ALGORITHM;
 222     }
 223 
 224     if (pszHashAlgorithm)
 225         env-&gt;ReleaseStringUTFChars(jHashAlgorithm, pszHashAlgorithm);
 226 
 227     return id;
 228 }
 229 
 230 /*
 231  * Returns a certificate chain context given a certificate context and key
 232  * usage identifier.
 233  */
 234 bool GetCertificateChain(LPSTR lpszKeyUsageIdentifier, PCCERT_CONTEXT pCertContext, PCCERT_CHAIN_CONTEXT* ppChainContext)
 235 {
 236     CERT_ENHKEY_USAGE        EnhkeyUsage;
 237     CERT_USAGE_MATCH         CertUsage;
 238     CERT_CHAIN_PARA          ChainPara;
 239     DWORD                    dwFlags = 0;
 240     LPSTR                    szUsageIdentifierArray[1];
 241 
 242     szUsageIdentifierArray[0] = lpszKeyUsageIdentifier;
 243     EnhkeyUsage.cUsageIdentifier = 1;
 244     EnhkeyUsage.rgpszUsageIdentifier = szUsageIdentifierArray;
 245     CertUsage.dwType = USAGE_MATCH_TYPE_AND;
 246     CertUsage.Usage  = EnhkeyUsage;
 247     ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
 248     ChainPara.RequestedUsage=CertUsage;
 249 
 250     // Build a chain using CertGetCertificateChain
 251     // and the certificate retrieved.
 252     return (::CertGetCertificateChain(NULL,     // use the default chain engine
 253                 pCertContext,   // pointer to the end certificate
 254                 NULL,           // use the default time
 255                 NULL,           // search no additional stores
 256                 &amp;ChainPara,     // use AND logic and enhanced key usage
 257                                 //  as indicated in the ChainPara
 258                                 //  data structure
 259                 dwFlags,
 260                 NULL,           // currently reserved
 261                 ppChainContext) == TRUE);       // return a pointer to the chain created
 262 }
 263 
 264 
 265 /////////////////////////////////////////////////////////////////////////////
 266 //
 267 
 268 /*
 269  * Class:     sun_security_mscapi_PRNG
 270  * Method:    getContext
 271  * Signature: ()J
 272  */
 273 JNIEXPORT jlong JNICALL Java_sun_security_mscapi_PRNG_getContext
 274         (JNIEnv *env, jclass clazz) {
 275     HCRYPTPROV hCryptProv = NULL;
 276     if(::CryptAcquireContext( //deprecated
 277        &amp;hCryptProv,
 278        NULL,
 279        NULL,
 280        PROV_RSA_FULL,
 281        CRYPT_VERIFYCONTEXT) == FALSE)
 282     {
 283         ThrowException(env, PROVIDER_EXCEPTION, GetLastError());
 284     }
 285     return hCryptProv;
 286 }
 287 
 288 
 289 /*
 290  * Class:     sun_security_mscapi_PRNG
 291  * Method:    releaseContext
 292  * Signature: (J)V
 293  */
 294 JNIEXPORT void JNICALL Java_sun_security_mscapi_PRNG_releaseContext
 295         (JNIEnv *env, jclass clazz, jlong ctxt) {
 296     if (ctxt) {
 297         ::CryptReleaseContext((HCRYPTPROV)ctxt, 0); //deprecated
 298     }
 299 }
 300 
 301 
 302 /*
 303  * Class:     sun_security_mscapi_PRNG
 304  * Method:    generateSeed
 305  * Signature: (JI[B)[B
 306  */
 307 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_PRNG_generateSeed
 308   (JNIEnv *env, jclass clazz, jlong ctxt, jint length, jbyteArray seed)
 309 {
 310 
 311     HCRYPTPROV hCryptProv = (HCRYPTPROV)ctxt;
 312     jbyte*     reseedBytes = NULL;
 313     jbyte*     seedBytes = NULL;
 314     jbyteArray result = NULL;
 315 
 316     __try
 317     {
 318         /*
 319          * If length is negative then use the supplied seed to re-seed the
 320          * generator and return null.
 321          * If length is non-zero then generate a new seed according to the
 322          * requested length and return the new seed.
 323          * If length is zero then overwrite the supplied seed with a new
 324          * seed of the same length and return the seed.
 325          */
 326         if (length &lt; 0) {
 327             length = env-&gt;GetArrayLength(seed);
 328             if ((reseedBytes = env-&gt;GetByteArrayElements(seed, 0)) == NULL) {
 329                 __leave;
 330             }
 331 
 332             if (::CryptGenRandom( //deprecated
 333                 hCryptProv,
 334                 length,
 335                 (BYTE *) reseedBytes) == FALSE) {
 336 
 337                 ThrowException(env, PROVIDER_EXCEPTION, GetLastError());
 338                 __leave;
 339             }
 340 
 341             result = NULL;
 342 
 343         } else {
 344 
 345             if (length &gt; 0) {
 346                 seed = env-&gt;NewByteArray(length);
 347                 if (seed == NULL) {
 348                     __leave;
 349                 }
 350             } else {
 351                 length = env-&gt;GetArrayLength(seed);
 352             }
 353 
 354             if ((seedBytes = env-&gt;GetByteArrayElements(seed, 0)) == NULL) {
 355                 __leave;
 356             }
 357 
 358             if (::CryptGenRandom( //deprecated
 359                 hCryptProv,
 360                 length,
 361                 (BYTE *) seedBytes) == FALSE) {
 362 
 363                 ThrowException(env, PROVIDER_EXCEPTION, GetLastError());
 364                 __leave;
 365             }
 366 
 367             result = seed; // seed will be updated when seedBytes gets released
 368         }
 369     }
 370     __finally
 371     {
 372         //--------------------------------------------------------------------
 373         // Clean up.
 374 
 375         if (reseedBytes)
 376             env-&gt;ReleaseByteArrayElements(seed, reseedBytes, JNI_ABORT);
 377 
 378         if (seedBytes)
 379             env-&gt;ReleaseByteArrayElements(seed, seedBytes, 0); // update orig
 380     }
 381 
 382     return result;
 383 }
 384 
 385 
 386 /*
 387  * Class:     sun_security_mscapi_CKeyStore
 388  * Method:    loadKeysOrCertificateChains
 389  * Signature: (Ljava/lang/String;)V
 390  */
 391 JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_loadKeysOrCertificateChains
 392   (JNIEnv *env, jobject obj, jstring jCertStoreName)
 393 {
 394     /**
 395      * Certificate in cert store has enhanced key usage extension
 396      * property (or EKU property) that is not part of the certificate itself. To determine
 397      * if the certificate should be returned, both the enhanced key usage in certificate
 398      * extension block and the extension property stored along with the certificate in
 399      * certificate store should be examined. Otherwise, we won&#39;t be able to determine
 400      * the proper key usage from the Java side because the information is not stored as
 401      * part of the encoded certificate.
 402      */
 403 
 404     const char* pszCertStoreName = NULL;
 405     HCERTSTORE hCertStore = NULL;
 406     PCCERT_CONTEXT pCertContext = NULL;
 407     char* pszNameString = NULL; // certificate&#39;s friendly name
 408     DWORD cchNameString = 0;
 409 
 410 
 411     __try
 412     {
 413         // Open a system certificate store.
 414         if ((pszCertStoreName = env-&gt;GetStringUTFChars(jCertStoreName, NULL))
 415             == NULL) {
 416             __leave;
 417         }
 418         if ((hCertStore = ::CertOpenSystemStore(NULL, pszCertStoreName))
 419             == NULL) {
 420 
 421             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
 422             __leave;
 423         }
 424 
 425         // Determine clazz and method ID to generate certificate
 426         jclass clazzArrayList = env-&gt;FindClass(&quot;java/util/ArrayList&quot;);
 427         if (clazzArrayList == NULL) {
 428             __leave;
 429         }
 430 
 431         jmethodID mNewArrayList = env-&gt;GetMethodID(clazzArrayList, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 432         if (mNewArrayList == NULL) {
 433             __leave;
 434         }
 435 
 436         jclass clazzOfThis = env-&gt;GetObjectClass(obj);
 437         if (clazzOfThis == NULL) {
 438             __leave;
 439         }
 440 
 441         jmethodID mGenCert = env-&gt;GetMethodID(clazzOfThis,
 442                                               &quot;generateCertificate&quot;,
 443                                               &quot;([BLjava/util/Collection;)V&quot;);
 444         if (mGenCert == NULL) {
 445             __leave;
 446         }
 447 
 448         // Determine method ID to generate certificate chain
 449         jmethodID mGenCertChain = env-&gt;GetMethodID(clazzOfThis,
 450                                                    &quot;generateCertificateChain&quot;,
 451                                                    &quot;(Ljava/lang/String;Ljava/util/Collection;)V&quot;);
 452         if (mGenCertChain == NULL) {
 453             __leave;
 454         }
 455 
 456         // Determine method ID to generate RSA certificate chain
 457         jmethodID mGenKeyAndCertChain = env-&gt;GetMethodID(clazzOfThis,
 458                                                    &quot;generateKeyAndCertificateChain&quot;,
 459                                                    &quot;(ZLjava/lang/String;JJILjava/util/Collection;)V&quot;);
 460         if (mGenKeyAndCertChain == NULL) {
 461             __leave;
 462         }
 463 
 464         // Use CertEnumCertificatesInStore to get the certificates
 465         // from the open store. pCertContext must be reset to
 466         // NULL to retrieve the first certificate in the store.
 467         while (pCertContext = ::CertEnumCertificatesInStore(hCertStore, pCertContext))
 468         {
 469             PP(&quot;--------------------------&quot;);
 470             // Check if private key available - client authentication certificate
 471             // must have private key available.
 472             HCRYPTPROV hCryptProv = NULL;
 473             DWORD dwKeySpec = 0;
 474             HCRYPTKEY hUserKey = NULL;
 475             BOOL bCallerFreeProv = FALSE;
 476             BOOL bHasNoPrivateKey = FALSE;
 477             DWORD dwPublicKeyLength = 0;
 478 
 479             // First, probe it silently
 480             if (::CryptAcquireCertificatePrivateKey(pCertContext,
 481                     CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG | CRYPT_ACQUIRE_SILENT_FLAG, NULL,
 482                     &amp;hCryptProv, &amp;dwKeySpec, &amp;bCallerFreeProv) == FALSE
 483                 &amp;&amp; GetLastError() != NTE_SILENT_CONTEXT)
 484             {
 485                 PP(&quot;bHasNoPrivateKey = TRUE!&quot;);
 486                 bHasNoPrivateKey = TRUE;
 487             }
 488             else
 489             {
 490                 if (bCallerFreeProv == TRUE) {
 491                     ::CryptReleaseContext(hCryptProv, NULL); // deprecated
 492                     bCallerFreeProv = FALSE;
 493                 }
 494 
 495                 // Second, acquire the key normally (not silently)
 496                 if (::CryptAcquireCertificatePrivateKey(pCertContext, CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG, NULL,
 497                         &amp;hCryptProv, &amp;dwKeySpec, &amp;bCallerFreeProv) == FALSE)
 498                 {
 499                     PP(&quot;bHasNoPrivateKey = TRUE!!&quot;);
 500                     bHasNoPrivateKey = TRUE;
 501                 }
 502                 else
 503                 {
 504                     if ((dwKeySpec &amp; CERT_NCRYPT_KEY_SPEC) == CERT_NCRYPT_KEY_SPEC) {
 505                         PP(&quot;CNG %I64d&quot;, hCryptProv);
 506                     } else {
 507                         // Private key is available
 508                         BOOL bGetUserKey = ::CryptGetUserKey(hCryptProv, dwKeySpec, &amp;hUserKey); //deprecated
 509 
 510                         // Skip certificate if cannot find private key
 511                         if (bGetUserKey == FALSE) {
 512                             if (bCallerFreeProv)
 513                                 ::CryptReleaseContext(hCryptProv, NULL); // deprecated
 514                             continue;
 515                         }
 516 
 517                         // Set cipher mode to ECB
 518                         DWORD dwCipherMode = CRYPT_MODE_ECB;
 519                         ::CryptSetKeyParam(hUserKey, KP_MODE, (BYTE*)&amp;dwCipherMode, NULL); //deprecated
 520                         PP(&quot;CAPI %I64d %I64d&quot;, hCryptProv, hUserKey);
 521                     }
 522                     // If the private key is present in smart card, we may not be able to
 523                     // determine the key length by using the private key handle. However,
 524                     // since public/private key pairs must have the same length, we could
 525                     // determine the key length of the private key by using the public key
 526                     // in the certificate.
 527                     dwPublicKeyLength = ::CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
 528                             &amp;(pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo));
 529                 }
 530             }
 531             PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
 532 
 533             // Build certificate chain by using system certificate store.
 534             // Add cert chain into collection for any key usage.
 535             //
 536             if (GetCertificateChain(OID_EKU_ANY, pCertContext, &amp;pCertChainContext))
 537             {
 538                 for (DWORD i = 0; i &lt; pCertChainContext-&gt;cChain; i++)
 539                 {
 540                     // Found cert chain
 541                     PCERT_SIMPLE_CHAIN rgpChain =
 542                         pCertChainContext-&gt;rgpChain[i];
 543 
 544                     // Create ArrayList to store certs in each chain
 545                     jobject jArrayList =
 546                         env-&gt;NewObject(clazzArrayList, mNewArrayList);
 547                     if (jArrayList == NULL) {
 548                         __leave;
 549                     }
 550 
 551                     // Cleanup the previous allocated name
 552                     if (pszNameString) {
 553                         delete [] pszNameString;
 554                         pszNameString = NULL;
 555                     }
 556 
 557                     for (unsigned int j=0; j &lt; rgpChain-&gt;cElement; j++)
 558                     {
 559                         PCERT_CHAIN_ELEMENT rgpElement =
 560                             rgpChain-&gt;rgpElement[j];
 561                         PCCERT_CONTEXT pc = rgpElement-&gt;pCertContext;
 562 
 563                         // Retrieve the friendly name of the first certificate
 564                         // in the chain
 565                         if (j == 0) {
 566 
 567                             // If the cert&#39;s name cannot be retrieved then
 568                             // pszNameString remains set to NULL.
 569                             // (An alias name will be generated automatically
 570                             // when storing this cert in the keystore.)
 571 
 572                             // Get length of friendly name
 573                             if ((cchNameString = CertGetNameString(pc,
 574                                 CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0, NULL,
 575                                 NULL, 0)) &gt; 1) {
 576 
 577                                 // Found friendly name
 578                                 pszNameString = new (env) char[cchNameString];
 579                                 if (pszNameString == NULL) {
 580                                     __leave;
 581                                 }
 582 
 583                                 CertGetNameString(pc,
 584                                     CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0, NULL,
 585                                     pszNameString, cchNameString);
 586                             }
 587                         }
 588 
 589                         BYTE* pbCertEncoded = pc-&gt;pbCertEncoded;
 590                         DWORD cbCertEncoded = pc-&gt;cbCertEncoded;
 591 
 592                         // Allocate and populate byte array
 593                         jbyteArray byteArray = env-&gt;NewByteArray(cbCertEncoded);
 594                         if (byteArray == NULL) {
 595                             __leave;
 596                         }
 597                         env-&gt;SetByteArrayRegion(byteArray, 0, cbCertEncoded,
 598                             (jbyte*) pbCertEncoded);
 599 
 600                         // Generate certificate from byte array and store into
 601                         // cert collection
 602                         env-&gt;CallVoidMethod(obj, mGenCert, byteArray, jArrayList);
 603                     }
 604 
 605                     // Usually pszNameString should be non-NULL. It&#39;s either
 606                     // the friendly name or an element from the subject name
 607                     // or SAN.
 608                     if (pszNameString)
 609                     {
 610                         PP(&quot;%s: %s&quot;, pszNameString, pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.Algorithm.pszObjId);
 611                         if (bHasNoPrivateKey)
 612                         {
 613                             // Generate certificate chain and store into cert chain
 614                             // collection
 615                             jstring name = env-&gt;NewStringUTF(pszNameString);
 616                             if (name == NULL) {
 617                                 __leave;
 618                             }
 619                             env-&gt;CallVoidMethod(obj, mGenCertChain,
 620                                 name,
 621                                 jArrayList);
 622                         }
 623                         else
 624                         {
 625                             if (hUserKey) {
 626                                 // Only accept RSA for CAPI
 627                                 DWORD dwData = CALG_RSA_KEYX;
 628                                 DWORD dwSize = sizeof(DWORD);
 629                                 ::CryptGetKeyParam(hUserKey, KP_ALGID, (BYTE*)&amp;dwData, //deprecated
 630                                         &amp;dwSize, NULL);
 631                                 if ((dwData &amp; ALG_TYPE_RSA) == ALG_TYPE_RSA)
 632                                 {
 633                                     // Generate RSA certificate chain and store into cert
 634                                     // chain collection
 635                                     jstring name = env-&gt;NewStringUTF(pszNameString);
 636                                     if (name == NULL) {
 637                                         __leave;
 638                                     }
 639                                     env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
 640                                             1,
 641                                             name,
 642                                             (jlong) hCryptProv, (jlong) hUserKey,
 643                                             dwPublicKeyLength, jArrayList);
 644                                 }
 645                             } else {
 646                                 // Only accept EC for CNG
 647                                 BYTE buffer[32];
 648                                 DWORD len = 0;
 649                                 if (::NCryptGetProperty(
 650                                         hCryptProv, NCRYPT_ALGORITHM_PROPERTY,
 651                                         (PBYTE)buffer, 32, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {
 652                                     if (buffer[0] == &#39;E&#39; &amp;&amp; buffer[2] == &#39;C&#39;
 653                                             &amp;&amp; (dwPublicKeyLength == 256
 654                                                     || dwPublicKeyLength == 384
 655                                                     || dwPublicKeyLength == 521)) {
 656                                         jstring name = env-&gt;NewStringUTF(pszNameString);
 657                                         if (name == NULL) {
 658                                             __leave;
 659                                         }
 660                                         env-&gt;CallVoidMethod(obj, mGenKeyAndCertChain,
 661                                             0,
 662                                             name,
 663                                             (jlong) hCryptProv, 0,
 664                                             dwPublicKeyLength, jArrayList);
 665                                     }
 666                                 }
 667                             }
 668                         }
 669                     }
 670                 }
 671 
 672                 // Free cert chain
 673                 if (pCertChainContext)
 674                     ::CertFreeCertificateChain(pCertChainContext);
 675             } else {
 676                 PP(&quot;GetCertificateChain failed %d&quot;, GetLastError());
 677             }
 678         }
 679     }
 680     __finally
 681     {
 682         if (hCertStore)
 683             ::CertCloseStore(hCertStore, 0);
 684 
 685         if (pszCertStoreName)
 686             env-&gt;ReleaseStringUTFChars(jCertStoreName, pszCertStoreName);
 687 
 688         if (pszNameString)
 689             delete [] pszNameString;
 690     }
 691 }
 692 
 693 
 694 /*
 695  * Class:     sun_security_mscapi_Key
 696  * Method:    cleanUp
 697  * Signature: (JJ)V
 698  */
 699 JNIEXPORT void JNICALL Java_sun_security_mscapi_Key_cleanUp
 700   (JNIEnv *env, jclass clazz, jlong hCryptProv, jlong hCryptKey)
 701 {
 702     if (hCryptKey != NULL)
 703         ::CryptDestroyKey((HCRYPTKEY) hCryptKey); // deprecated
 704 
 705     if (hCryptProv != NULL)
 706         ::CryptReleaseContext((HCRYPTPROV) hCryptProv, NULL); // deprecated
 707 }
 708 
 709 /*
 710  * Class:     sun_security_mscapi_CSignature
 711  * Method:    signHash
 712  * Signature: (Z[BILjava/lang/String;JJ)[B
 713  */
 714 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_signHash
 715   (JNIEnv *env, jclass clazz, jboolean noHashOID, jbyteArray jHash,
 716         jint jHashSize, jstring jHashAlgorithm, jlong hCryptProv,
 717         jlong hCryptKey)
 718 {
 719     HCRYPTHASH hHash = NULL;
 720     jbyte* pHashBuffer = NULL;
 721     jbyte* pSignedHashBuffer = NULL;
 722     jbyteArray jSignedHash = NULL;
 723     HCRYPTPROV hCryptProvAlt = NULL;
 724 
 725     __try
 726     {
 727         // Map hash algorithm
 728         ALG_ID algId = MapHashAlgorithm(env, jHashAlgorithm);
 729 
 730         // Acquire a hash object handle.
 731         if (::CryptCreateHash(HCRYPTPROV(hCryptProv), algId, 0, 0, &amp;hHash) == FALSE) //deprecated
 732         {
 733             // Failover to using the PROV_RSA_AES CSP
 734 
 735             DWORD cbData = 256;
 736             BYTE pbData[256];
 737             pbData[0] = &#39;\0&#39;;
 738 
 739             // Get name of the key container
 740             ::CryptGetProvParam((HCRYPTPROV)hCryptProv, PP_CONTAINER, //deprecated
 741                 (BYTE *)pbData, &amp;cbData, 0);
 742 
 743             // Acquire an alternative CSP handle
 744             if (::CryptAcquireContext(&amp;hCryptProvAlt, LPCSTR(pbData), NULL, //deprecated
 745                 PROV_RSA_AES, 0) == FALSE)
 746             {
 747 
 748                 ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
 749                 __leave;
 750             }
 751 
 752             // Acquire a hash object handle.
 753             if (::CryptCreateHash(HCRYPTPROV(hCryptProvAlt), algId, 0, 0, //deprecated
 754                 &amp;hHash) == FALSE)
 755             {
 756                 ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
 757                 __leave;
 758             }
 759         }
 760 
 761         // Copy hash from Java to native buffer
 762         pHashBuffer = new (env) jbyte[jHashSize];
 763         if (pHashBuffer == NULL) {
 764             __leave;
 765         }
 766         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
 767 
 768         // Set hash value in the hash object
 769         if (::CryptSetHashParam(hHash, HP_HASHVAL, (BYTE*)pHashBuffer, NULL) == FALSE) //deprecated
 770         {
 771             ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
 772             __leave;
 773         }
 774 
 775         // Determine key spec.
 776         DWORD dwKeySpec = AT_SIGNATURE;
 777         ALG_ID dwAlgId;
 778         DWORD dwAlgIdLen = sizeof(ALG_ID);
 779 
 780         if (! ::CryptGetKeyParam((HCRYPTKEY) hCryptKey, KP_ALGID, (BYTE*)&amp;dwAlgId, &amp;dwAlgIdLen, 0)) { //deprecated
 781             ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
 782             __leave;
 783 
 784         }
 785         if (CALG_RSA_KEYX == dwAlgId) {
 786             dwKeySpec = AT_KEYEXCHANGE;
 787         }
 788 
 789         // Determine size of buffer
 790         DWORD dwBufLen = 0;
 791         DWORD dwFlags = 0;
 792 
 793         if (noHashOID == JNI_TRUE) {
 794             dwFlags = CRYPT_NOHASHOID; // omit hash OID in NONEwithRSA signature
 795         }
 796 
 797         if (::CryptSignHash(hHash, dwKeySpec, NULL, dwFlags, NULL, &amp;dwBufLen) == FALSE) //deprecated
 798         {
 799             ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
 800             __leave;
 801         }
 802 
 803         pSignedHashBuffer = new (env) jbyte[dwBufLen];
 804         if (pSignedHashBuffer == NULL) {
 805             __leave;
 806         }
 807         if (::CryptSignHash(hHash, dwKeySpec, NULL, dwFlags, (BYTE*)pSignedHashBuffer, &amp;dwBufLen) == FALSE) //deprecated
 808         {
 809             ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
 810             __leave;
 811         }
 812 
 813         // Create new byte array
 814         jbyteArray temp = env-&gt;NewByteArray(dwBufLen);
 815         if (temp == NULL) {
 816             __leave;
 817         }
 818 
 819         // Copy data from native buffer
 820         env-&gt;SetByteArrayRegion(temp, 0, dwBufLen, pSignedHashBuffer);
 821 
 822         jSignedHash = temp;
 823     }
 824     __finally
 825     {
 826         if (pSignedHashBuffer)
 827             delete [] pSignedHashBuffer;
 828 
 829         if (pHashBuffer)
 830             delete [] pHashBuffer;
 831 
 832         if (hHash)
 833             ::CryptDestroyHash(hHash); //deprecated
 834 
 835         if (hCryptProvAlt)
 836             ::CryptReleaseContext(hCryptProvAlt, 0); // deprecated
 837     }
 838 
 839     return jSignedHash;
 840 }
 841 
 842 /*
 843  * Class:     sun_security_mscapi_CSignature
 844  * Method:    signCngHash
 845  * Signature: (I[BIILjava/lang/String;JJ)[B
 846  */
 847 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_signCngHash
 848   (JNIEnv *env, jclass clazz, jint type, jbyteArray jHash,
 849         jint jHashSize, jint saltLen, jstring jHashAlgorithm, jlong hCryptProv,
 850         jlong hCryptKey)
 851 {
 852     jbyteArray jSignedHash = NULL;
 853 
 854     jbyte* pHashBuffer = NULL;
 855     jbyte* pSignedHashBuffer = NULL;
 856     NCRYPT_KEY_HANDLE hk = NULL;
 857 
 858     __try
 859     {
 860         if (hCryptKey == 0) {
 861             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
 862         } else {
 863             SS_CHECK(::NCryptTranslateHandle(
 864                 NULL,
 865                 &amp;hk,
 866                 hCryptProv,
 867                 hCryptKey,
 868                 NULL,
 869                 0));
 870         }
 871 
 872         // Copy hash from Java to native buffer
 873         pHashBuffer = new (env) jbyte[jHashSize];
 874         if (pHashBuffer == NULL) {
 875             __leave;
 876         }
 877         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
 878 
 879         VOID* param;
 880         DWORD dwFlags;
 881 
 882         switch (type) {
 883         case 0:
 884             param = NULL;
 885             dwFlags = 0;
 886             break;
 887         case 1:
 888             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
 889             pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
 890             if (pkcs1Info.pszAlgId == NULL) {
 891                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
 892                         &quot;Unrecognised hash algorithm&quot;);
 893                 __leave;
 894             }
 895             param = &amp;pkcs1Info;
 896             dwFlags = BCRYPT_PAD_PKCS1;
 897             break;
 898         case 2:
 899             BCRYPT_PSS_PADDING_INFO pssInfo;
 900             pssInfo.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
 901             pssInfo.cbSalt = saltLen;
 902             if (pssInfo.pszAlgId == NULL) {
 903                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
 904                         &quot;Unrecognised hash algorithm&quot;);
 905                 __leave;
 906             }
 907             param = &amp;pssInfo;
 908             dwFlags = BCRYPT_PAD_PSS;
 909             break;
 910         }
 911 
 912         DWORD jSignedHashSize = 0;
 913         SS_CHECK(::NCryptSignHash(
 914                 hk,
 915                 param,
 916                 (BYTE*)pHashBuffer, jHashSize,
 917                 NULL, 0, &amp;jSignedHashSize,
 918                 dwFlags
 919                 ));
 920 
 921         pSignedHashBuffer = new (env) jbyte[jSignedHashSize];
 922         if (pSignedHashBuffer == NULL) {
 923             __leave;
 924         }
 925 
 926         SS_CHECK(::NCryptSignHash(
 927                 hk,
 928                 param,
 929                 (BYTE*)pHashBuffer, jHashSize,
 930                 (BYTE*)pSignedHashBuffer, jSignedHashSize, &amp;jSignedHashSize,
 931                 dwFlags
 932                 ));
 933 
 934         // Create new byte array
 935         jbyteArray temp = env-&gt;NewByteArray(jSignedHashSize);
 936         if (temp == NULL) {
 937             __leave;
 938         }
 939 
 940         // Copy data from native buffer
 941         env-&gt;SetByteArrayRegion(temp, 0, jSignedHashSize, pSignedHashBuffer);
 942 
 943         jSignedHash = temp;
 944     }
 945     __finally
 946     {
 947         if (pSignedHashBuffer)
 948             delete [] pSignedHashBuffer;
 949 
 950         if (pHashBuffer)
 951             delete [] pHashBuffer;
 952 
 953         if (hCryptKey != 0 &amp;&amp; hk != NULL)
 954             ::NCryptFreeObject(hk);
 955     }
 956 
 957     return jSignedHash;
 958 }
 959 
 960 /*
 961  * Class:     sun_security_mscapi_CSignature
 962  * Method:    verifySignedHash
 963  * Signature: ([BIL/java/lang/String;[BIJJ)Z
 964  */
 965 JNIEXPORT jboolean JNICALL Java_sun_security_mscapi_CSignature_verifySignedHash
 966   (JNIEnv *env, jclass clazz, jbyteArray jHash, jint jHashSize,
 967         jstring jHashAlgorithm, jbyteArray jSignedHash, jint jSignedHashSize,
 968         jlong hCryptProv, jlong hCryptKey)
 969 {
 970     HCRYPTHASH hHash = NULL;
 971     jbyte* pHashBuffer = NULL;
 972     jbyte* pSignedHashBuffer = NULL;
 973     DWORD dwSignedHashBufferLen = jSignedHashSize;
 974     jboolean result = JNI_FALSE;
 975     HCRYPTPROV hCryptProvAlt = NULL;
 976 
 977     __try
 978     {
 979         // Map hash algorithm
 980         ALG_ID algId = MapHashAlgorithm(env, jHashAlgorithm);
 981 
 982         // Acquire a hash object handle.
 983         if (::CryptCreateHash(HCRYPTPROV(hCryptProv), algId, 0, 0, &amp;hHash)
 984             == FALSE)
 985         {
 986             // Failover to using the PROV_RSA_AES CSP
 987 
 988             DWORD cbData = 256;
 989             BYTE pbData[256];
 990             pbData[0] = &#39;\0&#39;;
 991 
 992             // Get name of the key container
 993             ::CryptGetProvParam((HCRYPTPROV)hCryptProv, PP_CONTAINER, //deprecated
 994                 (BYTE *)pbData, &amp;cbData, 0);
 995 
 996             // Acquire an alternative CSP handle
 997             if (::CryptAcquireContext(&amp;hCryptProvAlt, LPCSTR(pbData), NULL, //deprecated
 998                 PROV_RSA_AES, 0) == FALSE)
 999             {
1000 
1001                 ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
1002                 __leave;
1003             }
1004 
1005             // Acquire a hash object handle.
1006             if (::CryptCreateHash(HCRYPTPROV(hCryptProvAlt), algId, 0, 0,
1007                 &amp;hHash) == FALSE)
1008             {
1009                 ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
1010                 __leave;
1011             }
1012         }
1013 
1014         // Copy hash and signedHash from Java to native buffer
1015         pHashBuffer = new (env) jbyte[jHashSize];
1016         if (pHashBuffer == NULL) {
1017             __leave;
1018         }
1019         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
1020 
1021         pSignedHashBuffer = new (env) jbyte[jSignedHashSize];
1022         if (pSignedHashBuffer == NULL) {
1023             __leave;
1024         }
1025         env-&gt;GetByteArrayRegion(jSignedHash, 0, jSignedHashSize,
1026             pSignedHashBuffer);
1027 
1028         // Set hash value in the hash object
1029         if (::CryptSetHashParam(hHash, HP_HASHVAL, (BYTE*) pHashBuffer, NULL) //deprecated
1030             == FALSE)
1031         {
1032             ThrowException(env, SIGNATURE_EXCEPTION, GetLastError());
1033             __leave;
1034         }
1035 
1036         // For RSA, the hash encryption algorithm is normally the same as the
1037         // public key algorithm, so AT_SIGNATURE is used.
1038 
1039         // Verify the signature
1040         if (::CryptVerifySignatureA(hHash, (BYTE *) pSignedHashBuffer, //deprecated
1041             dwSignedHashBufferLen, (HCRYPTKEY) hCryptKey, NULL, 0) == TRUE)
1042         {
1043             result = JNI_TRUE;
1044         }
1045     }
1046 
1047     __finally
1048     {
1049         if (pSignedHashBuffer)
1050             delete [] pSignedHashBuffer;
1051 
1052         if (pHashBuffer)
1053             delete [] pHashBuffer;
1054 
1055         if (hHash)
1056             ::CryptDestroyHash(hHash); //deprecated
1057 
1058         if (hCryptProvAlt)
1059             ::CryptReleaseContext(hCryptProvAlt, 0); // deprecated
1060     }
1061 
1062     return result;
1063 }
1064 
1065 /*
1066  * Class:     sun_security_mscapi_CSignature
1067  * Method:    verifyCngSignedHash
1068  * Signature: (I[BI[BIILjava/lang/String;JJ)Z
1069  */
1070 JNIEXPORT jboolean JNICALL Java_sun_security_mscapi_CSignature_verifyCngSignedHash
1071   (JNIEnv *env, jclass clazz, jint type,
1072         jbyteArray jHash, jint jHashSize,
1073         jbyteArray jSignedHash, jint jSignedHashSize,
1074         jint saltLen, jstring jHashAlgorithm,
1075         jlong hCryptProv, jlong hCryptKey)
1076 {
1077     jbyte* pHashBuffer = NULL;
1078     jbyte* pSignedHashBuffer = NULL;
1079     jboolean result = JNI_FALSE;
1080     NCRYPT_KEY_HANDLE hk = NULL;
1081 
1082     __try
1083     {
1084         if (hCryptKey == 0) {
1085             hk = (NCRYPT_KEY_HANDLE)hCryptProv;
1086         } else {
1087             SS_CHECK(::NCryptTranslateHandle(
1088                 NULL,
1089                 &amp;hk,
1090                 hCryptProv,
1091                 hCryptKey,
1092                 NULL,
1093                 0));
1094         }
1095 
1096         // Copy hash and signedHash from Java to native buffer
1097         pHashBuffer = new (env) jbyte[jHashSize];
1098         if (pHashBuffer == NULL) {
1099             __leave;
1100         }
1101         env-&gt;GetByteArrayRegion(jHash, 0, jHashSize, pHashBuffer);
1102 
1103         pSignedHashBuffer = new (env) jbyte[jSignedHashSize];
1104         if (pSignedHashBuffer == NULL) {
1105             __leave;
1106         }
1107         env-&gt;GetByteArrayRegion(jSignedHash, 0, jSignedHashSize,
1108             pSignedHashBuffer);
1109 
1110         VOID* param;
1111         DWORD dwFlags;
1112 
1113         switch (type) {
1114         case 0:
1115             param = NULL;
1116             dwFlags = 0;
1117             break;
1118         case 1:
1119             BCRYPT_PKCS1_PADDING_INFO pkcs1Info;
1120             pkcs1Info.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
1121             if (pkcs1Info.pszAlgId == NULL) {
1122                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
1123                         &quot;Unrecognised hash algorithm&quot;);
1124                 __leave;
1125             }
1126             param = &amp;pkcs1Info;
1127             dwFlags = NCRYPT_PAD_PKCS1_FLAG;
1128             break;
1129         case 2:
1130             BCRYPT_PSS_PADDING_INFO pssInfo;
1131             pssInfo.pszAlgId = MapHashIdentifier(env, jHashAlgorithm);
1132             pssInfo.cbSalt = saltLen;
1133             if (pssInfo.pszAlgId == NULL) {
1134                 ThrowExceptionWithMessage(env, SIGNATURE_EXCEPTION,
1135                         &quot;Unrecognised hash algorithm&quot;);
1136                 __leave;
1137             }
1138             param = &amp;pssInfo;
1139             dwFlags = NCRYPT_PAD_PSS_FLAG;
1140             break;
1141         }
1142 
1143         if (::NCryptVerifySignature(hk, param,
1144                 (BYTE *) pHashBuffer, jHashSize,
1145                 (BYTE *) pSignedHashBuffer, jSignedHashSize,
1146                 dwFlags) == ERROR_SUCCESS)
1147         {
1148             result = JNI_TRUE;
1149         }
1150     }
1151 
1152     __finally
1153     {
1154         if (pSignedHashBuffer)
1155             delete [] pSignedHashBuffer;
1156 
1157         if (pHashBuffer)
1158             delete [] pHashBuffer;
1159 
1160         if (hCryptKey != 0 &amp;&amp; hk != NULL)
1161             ::NCryptFreeObject(hk);
1162     }
1163 
1164     return result;
1165 }
1166 
1167 #define DUMP_PROP(p) \
1168     if (::NCryptGetProperty(hKey, p, (PBYTE)buffer, 8192, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) { \
1169         sprintf(header, &quot;%s %ls&quot;, #p, p); \
1170         dump(header, buffer, len); \
1171     }
1172 
1173 #define EXPORT_BLOB(p) \
1174     desc.cBuffers = 0; \
1175     if (::NCryptExportKey(hKey, NULL, p, &amp;desc, (PBYTE)buffer, 8192, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) { \
1176         sprintf(header, &quot;%s %ls (%ld)&quot;, #p, p, desc.cBuffers); \
1177         dump(header, buffer, len); \
1178         for (int i = 0; i &lt; (int)desc.cBuffers; i++) { \
1179             sprintf(header, &quot;desc %ld&quot;, desc.pBuffers[i].BufferType); \
1180             dump(header, (PBYTE)desc.pBuffers[i].pvBuffer, desc.pBuffers[i].cbBuffer); \
1181         } \
1182     }
1183 
1184 void showProperty(NCRYPT_HANDLE hKey) {
1185     char header[100];
1186     BYTE buffer[8192];
1187     DWORD len = 9;
1188     NCryptBufferDesc desc;
1189     DUMP_PROP(NCRYPT_ALGORITHM_GROUP_PROPERTY);
1190     DUMP_PROP(NCRYPT_ALGORITHM_PROPERTY);
1191     DUMP_PROP(NCRYPT_ASSOCIATED_ECDH_KEY);
1192     DUMP_PROP(NCRYPT_BLOCK_LENGTH_PROPERTY);
1193     DUMP_PROP(NCRYPT_CERTIFICATE_PROPERTY);
1194     DUMP_PROP(NCRYPT_DH_PARAMETERS_PROPERTY);
1195     DUMP_PROP(NCRYPT_EXPORT_POLICY_PROPERTY);
1196     DUMP_PROP(NCRYPT_IMPL_TYPE_PROPERTY);
1197     DUMP_PROP(NCRYPT_KEY_TYPE_PROPERTY);
1198     DUMP_PROP(NCRYPT_KEY_USAGE_PROPERTY);
1199     DUMP_PROP(NCRYPT_LAST_MODIFIED_PROPERTY);
1200     DUMP_PROP(NCRYPT_LENGTH_PROPERTY);
1201     DUMP_PROP(NCRYPT_LENGTHS_PROPERTY);
1202     DUMP_PROP(NCRYPT_MAX_NAME_LENGTH_PROPERTY);
1203     DUMP_PROP(NCRYPT_NAME_PROPERTY);
1204     DUMP_PROP(NCRYPT_PIN_PROMPT_PROPERTY);
1205     DUMP_PROP(NCRYPT_PIN_PROPERTY);
1206     DUMP_PROP(NCRYPT_PROVIDER_HANDLE_PROPERTY);
1207     DUMP_PROP(NCRYPT_READER_PROPERTY);
1208     DUMP_PROP(NCRYPT_ROOT_CERTSTORE_PROPERTY);
1209     DUMP_PROP(NCRYPT_SCARD_PIN_ID);
1210     DUMP_PROP(NCRYPT_SCARD_PIN_INFO);
1211     DUMP_PROP(NCRYPT_SECURE_PIN_PROPERTY);
1212     DUMP_PROP(NCRYPT_SECURITY_DESCR_PROPERTY);
1213     DUMP_PROP(NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY);
1214     DUMP_PROP(NCRYPT_SMARTCARD_GUID_PROPERTY);
1215     DUMP_PROP(NCRYPT_UI_POLICY_PROPERTY);
1216     DUMP_PROP(NCRYPT_UNIQUE_NAME_PROPERTY);
1217     DUMP_PROP(NCRYPT_USE_CONTEXT_PROPERTY);
1218     DUMP_PROP(NCRYPT_USE_COUNT_ENABLED_PROPERTY);
1219     DUMP_PROP(NCRYPT_USE_COUNT_PROPERTY);
1220     DUMP_PROP(NCRYPT_USER_CERTSTORE_PROPERTY);
1221     DUMP_PROP(NCRYPT_VERSION_PROPERTY);
1222     DUMP_PROP(NCRYPT_WINDOW_HANDLE_PROPERTY);
1223 
1224     EXPORT_BLOB(BCRYPT_DH_PRIVATE_BLOB);
1225     EXPORT_BLOB(BCRYPT_DH_PUBLIC_BLOB);
1226     EXPORT_BLOB(BCRYPT_DSA_PRIVATE_BLOB);
1227     EXPORT_BLOB(BCRYPT_DSA_PUBLIC_BLOB);
1228     EXPORT_BLOB(BCRYPT_ECCPRIVATE_BLOB);
1229     EXPORT_BLOB(BCRYPT_ECCPUBLIC_BLOB);
1230     EXPORT_BLOB(BCRYPT_PUBLIC_KEY_BLOB);
1231     EXPORT_BLOB(BCRYPT_PRIVATE_KEY_BLOB);
1232     EXPORT_BLOB(BCRYPT_RSAFULLPRIVATE_BLOB);
1233     EXPORT_BLOB(BCRYPT_RSAPRIVATE_BLOB);
1234     EXPORT_BLOB(BCRYPT_RSAPUBLIC_BLOB);
1235     EXPORT_BLOB(LEGACY_DH_PRIVATE_BLOB);
1236     EXPORT_BLOB(LEGACY_DH_PUBLIC_BLOB);
1237     EXPORT_BLOB(LEGACY_DSA_PRIVATE_BLOB);
1238     EXPORT_BLOB(LEGACY_DSA_PUBLIC_BLOB);
1239     EXPORT_BLOB(LEGACY_RSAPRIVATE_BLOB);
1240     EXPORT_BLOB(LEGACY_RSAPUBLIC_BLOB);
1241     EXPORT_BLOB(NCRYPT_CIPHER_KEY_BLOB);
1242     EXPORT_BLOB(NCRYPT_OPAQUETRANSPORT_BLOB);
1243     EXPORT_BLOB(NCRYPT_PKCS7_ENVELOPE_BLOB);
1244     //EXPORT_BLOB(NCRYPTBUFFER_CERT_BLOB);
1245     //EXPORT_BLOB(NCRYPT_PKCS8_PRIVATE_KEY_BLOB);
1246     BCryptBuffer bb;
1247     bb.BufferType = NCRYPTBUFFER_PKCS_SECRET;
1248     bb.cbBuffer = 18;
1249     bb.pvBuffer = L&quot;changeit&quot;;
1250     BCryptBufferDesc bbd;
1251     bbd.ulVersion = 0;
1252     bbd.cBuffers = 1;
1253     bbd.pBuffers = &amp;bb;
1254     if(::NCryptExportKey(hKey, NULL, NCRYPT_PKCS8_PRIVATE_KEY_BLOB, NULL,
1255             (PBYTE)buffer, 8192, &amp;len, NCRYPT_SILENT_FLAG) == ERROR_SUCCESS) {
1256         sprintf(header, &quot;NCRYPT_PKCS8_PRIVATE_KEY_BLOB %ls&quot;, NCRYPT_PKCS8_PRIVATE_KEY_BLOB);
1257         dump(header, buffer, len);
1258     }
1259     EXPORT_BLOB(NCRYPT_PROTECTED_KEY_BLOB);
1260 }
1261 
1262 /*
1263  * Class:     sun_security_mscapi_CKeyPairGenerator_RSA
1264  * Method:    generateCKeyPair
1265  * Signature: (Ljava/lang/String;ILjava/lang/String;)Lsun/security/mscapi/CKeyPair;
1266  */
1267 JNIEXPORT jobject JNICALL Java_sun_security_mscapi_CKeyPairGenerator_00024RSA_generateCKeyPair
1268   (JNIEnv *env, jclass clazz, jstring alg, jint keySize, jstring keyContainerName)
1269 {
1270     HCRYPTPROV hCryptProv = NULL;
1271     HCRYPTKEY hKeyPair;
1272     DWORD dwFlags = (keySize &lt;&lt; 16) | CRYPT_EXPORTABLE;
1273     jobject keypair = NULL;
1274     const char* pszKeyContainerName = NULL; // UUID
1275 
1276     __try
1277     {
1278         if ((pszKeyContainerName =
1279             env-&gt;GetStringUTFChars(keyContainerName, NULL)) == NULL) {
1280             __leave;
1281         }
1282 
1283         // Acquire a CSP context (create a new key container).
1284         // Prefer a PROV_RSA_AES CSP, when available, due to its support
1285         // for SHA-2-based signatures.
1286         if (::CryptAcquireContext( //deprecated
1287             &amp;hCryptProv,
1288             pszKeyContainerName,
1289             NULL,
1290             PROV_RSA_AES,
1291             CRYPT_NEWKEYSET) == FALSE)
1292         {
1293             // Failover to using the default CSP (PROV_RSA_FULL)
1294 
1295             if (::CryptAcquireContext( //deprecated
1296                 &amp;hCryptProv,
1297                 pszKeyContainerName,
1298                 NULL,
1299                 PROV_RSA_FULL,
1300                 CRYPT_NEWKEYSET) == FALSE)
1301             {
1302                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1303                 __leave;
1304             }
1305         }
1306 
1307         // Generate an keypair
1308         if(::CryptGenKey( //deprecated
1309            hCryptProv,
1310            AT_KEYEXCHANGE,
1311            dwFlags,
1312            &amp;hKeyPair) == FALSE)
1313         {
1314             ThrowException(env, KEY_EXCEPTION, GetLastError());
1315             __leave;
1316         }
1317 
1318         // Get the method ID for the CKeyPair constructor
1319         jclass clazzCKeyPair =
1320             env-&gt;FindClass(&quot;sun/security/mscapi/CKeyPair&quot;);
1321         if (clazzCKeyPair == NULL) {
1322             __leave;
1323         }
1324 
1325         jmethodID mNewCKeyPair =
1326             env-&gt;GetMethodID(clazzCKeyPair, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;JJI)V&quot;);
1327         if (mNewCKeyPair == NULL) {
1328             __leave;
1329         }
1330 
1331         // Create a new keypair
1332         keypair = env-&gt;NewObject(clazzCKeyPair, mNewCKeyPair,
1333             alg, (jlong) hCryptProv, (jlong) hKeyPair, keySize);
1334 
1335     }
1336     __finally
1337     {
1338         //--------------------------------------------------------------------
1339         // Clean up.
1340 
1341         if (pszKeyContainerName)
1342             env-&gt;ReleaseStringUTFChars(keyContainerName, pszKeyContainerName);
1343     }
1344 
1345     return keypair;
1346 }
1347 
1348 /*
1349  * Class:     sun_security_mscapi_CKey
1350  * Method:    getContainerName
1351  * Signature: (J)Ljava/lang/String;
1352  */
1353 JNIEXPORT jstring JNICALL Java_sun_security_mscapi_CKey_getContainerName
1354   (JNIEnv *env, jclass jclazz, jlong hCryptProv)
1355 {
1356     DWORD cbData = 256;
1357     BYTE pbData[256];
1358     pbData[0] = &#39;\0&#39;;
1359 
1360     ::CryptGetProvParam( //deprecated
1361         (HCRYPTPROV)hCryptProv,
1362         PP_CONTAINER,
1363         (BYTE *)pbData,
1364         &amp;cbData,
1365         0);
1366 
1367     return env-&gt;NewStringUTF((const char*)pbData);
1368 }
1369 
1370 /*
1371  * Class:     sun_security_mscapi_CKey
1372  * Method:    getKeyType
1373  * Signature: (J)Ljava/lang/String;
1374  */
1375 JNIEXPORT jstring JNICALL Java_sun_security_mscapi_CKey_getKeyType
1376   (JNIEnv *env, jclass jclazz, jlong hCryptKey)
1377 {
1378     ALG_ID dwAlgId;
1379     DWORD dwAlgIdLen = sizeof(ALG_ID);
1380 
1381     if (::CryptGetKeyParam((HCRYPTKEY) hCryptKey, KP_ALGID, (BYTE*)&amp;dwAlgId, &amp;dwAlgIdLen, 0)) { //deprecated
1382 
1383         if (CALG_RSA_SIGN == dwAlgId) {
1384             return env-&gt;NewStringUTF(&quot;Signature&quot;);
1385 
1386         } else if (CALG_RSA_KEYX == dwAlgId) {
1387             return env-&gt;NewStringUTF(&quot;Exchange&quot;);
1388 
1389         } else {
1390             char buffer[64];
1391             if (sprintf(buffer, &quot;%lu&quot;, dwAlgId)) {
1392                 return env-&gt;NewStringUTF(buffer);
1393             }
1394         }
1395     }
1396 
1397     return env-&gt;NewStringUTF(&quot;&lt;Unknown&gt;&quot;);
1398 }
1399 
1400 /*
1401  * Class:     sun_security_mscapi_CKeyStore
1402  * Method:    storeCertificate
1403  * Signature: (Ljava/lang/String;Ljava/lang/String;[BIJJ)V
1404  */
1405 JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_storeCertificate
1406   (JNIEnv *env, jobject obj, jstring jCertStoreName, jstring jCertAliasName,
1407         jbyteArray jCertEncoding, jint jCertEncodingSize, jlong hCryptProv,
1408         jlong hCryptKey)
1409 {
1410     const char* pszCertStoreName = NULL;
1411     HCERTSTORE hCertStore = NULL;
1412     PCCERT_CONTEXT pCertContext = NULL;
1413     PWCHAR pszCertAliasName = NULL;
1414     jbyte* pbCertEncoding = NULL;
1415     const jchar* jCertAliasChars = NULL;
1416     const char* pszContainerName = NULL;
1417     const char* pszProviderName = NULL;
1418     WCHAR * pwszContainerName = NULL;
1419     WCHAR * pwszProviderName = NULL;
1420 
1421     __try
1422     {
1423         // Open a system certificate store.
1424         if ((pszCertStoreName = env-&gt;GetStringUTFChars(jCertStoreName, NULL))
1425             == NULL) {
1426             __leave;
1427         }
1428         if ((hCertStore = ::CertOpenSystemStore(NULL, pszCertStoreName)) == NULL) {
1429             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1430             __leave;
1431         }
1432 
1433         // Copy encoding from Java to native buffer
1434         pbCertEncoding = new (env) jbyte[jCertEncodingSize];
1435         if (pbCertEncoding == NULL) {
1436             __leave;
1437         }
1438         env-&gt;GetByteArrayRegion(jCertEncoding, 0, jCertEncodingSize, pbCertEncoding);
1439 
1440         // Create a certificate context from the encoded cert
1441         if (!(pCertContext = ::CertCreateCertificateContext(X509_ASN_ENCODING,
1442             (BYTE*) pbCertEncoding, jCertEncodingSize))) {
1443 
1444             ThrowException(env, CERTIFICATE_PARSING_EXCEPTION, GetLastError());
1445             __leave;
1446         }
1447 
1448         // Set the certificate&#39;s friendly name
1449         int size = env-&gt;GetStringLength(jCertAliasName);
1450         pszCertAliasName = new (env) WCHAR[size + 1];
1451         if (pszCertAliasName == NULL) {
1452             __leave;
1453         }
1454 
1455         jCertAliasChars = env-&gt;GetStringChars(jCertAliasName, NULL);
1456         if (jCertAliasChars == NULL) {
1457             __leave;
1458         }
1459         memcpy(pszCertAliasName, jCertAliasChars, size * sizeof(WCHAR));
1460         pszCertAliasName[size] = 0; // append the string terminator
1461 
1462         CRYPT_DATA_BLOB friendlyName = {
1463             sizeof(WCHAR) * (size + 1),
1464             (BYTE *) pszCertAliasName
1465         };
1466 
1467         env-&gt;ReleaseStringChars(jCertAliasName, jCertAliasChars);
1468 
1469         if (! ::CertSetCertificateContextProperty(pCertContext,
1470             CERT_FRIENDLY_NAME_PROP_ID, 0, &amp;friendlyName)) {
1471 
1472             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1473             __leave;
1474         }
1475 
1476         // Attach the certificate&#39;s private key (if supplied)
1477         if (hCryptProv != 0 &amp;&amp; hCryptKey != 0) {
1478 
1479             CRYPT_KEY_PROV_INFO keyProviderInfo;
1480             DWORD dwDataLen;
1481 
1482             // Get the name of the key container
1483             if (! ::CryptGetProvParam( //deprecated
1484                 (HCRYPTPROV) hCryptProv,
1485                 PP_CONTAINER,
1486                 NULL,
1487                 &amp;dwDataLen,
1488                 0)) {
1489 
1490                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1491                 __leave;
1492             }
1493 
1494             pszContainerName = new (env) char[dwDataLen];
1495             if (pszContainerName == NULL) {
1496                 __leave;
1497             }
1498 
1499             if (! ::CryptGetProvParam( //deprecated
1500                 (HCRYPTPROV) hCryptProv,
1501                 PP_CONTAINER,
1502                 (BYTE *) pszContainerName,
1503                 &amp;dwDataLen,
1504                 0)) {
1505 
1506                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1507                 __leave;
1508             }
1509 
1510             // Convert to a wide char string
1511             pwszContainerName = new (env) WCHAR[dwDataLen];
1512             if (pwszContainerName == NULL) {
1513                 __leave;
1514             }
1515 
1516             if (mbstowcs(pwszContainerName, pszContainerName, dwDataLen) == 0) {
1517                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1518                 __leave;
1519             }
1520 
1521             // Set the name of the key container
1522             keyProviderInfo.pwszContainerName = pwszContainerName;
1523 
1524 
1525             // Get the name of the provider
1526             if (! ::CryptGetProvParam( //deprecated
1527                 (HCRYPTPROV) hCryptProv,
1528                 PP_NAME,
1529                 NULL,
1530                 &amp;dwDataLen,
1531                 0)) {
1532 
1533                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1534                 __leave;
1535             }
1536 
1537             pszProviderName = new (env) char[dwDataLen];
1538             if (pszProviderName == NULL) {
1539                 __leave;
1540             }
1541 
1542             if (! ::CryptGetProvParam( //deprecated
1543                 (HCRYPTPROV) hCryptProv,
1544                 PP_NAME,
1545                 (BYTE *) pszProviderName,
1546                 &amp;dwDataLen,
1547                 0)) {
1548 
1549                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1550                 __leave;
1551             }
1552 
1553             // Convert to a wide char string
1554             pwszProviderName = new (env) WCHAR[dwDataLen];
1555             if (pwszProviderName == NULL) {
1556                 __leave;
1557             }
1558 
1559             if (mbstowcs(pwszProviderName, pszProviderName, dwDataLen) == 0) {
1560                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1561                 __leave;
1562             }
1563 
1564             // Set the name of the provider
1565             keyProviderInfo.pwszProvName = pwszProviderName;
1566 
1567             // Get and set the type of the provider
1568             if (! ::CryptGetProvParam( //deprecated
1569                 (HCRYPTPROV) hCryptProv,
1570                 PP_PROVTYPE,
1571                 (LPBYTE) &amp;keyProviderInfo.dwProvType,
1572                 &amp;dwDataLen,
1573                 0)) {
1574 
1575                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1576                 __leave;
1577             }
1578 
1579             // Set no provider flags
1580             keyProviderInfo.dwFlags = 0;
1581 
1582             // Set no provider parameters
1583             keyProviderInfo.cProvParam = 0;
1584             keyProviderInfo.rgProvParam = NULL;
1585 
1586             // Get the key&#39;s algorithm ID
1587             if (! ::CryptGetKeyParam( //deprecated
1588                 (HCRYPTKEY) hCryptKey,
1589                 KP_ALGID,
1590                 (LPBYTE) &amp;keyProviderInfo.dwKeySpec,
1591                 &amp;dwDataLen,
1592                 0)) {
1593 
1594                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1595                 __leave;
1596             }
1597             // Set the key spec (using the algorithm ID).
1598             switch (keyProviderInfo.dwKeySpec) {
1599             case CALG_RSA_KEYX:
1600             case CALG_DH_SF:
1601                 keyProviderInfo.dwKeySpec = AT_KEYEXCHANGE;
1602                 break;
1603 
1604             case CALG_RSA_SIGN:
1605             case CALG_DSS_SIGN:
1606                 keyProviderInfo.dwKeySpec = AT_SIGNATURE;
1607                 break;
1608 
1609             default:
1610                 ThrowException(env, KEYSTORE_EXCEPTION, NTE_BAD_ALGID);
1611                 __leave;
1612             }
1613 
1614             if (! ::CertSetCertificateContextProperty(pCertContext,
1615                 CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;keyProviderInfo)) {
1616 
1617                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1618                 __leave;
1619             }
1620         }
1621 
1622         // Import encoded certificate
1623         if (!::CertAddCertificateContextToStore(hCertStore, pCertContext,
1624             CERT_STORE_ADD_REPLACE_EXISTING, NULL))
1625         {
1626             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1627             __leave;
1628         }
1629 
1630     }
1631     __finally
1632     {
1633         //--------------------------------------------------------------------
1634         // Clean up.
1635 
1636         if (hCertStore)
1637             ::CertCloseStore(hCertStore, 0);
1638 
1639         if (pszCertStoreName)
1640             env-&gt;ReleaseStringUTFChars(jCertStoreName, pszCertStoreName);
1641 
1642         if (pbCertEncoding)
1643             delete [] pbCertEncoding;
1644 
1645         if (pszCertAliasName)
1646             delete [] pszCertAliasName;
1647 
1648         if (pszContainerName)
1649             delete [] pszContainerName;
1650 
1651         if (pwszContainerName)
1652             delete [] pwszContainerName;
1653 
1654         if (pszProviderName)
1655             delete [] pszProviderName;
1656 
1657         if (pwszProviderName)
1658             delete [] pwszProviderName;
1659 
1660         if (pCertContext)
1661             ::CertFreeCertificateContext(pCertContext);
1662     }
1663 }
1664 
1665 /*
1666  * Class:     sun_security_mscapi_CKeyStore
1667  * Method:    removeCertificate
1668  * Signature: (Ljava/lang/String;Ljava/lang/String;[BI)V
1669  */
1670 JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_removeCertificate
1671   (JNIEnv *env, jobject obj, jstring jCertStoreName, jstring jCertAliasName,
1672   jbyteArray jCertEncoding, jint jCertEncodingSize) {
1673 
1674     const char* pszCertStoreName = NULL;
1675     const char* pszCertAliasName = NULL;
1676     HCERTSTORE hCertStore = NULL;
1677     PCCERT_CONTEXT pCertContext = NULL;
1678     PCCERT_CONTEXT pTBDCertContext = NULL;
1679     jbyte* pbCertEncoding = NULL;
1680     DWORD cchNameString = 0;
1681     char* pszNameString = NULL; // certificate&#39;s friendly name
1682     BOOL bDeleteAttempted = FALSE;
1683 
1684     __try
1685     {
1686         // Open a system certificate store.
1687         if ((pszCertStoreName = env-&gt;GetStringUTFChars(jCertStoreName, NULL))
1688             == NULL) {
1689             __leave;
1690         }
1691         if ((hCertStore = ::CertOpenSystemStore(NULL, pszCertStoreName)) == NULL) {
1692             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1693             __leave;
1694         }
1695 
1696         // Copy encoding from Java to native buffer
1697         pbCertEncoding = new (env) jbyte[jCertEncodingSize];
1698         if (pbCertEncoding == NULL) {
1699             __leave;
1700         }
1701         env-&gt;GetByteArrayRegion(jCertEncoding, 0, jCertEncodingSize, pbCertEncoding);
1702 
1703         // Create a certificate context from the encoded cert
1704         if (!(pCertContext = ::CertCreateCertificateContext(X509_ASN_ENCODING,
1705             (BYTE*) pbCertEncoding, jCertEncodingSize))) {
1706 
1707             ThrowException(env, CERTIFICATE_PARSING_EXCEPTION, GetLastError());
1708             __leave;
1709         }
1710 
1711         // Find the certificate to be deleted
1712         if (!(pTBDCertContext = ::CertFindCertificateInStore(hCertStore,
1713             X509_ASN_ENCODING, 0, CERT_FIND_EXISTING, pCertContext, NULL))) {
1714 
1715             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1716             __leave;
1717         }
1718 
1719         // Check that its friendly name matches the supplied alias
1720         if ((cchNameString = ::CertGetNameString(pTBDCertContext,
1721                 CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0, NULL, NULL, 0)) &gt; 1) {
1722 
1723             pszNameString = new (env) char[cchNameString];
1724             if (pszNameString == NULL) {
1725                 __leave;
1726             }
1727 
1728             ::CertGetNameString(pTBDCertContext,
1729                 CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0, NULL, pszNameString,
1730                 cchNameString);
1731 
1732             // Compare the certificate&#39;s friendly name with supplied alias name
1733             if ((pszCertAliasName = env-&gt;GetStringUTFChars(jCertAliasName, NULL))
1734                 == NULL) {
1735                 __leave;
1736             }
1737             if (strcmp(pszCertAliasName, pszNameString) == 0) {
1738 
1739                 // Only delete the certificate if the alias names matches
1740                 if (! ::CertDeleteCertificateFromStore(pTBDCertContext)) {
1741 
1742                     // pTBDCertContext is always freed by the
1743                     //  CertDeleteCertificateFromStore method
1744                     bDeleteAttempted = TRUE;
1745 
1746                     ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1747                     __leave;
1748                 }
1749             }
1750         }
1751 
1752     }
1753     __finally
1754     {
1755         //--------------------------------------------------------------------
1756         // Clean up.
1757 
1758         if (hCertStore)
1759             ::CertCloseStore(hCertStore, 0);
1760 
1761         if (pszCertStoreName)
1762             env-&gt;ReleaseStringUTFChars(jCertStoreName, pszCertStoreName);
1763 
1764         if (pszCertAliasName)
1765             env-&gt;ReleaseStringUTFChars(jCertAliasName, pszCertAliasName);
1766 
1767         if (pbCertEncoding)
1768             delete [] pbCertEncoding;
1769 
1770         if (pszNameString)
1771             delete [] pszNameString;
1772 
1773         if (pCertContext)
1774             ::CertFreeCertificateContext(pCertContext);
1775 
1776         if (bDeleteAttempted &amp;&amp; pTBDCertContext)
1777             ::CertFreeCertificateContext(pTBDCertContext);
1778     }
1779 }
1780 
1781 /*
1782  * Class:     sun_security_mscapi_CKeyStore
1783  * Method:    destroyKeyContainer
1784  * Signature: (Ljava/lang/String;)V
1785  */
1786 JNIEXPORT void JNICALL Java_sun_security_mscapi_CKeyStore_destroyKeyContainer
1787   (JNIEnv *env, jobject clazz, jstring keyContainerName)
1788 {
1789     HCRYPTPROV hCryptProv = NULL;
1790     const char* pszKeyContainerName = NULL;
1791 
1792     __try
1793     {
1794         if ((pszKeyContainerName =
1795             env-&gt;GetStringUTFChars(keyContainerName, NULL)) == NULL) {
1796             __leave;
1797         }
1798 
1799         // Destroying the default key container is not permitted
1800         // (because it may contain more one keypair).
1801         if (pszKeyContainerName == NULL) {
1802 
1803             ThrowException(env, KEYSTORE_EXCEPTION, NTE_BAD_KEYSET_PARAM);
1804             __leave;
1805         }
1806 
1807         // Acquire a CSP context (to the key container).
1808         if (::CryptAcquireContext( //deprecated
1809             &amp;hCryptProv,
1810             pszKeyContainerName,
1811             NULL,
1812             PROV_RSA_FULL,
1813             CRYPT_DELETEKEYSET) == FALSE)
1814         {
1815             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
1816             __leave;
1817         }
1818 
1819     }
1820     __finally
1821     {
1822         //--------------------------------------------------------------------
1823         // Clean up.
1824 
1825         if (pszKeyContainerName)
1826             env-&gt;ReleaseStringUTFChars(keyContainerName, pszKeyContainerName);
1827     }
1828 }
1829 
1830 /*
1831  * Class:     sun_security_mscapi_CRSACipher
1832  * Method:    encryptDecrypt
1833  * Signature: ([BIJZ)[B
1834  */
1835 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CRSACipher_encryptDecrypt
1836   (JNIEnv *env, jclass clazz, jbyteArray jData, jint jDataSize, jlong hKey,
1837    jboolean doEncrypt)
1838 {
1839     jbyteArray result = NULL;
1840     jbyte* pData = NULL;
1841     DWORD dwDataLen = jDataSize;
1842     DWORD dwBufLen = env-&gt;GetArrayLength(jData);
1843     DWORD i;
1844     BYTE tmp;
1845 
1846     __try
1847     {
1848         // Copy data from Java buffer to native buffer
1849         pData = new (env) jbyte[dwBufLen];
1850         if (pData == NULL) {
1851             __leave;
1852         }
1853         env-&gt;GetByteArrayRegion(jData, 0, dwBufLen, pData);
1854 
1855         if (doEncrypt == JNI_TRUE) {
1856             // encrypt
1857             if (! ::CryptEncrypt((HCRYPTKEY) hKey, 0, TRUE, 0, (BYTE *)pData, //deprecated
1858                 &amp;dwDataLen, dwBufLen)) {
1859 
1860                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1861                 __leave;
1862             }
1863             dwBufLen = dwDataLen;
1864 
1865             // convert from little-endian
1866             for (i = 0; i &lt; dwBufLen / 2; i++) {
1867                 tmp = pData[i];
1868                 pData[i] = pData[dwBufLen - i -1];
1869                 pData[dwBufLen - i - 1] = tmp;
1870             }
1871         } else {
1872             // convert to little-endian
1873             for (i = 0; i &lt; dwBufLen / 2; i++) {
1874                 tmp = pData[i];
1875                 pData[i] = pData[dwBufLen - i -1];
1876                 pData[dwBufLen - i - 1] = tmp;
1877             }
1878 
1879             // decrypt
1880             if (! ::CryptDecrypt((HCRYPTKEY) hKey, 0, TRUE, 0, (BYTE *)pData, //deprecated
1881                 &amp;dwBufLen)) {
1882 
1883                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1884                 __leave;
1885             }
1886         }
1887 
1888         // Create new byte array
1889         if ((result = env-&gt;NewByteArray(dwBufLen)) == NULL) {
1890             __leave;
1891         }
1892 
1893         // Copy data from native buffer to Java buffer
1894         env-&gt;SetByteArrayRegion(result, 0, dwBufLen, (jbyte*) pData);
1895     }
1896     __finally
1897     {
1898         if (pData)
1899             delete [] pData;
1900     }
1901 
1902     return result;
1903 }
1904 
1905 /*
1906  * Class:     sun_security_mscapi_CPublicKey
1907  * Method:    getPublicKeyBlob
1908  * Signature: (JJ)[B
1909  */
1910 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CPublicKey_getPublicKeyBlob
1911     (JNIEnv *env, jobject clazz, jlong hCryptProv, jlong hCryptKey) {
1912 
1913     jbyteArray blob = NULL;
1914     DWORD dwBlobLen;
1915     BYTE* pbKeyBlob = NULL;
1916 
1917     __try
1918     {
1919 
1920         // Determine the size of the blob
1921         if (hCryptKey == 0) {
1922             SS_CHECK(::NCryptExportKey(
1923                 hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,
1924                 NULL, NULL, 0, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
1925         } else {
1926             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, NULL, //deprecated
1927                 &amp;dwBlobLen)) {
1928 
1929                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1930                 __leave;
1931             }
1932         }
1933 
1934         pbKeyBlob = new (env) BYTE[dwBlobLen];
1935         if (pbKeyBlob == NULL) {
1936             __leave;
1937         }
1938 
1939         // Generate key blob
1940         if (hCryptKey == 0) {
1941             SS_CHECK(::NCryptExportKey(
1942                 hCryptProv, NULL, BCRYPT_ECCPUBLIC_BLOB,
1943                 NULL, pbKeyBlob, dwBlobLen, &amp;dwBlobLen, NCRYPT_SILENT_FLAG));
1944         } else {
1945             if (! ::CryptExportKey((HCRYPTKEY) hCryptKey, 0, PUBLICKEYBLOB, 0, //deprecated
1946                 pbKeyBlob, &amp;dwBlobLen)) {
1947 
1948                 ThrowException(env, KEY_EXCEPTION, GetLastError());
1949                 __leave;
1950             }
1951         }
1952 
1953         // Create new byte array
1954         if ((blob = env-&gt;NewByteArray(dwBlobLen)) == NULL) {
1955             __leave;
1956         }
1957 
1958         // Copy data from native buffer to Java buffer
1959         env-&gt;SetByteArrayRegion(blob, 0, dwBlobLen, (jbyte*) pbKeyBlob);
1960     }
1961     __finally
1962     {
1963         if (pbKeyBlob)
1964             delete [] pbKeyBlob;
1965     }
1966 
1967     return blob;
1968 }
1969 
1970 /*
1971  * Class:     sun_security_mscapi_CPublicKey_CRSAPublicKey
1972  * Method:    getExponent
1973  * Signature: ([B)[B
1974  */
1975 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CPublicKey_00024CRSAPublicKey_getExponent
1976     (JNIEnv *env, jobject clazz, jbyteArray jKeyBlob) {
1977 
1978     jbyteArray exponent = NULL;
1979     jbyte*     exponentBytes = NULL;
1980     jbyte*     keyBlob = NULL;
1981 
1982     __try {
1983 
1984         jsize length = env-&gt;GetArrayLength(jKeyBlob);
1985         jsize headerLength = sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
1986 
1987         if (length &lt; headerLength) {
1988             ThrowExceptionWithMessage(env, KEY_EXCEPTION, &quot;Invalid BLOB&quot;);
1989             __leave;
1990         }
1991 
1992         if ((keyBlob = env-&gt;GetByteArrayElements(jKeyBlob, 0)) == NULL) {
1993             __leave;
1994         }
1995 
1996         PUBLICKEYSTRUC* pPublicKeyStruc = (PUBLICKEYSTRUC *) keyBlob;
1997 
1998         // Check BLOB type
1999         if (pPublicKeyStruc-&gt;bType != PUBLICKEYBLOB) {
2000             ThrowException(env, KEY_EXCEPTION, NTE_BAD_TYPE);
2001             __leave;
2002         }
2003 
2004         RSAPUBKEY* pRsaPubKey =
2005             (RSAPUBKEY *) (keyBlob + sizeof(PUBLICKEYSTRUC));
2006 
2007         int len = sizeof(pRsaPubKey-&gt;pubexp);
2008         exponentBytes = new (env) jbyte[len];
2009         if (exponentBytes == NULL) {
2010             __leave;
2011         }
2012 
2013         // convert from little-endian while copying from blob
2014         for (int i = 0, j = len - 1; i &lt; len; i++, j--) {
2015             exponentBytes[i] = ((BYTE*) &amp;pRsaPubKey-&gt;pubexp)[j];
2016         }
2017 
2018         if ((exponent = env-&gt;NewByteArray(len)) == NULL) {
2019             __leave;
2020         }
2021         env-&gt;SetByteArrayRegion(exponent, 0, len, exponentBytes);
2022     }
2023     __finally
2024     {
2025         if (keyBlob)
2026             env-&gt;ReleaseByteArrayElements(jKeyBlob, keyBlob, JNI_ABORT);
2027 
2028         if (exponentBytes)
2029             delete [] exponentBytes;
2030     }
2031 
2032     return exponent;
2033 }
2034 
2035 /*
2036  * Class:     sun_security_mscapi_CPublicKey_CRSAPublicKey
2037  * Method:    getModulus
2038  * Signature: ([B)[B
2039  */
2040 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CPublicKey_00024CRSAPublicKey_getModulus
2041     (JNIEnv *env, jobject clazz, jbyteArray jKeyBlob) {
2042 
2043     jbyteArray modulus = NULL;
2044     jbyte*     modulusBytes = NULL;
2045     jbyte*     keyBlob = NULL;
2046 
2047     __try {
2048 
2049         jsize length = env-&gt;GetArrayLength(jKeyBlob);
2050         jsize headerLength = sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
2051 
2052         if (length &lt; headerLength) {
2053             ThrowExceptionWithMessage(env, KEY_EXCEPTION, &quot;Invalid BLOB&quot;);
2054             __leave;
2055         }
2056 
2057         if ((keyBlob = env-&gt;GetByteArrayElements(jKeyBlob, 0)) == NULL) {
2058             __leave;
2059         }
2060 
2061         PUBLICKEYSTRUC* pPublicKeyStruc = (PUBLICKEYSTRUC *) keyBlob;
2062 
2063         // Check BLOB type
2064         if (pPublicKeyStruc-&gt;bType != PUBLICKEYBLOB) {
2065             ThrowException(env, KEY_EXCEPTION, NTE_BAD_TYPE);
2066             __leave;
2067         }
2068 
2069         RSAPUBKEY* pRsaPubKey =
2070             (RSAPUBKEY *) (keyBlob + sizeof(PUBLICKEYSTRUC));
2071 
2072         int len = pRsaPubKey-&gt;bitlen / 8;
2073         if (len &lt; 0 || len &gt; length - headerLength) {
2074             ThrowExceptionWithMessage(env, KEY_EXCEPTION, &quot;Invalid key length&quot;);
2075             __leave;
2076         }
2077 
2078         modulusBytes = new (env) jbyte[len];
2079         if (modulusBytes == NULL) {
2080             __leave;
2081         }
2082         BYTE * pbModulus = (BYTE *) (keyBlob + headerLength);
2083 
2084         // convert from little-endian while copying from blob
2085         for (int i = 0, j = len - 1; i &lt; len; i++, j--) {
2086             modulusBytes[i] = pbModulus[j];
2087         }
2088 
2089         if ((modulus = env-&gt;NewByteArray(len)) == NULL) {
2090             __leave;
2091         }
2092         env-&gt;SetByteArrayRegion(modulus, 0, len, modulusBytes);
2093     }
2094     __finally
2095     {
2096         if (keyBlob)
2097             env-&gt;ReleaseByteArrayElements(jKeyBlob, keyBlob, JNI_ABORT);
2098 
2099         if (modulusBytes)
2100             delete [] modulusBytes;
2101     }
2102 
2103     return modulus;
2104 }
2105 
2106 /*
2107  * Convert an array in big-endian byte order into little-endian byte order.
2108  */
2109 int convertToLittleEndian(JNIEnv *env, jbyteArray source, jbyte* destination,
2110         int destinationLength) {
2111 
2112     int result = -1;
2113     jbyte* sourceBytes = NULL;
2114 
2115     __try {
2116         int sourceLength = env-&gt;GetArrayLength(source);
2117 
2118         sourceBytes = env-&gt;GetByteArrayElements(source, 0);
2119         if (sourceBytes == NULL) {
2120             __leave;
2121         }
2122 
2123         int copyLen = sourceLength;
2124         if (sourceLength &gt; destinationLength) {
2125             // source might include an extra sign byte
2126             if (sourceLength == destinationLength + 1 &amp;&amp; sourceBytes[0] == 0) {
2127                 copyLen--;
2128             } else {
2129                 __leave;
2130             }
2131         }
2132 
2133         // Copy bytes from the end of the source array to the beginning of the
2134         // destination array (until the destination array is full).
2135         // This ensures that the sign byte from the source array will be excluded.
2136         for (int i = 0; i &lt; copyLen; i++) {
2137             destination[i] = sourceBytes[sourceLength - 1 - i];
2138         }
2139         if (copyLen &lt; destinationLength) {
2140             memset(destination + copyLen, 0, destinationLength - copyLen);
2141         }
2142         result = destinationLength;
2143     } __finally {
2144         // Clean up.
2145         if (sourceBytes) {
2146             env-&gt;ReleaseByteArrayElements(source, sourceBytes, JNI_ABORT);
2147         }
2148     }
2149 
2150     return result;
2151 }
2152 
2153 /*
2154  * The Microsoft Base Cryptographic Provider supports public-key BLOBs
2155  * that have the following format:
2156  *
2157  *     PUBLICKEYSTRUC publickeystruc;
2158  *     RSAPUBKEY rsapubkey;
2159  *     BYTE modulus[rsapubkey.bitlen/8];
2160  *
2161  * and private-key BLOBs that have the following format:
2162  *
2163  *     PUBLICKEYSTRUC publickeystruc;
2164  *     RSAPUBKEY rsapubkey;
2165  *     BYTE modulus[rsapubkey.bitlen/8];
2166  *     BYTE prime1[rsapubkey.bitlen/16];
2167  *     BYTE prime2[rsapubkey.bitlen/16];
2168  *     BYTE exponent1[rsapubkey.bitlen/16];
2169  *     BYTE exponent2[rsapubkey.bitlen/16];
2170  *     BYTE coefficient[rsapubkey.bitlen/16];
2171  *     BYTE privateExponent[rsapubkey.bitlen/8];
2172  *
2173  * This method generates such BLOBs from the key elements supplied.
2174  */
2175 jbyteArray generateKeyBlob(
2176         JNIEnv *env,
2177         jint jKeyBitLength,
2178         jbyteArray jModulus,
2179         jbyteArray jPublicExponent,
2180         jbyteArray jPrivateExponent,
2181         jbyteArray jPrimeP,
2182         jbyteArray jPrimeQ,
2183         jbyteArray jExponentP,
2184         jbyteArray jExponentQ,
2185         jbyteArray jCrtCoefficient)
2186 {
2187     jsize jKeyByteLength = jKeyBitLength / 8;
2188     jsize jBlobLength;
2189     BOOL bGeneratePrivateKeyBlob;
2190 
2191     // Determine whether to generate a public-key or a private-key BLOB
2192     if (jPrivateExponent != NULL &amp;&amp;
2193         jPrimeP != NULL &amp;&amp;
2194         jPrimeQ != NULL &amp;&amp;
2195         jExponentP != NULL &amp;&amp;
2196         jExponentQ != NULL &amp;&amp;
2197         jCrtCoefficient != NULL) {
2198 
2199         bGeneratePrivateKeyBlob = TRUE;
2200         jBlobLength = sizeof(BLOBHEADER) +
2201                         sizeof(RSAPUBKEY) +
2202                         ((jKeyBitLength / 8) * 4) +
2203                         (jKeyBitLength / 16);
2204 
2205     } else {
2206         bGeneratePrivateKeyBlob = FALSE;
2207         jBlobLength = sizeof(BLOBHEADER) +
2208                         sizeof(RSAPUBKEY) +
2209                         (jKeyBitLength / 8);
2210     }
2211 
2212     jbyte* jBlobBytes = NULL;
2213     jbyte* jBlobElement;
2214     jbyteArray jBlob = NULL;
2215     jsize  jElementLength;
2216 
2217     __try {
2218         jBlobBytes = new (env) jbyte[jBlobLength];
2219         if (jBlobBytes == NULL) {
2220             __leave;
2221         }
2222 
2223         BLOBHEADER *pBlobHeader = (BLOBHEADER *) jBlobBytes;
2224         if (bGeneratePrivateKeyBlob) {
2225             pBlobHeader-&gt;bType = PRIVATEKEYBLOB;  // 0x07
2226         } else {
2227             pBlobHeader-&gt;bType = PUBLICKEYBLOB;   // 0x06
2228         }
2229         pBlobHeader-&gt;bVersion = CUR_BLOB_VERSION; // 0x02
2230         pBlobHeader-&gt;reserved = 0;                // 0x0000
2231         pBlobHeader-&gt;aiKeyAlg = CALG_RSA_KEYX;    // 0x0000a400
2232 
2233         RSAPUBKEY *pRsaPubKey =
2234             (RSAPUBKEY *) (jBlobBytes + sizeof(PUBLICKEYSTRUC));
2235         if (bGeneratePrivateKeyBlob) {
2236             pRsaPubKey-&gt;magic = 0x32415352;       // &quot;RSA2&quot;
2237         } else {
2238             pRsaPubKey-&gt;magic = 0x31415352;       // &quot;RSA1&quot;
2239         }
2240         pRsaPubKey-&gt;bitlen = jKeyBitLength;
2241         pRsaPubKey-&gt;pubexp = 0; // init
2242 
2243         // Sanity check
2244         jsize jPublicExponentLength = env-&gt;GetArrayLength(jPublicExponent);
2245         if (jPublicExponentLength &gt; sizeof(pRsaPubKey-&gt;pubexp)) {
2246             ThrowException(env, INVALID_KEY_EXCEPTION, NTE_BAD_TYPE);
2247             __leave;
2248         }
2249         // The length argument must be the smaller of jPublicExponentLength
2250         // and sizeof(pRsaPubKey-&gt;pubkey)
2251         if ((jElementLength = convertToLittleEndian(env, jPublicExponent,
2252             (jbyte *) &amp;(pRsaPubKey-&gt;pubexp), jPublicExponentLength)) &lt; 0) {
2253             __leave;
2254         }
2255 
2256         // Modulus n
2257         jBlobElement =
2258             (jbyte *) (jBlobBytes + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY));
2259         if ((jElementLength = convertToLittleEndian(env, jModulus, jBlobElement,
2260             jKeyByteLength)) &lt; 0) {
2261             __leave;
2262         }
2263 
2264         if (bGeneratePrivateKeyBlob) {
2265             // Prime p
2266             jBlobElement += jElementLength;
2267             if ((jElementLength = convertToLittleEndian(env, jPrimeP,
2268                 jBlobElement, jKeyByteLength / 2)) &lt; 0) {
2269                 __leave;
2270             }
2271 
2272             // Prime q
2273             jBlobElement += jElementLength;
2274             if ((jElementLength = convertToLittleEndian(env, jPrimeQ,
2275                 jBlobElement, jKeyByteLength / 2)) &lt; 0) {
2276                 __leave;
2277             }
2278 
2279             // Prime exponent p
2280             jBlobElement += jElementLength;
2281             if ((jElementLength = convertToLittleEndian(env, jExponentP,
2282                 jBlobElement, jKeyByteLength / 2)) &lt; 0) {
2283                 __leave;
2284             }
2285 
2286             // Prime exponent q
2287             jBlobElement += jElementLength;
2288             if ((jElementLength = convertToLittleEndian(env, jExponentQ,
2289                 jBlobElement, jKeyByteLength / 2)) &lt; 0) {
2290                 __leave;
2291             }
2292 
2293             // CRT coefficient
2294             jBlobElement += jElementLength;
2295             if ((jElementLength = convertToLittleEndian(env, jCrtCoefficient,
2296                 jBlobElement, jKeyByteLength / 2)) &lt; 0) {
2297                 __leave;
2298             }
2299 
2300             // Private exponent
2301             jBlobElement += jElementLength;
2302             if ((jElementLength = convertToLittleEndian(env, jPrivateExponent,
2303                 jBlobElement, jKeyByteLength)) &lt; 0) {
2304                 __leave;
2305             }
2306         }
2307 
2308         if ((jBlob = env-&gt;NewByteArray(jBlobLength)) == NULL) {
2309             __leave;
2310         }
2311         env-&gt;SetByteArrayRegion(jBlob, 0, jBlobLength, jBlobBytes);
2312 
2313     }
2314     __finally
2315     {
2316         if (jBlobBytes)
2317             delete [] jBlobBytes;
2318     }
2319 
2320     return jBlob;
2321 }
2322 
2323 /*
2324  * Class:     sun_security_mscapi_CKeyStore
2325  * Method:    generateRSAPrivateKeyBlob
2326  * Signature: (I[B[B[B[B[B[B[B[B)[B
2327  */
2328 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CKeyStore_generateRSAPrivateKeyBlob
2329     (JNIEnv *env, jobject clazz,
2330         jint jKeyBitLength,
2331         jbyteArray jModulus,
2332         jbyteArray jPublicExponent,
2333         jbyteArray jPrivateExponent,
2334         jbyteArray jPrimeP,
2335         jbyteArray jPrimeQ,
2336         jbyteArray jExponentP,
2337         jbyteArray jExponentQ,
2338         jbyteArray jCrtCoefficient)
2339 {
2340     return generateKeyBlob(env, jKeyBitLength, jModulus, jPublicExponent,
2341         jPrivateExponent, jPrimeP, jPrimeQ, jExponentP, jExponentQ,
2342         jCrtCoefficient);
2343 }
2344 
2345 /*
2346  * Class:     sun_security_mscapi_CSignature_RSA
2347  * Method:    generatePublicKeyBlob
2348  * Signature: (I[B[B)[B
2349  */
2350 JNIEXPORT jbyteArray JNICALL Java_sun_security_mscapi_CSignature_00024RSA_generatePublicKeyBlob
2351     (JNIEnv *env, jclass clazz,
2352         jint jKeyBitLength,
2353         jbyteArray jModulus,
2354         jbyteArray jPublicExponent)
2355 {
2356     return generateKeyBlob(env, jKeyBitLength, jModulus, jPublicExponent,
2357         NULL, NULL, NULL, NULL, NULL, NULL);
2358 }
2359 
2360 /*
2361  * Class:     sun_security_mscapi_CKeyStore
2362  * Method:    storePrivateKey
2363  * Signature: (Ljava/lang/String;[BLjava/lang/String;I)Lsun/security/mscapi/CPrivateKey;
2364  */
2365 JNIEXPORT jobject JNICALL Java_sun_security_mscapi_CKeyStore_storePrivateKey
2366     (JNIEnv *env, jobject clazz, jstring alg, jbyteArray keyBlob,
2367      jstring keyContainerName, jint keySize)
2368 {
2369     HCRYPTPROV hCryptProv = NULL;
2370     HCRYPTKEY hKey = NULL;
2371     DWORD dwBlobLen;
2372     BYTE * pbKeyBlob = NULL;
2373     const char* pszKeyContainerName = NULL; // UUID
2374     jobject privateKey = NULL;
2375 
2376     __try
2377     {
2378         if ((pszKeyContainerName =
2379             env-&gt;GetStringUTFChars(keyContainerName, NULL)) == NULL) {
2380             __leave;
2381         }
2382         dwBlobLen = env-&gt;GetArrayLength(keyBlob);
2383         if ((pbKeyBlob = (BYTE *) env-&gt;GetByteArrayElements(keyBlob, 0))
2384             == NULL) {
2385             __leave;
2386         }
2387 
2388         // Acquire a CSP context (create a new key container).
2389         if (::CryptAcquireContext( //deprecated
2390             &amp;hCryptProv,
2391             pszKeyContainerName,
2392             NULL,
2393             PROV_RSA_FULL,
2394             CRYPT_NEWKEYSET) == FALSE)
2395         {
2396             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
2397             __leave;
2398         }
2399 
2400         // Import the private key
2401         if (::CryptImportKey( //deprecated
2402             hCryptProv,
2403             pbKeyBlob,
2404             dwBlobLen,
2405             0,
2406             CRYPT_EXPORTABLE,
2407             &amp;hKey) == FALSE)
2408         {
2409             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
2410             __leave;
2411         }
2412 
2413         // Get the method ID for the CPrivateKey constructor
2414         jclass clazzCPrivateKey =
2415             env-&gt;FindClass(&quot;sun/security/mscapi/CPrivateKey&quot;);
2416         if (clazzCPrivateKey == NULL) {
2417             __leave;
2418         }
2419 
2420         jmethodID mNewCPrivateKey =
2421             env-&gt;GetStaticMethodID(clazzCPrivateKey, &quot;of&quot;,
2422             &quot;(Ljava/lang/String;JJI)Lsun/security/mscapi/CPrivateKey;&quot;);
2423         if (mNewCPrivateKey == NULL) {
2424             __leave;
2425         }
2426 
2427         // Create a new private key
2428         privateKey = env-&gt;CallStaticObjectMethod(clazzCPrivateKey, mNewCPrivateKey,
2429             alg, (jlong) hCryptProv, (jlong) hKey, keySize);
2430 
2431     }
2432     __finally
2433     {
2434         //--------------------------------------------------------------------
2435         // Clean up.
2436 
2437         if (pszKeyContainerName)
2438             env-&gt;ReleaseStringUTFChars(keyContainerName, pszKeyContainerName);
2439 
2440         if (pbKeyBlob)
2441             env-&gt;ReleaseByteArrayElements(keyBlob, (jbyte *) pbKeyBlob,
2442                 JNI_ABORT);
2443     }
2444 
2445     return privateKey;
2446 }
2447 
2448 /*
2449  * Class:     sun_security_mscapi_CSignature
2450  * Method:    importECPublicKey
2451  * Signature: (Ljava/lang/String;[BI)Lsun/security/mscapi/CPublicKey;
2452  */
2453 JNIEXPORT jobject JNICALL Java_sun_security_mscapi_CSignature_importECPublicKey
2454     (JNIEnv *env, jclass clazz, jstring alg, jbyteArray keyBlob, jint keySize)
2455 {
2456     BCRYPT_ALG_HANDLE hSignAlg = NULL;
2457     NCRYPT_KEY_HANDLE       hTmpKey         = NULL;
2458     DWORD dwBlobLen;
2459     BYTE * pbKeyBlob = NULL;
2460     jobject publicKey = NULL;
2461 
2462     __try
2463     {
2464         dwBlobLen = env-&gt;GetArrayLength(keyBlob);
2465         if ((pbKeyBlob = (BYTE *) env-&gt;GetByteArrayElements(keyBlob, 0))
2466             == NULL) {
2467             __leave;
2468         }
2469         dump(&quot;NCryptImportKey&quot;, pbKeyBlob, dwBlobLen);
2470         NCRYPT_PROV_HANDLE hProv;
2471         SS_CHECK(NCryptOpenStorageProvider(
2472                 &amp;hProv, L&quot;Microsoft Software Key Storage Provider&quot;, 0 ));
2473         SS_CHECK(NCryptImportKey(
2474                                                     hProv,
2475                                                     NULL,
2476                                                     BCRYPT_ECCPUBLIC_BLOB,
2477                                                     NULL,
2478                                                     &amp;hTmpKey,
2479                                                     pbKeyBlob,
2480                                                     dwBlobLen,
2481                                                     0));
2482         NCryptFreeObject( hProv );
2483         // Get the method ID for the CPublicKey constructor
2484         jclass clazzCPublicKey =
2485             env-&gt;FindClass(&quot;sun/security/mscapi/CPublicKey&quot;);
2486         if (clazzCPublicKey == NULL) {
2487             __leave;
2488         }
2489 
2490         jmethodID mNewCPublicKey =
2491             env-&gt;GetStaticMethodID(clazzCPublicKey, &quot;of&quot;,
2492             &quot;(Ljava/lang/String;JJI)Lsun/security/mscapi/CPublicKey;&quot;);
2493         if (mNewCPublicKey == NULL) {
2494             __leave;
2495         }
2496 
2497         // Create a new public key
2498         publicKey = env-&gt;CallStaticObjectMethod(clazzCPublicKey, mNewCPublicKey,
2499             alg, (jlong) hTmpKey, (jlong) 0, keySize);
2500     }
2501     __finally
2502     {
2503     }
2504 
2505     return publicKey;
2506 }
2507 
2508 /*
2509  * Class:     sun_security_mscapi_CSignature
2510  * Method:    importPublicKey
2511  * Signature: (Ljava/lang/String;[BI)Lsun/security/mscapi/CPublicKey;
2512  */
2513 JNIEXPORT jobject JNICALL Java_sun_security_mscapi_CSignature_importPublicKey
2514     (JNIEnv *env, jclass clazz, jstring alg, jbyteArray keyBlob, jint keySize)
2515 {
2516     HCRYPTPROV hCryptProv = NULL;
2517     HCRYPTKEY hKey = NULL;
2518     DWORD dwBlobLen;
2519     BYTE * pbKeyBlob = NULL;
2520     jobject publicKey = NULL;
2521 
2522     __try
2523     {
2524         dwBlobLen = env-&gt;GetArrayLength(keyBlob);
2525         if ((pbKeyBlob = (BYTE *) env-&gt;GetByteArrayElements(keyBlob, 0))
2526             == NULL) {
2527             __leave;
2528         }
2529 
2530         // Acquire a CSP context (create a new key container).
2531         // Prefer a PROV_RSA_AES CSP, when available, due to its support
2532         // for SHA-2-based signatures.
2533         if (::CryptAcquireContext( //deprecated
2534             &amp;hCryptProv,
2535             NULL,
2536             NULL,
2537             PROV_RSA_AES,
2538             CRYPT_VERIFYCONTEXT) == FALSE)
2539         {
2540             // Failover to using the default CSP (PROV_RSA_FULL)
2541 
2542             if (::CryptAcquireContext( //deprecated
2543                 &amp;hCryptProv,
2544                 NULL,
2545                 NULL,
2546                 PROV_RSA_FULL,
2547                 CRYPT_VERIFYCONTEXT) == FALSE)
2548             {
2549                 ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
2550                 __leave;
2551             }
2552         }
2553 
2554         // Import the public key
2555         if (::CryptImportKey( //deprecated
2556             hCryptProv,
2557             pbKeyBlob,
2558             dwBlobLen,
2559             0,
2560             CRYPT_EXPORTABLE,
2561             &amp;hKey) == FALSE)
2562         {
2563             ThrowException(env, KEYSTORE_EXCEPTION, GetLastError());
2564             __leave;
2565         }
2566 
2567         // Get the method ID for the CPublicKey constructor
2568         jclass clazzCPublicKey =
2569             env-&gt;FindClass(&quot;sun/security/mscapi/CPublicKey&quot;);
2570         if (clazzCPublicKey == NULL) {
2571             __leave;
2572         }
2573 
2574         jmethodID mNewCPublicKey =
2575             env-&gt;GetStaticMethodID(clazzCPublicKey, &quot;of&quot;,
2576             &quot;(Ljava/lang/String;JJI)Lsun/security/mscapi/CPublicKey;&quot;);
2577         if (mNewCPublicKey == NULL) {
2578             __leave;
2579         }
2580 
2581         // Create a new public key
2582         publicKey = env-&gt;CallStaticObjectMethod(clazzCPublicKey, mNewCPublicKey,
2583             alg, (jlong) hCryptProv, (jlong) hKey, keySize);
2584 
2585     }
2586     __finally
2587     {
2588         //--------------------------------------------------------------------
2589         // Clean up.
2590 
2591         if (pbKeyBlob)
2592             env-&gt;ReleaseByteArrayElements(keyBlob, (jbyte *) pbKeyBlob,
2593                 JNI_ABORT);
2594     }
2595 
2596     return publicKey;
2597 }
2598 
2599 } /* extern &quot;C&quot; */
    </pre>
  </body>
</html>
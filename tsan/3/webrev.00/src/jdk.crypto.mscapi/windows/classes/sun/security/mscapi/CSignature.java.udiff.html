<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CPublicKey.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libsunmscapi/security.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,14 +116,17 @@</span>
          }
  
          // initialize for signing. See JCA doc
          @Override
          protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+             if (key == null) {</span>
<span class="udiff-line-added">+                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="udiff-line-added">+             }</span>
              if ((key instanceof CPrivateKey) == false
                      || !key.getAlgorithm().equalsIgnoreCase(&quot;RSA&quot;)) {
<span class="udiff-line-modified-removed">-                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>
<span class="udiff-line-modified-added">+                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="udiff-line-added">+                         + key.getClass() + &quot; &quot; + key.getAlgorithm());</span>
              }
              privateKey = (CPrivateKey) key;
  
              // Check against the local and global values to make sure
              // the sizes are ok.  Round up to nearest byte.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136,13 +139,17 @@</span>
          }
  
          // initialize for signing. See JCA doc
          @Override
          protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<span class="udiff-line-added">+             if (key == null) {</span>
<span class="udiff-line-added">+                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="udiff-line-added">+             }</span>
              // This signature accepts only RSAPublicKey
              if ((key instanceof RSAPublicKey) == false) {
<span class="udiff-line-modified-removed">-                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>
<span class="udiff-line-modified-added">+                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="udiff-line-added">+                         + key.getClass());</span>
              }
  
  
              if ((key instanceof CPublicKey) == false) {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -199,20 +206,26 @@</span>
          @Override
          protected byte[] engineSign() throws SignatureException {
  
              byte[] hash = getDigestValue();
  
<span class="udiff-line-modified-removed">-             // Omit the hash OID when generating a NONEwithRSA signature</span>
<span class="udiff-line-modified-removed">-             boolean noHashOID = this instanceof NONEwithRSA;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Sign hash using MS Crypto APIs</span>
<span class="udiff-line-modified-removed">-             byte[] result = signHash(noHashOID, hash, hash.length,</span>
<span class="udiff-line-modified-added">+             if (privateKey.getHCryptKey() == 0) {</span>
<span class="udiff-line-modified-added">+                 return signCngHash(1, hash, hash.length,</span>
<span class="udiff-line-modified-added">+                         0,</span>
<span class="udiff-line-modified-added">+                         this instanceof NONEwithRSA ? null : messageDigestAlgorithm,</span>
<span class="udiff-line-modified-added">+                         privateKey.getHCryptProvider(), 0);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // Omit the hash OID when generating a NONEwithRSA signature</span>
<span class="udiff-line-added">+                 boolean noHashOID = this instanceof NONEwithRSA;</span>
<span class="udiff-line-added">+                 // Sign hash using MS Crypto APIs</span>
<span class="udiff-line-added">+                 byte[] result = signHash(noHashOID, hash, hash.length,</span>
                          messageDigestAlgorithm, privateKey.getHCryptProvider(),
                          privateKey.getHCryptKey());
  
<span class="udiff-line-modified-removed">-             // Convert signature array from little endian to big endian</span>
<span class="udiff-line-modified-removed">-             return convertEndianArray(result);</span>
<span class="udiff-line-modified-added">+                 // Convert signature array from little endian to big endian</span>
<span class="udiff-line-modified-added">+                 return convertEndianArray(result);</span>
<span class="udiff-line-added">+             }</span>
          }
  
          /**
           * Verifies the passed-in signature.
           *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228,14 +241,24 @@</span>
          @Override
          protected boolean engineVerify(byte[] sigBytes)
                  throws SignatureException {
              byte[] hash = getDigestValue();
  
<span class="udiff-line-modified-removed">-             return verifySignedHash(hash, hash.length,</span>
<span class="udiff-line-modified-removed">-                     messageDigestAlgorithm, convertEndianArray(sigBytes),</span>
<span class="udiff-line-modified-removed">-                     sigBytes.length, publicKey.getHCryptProvider(),</span>
<span class="udiff-line-modified-removed">-                     publicKey.getHCryptKey());</span>
<span class="udiff-line-modified-added">+             if (publicKey.getHCryptKey() == 0) {</span>
<span class="udiff-line-modified-added">+                 return verifyCngSignedHash(</span>
<span class="udiff-line-modified-added">+                         1, hash, hash.length,</span>
<span class="udiff-line-modified-added">+                         sigBytes, sigBytes.length,</span>
<span class="udiff-line-added">+                         0,</span>
<span class="udiff-line-added">+                         messageDigestAlgorithm,</span>
<span class="udiff-line-added">+                         publicKey.getHCryptProvider(),</span>
<span class="udiff-line-added">+                         0);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 return verifySignedHash(hash, hash.length,</span>
<span class="udiff-line-added">+                         messageDigestAlgorithm, convertEndianArray(sigBytes),</span>
<span class="udiff-line-added">+                         sigBytes.length, publicKey.getHCryptProvider(),</span>
<span class="udiff-line-added">+                         publicKey.getHCryptKey());</span>
<span class="udiff-line-added">+             }</span>
          }
  
          /**
           * Generates a public-key BLOB from a key&#39;s components.
           */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -408,29 +431,36 @@</span>
          }
  
          // initialize for signing. See JCA doc
          @Override
          protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<span class="udiff-line-added">+             if (key == null) {</span>
<span class="udiff-line-added">+                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="udiff-line-added">+             }</span>
              if ((key instanceof CPrivateKey) == false
                      || !key.getAlgorithm().equalsIgnoreCase(&quot;EC&quot;)) {
<span class="udiff-line-modified-removed">-                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>
<span class="udiff-line-modified-added">+                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="udiff-line-added">+                         + key.getClass() + &quot; &quot; + key.getAlgorithm());</span>
              }
              privateKey = (CPrivateKey) key;
  
              this.publicKey = null;
              resetDigest();
          }
  
          // initialize for signing. See JCA doc
          @Override
          protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<span class="udiff-line-added">+             if (key == null) {</span>
<span class="udiff-line-added">+                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="udiff-line-added">+             }</span>
              // This signature accepts only ECPublicKey
              if ((key instanceof ECPublicKey) == false) {
<span class="udiff-line-modified-removed">-                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>
<span class="udiff-line-modified-added">+                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="udiff-line-added">+                         + key.getClass());</span>
              }
  
<span class="udiff-line-removed">- </span>
              if ((key instanceof CPublicKey) == false) {
                  try {
                      publicKey = importECPublicKey(&quot;EC&quot;,
                              CKey.generateECBlob(key),
                              KeyUtil.getKeySize(key));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -489,13 +519,17 @@</span>
              fallbackSignature = null;
          }
  
          @Override
          protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<span class="udiff-line-added">+             if (key == null) {</span>
<span class="udiff-line-added">+                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="udiff-line-added">+             }</span>
              // This signature accepts only RSAPublicKey
              if ((key instanceof java.security.interfaces.RSAPublicKey) == false) {
<span class="udiff-line-modified-removed">-                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>
<span class="udiff-line-modified-added">+                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="udiff-line-added">+                         + key.getClass());</span>
              }
  
              this.privateKey = null;
  
              if (key instanceof CPublicKey) {
</pre>
<center><a href="CPublicKey.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libsunmscapi/security.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.mscapi;
 27 
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.security.interfaces.ECPublicKey;
 31 import java.security.interfaces.RSAPublicKey;
 32 import java.security.spec.AlgorithmParameterSpec;
 33 import java.math.BigInteger;
 34 import java.security.spec.MGF1ParameterSpec;
 35 import java.security.spec.PSSParameterSpec;
 36 import java.util.Locale;
 37 
 38 import sun.security.rsa.RSAKeyFactory;
 39 import sun.security.util.ECUtil;
 40 import sun.security.util.KeyUtil;
 41 
 42 /**
 43  * Signature implementation.
 44  *
 45  * Objects should be instantiated by calling Signature.getInstance() using the
 46  * following algorithm names:
 47  *
 48  *  . &quot;NONEwithRSA&quot;
 49  *  . &quot;SHA1withRSA&quot;
 50  *  . &quot;SHA256withRSA&quot;
 51  *  . &quot;SHA384withRSA&quot;
 52  *  . &quot;SHA512withRSA&quot;
 53  *  . &quot;MD5withRSA&quot;
 54  *  . &quot;MD2withRSA&quot;
 55  *  . &quot;RSASSA-PSS&quot;
 56  *  . &quot;SHA1withECDSA&quot;
 57  *  . &quot;SHA224withECDSA&quot;
 58  *  . &quot;SHA256withECDSA&quot;
 59  *  . &quot;SHA384withECDSA&quot;
 60  *  . &quot;SHA512withECDSA&quot;
 61  *
 62  * NOTE: RSA keys must be at least 512 bits long.
 63  *
 64  * NOTE: NONEwithRSA must be supplied with a pre-computed message digest.
 65  *       Only the following digest algorithms are supported: MD5, SHA-1,
 66  *       SHA-256, SHA-384, SHA-512 and a special-purpose digest
 67  *       algorithm which is a concatenation of SHA-1 and MD5 digests.
 68  *
 69  * @since   1.6
 70  * @author  Stanley Man-Kit Ho
 71  */
 72 abstract class CSignature extends SignatureSpi {
 73     // private key algorithm name
 74     protected String keyAlgorithm;
 75 
 76     // message digest implementation we use
 77     protected MessageDigest messageDigest;
 78 
 79     // message digest name
 80     protected String messageDigestAlgorithm;
 81 
 82     // flag indicating whether the digest has been reset
 83     protected boolean needsReset;
 84 
 85     // the signing key
 86     protected CPrivateKey privateKey = null;
 87 
 88     // the verification key
 89     protected CPublicKey publicKey = null;
 90 
 91     /**
 92      * Constructs a new CSignature. Used by subclasses.
 93      */
 94     CSignature(String keyName, String digestName) {
 95 
 96         this.keyAlgorithm = keyName;
 97         if (digestName != null) {
 98             try {
 99                 messageDigest = MessageDigest.getInstance(digestName);
100                 // Get the digest&#39;s canonical name
101                 messageDigestAlgorithm = messageDigest.getAlgorithm();
102             } catch (NoSuchAlgorithmException e) {
103                 throw new ProviderException(e);
104             }
105         } else {
106             messageDigest = null;
107             messageDigestAlgorithm = null;
108         }
109         needsReset = false;
110     }
111 
112     static class RSA extends CSignature {
113 
114         public RSA(String digestAlgorithm) {
115             super(&quot;RSA&quot;, digestAlgorithm);
116         }
117 
118         // initialize for signing. See JCA doc
119         @Override
120         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<a name="2" id="anc2"></a><span class="line-modified">121 </span>


122             if ((key instanceof CPrivateKey) == false
123                     || !key.getAlgorithm().equalsIgnoreCase(&quot;RSA&quot;)) {
<a name="3" id="anc3"></a><span class="line-modified">124                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

125             }
126             privateKey = (CPrivateKey) key;
127 
128             // Check against the local and global values to make sure
129             // the sizes are ok.  Round up to nearest byte.
130             RSAKeyFactory.checkKeyLengths(((privateKey.length() + 7) &amp; ~7),
131                     null, CKeyPairGenerator.RSA.KEY_SIZE_MIN,
132                     CKeyPairGenerator.RSA.KEY_SIZE_MAX);
133 
134             this.publicKey = null;
135             resetDigest();
136         }
137 
138         // initialize for signing. See JCA doc
139         @Override
140         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<a name="4" id="anc4"></a>


141             // This signature accepts only RSAPublicKey
142             if ((key instanceof RSAPublicKey) == false) {
<a name="5" id="anc5"></a><span class="line-modified">143                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

144             }
145 
146 
147             if ((key instanceof CPublicKey) == false) {
148 
149                 // convert key to MSCAPI format
150                 java.security.interfaces.RSAPublicKey rsaKey =
151                         (java.security.interfaces.RSAPublicKey) key;
152 
153                 BigInteger modulus = rsaKey.getModulus();
154                 BigInteger exponent =  rsaKey.getPublicExponent();
155 
156                 // Check against the local and global values to make sure
157                 // the sizes are ok.  Round up to the nearest byte.
158                 RSAKeyFactory.checkKeyLengths(((modulus.bitLength() + 7) &amp; ~7),
159                         exponent, -1, CKeyPairGenerator.RSA.KEY_SIZE_MAX);
160 
161                 byte[] modulusBytes = modulus.toByteArray();
162                 byte[] exponentBytes = exponent.toByteArray();
163 
164                 // Adjust key length due to sign bit
165                 int keyBitLength = (modulusBytes[0] == 0)
166                         ? (modulusBytes.length - 1) * 8
167                         : modulusBytes.length * 8;
168 
169                 byte[] keyBlob = generatePublicKeyBlob(
170                         keyBitLength, modulusBytes, exponentBytes);
171 
172                 try {
173                     publicKey = importPublicKey(&quot;RSA&quot;, keyBlob, keyBitLength);
174 
175                 } catch (KeyStoreException e) {
176                     throw new InvalidKeyException(e);
177                 }
178 
179             } else {
180                 publicKey = (CPublicKey) key;
181             }
182 
183             this.privateKey = null;
184             resetDigest();
185         }
186 
187         /**
188          * Returns the signature bytes of all the data
189          * updated so far.
190          * The format of the signature depends on the underlying
191          * signature scheme.
192          *
193          * @return the signature bytes of the signing operation&#39;s result.
194          *
195          * @exception SignatureException if the engine is not
196          * initialized properly or if this signature algorithm is unable to
197          * process the input data provided.
198          */
199         @Override
200         protected byte[] engineSign() throws SignatureException {
201 
202             byte[] hash = getDigestValue();
203 
<a name="6" id="anc6"></a><span class="line-modified">204             // Omit the hash OID when generating a NONEwithRSA signature</span>
<span class="line-modified">205             boolean noHashOID = this instanceof NONEwithRSA;</span>
<span class="line-modified">206 </span>
<span class="line-modified">207             // Sign hash using MS Crypto APIs</span>
<span class="line-modified">208             byte[] result = signHash(noHashOID, hash, hash.length,</span>





209                         messageDigestAlgorithm, privateKey.getHCryptProvider(),
210                         privateKey.getHCryptKey());
211 
<a name="7" id="anc7"></a><span class="line-modified">212             // Convert signature array from little endian to big endian</span>
<span class="line-modified">213             return convertEndianArray(result);</span>

214         }
215 
216         /**
217          * Verifies the passed-in signature.
218          *
219          * @param sigBytes the signature bytes to be verified.
220          *
221          * @return true if the signature was verified, false if not.
222          *
223          * @exception SignatureException if the engine is not
224          * initialized properly, the passed-in signature is improperly
225          * encoded or of the wrong type, if this signature algorithm is unable to
226          * process the input data provided, etc.
227          */
228         @Override
229         protected boolean engineVerify(byte[] sigBytes)
230                 throws SignatureException {
231             byte[] hash = getDigestValue();
232 
<a name="8" id="anc8"></a><span class="line-modified">233             return verifySignedHash(hash, hash.length,</span>
<span class="line-modified">234                     messageDigestAlgorithm, convertEndianArray(sigBytes),</span>
<span class="line-modified">235                     sigBytes.length, publicKey.getHCryptProvider(),</span>
<span class="line-modified">236                     publicKey.getHCryptKey());</span>










237         }
238 
239         /**
240          * Generates a public-key BLOB from a key&#39;s components.
241          */
242         // used by CRSACipher
243         static native byte[] generatePublicKeyBlob(
244                 int keyBitLength, byte[] modulus, byte[] publicExponent)
245                 throws InvalidKeyException;
246 
247     }
248 
249     // Nested class for NONEwithRSA signatures
250     public static final class NONEwithRSA extends RSA {
251 
252         // the longest supported digest is 512 bits (SHA-512)
253         private static final int RAW_RSA_MAX = 64;
254 
255         private final byte[] precomputedDigest;
256         private int offset = 0;
257 
258         public NONEwithRSA() {
259             super(null);
260             precomputedDigest = new byte[RAW_RSA_MAX];
261         }
262 
263         // Stores the precomputed message digest value.
264         @Override
265         protected void engineUpdate(byte b) throws SignatureException {
266             if (offset &gt;= precomputedDigest.length) {
267                 offset = RAW_RSA_MAX + 1;
268                 return;
269             }
270             precomputedDigest[offset++] = b;
271         }
272 
273         // Stores the precomputed message digest value.
274         @Override
275         protected void engineUpdate(byte[] b, int off, int len)
276                 throws SignatureException {
277             if (len &gt; (precomputedDigest.length - offset)) {
278                 offset = RAW_RSA_MAX + 1;
279                 return;
280             }
281             System.arraycopy(b, off, precomputedDigest, offset, len);
282             offset += len;
283         }
284 
285         // Stores the precomputed message digest value.
286         @Override
287         protected void engineUpdate(ByteBuffer byteBuffer) {
288             int len = byteBuffer.remaining();
289             if (len &lt;= 0) {
290                 return;
291             }
292             if (len &gt; (precomputedDigest.length - offset)) {
293                 offset = RAW_RSA_MAX + 1;
294                 return;
295             }
296             byteBuffer.get(precomputedDigest, offset, len);
297             offset += len;
298         }
299 
300         @Override
301         protected void resetDigest(){
302             offset = 0;
303         }
304 
305         // Returns the precomputed message digest value.
306         @Override
307         protected byte[] getDigestValue() throws SignatureException {
308             if (offset &gt; RAW_RSA_MAX) {
309                 throw new SignatureException(&quot;Message digest is too long&quot;);
310             }
311 
312             // Determine the digest algorithm from the digest length
313             if (offset == 20) {
314                 setDigestName(&quot;SHA1&quot;);
315             } else if (offset == 36) {
316                 setDigestName(&quot;SHA1+MD5&quot;);
317             } else if (offset == 32) {
318                 setDigestName(&quot;SHA-256&quot;);
319             } else if (offset == 48) {
320                 setDigestName(&quot;SHA-384&quot;);
321             } else if (offset == 64) {
322                 setDigestName(&quot;SHA-512&quot;);
323             } else if (offset == 16) {
324                 setDigestName(&quot;MD5&quot;);
325             } else {
326                 throw new SignatureException(
327                     &quot;Message digest length is not supported&quot;);
328             }
329 
330             byte[] result = new byte[offset];
331             System.arraycopy(precomputedDigest, 0, result, 0, offset);
332             offset = 0;
333 
334             return result;
335         }
336     }
337 
338     public static final class SHA1withRSA extends RSA {
339         public SHA1withRSA() {
340             super(&quot;SHA1&quot;);
341         }
342     }
343 
344     public static final class SHA256withRSA extends RSA {
345         public SHA256withRSA() {
346             super(&quot;SHA-256&quot;);
347         }
348     }
349 
350     public static final class SHA384withRSA extends RSA {
351         public SHA384withRSA() {
352             super(&quot;SHA-384&quot;);
353         }
354     }
355 
356     public static final class SHA512withRSA extends RSA {
357         public SHA512withRSA() {
358             super(&quot;SHA-512&quot;);
359         }
360     }
361 
362     public static final class MD5withRSA extends RSA {
363         public MD5withRSA() {
364             super(&quot;MD5&quot;);
365         }
366     }
367 
368     public static final class MD2withRSA extends RSA {
369         public MD2withRSA() {
370             super(&quot;MD2&quot;);
371         }
372     }
373 
374     public static final class SHA1withECDSA extends ECDSA {
375         public SHA1withECDSA() {
376             super(&quot;SHA-1&quot;);
377         }
378     }
379 
380     public static final class SHA224withECDSA extends ECDSA {
381         public SHA224withECDSA() {
382             super(&quot;SHA-224&quot;);
383         }
384     }
385 
386     public static final class SHA256withECDSA extends ECDSA {
387         public SHA256withECDSA() {
388             super(&quot;SHA-256&quot;);
389         }
390     }
391 
392     public static final class SHA384withECDSA extends ECDSA {
393         public SHA384withECDSA() {
394             super(&quot;SHA-384&quot;);
395         }
396     }
397 
398     public static final class SHA512withECDSA extends ECDSA {
399         public SHA512withECDSA() {
400             super(&quot;SHA-512&quot;);
401         }
402     }
403 
404     static class ECDSA extends CSignature {
405 
406         public ECDSA(String messageDigestAlgorithm) {
407             super(&quot;EC&quot;, messageDigestAlgorithm);
408         }
409 
410         // initialize for signing. See JCA doc
411         @Override
412         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<a name="9" id="anc9"></a>


413             if ((key instanceof CPrivateKey) == false
414                     || !key.getAlgorithm().equalsIgnoreCase(&quot;EC&quot;)) {
<a name="10" id="anc10"></a><span class="line-modified">415                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

416             }
417             privateKey = (CPrivateKey) key;
418 
419             this.publicKey = null;
420             resetDigest();
421         }
422 
423         // initialize for signing. See JCA doc
424         @Override
425         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<a name="11" id="anc11"></a>


426             // This signature accepts only ECPublicKey
427             if ((key instanceof ECPublicKey) == false) {
<a name="12" id="anc12"></a><span class="line-modified">428                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

429             }
430 
<a name="13" id="anc13"></a><span class="line-removed">431 </span>
432             if ((key instanceof CPublicKey) == false) {
433                 try {
434                     publicKey = importECPublicKey(&quot;EC&quot;,
435                             CKey.generateECBlob(key),
436                             KeyUtil.getKeySize(key));
437                 } catch (KeyStoreException e) {
438                     throw new InvalidKeyException(e);
439                 }
440             } else {
441                 publicKey = (CPublicKey) key;
442             }
443 
444             this.privateKey = null;
445             resetDigest();
446         }
447 
448         @Override
449         protected byte[] engineSign() throws SignatureException {
450             byte[] hash = getDigestValue();
451             byte[] raw = signCngHash(0, hash, hash.length,
452                     0,
453                     null,
454                     privateKey.getHCryptProvider(), 0);
455             return ECUtil.encodeSignature(raw);
456         }
457 
458         @Override
459         protected boolean engineVerify(byte[] sigBytes) throws SignatureException {
460             byte[] hash = getDigestValue();
461             sigBytes = ECUtil.decodeSignature(sigBytes);
462             return verifyCngSignedHash(
463                     0,
464                     hash, hash.length,
465                     sigBytes, sigBytes.length,
466                     0,
467                     null,
468                     publicKey.getHCryptProvider(),
469                     0
470             );
471         }
472     }
473 
474     public static final class PSS extends RSA {
475 
476         private PSSParameterSpec pssParams = null;
477 
478         // Workaround: Cannot import raw public key to CNG. This signature
479         // will be used for verification if key is not from MSCAPI.
480         private Signature fallbackSignature;
481 
482         public PSS() {
483             super(null);
484         }
485 
486         @Override
487         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
488             super.engineInitSign(key);
489             fallbackSignature = null;
490         }
491 
492         @Override
493         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<a name="14" id="anc14"></a>


494             // This signature accepts only RSAPublicKey
495             if ((key instanceof java.security.interfaces.RSAPublicKey) == false) {
<a name="15" id="anc15"></a><span class="line-modified">496                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

497             }
498 
499             this.privateKey = null;
500 
501             if (key instanceof CPublicKey) {
502                 fallbackSignature = null;
503                 publicKey = (CPublicKey) key;
504             } else {
505                 if (fallbackSignature == null) {
506                     try {
507                         fallbackSignature = Signature.getInstance(
508                                 &quot;RSASSA-PSS&quot;, &quot;SunRsaSign&quot;);
509                     } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
510                         throw new InvalidKeyException(&quot;Invalid key&quot;, e);
511                     }
512                 }
513                 fallbackSignature.initVerify(key);
514                 if (pssParams != null) {
515                     try {
516                         fallbackSignature.setParameter(pssParams);
517                     } catch (InvalidAlgorithmParameterException e) {
518                         throw new InvalidKeyException(&quot;Invalid params&quot;, e);
519                     }
520                 }
521                 publicKey = null;
522             }
523             resetDigest();
524         }
525 
526         @Override
527         protected void engineUpdate(byte b) throws SignatureException {
528             ensureInit();
529             if (fallbackSignature != null) {
530                 fallbackSignature.update(b);
531             } else {
532                 messageDigest.update(b);
533             }
534             needsReset = true;
535         }
536 
537         @Override
538         protected void engineUpdate(byte[] b, int off, int len) throws SignatureException {
539             ensureInit();
540             if (fallbackSignature != null) {
541                 fallbackSignature.update(b, off, len);
542             } else {
543                 messageDigest.update(b, off, len);
544             }
545             needsReset = true;
546         }
547 
548         @Override
549         protected void engineUpdate(ByteBuffer input) {
550             try {
551                 ensureInit();
552             } catch (SignatureException se) {
553                 // hack for working around API bug
554                 throw new RuntimeException(se.getMessage());
555             }
556             if (fallbackSignature != null) {
557                 try {
558                     fallbackSignature.update(input);
559                 } catch (SignatureException se) {
560                     // hack for working around API bug
561                     throw new RuntimeException(se.getMessage());
562                 }
563             } else {
564                 messageDigest.update(input);
565             }
566             needsReset = true;
567         }
568 
569         @Override
570         protected byte[] engineSign() throws SignatureException {
571             ensureInit();
572             byte[] hash = getDigestValue();
573             return signCngHash(2, hash, hash.length,
574                     pssParams.getSaltLength(),
575                     ((MGF1ParameterSpec)
576                             pssParams.getMGFParameters()).getDigestAlgorithm(),
577                     privateKey.getHCryptProvider(), privateKey.getHCryptKey());
578         }
579 
580         @Override
581         protected boolean engineVerify(byte[] sigBytes) throws SignatureException {
582             ensureInit();
583             if (fallbackSignature != null) {
584                 needsReset = false;
585                 return fallbackSignature.verify(sigBytes);
586             } else {
587                 byte[] hash = getDigestValue();
588                 return verifyCngSignedHash(
589                         2, hash, hash.length,
590                         sigBytes, sigBytes.length,
591                         pssParams.getSaltLength(),
592                         ((MGF1ParameterSpec)
593                                 pssParams.getMGFParameters()).getDigestAlgorithm(),
594                         publicKey.getHCryptProvider(),
595                         publicKey.getHCryptKey()
596                 );
597             }
598         }
599 
600         @Override
601         protected void engineSetParameter(AlgorithmParameterSpec params)
602                 throws InvalidAlgorithmParameterException {
603             if (needsReset) {
604                 throw new ProviderException
605                         (&quot;Cannot set parameters during operations&quot;);
606             }
607             this.pssParams = validateSigParams(params);
608             if (fallbackSignature != null) {
609                 fallbackSignature.setParameter(params);
610             }
611         }
612 
613         @Override
614         protected AlgorithmParameters engineGetParameters() {
615             AlgorithmParameters ap = null;
616             if (this.pssParams != null) {
617                 try {
618                     ap = AlgorithmParameters.getInstance(&quot;RSASSA-PSS&quot;);
619                     ap.init(this.pssParams);
620                 } catch (GeneralSecurityException gse) {
621                     throw new ProviderException(gse.getMessage());
622                 }
623             }
624             return ap;
625         }
626 
627         private void ensureInit() throws SignatureException {
628             if (this.privateKey == null &amp;&amp; this.publicKey == null
629                     &amp;&amp; fallbackSignature == null) {
630                 throw new SignatureException(&quot;Missing key&quot;);
631             }
632             if (this.pssParams == null) {
633                 // Parameters are required for signature verification
634                 throw new SignatureException
635                         (&quot;Parameters required for RSASSA-PSS signatures&quot;);
636             }
637             if (fallbackSignature == null &amp;&amp; messageDigest == null) {
638                 // This could happen if initVerify(softKey), setParameter(),
639                 // and initSign() were called. No messageDigest. Create it.
640                 try {
641                     messageDigest = MessageDigest
642                             .getInstance(pssParams.getDigestAlgorithm());
643                 } catch (NoSuchAlgorithmException e) {
644                     throw new SignatureException(e);
645                 }
646             }
647         }
648 
649         /**
650          * Validate the specified Signature PSS parameters.
651          */
652         private PSSParameterSpec validateSigParams(AlgorithmParameterSpec p)
653                 throws InvalidAlgorithmParameterException {
654 
655             if (p == null) {
656                 throw new InvalidAlgorithmParameterException
657                         (&quot;Parameters cannot be null&quot;);
658             }
659 
660             if (!(p instanceof PSSParameterSpec)) {
661                 throw new InvalidAlgorithmParameterException
662                         (&quot;parameters must be type PSSParameterSpec&quot;);
663             }
664 
665             // no need to validate again if same as current signature parameters
666             PSSParameterSpec params = (PSSParameterSpec) p;
667             if (params == this.pssParams) return params;
668 
669             // now sanity check the parameter values
670             if (!(params.getMGFAlgorithm().equalsIgnoreCase(&quot;MGF1&quot;))) {
671                 throw new InvalidAlgorithmParameterException(&quot;Only supports MGF1&quot;);
672 
673             }
674 
675             if (params.getTrailerField() != PSSParameterSpec.TRAILER_FIELD_BC) {
676                 throw new InvalidAlgorithmParameterException
677                         (&quot;Only supports TrailerFieldBC(1)&quot;);
678             }
679 
680             AlgorithmParameterSpec algSpec = params.getMGFParameters();
681             if (!(algSpec instanceof MGF1ParameterSpec)) {
682                 throw new InvalidAlgorithmParameterException
683                         (&quot;Only support MGF1ParameterSpec&quot;);
684             }
685 
686             MGF1ParameterSpec mgfSpec = (MGF1ParameterSpec)algSpec;
687 
688             String msgHashAlg = params.getDigestAlgorithm()
689                     .toLowerCase(Locale.ROOT).replaceAll(&quot;-&quot;, &quot;&quot;);
690             if (msgHashAlg.equals(&quot;sha&quot;)) {
691                 msgHashAlg = &quot;sha1&quot;;
692             }
693             String mgf1HashAlg = mgfSpec.getDigestAlgorithm()
694                     .toLowerCase(Locale.ROOT).replaceAll(&quot;-&quot;, &quot;&quot;);
695             if (mgf1HashAlg.equals(&quot;sha&quot;)) {
696                 mgf1HashAlg = &quot;sha1&quot;;
697             }
698 
699             if (!mgf1HashAlg.equals(msgHashAlg)) {
700                 throw new InvalidAlgorithmParameterException
701                         (&quot;MGF1 hash must be the same as message hash&quot;);
702             }
703 
704             return params;
705         }
706     }
707 
708     /**
709      * Sign hash using CNG API with HCRYPTKEY.
710      * @param type 0 no padding, 1, pkcs1, 2, pss
711      */
712     native static byte[] signCngHash(
713             int type, byte[] hash,
714             int hashSize, int saltLength, String hashAlgorithm,
715             long hCryptProv, long nCryptKey)
716             throws SignatureException;
717 
718     /**
719      * Verify a signed hash using CNG API with HCRYPTKEY.
720      * @param type 0 no padding, 1, pkcs1, 2, pss
721      */
722     private native static boolean verifyCngSignedHash(
723             int type, byte[] hash, int hashSize,
724             byte[] signature, int signatureSize,
725             int saltLength, String hashAlgorithm,
726             long hCryptProv, long hKey) throws SignatureException;
727 
728     /**
729      * Resets the message digest if needed.
730      */
731     protected void resetDigest() {
732         if (needsReset) {
733             if (messageDigest != null) {
734                 messageDigest.reset();
735             }
736             needsReset = false;
737         }
738     }
739 
740     protected byte[] getDigestValue() throws SignatureException {
741         needsReset = false;
742         return messageDigest.digest();
743     }
744 
745     protected void setDigestName(String name) {
746         messageDigestAlgorithm = name;
747     }
748 
749     /**
750      * Updates the data to be signed or verified
751      * using the specified byte.
752      *
753      * @param b the byte to use for the update.
754      *
755      * @exception SignatureException if the engine is not initialized
756      * properly.
757      */
758     @Override
759     protected void engineUpdate(byte b) throws SignatureException {
760         messageDigest.update(b);
761         needsReset = true;
762     }
763 
764     /**
765      * Updates the data to be signed or verified, using the
766      * specified array of bytes, starting at the specified offset.
767      *
768      * @param b the array of bytes
769      * @param off the offset to start from in the array of bytes
770      * @param len the number of bytes to use, starting at offset
771      *
772      * @exception SignatureException if the engine is not initialized
773      * properly
774      */
775     @Override
776     protected void engineUpdate(byte[] b, int off, int len)
777             throws SignatureException {
778         messageDigest.update(b, off, len);
779         needsReset = true;
780     }
781 
782     /**
783      * Updates the data to be signed or verified, using the
784      * specified ByteBuffer.
785      *
786      * @param input the ByteBuffer
787      */
788     @Override
789     protected void engineUpdate(ByteBuffer input) {
790         messageDigest.update(input);
791         needsReset = true;
792     }
793 
794     /**
795      * Convert array from big endian to little endian, or vice versa.
796      */
797     private static byte[] convertEndianArray(byte[] byteArray) {
798         if (byteArray == null || byteArray.length == 0)
799             return byteArray;
800 
801         byte [] retval = new byte[byteArray.length];
802 
803         // make it big endian
804         for (int i=0;i &lt; byteArray.length;i++)
805             retval[i] = byteArray[byteArray.length - i - 1];
806 
807         return retval;
808     }
809 
810     /**
811      * Sign hash using Microsoft Crypto API with HCRYPTKEY.
812      * The returned data is in little-endian.
813      */
814     private native static byte[] signHash(boolean noHashOID, byte[] hash,
815         int hashSize, String hashAlgorithm, long hCryptProv, long hCryptKey)
816             throws SignatureException;
817 
818     /**
819      * Verify a signed hash using Microsoft Crypto API with HCRYPTKEY.
820      */
821     private native static boolean verifySignedHash(byte[] hash, int hashSize,
822         String hashAlgorithm, byte[] signature, int signatureSize,
823         long hCryptProv, long hCryptKey) throws SignatureException;
824 
825     /**
826      * Sets the specified algorithm parameter to the specified
827      * value. This method supplies a general-purpose mechanism through
828      * which it is possible to set the various parameters of this object.
829      * A parameter may be any settable parameter for the algorithm, such as
830      * a parameter size, or a source of random bits for signature generation
831      * (if appropriate), or an indication of whether or not to perform
832      * a specific but optional computation. A uniform algorithm-specific
833      * naming scheme for each parameter is desirable but left unspecified
834      * at this time.
835      *
836      * @param param the string identifier of the parameter.
837      *
838      * @param value the parameter value.
839      *
840      * @exception InvalidParameterException if &lt;code&gt;param&lt;/code&gt; is an
841      * invalid parameter for this signature algorithm engine,
842      * the parameter is already set
843      * and cannot be set again, a security exception occurs, and so on.
844      *
845      * @deprecated Replaced by {@link
846      * #engineSetParameter(java.security.spec.AlgorithmParameterSpec)
847      * engineSetParameter}.
848      */
849     @Override
850     @Deprecated
851     protected void engineSetParameter(String param, Object value)
852             throws InvalidParameterException {
853         throw new InvalidParameterException(&quot;Parameter not supported&quot;);
854     }
855 
856     /**
857      * Sets this signature engine with the specified algorithm parameter.
858      *
859      * @param params the parameters
860      *
861      * @exception InvalidAlgorithmParameterException if the given
862      * parameter is invalid
863      */
864     @Override
865     protected void engineSetParameter(AlgorithmParameterSpec params)
866             throws InvalidAlgorithmParameterException {
867         if (params != null) {
868             throw new InvalidAlgorithmParameterException(&quot;No parameter accepted&quot;);
869         }
870     }
871 
872     /**
873      * Gets the value of the specified algorithm parameter.
874      * This method supplies a general-purpose mechanism through which it
875      * is possible to get the various parameters of this object. A parameter
876      * may be any settable parameter for the algorithm, such as a parameter
877      * size, or  a source of random bits for signature generation (if
878      * appropriate), or an indication of whether or not to perform a
879      * specific but optional computation. A uniform algorithm-specific
880      * naming scheme for each parameter is desirable but left unspecified
881      * at this time.
882      *
883      * @param param the string name of the parameter.
884      *
885      * @return the object that represents the parameter value, or null if
886      * there is none.
887      *
888      * @exception InvalidParameterException if &lt;code&gt;param&lt;/code&gt; is an
889      * invalid parameter for this engine, or another exception occurs while
890      * trying to get this parameter.
891      *
892      * @deprecated
893      */
894     @Override
895     @Deprecated
896     protected Object engineGetParameter(String param)
897            throws InvalidParameterException {
898         throw new InvalidParameterException(&quot;Parameter not supported&quot;);
899     }
900 
901     /**
902      * Gets the algorithm parameter from this signature engine.
903      *
904      * @return the parameter, or null if no parameter is used.
905      */
906     @Override
907     protected AlgorithmParameters engineGetParameters() {
908         return null;
909     }
910 
911     /**
912      * Imports a public-key BLOB.
913      */
914     // used by CRSACipher
915     static native CPublicKey importPublicKey(
916             String alg, byte[] keyBlob, int keySize) throws KeyStoreException;
917 
918     static native CPublicKey importECPublicKey(
919             String alg, byte[] keyBlob, int keySize) throws KeyStoreException;
920 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
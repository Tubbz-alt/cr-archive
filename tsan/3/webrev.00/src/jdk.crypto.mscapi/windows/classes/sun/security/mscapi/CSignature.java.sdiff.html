<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CPublicKey.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libsunmscapi/security.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
101                 messageDigestAlgorithm = messageDigest.getAlgorithm();
102             } catch (NoSuchAlgorithmException e) {
103                 throw new ProviderException(e);
104             }
105         } else {
106             messageDigest = null;
107             messageDigestAlgorithm = null;
108         }
109         needsReset = false;
110     }
111 
112     static class RSA extends CSignature {
113 
114         public RSA(String digestAlgorithm) {
115             super(&quot;RSA&quot;, digestAlgorithm);
116         }
117 
118         // initialize for signing. See JCA doc
119         @Override
120         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<span class="line-modified">121 </span>


122             if ((key instanceof CPrivateKey) == false
123                     || !key.getAlgorithm().equalsIgnoreCase(&quot;RSA&quot;)) {
<span class="line-modified">124                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

125             }
126             privateKey = (CPrivateKey) key;
127 
128             // Check against the local and global values to make sure
129             // the sizes are ok.  Round up to nearest byte.
130             RSAKeyFactory.checkKeyLengths(((privateKey.length() + 7) &amp; ~7),
131                     null, CKeyPairGenerator.RSA.KEY_SIZE_MIN,
132                     CKeyPairGenerator.RSA.KEY_SIZE_MAX);
133 
134             this.publicKey = null;
135             resetDigest();
136         }
137 
138         // initialize for signing. See JCA doc
139         @Override
140         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {



141             // This signature accepts only RSAPublicKey
142             if ((key instanceof RSAPublicKey) == false) {
<span class="line-modified">143                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

144             }
145 
146 
147             if ((key instanceof CPublicKey) == false) {
148 
149                 // convert key to MSCAPI format
150                 java.security.interfaces.RSAPublicKey rsaKey =
151                         (java.security.interfaces.RSAPublicKey) key;
152 
153                 BigInteger modulus = rsaKey.getModulus();
154                 BigInteger exponent =  rsaKey.getPublicExponent();
155 
156                 // Check against the local and global values to make sure
157                 // the sizes are ok.  Round up to the nearest byte.
158                 RSAKeyFactory.checkKeyLengths(((modulus.bitLength() + 7) &amp; ~7),
159                         exponent, -1, CKeyPairGenerator.RSA.KEY_SIZE_MAX);
160 
161                 byte[] modulusBytes = modulus.toByteArray();
162                 byte[] exponentBytes = exponent.toByteArray();
163 
</pre>
<hr />
<pre>
184             resetDigest();
185         }
186 
187         /**
188          * Returns the signature bytes of all the data
189          * updated so far.
190          * The format of the signature depends on the underlying
191          * signature scheme.
192          *
193          * @return the signature bytes of the signing operation&#39;s result.
194          *
195          * @exception SignatureException if the engine is not
196          * initialized properly or if this signature algorithm is unable to
197          * process the input data provided.
198          */
199         @Override
200         protected byte[] engineSign() throws SignatureException {
201 
202             byte[] hash = getDigestValue();
203 
<span class="line-modified">204             // Omit the hash OID when generating a NONEwithRSA signature</span>
<span class="line-modified">205             boolean noHashOID = this instanceof NONEwithRSA;</span>
<span class="line-modified">206 </span>
<span class="line-modified">207             // Sign hash using MS Crypto APIs</span>
<span class="line-modified">208             byte[] result = signHash(noHashOID, hash, hash.length,</span>





209                         messageDigestAlgorithm, privateKey.getHCryptProvider(),
210                         privateKey.getHCryptKey());
211 
<span class="line-modified">212             // Convert signature array from little endian to big endian</span>
<span class="line-modified">213             return convertEndianArray(result);</span>

214         }
215 
216         /**
217          * Verifies the passed-in signature.
218          *
219          * @param sigBytes the signature bytes to be verified.
220          *
221          * @return true if the signature was verified, false if not.
222          *
223          * @exception SignatureException if the engine is not
224          * initialized properly, the passed-in signature is improperly
225          * encoded or of the wrong type, if this signature algorithm is unable to
226          * process the input data provided, etc.
227          */
228         @Override
229         protected boolean engineVerify(byte[] sigBytes)
230                 throws SignatureException {
231             byte[] hash = getDigestValue();
232 
<span class="line-modified">233             return verifySignedHash(hash, hash.length,</span>
<span class="line-modified">234                     messageDigestAlgorithm, convertEndianArray(sigBytes),</span>
<span class="line-modified">235                     sigBytes.length, publicKey.getHCryptProvider(),</span>
<span class="line-modified">236                     publicKey.getHCryptKey());</span>










237         }
238 
239         /**
240          * Generates a public-key BLOB from a key&#39;s components.
241          */
242         // used by CRSACipher
243         static native byte[] generatePublicKeyBlob(
244                 int keyBitLength, byte[] modulus, byte[] publicExponent)
245                 throws InvalidKeyException;
246 
247     }
248 
249     // Nested class for NONEwithRSA signatures
250     public static final class NONEwithRSA extends RSA {
251 
252         // the longest supported digest is 512 bits (SHA-512)
253         private static final int RAW_RSA_MAX = 64;
254 
255         private final byte[] precomputedDigest;
256         private int offset = 0;
</pre>
<hr />
<pre>
393         public SHA384withECDSA() {
394             super(&quot;SHA-384&quot;);
395         }
396     }
397 
398     public static final class SHA512withECDSA extends ECDSA {
399         public SHA512withECDSA() {
400             super(&quot;SHA-512&quot;);
401         }
402     }
403 
404     static class ECDSA extends CSignature {
405 
406         public ECDSA(String messageDigestAlgorithm) {
407             super(&quot;EC&quot;, messageDigestAlgorithm);
408         }
409 
410         // initialize for signing. See JCA doc
411         @Override
412         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {



413             if ((key instanceof CPrivateKey) == false
414                     || !key.getAlgorithm().equalsIgnoreCase(&quot;EC&quot;)) {
<span class="line-modified">415                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

416             }
417             privateKey = (CPrivateKey) key;
418 
419             this.publicKey = null;
420             resetDigest();
421         }
422 
423         // initialize for signing. See JCA doc
424         @Override
425         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {



426             // This signature accepts only ECPublicKey
427             if ((key instanceof ECPublicKey) == false) {
<span class="line-modified">428                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

429             }
430 
<span class="line-removed">431 </span>
432             if ((key instanceof CPublicKey) == false) {
433                 try {
434                     publicKey = importECPublicKey(&quot;EC&quot;,
435                             CKey.generateECBlob(key),
436                             KeyUtil.getKeySize(key));
437                 } catch (KeyStoreException e) {
438                     throw new InvalidKeyException(e);
439                 }
440             } else {
441                 publicKey = (CPublicKey) key;
442             }
443 
444             this.privateKey = null;
445             resetDigest();
446         }
447 
448         @Override
449         protected byte[] engineSign() throws SignatureException {
450             byte[] hash = getDigestValue();
451             byte[] raw = signCngHash(0, hash, hash.length,
</pre>
<hr />
<pre>
474     public static final class PSS extends RSA {
475 
476         private PSSParameterSpec pssParams = null;
477 
478         // Workaround: Cannot import raw public key to CNG. This signature
479         // will be used for verification if key is not from MSCAPI.
480         private Signature fallbackSignature;
481 
482         public PSS() {
483             super(null);
484         }
485 
486         @Override
487         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
488             super.engineInitSign(key);
489             fallbackSignature = null;
490         }
491 
492         @Override
493         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {



494             // This signature accepts only RSAPublicKey
495             if ((key instanceof java.security.interfaces.RSAPublicKey) == false) {
<span class="line-modified">496                 throw new InvalidKeyException(&quot;Key type not supported&quot;);</span>

497             }
498 
499             this.privateKey = null;
500 
501             if (key instanceof CPublicKey) {
502                 fallbackSignature = null;
503                 publicKey = (CPublicKey) key;
504             } else {
505                 if (fallbackSignature == null) {
506                     try {
507                         fallbackSignature = Signature.getInstance(
508                                 &quot;RSASSA-PSS&quot;, &quot;SunRsaSign&quot;);
509                     } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
510                         throw new InvalidKeyException(&quot;Invalid key&quot;, e);
511                     }
512                 }
513                 fallbackSignature.initVerify(key);
514                 if (pssParams != null) {
515                     try {
516                         fallbackSignature.setParameter(pssParams);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
101                 messageDigestAlgorithm = messageDigest.getAlgorithm();
102             } catch (NoSuchAlgorithmException e) {
103                 throw new ProviderException(e);
104             }
105         } else {
106             messageDigest = null;
107             messageDigestAlgorithm = null;
108         }
109         needsReset = false;
110     }
111 
112     static class RSA extends CSignature {
113 
114         public RSA(String digestAlgorithm) {
115             super(&quot;RSA&quot;, digestAlgorithm);
116         }
117 
118         // initialize for signing. See JCA doc
119         @Override
120         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<span class="line-modified">121             if (key == null) {</span>
<span class="line-added">122                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="line-added">123             }</span>
124             if ((key instanceof CPrivateKey) == false
125                     || !key.getAlgorithm().equalsIgnoreCase(&quot;RSA&quot;)) {
<span class="line-modified">126                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="line-added">127                         + key.getClass() + &quot; &quot; + key.getAlgorithm());</span>
128             }
129             privateKey = (CPrivateKey) key;
130 
131             // Check against the local and global values to make sure
132             // the sizes are ok.  Round up to nearest byte.
133             RSAKeyFactory.checkKeyLengths(((privateKey.length() + 7) &amp; ~7),
134                     null, CKeyPairGenerator.RSA.KEY_SIZE_MIN,
135                     CKeyPairGenerator.RSA.KEY_SIZE_MAX);
136 
137             this.publicKey = null;
138             resetDigest();
139         }
140 
141         // initialize for signing. See JCA doc
142         @Override
143         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<span class="line-added">144             if (key == null) {</span>
<span class="line-added">145                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="line-added">146             }</span>
147             // This signature accepts only RSAPublicKey
148             if ((key instanceof RSAPublicKey) == false) {
<span class="line-modified">149                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="line-added">150                         + key.getClass());</span>
151             }
152 
153 
154             if ((key instanceof CPublicKey) == false) {
155 
156                 // convert key to MSCAPI format
157                 java.security.interfaces.RSAPublicKey rsaKey =
158                         (java.security.interfaces.RSAPublicKey) key;
159 
160                 BigInteger modulus = rsaKey.getModulus();
161                 BigInteger exponent =  rsaKey.getPublicExponent();
162 
163                 // Check against the local and global values to make sure
164                 // the sizes are ok.  Round up to the nearest byte.
165                 RSAKeyFactory.checkKeyLengths(((modulus.bitLength() + 7) &amp; ~7),
166                         exponent, -1, CKeyPairGenerator.RSA.KEY_SIZE_MAX);
167 
168                 byte[] modulusBytes = modulus.toByteArray();
169                 byte[] exponentBytes = exponent.toByteArray();
170 
</pre>
<hr />
<pre>
191             resetDigest();
192         }
193 
194         /**
195          * Returns the signature bytes of all the data
196          * updated so far.
197          * The format of the signature depends on the underlying
198          * signature scheme.
199          *
200          * @return the signature bytes of the signing operation&#39;s result.
201          *
202          * @exception SignatureException if the engine is not
203          * initialized properly or if this signature algorithm is unable to
204          * process the input data provided.
205          */
206         @Override
207         protected byte[] engineSign() throws SignatureException {
208 
209             byte[] hash = getDigestValue();
210 
<span class="line-modified">211             if (privateKey.getHCryptKey() == 0) {</span>
<span class="line-modified">212                 return signCngHash(1, hash, hash.length,</span>
<span class="line-modified">213                         0,</span>
<span class="line-modified">214                         this instanceof NONEwithRSA ? null : messageDigestAlgorithm,</span>
<span class="line-modified">215                         privateKey.getHCryptProvider(), 0);</span>
<span class="line-added">216             } else {</span>
<span class="line-added">217                 // Omit the hash OID when generating a NONEwithRSA signature</span>
<span class="line-added">218                 boolean noHashOID = this instanceof NONEwithRSA;</span>
<span class="line-added">219                 // Sign hash using MS Crypto APIs</span>
<span class="line-added">220                 byte[] result = signHash(noHashOID, hash, hash.length,</span>
221                         messageDigestAlgorithm, privateKey.getHCryptProvider(),
222                         privateKey.getHCryptKey());
223 
<span class="line-modified">224                 // Convert signature array from little endian to big endian</span>
<span class="line-modified">225                 return convertEndianArray(result);</span>
<span class="line-added">226             }</span>
227         }
228 
229         /**
230          * Verifies the passed-in signature.
231          *
232          * @param sigBytes the signature bytes to be verified.
233          *
234          * @return true if the signature was verified, false if not.
235          *
236          * @exception SignatureException if the engine is not
237          * initialized properly, the passed-in signature is improperly
238          * encoded or of the wrong type, if this signature algorithm is unable to
239          * process the input data provided, etc.
240          */
241         @Override
242         protected boolean engineVerify(byte[] sigBytes)
243                 throws SignatureException {
244             byte[] hash = getDigestValue();
245 
<span class="line-modified">246             if (publicKey.getHCryptKey() == 0) {</span>
<span class="line-modified">247                 return verifyCngSignedHash(</span>
<span class="line-modified">248                         1, hash, hash.length,</span>
<span class="line-modified">249                         sigBytes, sigBytes.length,</span>
<span class="line-added">250                         0,</span>
<span class="line-added">251                         messageDigestAlgorithm,</span>
<span class="line-added">252                         publicKey.getHCryptProvider(),</span>
<span class="line-added">253                         0);</span>
<span class="line-added">254             } else {</span>
<span class="line-added">255                 return verifySignedHash(hash, hash.length,</span>
<span class="line-added">256                         messageDigestAlgorithm, convertEndianArray(sigBytes),</span>
<span class="line-added">257                         sigBytes.length, publicKey.getHCryptProvider(),</span>
<span class="line-added">258                         publicKey.getHCryptKey());</span>
<span class="line-added">259             }</span>
260         }
261 
262         /**
263          * Generates a public-key BLOB from a key&#39;s components.
264          */
265         // used by CRSACipher
266         static native byte[] generatePublicKeyBlob(
267                 int keyBitLength, byte[] modulus, byte[] publicExponent)
268                 throws InvalidKeyException;
269 
270     }
271 
272     // Nested class for NONEwithRSA signatures
273     public static final class NONEwithRSA extends RSA {
274 
275         // the longest supported digest is 512 bits (SHA-512)
276         private static final int RAW_RSA_MAX = 64;
277 
278         private final byte[] precomputedDigest;
279         private int offset = 0;
</pre>
<hr />
<pre>
416         public SHA384withECDSA() {
417             super(&quot;SHA-384&quot;);
418         }
419     }
420 
421     public static final class SHA512withECDSA extends ECDSA {
422         public SHA512withECDSA() {
423             super(&quot;SHA-512&quot;);
424         }
425     }
426 
427     static class ECDSA extends CSignature {
428 
429         public ECDSA(String messageDigestAlgorithm) {
430             super(&quot;EC&quot;, messageDigestAlgorithm);
431         }
432 
433         // initialize for signing. See JCA doc
434         @Override
435         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
<span class="line-added">436             if (key == null) {</span>
<span class="line-added">437                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="line-added">438             }</span>
439             if ((key instanceof CPrivateKey) == false
440                     || !key.getAlgorithm().equalsIgnoreCase(&quot;EC&quot;)) {
<span class="line-modified">441                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="line-added">442                         + key.getClass() + &quot; &quot; + key.getAlgorithm());</span>
443             }
444             privateKey = (CPrivateKey) key;
445 
446             this.publicKey = null;
447             resetDigest();
448         }
449 
450         // initialize for signing. See JCA doc
451         @Override
452         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<span class="line-added">453             if (key == null) {</span>
<span class="line-added">454                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="line-added">455             }</span>
456             // This signature accepts only ECPublicKey
457             if ((key instanceof ECPublicKey) == false) {
<span class="line-modified">458                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="line-added">459                         + key.getClass());</span>
460             }
461 

462             if ((key instanceof CPublicKey) == false) {
463                 try {
464                     publicKey = importECPublicKey(&quot;EC&quot;,
465                             CKey.generateECBlob(key),
466                             KeyUtil.getKeySize(key));
467                 } catch (KeyStoreException e) {
468                     throw new InvalidKeyException(e);
469                 }
470             } else {
471                 publicKey = (CPublicKey) key;
472             }
473 
474             this.privateKey = null;
475             resetDigest();
476         }
477 
478         @Override
479         protected byte[] engineSign() throws SignatureException {
480             byte[] hash = getDigestValue();
481             byte[] raw = signCngHash(0, hash, hash.length,
</pre>
<hr />
<pre>
504     public static final class PSS extends RSA {
505 
506         private PSSParameterSpec pssParams = null;
507 
508         // Workaround: Cannot import raw public key to CNG. This signature
509         // will be used for verification if key is not from MSCAPI.
510         private Signature fallbackSignature;
511 
512         public PSS() {
513             super(null);
514         }
515 
516         @Override
517         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
518             super.engineInitSign(key);
519             fallbackSignature = null;
520         }
521 
522         @Override
523         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
<span class="line-added">524             if (key == null) {</span>
<span class="line-added">525                 throw new InvalidKeyException(&quot;Key cannot be null&quot;);</span>
<span class="line-added">526             }</span>
527             // This signature accepts only RSAPublicKey
528             if ((key instanceof java.security.interfaces.RSAPublicKey) == false) {
<span class="line-modified">529                 throw new InvalidKeyException(&quot;Key type not supported: &quot;</span>
<span class="line-added">530                         + key.getClass());</span>
531             }
532 
533             this.privateKey = null;
534 
535             if (key instanceof CPublicKey) {
536                 fallbackSignature = null;
537                 publicKey = (CPublicKey) key;
538             } else {
539                 if (fallbackSignature == null) {
540                     try {
541                         fallbackSignature = Signature.getInstance(
542                                 &quot;RSASSA-PSS&quot;, &quot;SunRsaSign&quot;);
543                     } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
544                         throw new InvalidKeyException(&quot;Invalid key&quot;, e);
545                     }
546                 }
547                 fallbackSignature.initVerify(key);
548                 if (pssParams != null) {
549                     try {
550                         fallbackSignature.setParameter(pssParams);
</pre>
</td>
</tr>
</table>
<center><a href="CPublicKey.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libsunmscapi/security.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
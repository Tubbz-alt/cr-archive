diff a/src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java b/src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java
--- a/src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java
+++ b/src/jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CSignature.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -116,14 +116,17 @@
         }
 
         // initialize for signing. See JCA doc
         @Override
         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
-
+            if (key == null) {
+                throw new InvalidKeyException("Key cannot be null");
+            }
             if ((key instanceof CPrivateKey) == false
                     || !key.getAlgorithm().equalsIgnoreCase("RSA")) {
-                throw new InvalidKeyException("Key type not supported");
+                throw new InvalidKeyException("Key type not supported: "
+                        + key.getClass() + " " + key.getAlgorithm());
             }
             privateKey = (CPrivateKey) key;
 
             // Check against the local and global values to make sure
             // the sizes are ok.  Round up to nearest byte.
@@ -136,13 +139,17 @@
         }
 
         // initialize for signing. See JCA doc
         @Override
         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
+            if (key == null) {
+                throw new InvalidKeyException("Key cannot be null");
+            }
             // This signature accepts only RSAPublicKey
             if ((key instanceof RSAPublicKey) == false) {
-                throw new InvalidKeyException("Key type not supported");
+                throw new InvalidKeyException("Key type not supported: "
+                        + key.getClass());
             }
 
 
             if ((key instanceof CPublicKey) == false) {
 
@@ -199,20 +206,26 @@
         @Override
         protected byte[] engineSign() throws SignatureException {
 
             byte[] hash = getDigestValue();
 
-            // Omit the hash OID when generating a NONEwithRSA signature
-            boolean noHashOID = this instanceof NONEwithRSA;
-
-            // Sign hash using MS Crypto APIs
-            byte[] result = signHash(noHashOID, hash, hash.length,
+            if (privateKey.getHCryptKey() == 0) {
+                return signCngHash(1, hash, hash.length,
+                        0,
+                        this instanceof NONEwithRSA ? null : messageDigestAlgorithm,
+                        privateKey.getHCryptProvider(), 0);
+            } else {
+                // Omit the hash OID when generating a NONEwithRSA signature
+                boolean noHashOID = this instanceof NONEwithRSA;
+                // Sign hash using MS Crypto APIs
+                byte[] result = signHash(noHashOID, hash, hash.length,
                         messageDigestAlgorithm, privateKey.getHCryptProvider(),
                         privateKey.getHCryptKey());
 
-            // Convert signature array from little endian to big endian
-            return convertEndianArray(result);
+                // Convert signature array from little endian to big endian
+                return convertEndianArray(result);
+            }
         }
 
         /**
          * Verifies the passed-in signature.
          *
@@ -228,14 +241,24 @@
         @Override
         protected boolean engineVerify(byte[] sigBytes)
                 throws SignatureException {
             byte[] hash = getDigestValue();
 
-            return verifySignedHash(hash, hash.length,
-                    messageDigestAlgorithm, convertEndianArray(sigBytes),
-                    sigBytes.length, publicKey.getHCryptProvider(),
-                    publicKey.getHCryptKey());
+            if (publicKey.getHCryptKey() == 0) {
+                return verifyCngSignedHash(
+                        1, hash, hash.length,
+                        sigBytes, sigBytes.length,
+                        0,
+                        messageDigestAlgorithm,
+                        publicKey.getHCryptProvider(),
+                        0);
+            } else {
+                return verifySignedHash(hash, hash.length,
+                        messageDigestAlgorithm, convertEndianArray(sigBytes),
+                        sigBytes.length, publicKey.getHCryptProvider(),
+                        publicKey.getHCryptKey());
+            }
         }
 
         /**
          * Generates a public-key BLOB from a key's components.
          */
@@ -408,29 +431,36 @@
         }
 
         // initialize for signing. See JCA doc
         @Override
         protected void engineInitSign(PrivateKey key) throws InvalidKeyException {
+            if (key == null) {
+                throw new InvalidKeyException("Key cannot be null");
+            }
             if ((key instanceof CPrivateKey) == false
                     || !key.getAlgorithm().equalsIgnoreCase("EC")) {
-                throw new InvalidKeyException("Key type not supported");
+                throw new InvalidKeyException("Key type not supported: "
+                        + key.getClass() + " " + key.getAlgorithm());
             }
             privateKey = (CPrivateKey) key;
 
             this.publicKey = null;
             resetDigest();
         }
 
         // initialize for signing. See JCA doc
         @Override
         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
+            if (key == null) {
+                throw new InvalidKeyException("Key cannot be null");
+            }
             // This signature accepts only ECPublicKey
             if ((key instanceof ECPublicKey) == false) {
-                throw new InvalidKeyException("Key type not supported");
+                throw new InvalidKeyException("Key type not supported: "
+                        + key.getClass());
             }
 
-
             if ((key instanceof CPublicKey) == false) {
                 try {
                     publicKey = importECPublicKey("EC",
                             CKey.generateECBlob(key),
                             KeyUtil.getKeySize(key));
@@ -489,13 +519,17 @@
             fallbackSignature = null;
         }
 
         @Override
         protected void engineInitVerify(PublicKey key) throws InvalidKeyException {
+            if (key == null) {
+                throw new InvalidKeyException("Key cannot be null");
+            }
             // This signature accepts only RSAPublicKey
             if ((key instanceof java.security.interfaces.RSAPublicKey) == false) {
-                throw new InvalidKeyException("Key type not supported");
+                throw new InvalidKeyException("Key type not supported: "
+                        + key.getClass());
             }
 
             this.privateKey = null;
 
             if (key instanceof CPublicKey) {

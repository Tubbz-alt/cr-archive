<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/linker/NameCodec.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../doubleconv/IeeeDouble.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../regexp/JdkRegExp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/linker/NameCodec.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.linker;
 27 
 28 /**
 29  * &lt;p&gt;
 30  * Implements the name mangling and demangling as specified by John Rose&#39;s
 31  * &lt;a href=&quot;https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm&quot;
 32  * target=&quot;_blank&quot;&gt;&quot;Symbolic Freedom in the VM&quot;&lt;/a&gt; article. Normally, you would
 33  * mangle the names in the call sites as you&#39;re generating bytecode, and then
 34  * demangle them when you receive them in bootstrap methods.
 35  * &lt;/p&gt;
 36  * &lt;p&gt;
 37  * This code is derived from sun.invoke.util.BytecodeName. Apart from subsetting that
 38  * class, we don&#39;t want to create dependency between non-exported package from java.base
 39  * to nashorn module.
 40  * &lt;/p&gt;
 41  *
<span class="line-modified"> 42  * &lt;h3&gt;Comment from BytecodeName class reproduced here:&lt;/h3&gt;</span>
 43  *
 44  * Includes universal mangling rules for the JVM.
 45  *
<span class="line-modified"> 46  * &lt;h3&gt;Avoiding Dangerous Characters &lt;/h3&gt;</span>
 47  *
 48  * &lt;p&gt;
 49  * The JVM defines a very small set of characters which are illegal
 50  * in name spellings.  We will slightly extend and regularize this set
 51  * into a group of &lt;cite&gt;dangerous characters&lt;/cite&gt;.
 52  * These characters will then be replaced, in mangled names, by escape sequences.
 53  * In addition, accidental escape sequences must be further escaped.
 54  * Finally, a special prefix will be applied if and only if
 55  * the mangling would otherwise fail to begin with the escape character.
 56  * This happens to cover the corner case of the null string,
 57  * and also clearly marks symbols which need demangling.
 58  * &lt;/p&gt;
 59  * &lt;p&gt;
 60  * Dangerous characters are the union of all characters forbidden
 61  * or otherwise restricted by the JVM specification,
 62  * plus their mates, if they are brackets
 63  * (&lt;code&gt;&lt;b&gt;[&lt;/b&gt;&lt;/code&gt; and &lt;code&gt;&lt;b&gt;]&lt;/b&gt;&lt;/code&gt;,
 64  * &lt;code&gt;&lt;b&gt;&amp;lt;&lt;/b&gt;&lt;/code&gt; and &lt;code&gt;&lt;b&gt;&amp;gt;&lt;/b&gt;&lt;/code&gt;),
 65  * plus, arbitrarily, the colon character &lt;code&gt;&lt;b&gt;:&lt;/b&gt;&lt;/code&gt;.
 66  * There is no distinction between type, method, and field names.
 67  * This makes it easier to convert between mangled names of different
 68  * types, since they do not need to be decoded (demangled).
 69  * &lt;/p&gt;
 70  * &lt;p&gt;
 71  * The escape character is backslash &lt;code&gt;&lt;b&gt;\&lt;/b&gt;&lt;/code&gt;
 72  * (also known as reverse solidus).
 73  * This character is, until now, unheard of in bytecode names,
 74  * but traditional in the proposed role.
 75  *
 76  * &lt;/p&gt;
<span class="line-modified"> 77  * &lt;h3&gt; Replacement Characters &lt;/h3&gt;</span>
 78  *
 79  *
 80  * &lt;p&gt;
 81  * Every escape sequence is two characters
 82  * (in fact, two UTF8 bytes) beginning with
 83  * the escape character and followed by a
 84  * &lt;cite&gt;replacement character&lt;/cite&gt;.
 85  * (Since the replacement character is never a backslash,
 86  * iterated manglings do not double in size.)
 87  * &lt;/p&gt;
 88  * &lt;p&gt;
 89  * Each dangerous character has some rough visual similarity
 90  * to its corresponding replacement character.
 91  * This makes mangled symbols easier to recognize by sight.
 92  * &lt;/p&gt;
 93  * &lt;p&gt;
 94  * The dangerous characters are
 95  * &lt;code&gt;&lt;b&gt;/&lt;/b&gt;&lt;/code&gt; (forward slash, used to delimit package components),
 96  * &lt;code&gt;&lt;b&gt;.&lt;/b&gt;&lt;/code&gt; (dot, also a package delimiter),
 97  * &lt;code&gt;&lt;b&gt;;&lt;/b&gt;&lt;/code&gt; (semicolon, used in signatures),
</pre>
<hr />
<pre>
142  *   &lt;li&gt;In each accidental escape, replace the backslash with an escape sequence
143  * (&lt;code&gt;&lt;b&gt;\-&lt;/b&gt;&lt;/code&gt;).&lt;/li&gt;
144  *   &lt;li&gt;Replace each dangerous character with an escape sequence
145  * (&lt;code&gt;&lt;b&gt;\|&lt;/b&gt;&lt;/code&gt; for &lt;code&gt;&lt;b&gt;/&lt;/b&gt;&lt;/code&gt;, etc.).&lt;/li&gt;
146  *   &lt;li&gt;If the first two steps introduced any change, &lt;em&gt;and&lt;/em&gt;
147  * if the string does not already begin with a backslash, prepend a null prefix (&lt;code&gt;&lt;b&gt;\=&lt;/b&gt;&lt;/code&gt;).&lt;/li&gt;
148  * &lt;/ol&gt;
149  *
150  * To demangle a mangled string that begins with an escape,
151  * remove any null prefix, and then replace (in parallel)
152  * each escape sequence by its original character.
153  * &lt;p&gt;Spelling strings which contain accidental
154  * escapes &lt;em&gt;must&lt;/em&gt; have them replaced, even if those
155  * strings do not contain dangerous characters.
156  * This restriction means that mangling a string always
157  * requires a scan of the string for escapes.
158  * But then, a scan would be required anyway,
159  * to check for dangerous characters.
160  *
161  * &lt;/p&gt;
<span class="line-modified">162  * &lt;h3&gt; Nice Properties &lt;/h3&gt;</span>
163  *
164  * &lt;p&gt;
165  * If a bytecode name does not contain any escape sequence,
166  * demangling is a no-op:  The string demangles to itself.
167  * Such a string is called &lt;cite&gt;self-mangling&lt;/cite&gt;.
168  * Almost all strings are self-mangling.
169  * In practice, to demangle almost any name &amp;ldquo;found in nature&amp;rdquo;,
170  * simply verify that it does not begin with a backslash.
171  * &lt;/p&gt;
172  * &lt;p&gt;
173  * Mangling is a one-to-one function, while demangling
174  * is a many-to-one function.
175  * A mangled string is defined as &lt;cite&gt;validly mangled&lt;/cite&gt; if
176  * it is in fact the unique mangling of its spelling string.
177  * Three examples of invalidly mangled strings are &lt;code&gt;&lt;b&gt;\=foo&lt;/b&gt;&lt;/code&gt;,
178  * &lt;code&gt;&lt;b&gt;\-bar&lt;/b&gt;&lt;/code&gt;, and &lt;code&gt;&lt;b&gt;baz\!&lt;/b&gt;&lt;/code&gt;, which demangle to &lt;code&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/code&gt;, &lt;code&gt;&lt;b&gt;\bar&lt;/b&gt;&lt;/code&gt;, and
179  * &lt;code&gt;&lt;b&gt;baz\!&lt;/b&gt;&lt;/code&gt;, but then remangle to &lt;code&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/code&gt;, &lt;code&gt;&lt;b&gt;\bar&lt;/b&gt;&lt;/code&gt;, and &lt;code&gt;&lt;b&gt;\=baz\-!&lt;/b&gt;&lt;/code&gt;.
180  * If a language back-end or runtime is using mangled names,
181  * it should never present an invalidly mangled bytecode
182  * name to the JVM.  If the runtime encounters one,
</pre>
<hr />
<pre>
205  * if it would participate in an accidental escape when followed
206  * by the first character of the second string.&lt;/li&gt;
207  * &lt;/ul&gt;
208  * &lt;p&gt;If languages that include non-Java symbol spellings use this
209  * mangling convention, they will enjoy the following advantages:
210  * &lt;/p&gt;
211  * &lt;ul&gt;
212  *   &lt;li&gt;They can interoperate via symbols they share in common.&lt;/li&gt;
213  *   &lt;li&gt;Low-level tools, such as backtrace printers, will have readable displays.&lt;/li&gt;
214  *   &lt;li&gt;Future JVM and language extensions can safely use the dangerous characters
215  * for structuring symbols, but will never interfere with valid spellings.&lt;/li&gt;
216  *   &lt;li&gt;Runtimes and compilers can use standard libraries for mangling and demangling.&lt;/li&gt;
217  *   &lt;li&gt;Occasional transliterations and name composition will be simple and regular,
218  * for classes, methods, and fields.&lt;/li&gt;
219  *   &lt;li&gt;Bytecode names will continue to be compact.
220  * When mangled, spellings will at most double in length, either in
221  * UTF8 or UTF16 format, and most will not change at all.&lt;/li&gt;
222  * &lt;/ul&gt;
223  *
224  *
<span class="line-modified">225  * &lt;h3&gt; Suggestions for Human Readable Presentations &lt;/h3&gt;</span>
226  *
227  *
228  * &lt;p&gt;
229  * For human readable displays of symbols,
230  * it will be better to present a string-like quoted
231  * representation of the spelling, because JVM users
232  * are generally familiar with such tokens.
233  * We suggest using single or double quotes before and after
234  * mangled symbols which are not valid Java identifiers,
235  * with quotes, backslashes, and non-printing characters
236  * escaped as if for literals in the Java language.
237  * &lt;/p&gt;
238  * &lt;p&gt;
239  * For example, an HTML-like spelling
240  * &lt;code&gt;&lt;b&gt;&amp;lt;pre&amp;gt;&lt;/b&gt;&lt;/code&gt; mangles to
241  * &lt;code&gt;&lt;b&gt;\^pre\_&lt;/b&gt;&lt;/code&gt; and could
242  * display more cleanly as
243  * &lt;code&gt;&lt;b&gt;&#39;&amp;lt;pre&amp;gt;&#39;&lt;/b&gt;&lt;/code&gt;,
244  * with the quotes included.
245  * Such string-like conventions are &lt;em&gt;not&lt;/em&gt; suitable
</pre>
</td>
<td>
<hr />
<pre>
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nashorn.internal.runtime.linker;
 27 
 28 /**
 29  * &lt;p&gt;
 30  * Implements the name mangling and demangling as specified by John Rose&#39;s
 31  * &lt;a href=&quot;https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm&quot;
 32  * target=&quot;_blank&quot;&gt;&quot;Symbolic Freedom in the VM&quot;&lt;/a&gt; article. Normally, you would
 33  * mangle the names in the call sites as you&#39;re generating bytecode, and then
 34  * demangle them when you receive them in bootstrap methods.
 35  * &lt;/p&gt;
 36  * &lt;p&gt;
 37  * This code is derived from sun.invoke.util.BytecodeName. Apart from subsetting that
 38  * class, we don&#39;t want to create dependency between non-exported package from java.base
 39  * to nashorn module.
 40  * &lt;/p&gt;
 41  *
<span class="line-modified"> 42  * &lt;h2&gt;Comment from BytecodeName class reproduced here:&lt;/h2&gt;</span>
 43  *
 44  * Includes universal mangling rules for the JVM.
 45  *
<span class="line-modified"> 46  * &lt;h2&gt;Avoiding Dangerous Characters &lt;/h2&gt;</span>
 47  *
 48  * &lt;p&gt;
 49  * The JVM defines a very small set of characters which are illegal
 50  * in name spellings.  We will slightly extend and regularize this set
 51  * into a group of &lt;cite&gt;dangerous characters&lt;/cite&gt;.
 52  * These characters will then be replaced, in mangled names, by escape sequences.
 53  * In addition, accidental escape sequences must be further escaped.
 54  * Finally, a special prefix will be applied if and only if
 55  * the mangling would otherwise fail to begin with the escape character.
 56  * This happens to cover the corner case of the null string,
 57  * and also clearly marks symbols which need demangling.
 58  * &lt;/p&gt;
 59  * &lt;p&gt;
 60  * Dangerous characters are the union of all characters forbidden
 61  * or otherwise restricted by the JVM specification,
 62  * plus their mates, if they are brackets
 63  * (&lt;code&gt;&lt;b&gt;[&lt;/b&gt;&lt;/code&gt; and &lt;code&gt;&lt;b&gt;]&lt;/b&gt;&lt;/code&gt;,
 64  * &lt;code&gt;&lt;b&gt;&amp;lt;&lt;/b&gt;&lt;/code&gt; and &lt;code&gt;&lt;b&gt;&amp;gt;&lt;/b&gt;&lt;/code&gt;),
 65  * plus, arbitrarily, the colon character &lt;code&gt;&lt;b&gt;:&lt;/b&gt;&lt;/code&gt;.
 66  * There is no distinction between type, method, and field names.
 67  * This makes it easier to convert between mangled names of different
 68  * types, since they do not need to be decoded (demangled).
 69  * &lt;/p&gt;
 70  * &lt;p&gt;
 71  * The escape character is backslash &lt;code&gt;&lt;b&gt;\&lt;/b&gt;&lt;/code&gt;
 72  * (also known as reverse solidus).
 73  * This character is, until now, unheard of in bytecode names,
 74  * but traditional in the proposed role.
 75  *
 76  * &lt;/p&gt;
<span class="line-modified"> 77  * &lt;h2&gt; Replacement Characters &lt;/h2&gt;</span>
 78  *
 79  *
 80  * &lt;p&gt;
 81  * Every escape sequence is two characters
 82  * (in fact, two UTF8 bytes) beginning with
 83  * the escape character and followed by a
 84  * &lt;cite&gt;replacement character&lt;/cite&gt;.
 85  * (Since the replacement character is never a backslash,
 86  * iterated manglings do not double in size.)
 87  * &lt;/p&gt;
 88  * &lt;p&gt;
 89  * Each dangerous character has some rough visual similarity
 90  * to its corresponding replacement character.
 91  * This makes mangled symbols easier to recognize by sight.
 92  * &lt;/p&gt;
 93  * &lt;p&gt;
 94  * The dangerous characters are
 95  * &lt;code&gt;&lt;b&gt;/&lt;/b&gt;&lt;/code&gt; (forward slash, used to delimit package components),
 96  * &lt;code&gt;&lt;b&gt;.&lt;/b&gt;&lt;/code&gt; (dot, also a package delimiter),
 97  * &lt;code&gt;&lt;b&gt;;&lt;/b&gt;&lt;/code&gt; (semicolon, used in signatures),
</pre>
<hr />
<pre>
142  *   &lt;li&gt;In each accidental escape, replace the backslash with an escape sequence
143  * (&lt;code&gt;&lt;b&gt;\-&lt;/b&gt;&lt;/code&gt;).&lt;/li&gt;
144  *   &lt;li&gt;Replace each dangerous character with an escape sequence
145  * (&lt;code&gt;&lt;b&gt;\|&lt;/b&gt;&lt;/code&gt; for &lt;code&gt;&lt;b&gt;/&lt;/b&gt;&lt;/code&gt;, etc.).&lt;/li&gt;
146  *   &lt;li&gt;If the first two steps introduced any change, &lt;em&gt;and&lt;/em&gt;
147  * if the string does not already begin with a backslash, prepend a null prefix (&lt;code&gt;&lt;b&gt;\=&lt;/b&gt;&lt;/code&gt;).&lt;/li&gt;
148  * &lt;/ol&gt;
149  *
150  * To demangle a mangled string that begins with an escape,
151  * remove any null prefix, and then replace (in parallel)
152  * each escape sequence by its original character.
153  * &lt;p&gt;Spelling strings which contain accidental
154  * escapes &lt;em&gt;must&lt;/em&gt; have them replaced, even if those
155  * strings do not contain dangerous characters.
156  * This restriction means that mangling a string always
157  * requires a scan of the string for escapes.
158  * But then, a scan would be required anyway,
159  * to check for dangerous characters.
160  *
161  * &lt;/p&gt;
<span class="line-modified">162  * &lt;h2&gt; Nice Properties &lt;/h2&gt;</span>
163  *
164  * &lt;p&gt;
165  * If a bytecode name does not contain any escape sequence,
166  * demangling is a no-op:  The string demangles to itself.
167  * Such a string is called &lt;cite&gt;self-mangling&lt;/cite&gt;.
168  * Almost all strings are self-mangling.
169  * In practice, to demangle almost any name &amp;ldquo;found in nature&amp;rdquo;,
170  * simply verify that it does not begin with a backslash.
171  * &lt;/p&gt;
172  * &lt;p&gt;
173  * Mangling is a one-to-one function, while demangling
174  * is a many-to-one function.
175  * A mangled string is defined as &lt;cite&gt;validly mangled&lt;/cite&gt; if
176  * it is in fact the unique mangling of its spelling string.
177  * Three examples of invalidly mangled strings are &lt;code&gt;&lt;b&gt;\=foo&lt;/b&gt;&lt;/code&gt;,
178  * &lt;code&gt;&lt;b&gt;\-bar&lt;/b&gt;&lt;/code&gt;, and &lt;code&gt;&lt;b&gt;baz\!&lt;/b&gt;&lt;/code&gt;, which demangle to &lt;code&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/code&gt;, &lt;code&gt;&lt;b&gt;\bar&lt;/b&gt;&lt;/code&gt;, and
179  * &lt;code&gt;&lt;b&gt;baz\!&lt;/b&gt;&lt;/code&gt;, but then remangle to &lt;code&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/code&gt;, &lt;code&gt;&lt;b&gt;\bar&lt;/b&gt;&lt;/code&gt;, and &lt;code&gt;&lt;b&gt;\=baz\-!&lt;/b&gt;&lt;/code&gt;.
180  * If a language back-end or runtime is using mangled names,
181  * it should never present an invalidly mangled bytecode
182  * name to the JVM.  If the runtime encounters one,
</pre>
<hr />
<pre>
205  * if it would participate in an accidental escape when followed
206  * by the first character of the second string.&lt;/li&gt;
207  * &lt;/ul&gt;
208  * &lt;p&gt;If languages that include non-Java symbol spellings use this
209  * mangling convention, they will enjoy the following advantages:
210  * &lt;/p&gt;
211  * &lt;ul&gt;
212  *   &lt;li&gt;They can interoperate via symbols they share in common.&lt;/li&gt;
213  *   &lt;li&gt;Low-level tools, such as backtrace printers, will have readable displays.&lt;/li&gt;
214  *   &lt;li&gt;Future JVM and language extensions can safely use the dangerous characters
215  * for structuring symbols, but will never interfere with valid spellings.&lt;/li&gt;
216  *   &lt;li&gt;Runtimes and compilers can use standard libraries for mangling and demangling.&lt;/li&gt;
217  *   &lt;li&gt;Occasional transliterations and name composition will be simple and regular,
218  * for classes, methods, and fields.&lt;/li&gt;
219  *   &lt;li&gt;Bytecode names will continue to be compact.
220  * When mangled, spellings will at most double in length, either in
221  * UTF8 or UTF16 format, and most will not change at all.&lt;/li&gt;
222  * &lt;/ul&gt;
223  *
224  *
<span class="line-modified">225  * &lt;h2&gt; Suggestions for Human Readable Presentations &lt;/h2&gt;</span>
226  *
227  *
228  * &lt;p&gt;
229  * For human readable displays of symbols,
230  * it will be better to present a string-like quoted
231  * representation of the spelling, because JVM users
232  * are generally familiar with such tokens.
233  * We suggest using single or double quotes before and after
234  * mangled symbols which are not valid Java identifiers,
235  * with quotes, backslashes, and non-printing characters
236  * escaped as if for literals in the Java language.
237  * &lt;/p&gt;
238  * &lt;p&gt;
239  * For example, an HTML-like spelling
240  * &lt;code&gt;&lt;b&gt;&amp;lt;pre&amp;gt;&lt;/b&gt;&lt;/code&gt; mangles to
241  * &lt;code&gt;&lt;b&gt;\^pre\_&lt;/b&gt;&lt;/code&gt; and could
242  * display more cleanly as
243  * &lt;code&gt;&lt;b&gt;&#39;&amp;lt;pre&amp;gt;&#39;&lt;/b&gt;&lt;/code&gt;,
244  * with the quotes included.
245  * Such string-like conventions are &lt;em&gt;not&lt;/em&gt; suitable
</pre>
</td>
</tr>
</table>
<center><a href="../doubleconv/IeeeDouble.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../regexp/JdkRegExp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
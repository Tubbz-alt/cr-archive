<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../StoredScript.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BignumDtoa.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59 
 60 import java.util.Arrays;
 61 
 62 class Bignum {
 63 
 64     // 3584 = 128 * 28. We can represent 2^3584 &gt; 10^1000 accurately.
 65     // This bignum can encode much bigger numbers, since it contains an
 66     // exponent.
 67     static final int kMaxSignificantBits = 3584;
 68 
 69     static final int kChunkSize = 32;       // size of int
 70     static final int kDoubleChunkSize = 64; // size of long
 71     // With bigit size of 28 we loose some bits, but a double still fits easily
 72     // into two ints, and more importantly we can use the Comba multiplication.
 73     static final int kBigitSize = 28;
 74     static final int kBigitMask = (1 &lt;&lt; kBigitSize) - 1;
 75     // Every instance allocates kbigitLength ints on the stack. Bignums cannot
 76     // grow. There are no checks if the stack-allocated space is sufficient.
 77     static final int kBigitCapacity = kMaxSignificantBits / kBigitSize;
 78 
<span class="line-removed"> 79     private final int[] bigits_ = new int[kBigitCapacity];</span>
<span class="line-removed"> 80     // A vector backed by bigits_buffer_. This way accesses to the array are</span>
<span class="line-removed"> 81     // checked for out-of-bounds errors.</span>
<span class="line-removed"> 82     // Vector&lt;int&gt; bigits_;</span>
 83     private int used_digits_;
 84     // The Bignum&#39;s value equals value(bigits_) * 2^(exponent_ * kBigitSize).
 85     private int exponent_;

 86 
 87     Bignum() {}
 88 
 89     void times10() { multiplyByUInt32(10); }
 90 
 91     static boolean equal(final Bignum a, final Bignum b) {
 92         return compare(a, b) == 0;
 93     }
 94     static boolean lessEqual(final Bignum a, final Bignum b) {
 95         return compare(a, b) &lt;= 0;
 96     }
 97     static boolean less(final Bignum a, final Bignum b) {
 98         return compare(a, b) &lt; 0;
 99     }
100 
101     // Returns a + b == c
102     static boolean plusEqual(final Bignum a, final Bignum b, final Bignum c) {
103         return plusCompare(a, b, c) == 0;
104     }
105     // Returns a + b &lt;= c
</pre>
<hr />
<pre>
107         return plusCompare(a, b, c) &lt;= 0;
108     }
109     // Returns a + b &lt; c
110     static boolean plusLess(final Bignum a, final Bignum b, final Bignum c) {
111         return plusCompare(a, b, c) &lt; 0;
112     }
113 
114     private void ensureCapacity(final int size) {
115         if (size &gt; kBigitCapacity) {
116             throw new RuntimeException();
117         }
118     }
119 
120     // BigitLength includes the &quot;hidden&quot; digits encoded in the exponent.
121     int bigitLength() { return used_digits_ + exponent_; }
122 
123     // Guaranteed to lie in one Bigit.
124     void assignUInt16(final char value) {
125         assert (kBigitSize &gt;= 16);
126         zero();
<span class="line-modified">127         if (value == 0) return;</span>


128 
129         ensureCapacity(1);
130         bigits_[0] = value;
131         used_digits_ = 1;
132     }
133 
134 
135     void assignUInt64(long value) {
136         final  int kUInt64Size = 64;
137 
138         zero();
<span class="line-modified">139         if (value == 0) return;</span>


140 
141         final int needed_bigits = kUInt64Size / kBigitSize + 1;
142         ensureCapacity(needed_bigits);
143         for (int i = 0; i &lt; needed_bigits; ++i) {
144             bigits_[i] = (int) (value &amp; kBigitMask);
145             value = value &gt;&gt;&gt; kBigitSize;
146         }
147         used_digits_ = needed_bigits;
148         clamp();
149     }
150 
151 
152     void assignBignum(final Bignum other) {
153         exponent_ = other.exponent_;
154         for (int i = 0; i &lt; other.used_digits_; ++i) {
155             bigits_[i] = other.bigits_[i];
156         }
157         // Clear the excess digits (if there were any).
158         for (int i = other.used_digits_; i &lt; used_digits_; ++i) {
159             bigits_[i] = 0;
</pre>
<hr />
<pre>
504         int bit_size = 0;
505         int tmp_base = base;
506         while (tmp_base != 0) {
507             tmp_base &gt;&gt;&gt;= 1;
508             bit_size++;
509         }
510         final int final_size = bit_size * power_exponent;
511         // 1 extra bigit for the shifting, and one for rounded final_size.
512         ensureCapacity(final_size / kBigitSize + 2);
513 
514         // Left to Right exponentiation.
515         int mask = 1;
516         while (power_exponent &gt;= mask) mask &lt;&lt;= 1;
517 
518         // The mask is now pointing to the bit above the most significant 1-bit of
519         // power_exponent.
520         // Get rid of first 1-bit;
521         mask &gt;&gt;&gt;= 2;
522         long this_value = base;
523 
<span class="line-modified">524         boolean delayed_multipliciation = false;</span>
525         final long max_32bits = 0xFFFFFFFFL;
526         while (mask != 0 &amp;&amp; this_value &lt;= max_32bits) {
527             this_value = this_value * this_value;
528             // Verify that there is enough space in this_value to perform the
529             // multiplication.  The first bit_size bits must be 0.
530             if ((power_exponent &amp; mask) != 0) {

531                 final long base_bits_mask =
532                         ~((1L &lt;&lt; (64 - bit_size)) - 1);
533                 final boolean high_bits_zero = (this_value &amp; base_bits_mask) == 0;
534                 if (high_bits_zero) {
535                     this_value *= base;
536                 } else {
<span class="line-modified">537                     delayed_multipliciation = true;</span>
538                 }
539             }
540             mask &gt;&gt;&gt;= 1;
541         }
542         assignUInt64(this_value);
<span class="line-modified">543         if (delayed_multipliciation) {</span>
544             multiplyByUInt32(base);
545         }
546 
547         // Now do the same thing as a bignum.
548         while (mask != 0) {
549             square();
550             if ((power_exponent &amp; mask) != 0) {
551                 multiplyByUInt32(base);
552             }
553             mask &gt;&gt;&gt;= 1;
554         }
555 
556         // And finally add the saved shifts.
557         shiftLeft(shifts * power_exponent);
558     }
559 
560 
561     // Precondition: this/other &lt; 16bit.
562     char divideModuloIntBignum(final Bignum other) {
563         assert (isClamped());
</pre>
<hr />
<pre>
664                 buffer.setCharAt(string_index--, &#39;0&#39;);
665             }
666         }
667         for (int i = 0; i &lt; used_digits_ - 1; ++i) {
668             int current_bigit = bigits_[i];
669             for (int j = 0; j &lt; kHexCharsPerBigit; ++j) {
670                 buffer.setCharAt(string_index--, hexCharOfValue(current_bigit &amp; 0xF));
671                 current_bigit &gt;&gt;&gt;= 4;
672             }
673         }
674         // And finally the last bigit.
675         int most_significant_bigit = bigits_[used_digits_ - 1];
676         while (most_significant_bigit != 0) {
677             buffer.setCharAt(string_index--, hexCharOfValue(most_significant_bigit &amp; 0xF));
678             most_significant_bigit &gt;&gt;&gt;= 4;
679         }
680         return buffer.toString();
681     }
682 
683 
<span class="line-modified">684     int bigitAt(final int index) {</span>
685         if (index &gt;= bigitLength()) return 0;
686         if (index &lt; exponent_) return 0;
687         return bigits_[index - exponent_];
688     }
689 
690 
691     static int compare(final Bignum a, final Bignum b) {
692         assert (a.isClamped());
693         assert (b.isClamped());
694         final int bigit_length_a = a.bigitLength();
695         final int bigit_length_b = b.bigitLength();
696         if (bigit_length_a &lt; bigit_length_b) return -1;
697         if (bigit_length_a &gt; bigit_length_b) return +1;
698         for (int i = bigit_length_a - 1; i &gt;= Math.min(a.exponent_, b.exponent_); --i) {
<span class="line-modified">699             final int bigit_a = a.bigitAt(i);</span>
<span class="line-modified">700             final int bigit_b = b.bigitAt(i);</span>
701             if (bigit_a &lt; bigit_b) return -1;
702             if (bigit_a &gt; bigit_b) return +1;
703             // Otherwise they are equal up to this digit. Try the next digit.
704         }
705         return 0;
706     }
707 
708 
709     static int plusCompare(final Bignum a, final Bignum b, final Bignum c) {
710         assert (a.isClamped());
711         assert (b.isClamped());
712         assert (c.isClamped());
713         if (a.bigitLength() &lt; b.bigitLength()) {
714             return plusCompare(b, a, c);
715         }
716         if (a.bigitLength() + 1 &lt; c.bigitLength()) return -1;
717         if (a.bigitLength() &gt; c.bigitLength()) return +1;
718         // The exponent encodes 0-bigits. So if there are more 0-digits in &#39;a&#39; than
719         // &#39;b&#39; has digits, then the bigit-length of &#39;a&#39;+&#39;b&#39; must be equal to the one
720         // of &#39;a&#39;.
721         if (a.exponent_ &gt;= b.bigitLength() &amp;&amp; a.bigitLength() &lt; c.bigitLength()) {
722             return -1;
723         }
724 
725         int borrow = 0;
726         // Starting at min_exponent all digits are == 0. So no need to compare them.
727         final int min_exponent = Math.min(Math.min(a.exponent_, b.exponent_), c.exponent_);
728         for (int i = c.bigitLength() - 1; i &gt;= min_exponent; --i) {
<span class="line-modified">729             final int int_a = a.bigitAt(i);</span>
<span class="line-modified">730             final int int_b = b.bigitAt(i);</span>
<span class="line-modified">731             final int int_c = c.bigitAt(i);</span>
732             final int sum = int_a + int_b;
733             if (sum &gt; int_c + borrow) {
734                 return +1;
735             } else {
736                 borrow = int_c + borrow - sum;
737                 if (borrow &gt; 1) return -1;
738                 borrow &lt;&lt;= kBigitSize;
739             }
740         }
741         if (borrow == 0) return 0;
742         return -1;
743     }
744 
745 
746     void clamp() {
747         while (used_digits_ &gt; 0 &amp;&amp; bigits_[used_digits_ - 1] == 0) {
748             used_digits_--;
749         }
750         if (used_digits_ == 0) {
751             // Zero.
</pre>
</td>
<td>
<hr />
<pre>
 59 
 60 import java.util.Arrays;
 61 
 62 class Bignum {
 63 
 64     // 3584 = 128 * 28. We can represent 2^3584 &gt; 10^1000 accurately.
 65     // This bignum can encode much bigger numbers, since it contains an
 66     // exponent.
 67     static final int kMaxSignificantBits = 3584;
 68 
 69     static final int kChunkSize = 32;       // size of int
 70     static final int kDoubleChunkSize = 64; // size of long
 71     // With bigit size of 28 we loose some bits, but a double still fits easily
 72     // into two ints, and more importantly we can use the Comba multiplication.
 73     static final int kBigitSize = 28;
 74     static final int kBigitMask = (1 &lt;&lt; kBigitSize) - 1;
 75     // Every instance allocates kbigitLength ints on the stack. Bignums cannot
 76     // grow. There are no checks if the stack-allocated space is sufficient.
 77     static final int kBigitCapacity = kMaxSignificantBits / kBigitSize;
 78 




 79     private int used_digits_;
 80     // The Bignum&#39;s value equals value(bigits_) * 2^(exponent_ * kBigitSize).
 81     private int exponent_;
<span class="line-added"> 82     private final int[] bigits_ = new int[kBigitCapacity];</span>
 83 
 84     Bignum() {}
 85 
 86     void times10() { multiplyByUInt32(10); }
 87 
 88     static boolean equal(final Bignum a, final Bignum b) {
 89         return compare(a, b) == 0;
 90     }
 91     static boolean lessEqual(final Bignum a, final Bignum b) {
 92         return compare(a, b) &lt;= 0;
 93     }
 94     static boolean less(final Bignum a, final Bignum b) {
 95         return compare(a, b) &lt; 0;
 96     }
 97 
 98     // Returns a + b == c
 99     static boolean plusEqual(final Bignum a, final Bignum b, final Bignum c) {
100         return plusCompare(a, b, c) == 0;
101     }
102     // Returns a + b &lt;= c
</pre>
<hr />
<pre>
104         return plusCompare(a, b, c) &lt;= 0;
105     }
106     // Returns a + b &lt; c
107     static boolean plusLess(final Bignum a, final Bignum b, final Bignum c) {
108         return plusCompare(a, b, c) &lt; 0;
109     }
110 
111     private void ensureCapacity(final int size) {
112         if (size &gt; kBigitCapacity) {
113             throw new RuntimeException();
114         }
115     }
116 
117     // BigitLength includes the &quot;hidden&quot; digits encoded in the exponent.
118     int bigitLength() { return used_digits_ + exponent_; }
119 
120     // Guaranteed to lie in one Bigit.
121     void assignUInt16(final char value) {
122         assert (kBigitSize &gt;= 16);
123         zero();
<span class="line-modified">124         if (value == 0) {</span>
<span class="line-added">125             return;</span>
<span class="line-added">126         }</span>
127 
128         ensureCapacity(1);
129         bigits_[0] = value;
130         used_digits_ = 1;
131     }
132 
133 
134     void assignUInt64(long value) {
135         final  int kUInt64Size = 64;
136 
137         zero();
<span class="line-modified">138         if (value == 0) {</span>
<span class="line-added">139             return;</span>
<span class="line-added">140         }</span>
141 
142         final int needed_bigits = kUInt64Size / kBigitSize + 1;
143         ensureCapacity(needed_bigits);
144         for (int i = 0; i &lt; needed_bigits; ++i) {
145             bigits_[i] = (int) (value &amp; kBigitMask);
146             value = value &gt;&gt;&gt; kBigitSize;
147         }
148         used_digits_ = needed_bigits;
149         clamp();
150     }
151 
152 
153     void assignBignum(final Bignum other) {
154         exponent_ = other.exponent_;
155         for (int i = 0; i &lt; other.used_digits_; ++i) {
156             bigits_[i] = other.bigits_[i];
157         }
158         // Clear the excess digits (if there were any).
159         for (int i = other.used_digits_; i &lt; used_digits_; ++i) {
160             bigits_[i] = 0;
</pre>
<hr />
<pre>
505         int bit_size = 0;
506         int tmp_base = base;
507         while (tmp_base != 0) {
508             tmp_base &gt;&gt;&gt;= 1;
509             bit_size++;
510         }
511         final int final_size = bit_size * power_exponent;
512         // 1 extra bigit for the shifting, and one for rounded final_size.
513         ensureCapacity(final_size / kBigitSize + 2);
514 
515         // Left to Right exponentiation.
516         int mask = 1;
517         while (power_exponent &gt;= mask) mask &lt;&lt;= 1;
518 
519         // The mask is now pointing to the bit above the most significant 1-bit of
520         // power_exponent.
521         // Get rid of first 1-bit;
522         mask &gt;&gt;&gt;= 2;
523         long this_value = base;
524 
<span class="line-modified">525         boolean delayed_multiplication = false;</span>
526         final long max_32bits = 0xFFFFFFFFL;
527         while (mask != 0 &amp;&amp; this_value &lt;= max_32bits) {
528             this_value = this_value * this_value;
529             // Verify that there is enough space in this_value to perform the
530             // multiplication.  The first bit_size bits must be 0.
531             if ((power_exponent &amp; mask) != 0) {
<span class="line-added">532                 assert bit_size &gt; 0;</span>
533                 final long base_bits_mask =
534                         ~((1L &lt;&lt; (64 - bit_size)) - 1);
535                 final boolean high_bits_zero = (this_value &amp; base_bits_mask) == 0;
536                 if (high_bits_zero) {
537                     this_value *= base;
538                 } else {
<span class="line-modified">539                     delayed_multiplication = true;</span>
540                 }
541             }
542             mask &gt;&gt;&gt;= 1;
543         }
544         assignUInt64(this_value);
<span class="line-modified">545         if (delayed_multiplication) {</span>
546             multiplyByUInt32(base);
547         }
548 
549         // Now do the same thing as a bignum.
550         while (mask != 0) {
551             square();
552             if ((power_exponent &amp; mask) != 0) {
553                 multiplyByUInt32(base);
554             }
555             mask &gt;&gt;&gt;= 1;
556         }
557 
558         // And finally add the saved shifts.
559         shiftLeft(shifts * power_exponent);
560     }
561 
562 
563     // Precondition: this/other &lt; 16bit.
564     char divideModuloIntBignum(final Bignum other) {
565         assert (isClamped());
</pre>
<hr />
<pre>
666                 buffer.setCharAt(string_index--, &#39;0&#39;);
667             }
668         }
669         for (int i = 0; i &lt; used_digits_ - 1; ++i) {
670             int current_bigit = bigits_[i];
671             for (int j = 0; j &lt; kHexCharsPerBigit; ++j) {
672                 buffer.setCharAt(string_index--, hexCharOfValue(current_bigit &amp; 0xF));
673                 current_bigit &gt;&gt;&gt;= 4;
674             }
675         }
676         // And finally the last bigit.
677         int most_significant_bigit = bigits_[used_digits_ - 1];
678         while (most_significant_bigit != 0) {
679             buffer.setCharAt(string_index--, hexCharOfValue(most_significant_bigit &amp; 0xF));
680             most_significant_bigit &gt;&gt;&gt;= 4;
681         }
682         return buffer.toString();
683     }
684 
685 
<span class="line-modified">686     int bigitOrZero(final int index) {</span>
687         if (index &gt;= bigitLength()) return 0;
688         if (index &lt; exponent_) return 0;
689         return bigits_[index - exponent_];
690     }
691 
692 
693     static int compare(final Bignum a, final Bignum b) {
694         assert (a.isClamped());
695         assert (b.isClamped());
696         final int bigit_length_a = a.bigitLength();
697         final int bigit_length_b = b.bigitLength();
698         if (bigit_length_a &lt; bigit_length_b) return -1;
699         if (bigit_length_a &gt; bigit_length_b) return +1;
700         for (int i = bigit_length_a - 1; i &gt;= Math.min(a.exponent_, b.exponent_); --i) {
<span class="line-modified">701             final int bigit_a = a.bigitOrZero(i);</span>
<span class="line-modified">702             final int bigit_b = b.bigitOrZero(i);</span>
703             if (bigit_a &lt; bigit_b) return -1;
704             if (bigit_a &gt; bigit_b) return +1;
705             // Otherwise they are equal up to this digit. Try the next digit.
706         }
707         return 0;
708     }
709 
710 
711     static int plusCompare(final Bignum a, final Bignum b, final Bignum c) {
712         assert (a.isClamped());
713         assert (b.isClamped());
714         assert (c.isClamped());
715         if (a.bigitLength() &lt; b.bigitLength()) {
716             return plusCompare(b, a, c);
717         }
718         if (a.bigitLength() + 1 &lt; c.bigitLength()) return -1;
719         if (a.bigitLength() &gt; c.bigitLength()) return +1;
720         // The exponent encodes 0-bigits. So if there are more 0-digits in &#39;a&#39; than
721         // &#39;b&#39; has digits, then the bigit-length of &#39;a&#39;+&#39;b&#39; must be equal to the one
722         // of &#39;a&#39;.
723         if (a.exponent_ &gt;= b.bigitLength() &amp;&amp; a.bigitLength() &lt; c.bigitLength()) {
724             return -1;
725         }
726 
727         int borrow = 0;
728         // Starting at min_exponent all digits are == 0. So no need to compare them.
729         final int min_exponent = Math.min(Math.min(a.exponent_, b.exponent_), c.exponent_);
730         for (int i = c.bigitLength() - 1; i &gt;= min_exponent; --i) {
<span class="line-modified">731             final int int_a = a.bigitOrZero(i);</span>
<span class="line-modified">732             final int int_b = b.bigitOrZero(i);</span>
<span class="line-modified">733             final int int_c = c.bigitOrZero(i);</span>
734             final int sum = int_a + int_b;
735             if (sum &gt; int_c + borrow) {
736                 return +1;
737             } else {
738                 borrow = int_c + borrow - sum;
739                 if (borrow &gt; 1) return -1;
740                 borrow &lt;&lt;= kBigitSize;
741             }
742         }
743         if (borrow == 0) return 0;
744         return -1;
745     }
746 
747 
748     void clamp() {
749         while (used_digits_ &gt; 0 &amp;&amp; bigits_[used_digits_ - 1] == 0) {
750             used_digits_--;
751         }
752         if (used_digits_ == 0) {
753             // Zero.
</pre>
</td>
</tr>
</table>
<center><a href="../StoredScript.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BignumDtoa.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
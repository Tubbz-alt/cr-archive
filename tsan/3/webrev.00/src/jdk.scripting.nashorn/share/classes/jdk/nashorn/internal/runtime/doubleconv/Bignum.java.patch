diff a/src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java b/src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java
--- a/src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java
+++ b/src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java
@@ -74,17 +74,14 @@
     static final int kBigitMask = (1 << kBigitSize) - 1;
     // Every instance allocates kbigitLength ints on the stack. Bignums cannot
     // grow. There are no checks if the stack-allocated space is sufficient.
     static final int kBigitCapacity = kMaxSignificantBits / kBigitSize;
 
-    private final int[] bigits_ = new int[kBigitCapacity];
-    // A vector backed by bigits_buffer_. This way accesses to the array are
-    // checked for out-of-bounds errors.
-    // Vector<int> bigits_;
     private int used_digits_;
     // The Bignum's value equals value(bigits_) * 2^(exponent_ * kBigitSize).
     private int exponent_;
+    private final int[] bigits_ = new int[kBigitCapacity];
 
     Bignum() {}
 
     void times10() { multiplyByUInt32(10); }
 
@@ -122,11 +119,13 @@
 
     // Guaranteed to lie in one Bigit.
     void assignUInt16(final char value) {
         assert (kBigitSize >= 16);
         zero();
-        if (value == 0) return;
+        if (value == 0) {
+            return;
+        }
 
         ensureCapacity(1);
         bigits_[0] = value;
         used_digits_ = 1;
     }
@@ -134,11 +133,13 @@
 
     void assignUInt64(long value) {
         final  int kUInt64Size = 64;
 
         zero();
-        if (value == 0) return;
+        if (value == 0) {
+            return;
+        }
 
         final int needed_bigits = kUInt64Size / kBigitSize + 1;
         ensureCapacity(needed_bigits);
         for (int i = 0; i < needed_bigits; ++i) {
             bigits_[i] = (int) (value & kBigitMask);
@@ -519,30 +520,31 @@
         // power_exponent.
         // Get rid of first 1-bit;
         mask >>>= 2;
         long this_value = base;
 
-        boolean delayed_multipliciation = false;
+        boolean delayed_multiplication = false;
         final long max_32bits = 0xFFFFFFFFL;
         while (mask != 0 && this_value <= max_32bits) {
             this_value = this_value * this_value;
             // Verify that there is enough space in this_value to perform the
             // multiplication.  The first bit_size bits must be 0.
             if ((power_exponent & mask) != 0) {
+                assert bit_size > 0;
                 final long base_bits_mask =
                         ~((1L << (64 - bit_size)) - 1);
                 final boolean high_bits_zero = (this_value & base_bits_mask) == 0;
                 if (high_bits_zero) {
                     this_value *= base;
                 } else {
-                    delayed_multipliciation = true;
+                    delayed_multiplication = true;
                 }
             }
             mask >>>= 1;
         }
         assignUInt64(this_value);
-        if (delayed_multipliciation) {
+        if (delayed_multiplication) {
             multiplyByUInt32(base);
         }
 
         // Now do the same thing as a bignum.
         while (mask != 0) {
@@ -679,11 +681,11 @@
         }
         return buffer.toString();
     }
 
 
-    int bigitAt(final int index) {
+    int bigitOrZero(final int index) {
         if (index >= bigitLength()) return 0;
         if (index < exponent_) return 0;
         return bigits_[index - exponent_];
     }
 
@@ -694,12 +696,12 @@
         final int bigit_length_a = a.bigitLength();
         final int bigit_length_b = b.bigitLength();
         if (bigit_length_a < bigit_length_b) return -1;
         if (bigit_length_a > bigit_length_b) return +1;
         for (int i = bigit_length_a - 1; i >= Math.min(a.exponent_, b.exponent_); --i) {
-            final int bigit_a = a.bigitAt(i);
-            final int bigit_b = b.bigitAt(i);
+            final int bigit_a = a.bigitOrZero(i);
+            final int bigit_b = b.bigitOrZero(i);
             if (bigit_a < bigit_b) return -1;
             if (bigit_a > bigit_b) return +1;
             // Otherwise they are equal up to this digit. Try the next digit.
         }
         return 0;
@@ -724,13 +726,13 @@
 
         int borrow = 0;
         // Starting at min_exponent all digits are == 0. So no need to compare them.
         final int min_exponent = Math.min(Math.min(a.exponent_, b.exponent_), c.exponent_);
         for (int i = c.bigitLength() - 1; i >= min_exponent; --i) {
-            final int int_a = a.bigitAt(i);
-            final int int_b = b.bigitAt(i);
-            final int int_c = c.bigitAt(i);
+            final int int_a = a.bigitOrZero(i);
+            final int int_b = b.bigitOrZero(i);
+            final int int_c = c.bigitOrZero(i);
             final int sum = int_a + int_b;
             if (sum > int_c + borrow) {
                 return +1;
             } else {
                 borrow = int_c + borrow - sum;

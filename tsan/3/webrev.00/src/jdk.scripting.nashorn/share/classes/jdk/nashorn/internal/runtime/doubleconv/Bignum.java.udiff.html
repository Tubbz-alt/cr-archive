<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../StoredScript.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BignumDtoa.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.scripting.nashorn/share/classes/jdk/nashorn/internal/runtime/doubleconv/Bignum.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -74,17 +74,14 @@</span>
      static final int kBigitMask = (1 &lt;&lt; kBigitSize) - 1;
      // Every instance allocates kbigitLength ints on the stack. Bignums cannot
      // grow. There are no checks if the stack-allocated space is sufficient.
      static final int kBigitCapacity = kMaxSignificantBits / kBigitSize;
  
<span class="udiff-line-removed">-     private final int[] bigits_ = new int[kBigitCapacity];</span>
<span class="udiff-line-removed">-     // A vector backed by bigits_buffer_. This way accesses to the array are</span>
<span class="udiff-line-removed">-     // checked for out-of-bounds errors.</span>
<span class="udiff-line-removed">-     // Vector&lt;int&gt; bigits_;</span>
      private int used_digits_;
      // The Bignum&#39;s value equals value(bigits_) * 2^(exponent_ * kBigitSize).
      private int exponent_;
<span class="udiff-line-added">+     private final int[] bigits_ = new int[kBigitCapacity];</span>
  
      Bignum() {}
  
      void times10() { multiplyByUInt32(10); }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -122,11 +119,13 @@</span>
  
      // Guaranteed to lie in one Bigit.
      void assignUInt16(final char value) {
          assert (kBigitSize &gt;= 16);
          zero();
<span class="udiff-line-modified-removed">-         if (value == 0) return;</span>
<span class="udiff-line-modified-added">+         if (value == 0) {</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
  
          ensureCapacity(1);
          bigits_[0] = value;
          used_digits_ = 1;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134,11 +133,13 @@</span>
  
      void assignUInt64(long value) {
          final  int kUInt64Size = 64;
  
          zero();
<span class="udiff-line-modified-removed">-         if (value == 0) return;</span>
<span class="udiff-line-modified-added">+         if (value == 0) {</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
  
          final int needed_bigits = kUInt64Size / kBigitSize + 1;
          ensureCapacity(needed_bigits);
          for (int i = 0; i &lt; needed_bigits; ++i) {
              bigits_[i] = (int) (value &amp; kBigitMask);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -519,30 +520,31 @@</span>
          // power_exponent.
          // Get rid of first 1-bit;
          mask &gt;&gt;&gt;= 2;
          long this_value = base;
  
<span class="udiff-line-modified-removed">-         boolean delayed_multipliciation = false;</span>
<span class="udiff-line-modified-added">+         boolean delayed_multiplication = false;</span>
          final long max_32bits = 0xFFFFFFFFL;
          while (mask != 0 &amp;&amp; this_value &lt;= max_32bits) {
              this_value = this_value * this_value;
              // Verify that there is enough space in this_value to perform the
              // multiplication.  The first bit_size bits must be 0.
              if ((power_exponent &amp; mask) != 0) {
<span class="udiff-line-added">+                 assert bit_size &gt; 0;</span>
                  final long base_bits_mask =
                          ~((1L &lt;&lt; (64 - bit_size)) - 1);
                  final boolean high_bits_zero = (this_value &amp; base_bits_mask) == 0;
                  if (high_bits_zero) {
                      this_value *= base;
                  } else {
<span class="udiff-line-modified-removed">-                     delayed_multipliciation = true;</span>
<span class="udiff-line-modified-added">+                     delayed_multiplication = true;</span>
                  }
              }
              mask &gt;&gt;&gt;= 1;
          }
          assignUInt64(this_value);
<span class="udiff-line-modified-removed">-         if (delayed_multipliciation) {</span>
<span class="udiff-line-modified-added">+         if (delayed_multiplication) {</span>
              multiplyByUInt32(base);
          }
  
          // Now do the same thing as a bignum.
          while (mask != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -679,11 +681,11 @@</span>
          }
          return buffer.toString();
      }
  
  
<span class="udiff-line-modified-removed">-     int bigitAt(final int index) {</span>
<span class="udiff-line-modified-added">+     int bigitOrZero(final int index) {</span>
          if (index &gt;= bigitLength()) return 0;
          if (index &lt; exponent_) return 0;
          return bigits_[index - exponent_];
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -694,12 +696,12 @@</span>
          final int bigit_length_a = a.bigitLength();
          final int bigit_length_b = b.bigitLength();
          if (bigit_length_a &lt; bigit_length_b) return -1;
          if (bigit_length_a &gt; bigit_length_b) return +1;
          for (int i = bigit_length_a - 1; i &gt;= Math.min(a.exponent_, b.exponent_); --i) {
<span class="udiff-line-modified-removed">-             final int bigit_a = a.bigitAt(i);</span>
<span class="udiff-line-modified-removed">-             final int bigit_b = b.bigitAt(i);</span>
<span class="udiff-line-modified-added">+             final int bigit_a = a.bigitOrZero(i);</span>
<span class="udiff-line-modified-added">+             final int bigit_b = b.bigitOrZero(i);</span>
              if (bigit_a &lt; bigit_b) return -1;
              if (bigit_a &gt; bigit_b) return +1;
              // Otherwise they are equal up to this digit. Try the next digit.
          }
          return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -724,13 +726,13 @@</span>
  
          int borrow = 0;
          // Starting at min_exponent all digits are == 0. So no need to compare them.
          final int min_exponent = Math.min(Math.min(a.exponent_, b.exponent_), c.exponent_);
          for (int i = c.bigitLength() - 1; i &gt;= min_exponent; --i) {
<span class="udiff-line-modified-removed">-             final int int_a = a.bigitAt(i);</span>
<span class="udiff-line-modified-removed">-             final int int_b = b.bigitAt(i);</span>
<span class="udiff-line-modified-removed">-             final int int_c = c.bigitAt(i);</span>
<span class="udiff-line-modified-added">+             final int int_a = a.bigitOrZero(i);</span>
<span class="udiff-line-modified-added">+             final int int_b = b.bigitOrZero(i);</span>
<span class="udiff-line-modified-added">+             final int int_c = c.bigitOrZero(i);</span>
              final int sum = int_a + int_b;
              if (sum &gt; int_c + borrow) {
                  return +1;
              } else {
                  borrow = int_c + borrow - sum;
</pre>
<center><a href="../StoredScript.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BignumDtoa.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
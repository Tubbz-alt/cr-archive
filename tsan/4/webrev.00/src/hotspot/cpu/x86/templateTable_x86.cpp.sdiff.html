<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3291   transition(vtos, vtos);
3292 
3293   const Register cache = rcx;
3294   const Register index = rdx;
3295   const Register obj   = rcx;
3296   const Register off   = rbx;
3297   const Register flags = rax;
3298 
3299   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3300   jvmti_post_field_mod(cache, index, is_static);
3301   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3302 
3303   // [jk] not needed currently
3304   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3305   //                                              Assembler::StoreStore));
3306 
3307   Label notVolatile, Done;
3308   __ movl(rdx, flags);
3309 
3310   // Check for volatile store
<span class="line-modified">3311   __ testl(rdx, rdx);</span>
3312   __ jcc(Assembler::zero, notVolatile);
3313 
3314   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3315   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3316                                                Assembler::StoreStore));
3317   __ jmp(Done);
3318   __ bind(notVolatile);
3319 
3320   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3321 
3322   __ bind(Done);
3323 }
3324 
3325 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
3326                                               Register obj, Register off, Register flags) {
3327 
3328   // field addresses
3329   const Address field(obj, off, Address::times_1, 0*wordSize);
3330   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3331 
</pre>
</td>
<td>
<hr />
<pre>
3291   transition(vtos, vtos);
3292 
3293   const Register cache = rcx;
3294   const Register index = rdx;
3295   const Register obj   = rcx;
3296   const Register off   = rbx;
3297   const Register flags = rax;
3298 
3299   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3300   jvmti_post_field_mod(cache, index, is_static);
3301   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3302 
3303   // [jk] not needed currently
3304   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3305   //                                              Assembler::StoreStore));
3306 
3307   Label notVolatile, Done;
3308   __ movl(rdx, flags);
3309 
3310   // Check for volatile store
<span class="line-modified">3311   __ testl(rdx, 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift);</span>
3312   __ jcc(Assembler::zero, notVolatile);
3313 
3314   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3315   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3316                                                Assembler::StoreStore));
3317   __ jmp(Done);
3318   __ bind(notVolatile);
3319 
3320   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3321 
3322   __ bind(Done);
3323 }
3324 
3325 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
3326                                               Register obj, Register off, Register flags) {
3327 
3328   // field addresses
3329   const Address field(obj, off, Address::times_1, 0*wordSize);
3330   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3331 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
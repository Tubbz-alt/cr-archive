<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/posix/os_posix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;jvm.h&quot;
  26 #include &quot;logging/log.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_posix.inline.hpp&quot;
  29 #include &quot;utilities/globalDefinitions.hpp&quot;
  30 #include &quot;runtime/frame.inline.hpp&quot;
  31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  32 #include &quot;services/memTracker.hpp&quot;
  33 #include &quot;runtime/atomic.hpp&quot;
  34 #include &quot;runtime/orderAccess.hpp&quot;
  35 #include &quot;utilities/align.hpp&quot;
  36 #include &quot;utilities/events.hpp&quot;
  37 #include &quot;utilities/formatBuffer.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #include &quot;utilities/vmError.hpp&quot;
  40 
  41 #include &lt;dirent.h&gt;
  42 #include &lt;dlfcn.h&gt;
  43 #include &lt;grp.h&gt;
  44 #include &lt;pwd.h&gt;
  45 #include &lt;pthread.h&gt;
  46 #include &lt;signal.h&gt;
  47 #include &lt;sys/mman.h&gt;
  48 #include &lt;sys/resource.h&gt;
  49 #include &lt;sys/utsname.h&gt;
  50 #include &lt;time.h&gt;
  51 #include &lt;unistd.h&gt;
  52 #include &lt;utmpx.h&gt;
  53 
  54 // Todo: provide a os::get_max_process_id() or similar. Number of processes
  55 // may have been configured, can be read more accurately from proc fs etc.
  56 #ifndef MAX_PID
  57 #define MAX_PID INT_MAX
  58 #endif
  59 #define IS_VALID_PID(p) (p &gt; 0 &amp;&amp; p &lt; MAX_PID)
  60 
  61 #define ROOT_UID 0
  62 
  63 #ifndef MAP_ANONYMOUS
  64   #define MAP_ANONYMOUS MAP_ANON
  65 #endif
  66 
  67 #define check_with_errno(check_type, cond, msg)                             \
  68   do {                                                                      \
  69     int err = errno;                                                        \
  70     check_type(cond, &quot;%s; error=&#39;%s&#39; (errno=%s)&quot;, msg, os::strerror(err),   \
  71                os::errno_name(err));                                        \
  72 } while (false)
  73 
  74 #define assert_with_errno(cond, msg)    check_with_errno(assert, cond, msg)
  75 #define guarantee_with_errno(cond, msg) check_with_errno(guarantee, cond, msg)
  76 
  77 // Check core dump limit and report possible place where core can be found
  78 void os::check_dump_limit(char* buffer, size_t bufferSize) {
  79   if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) &amp;&amp; !CreateCoredumpOnCrash) {
  80     jio_snprintf(buffer, bufferSize, &quot;CreateCoredumpOnCrash is disabled from command line&quot;);
  81     VMError::record_coredump_status(buffer, false);
  82     return;
  83   }
  84 
  85   int n;
  86   struct rlimit rlim;
  87   bool success;
  88 
  89   char core_path[PATH_MAX];
  90   n = get_core_path(core_path, PATH_MAX);
  91 
  92   if (n &lt;= 0) {
  93     jio_snprintf(buffer, bufferSize, &quot;core.%d (may not exist)&quot;, current_process_id());
  94     success = true;
  95 #ifdef LINUX
  96   } else if (core_path[0] == &#39;&quot;&#39;) { // redirect to user process
  97     jio_snprintf(buffer, bufferSize, &quot;Core dumps may be processed with %s&quot;, core_path);
  98     success = true;
  99 #endif
 100   } else if (getrlimit(RLIMIT_CORE, &amp;rlim) != 0) {
 101     jio_snprintf(buffer, bufferSize, &quot;%s (may not exist)&quot;, core_path);
 102     success = true;
 103   } else {
 104     switch(rlim.rlim_cur) {
 105       case RLIM_INFINITY:
 106         jio_snprintf(buffer, bufferSize, &quot;%s&quot;, core_path);
 107         success = true;
 108         break;
 109       case 0:
 110         jio_snprintf(buffer, bufferSize, &quot;Core dumps have been disabled. To enable core dumping, try \&quot;ulimit -c unlimited\&quot; before starting Java again&quot;);
 111         success = false;
 112         break;
 113       default:
 114         jio_snprintf(buffer, bufferSize, &quot;%s (max size &quot; UINT64_FORMAT &quot; kB). To ensure a full core dump, try \&quot;ulimit -c unlimited\&quot; before starting Java again&quot;, core_path, uint64_t(rlim.rlim_cur) / 1024);
 115         success = true;
 116         break;
 117     }
 118   }
 119 
 120   VMError::record_coredump_status(buffer, success);
 121 }
 122 
 123 int os::get_native_stack(address* stack, int frames, int toSkip) {
 124   int frame_idx = 0;
 125   int num_of_frames;  // number of frames captured
 126   frame fr = os::current_frame();
 127   while (fr.pc() &amp;&amp; frame_idx &lt; frames) {
 128     if (toSkip &gt; 0) {
 129       toSkip --;
 130     } else {
 131       stack[frame_idx ++] = fr.pc();
 132     }
 133     if (fr.fp() == NULL || fr.cb() != NULL ||
 134         fr.sender_pc() == NULL || os::is_first_C_frame(&amp;fr)) break;
 135 
 136     if (fr.sender_pc() &amp;&amp; !os::is_first_C_frame(&amp;fr)) {
 137       fr = os::get_sender_for_C_frame(&amp;fr);
 138     } else {
 139       break;
 140     }
 141   }
 142   num_of_frames = frame_idx;
 143   for (; frame_idx &lt; frames; frame_idx ++) {
 144     stack[frame_idx] = NULL;
 145   }
 146 
 147   return num_of_frames;
 148 }
 149 
 150 
 151 bool os::unsetenv(const char* name) {
 152   assert(name != NULL, &quot;Null pointer&quot;);
 153   return (::unsetenv(name) == 0);
 154 }
 155 
 156 int os::get_last_error() {
 157   return errno;
 158 }
 159 
 160 size_t os::lasterror(char *buf, size_t len) {
 161   if (errno == 0)  return 0;
 162 
 163   const char *s = os::strerror(errno);
 164   size_t n = ::strlen(s);
 165   if (n &gt;= len) {
 166     n = len - 1;
 167   }
 168   ::strncpy(buf, s, n);
 169   buf[n] = &#39;\0&#39;;
 170   return n;
 171 }
 172 
 173 void os::wait_for_keypress_at_exit(void) {
 174   // don&#39;t do anything on posix platforms
 175   return;
 176 }
 177 
 178 int os::create_file_for_heap(const char* dir) {
 179   int fd;
 180 
 181 #if defined(LINUX) &amp;&amp; defined(O_TMPFILE)
 182   char* native_dir = os::strdup(dir);
 183   if (native_dir == NULL) {
 184     vm_exit_during_initialization(err_msg(&quot;strdup failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));
 185     return -1;
 186   }
 187   os::native_path(native_dir);
 188   fd = os::open(dir, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);
 189   os::free(native_dir);
 190 
 191   if (fd == -1)
 192 #endif
 193   {
 194     const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;
 195 
 196     size_t fullname_len = strlen(dir) + strlen(name_template);
 197     char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);
 198     if (fullname == NULL) {
 199       vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));
 200       return -1;
 201     }
 202     int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);
 203     assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);
 204 
 205     os::native_path(fullname);
 206 
 207     // create a new file.
 208     fd = mkstemp(fullname);
 209 
 210     if (fd &lt; 0) {
 211       warning(&quot;Could not create file for heap with template %s&quot;, fullname);
 212       os::free(fullname);
 213       return -1;
 214     } else {
 215       // delete the name from the filesystem. When &#39;fd&#39; is closed, the file (and space) will be deleted.
 216       int ret = unlink(fullname);
 217       assert_with_errno(ret == 0, &quot;unlink returned error&quot;);
 218     }
 219 
 220     os::free(fullname);
 221   }
 222 
 223   return fd;
 224 }
 225 
 226 static char* reserve_mmapped_memory(size_t bytes, char* requested_addr) {
 227   char * addr;
 228   int flags = MAP_PRIVATE NOT_AIX( | MAP_NORESERVE ) | MAP_ANONYMOUS;
 229   if (requested_addr != NULL) {
 230     assert((uintptr_t)requested_addr % os::vm_page_size() == 0, &quot;Requested address should be aligned to OS page size&quot;);
 231     flags |= MAP_FIXED;
 232   }
 233 
 234   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
 235   // touch an uncommitted page. Otherwise, the read/write might
 236   // succeed if we have enough swap space to back the physical page.
 237   addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,
 238                        flags, -1, 0);
 239 
 240   if (addr != MAP_FAILED) {
 241     MemTracker::record_virtual_memory_reserve((address)addr, bytes, CALLER_PC);
 242     return addr;
 243   }
 244   return NULL;
 245 }
 246 
 247 static int util_posix_fallocate(int fd, off_t offset, off_t len) {
 248 #ifdef __APPLE__
 249   fstore_t store = { F_ALLOCATECONTIG, F_PEOFPOSMODE, 0, len };
 250   // First we try to get a continuous chunk of disk space
 251   int ret = fcntl(fd, F_PREALLOCATE, &amp;store);
 252   if (ret == -1) {
 253     // Maybe we are too fragmented, try to allocate non-continuous range
 254     store.fst_flags = F_ALLOCATEALL;
 255     ret = fcntl(fd, F_PREALLOCATE, &amp;store);
 256   }
 257   if(ret != -1) {
 258     return ftruncate(fd, len);
 259   }
 260   return -1;
 261 #else
 262   return posix_fallocate(fd, offset, len);
 263 #endif
 264 }
 265 
 266 // Map the given address range to the provided file descriptor.
 267 char* os::map_memory_to_file(char* base, size_t size, int fd) {
 268   assert(fd != -1, &quot;File descriptor is not valid&quot;);
 269 
 270   // allocate space for the file
 271   int ret = util_posix_fallocate(fd, 0, (off_t)size);
 272   if (ret != 0) {
 273     vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory. error(%d)&quot;, ret));
 274     return NULL;
 275   }
 276 
 277   int prot = PROT_READ | PROT_WRITE;
 278   int flags = MAP_SHARED;
 279   if (base != NULL) {
 280     flags |= MAP_FIXED;
 281   }
 282   char* addr = (char*)mmap(base, size, prot, flags, fd, 0);
 283 
 284   if (addr == MAP_FAILED) {
 285     warning(&quot;Failed mmap to file. (%s)&quot;, os::strerror(errno));
 286     return NULL;
 287   }
 288   if (base != NULL &amp;&amp; addr != base) {
 289     if (!os::release_memory(addr, size)) {
 290       warning(&quot;Could not release memory on unsuccessful file mapping&quot;);
 291     }
 292     return NULL;
 293   }
 294   return addr;
 295 }
 296 
 297 char* os::replace_existing_mapping_with_file_mapping(char* base, size_t size, int fd) {
 298   assert(fd != -1, &quot;File descriptor is not valid&quot;);
 299   assert(base != NULL, &quot;Base cannot be NULL&quot;);
 300 
 301   return map_memory_to_file(base, size, fd);
 302 }
 303 
 304 // Multiple threads can race in this code, and can remap over each other with MAP_FIXED,
 305 // so on posix, unmap the section at the start and at the end of the chunk that we mapped
 306 // rather than unmapping and remapping the whole chunk to get requested alignment.
 307 char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
 308   assert((alignment &amp; (os::vm_allocation_granularity() - 1)) == 0,
 309       &quot;Alignment must be a multiple of allocation granularity (page size)&quot;);
 310   assert((size &amp; (alignment -1)) == 0, &quot;size must be &#39;alignment&#39; aligned&quot;);
 311 
 312   size_t extra_size = size + alignment;
 313   assert(extra_size &gt;= size, &quot;overflow, size is too large to allow alignment&quot;);
 314 
 315   char* extra_base;
 316   if (file_desc != -1) {
 317     // For file mapping, we do not call os:reserve_memory(extra_size, NULL, alignment, file_desc) because
 318     // we need to deal with shrinking of the file space later when we release extra memory after alignment.
 319     // We also cannot called os:reserve_memory() with file_desc set to -1 because on aix we might get SHM memory.
 320     // So here to call a helper function while reserve memory for us. After we have a aligned base,
 321     // we will replace anonymous mapping with file mapping.
 322     extra_base = reserve_mmapped_memory(extra_size, NULL);
 323     if (extra_base != NULL) {
 324       MemTracker::record_virtual_memory_reserve((address)extra_base, extra_size, CALLER_PC);
 325     }
 326   } else {
 327     extra_base = os::reserve_memory(extra_size, NULL, alignment);
 328   }
 329 
 330   if (extra_base == NULL) {
 331     return NULL;
 332   }
 333 
 334   // Do manual alignment
 335   char* aligned_base = align_up(extra_base, alignment);
 336 
 337   // [  |                                       |  ]
 338   // ^ extra_base
 339   //    ^ extra_base + begin_offset == aligned_base
 340   //     extra_base + begin_offset + size       ^
 341   //                       extra_base + extra_size ^
 342   // |&lt;&gt;| == begin_offset
 343   //                              end_offset == |&lt;&gt;|
 344   size_t begin_offset = aligned_base - extra_base;
 345   size_t end_offset = (extra_base + extra_size) - (aligned_base + size);
 346 
 347   if (begin_offset &gt; 0) {
 348       os::release_memory(extra_base, begin_offset);
 349   }
 350 
 351   if (end_offset &gt; 0) {
 352       os::release_memory(extra_base + begin_offset + size, end_offset);
 353   }
 354 
 355   if (file_desc != -1) {
 356     // After we have an aligned address, we can replace anonymous mapping with file mapping
 357     if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {
 358       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
 359     }
 360     MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);
 361   }
 362   return aligned_base;
 363 }
 364 
 365 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
 366   // All supported POSIX platforms provide C99 semantics.
 367   int result = ::vsnprintf(buf, len, fmt, args);
 368   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
 369   // whether the buffer is NUL terminated, so ensure it is.
 370   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
 371     buf[len - 1] = &#39;\0&#39;;
 372   }
 373   return result;
 374 }
 375 
 376 int os::get_fileno(FILE* fp) {
 377   return NOT_AIX(::)fileno(fp);
 378 }
 379 
 380 struct tm* os::gmtime_pd(const time_t* clock, struct tm*  res) {
 381   return gmtime_r(clock, res);
 382 }
 383 
 384 void os::Posix::print_load_average(outputStream* st) {
 385   st-&gt;print(&quot;load average:&quot;);
 386   double loadavg[3];
 387   int res = os::loadavg(loadavg, 3);
 388   if (res != -1) {
 389     st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);
 390   } else {
 391     st-&gt;print(&quot; Unavailable&quot;);
 392   }
 393   st-&gt;cr();
 394 }
 395 
 396 // boot/uptime information;
 397 // unfortunately it does not work on macOS and Linux because the utx chain has no entry
 398 // for reboot at least on my test machines
 399 void os::Posix::print_uptime_info(outputStream* st) {
 400   int bootsec = -1;
 401   int currsec = time(NULL);
 402   struct utmpx* ent;
 403   setutxent();
 404   while ((ent = getutxent())) {
 405     if (!strcmp(&quot;system boot&quot;, ent-&gt;ut_line)) {
 406       bootsec = ent-&gt;ut_tv.tv_sec;
 407       break;
 408     }
 409   }
 410 
 411   if (bootsec != -1) {
 412     os::print_dhm(st, &quot;OS uptime:&quot;, (long) (currsec-bootsec));
 413   }
 414 }
 415 
 416 
 417 void os::Posix::print_rlimit_info(outputStream* st) {
 418   st-&gt;print(&quot;rlimit:&quot;);
 419   struct rlimit rlim;
 420 
 421   st-&gt;print(&quot; STACK &quot;);
 422   getrlimit(RLIMIT_STACK, &amp;rlim);
 423   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 424   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 425 
 426   st-&gt;print(&quot;, CORE &quot;);
 427   getrlimit(RLIMIT_CORE, &amp;rlim);
 428   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 429   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 430 
 431   // Isn&#39;t there on solaris
 432 #if defined(AIX)
 433   st-&gt;print(&quot;, NPROC &quot;);
 434   st-&gt;print(&quot;%d&quot;, sysconf(_SC_CHILD_MAX));
 435   st-&gt;print(&quot;, THREADS &quot;);
 436   getrlimit(RLIMIT_THREADS, &amp;rlim);
 437   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 438   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 439 #elif !defined(SOLARIS)
 440   st-&gt;print(&quot;, NPROC &quot;);
 441   getrlimit(RLIMIT_NPROC, &amp;rlim);
 442   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 443   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 444 #endif
 445 
 446   st-&gt;print(&quot;, NOFILE &quot;);
 447   getrlimit(RLIMIT_NOFILE, &amp;rlim);
 448   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 449   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 450 
 451   st-&gt;print(&quot;, AS &quot;);
 452   getrlimit(RLIMIT_AS, &amp;rlim);
 453   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 454   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 455 
 456   st-&gt;print(&quot;, CPU &quot;);
 457   getrlimit(RLIMIT_CPU, &amp;rlim);
 458   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 459   else st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));
 460 
 461   st-&gt;print(&quot;, DATA &quot;);
 462   getrlimit(RLIMIT_DATA, &amp;rlim);
 463   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 464   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 465 
 466   st-&gt;print(&quot;, FSIZE &quot;);
 467   getrlimit(RLIMIT_FSIZE, &amp;rlim);
 468   if (rlim.rlim_cur == RLIM_INFINITY) st-&gt;print(&quot;infinity&quot;);
 469   else st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_cur) / 1024);
 470 
 471   st-&gt;cr();
 472 }
 473 
 474 void os::Posix::print_uname_info(outputStream* st) {
 475   // kernel
 476   st-&gt;print(&quot;uname:&quot;);
 477   struct utsname name;
 478   uname(&amp;name);
 479   st-&gt;print(&quot;%s &quot;, name.sysname);
 480 #ifdef ASSERT
 481   st-&gt;print(&quot;%s &quot;, name.nodename);
 482 #endif
 483   st-&gt;print(&quot;%s &quot;, name.release);
 484   st-&gt;print(&quot;%s &quot;, name.version);
 485   st-&gt;print(&quot;%s&quot;, name.machine);
 486   st-&gt;cr();
 487 }
 488 
 489 void os::Posix::print_umask(outputStream* st, mode_t umsk) {
 490   st-&gt;print((umsk &amp; S_IRUSR) ? &quot;r&quot; : &quot;-&quot;);
 491   st-&gt;print((umsk &amp; S_IWUSR) ? &quot;w&quot; : &quot;-&quot;);
 492   st-&gt;print((umsk &amp; S_IXUSR) ? &quot;x&quot; : &quot;-&quot;);
 493   st-&gt;print((umsk &amp; S_IRGRP) ? &quot;r&quot; : &quot;-&quot;);
 494   st-&gt;print((umsk &amp; S_IWGRP) ? &quot;w&quot; : &quot;-&quot;);
 495   st-&gt;print((umsk &amp; S_IXGRP) ? &quot;x&quot; : &quot;-&quot;);
 496   st-&gt;print((umsk &amp; S_IROTH) ? &quot;r&quot; : &quot;-&quot;);
 497   st-&gt;print((umsk &amp; S_IWOTH) ? &quot;w&quot; : &quot;-&quot;);
 498   st-&gt;print((umsk &amp; S_IXOTH) ? &quot;x&quot; : &quot;-&quot;);
 499 }
 500 
 501 void os::Posix::print_user_info(outputStream* st) {
 502   unsigned id = (unsigned) ::getuid();
 503   st-&gt;print(&quot;uid  : %u &quot;, id);
 504   id = (unsigned) ::geteuid();
 505   st-&gt;print(&quot;euid : %u &quot;, id);
 506   id = (unsigned) ::getgid();
 507   st-&gt;print(&quot;gid  : %u &quot;, id);
 508   id = (unsigned) ::getegid();
 509   st-&gt;print_cr(&quot;egid : %u&quot;, id);
 510   st-&gt;cr();
 511 
 512   mode_t umsk = ::umask(0);
 513   ::umask(umsk);
 514   st-&gt;print(&quot;umask: %04o (&quot;, (unsigned) umsk);
 515   print_umask(st, umsk);
 516   st-&gt;print_cr(&quot;)&quot;);
 517   st-&gt;cr();
 518 }
 519 
 520 
 521 bool os::get_host_name(char* buf, size_t buflen) {
 522   struct utsname name;
 523   uname(&amp;name);
 524   jio_snprintf(buf, buflen, &quot;%s&quot;, name.nodename);
 525   return true;
 526 }
 527 
 528 bool os::has_allocatable_memory_limit(julong* limit) {
 529   struct rlimit rlim;
 530   int getrlimit_res = getrlimit(RLIMIT_AS, &amp;rlim);
 531   // if there was an error when calling getrlimit, assume that there is no limitation
 532   // on virtual memory.
 533   bool result;
 534   if ((getrlimit_res != 0) || (rlim.rlim_cur == RLIM_INFINITY)) {
 535     result = false;
 536   } else {
 537     *limit = (julong)rlim.rlim_cur;
 538     result = true;
 539   }
<a name="1" id="anc1"></a><span class="line-added"> 540 </span>
<span class="line-added"> 541 #if (INCLUDE_TSAN) &amp;&amp; defined(AARCH64)</span>
<span class="line-added"> 542   // Current TSAN memory mapping for 48bits aarch64, a large continuous space could be allocated between</span>
<span class="line-added"> 543   // kMidAppMemBeg = 0x0aaaa00000000ull and kMidAppMemEnd = 0x0aaaf00000000ull, which is only 20GB size.</span>
<span class="line-added"> 544   // Take 16GB here for safer allocation.</span>
<span class="line-added"> 545   const julong max_avail_vmspace = 16ULL * G; // 16GB</span>
<span class="line-added"> 546   const u8 msb_in_aarch64 = 47; // Only support 48-bits space now.</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548   // Based on tsan memory mapping for 48bits aarch64,</span>
<span class="line-added"> 549   // libjvm.so will be loaded between kHiAppMemBeg = 0x0ffff00000000ull and kHiAppMemEnd = 0x1000000000000ull</span>
<span class="line-added"> 550   u8 vm_addr_u8 = reinterpret_cast&lt;u8&gt;(&amp;__FUNCTION__);</span>
<span class="line-added"> 551   // High address in 48bits user space is like 0x0000ffffxxxxxxxx.</span>
<span class="line-added"> 552   assert((vm_addr_u8  &gt;&gt; msb_in_aarch64) == 0x1, &quot;warning: allocation could fail in non 48-bit address space.&quot;);</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554   if (result) {</span>
<span class="line-added"> 555     *limit = MIN2(*limit, max_avail_vmspace);</span>
<span class="line-added"> 556   } else {</span>
<span class="line-added"> 557     *limit = max_avail_vmspace;</span>
<span class="line-added"> 558   }</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   result = true;</span>
<span class="line-added"> 561 #endif</span>
<span class="line-added"> 562 </span>
 563 #ifdef _LP64
 564   return result;
 565 #else
 566   // arbitrary virtual space limit for 32 bit Unices found by testing. If
 567   // getrlimit above returned a limit, bound it with this limit. Otherwise
 568   // directly use it.
 569   const julong max_virtual_limit = (julong)3800*M;
 570   if (result) {
 571     *limit = MIN2(*limit, max_virtual_limit);
 572   } else {
 573     *limit = max_virtual_limit;
 574   }
 575 
 576   // bound by actually allocatable memory. The algorithm uses two bounds, an
 577   // upper and a lower limit. The upper limit is the current highest amount of
 578   // memory that could not be allocated, the lower limit is the current highest
 579   // amount of memory that could be allocated.
 580   // The algorithm iteratively refines the result by halving the difference
 581   // between these limits, updating either the upper limit (if that value could
 582   // not be allocated) or the lower limit (if the that value could be allocated)
 583   // until the difference between these limits is &quot;small&quot;.
 584 
 585   // the minimum amount of memory we care about allocating.
 586   const julong min_allocation_size = M;
 587 
 588   julong upper_limit = *limit;
 589 
 590   // first check a few trivial cases
 591   if (is_allocatable(upper_limit) || (upper_limit &lt;= min_allocation_size)) {
 592     *limit = upper_limit;
 593   } else if (!is_allocatable(min_allocation_size)) {
 594     // we found that not even min_allocation_size is allocatable. Return it
 595     // anyway. There is no point to search for a better value any more.
 596     *limit = min_allocation_size;
 597   } else {
 598     // perform the binary search.
 599     julong lower_limit = min_allocation_size;
 600     while ((upper_limit - lower_limit) &gt; min_allocation_size) {
 601       julong temp_limit = ((upper_limit - lower_limit) / 2) + lower_limit;
 602       temp_limit = align_down(temp_limit, min_allocation_size);
 603       if (is_allocatable(temp_limit)) {
 604         lower_limit = temp_limit;
 605       } else {
 606         upper_limit = temp_limit;
 607       }
 608     }
 609     *limit = lower_limit;
 610   }
 611   return true;
 612 #endif
 613 }
 614 
 615 const char* os::get_current_directory(char *buf, size_t buflen) {
 616   return getcwd(buf, buflen);
 617 }
 618 
 619 FILE* os::open(int fd, const char* mode) {
 620   return ::fdopen(fd, mode);
 621 }
 622 
 623 ssize_t os::read_at(int fd, void *buf, unsigned int nBytes, jlong offset) {
 624   return ::pread(fd, buf, nBytes, offset);
 625 }
 626 
 627 void os::flockfile(FILE* fp) {
 628   ::flockfile(fp);
 629 }
 630 
 631 void os::funlockfile(FILE* fp) {
 632   ::funlockfile(fp);
 633 }
 634 
 635 DIR* os::opendir(const char* dirname) {
 636   assert(dirname != NULL, &quot;just checking&quot;);
 637   return ::opendir(dirname);
 638 }
 639 
 640 struct dirent* os::readdir(DIR* dirp) {
 641   assert(dirp != NULL, &quot;just checking&quot;);
 642   return ::readdir(dirp);
 643 }
 644 
 645 int os::closedir(DIR *dirp) {
 646   assert(dirp != NULL, &quot;just checking&quot;);
 647   return ::closedir(dirp);
 648 }
 649 
 650 // Builds a platform dependent Agent_OnLoad_&lt;lib_name&gt; function name
 651 // which is used to find statically linked in agents.
 652 // Parameters:
 653 //            sym_name: Symbol in library we are looking for
 654 //            lib_name: Name of library to look in, NULL for shared libs.
 655 //            is_absolute_path == true if lib_name is absolute path to agent
 656 //                                     such as &quot;/a/b/libL.so&quot;
 657 //            == false if only the base name of the library is passed in
 658 //               such as &quot;L&quot;
 659 char* os::build_agent_function_name(const char *sym_name, const char *lib_name,
 660                                     bool is_absolute_path) {
 661   char *agent_entry_name;
 662   size_t len;
 663   size_t name_len;
 664   size_t prefix_len = strlen(JNI_LIB_PREFIX);
 665   size_t suffix_len = strlen(JNI_LIB_SUFFIX);
 666   const char *start;
 667 
 668   if (lib_name != NULL) {
 669     name_len = strlen(lib_name);
 670     if (is_absolute_path) {
 671       // Need to strip path, prefix and suffix
 672       if ((start = strrchr(lib_name, *os::file_separator())) != NULL) {
 673         lib_name = ++start;
 674       }
 675       if (strlen(lib_name) &lt;= (prefix_len + suffix_len)) {
 676         return NULL;
 677       }
 678       lib_name += prefix_len;
 679       name_len = strlen(lib_name) - suffix_len;
 680     }
 681   }
 682   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
 683   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
 684   if (agent_entry_name == NULL) {
 685     return NULL;
 686   }
 687   strcpy(agent_entry_name, sym_name);
 688   if (lib_name != NULL) {
 689     strcat(agent_entry_name, &quot;_&quot;);
 690     strncat(agent_entry_name, lib_name, name_len);
 691   }
 692   return agent_entry_name;
 693 }
 694 
 695 
 696 void os::naked_short_nanosleep(jlong ns) {
 697   struct timespec req;
 698   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
 699   req.tv_sec = 0;
 700   req.tv_nsec = ns;
 701   ::nanosleep(&amp;req, NULL);
 702   return;
 703 }
 704 
 705 void os::naked_short_sleep(jlong ms) {
 706   assert(ms &lt; MILLIUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
 707   os::naked_short_nanosleep(millis_to_nanos(ms));
 708   return;
 709 }
 710 
 711 static const struct {
 712   int sig; const char* name;
 713 }
 714  g_signal_info[] =
 715   {
 716   {  SIGABRT,     &quot;SIGABRT&quot; },
 717 #ifdef SIGAIO
 718   {  SIGAIO,      &quot;SIGAIO&quot; },
 719 #endif
 720   {  SIGALRM,     &quot;SIGALRM&quot; },
 721 #ifdef SIGALRM1
 722   {  SIGALRM1,    &quot;SIGALRM1&quot; },
 723 #endif
 724   {  SIGBUS,      &quot;SIGBUS&quot; },
 725 #ifdef SIGCANCEL
 726   {  SIGCANCEL,   &quot;SIGCANCEL&quot; },
 727 #endif
 728   {  SIGCHLD,     &quot;SIGCHLD&quot; },
 729 #ifdef SIGCLD
 730   {  SIGCLD,      &quot;SIGCLD&quot; },
 731 #endif
 732   {  SIGCONT,     &quot;SIGCONT&quot; },
 733 #ifdef SIGCPUFAIL
 734   {  SIGCPUFAIL,  &quot;SIGCPUFAIL&quot; },
 735 #endif
 736 #ifdef SIGDANGER
 737   {  SIGDANGER,   &quot;SIGDANGER&quot; },
 738 #endif
 739 #ifdef SIGDIL
 740   {  SIGDIL,      &quot;SIGDIL&quot; },
 741 #endif
 742 #ifdef SIGEMT
 743   {  SIGEMT,      &quot;SIGEMT&quot; },
 744 #endif
 745   {  SIGFPE,      &quot;SIGFPE&quot; },
 746 #ifdef SIGFREEZE
 747   {  SIGFREEZE,   &quot;SIGFREEZE&quot; },
 748 #endif
 749 #ifdef SIGGFAULT
 750   {  SIGGFAULT,   &quot;SIGGFAULT&quot; },
 751 #endif
 752 #ifdef SIGGRANT
 753   {  SIGGRANT,    &quot;SIGGRANT&quot; },
 754 #endif
 755   {  SIGHUP,      &quot;SIGHUP&quot; },
 756   {  SIGILL,      &quot;SIGILL&quot; },
 757 #ifdef SIGINFO
 758   {  SIGINFO,     &quot;SIGINFO&quot; },
 759 #endif
 760   {  SIGINT,      &quot;SIGINT&quot; },
 761 #ifdef SIGIO
 762   {  SIGIO,       &quot;SIGIO&quot; },
 763 #endif
 764 #ifdef SIGIOINT
 765   {  SIGIOINT,    &quot;SIGIOINT&quot; },
 766 #endif
 767 #ifdef SIGIOT
 768 // SIGIOT is there for BSD compatibility, but on most Unices just a
 769 // synonym for SIGABRT. The result should be &quot;SIGABRT&quot;, not
 770 // &quot;SIGIOT&quot;.
 771 #if (SIGIOT != SIGABRT )
 772   {  SIGIOT,      &quot;SIGIOT&quot; },
 773 #endif
 774 #endif
 775 #ifdef SIGKAP
 776   {  SIGKAP,      &quot;SIGKAP&quot; },
 777 #endif
 778   {  SIGKILL,     &quot;SIGKILL&quot; },
 779 #ifdef SIGLOST
 780   {  SIGLOST,     &quot;SIGLOST&quot; },
 781 #endif
 782 #ifdef SIGLWP
 783   {  SIGLWP,      &quot;SIGLWP&quot; },
 784 #endif
 785 #ifdef SIGLWPTIMER
 786   {  SIGLWPTIMER, &quot;SIGLWPTIMER&quot; },
 787 #endif
 788 #ifdef SIGMIGRATE
 789   {  SIGMIGRATE,  &quot;SIGMIGRATE&quot; },
 790 #endif
 791 #ifdef SIGMSG
 792   {  SIGMSG,      &quot;SIGMSG&quot; },
 793 #endif
 794   {  SIGPIPE,     &quot;SIGPIPE&quot; },
 795 #ifdef SIGPOLL
 796   {  SIGPOLL,     &quot;SIGPOLL&quot; },
 797 #endif
 798 #ifdef SIGPRE
 799   {  SIGPRE,      &quot;SIGPRE&quot; },
 800 #endif
 801   {  SIGPROF,     &quot;SIGPROF&quot; },
 802 #ifdef SIGPTY
 803   {  SIGPTY,      &quot;SIGPTY&quot; },
 804 #endif
 805 #ifdef SIGPWR
 806   {  SIGPWR,      &quot;SIGPWR&quot; },
 807 #endif
 808   {  SIGQUIT,     &quot;SIGQUIT&quot; },
 809 #ifdef SIGRECONFIG
 810   {  SIGRECONFIG, &quot;SIGRECONFIG&quot; },
 811 #endif
 812 #ifdef SIGRECOVERY
 813   {  SIGRECOVERY, &quot;SIGRECOVERY&quot; },
 814 #endif
 815 #ifdef SIGRESERVE
 816   {  SIGRESERVE,  &quot;SIGRESERVE&quot; },
 817 #endif
 818 #ifdef SIGRETRACT
 819   {  SIGRETRACT,  &quot;SIGRETRACT&quot; },
 820 #endif
 821 #ifdef SIGSAK
 822   {  SIGSAK,      &quot;SIGSAK&quot; },
 823 #endif
 824   {  SIGSEGV,     &quot;SIGSEGV&quot; },
 825 #ifdef SIGSOUND
 826   {  SIGSOUND,    &quot;SIGSOUND&quot; },
 827 #endif
 828 #ifdef SIGSTKFLT
 829   {  SIGSTKFLT,    &quot;SIGSTKFLT&quot; },
 830 #endif
 831   {  SIGSTOP,     &quot;SIGSTOP&quot; },
 832   {  SIGSYS,      &quot;SIGSYS&quot; },
 833 #ifdef SIGSYSERROR
 834   {  SIGSYSERROR, &quot;SIGSYSERROR&quot; },
 835 #endif
 836 #ifdef SIGTALRM
 837   {  SIGTALRM,    &quot;SIGTALRM&quot; },
 838 #endif
 839   {  SIGTERM,     &quot;SIGTERM&quot; },
 840 #ifdef SIGTHAW
 841   {  SIGTHAW,     &quot;SIGTHAW&quot; },
 842 #endif
 843   {  SIGTRAP,     &quot;SIGTRAP&quot; },
 844 #ifdef SIGTSTP
 845   {  SIGTSTP,     &quot;SIGTSTP&quot; },
 846 #endif
 847   {  SIGTTIN,     &quot;SIGTTIN&quot; },
 848   {  SIGTTOU,     &quot;SIGTTOU&quot; },
 849 #ifdef SIGURG
 850   {  SIGURG,      &quot;SIGURG&quot; },
 851 #endif
 852   {  SIGUSR1,     &quot;SIGUSR1&quot; },
 853   {  SIGUSR2,     &quot;SIGUSR2&quot; },
 854 #ifdef SIGVIRT
 855   {  SIGVIRT,     &quot;SIGVIRT&quot; },
 856 #endif
 857   {  SIGVTALRM,   &quot;SIGVTALRM&quot; },
 858 #ifdef SIGWAITING
 859   {  SIGWAITING,  &quot;SIGWAITING&quot; },
 860 #endif
 861 #ifdef SIGWINCH
 862   {  SIGWINCH,    &quot;SIGWINCH&quot; },
 863 #endif
 864 #ifdef SIGWINDOW
 865   {  SIGWINDOW,   &quot;SIGWINDOW&quot; },
 866 #endif
 867   {  SIGXCPU,     &quot;SIGXCPU&quot; },
 868   {  SIGXFSZ,     &quot;SIGXFSZ&quot; },
 869 #ifdef SIGXRES
 870   {  SIGXRES,     &quot;SIGXRES&quot; },
 871 #endif
 872   { -1, NULL }
 873 };
 874 
 875 // Returned string is a constant. For unknown signals &quot;UNKNOWN&quot; is returned.
 876 const char* os::Posix::get_signal_name(int sig, char* out, size_t outlen) {
 877 
 878   const char* ret = NULL;
 879 
 880 #ifdef SIGRTMIN
 881   if (sig &gt;= SIGRTMIN &amp;&amp; sig &lt;= SIGRTMAX) {
 882     if (sig == SIGRTMIN) {
 883       ret = &quot;SIGRTMIN&quot;;
 884     } else if (sig == SIGRTMAX) {
 885       ret = &quot;SIGRTMAX&quot;;
 886     } else {
 887       jio_snprintf(out, outlen, &quot;SIGRTMIN+%d&quot;, sig - SIGRTMIN);
 888       return out;
 889     }
 890   }
 891 #endif
 892 
 893   if (sig &gt; 0) {
 894     for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {
 895       if (g_signal_info[idx].sig == sig) {
 896         ret = g_signal_info[idx].name;
 897         break;
 898       }
 899     }
 900   }
 901 
 902   if (!ret) {
 903     if (!is_valid_signal(sig)) {
 904       ret = &quot;INVALID&quot;;
 905     } else {
 906       ret = &quot;UNKNOWN&quot;;
 907     }
 908   }
 909 
 910   if (out &amp;&amp; outlen &gt; 0) {
 911     strncpy(out, ret, outlen);
 912     out[outlen - 1] = &#39;\0&#39;;
 913   }
 914   return out;
 915 }
 916 
 917 int os::Posix::get_signal_number(const char* signal_name) {
 918   char tmp[30];
 919   const char* s = signal_name;
 920   if (s[0] != &#39;S&#39; || s[1] != &#39;I&#39; || s[2] != &#39;G&#39;) {
 921     jio_snprintf(tmp, sizeof(tmp), &quot;SIG%s&quot;, signal_name);
 922     s = tmp;
 923   }
 924   for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {
 925     if (strcmp(g_signal_info[idx].name, s) == 0) {
 926       return g_signal_info[idx].sig;
 927     }
 928   }
 929   return -1;
 930 }
 931 
 932 int os::get_signal_number(const char* signal_name) {
 933   return os::Posix::get_signal_number(signal_name);
 934 }
 935 
 936 // Returns true if signal number is valid.
 937 bool os::Posix::is_valid_signal(int sig) {
 938   // MacOS not really POSIX compliant: sigaddset does not return
 939   // an error for invalid signal numbers. However, MacOS does not
 940   // support real time signals and simply seems to have just 33
 941   // signals with no holes in the signal range.
 942 #ifdef __APPLE__
 943   return sig &gt;= 1 &amp;&amp; sig &lt; NSIG;
 944 #else
 945   // Use sigaddset to check for signal validity.
 946   sigset_t set;
 947   sigemptyset(&amp;set);
 948   if (sigaddset(&amp;set, sig) == -1 &amp;&amp; errno == EINVAL) {
 949     return false;
 950   }
 951   return true;
 952 #endif
 953 }
 954 
 955 bool os::Posix::is_sig_ignored(int sig) {
 956   struct sigaction oact;
 957   sigaction(sig, (struct sigaction*)NULL, &amp;oact);
 958   void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)
 959                                  : CAST_FROM_FN_PTR(void*,  oact.sa_handler);
 960   if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {
 961     return true;
 962   } else {
 963     return false;
 964   }
 965 }
 966 
 967 // Returns:
 968 // NULL for an invalid signal number
 969 // &quot;SIG&lt;num&gt;&quot; for a valid but unknown signal number
 970 // signal name otherwise.
 971 const char* os::exception_name(int sig, char* buf, size_t size) {
 972   if (!os::Posix::is_valid_signal(sig)) {
 973     return NULL;
 974   }
 975   const char* const name = os::Posix::get_signal_name(sig, buf, size);
 976   if (strcmp(name, &quot;UNKNOWN&quot;) == 0) {
 977     jio_snprintf(buf, size, &quot;SIG%d&quot;, sig);
 978   }
 979   return buf;
 980 }
 981 
 982 #define NUM_IMPORTANT_SIGS 32
 983 // Returns one-line short description of a signal set in a user provided buffer.
 984 const char* os::Posix::describe_signal_set_short(const sigset_t* set, char* buffer, size_t buf_size) {
 985   assert(buf_size == (NUM_IMPORTANT_SIGS + 1), &quot;wrong buffer size&quot;);
 986   // Note: for shortness, just print out the first 32. That should
 987   // cover most of the useful ones, apart from realtime signals.
 988   for (int sig = 1; sig &lt;= NUM_IMPORTANT_SIGS; sig++) {
 989     const int rc = sigismember(set, sig);
 990     if (rc == -1 &amp;&amp; errno == EINVAL) {
 991       buffer[sig-1] = &#39;?&#39;;
 992     } else {
 993       buffer[sig-1] = rc == 0 ? &#39;0&#39; : &#39;1&#39;;
 994     }
 995   }
 996   buffer[NUM_IMPORTANT_SIGS] = 0;
 997   return buffer;
 998 }
 999 
1000 // Prints one-line description of a signal set.
1001 void os::Posix::print_signal_set_short(outputStream* st, const sigset_t* set) {
1002   char buf[NUM_IMPORTANT_SIGS + 1];
1003   os::Posix::describe_signal_set_short(set, buf, sizeof(buf));
1004   st-&gt;print(&quot;%s&quot;, buf);
1005 }
1006 
1007 // Writes one-line description of a combination of sigaction.sa_flags into a user
1008 // provided buffer. Returns that buffer.
1009 const char* os::Posix::describe_sa_flags(int flags, char* buffer, size_t size) {
1010   char* p = buffer;
1011   size_t remaining = size;
1012   bool first = true;
1013   int idx = 0;
1014 
1015   assert(buffer, &quot;invalid argument&quot;);
1016 
1017   if (size == 0) {
1018     return buffer;
1019   }
1020 
1021   strncpy(buffer, &quot;none&quot;, size);
1022 
1023   const struct {
1024     // NB: i is an unsigned int here because SA_RESETHAND is on some
1025     // systems 0x80000000, which is implicitly unsigned.  Assignining
1026     // it to an int field would be an overflow in unsigned-to-signed
1027     // conversion.
1028     unsigned int i;
1029     const char* s;
1030   } flaginfo [] = {
1031     { SA_NOCLDSTOP, &quot;SA_NOCLDSTOP&quot; },
1032     { SA_ONSTACK,   &quot;SA_ONSTACK&quot;   },
1033     { SA_RESETHAND, &quot;SA_RESETHAND&quot; },
1034     { SA_RESTART,   &quot;SA_RESTART&quot;   },
1035     { SA_SIGINFO,   &quot;SA_SIGINFO&quot;   },
1036     { SA_NOCLDWAIT, &quot;SA_NOCLDWAIT&quot; },
1037     { SA_NODEFER,   &quot;SA_NODEFER&quot;   },
1038 #ifdef AIX
1039     { SA_ONSTACK,   &quot;SA_ONSTACK&quot;   },
1040     { SA_OLDSTYLE,  &quot;SA_OLDSTYLE&quot;  },
1041 #endif
1042     { 0, NULL }
1043   };
1044 
1045   for (idx = 0; flaginfo[idx].s &amp;&amp; remaining &gt; 1; idx++) {
1046     if (flags &amp; flaginfo[idx].i) {
1047       if (first) {
1048         jio_snprintf(p, remaining, &quot;%s&quot;, flaginfo[idx].s);
1049         first = false;
1050       } else {
1051         jio_snprintf(p, remaining, &quot;|%s&quot;, flaginfo[idx].s);
1052       }
1053       const size_t len = strlen(p);
1054       p += len;
1055       remaining -= len;
1056     }
1057   }
1058 
1059   buffer[size - 1] = &#39;\0&#39;;
1060 
1061   return buffer;
1062 }
1063 
1064 // Prints one-line description of a combination of sigaction.sa_flags.
1065 void os::Posix::print_sa_flags(outputStream* st, int flags) {
1066   char buffer[0x100];
1067   os::Posix::describe_sa_flags(flags, buffer, sizeof(buffer));
1068   st-&gt;print(&quot;%s&quot;, buffer);
1069 }
1070 
1071 // Helper function for os::Posix::print_siginfo_...():
1072 // return a textual description for signal code.
1073 struct enum_sigcode_desc_t {
1074   const char* s_name;
1075   const char* s_desc;
1076 };
1077 
1078 static bool get_signal_code_description(const siginfo_t* si, enum_sigcode_desc_t* out) {
1079 
1080   const struct {
1081     int sig; int code; const char* s_code; const char* s_desc;
1082   } t1 [] = {
1083     { SIGILL,  ILL_ILLOPC,   &quot;ILL_ILLOPC&quot;,   &quot;Illegal opcode.&quot; },
1084     { SIGILL,  ILL_ILLOPN,   &quot;ILL_ILLOPN&quot;,   &quot;Illegal operand.&quot; },
1085     { SIGILL,  ILL_ILLADR,   &quot;ILL_ILLADR&quot;,   &quot;Illegal addressing mode.&quot; },
1086     { SIGILL,  ILL_ILLTRP,   &quot;ILL_ILLTRP&quot;,   &quot;Illegal trap.&quot; },
1087     { SIGILL,  ILL_PRVOPC,   &quot;ILL_PRVOPC&quot;,   &quot;Privileged opcode.&quot; },
1088     { SIGILL,  ILL_PRVREG,   &quot;ILL_PRVREG&quot;,   &quot;Privileged register.&quot; },
1089     { SIGILL,  ILL_COPROC,   &quot;ILL_COPROC&quot;,   &quot;Coprocessor error.&quot; },
1090     { SIGILL,  ILL_BADSTK,   &quot;ILL_BADSTK&quot;,   &quot;Internal stack error.&quot; },
1091 #if defined(IA64) &amp;&amp; defined(LINUX)
1092     { SIGILL,  ILL_BADIADDR, &quot;ILL_BADIADDR&quot;, &quot;Unimplemented instruction address&quot; },
1093     { SIGILL,  ILL_BREAK,    &quot;ILL_BREAK&quot;,    &quot;Application Break instruction&quot; },
1094 #endif
1095     { SIGFPE,  FPE_INTDIV,   &quot;FPE_INTDIV&quot;,   &quot;Integer divide by zero.&quot; },
1096     { SIGFPE,  FPE_INTOVF,   &quot;FPE_INTOVF&quot;,   &quot;Integer overflow.&quot; },
1097     { SIGFPE,  FPE_FLTDIV,   &quot;FPE_FLTDIV&quot;,   &quot;Floating-point divide by zero.&quot; },
1098     { SIGFPE,  FPE_FLTOVF,   &quot;FPE_FLTOVF&quot;,   &quot;Floating-point overflow.&quot; },
1099     { SIGFPE,  FPE_FLTUND,   &quot;FPE_FLTUND&quot;,   &quot;Floating-point underflow.&quot; },
1100     { SIGFPE,  FPE_FLTRES,   &quot;FPE_FLTRES&quot;,   &quot;Floating-point inexact result.&quot; },
1101     { SIGFPE,  FPE_FLTINV,   &quot;FPE_FLTINV&quot;,   &quot;Invalid floating-point operation.&quot; },
1102     { SIGFPE,  FPE_FLTSUB,   &quot;FPE_FLTSUB&quot;,   &quot;Subscript out of range.&quot; },
1103     { SIGSEGV, SEGV_MAPERR,  &quot;SEGV_MAPERR&quot;,  &quot;Address not mapped to object.&quot; },
1104     { SIGSEGV, SEGV_ACCERR,  &quot;SEGV_ACCERR&quot;,  &quot;Invalid permissions for mapped object.&quot; },
1105 #ifdef AIX
1106     // no explanation found what keyerr would be
1107     { SIGSEGV, SEGV_KEYERR,  &quot;SEGV_KEYERR&quot;,  &quot;key error&quot; },
1108 #endif
1109 #if defined(IA64) &amp;&amp; !defined(AIX)
1110     { SIGSEGV, SEGV_PSTKOVF, &quot;SEGV_PSTKOVF&quot;, &quot;Paragraph stack overflow&quot; },
1111 #endif
1112 #if defined(__sparc) &amp;&amp; defined(SOLARIS)
1113 // define Solaris Sparc M7 ADI SEGV signals
1114 #if !defined(SEGV_ACCADI)
1115 #define SEGV_ACCADI 3
1116 #endif
1117     { SIGSEGV, SEGV_ACCADI,  &quot;SEGV_ACCADI&quot;,  &quot;ADI not enabled for mapped object.&quot; },
1118 #if !defined(SEGV_ACCDERR)
1119 #define SEGV_ACCDERR 4
1120 #endif
1121     { SIGSEGV, SEGV_ACCDERR, &quot;SEGV_ACCDERR&quot;, &quot;ADI disrupting exception.&quot; },
1122 #if !defined(SEGV_ACCPERR)
1123 #define SEGV_ACCPERR 5
1124 #endif
1125     { SIGSEGV, SEGV_ACCPERR, &quot;SEGV_ACCPERR&quot;, &quot;ADI precise exception.&quot; },
1126 #endif // defined(__sparc) &amp;&amp; defined(SOLARIS)
1127     { SIGBUS,  BUS_ADRALN,   &quot;BUS_ADRALN&quot;,   &quot;Invalid address alignment.&quot; },
1128     { SIGBUS,  BUS_ADRERR,   &quot;BUS_ADRERR&quot;,   &quot;Nonexistent physical address.&quot; },
1129     { SIGBUS,  BUS_OBJERR,   &quot;BUS_OBJERR&quot;,   &quot;Object-specific hardware error.&quot; },
1130     { SIGTRAP, TRAP_BRKPT,   &quot;TRAP_BRKPT&quot;,   &quot;Process breakpoint.&quot; },
1131     { SIGTRAP, TRAP_TRACE,   &quot;TRAP_TRACE&quot;,   &quot;Process trace trap.&quot; },
1132     { SIGCHLD, CLD_EXITED,   &quot;CLD_EXITED&quot;,   &quot;Child has exited.&quot; },
1133     { SIGCHLD, CLD_KILLED,   &quot;CLD_KILLED&quot;,   &quot;Child has terminated abnormally and did not create a core file.&quot; },
1134     { SIGCHLD, CLD_DUMPED,   &quot;CLD_DUMPED&quot;,   &quot;Child has terminated abnormally and created a core file.&quot; },
1135     { SIGCHLD, CLD_TRAPPED,  &quot;CLD_TRAPPED&quot;,  &quot;Traced child has trapped.&quot; },
1136     { SIGCHLD, CLD_STOPPED,  &quot;CLD_STOPPED&quot;,  &quot;Child has stopped.&quot; },
1137     { SIGCHLD, CLD_CONTINUED,&quot;CLD_CONTINUED&quot;,&quot;Stopped child has continued.&quot; },
1138 #ifdef SIGPOLL
1139     { SIGPOLL, POLL_OUT,     &quot;POLL_OUT&quot;,     &quot;Output buffers available.&quot; },
1140     { SIGPOLL, POLL_MSG,     &quot;POLL_MSG&quot;,     &quot;Input message available.&quot; },
1141     { SIGPOLL, POLL_ERR,     &quot;POLL_ERR&quot;,     &quot;I/O error.&quot; },
1142     { SIGPOLL, POLL_PRI,     &quot;POLL_PRI&quot;,     &quot;High priority input available.&quot; },
1143     { SIGPOLL, POLL_HUP,     &quot;POLL_HUP&quot;,     &quot;Device disconnected. [Option End]&quot; },
1144 #endif
1145     { -1, -1, NULL, NULL }
1146   };
1147 
1148   // Codes valid in any signal context.
1149   const struct {
1150     int code; const char* s_code; const char* s_desc;
1151   } t2 [] = {
1152     { SI_USER,      &quot;SI_USER&quot;,     &quot;Signal sent by kill().&quot; },
1153     { SI_QUEUE,     &quot;SI_QUEUE&quot;,    &quot;Signal sent by the sigqueue().&quot; },
1154     { SI_TIMER,     &quot;SI_TIMER&quot;,    &quot;Signal generated by expiration of a timer set by timer_settime().&quot; },
1155     { SI_ASYNCIO,   &quot;SI_ASYNCIO&quot;,  &quot;Signal generated by completion of an asynchronous I/O request.&quot; },
1156     { SI_MESGQ,     &quot;SI_MESGQ&quot;,    &quot;Signal generated by arrival of a message on an empty message queue.&quot; },
1157     // Linux specific
1158 #ifdef SI_TKILL
1159     { SI_TKILL,     &quot;SI_TKILL&quot;,    &quot;Signal sent by tkill (pthread_kill)&quot; },
1160 #endif
1161 #ifdef SI_DETHREAD
1162     { SI_DETHREAD,  &quot;SI_DETHREAD&quot;, &quot;Signal sent by execve() killing subsidiary threads&quot; },
1163 #endif
1164 #ifdef SI_KERNEL
1165     { SI_KERNEL,    &quot;SI_KERNEL&quot;,   &quot;Signal sent by kernel.&quot; },
1166 #endif
1167 #ifdef SI_SIGIO
1168     { SI_SIGIO,     &quot;SI_SIGIO&quot;,    &quot;Signal sent by queued SIGIO&quot; },
1169 #endif
1170 
1171 #ifdef AIX
1172     { SI_UNDEFINED, &quot;SI_UNDEFINED&quot;,&quot;siginfo contains partial information&quot; },
1173     { SI_EMPTY,     &quot;SI_EMPTY&quot;,    &quot;siginfo contains no useful information&quot; },
1174 #endif
1175 
1176 #ifdef __sun
1177     { SI_NOINFO,    &quot;SI_NOINFO&quot;,   &quot;No signal information&quot; },
1178     { SI_RCTL,      &quot;SI_RCTL&quot;,     &quot;kernel generated signal via rctl action&quot; },
1179     { SI_LWP,       &quot;SI_LWP&quot;,      &quot;Signal sent via lwp_kill&quot; },
1180 #endif
1181 
1182     { -1, NULL, NULL }
1183   };
1184 
1185   const char* s_code = NULL;
1186   const char* s_desc = NULL;
1187 
1188   for (int i = 0; t1[i].sig != -1; i ++) {
1189     if (t1[i].sig == si-&gt;si_signo &amp;&amp; t1[i].code == si-&gt;si_code) {
1190       s_code = t1[i].s_code;
1191       s_desc = t1[i].s_desc;
1192       break;
1193     }
1194   }
1195 
1196   if (s_code == NULL) {
1197     for (int i = 0; t2[i].s_code != NULL; i ++) {
1198       if (t2[i].code == si-&gt;si_code) {
1199         s_code = t2[i].s_code;
1200         s_desc = t2[i].s_desc;
1201       }
1202     }
1203   }
1204 
1205   if (s_code == NULL) {
1206     out-&gt;s_name = &quot;unknown&quot;;
1207     out-&gt;s_desc = &quot;unknown&quot;;
1208     return false;
1209   }
1210 
1211   out-&gt;s_name = s_code;
1212   out-&gt;s_desc = s_desc;
1213 
1214   return true;
1215 }
1216 
1217 bool os::signal_sent_by_kill(const void* siginfo) {
1218   const siginfo_t* const si = (const siginfo_t*)siginfo;
1219   return si-&gt;si_code == SI_USER || si-&gt;si_code == SI_QUEUE
1220 #ifdef SI_TKILL
1221          || si-&gt;si_code == SI_TKILL
1222 #endif
1223   ;
1224 }
1225 
1226 void os::print_siginfo(outputStream* os, const void* si0) {
1227 
1228   const siginfo_t* const si = (const siginfo_t*) si0;
1229 
1230   char buf[20];
1231   os-&gt;print(&quot;siginfo:&quot;);
1232 
1233   if (!si) {
1234     os-&gt;print(&quot; &lt;null&gt;&quot;);
1235     return;
1236   }
1237 
1238   const int sig = si-&gt;si_signo;
1239 
1240   os-&gt;print(&quot; si_signo: %d (%s)&quot;, sig, os::Posix::get_signal_name(sig, buf, sizeof(buf)));
1241 
1242   enum_sigcode_desc_t ed;
1243   get_signal_code_description(si, &amp;ed);
1244   os-&gt;print(&quot;, si_code: %d (%s)&quot;, si-&gt;si_code, ed.s_name);
1245 
1246   if (si-&gt;si_errno) {
1247     os-&gt;print(&quot;, si_errno: %d&quot;, si-&gt;si_errno);
1248   }
1249 
1250   // Output additional information depending on the signal code.
1251 
1252   // Note: Many implementations lump si_addr, si_pid, si_uid etc. together as unions,
1253   // so it depends on the context which member to use. For synchronous error signals,
1254   // we print si_addr, unless the signal was sent by another process or thread, in
1255   // which case we print out pid or tid of the sender.
1256   if (signal_sent_by_kill(si)) {
1257     const pid_t pid = si-&gt;si_pid;
1258     os-&gt;print(&quot;, si_pid: %ld&quot;, (long) pid);
1259     if (IS_VALID_PID(pid)) {
1260       const pid_t me = getpid();
1261       if (me == pid) {
1262         os-&gt;print(&quot; (current process)&quot;);
1263       }
1264     } else {
1265       os-&gt;print(&quot; (invalid)&quot;);
1266     }
1267     os-&gt;print(&quot;, si_uid: %ld&quot;, (long) si-&gt;si_uid);
1268     if (sig == SIGCHLD) {
1269       os-&gt;print(&quot;, si_status: %d&quot;, si-&gt;si_status);
1270     }
1271   } else if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||
1272              sig == SIGTRAP || sig == SIGFPE) {
1273     os-&gt;print(&quot;, si_addr: &quot; PTR_FORMAT, p2i(si-&gt;si_addr));
1274 #ifdef SIGPOLL
1275   } else if (sig == SIGPOLL) {
1276     os-&gt;print(&quot;, si_band: %ld&quot;, si-&gt;si_band);
1277 #endif
1278   }
1279 
1280 }
1281 
1282 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1283   OSThread* osthread = thread-&gt;osthread();
1284   if (osthread) {
1285 #if defined (SOLARIS)
1286     // Note: we cannot use pthread_kill on Solaris - not because
1287     // its missing, but because we do not have the pthread_t id.
1288     int status = thr_kill(osthread-&gt;thread_id(), sig);
1289 #else
1290     int status = pthread_kill(osthread-&gt;pthread_id(), sig);
1291 #endif
1292     if (status == 0) {
1293       Events::log(Thread::current(), &quot;sent signal %d to Thread &quot; INTPTR_FORMAT &quot; because %s.&quot;,
1294                   sig, p2i(thread), reason);
1295       return true;
1296     }
1297   }
1298   return false;
1299 }
1300 
1301 int os::Posix::unblock_thread_signal_mask(const sigset_t *set) {
1302   return pthread_sigmask(SIG_UNBLOCK, set, NULL);
1303 }
1304 
1305 address os::Posix::ucontext_get_pc(const ucontext_t* ctx) {
1306 #if defined(AIX)
1307    return Aix::ucontext_get_pc(ctx);
1308 #elif defined(BSD)
1309    return Bsd::ucontext_get_pc(ctx);
1310 #elif defined(LINUX)
1311    return Linux::ucontext_get_pc(ctx);
1312 #elif defined(SOLARIS)
1313    return Solaris::ucontext_get_pc(ctx);
1314 #else
1315    VMError::report_and_die(&quot;unimplemented ucontext_get_pc&quot;);
1316 #endif
1317 }
1318 
1319 void os::Posix::ucontext_set_pc(ucontext_t* ctx, address pc) {
1320 #if defined(AIX)
1321    Aix::ucontext_set_pc(ctx, pc);
1322 #elif defined(BSD)
1323    Bsd::ucontext_set_pc(ctx, pc);
1324 #elif defined(LINUX)
1325    Linux::ucontext_set_pc(ctx, pc);
1326 #elif defined(SOLARIS)
1327    Solaris::ucontext_set_pc(ctx, pc);
1328 #else
1329    VMError::report_and_die(&quot;unimplemented ucontext_get_pc&quot;);
1330 #endif
1331 }
1332 
1333 char* os::Posix::describe_pthread_attr(char* buf, size_t buflen, const pthread_attr_t* attr) {
1334   size_t stack_size = 0;
1335   size_t guard_size = 0;
1336   int detachstate = 0;
1337   pthread_attr_getstacksize(attr, &amp;stack_size);
1338   pthread_attr_getguardsize(attr, &amp;guard_size);
1339   // Work around linux NPTL implementation error, see also os::create_thread() in os_linux.cpp.
1340   LINUX_ONLY(stack_size -= guard_size);
1341   pthread_attr_getdetachstate(attr, &amp;detachstate);
1342   jio_snprintf(buf, buflen, &quot;stacksize: &quot; SIZE_FORMAT &quot;k, guardsize: &quot; SIZE_FORMAT &quot;k, %s&quot;,
1343     stack_size / 1024, guard_size / 1024,
1344     (detachstate == PTHREAD_CREATE_DETACHED ? &quot;detached&quot; : &quot;joinable&quot;));
1345   return buf;
1346 }
1347 
1348 char* os::Posix::realpath(const char* filename, char* outbuf, size_t outbuflen) {
1349 
1350   if (filename == NULL || outbuf == NULL || outbuflen &lt; 1) {
1351     assert(false, &quot;os::Posix::realpath: invalid arguments.&quot;);
1352     errno = EINVAL;
1353     return NULL;
1354   }
1355 
1356   char* result = NULL;
1357 
1358   // This assumes platform realpath() is implemented according to POSIX.1-2008.
1359   // POSIX.1-2008 allows to specify NULL for the output buffer, in which case
1360   // output buffer is dynamically allocated and must be ::free()&#39;d by the caller.
1361   char* p = ::realpath(filename, NULL);
1362   if (p != NULL) {
1363     if (strlen(p) &lt; outbuflen) {
1364       strcpy(outbuf, p);
1365       result = outbuf;
1366     } else {
1367       errno = ENAMETOOLONG;
1368     }
1369     ::free(p); // *not* os::free
1370   } else {
1371     // Fallback for platforms struggling with modern Posix standards (AIX 5.3, 6.1). If realpath
1372     // returns EINVAL, this may indicate that realpath is not POSIX.1-2008 compatible and
1373     // that it complains about the NULL we handed down as user buffer.
1374     // In this case, use the user provided buffer but at least check whether realpath caused
1375     // a memory overwrite.
1376     if (errno == EINVAL) {
1377       outbuf[outbuflen - 1] = &#39;\0&#39;;
1378       p = ::realpath(filename, outbuf);
1379       if (p != NULL) {
1380         guarantee(outbuf[outbuflen - 1] == &#39;\0&#39;, &quot;realpath buffer overwrite detected.&quot;);
1381         result = p;
1382       }
1383     }
1384   }
1385   return result;
1386 
1387 }
1388 
1389 int os::stat(const char *path, struct stat *sbuf) {
1390   return ::stat(path, sbuf);
1391 }
1392 
1393 char * os::native_path(char *path) {
1394   return path;
1395 }
1396 
1397 bool os::same_files(const char* file1, const char* file2) {
1398   if (strcmp(file1, file2) == 0) {
1399     return true;
1400   }
1401 
1402   bool is_same = false;
1403   struct stat st1;
1404   struct stat st2;
1405 
1406   if (os::stat(file1, &amp;st1) &lt; 0) {
1407     return false;
1408   }
1409 
1410   if (os::stat(file2, &amp;st2) &lt; 0) {
1411     return false;
1412   }
1413 
1414   if (st1.st_dev == st2.st_dev &amp;&amp; st1.st_ino == st2.st_ino) {
1415     // same files
1416     is_same = true;
1417   }
1418   return is_same;
1419 }
1420 
1421 // Check minimum allowable stack sizes for thread creation and to initialize
1422 // the java system classes, including StackOverflowError - depends on page
1423 // size.
1424 // The space needed for frames during startup is platform dependent. It
1425 // depends on word size, platform calling conventions, C frame layout and
1426 // interpreter/C1/C2 design decisions. Therefore this is given in a
1427 // platform (os/cpu) dependent constant.
1428 // To this, space for guard mechanisms is added, which depends on the
1429 // page size which again depends on the concrete system the VM is running
1430 // on. Space for libc guard pages is not included in this size.
1431 jint os::Posix::set_minimum_stack_sizes() {
1432   size_t os_min_stack_allowed = SOLARIS_ONLY(thr_min_stack()) NOT_SOLARIS(PTHREAD_STACK_MIN);
1433 
1434   _java_thread_min_stack_allowed = _java_thread_min_stack_allowed +
1435                                    JavaThread::stack_guard_zone_size() +
1436                                    JavaThread::stack_shadow_zone_size();
1437 
1438   _java_thread_min_stack_allowed = align_up(_java_thread_min_stack_allowed, vm_page_size());
1439   _java_thread_min_stack_allowed = MAX2(_java_thread_min_stack_allowed, os_min_stack_allowed);
1440 
1441   size_t stack_size_in_bytes = ThreadStackSize * K;
1442   if (stack_size_in_bytes != 0 &amp;&amp;
1443       stack_size_in_bytes &lt; _java_thread_min_stack_allowed) {
1444     // The &#39;-Xss&#39; and &#39;-XX:ThreadStackSize=N&#39; options both set
1445     // ThreadStackSize so we go with &quot;Java thread stack size&quot; instead
1446     // of &quot;ThreadStackSize&quot; to be more friendly.
1447     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
1448                   &quot;Specify at least &quot; SIZE_FORMAT &quot;k&quot;,
1449                   _java_thread_min_stack_allowed / K);
1450     return JNI_ERR;
1451   }
1452 
1453   // Make the stack size a multiple of the page size so that
1454   // the yellow/red zones can be guarded.
1455   JavaThread::set_stack_size_at_create(align_up(stack_size_in_bytes, vm_page_size()));
1456 
1457   // Reminder: a compiler thread is a Java thread.
1458   _compiler_thread_min_stack_allowed = _compiler_thread_min_stack_allowed +
1459                                        JavaThread::stack_guard_zone_size() +
1460                                        JavaThread::stack_shadow_zone_size();
1461 
1462   _compiler_thread_min_stack_allowed = align_up(_compiler_thread_min_stack_allowed, vm_page_size());
1463   _compiler_thread_min_stack_allowed = MAX2(_compiler_thread_min_stack_allowed, os_min_stack_allowed);
1464 
1465   stack_size_in_bytes = CompilerThreadStackSize * K;
1466   if (stack_size_in_bytes != 0 &amp;&amp;
1467       stack_size_in_bytes &lt; _compiler_thread_min_stack_allowed) {
1468     tty-&gt;print_cr(&quot;\nThe CompilerThreadStackSize specified is too small. &quot;
1469                   &quot;Specify at least &quot; SIZE_FORMAT &quot;k&quot;,
1470                   _compiler_thread_min_stack_allowed / K);
1471     return JNI_ERR;
1472   }
1473 
1474   _vm_internal_thread_min_stack_allowed = align_up(_vm_internal_thread_min_stack_allowed, vm_page_size());
1475   _vm_internal_thread_min_stack_allowed = MAX2(_vm_internal_thread_min_stack_allowed, os_min_stack_allowed);
1476 
1477   stack_size_in_bytes = VMThreadStackSize * K;
1478   if (stack_size_in_bytes != 0 &amp;&amp;
1479       stack_size_in_bytes &lt; _vm_internal_thread_min_stack_allowed) {
1480     tty-&gt;print_cr(&quot;\nThe VMThreadStackSize specified is too small. &quot;
1481                   &quot;Specify at least &quot; SIZE_FORMAT &quot;k&quot;,
1482                   _vm_internal_thread_min_stack_allowed / K);
1483     return JNI_ERR;
1484   }
1485   return JNI_OK;
1486 }
1487 
1488 // Called when creating the thread.  The minimum stack sizes have already been calculated
1489 size_t os::Posix::get_initial_stack_size(ThreadType thr_type, size_t req_stack_size) {
1490   size_t stack_size;
1491   if (req_stack_size == 0) {
1492     stack_size = default_stack_size(thr_type);
1493   } else {
1494     stack_size = req_stack_size;
1495   }
1496 
1497   switch (thr_type) {
1498   case os::java_thread:
1499     // Java threads use ThreadStackSize which default value can be
1500     // changed with the flag -Xss
1501     if (req_stack_size == 0 &amp;&amp; JavaThread::stack_size_at_create() &gt; 0) {
1502       // no requested size and we have a more specific default value
1503       stack_size = JavaThread::stack_size_at_create();
1504     }
1505     stack_size = MAX2(stack_size,
1506                       _java_thread_min_stack_allowed);
1507     break;
1508   case os::compiler_thread:
1509     if (req_stack_size == 0 &amp;&amp; CompilerThreadStackSize &gt; 0) {
1510       // no requested size and we have a more specific default value
1511       stack_size = (size_t)(CompilerThreadStackSize * K);
1512     }
1513     stack_size = MAX2(stack_size,
1514                       _compiler_thread_min_stack_allowed);
1515     break;
1516   case os::vm_thread:
1517   case os::pgc_thread:
1518   case os::cgc_thread:
1519   case os::watcher_thread:
1520   default:  // presume the unknown thr_type is a VM internal
1521     if (req_stack_size == 0 &amp;&amp; VMThreadStackSize &gt; 0) {
1522       // no requested size and we have a more specific default value
1523       stack_size = (size_t)(VMThreadStackSize * K);
1524     }
1525 
1526     stack_size = MAX2(stack_size,
1527                       _vm_internal_thread_min_stack_allowed);
1528     break;
1529   }
1530 
1531   // pthread_attr_setstacksize() may require that the size be rounded up to the OS page size.
1532   // Be careful not to round up to 0. Align down in that case.
1533   if (stack_size &lt;= SIZE_MAX - vm_page_size()) {
1534     stack_size = align_up(stack_size, vm_page_size());
1535   } else {
1536     stack_size = align_down(stack_size, vm_page_size());
1537   }
1538 
1539   return stack_size;
1540 }
1541 
1542 bool os::Posix::is_root(uid_t uid){
1543     return ROOT_UID == uid;
1544 }
1545 
1546 bool os::Posix::matches_effective_uid_or_root(uid_t uid) {
1547     return is_root(uid) || geteuid() == uid;
1548 }
1549 
1550 bool os::Posix::matches_effective_uid_and_gid_or_root(uid_t uid, gid_t gid) {
1551     return is_root(uid) || (geteuid() == uid &amp;&amp; getegid() == gid);
1552 }
1553 
1554 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
1555 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
1556 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
1557 
1558 os::ThreadCrashProtection::ThreadCrashProtection() {
1559 }
1560 
1561 /*
1562  * See the caveats for this class in os_posix.hpp
1563  * Protects the callback call so that SIGSEGV / SIGBUS jumps back into this
1564  * method and returns false. If none of the signals are raised, returns true.
1565  * The callback is supposed to provide the method that should be protected.
1566  */
1567 bool os::ThreadCrashProtection::call(os::CrashProtectionCallback&amp; cb) {
1568   sigset_t saved_sig_mask;
1569 
1570   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
1571 
1572   _protected_thread = Thread::current_or_null();
1573   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
1574 
1575   // we cannot rely on sigsetjmp/siglongjmp to save/restore the signal mask
1576   // since on at least some systems (OS X) siglongjmp will restore the mask
1577   // for the process, not the thread
1578   pthread_sigmask(0, NULL, &amp;saved_sig_mask);
1579   if (sigsetjmp(_jmpbuf, 0) == 0) {
1580     // make sure we can see in the signal handler that we have crash protection
1581     // installed
1582     _crash_protection = this;
1583     cb.call();
1584     // and clear the crash protection
1585     _crash_protection = NULL;
1586     _protected_thread = NULL;
1587     Thread::muxRelease(&amp;_crash_mux);
1588     return true;
1589   }
1590   // this happens when we siglongjmp() back
1591   pthread_sigmask(SIG_SETMASK, &amp;saved_sig_mask, NULL);
1592   _crash_protection = NULL;
1593   _protected_thread = NULL;
1594   Thread::muxRelease(&amp;_crash_mux);
1595   return false;
1596 }
1597 
1598 void os::ThreadCrashProtection::restore() {
1599   assert(_crash_protection != NULL, &quot;must have crash protection&quot;);
1600   siglongjmp(_jmpbuf, 1);
1601 }
1602 
1603 void os::ThreadCrashProtection::check_crash_protection(int sig,
1604     Thread* thread) {
1605 
1606   if (thread != NULL &amp;&amp;
1607       thread == _protected_thread &amp;&amp;
1608       _crash_protection != NULL) {
1609 
1610     if (sig == SIGSEGV || sig == SIGBUS) {
1611       _crash_protection-&gt;restore();
1612     }
1613   }
1614 }
1615 
1616 // Shared clock/time and other supporting routines for pthread_mutex/cond
1617 // initialization. This is enabled on Solaris but only some of the clock/time
1618 // functionality is actually used there.
1619 
1620 // Shared condattr object for use with relative timed-waits. Will be associated
1621 // with CLOCK_MONOTONIC if available to avoid issues with time-of-day changes,
1622 // but otherwise whatever default is used by the platform - generally the
1623 // time-of-day clock.
1624 static pthread_condattr_t _condAttr[1];
1625 
1626 // Shared mutexattr to explicitly set the type to PTHREAD_MUTEX_NORMAL as not
1627 // all systems (e.g. FreeBSD) map the default to &quot;normal&quot;.
1628 static pthread_mutexattr_t _mutexAttr[1];
1629 
1630 // common basic initialization that is always supported
1631 static void pthread_init_common(void) {
1632   int status;
1633   if ((status = pthread_condattr_init(_condAttr)) != 0) {
1634     fatal(&quot;pthread_condattr_init: %s&quot;, os::strerror(status));
1635   }
1636   if ((status = pthread_mutexattr_init(_mutexAttr)) != 0) {
1637     fatal(&quot;pthread_mutexattr_init: %s&quot;, os::strerror(status));
1638   }
1639   if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
1640     fatal(&quot;pthread_mutexattr_settype: %s&quot;, os::strerror(status));
1641   }
1642   // Solaris has it&#39;s own PlatformMutex, distinct from the one for POSIX.
1643   NOT_SOLARIS(os::PlatformMutex::init();)
1644 }
1645 
1646 #ifndef SOLARIS
1647 sigset_t sigs;
1648 struct sigaction sigact[NSIG];
1649 
1650 struct sigaction* os::Posix::get_preinstalled_handler(int sig) {
1651   if (sigismember(&amp;sigs, sig)) {
1652     return &amp;sigact[sig];
1653   }
1654   return NULL;
1655 }
1656 
1657 void os::Posix::save_preinstalled_handler(int sig, struct sigaction&amp; oldAct) {
1658   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
1659   sigact[sig] = oldAct;
1660   sigaddset(&amp;sigs, sig);
1661 }
1662 #endif
1663 
1664 // Not all POSIX types and API&#39;s are available on all notionally &quot;posix&quot;
1665 // platforms. If we have build-time support then we will check for actual
1666 // runtime support via dlopen/dlsym lookup. This allows for running on an
1667 // older OS version compared to the build platform. But if there is no
1668 // build time support then there cannot be any runtime support as we do not
1669 // know what the runtime types would be (for example clockid_t might be an
1670 // int or int64_t).
1671 //
1672 #ifdef SUPPORTS_CLOCK_MONOTONIC
1673 
1674 // This means we have clockid_t, clock_gettime et al and CLOCK_MONOTONIC
1675 
1676 int (*os::Posix::_clock_gettime)(clockid_t, struct timespec *) = NULL;
1677 int (*os::Posix::_clock_getres)(clockid_t, struct timespec *) = NULL;
1678 
1679 static int (*_pthread_condattr_setclock)(pthread_condattr_t *, clockid_t) = NULL;
1680 
1681 static bool _use_clock_monotonic_condattr = false;
1682 
1683 // Determine what POSIX API&#39;s are present and do appropriate
1684 // configuration.
1685 void os::Posix::init(void) {
1686 
1687   // NOTE: no logging available when this is called. Put logging
1688   // statements in init_2().
1689 
1690   // 1. Check for CLOCK_MONOTONIC support.
1691 
1692   void* handle = NULL;
1693 
1694   // For linux we need librt, for other OS we can find
1695   // this function in regular libc.
1696 #ifdef NEEDS_LIBRT
1697   // We do dlopen&#39;s in this particular order due to bug in linux
1698   // dynamic loader (see 6348968) leading to crash on exit.
1699   handle = dlopen(&quot;librt.so.1&quot;, RTLD_LAZY);
1700   if (handle == NULL) {
1701     handle = dlopen(&quot;librt.so&quot;, RTLD_LAZY);
1702   }
1703 #endif
1704 
1705   if (handle == NULL) {
1706     handle = RTLD_DEFAULT;
1707   }
1708 
1709   int (*clock_getres_func)(clockid_t, struct timespec*) =
1710     (int(*)(clockid_t, struct timespec*))dlsym(handle, &quot;clock_getres&quot;);
1711   int (*clock_gettime_func)(clockid_t, struct timespec*) =
1712     (int(*)(clockid_t, struct timespec*))dlsym(handle, &quot;clock_gettime&quot;);
1713   if (clock_getres_func != NULL &amp;&amp; clock_gettime_func != NULL) {
1714     // We assume that if both clock_gettime and clock_getres support
1715     // CLOCK_MONOTONIC then the OS provides true high-res monotonic clock.
1716     struct timespec res;
1717     struct timespec tp;
1718     if (clock_getres_func(CLOCK_MONOTONIC, &amp;res) == 0 &amp;&amp;
1719         clock_gettime_func(CLOCK_MONOTONIC, &amp;tp) == 0) {
1720       // Yes, monotonic clock is supported.
1721       _clock_gettime = clock_gettime_func;
1722       _clock_getres = clock_getres_func;
1723     } else {
1724 #ifdef NEEDS_LIBRT
1725       // Close librt if there is no monotonic clock.
1726       if (handle != RTLD_DEFAULT) {
1727         dlclose(handle);
1728       }
1729 #endif
1730     }
1731   }
1732 
1733   // 2. Check for pthread_condattr_setclock support.
1734 
1735   // libpthread is already loaded.
1736   int (*condattr_setclock_func)(pthread_condattr_t*, clockid_t) =
1737     (int (*)(pthread_condattr_t*, clockid_t))dlsym(RTLD_DEFAULT,
1738                                                    &quot;pthread_condattr_setclock&quot;);
1739   if (condattr_setclock_func != NULL) {
1740     _pthread_condattr_setclock = condattr_setclock_func;
1741   }
1742 
1743   // Now do general initialization.
1744 
1745   pthread_init_common();
1746 
1747 #ifndef SOLARIS
1748   int status;
1749   if (_pthread_condattr_setclock != NULL &amp;&amp; _clock_gettime != NULL) {
1750     if ((status = _pthread_condattr_setclock(_condAttr, CLOCK_MONOTONIC)) != 0) {
1751       if (status == EINVAL) {
1752         _use_clock_monotonic_condattr = false;
1753         warning(&quot;Unable to use monotonic clock with relative timed-waits&quot; \
1754                 &quot; - changes to the time-of-day clock may have adverse affects&quot;);
1755       } else {
1756         fatal(&quot;pthread_condattr_setclock: %s&quot;, os::strerror(status));
1757       }
1758     } else {
1759       _use_clock_monotonic_condattr = true;
1760     }
1761   }
1762 #endif // !SOLARIS
1763 
1764 }
1765 
1766 void os::Posix::init_2(void) {
1767 #ifndef SOLARIS
1768   log_info(os)(&quot;Use of CLOCK_MONOTONIC is%s supported&quot;,
1769                (_clock_gettime != NULL ? &quot;&quot; : &quot; not&quot;));
1770   log_info(os)(&quot;Use of pthread_condattr_setclock is%s supported&quot;,
1771                (_pthread_condattr_setclock != NULL ? &quot;&quot; : &quot; not&quot;));
1772   log_info(os)(&quot;Relative timed-wait using pthread_cond_timedwait is associated with %s&quot;,
1773                _use_clock_monotonic_condattr ? &quot;CLOCK_MONOTONIC&quot; : &quot;the default clock&quot;);
1774   sigemptyset(&amp;sigs);
1775 #endif // !SOLARIS
1776 }
1777 
1778 #else // !SUPPORTS_CLOCK_MONOTONIC
1779 
1780 void os::Posix::init(void) {
1781   pthread_init_common();
1782 }
1783 
1784 void os::Posix::init_2(void) {
1785 #ifndef SOLARIS
1786   log_info(os)(&quot;Use of CLOCK_MONOTONIC is not supported&quot;);
1787   log_info(os)(&quot;Use of pthread_condattr_setclock is not supported&quot;);
1788   log_info(os)(&quot;Relative timed-wait using pthread_cond_timedwait is associated with the default clock&quot;);
1789   sigemptyset(&amp;sigs);
1790 #endif // !SOLARIS
1791 }
1792 
1793 #endif // SUPPORTS_CLOCK_MONOTONIC
1794 
1795 // Utility to convert the given timeout to an absolute timespec
1796 // (based on the appropriate clock) to use with pthread_cond_timewait,
1797 // and sem_timedwait().
1798 // The clock queried here must be the clock used to manage the
1799 // timeout of the condition variable or semaphore.
1800 //
1801 // The passed in timeout value is either a relative time in nanoseconds
1802 // or an absolute time in milliseconds. A relative timeout will be
1803 // associated with CLOCK_MONOTONIC if available, unless the real-time clock
1804 // is explicitly requested; otherwise, or if absolute,
1805 // the default time-of-day clock will be used.
1806 
1807 // Given time is a 64-bit value and the time_t used in the timespec is
1808 // sometimes a signed-32-bit value we have to watch for overflow if times
1809 // way in the future are given. Further on Solaris versions
1810 // prior to 10 there is a restriction (see cond_timedwait) that the specified
1811 // number of seconds, in abstime, is less than current_time + 100000000.
1812 // As it will be over 20 years before &quot;now + 100000000&quot; will overflow we can
1813 // ignore overflow and just impose a hard-limit on seconds using the value
1814 // of &quot;now + 100000000&quot;. This places a limit on the timeout of about 3.17
1815 // years from &quot;now&quot;.
1816 //
1817 #define MAX_SECS 100000000
1818 
1819 // Calculate a new absolute time that is &quot;timeout&quot; nanoseconds from &quot;now&quot;.
1820 // &quot;unit&quot; indicates the unit of &quot;now_part_sec&quot; (may be nanos or micros depending
1821 // on which clock API is being used).
1822 static void calc_rel_time(timespec* abstime, jlong timeout, jlong now_sec,
1823                           jlong now_part_sec, jlong unit) {
1824   time_t max_secs = now_sec + MAX_SECS;
1825 
1826   jlong seconds = timeout / NANOUNITS;
1827   timeout %= NANOUNITS; // remaining nanos
1828 
1829   if (seconds &gt;= MAX_SECS) {
1830     // More seconds than we can add, so pin to max_secs.
1831     abstime-&gt;tv_sec = max_secs;
1832     abstime-&gt;tv_nsec = 0;
1833   } else {
1834     abstime-&gt;tv_sec = now_sec  + seconds;
1835     long nanos = (now_part_sec * (NANOUNITS / unit)) + timeout;
1836     if (nanos &gt;= NANOUNITS) { // overflow
1837       abstime-&gt;tv_sec += 1;
1838       nanos -= NANOUNITS;
1839     }
1840     abstime-&gt;tv_nsec = nanos;
1841   }
1842 }
1843 
1844 // Unpack the given deadline in milliseconds since the epoch, into the given timespec.
1845 // The current time in seconds is also passed in to enforce an upper bound as discussed above.
1846 // This is only used with gettimeofday, when clock_gettime is not available.
1847 static void unpack_abs_time(timespec* abstime, jlong deadline, jlong now_sec) {
1848   time_t max_secs = now_sec + MAX_SECS;
1849 
1850   jlong seconds = deadline / MILLIUNITS;
1851   jlong millis = deadline % MILLIUNITS;
1852 
1853   if (seconds &gt;= max_secs) {
1854     // Absolute seconds exceeds allowed max, so pin to max_secs.
1855     abstime-&gt;tv_sec = max_secs;
1856     abstime-&gt;tv_nsec = 0;
1857   } else {
1858     abstime-&gt;tv_sec = seconds;
1859     abstime-&gt;tv_nsec = millis_to_nanos(millis);
1860   }
1861 }
1862 
1863 static jlong millis_to_nanos_bounded(jlong millis) {
1864   // We have to watch for overflow when converting millis to nanos,
1865   // but if millis is that large then we will end up limiting to
1866   // MAX_SECS anyway, so just do that here.
1867   if (millis / MILLIUNITS &gt; MAX_SECS) {
1868     millis = jlong(MAX_SECS) * MILLIUNITS;
1869   }
1870   return millis_to_nanos(millis);
1871 }
1872 
1873 static void to_abstime(timespec* abstime, jlong timeout,
1874                        bool isAbsolute, bool isRealtime) {
1875   DEBUG_ONLY(int max_secs = MAX_SECS;)
1876 
1877   if (timeout &lt; 0) {
1878     timeout = 0;
1879   }
1880 
1881 #ifdef SUPPORTS_CLOCK_MONOTONIC
1882 
1883   clockid_t clock = CLOCK_MONOTONIC;
1884   // need to ensure we have a runtime check for clock_gettime support
1885   if (!isAbsolute &amp;&amp; os::Posix::supports_monotonic_clock()) {
1886     if (!_use_clock_monotonic_condattr || isRealtime) {
1887       clock = CLOCK_REALTIME;
1888     }
1889     struct timespec now;
1890     int status = os::Posix::clock_gettime(clock, &amp;now);
1891     assert_status(status == 0, status, &quot;clock_gettime&quot;);
1892     calc_rel_time(abstime, timeout, now.tv_sec, now.tv_nsec, NANOUNITS);
1893     DEBUG_ONLY(max_secs += now.tv_sec;)
1894   } else {
1895 
1896 #else
1897 
1898   { // Match the block scope.
1899 
1900 #endif // SUPPORTS_CLOCK_MONOTONIC
1901 
1902     // Time-of-day clock is all we can reliably use.
1903     struct timeval now;
1904     int status = gettimeofday(&amp;now, NULL);
1905     assert_status(status == 0, errno, &quot;gettimeofday&quot;);
1906     if (isAbsolute) {
1907       unpack_abs_time(abstime, timeout, now.tv_sec);
1908     } else {
1909       calc_rel_time(abstime, timeout, now.tv_sec, now.tv_usec, MICROUNITS);
1910     }
1911     DEBUG_ONLY(max_secs += now.tv_sec;)
1912   }
1913 
1914   assert(abstime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
1915   assert(abstime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
1916   assert(abstime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
1917   assert(abstime-&gt;tv_nsec &lt; NANOUNITS, &quot;tv_nsec &gt;= NANOUNITS&quot;);
1918 }
1919 
1920 // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
1921 // real-time (time-of-day) clock. Used by PosixSemaphore.
1922 void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
1923   to_abstime(abstime, millis_to_nanos_bounded(millis),
1924              false /* not absolute */,
1925              true  /* use real-time clock */);
1926 }
1927 
1928 // Shared pthread_mutex/cond based PlatformEvent implementation.
1929 // Not currently usable by Solaris.
1930 
1931 #ifndef SOLARIS
1932 
1933 // PlatformEvent
1934 //
1935 // Assumption:
1936 //    Only one parker can exist on an event, which is why we allocate
1937 //    them per-thread. Multiple unparkers can coexist.
1938 //
1939 // _event serves as a restricted-range semaphore.
1940 //   -1 : thread is blocked, i.e. there is a waiter
1941 //    0 : neutral: thread is running or ready,
1942 //        could have been signaled after a wait started
1943 //    1 : signaled - thread is running or ready
1944 //
1945 //    Having three states allows for some detection of bad usage - see
1946 //    comments on unpark().
1947 
1948 os::PlatformEvent::PlatformEvent() {
1949   int status = pthread_cond_init(_cond, _condAttr);
1950   assert_status(status == 0, status, &quot;cond_init&quot;);
1951   status = pthread_mutex_init(_mutex, _mutexAttr);
1952   assert_status(status == 0, status, &quot;mutex_init&quot;);
1953   _event   = 0;
1954   _nParked = 0;
1955 }
1956 
1957 void os::PlatformEvent::park() {       // AKA &quot;down()&quot;
1958   // Transitions for _event:
1959   //   -1 =&gt; -1 : illegal
1960   //    1 =&gt;  0 : pass - return immediately
1961   //    0 =&gt; -1 : block; then set _event to 0 before returning
1962 
1963   // Invariant: Only the thread associated with the PlatformEvent
1964   // may call park().
1965   assert(_nParked == 0, &quot;invariant&quot;);
1966 
1967   int v;
1968 
1969   // atomically decrement _event
1970   for (;;) {
1971     v = _event;
1972     if (Atomic::cmpxchg(&amp;_event, v, v - 1) == v) break;
1973   }
1974   guarantee(v &gt;= 0, &quot;invariant&quot;);
1975 
1976   if (v == 0) { // Do this the hard way by blocking ...
1977     int status = pthread_mutex_lock(_mutex);
1978     assert_status(status == 0, status, &quot;mutex_lock&quot;);
1979     guarantee(_nParked == 0, &quot;invariant&quot;);
1980     ++_nParked;
1981     while (_event &lt; 0) {
1982       // OS-level &quot;spurious wakeups&quot; are ignored
1983       status = pthread_cond_wait(_cond, _mutex);
1984       assert_status(status == 0, status, &quot;cond_wait&quot;);
1985     }
1986     --_nParked;
1987 
1988     _event = 0;
1989     status = pthread_mutex_unlock(_mutex);
1990     assert_status(status == 0, status, &quot;mutex_unlock&quot;);
1991     // Paranoia to ensure our locked and lock-free paths interact
1992     // correctly with each other.
1993     OrderAccess::fence();
1994   }
1995   guarantee(_event &gt;= 0, &quot;invariant&quot;);
1996 }
1997 
1998 int os::PlatformEvent::park(jlong millis) {
1999   // Transitions for _event:
2000   //   -1 =&gt; -1 : illegal
2001   //    1 =&gt;  0 : pass - return immediately
2002   //    0 =&gt; -1 : block; then set _event to 0 before returning
2003 
2004   // Invariant: Only the thread associated with the Event/PlatformEvent
2005   // may call park().
2006   assert(_nParked == 0, &quot;invariant&quot;);
2007 
2008   int v;
2009   // atomically decrement _event
2010   for (;;) {
2011     v = _event;
2012     if (Atomic::cmpxchg(&amp;_event, v, v - 1) == v) break;
2013   }
2014   guarantee(v &gt;= 0, &quot;invariant&quot;);
2015 
2016   if (v == 0) { // Do this the hard way by blocking ...
2017     struct timespec abst;
2018     to_abstime(&amp;abst, millis_to_nanos_bounded(millis), false, false);
2019 
2020     int ret = OS_TIMEOUT;
2021     int status = pthread_mutex_lock(_mutex);
2022     assert_status(status == 0, status, &quot;mutex_lock&quot;);
2023     guarantee(_nParked == 0, &quot;invariant&quot;);
2024     ++_nParked;
2025 
2026     while (_event &lt; 0) {
2027       status = pthread_cond_timedwait(_cond, _mutex, &amp;abst);
2028       assert_status(status == 0 || status == ETIMEDOUT,
2029                     status, &quot;cond_timedwait&quot;);
2030       // OS-level &quot;spurious wakeups&quot; are ignored unless the archaic
2031       // FilterSpuriousWakeups is set false. That flag should be obsoleted.
2032       if (!FilterSpuriousWakeups) break;
2033       if (status == ETIMEDOUT) break;
2034     }
2035     --_nParked;
2036 
2037     if (_event &gt;= 0) {
2038       ret = OS_OK;
2039     }
2040 
2041     _event = 0;
2042     status = pthread_mutex_unlock(_mutex);
2043     assert_status(status == 0, status, &quot;mutex_unlock&quot;);
2044     // Paranoia to ensure our locked and lock-free paths interact
2045     // correctly with each other.
2046     OrderAccess::fence();
2047     return ret;
2048   }
2049   return OS_OK;
2050 }
2051 
2052 void os::PlatformEvent::unpark() {
2053   // Transitions for _event:
2054   //    0 =&gt; 1 : just return
2055   //    1 =&gt; 1 : just return
2056   //   -1 =&gt; either 0 or 1; must signal target thread
2057   //         That is, we can safely transition _event from -1 to either
2058   //         0 or 1.
2059   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
2060   //
2061   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
2062   // that it will take two back-to-back park() calls for the owning
2063   // thread to block. This has the benefit of forcing a spurious return
2064   // from the first park() call after an unpark() call which will help
2065   // shake out uses of park() and unpark() without checking state conditions
2066   // properly. This spurious return doesn&#39;t manifest itself in any user code
2067   // but only in the correctly written condition checking loops of ObjectMonitor,
2068   // Mutex/Monitor, Thread::muxAcquire and JavaThread::sleep
2069 
2070   if (Atomic::xchg(&amp;_event, 1) &gt;= 0) return;
2071 
2072   int status = pthread_mutex_lock(_mutex);
2073   assert_status(status == 0, status, &quot;mutex_lock&quot;);
2074   int anyWaiters = _nParked;
2075   assert(anyWaiters == 0 || anyWaiters == 1, &quot;invariant&quot;);
2076   status = pthread_mutex_unlock(_mutex);
2077   assert_status(status == 0, status, &quot;mutex_unlock&quot;);
2078 
2079   // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
2080   // This is safe and avoids a common class of futile wakeups.  In rare
2081   // circumstances this can cause a thread to return prematurely from
2082   // cond_{timed}wait() but the spurious wakeup is benign and the victim
2083   // will simply re-test the condition and re-park itself.
2084   // This provides particular benefit if the underlying platform does not
2085   // provide wait morphing.
2086 
2087   if (anyWaiters != 0) {
2088     status = pthread_cond_signal(_cond);
2089     assert_status(status == 0, status, &quot;cond_signal&quot;);
2090   }
2091 }
2092 
2093 // JSR166 support
2094 
2095  os::PlatformParker::PlatformParker() {
2096   int status;
2097   status = pthread_cond_init(&amp;_cond[REL_INDEX], _condAttr);
2098   assert_status(status == 0, status, &quot;cond_init rel&quot;);
2099   status = pthread_cond_init(&amp;_cond[ABS_INDEX], NULL);
2100   assert_status(status == 0, status, &quot;cond_init abs&quot;);
2101   status = pthread_mutex_init(_mutex, _mutexAttr);
2102   assert_status(status == 0, status, &quot;mutex_init&quot;);
2103   _cur_index = -1; // mark as unused
2104 }
2105 
2106 // Parker::park decrements count if &gt; 0, else does a condvar wait.  Unpark
2107 // sets count to 1 and signals condvar.  Only one thread ever waits
2108 // on the condvar. Contention seen when trying to park implies that someone
2109 // is unparking you, so don&#39;t wait. And spurious returns are fine, so there
2110 // is no need to track notifications.
2111 
2112 void Parker::park(bool isAbsolute, jlong time) {
2113 
2114   // Optional fast-path check:
2115   // Return immediately if a permit is available.
2116   // We depend on Atomic::xchg() having full barrier semantics
2117   // since we are doing a lock-free update to _counter.
2118   if (Atomic::xchg(&amp;_counter, 0) &gt; 0) return;
2119 
2120   Thread* thread = Thread::current();
2121   assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);
2122   JavaThread *jt = (JavaThread *)thread;
2123 
2124   // Optional optimization -- avoid state transitions if there&#39;s
2125   // an interrupt pending.
2126   if (jt-&gt;is_interrupted(false)) {
2127     return;
2128   }
2129 
2130   // Next, demultiplex/decode time arguments
2131   struct timespec absTime;
2132   if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0)) { // don&#39;t wait at all
2133     return;
2134   }
2135   if (time &gt; 0) {
2136     to_abstime(&amp;absTime, time, isAbsolute, false);
2137   }
2138 
2139   // Enter safepoint region
2140   // Beware of deadlocks such as 6317397.
2141   // The per-thread Parker:: mutex is a classic leaf-lock.
2142   // In particular a thread must never block on the Threads_lock while
2143   // holding the Parker:: mutex.  If safepoints are pending both the
2144   // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
2145   ThreadBlockInVM tbivm(jt);
2146 
2147   // Can&#39;t access interrupt state now that we are _thread_blocked. If we&#39;ve
2148   // been interrupted since we checked above then _counter will be &gt; 0.
2149 
2150   // Don&#39;t wait if cannot get lock since interference arises from
2151   // unparking.
2152   if (pthread_mutex_trylock(_mutex) != 0) {
2153     return;
2154   }
2155 
2156   int status;
2157   if (_counter &gt; 0)  { // no wait needed
2158     _counter = 0;
2159     status = pthread_mutex_unlock(_mutex);
2160     assert_status(status == 0, status, &quot;invariant&quot;);
2161     // Paranoia to ensure our locked and lock-free paths interact
2162     // correctly with each other and Java-level accesses.
2163     OrderAccess::fence();
2164     return;
2165   }
2166 
2167   OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
2168   jt-&gt;set_suspend_equivalent();
2169   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2170 
2171   assert(_cur_index == -1, &quot;invariant&quot;);
2172   if (time == 0) {
2173     _cur_index = REL_INDEX; // arbitrary choice when not timed
2174     status = pthread_cond_wait(&amp;_cond[_cur_index], _mutex);
2175     assert_status(status == 0, status, &quot;cond_timedwait&quot;);
2176   }
2177   else {
2178     _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;
2179     status = pthread_cond_timedwait(&amp;_cond[_cur_index], _mutex, &amp;absTime);
2180     assert_status(status == 0 || status == ETIMEDOUT,
2181                   status, &quot;cond_timedwait&quot;);
2182   }
2183   _cur_index = -1;
2184 
2185   _counter = 0;
2186   status = pthread_mutex_unlock(_mutex);
2187   assert_status(status == 0, status, &quot;invariant&quot;);
2188   // Paranoia to ensure our locked and lock-free paths interact
2189   // correctly with each other and Java-level accesses.
2190   OrderAccess::fence();
2191 
2192   // If externally suspended while waiting, re-suspend
2193   if (jt-&gt;handle_special_suspend_equivalent_condition()) {
2194     jt-&gt;java_suspend_self();
2195   }
2196 }
2197 
2198 void Parker::unpark() {
2199   int status = pthread_mutex_lock(_mutex);
2200   assert_status(status == 0, status, &quot;invariant&quot;);
2201   const int s = _counter;
2202   _counter = 1;
2203   // must capture correct index before unlocking
2204   int index = _cur_index;
2205   status = pthread_mutex_unlock(_mutex);
2206   assert_status(status == 0, status, &quot;invariant&quot;);
2207 
2208   // Note that we signal() *after* dropping the lock for &quot;immortal&quot; Events.
2209   // This is safe and avoids a common class of futile wakeups.  In rare
2210   // circumstances this can cause a thread to return prematurely from
2211   // cond_{timed}wait() but the spurious wakeup is benign and the victim
2212   // will simply re-test the condition and re-park itself.
2213   // This provides particular benefit if the underlying platform does not
2214   // provide wait morphing.
2215 
2216   if (s &lt; 1 &amp;&amp; index != -1) {
2217     // thread is definitely parked
2218     status = pthread_cond_signal(&amp;_cond[index]);
2219     assert_status(status == 0, status, &quot;invariant&quot;);
2220   }
2221 }
2222 
2223 // Platform Mutex/Monitor implementation
2224 
2225 #if PLATFORM_MONITOR_IMPL_INDIRECT
2226 
2227 os::PlatformMutex::Mutex::Mutex() : _next(NULL) {
2228   int status = pthread_mutex_init(&amp;_mutex, _mutexAttr);
2229   assert_status(status == 0, status, &quot;mutex_init&quot;);
2230 }
2231 
2232 os::PlatformMutex::Mutex::~Mutex() {
2233   int status = pthread_mutex_destroy(&amp;_mutex);
2234   assert_status(status == 0, status, &quot;mutex_destroy&quot;);
2235 }
2236 
2237 pthread_mutex_t os::PlatformMutex::_freelist_lock;
2238 os::PlatformMutex::Mutex* os::PlatformMutex::_mutex_freelist = NULL;
2239 
2240 void os::PlatformMutex::init() {
2241   int status = pthread_mutex_init(&amp;_freelist_lock, _mutexAttr);
2242   assert_status(status == 0, status, &quot;freelist lock init&quot;);
2243 }
2244 
2245 struct os::PlatformMutex::WithFreeListLocked : public StackObj {
2246   WithFreeListLocked() {
2247     int status = pthread_mutex_lock(&amp;_freelist_lock);
2248     assert_status(status == 0, status, &quot;freelist lock&quot;);
2249   }
2250 
2251   ~WithFreeListLocked() {
2252     int status = pthread_mutex_unlock(&amp;_freelist_lock);
2253     assert_status(status == 0, status, &quot;freelist unlock&quot;);
2254   }
2255 };
2256 
2257 os::PlatformMutex::PlatformMutex() {
2258   {
2259     WithFreeListLocked wfl;
2260     _impl = _mutex_freelist;
2261     if (_impl != NULL) {
2262       _mutex_freelist = _impl-&gt;_next;
2263       _impl-&gt;_next = NULL;
2264       return;
2265     }
2266   }
2267   _impl = new Mutex();
2268 }
2269 
2270 os::PlatformMutex::~PlatformMutex() {
2271   WithFreeListLocked wfl;
2272   assert(_impl-&gt;_next == NULL, &quot;invariant&quot;);
2273   _impl-&gt;_next = _mutex_freelist;
2274   _mutex_freelist = _impl;
2275 }
2276 
2277 os::PlatformMonitor::Cond::Cond() : _next(NULL) {
2278   int status = pthread_cond_init(&amp;_cond, _condAttr);
2279   assert_status(status == 0, status, &quot;cond_init&quot;);
2280 }
2281 
2282 os::PlatformMonitor::Cond::~Cond() {
2283   int status = pthread_cond_destroy(&amp;_cond);
2284   assert_status(status == 0, status, &quot;cond_destroy&quot;);
2285 }
2286 
2287 os::PlatformMonitor::Cond* os::PlatformMonitor::_cond_freelist = NULL;
2288 
2289 os::PlatformMonitor::PlatformMonitor() {
2290   {
2291     WithFreeListLocked wfl;
2292     _impl = _cond_freelist;
2293     if (_impl != NULL) {
2294       _cond_freelist = _impl-&gt;_next;
2295       _impl-&gt;_next = NULL;
2296       return;
2297     }
2298   }
2299   _impl = new Cond();
2300 }
2301 
2302 os::PlatformMonitor::~PlatformMonitor() {
2303   WithFreeListLocked wfl;
2304   assert(_impl-&gt;_next == NULL, &quot;invariant&quot;);
2305   _impl-&gt;_next = _cond_freelist;
2306   _cond_freelist = _impl;
2307 }
2308 
2309 #else
2310 
2311 os::PlatformMutex::PlatformMutex() {
2312   int status = pthread_mutex_init(&amp;_mutex, _mutexAttr);
2313   assert_status(status == 0, status, &quot;mutex_init&quot;);
2314 }
2315 
2316 os::PlatformMutex::~PlatformMutex() {
2317   int status = pthread_mutex_destroy(&amp;_mutex);
2318   assert_status(status == 0, status, &quot;mutex_destroy&quot;);
2319 }
2320 
2321 os::PlatformMonitor::PlatformMonitor() {
2322   int status = pthread_cond_init(&amp;_cond, _condAttr);
2323   assert_status(status == 0, status, &quot;cond_init&quot;);
2324 }
2325 
2326 os::PlatformMonitor::~PlatformMonitor() {
2327   int status = pthread_cond_destroy(&amp;_cond);
2328   assert_status(status == 0, status, &quot;cond_destroy&quot;);
2329 }
2330 
2331 #endif // PLATFORM_MONITOR_IMPL_INDIRECT
2332 
2333 // Must already be locked
2334 int os::PlatformMonitor::wait(jlong millis) {
2335   assert(millis &gt;= 0, &quot;negative timeout&quot;);
2336   if (millis &gt; 0) {
2337     struct timespec abst;
2338     // We have to watch for overflow when converting millis to nanos,
2339     // but if millis is that large then we will end up limiting to
2340     // MAX_SECS anyway, so just do that here.
2341     if (millis / MILLIUNITS &gt; MAX_SECS) {
2342       millis = jlong(MAX_SECS) * MILLIUNITS;
2343     }
2344     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);
2345 
2346     int ret = OS_TIMEOUT;
2347     int status = pthread_cond_timedwait(cond(), mutex(), &amp;abst);
2348     assert_status(status == 0 || status == ETIMEDOUT,
2349                   status, &quot;cond_timedwait&quot;);
2350     if (status == 0) {
2351       ret = OS_OK;
2352     }
2353     return ret;
2354   } else {
2355     int status = pthread_cond_wait(cond(), mutex());
2356     assert_status(status == 0, status, &quot;cond_wait&quot;);
2357     return OS_OK;
2358   }
2359 }
2360 
2361 #endif // !SOLARIS
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/interp_masm.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;nativeInst_aarch64.hpp&quot;
  37 #include &quot;oops/compiledICHolder.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/vframeArray.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;vmreg_aarch64.inline.hpp&quot;
  44 #ifdef COMPILER1
  45 #include &quot;c1/c1_Runtime1.hpp&quot;
  46 #endif
  47 #if COMPILER2_OR_JVMCI
  48 #include &quot;adfiles/ad_aarch64.hpp&quot;
  49 #include &quot;opto/runtime.hpp&quot;
  50 #endif
  51 #if INCLUDE_JVMCI
  52 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  53 #endif
  54 
  55 #define __ masm-&gt;
  56 
  57 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  58 
  59 class SimpleRuntimeFrame {
  60 
  61   public:
  62 
  63   // Most of the runtime stubs have this simple frame layout.
  64   // This class exists to make the layout shared in one place.
  65   // Offsets are for compiler stack slots, which are jints.
  66   enum layout {
  67     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  68     // will override any oopMap setting for it. We must therefore force the layout
  69     // so that it agrees with the frame sender code.
  70     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  71     // frame::arg_reg_save_area_bytes == 0
  72     rbp_off = 0,
  73     rbp_off2,
  74     return_off, return_off2,
  75     framesize
  76   };
  77 };
  78 
  79 // FIXME -- this is used by C1
  80 class RegisterSaver {
  81  public:
  82   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
  83   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  84 
  85   // Offsets into the register save area
  86   // Used by deoptimization when it is managing result register
  87   // values on its own
  88 
  89   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  90   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  91   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  92   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  93   static int v0_offset_in_bytes(void)   { return 0; }
  94   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  95 
  96   // During deoptimization only the result registers need to be restored,
  97   // all the other values have already been extracted.
  98   static void restore_result_registers(MacroAssembler* masm);
  99 
 100     // Capture info about frame layout
 101   enum layout {
 102                 fpu_state_off = 0,
 103                 fpu_state_end = fpu_state_off + FPUStateSizeInWords - 1,
 104                 // The frame sender code expects that rfp will be in
 105                 // the &quot;natural&quot; place and will override any oopMap
 106                 // setting for it. We must therefore force the layout
 107                 // so that it agrees with the frame sender code.
 108                 r0_off = fpu_state_off + FPUStateSizeInWords,
 109                 rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,
 110                 return_off = rfp_off + RegisterImpl::max_slots_per_register,      // slot for return address
 111                 reg_save_size = return_off + RegisterImpl::max_slots_per_register};
 112 
 113 };
 114 
 115 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 116 #if COMPILER2_OR_JVMCI
 117   if (save_vectors) {
 118     // Save upper half of vector registers
 119     int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register /
 120                      VMRegImpl::slots_per_word;
 121     additional_frame_words += vect_words;
 122   }
 123 #else
 124   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 125 #endif
 126 
 127   int frame_size_in_bytes = align_up(additional_frame_words * wordSize +
 128                                      reg_save_size * BytesPerInt, 16);
 129   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 130   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 131   // The caller will allocate additional_frame_words
 132   int additional_frame_slots = additional_frame_words * wordSize / BytesPerInt;
 133   // CodeBlob frame size is in words.
 134   int frame_size_in_words = frame_size_in_bytes / wordSize;
 135   *total_frame_words = frame_size_in_words;
 136 
 137   // Save Integer and Float registers.
 138   __ enter();
 139   __ push_CPU_state(save_vectors);
 140 
 141   // Set an oopmap for the call site.  This oopmap will map all
 142   // oop-registers and debug-info registers as callee-saved.  This
 143   // will allow deoptimization at this safepoint to find all possible
 144   // debug-info recordings, as well as let GC find all oops.
 145 
 146   OopMapSet *oop_maps = new OopMapSet();
 147   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 148 
 149   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 150     Register r = as_Register(i);
 151     if (r &lt;= rfp &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {
 152       // SP offsets are in 4-byte words.
 153       // Register slots are 8 bytes wide, 32 floating-point registers.
 154       int sp_offset = RegisterImpl::max_slots_per_register * i +
 155                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;
 156       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 157                                 r-&gt;as_VMReg());
 158     }
 159   }
 160 
 161   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 162     FloatRegister r = as_FloatRegister(i);
 163     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :
 164                                    (FloatRegisterImpl::save_slots_per_register * i);
 165     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 166                               r-&gt;as_VMReg());
 167   }
 168 
 169   return oop_map;
 170 }
 171 
 172 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 173 #ifndef COMPILER2
 174   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 175 #endif
 176   __ pop_CPU_state(restore_vectors);
 177   __ leave();
 178 }
 179 
 180 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 181 
 182   // Just restore result register. Only used by deoptimization. By
 183   // now any callee save register that needs to be restored to a c2
 184   // caller of the deoptee has been extracted into the vframeArray
 185   // and will be stuffed into the c2i adapter we create for later
 186   // restoration so only result registers need to be restored here.
 187 
 188   // Restore fp result register
 189   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 190   // Restore integer result register
 191   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 192 
 193   // Pop all of the register save are off the stack
 194   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 195 }
 196 
 197 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 198 // 8 bytes vector registers are saved by default on AArch64.
 199 bool SharedRuntime::is_wide_vector(int size) {
 200   return size &gt; 8;
 201 }
 202 
 203 size_t SharedRuntime::trampoline_size() {
 204   return 16;
 205 }
 206 
 207 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 208   __ mov(rscratch1, destination);
 209   __ br(rscratch1);
 210 }
 211 
 212 // The java_calling_convention describes stack locations as ideal slots on
 213 // a frame with no abi restrictions. Since we must observe abi restrictions
 214 // (like the placement of the register window) the slots must be biased by
 215 // the following value.
 216 static int reg2offset_in(VMReg r) {
 217   // Account for saved rfp and lr
 218   // This should really be in_preserve_stack_slots
 219   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 220 }
 221 
 222 static int reg2offset_out(VMReg r) {
 223   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 224 }
 225 
 226 // ---------------------------------------------------------------------------
 227 // Read the array of BasicTypes from a signature, and compute where the
 228 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 229 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 230 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 231 // as framesizes are fixed.
 232 // VMRegImpl::stack0 refers to the first slot 0(sp).
 233 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 234 // up to RegisterImpl::number_of_registers) are the 64-bit
 235 // integer registers.
 236 
 237 // Note: the INPUTS in sig_bt are in units of Java argument words,
 238 // which are 64-bit.  The OUTPUTS are in 32-bit units.
 239 
 240 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 241 // By skipping the first C ABI register we can call non-static jni
 242 // methods with small numbers of arguments without having to shuffle
 243 // the arguments at all. Since we control the java ABI we ought to at
 244 // least get some advantage out of it.
 245 
 246 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 247                                            VMRegPair *regs,
 248                                            int total_args_passed,
 249                                            int is_outgoing) {
 250 
 251   // Create the mapping between argument positions and
 252   // registers.
 253   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 254     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5, j_rarg6, j_rarg7
 255   };
 256   static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 257     j_farg0, j_farg1, j_farg2, j_farg3,
 258     j_farg4, j_farg5, j_farg6, j_farg7
 259   };
 260 
 261 
 262   uint int_args = 0;
 263   uint fp_args = 0;
 264   uint stk_args = 0; // inc by 2 each time
 265 
 266   for (int i = 0; i &lt; total_args_passed; i++) {
 267     switch (sig_bt[i]) {
 268     case T_BOOLEAN:
 269     case T_CHAR:
 270     case T_BYTE:
 271     case T_SHORT:
 272     case T_INT:
 273       if (int_args &lt; Argument::n_int_register_parameters_j) {
 274         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 275       } else {
 276         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 277         stk_args += 2;
 278       }
 279       break;
 280     case T_VOID:
 281       // halves of T_LONG or T_DOUBLE
 282       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 283       regs[i].set_bad();
 284       break;
 285     case T_LONG:
 286       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 287       // fall through
 288     case T_OBJECT:
 289     case T_ARRAY:
 290     case T_ADDRESS:
 291       if (int_args &lt; Argument::n_int_register_parameters_j) {
 292         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 293       } else {
 294         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 295         stk_args += 2;
 296       }
 297       break;
 298     case T_FLOAT:
 299       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 300         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 301       } else {
 302         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 303         stk_args += 2;
 304       }
 305       break;
 306     case T_DOUBLE:
 307       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 308       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 309         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 310       } else {
 311         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 312         stk_args += 2;
 313       }
 314       break;
 315     default:
 316       ShouldNotReachHere();
 317       break;
 318     }
 319   }
 320 
 321   return align_up(stk_args, 2);
 322 }
 323 
 324 // Patch the callers callsite with entry to compiled code if it exists.
 325 static void patch_callers_callsite(MacroAssembler *masm) {
 326   Label L;
 327   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 328   __ cbz(rscratch1, L);
 329 
 330   __ enter();
 331   __ push_CPU_state();
 332 
 333   // VM needs caller&#39;s callsite
 334   // VM needs target method
 335   // This needs to be a long call since we will relocate this adapter to
 336   // the codeBuffer and it may not reach
 337 
 338 #ifndef PRODUCT
 339   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 340 #endif
 341 
 342   __ mov(c_rarg0, rmethod);
 343   __ mov(c_rarg1, lr);
 344   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 345   __ blr(rscratch1);
 346   __ maybe_isb();
 347 
 348   __ pop_CPU_state();
 349   // restore sp
 350   __ leave();
 351   __ bind(L);
 352 }
 353 
 354 static void gen_c2i_adapter(MacroAssembler *masm,
 355                             int total_args_passed,
 356                             int comp_args_on_stack,
 357                             const BasicType *sig_bt,
 358                             const VMRegPair *regs,
 359                             Label&amp; skip_fixup) {
 360   // Before we get into the guts of the C2I adapter, see if we should be here
 361   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 362   // interpreter, which means the caller made a static call to get here
 363   // (vcalls always get a compiled target if there is one).  Check for a
 364   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 365   patch_callers_callsite(masm);
 366 
 367   __ bind(skip_fixup);
 368 
 369   int words_pushed = 0;
 370 
 371   // Since all args are passed on the stack, total_args_passed *
 372   // Interpreter::stackElementSize is the space we need.
 373 
 374   int extraspace = total_args_passed * Interpreter::stackElementSize;
 375 
 376   __ mov(r13, sp);
 377 
 378   // stack is aligned, keep it that way
 379   extraspace = align_up(extraspace, 2*wordSize);
 380 
 381   if (extraspace)
 382     __ sub(sp, sp, extraspace);
 383 
 384   // Now write the args into the outgoing interpreter space
 385   for (int i = 0; i &lt; total_args_passed; i++) {
 386     if (sig_bt[i] == T_VOID) {
 387       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 388       continue;
 389     }
 390 
 391     // offset to start parameters
 392     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 393     int next_off = st_off - Interpreter::stackElementSize;
 394 
 395     // Say 4 args:
 396     // i   st_off
 397     // 0   32 T_LONG
 398     // 1   24 T_VOID
 399     // 2   16 T_OBJECT
 400     // 3    8 T_BOOL
 401     // -    0 return address
 402     //
 403     // However to make thing extra confusing. Because we can fit a long/double in
 404     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 405     // leaves one slot empty and only stores to a single slot. In this case the
 406     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 407 
 408     VMReg r_1 = regs[i].first();
 409     VMReg r_2 = regs[i].second();
 410     if (!r_1-&gt;is_valid()) {
 411       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 412       continue;
 413     }
 414     if (r_1-&gt;is_stack()) {
 415       // memory to memory use rscratch1
 416       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size
 417                     + extraspace
 418                     + words_pushed * wordSize);
 419       if (!r_2-&gt;is_valid()) {
 420         // sign extend??
 421         __ ldrw(rscratch1, Address(sp, ld_off));
 422         __ str(rscratch1, Address(sp, st_off));
 423 
 424       } else {
 425 
 426         __ ldr(rscratch1, Address(sp, ld_off));
 427 
 428         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 429         // T_DOUBLE and T_LONG use two slots in the interpreter
 430         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 431           // ld_off == LSW, ld_off+wordSize == MSW
 432           // st_off == MSW, next_off == LSW
 433           __ str(rscratch1, Address(sp, next_off));
 434 #ifdef ASSERT
 435           // Overwrite the unused slot with known junk
 436           __ mov(rscratch1, 0xdeadffffdeadaaaaul);
 437           __ str(rscratch1, Address(sp, st_off));
 438 #endif /* ASSERT */
 439         } else {
 440           __ str(rscratch1, Address(sp, st_off));
 441         }
 442       }
 443     } else if (r_1-&gt;is_Register()) {
 444       Register r = r_1-&gt;as_Register();
 445       if (!r_2-&gt;is_valid()) {
 446         // must be only an int (or less ) so move only 32bits to slot
 447         // why not sign extend??
 448         __ str(r, Address(sp, st_off));
 449       } else {
 450         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 451         // T_DOUBLE and T_LONG use two slots in the interpreter
 452         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 453           // long/double in gpr
 454 #ifdef ASSERT
 455           // Overwrite the unused slot with known junk
 456           __ mov(rscratch1, 0xdeadffffdeadaaabul);
 457           __ str(rscratch1, Address(sp, st_off));
 458 #endif /* ASSERT */
 459           __ str(r, Address(sp, next_off));
 460         } else {
 461           __ str(r, Address(sp, st_off));
 462         }
 463       }
 464     } else {
 465       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 466       if (!r_2-&gt;is_valid()) {
 467         // only a float use just part of the slot
 468         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));
 469       } else {
 470 #ifdef ASSERT
 471         // Overwrite the unused slot with known junk
 472         __ mov(rscratch1, 0xdeadffffdeadaaacul);
 473         __ str(rscratch1, Address(sp, st_off));
 474 #endif /* ASSERT */
 475         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));
 476       }
 477     }
 478   }
 479 
 480   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 481 
 482   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 483   __ br(rscratch1);
 484 }
 485 
 486 
 487 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 488                                     int total_args_passed,
 489                                     int comp_args_on_stack,
 490                                     const BasicType *sig_bt,
 491                                     const VMRegPair *regs) {
 492 
 493   // Note: r13 contains the senderSP on entry. We must preserve it since
 494   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 495   // code goes non-entrant while we get args ready.
 496 
 497   // In addition we use r13 to locate all the interpreter args because
 498   // we must align the stack to 16 bytes.
 499 
 500   // Adapters are frameless.
 501 
 502   // An i2c adapter is frameless because the *caller* frame, which is
 503   // interpreted, routinely repairs its own esp (from
 504   // interpreter_frame_last_sp), even if a callee has modified the
 505   // stack pointer.  It also recalculates and aligns sp.
 506 
 507   // A c2i adapter is frameless because the *callee* frame, which is
 508   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 509   // which is set up via the senderSP register).
 510 
 511   // In other words, if *either* the caller or callee is interpreted, we can
 512   // get the stack pointer repaired after a call.
 513 
 514   // This is why c2i and i2c adapters cannot be indefinitely composed.
 515   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 516   // both caller and callee would be compiled methods, and neither would
 517   // clean up the stack pointer changes performed by the two adapters.
 518   // If this happens, control eventually transfers back to the compiled
 519   // caller, but with an uncorrected stack, causing delayed havoc.
 520 
 521   if (VerifyAdapterCalls &amp;&amp;
 522       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 523 #if 0
 524     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 525     //  assert(Interpreter::contains($return_addr) ||
 526     //         StubRoutines::contains($return_addr),
 527     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 528     __ block_comment(&quot;verify_i2c { &quot;);
 529     Label L_ok;
 530     if (Interpreter::code() != NULL)
 531       range_check(masm, rax, r11,
 532                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 533                   L_ok);
 534     if (StubRoutines::code1() != NULL)
 535       range_check(masm, rax, r11,
 536                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 537                   L_ok);
 538     if (StubRoutines::code2() != NULL)
 539       range_check(masm, rax, r11,
 540                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 541                   L_ok);
 542     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 543     __ block_comment(msg);
 544     __ stop(msg);
 545     __ bind(L_ok);
 546     __ block_comment(&quot;} verify_i2ce &quot;);
 547 #endif
 548   }
 549 
 550   // Cut-out for having no stack args.
 551   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
 552   if (comp_args_on_stack) {
 553     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);
 554     __ andr(sp, rscratch1, -16);
 555   }
 556 
 557   // Will jump to the compiled code just as if compiled code was doing it.
 558   // Pre-load the register-jump target early, to schedule it better.
 559   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 560 
 561 #if INCLUDE_JVMCI
 562   if (EnableJVMCI || UseAOT) {
 563     // check if this call should be routed towards a specific entry point
 564     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 565     Label no_alternative_target;
 566     __ cbz(rscratch2, no_alternative_target);
 567     __ mov(rscratch1, rscratch2);
 568     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 569     __ bind(no_alternative_target);
 570   }
 571 #endif // INCLUDE_JVMCI
 572 
 573   // Now generate the shuffle code.
 574   for (int i = 0; i &lt; total_args_passed; i++) {
 575     if (sig_bt[i] == T_VOID) {
 576       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 577       continue;
 578     }
 579 
 580     // Pick up 0, 1 or 2 words from SP+offset.
 581 
 582     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
 583             &quot;scrambled load targets?&quot;);
 584     // Load in argument order going down.
 585     int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;
 586     // Point to interpreter value (vs. tag)
 587     int next_off = ld_off - Interpreter::stackElementSize;
 588     //
 589     //
 590     //
 591     VMReg r_1 = regs[i].first();
 592     VMReg r_2 = regs[i].second();
 593     if (!r_1-&gt;is_valid()) {
 594       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 595       continue;
 596     }
 597     if (r_1-&gt;is_stack()) {
 598       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 599       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;
 600       if (!r_2-&gt;is_valid()) {
 601         // sign extend???
 602         __ ldrsw(rscratch2, Address(esp, ld_off));
 603         __ str(rscratch2, Address(sp, st_off));
 604       } else {
 605         //
 606         // We are using two optoregs. This can be either T_OBJECT,
 607         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 608         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 609         // So we must adjust where to pick up the data to match the
 610         // interpreter.
 611         //
 612         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 613         // are accessed as negative so LSW is at LOW address
 614 
 615         // ld_off is MSW so get LSW
 616         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 617                            next_off : ld_off;
 618         __ ldr(rscratch2, Address(esp, offset));
 619         // st_off is LSW (i.e. reg.first())
 620         __ str(rscratch2, Address(sp, st_off));
 621       }
 622     } else if (r_1-&gt;is_Register()) {  // Register argument
 623       Register r = r_1-&gt;as_Register();
 624       if (r_2-&gt;is_valid()) {
 625         //
 626         // We are using two VMRegs. This can be either T_OBJECT,
 627         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 628         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 629         // So we must adjust where to pick up the data to match the
 630         // interpreter.
 631 
 632         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 633                            next_off : ld_off;
 634 
 635         // this can be a misaligned move
 636         __ ldr(r, Address(esp, offset));
 637       } else {
 638         // sign extend and use a full word?
 639         __ ldrw(r, Address(esp, ld_off));
 640       }
 641     } else {
 642       if (!r_2-&gt;is_valid()) {
 643         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));
 644       } else {
 645         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 646       }
 647     }
 648   }
 649 
 650   // 6243940 We might end up in handle_wrong_method if
 651   // the callee is deoptimized as we race thru here. If that
 652   // happens we don&#39;t want to take a safepoint because the
 653   // caller frame will look interpreted and arguments are now
 654   // &quot;compiled&quot; so it is much better to make this transition
 655   // invisible to the stack walking code. Unfortunately if
 656   // we try and find the callee by normal means a safepoint
 657   // is possible. So we stash the desired callee in the thread
 658   // and the vm will find there should this case occur.
 659 
 660   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 661 
 662   __ br(rscratch1);
 663 }
 664 
 665 // ---------------------------------------------------------------
 666 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 667                                                             int total_args_passed,
 668                                                             int comp_args_on_stack,
 669                                                             const BasicType *sig_bt,
 670                                                             const VMRegPair *regs,
 671                                                             AdapterFingerPrint* fingerprint) {
 672   address i2c_entry = __ pc();
 673 
 674   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 675 
 676   address c2i_unverified_entry = __ pc();
 677   Label skip_fixup;
 678 
 679   Label ok;
 680 
 681   Register holder = rscratch2;
 682   Register receiver = j_rarg0;
 683   Register tmp = r10;  // A call-clobbered register not used for arg passing
 684 
 685   // -------------------------------------------------------------------------
 686   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 687   // to the interpreter.  The args start out packed in the compiled layout.  They
 688   // need to be unpacked into the interpreter layout.  This will almost always
 689   // require some stack space.  We grow the current (compiled) stack, then repack
 690   // the args.  We  finally end in a jump to the generic interpreter entry point.
 691   // On exit from the interpreter, the interpreter will restore our SP (lest the
 692   // compiled code, which relys solely on SP and not FP, get sick).
 693 
 694   {
 695     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 696     __ load_klass(rscratch1, receiver);
 697     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 698     __ cmp(rscratch1, tmp);
 699     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 700     __ br(Assembler::EQ, ok);
 701     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 702 
 703     __ bind(ok);
 704     // Method might have been compiled since the call site was patched to
 705     // interpreted; if that is the case treat it as a miss so we can get
 706     // the call site corrected.
 707     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 708     __ cbz(rscratch1, skip_fixup);
 709     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 710     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 711   }
 712 
 713   address c2i_entry = __ pc();
 714 
 715   // Class initialization barrier for static methods
 716   address c2i_no_clinit_check_entry = NULL;
 717   if (VM_Version::supports_fast_class_init_checks()) {
 718     Label L_skip_barrier;
 719 
 720     { // Bypass the barrier for non-static methods
 721       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));
 722       __ andsw(zr, rscratch1, JVM_ACC_STATIC);
 723       __ br(Assembler::EQ, L_skip_barrier); // non-static
 724     }
 725 
 726     __ load_method_holder(rscratch2, rmethod);
 727     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
 728     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 729 
 730     __ bind(L_skip_barrier);
 731     c2i_no_clinit_check_entry = __ pc();
 732   }
 733 
 734   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 735 
 736   __ flush();
 737   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);
 738 }
 739 
 740 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 741                                          VMRegPair *regs,
 742                                          VMRegPair *regs2,
 743                                          int total_args_passed) {
 744   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 745 
 746 // We return the amount of VMRegImpl stack slots we need to reserve for all
 747 // the arguments NOT counting out_preserve_stack_slots.
 748 
 749     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 750       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 751     };
 752     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 753       c_farg0, c_farg1, c_farg2, c_farg3,
 754       c_farg4, c_farg5, c_farg6, c_farg7
 755     };
 756 
 757     uint int_args = 0;
 758     uint fp_args = 0;
 759     uint stk_args = 0; // inc by 2 each time
 760 
 761     for (int i = 0; i &lt; total_args_passed; i++) {
 762       switch (sig_bt[i]) {
 763       case T_BOOLEAN:
 764       case T_CHAR:
 765       case T_BYTE:
 766       case T_SHORT:
 767       case T_INT:
 768         if (int_args &lt; Argument::n_int_register_parameters_c) {
 769           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 770         } else {
 771           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 772           stk_args += 2;
 773         }
 774         break;
 775       case T_LONG:
 776         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 777         // fall through
 778       case T_OBJECT:
 779       case T_ARRAY:
 780       case T_ADDRESS:
 781       case T_METADATA:
 782         if (int_args &lt; Argument::n_int_register_parameters_c) {
 783           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 784         } else {
 785           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 786           stk_args += 2;
 787         }
 788         break;
 789       case T_FLOAT:
 790         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 791           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 792         } else {
 793           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 794           stk_args += 2;
 795         }
 796         break;
 797       case T_DOUBLE:
 798         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 799         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 800           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 801         } else {
 802           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 803           stk_args += 2;
 804         }
 805         break;
 806       case T_VOID: // Halves of longs and doubles
 807         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 808         regs[i].set_bad();
 809         break;
 810       default:
 811         ShouldNotReachHere();
 812         break;
 813       }
 814     }
 815 
 816   return stk_args;
 817 }
 818 
 819 // On 64 bit we will store integer like items to the stack as
 820 // 64 bits items (sparc abi) even though java would only store
 821 // 32bits for a parameter. On 32bit it will simply be 32 bits
 822 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
 823 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 824   if (src.first()-&gt;is_stack()) {
 825     if (dst.first()-&gt;is_stack()) {
 826       // stack to stack
 827       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 828       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 829     } else {
 830       // stack to reg
 831       __ ldrsw(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
 832     }
 833   } else if (dst.first()-&gt;is_stack()) {
 834     // reg to stack
 835     // Do we really have to sign extend???
 836     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 837     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
 838   } else {
 839     if (dst.first() != src.first()) {
 840       __ sxtw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 841     }
 842   }
 843 }
 844 
 845 // An oop arg. Must pass a handle not the oop itself
 846 static void object_move(MacroAssembler* masm,
 847                         OopMap* map,
 848                         int oop_handle_offset,
 849                         int framesize_in_slots,
 850                         VMRegPair src,
 851                         VMRegPair dst,
 852                         bool is_receiver,
 853                         int* receiver_offset) {
 854 
 855   // must pass a handle. First figure out the location we use as a handle
 856 
 857   Register rHandle = dst.first()-&gt;is_stack() ? rscratch2 : dst.first()-&gt;as_Register();
 858 
 859   // See if oop is NULL if it is we need no handle
 860 
 861   if (src.first()-&gt;is_stack()) {
 862 
 863     // Oop is already on the stack as an argument
 864     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 865     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
 866     if (is_receiver) {
 867       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
 868     }
 869 
 870     __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 871     __ lea(rHandle, Address(rfp, reg2offset_in(src.first())));
 872     // conditionally move a NULL
 873     __ cmp(rscratch1, zr);
 874     __ csel(rHandle, zr, rHandle, Assembler::EQ);
 875   } else {
 876 
 877     // Oop is in an a register we must store it to the space we reserve
 878     // on the stack for oop_handles and pass a handle if oop is non-NULL
 879 
 880     const Register rOop = src.first()-&gt;as_Register();
 881     int oop_slot;
 882     if (rOop == j_rarg0)
 883       oop_slot = 0;
 884     else if (rOop == j_rarg1)
 885       oop_slot = 1;
 886     else if (rOop == j_rarg2)
 887       oop_slot = 2;
 888     else if (rOop == j_rarg3)
 889       oop_slot = 3;
 890     else if (rOop == j_rarg4)
 891       oop_slot = 4;
 892     else if (rOop == j_rarg5)
 893       oop_slot = 5;
 894     else if (rOop == j_rarg6)
 895       oop_slot = 6;
 896     else {
 897       assert(rOop == j_rarg7, &quot;wrong register&quot;);
 898       oop_slot = 7;
 899     }
 900 
 901     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
 902     int offset = oop_slot*VMRegImpl::stack_slot_size;
 903 
 904     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
 905     // Store oop in handle area, may be NULL
 906     __ str(rOop, Address(sp, offset));
 907     if (is_receiver) {
 908       *receiver_offset = offset;
 909     }
 910 
 911     __ cmp(rOop, zr);
 912     __ lea(rHandle, Address(sp, offset));
 913     // conditionally move a NULL
 914     __ csel(rHandle, zr, rHandle, Assembler::EQ);
 915   }
 916 
 917   // If arg is on the stack then place it otherwise it is already in correct reg.
 918   if (dst.first()-&gt;is_stack()) {
 919     __ str(rHandle, Address(sp, reg2offset_out(dst.first())));
 920   }
 921 }
 922 
 923 // A float arg may have to do float reg int reg conversion
 924 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 925   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
 926          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
 927   if (src.first()-&gt;is_stack()) {
 928     if (dst.first()-&gt;is_stack()) {
 929       __ ldrw(rscratch1, Address(rfp, reg2offset_in(src.first())));
 930       __ strw(rscratch1, Address(sp, reg2offset_out(dst.first())));
 931     } else {
 932       ShouldNotReachHere();
 933     }
 934   } else if (src.first() != dst.first()) {
 935     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
 936       __ fmovs(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
 937     else
 938       ShouldNotReachHere();
 939   }
 940 }
 941 
 942 // A long move
 943 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 944   if (src.first()-&gt;is_stack()) {
 945     if (dst.first()-&gt;is_stack()) {
 946       // stack to stack
 947       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 948       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 949     } else {
 950       // stack to reg
 951       __ ldr(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
 952     }
 953   } else if (dst.first()-&gt;is_stack()) {
 954     // reg to stack
 955     // Do we really have to sign extend???
 956     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 957     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
 958   } else {
 959     if (dst.first() != src.first()) {
 960       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
 961     }
 962   }
 963 }
 964 
 965 
 966 // A double move
 967 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
 968   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
 969          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
 970   if (src.first()-&gt;is_stack()) {
 971     if (dst.first()-&gt;is_stack()) {
 972       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
 973       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
 974     } else {
 975       ShouldNotReachHere();
 976     }
 977   } else if (src.first() != dst.first()) {
 978     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
 979       __ fmovd(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
 980     else
 981       ShouldNotReachHere();
 982   }
 983 }
 984 
 985 
 986 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
 987   // We always ignore the frame_slots arg and just use the space just below frame pointer
 988   // which by this time is free to use
 989   switch (ret_type) {
 990   case T_FLOAT:
 991     __ strs(v0, Address(rfp, -wordSize));
 992     break;
 993   case T_DOUBLE:
 994     __ strd(v0, Address(rfp, -wordSize));
 995     break;
 996   case T_VOID:  break;
 997   default: {
 998     __ str(r0, Address(rfp, -wordSize));
 999     }
1000   }
1001 }
1002 
1003 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1004   // We always ignore the frame_slots arg and just use the space just below frame pointer
1005   // which by this time is free to use
1006   switch (ret_type) {
1007   case T_FLOAT:
1008     __ ldrs(v0, Address(rfp, -wordSize));
1009     break;
1010   case T_DOUBLE:
1011     __ ldrd(v0, Address(rfp, -wordSize));
1012     break;
1013   case T_VOID:  break;
1014   default: {
1015     __ ldr(r0, Address(rfp, -wordSize));
1016     }
1017   }
1018 }
1019 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1020   RegSet x;
1021   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1022     if (args[i].first()-&gt;is_Register()) {
1023       x = x + args[i].first()-&gt;as_Register();
1024     } else if (args[i].first()-&gt;is_FloatRegister()) {
1025       __ strd(args[i].first()-&gt;as_FloatRegister(), Address(__ pre(sp, -2 * wordSize)));
1026     }
1027   }
1028   __ push(x, sp);
1029 }
1030 
1031 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1032   RegSet x;
1033   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1034     if (args[i].first()-&gt;is_Register()) {
1035       x = x + args[i].first()-&gt;as_Register();
1036     } else {
1037       ;
1038     }
1039   }
1040   __ pop(x, sp);
1041   for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1042     if (args[i].first()-&gt;is_Register()) {
1043       ;
1044     } else if (args[i].first()-&gt;is_FloatRegister()) {
1045       __ ldrd(args[i].first()-&gt;as_FloatRegister(), Address(__ post(sp, 2 * wordSize)));
1046     }
1047   }
1048 }
1049 
1050 
1051 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1052 // keeps a new JNI critical region from starting until a GC has been
1053 // forced.  Save down any oops in registers and describe them in an
1054 // OopMap.
1055 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1056                                                int stack_slots,
1057                                                int total_c_args,
1058                                                int total_in_args,
1059                                                int arg_save_area,
1060                                                OopMapSet* oop_maps,
1061                                                VMRegPair* in_regs,
1062                                                BasicType* in_sig_bt) { Unimplemented(); }
1063 
1064 // Unpack an array argument into a pointer to the body and the length
1065 // if the array is non-null, otherwise pass 0 for both.
1066 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) { Unimplemented(); }
1067 
1068 
1069 class ComputeMoveOrder: public StackObj {
1070   class MoveOperation: public ResourceObj {
1071     friend class ComputeMoveOrder;
1072    private:
1073     VMRegPair        _src;
1074     VMRegPair        _dst;
1075     int              _src_index;
1076     int              _dst_index;
1077     bool             _processed;
1078     MoveOperation*  _next;
1079     MoveOperation*  _prev;
1080 
1081     static int get_id(VMRegPair r) { Unimplemented(); return 0; }
1082 
1083    public:
1084     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1085       _src(src)
1086     , _dst(dst)
1087     , _src_index(src_index)
1088     , _dst_index(dst_index)
1089     , _processed(false)
1090     , _next(NULL)
1091     , _prev(NULL) { Unimplemented(); }
1092 
1093     VMRegPair src() const              { Unimplemented(); return _src; }
1094     int src_id() const                 { Unimplemented(); return 0; }
1095     int src_index() const              { Unimplemented(); return 0; }
1096     VMRegPair dst() const              { Unimplemented(); return _src; }
1097     void set_dst(int i, VMRegPair dst) { Unimplemented(); }
1098     int dst_index() const              { Unimplemented(); return 0; }
1099     int dst_id() const                 { Unimplemented(); return 0; }
1100     MoveOperation* next() const        { Unimplemented(); return 0; }
1101     MoveOperation* prev() const        { Unimplemented(); return 0; }
1102     void set_processed()               { Unimplemented(); }
1103     bool is_processed() const          { Unimplemented(); return 0; }
1104 
1105     // insert
1106     void break_cycle(VMRegPair temp_register) { Unimplemented(); }
1107 
1108     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) { Unimplemented(); }
1109   };
1110 
1111  private:
1112   GrowableArray&lt;MoveOperation*&gt; edges;
1113 
1114  public:
1115   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1116                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1117 
1118   // Collected all the move operations
1119   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1120 
1121   // Walk the edges breaking cycles between moves.  The result list
1122   // can be walked in order to produce the proper set of loads
1123   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1124 };
1125 
1126 
1127 static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
1128   CodeBlob *cb = CodeCache::find_blob(dest);
1129   if (cb) {
1130     __ far_call(RuntimeAddress(dest));
1131   } else {
1132     assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
1133     assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
1134     __ lea(rscratch1, RuntimeAddress(dest));
1135     __ blr(rscratch1);
1136     __ maybe_isb();
1137   }
1138 }
1139 
1140 static void verify_oop_args(MacroAssembler* masm,
1141                             const methodHandle&amp; method,
1142                             const BasicType* sig_bt,
1143                             const VMRegPair* regs) {
1144   Register temp_reg = r19;  // not part of any compiled calling seq
1145   if (VerifyOops) {
1146     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1147       if (sig_bt[i] == T_OBJECT ||
1148           sig_bt[i] == T_ARRAY) {
1149         VMReg r = regs[i].first();
1150         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1151         if (r-&gt;is_stack()) {
1152           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1153           __ verify_oop(temp_reg);
1154         } else {
1155           __ verify_oop(r-&gt;as_Register());
1156         }
1157       }
1158     }
1159   }
1160 }
1161 
1162 static void gen_special_dispatch(MacroAssembler* masm,
1163                                  const methodHandle&amp; method,
1164                                  const BasicType* sig_bt,
1165                                  const VMRegPair* regs) {
1166   verify_oop_args(masm, method, sig_bt, regs);
1167   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1168 
1169   // Now write the args into the outgoing interpreter space
1170   bool     has_receiver   = false;
1171   Register receiver_reg   = noreg;
1172   int      member_arg_pos = -1;
1173   Register member_reg     = noreg;
1174   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1175   if (ref_kind != 0) {
1176     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1177     member_reg = r19;  // known to be free at this point
1178     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1179   } else if (iid == vmIntrinsics::_invokeBasic) {
1180     has_receiver = true;
1181   } else {
1182     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1183   }
1184 
1185   if (member_reg != noreg) {
1186     // Load the member_arg into register, if necessary.
1187     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1188     VMReg r = regs[member_arg_pos].first();
1189     if (r-&gt;is_stack()) {
1190       __ ldr(member_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1191     } else {
1192       // no data motion is needed
1193       member_reg = r-&gt;as_Register();
1194     }
1195   }
1196 
1197   if (has_receiver) {
1198     // Make sure the receiver is loaded into a register.
1199     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1200     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1201     VMReg r = regs[0].first();
1202     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1203     if (r-&gt;is_stack()) {
1204       // Porting note:  This assumes that compiled calling conventions always
1205       // pass the receiver oop in a register.  If this is not true on some
1206       // platform, pick a temp and load the receiver from stack.
1207       fatal(&quot;receiver always in a register&quot;);
1208       receiver_reg = r2;  // known to be free at this point
1209       __ ldr(receiver_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1210     } else {
1211       // no data motion is needed
1212       receiver_reg = r-&gt;as_Register();
1213     }
1214   }
1215 
1216   // Figure out which address we are really jumping to:
1217   MethodHandles::generate_method_handle_dispatch(masm, iid,
1218                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1219 }
1220 
1221 // ---------------------------------------------------------------------------
1222 // Generate a native wrapper for a given method.  The method takes arguments
1223 // in the Java compiled code convention, marshals them to the native
1224 // convention (handlizes oops, etc), transitions to native, makes the call,
1225 // returns to java state (possibly blocking), unhandlizes any result and
1226 // returns.
1227 //
1228 // Critical native functions are a shorthand for the use of
1229 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1230 // functions.  The wrapper is expected to unpack the arguments before
1231 // passing them to the callee and perform checks before and after the
1232 // native call to ensure that they GCLocker
1233 // lock_critical/unlock_critical semantics are followed.  Some other
1234 // parts of JNI setup are skipped like the tear down of the JNI handle
1235 // block and the check for pending exceptions it&#39;s impossible for them
1236 // to be thrown.
1237 //
1238 // They are roughly structured like this:
1239 //    if (GCLocker::needs_gc())
1240 //      SharedRuntime::block_for_jni_critical();
1241 //    tranistion to thread_in_native
1242 //    unpack arrray arguments and call native entry point
1243 //    check for safepoint in progress
1244 //    check if any thread suspend flags are set
1245 //      call into JVM and possible unlock the JNI critical
1246 //      if a GC was suppressed while in the critical native.
1247 //    transition back to thread_in_Java
1248 //    return to caller
1249 //
1250 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1251                                                 const methodHandle&amp; method,
1252                                                 int compile_id,
1253                                                 BasicType* in_sig_bt,
1254                                                 VMRegPair* in_regs,
1255                                                 BasicType ret_type,
1256                                                 address critical_entry) {
1257   if (method-&gt;is_method_handle_intrinsic()) {
1258     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1259     intptr_t start = (intptr_t)__ pc();
1260     int vep_offset = ((intptr_t)__ pc()) - start;
1261 
1262     // First instruction must be a nop as it may need to be patched on deoptimisation
1263     __ nop();
1264     gen_special_dispatch(masm,
1265                          method,
1266                          in_sig_bt,
1267                          in_regs);
1268     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1269     __ flush();
1270     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1271     return nmethod::new_native_nmethod(method,
1272                                        compile_id,
1273                                        masm-&gt;code(),
1274                                        vep_offset,
1275                                        frame_complete,
1276                                        stack_slots / VMRegImpl::slots_per_word,
1277                                        in_ByteSize(-1),
1278                                        in_ByteSize(-1),
1279                                        (OopMapSet*)NULL);
1280   }
1281   bool is_critical_native = true;
1282   address native_func = critical_entry;
1283   if (native_func == NULL) {
1284     native_func = method-&gt;native_function();
1285     is_critical_native = false;
1286   }
1287   assert(native_func != NULL, &quot;must have function&quot;);
1288 
1289   // An OopMap for lock (and class if static)
1290   OopMapSet *oop_maps = new OopMapSet();
1291   intptr_t start = (intptr_t)__ pc();
1292 
1293   // We have received a description of where all the java arg are located
1294   // on entry to the wrapper. We need to convert these args to where
1295   // the jni function will expect them. To figure out where they go
1296   // we convert the java signature to a C signature by inserting
1297   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1298 
1299   const int total_in_args = method-&gt;size_of_parameters();
1300   int total_c_args = total_in_args;
1301   if (!is_critical_native) {
1302     total_c_args += 1;
1303     if (method-&gt;is_static()) {
1304       total_c_args++;
1305     }
1306   } else {
1307     for (int i = 0; i &lt; total_in_args; i++) {
1308       if (in_sig_bt[i] == T_ARRAY) {
1309         total_c_args++;
1310       }
1311     }
1312   }
1313 
1314   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1315   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1316   BasicType* in_elem_bt = NULL;
1317 
1318   int argc = 0;
1319   if (!is_critical_native) {
1320     out_sig_bt[argc++] = T_ADDRESS;
1321     if (method-&gt;is_static()) {
1322       out_sig_bt[argc++] = T_OBJECT;
1323     }
1324 
1325     for (int i = 0; i &lt; total_in_args ; i++ ) {
1326       out_sig_bt[argc++] = in_sig_bt[i];
1327     }
1328   } else {
1329     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1330     SignatureStream ss(method-&gt;signature());
1331     for (int i = 0; i &lt; total_in_args ; i++ ) {
1332       if (in_sig_bt[i] == T_ARRAY) {
1333         // Arrays are passed as int, elem* pair
1334         out_sig_bt[argc++] = T_INT;
1335         out_sig_bt[argc++] = T_ADDRESS;
1336         ss.skip_array_prefix(1);  // skip one &#39;[&#39;
1337         assert(ss.is_primitive(), &quot;primitive type expected&quot;);
1338         in_elem_bt[i] = ss.type();
1339       } else {
1340         out_sig_bt[argc++] = in_sig_bt[i];
1341         in_elem_bt[i] = T_VOID;
1342       }
1343       if (in_sig_bt[i] != T_VOID) {
1344         assert(in_sig_bt[i] == ss.type() ||
1345                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);
1346         ss.next();
1347       }
1348     }
1349   }
1350 
1351   // Now figure out where the args must be stored and how much stack space
1352   // they require.
1353   int out_arg_slots;
1354   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1355 
1356   // Compute framesize for the wrapper.  We need to handlize all oops in
1357   // incoming registers
1358 
1359   // Calculate the total number of stack slots we will need.
1360 
1361   // First count the abi requirement plus all of the outgoing args
1362   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1363 
1364   // Now the space for the inbound oop handle area
1365   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
1366   if (is_critical_native) {
1367     // Critical natives may have to call out so they need a save area
1368     // for register arguments.
1369     int double_slots = 0;
1370     int single_slots = 0;
1371     for ( int i = 0; i &lt; total_in_args; i++) {
1372       if (in_regs[i].first()-&gt;is_Register()) {
1373         const Register reg = in_regs[i].first()-&gt;as_Register();
1374         switch (in_sig_bt[i]) {
1375           case T_BOOLEAN:
1376           case T_BYTE:
1377           case T_SHORT:
1378           case T_CHAR:
1379           case T_INT:  single_slots++; break;
1380           case T_ARRAY:  // specific to LP64 (7145024)
1381           case T_LONG: double_slots++; break;
1382           default:  ShouldNotReachHere();
1383         }
1384       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1385         ShouldNotReachHere();
1386       }
1387     }
1388     total_save_slots = double_slots * 2 + single_slots;
1389     // align the save area
1390     if (double_slots != 0) {
1391       stack_slots = align_up(stack_slots, 2);
1392     }
1393   }
1394 
1395   int oop_handle_offset = stack_slots;
1396   stack_slots += total_save_slots;
1397 
1398   // Now any space we need for handlizing a klass if static method
1399 
1400   int klass_slot_offset = 0;
1401   int klass_offset = -1;
1402   int lock_slot_offset = 0;
1403   bool is_static = false;
1404 
1405   if (method-&gt;is_static()) {
1406     klass_slot_offset = stack_slots;
1407     stack_slots += VMRegImpl::slots_per_word;
1408     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
1409     is_static = true;
1410   }
1411 
1412   // Plus a lock if needed
1413 
1414   if (method-&gt;is_synchronized()) {
1415     lock_slot_offset = stack_slots;
1416     stack_slots += VMRegImpl::slots_per_word;
1417   }
1418 
1419   // Now a place (+2) to save return values or temp during shuffling
1420   // + 4 for return address (which we own) and saved rfp
1421   stack_slots += 6;
1422 
1423   // Ok The space we have allocated will look like:
1424   //
1425   //
1426   // FP-&gt; |                     |
1427   //      |---------------------|
1428   //      | 2 slots for moves   |
1429   //      |---------------------|
1430   //      | lock box (if sync)  |
1431   //      |---------------------| &lt;- lock_slot_offset
1432   //      | klass (if static)   |
1433   //      |---------------------| &lt;- klass_slot_offset
1434   //      | oopHandle area      |
1435   //      |---------------------| &lt;- oop_handle_offset (8 java arg registers)
1436   //      | outbound memory     |
1437   //      | based arguments     |
1438   //      |                     |
1439   //      |---------------------|
1440   //      |                     |
1441   // SP-&gt; | out_preserved_slots |
1442   //
1443   //
1444 
1445 
1446   // Now compute actual number of stack words we need rounding to make
1447   // stack properly aligned.
1448   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
1449 
1450   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
1451 
1452   // First thing make an ic check to see if we should even be here
1453 
1454   // We are free to use all registers as temps without saving them and
1455   // restoring them except rfp. rfp is the only callee save register
1456   // as far as the interpreter and the compiler(s) are concerned.
1457 
1458 
1459   const Register ic_reg = rscratch2;
1460   const Register receiver = j_rarg0;
1461 
1462   Label hit;
1463   Label exception_pending;
1464 
1465   assert_different_registers(ic_reg, receiver, rscratch1);
1466   __ verify_oop(receiver);
1467   __ cmp_klass(receiver, ic_reg, rscratch1);
1468   __ br(Assembler::EQ, hit);
1469 
1470   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1471 
1472   // Verified entry point must be aligned
1473   __ align(8);
1474 
1475   __ bind(hit);
1476 
1477   int vep_offset = ((intptr_t)__ pc()) - start;
1478 
1479   // If we have to make this method not-entrant we&#39;ll overwrite its
1480   // first instruction with a jump.  For this action to be legal we
1481   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1482   // SVC, HVC, or SMC.  Make it a NOP.
1483   __ nop();
1484 
1485   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
1486     Label L_skip_barrier;
1487     __ mov_metadata(rscratch2, method-&gt;method_holder()); // InstanceKlass*
1488     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
1489     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
1490 
1491     __ bind(L_skip_barrier);
1492   }
1493 
1494   // Generate stack overflow check
1495   if (UseStackBanging) {
1496     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1497   } else {
1498     Unimplemented();
1499   }
1500 
1501   // Generate a new frame for the wrapper.
1502   __ enter();
1503   // -2 because return address is already present and so is saved rfp
1504   __ sub(sp, sp, stack_size - 2*wordSize);
1505 
1506   // Frame is now completed as far as size and linkage.
1507   int frame_complete = ((intptr_t)__ pc()) - start;
1508 
1509   // We use r20 as the oop handle for the receiver/klass
1510   // It is callee save so it survives the call to native
1511 
1512   const Register oop_handle_reg = r20;
1513 
1514   if (is_critical_native) {
1515     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1516                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1517   }
1518 
1519   //
1520   // We immediately shuffle the arguments so that any vm call we have to
1521   // make from here on out (sync slow path, jvmti, etc.) we will have
1522   // captured the oops from our caller and have a valid oopMap for
1523   // them.
1524 
1525   // -----------------
1526   // The Grand Shuffle
1527 
1528   // The Java calling convention is either equal (linux) or denser (win64) than the
1529   // c calling convention. However the because of the jni_env argument the c calling
1530   // convention always has at least one more (and two for static) arguments than Java.
1531   // Therefore if we move the args from java -&gt; c backwards then we will never have
1532   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
1533   // and figure out how to break any cycles.
1534   //
1535 
1536   // Record esp-based slot for receiver on stack for non-static methods
1537   int receiver_offset = -1;
1538 
1539   // This is a trick. We double the stack slots so we can claim
1540   // the oops in the caller&#39;s frame. Since we are sure to have
1541   // more args than the caller doubling is enough to make
1542   // sure we can capture all the incoming oop args from the
1543   // caller.
1544   //
1545   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1546 
1547   // Mark location of rfp (someday)
1548   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rfp));
1549 
1550 
1551   int float_args = 0;
1552   int int_args = 0;
1553 
1554 #ifdef ASSERT
1555   bool reg_destroyed[RegisterImpl::number_of_registers];
1556   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
1557   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
1558     reg_destroyed[r] = false;
1559   }
1560   for ( int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++ ) {
1561     freg_destroyed[f] = false;
1562   }
1563 
1564 #endif /* ASSERT */
1565 
1566   // This may iterate in two different directions depending on the
1567   // kind of native it is.  The reason is that for regular JNI natives
1568   // the incoming and outgoing registers are offset upwards and for
1569   // critical natives they are offset down.
1570   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
1571   VMRegPair tmp_vmreg;
1572   tmp_vmreg.set2(r19-&gt;as_VMReg());
1573 
1574   if (!is_critical_native) {
1575     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1576       arg_order.push(i);
1577       arg_order.push(c_arg);
1578     }
1579   } else {
1580     // Compute a valid move order, using tmp_vmreg to break any cycles
1581     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
1582   }
1583 
1584   int temploc = -1;
1585   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
1586     int i = arg_order.at(ai);
1587     int c_arg = arg_order.at(ai + 1);
1588     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
1589     if (c_arg == -1) {
1590       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1591       // This arg needs to be moved to a temporary
1592       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
1593       in_regs[i] = tmp_vmreg;
1594       temploc = i;
1595       continue;
1596     } else if (i == -1) {
1597       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1598       // Read from the temporary location
1599       assert(temploc != -1, &quot;must be valid&quot;);
1600       i = temploc;
1601       temploc = -1;
1602     }
1603 #ifdef ASSERT
1604     if (in_regs[i].first()-&gt;is_Register()) {
1605       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
1606     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1607       assert(!freg_destroyed[in_regs[i].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
1608     }
1609     if (out_regs[c_arg].first()-&gt;is_Register()) {
1610       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1611     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1612       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1613     }
1614 #endif /* ASSERT */
1615     switch (in_sig_bt[i]) {
1616       case T_ARRAY:
1617         if (is_critical_native) {
1618           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1619           c_arg++;
1620 #ifdef ASSERT
1621           if (out_regs[c_arg].first()-&gt;is_Register()) {
1622             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1623           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1624             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1625           }
1626 #endif
1627           int_args++;
1628           break;
1629         }
1630       case T_OBJECT:
1631         assert(!is_critical_native, &quot;no oop arguments&quot;);
1632         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1633                     ((i == 0) &amp;&amp; (!is_static)),
1634                     &amp;receiver_offset);
1635         int_args++;
1636         break;
1637       case T_VOID:
1638         break;
1639 
1640       case T_FLOAT:
1641         float_move(masm, in_regs[i], out_regs[c_arg]);
1642         float_args++;
1643         break;
1644 
1645       case T_DOUBLE:
1646         assert( i + 1 &lt; total_in_args &amp;&amp;
1647                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1648                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1649         double_move(masm, in_regs[i], out_regs[c_arg]);
1650         float_args++;
1651         break;
1652 
1653       case T_LONG :
1654         long_move(masm, in_regs[i], out_regs[c_arg]);
1655         int_args++;
1656         break;
1657 
1658       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
1659 
1660       default:
1661         move32_64(masm, in_regs[i], out_regs[c_arg]);
1662         int_args++;
1663     }
1664   }
1665 
1666   // point c_arg at the first arg that is already loaded in case we
1667   // need to spill before we call out
1668   int c_arg = total_c_args - total_in_args;
1669 
1670   // Pre-load a static method&#39;s oop into c_rarg1.
1671   if (method-&gt;is_static() &amp;&amp; !is_critical_native) {
1672 
1673     //  load oop into a register
1674     __ movoop(c_rarg1,
1675               JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
1676               /*immediate*/true);
1677 
1678     // Now handlize the static class mirror it&#39;s known not-null.
1679     __ str(c_rarg1, Address(sp, klass_offset));
1680     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
1681 
1682     // Now get the handle
1683     __ lea(c_rarg1, Address(sp, klass_offset));
1684     // and protect the arg if we must spill
1685     c_arg--;
1686   }
1687 
1688   // Change state to native (we save the return address in the thread, since it might not
1689   // be pushed on the stack when we do a stack traversal).
1690   // We use the same pc/oopMap repeatedly when we call out
1691 
1692   Label native_return;
1693   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1694 
1695   Label dtrace_method_entry, dtrace_method_entry_done;
1696   {
1697     unsigned long offset;
1698     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1699     __ ldrb(rscratch1, Address(rscratch1, offset));
1700     __ cbnzw(rscratch1, dtrace_method_entry);
1701     __ bind(dtrace_method_entry_done);
1702   }
1703 
1704   TSAN_RUNTIME_ONLY(
1705     // protect the args we&#39;ve loaded
1706     save_args(masm, total_c_args, c_arg, out_regs);
1707     __ call_VM(noreg,
1708       CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),
1709       rthread);
1710     restore_args(masm, total_c_args, c_arg, out_regs);
1711   );
1712 
1713   // RedefineClasses() tracing support for obsolete method entry
1714   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1715     // protect the args we&#39;ve loaded
1716     save_args(masm, total_c_args, c_arg, out_regs);
1717     __ mov_metadata(c_rarg1, method());
1718     __ call_VM_leaf(
1719       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1720       rthread, c_rarg1);
1721     restore_args(masm, total_c_args, c_arg, out_regs);
1722   }
1723 
1724   // Lock a synchronized method
1725 
1726   // Register definitions used by locking and unlocking
1727 
1728   const Register swap_reg = r0;
1729   const Register obj_reg  = r19;  // Will contain the oop
1730   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
1731   const Register old_hdr  = r13;  // value of old header at unlock time
1732   const Register tmp = lr;
1733 
1734   Label slow_path_lock;
1735   Label lock_done;
1736 
1737   if (method-&gt;is_synchronized()) {
1738     assert(!is_critical_native, &quot;unhandled&quot;);
1739 
1740     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
1741 
1742     // Get the handle (the 2nd argument)
1743     __ mov(oop_handle_reg, c_rarg1);
1744 
1745     // Get address of the box
1746 
1747     __ lea(lock_reg, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1748 
1749     // Load the oop from the handle
1750     __ ldr(obj_reg, Address(oop_handle_reg, 0));
1751 
1752     __ resolve(IS_NOT_NULL, obj_reg);
1753 
1754     if (UseBiasedLocking) {
1755       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &amp;slow_path_lock);
1756     }
1757 
1758     // Load (object-&gt;mark() | 1) into swap_reg %r0
1759     __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1760     __ orr(swap_reg, rscratch1, 1);
1761 
1762     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1763     __ str(swap_reg, Address(lock_reg, mark_word_offset));
1764 
1765     // src -&gt; dest iff dest == r0 else r0 &lt;- dest
1766     { Label here;
1767       __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, /*fallthrough*/NULL);
1768     }
1769 
1770     // Hmm should this move to the slow path code area???
1771 
1772     // Test if the oopMark is an obvious stack pointer, i.e.,
1773     //  1) (mark &amp; 3) == 0, and
1774     //  2) sp &lt;= mark &lt; mark + os::pagesize()
1775     // These 3 tests can be done by evaluating the following
1776     // expression: ((mark - sp) &amp; (3 - os::vm_page_size())),
1777     // assuming both stack pointer and pagesize have their
1778     // least significant 2 bits clear.
1779     // NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg
1780 
1781     __ sub(swap_reg, sp, swap_reg);
1782     __ neg(swap_reg, swap_reg);
1783     __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());
1784 
1785     // Save the test result, for recursive case, the result is zero
1786     __ str(swap_reg, Address(lock_reg, mark_word_offset));
1787     __ br(Assembler::NE, slow_path_lock);
1788 
1789     // Slow path will re-enter here
1790 
1791     __ bind(lock_done);
<a name="1" id="anc1"></a><span class="line-added">1792 </span>
<span class="line-added">1793     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">1794       __ pusha();</span>
<span class="line-added">1795       __ call_VM(noreg,</span>
<span class="line-added">1796                  CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),</span>
<span class="line-added">1797                  obj_reg);</span>
<span class="line-added">1798       __ popa();</span>
<span class="line-added">1799     );</span>
1800   }
1801 
1802 
1803   // Finally just about ready to make the JNI call
1804 
1805   // get JNIEnv* which is first argument to native
1806   if (!is_critical_native) {
1807     __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));
1808   }
1809 
1810   // Now set thread in native
1811   __ mov(rscratch1, _thread_in_native);
1812   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1813   __ stlrw(rscratch1, rscratch2);
1814 
1815   {
1816     int return_type = 0;
1817     switch (ret_type) {
1818     case T_VOID: break;
1819       return_type = 0; break;
1820     case T_CHAR:
1821     case T_BYTE:
1822     case T_SHORT:
1823     case T_INT:
1824     case T_BOOLEAN:
1825     case T_LONG:
1826       return_type = 1; break;
1827     case T_ARRAY:
1828     case T_OBJECT:
1829       return_type = 1; break;
1830     case T_FLOAT:
1831       return_type = 2; break;
1832     case T_DOUBLE:
1833       return_type = 3; break;
1834     default:
1835       ShouldNotReachHere();
1836     }
1837     rt_call(masm, native_func,
1838             int_args + 2, // AArch64 passes up to 8 args in int registers
1839             float_args,   // and up to 8 float args
1840             return_type);
1841   }
1842 
1843   __ bind(native_return);
1844 
1845   intptr_t return_pc = (intptr_t) __ pc();
1846   oop_maps-&gt;add_gc_map(return_pc - start, map);
1847 
1848   // Unpack native results.
1849   switch (ret_type) {
1850   case T_BOOLEAN: __ c2bool(r0);                     break;
1851   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
1852   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
1853   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
1854   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
1855   case T_DOUBLE :
1856   case T_FLOAT  :
1857     // Result is in v0 we&#39;ll save as needed
1858     break;
1859   case T_ARRAY:                 // Really a handle
1860   case T_OBJECT:                // Really a handle
1861       break; // can&#39;t de-handlize until after safepoint check
1862   case T_VOID: break;
1863   case T_LONG: break;
1864   default       : ShouldNotReachHere();
1865   }
1866 
1867   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
1868   // This additional state is necessary because reading and testing the synchronization
1869   // state is not atomic w.r.t. GC, as this scenario demonstrates:
1870   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
1871   //     VM thread changes sync state to synchronizing and suspends threads for GC.
1872   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
1873   //     didn&#39;t see any synchronization is progress, and escapes.
1874   __ mov(rscratch1, _thread_in_native_trans);
1875 
1876   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
1877 
1878   // Force this write out before the read below
1879   __ dmb(Assembler::ISH);
1880 
1881   // check for safepoint operation in progress and/or pending suspend requests
1882   Label safepoint_in_progress, safepoint_in_progress_done;
1883   {
1884     __ safepoint_poll_acquire(safepoint_in_progress);
1885     __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));
1886     __ cbnzw(rscratch1, safepoint_in_progress);
1887     __ bind(safepoint_in_progress_done);
1888   }
1889 
1890   // change thread state
1891   Label after_transition;
1892   __ mov(rscratch1, _thread_in_Java);
1893   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1894   __ stlrw(rscratch1, rscratch2);
1895   __ bind(after_transition);
1896 
1897   Label reguard;
1898   Label reguard_done;
1899   __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));
1900   __ cmpw(rscratch1, JavaThread::stack_guard_yellow_reserved_disabled);
1901   __ br(Assembler::EQ, reguard);
1902   __ bind(reguard_done);
1903 
1904   // native result if any is live
1905 
1906   // Unlock
1907   Label unlock_done;
1908   Label slow_path_unlock;
1909   if (method-&gt;is_synchronized()) {
1910 
1911     // Get locked oop from the handle we passed to jni
1912     __ ldr(obj_reg, Address(oop_handle_reg, 0));
1913 
1914     __ resolve(IS_NOT_NULL, obj_reg);
1915 
<a name="2" id="anc2"></a><span class="line-added">1916     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">1917       __ pusha();</span>
<span class="line-added">1918       __ call_VM(noreg,</span>
<span class="line-added">1919                  CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_unlock),</span>
<span class="line-added">1920                  obj_reg);</span>
<span class="line-added">1921       __ popa();</span>
<span class="line-added">1922     );</span>
<span class="line-added">1923 </span>
<span class="line-added">1924 </span>
1925     Label done;
1926 
1927     if (UseBiasedLocking) {
1928       __ biased_locking_exit(obj_reg, old_hdr, done);
1929     }
1930 
1931     // Simple recursive lock?
1932 
1933     __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1934     __ cbz(rscratch1, done);
1935 
1936     // Must save r0 if if it is live now because cmpxchg must use it
1937     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1938       save_native_result(masm, ret_type, stack_slots);
1939     }
1940 
1941 
1942     // get address of the stack lock
1943     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1944     //  get old displaced header
1945     __ ldr(old_hdr, Address(r0, 0));
1946 
1947     // Atomic swap old header if oop still contains the stack lock
1948     Label succeed;
1949     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
1950     __ bind(succeed);
1951 
1952     // slow path re-enters here
1953     __ bind(unlock_done);
1954     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1955       restore_native_result(masm, ret_type, stack_slots);
1956     }
1957 
1958     __ bind(done);
1959   }
1960 
1961   TSAN_RUNTIME_ONLY(
1962     save_native_result(masm, ret_type, stack_slots);
1963     __ call_VM_leaf(
1964          CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));
1965     restore_native_result(masm, ret_type, stack_slots);
1966   );
1967 
1968   Label dtrace_method_exit, dtrace_method_exit_done;
1969   {
1970     unsigned long offset;
1971     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1972     __ ldrb(rscratch1, Address(rscratch1, offset));
1973     __ cbnzw(rscratch1, dtrace_method_exit);
1974     __ bind(dtrace_method_exit_done);
1975   }
1976 
1977   __ reset_last_Java_frame(false);
1978 
1979   // Unbox oop result, e.g. JNIHandles::resolve result.
1980   if (is_reference_type(ret_type)) {
1981     __ resolve_jobject(r0, rthread, rscratch2);
1982   }
1983 
1984   if (CheckJNICalls) {
1985     // clear_pending_jni_exception_check
1986     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1987   }
1988 
1989   if (!is_critical_native) {
1990     // reset handle block
1991     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
1992     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
1993   }
1994 
1995   __ leave();
1996 
1997   if (!is_critical_native) {
1998     // Any exception pending?
1999     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2000     __ cbnz(rscratch1, exception_pending);
2001   }
2002 
2003   // We&#39;re done
2004   __ ret(lr);
2005 
2006   // Unexpected paths are out of line and go here
2007 
2008   if (!is_critical_native) {
2009     // forward the exception
2010     __ bind(exception_pending);
2011 
2012     // and forward the exception
2013     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2014   }
2015 
2016   // Slow path locking &amp; unlocking
2017   if (method-&gt;is_synchronized()) {
2018 
2019     __ block_comment(&quot;Slow path lock {&quot;);
2020     __ bind(slow_path_lock);
2021 
2022     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2023     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2024 
2025     // protect the args we&#39;ve loaded
2026     save_args(masm, total_c_args, c_arg, out_regs);
2027 
2028     __ mov(c_rarg0, obj_reg);
2029     __ mov(c_rarg1, lock_reg);
2030     __ mov(c_rarg2, rthread);
2031 
2032     // Not a leaf but we have last_Java_frame setup as we want
2033     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2034     restore_args(masm, total_c_args, c_arg, out_regs);
2035 
2036 #ifdef ASSERT
2037     { Label L;
2038       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2039       __ cbz(rscratch1, L);
2040       __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2041       __ bind(L);
2042     }
2043 #endif
2044     __ b(lock_done);
2045 
2046     __ block_comment(&quot;} Slow path lock&quot;);
2047 
2048     __ block_comment(&quot;Slow path unlock {&quot;);
2049     __ bind(slow_path_unlock);
2050 
2051     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2052     // are still exposed.
2053 
2054     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2055       save_native_result(masm, ret_type, stack_slots);
2056     }
2057 
2058     __ mov(c_rarg2, rthread);
2059     __ lea(c_rarg1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2060     __ mov(c_rarg0, obj_reg);
2061 
2062     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2063     // NOTE that obj_reg == r19 currently
2064     __ ldr(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2065     __ str(zr, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2066 
2067     rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), 3, 0, 1);
2068 
2069 #ifdef ASSERT
2070     {
2071       Label L;
2072       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2073       __ cbz(rscratch1, L);
2074       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2075       __ bind(L);
2076     }
2077 #endif /* ASSERT */
2078 
2079     __ str(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2080 
2081     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2082       restore_native_result(masm, ret_type, stack_slots);
2083     }
2084     __ b(unlock_done);
2085 
2086     __ block_comment(&quot;} Slow path unlock&quot;);
2087 
2088   } // synchronized
2089 
2090   // SLOW PATH Reguard the stack if needed
2091 
2092   __ bind(reguard);
2093   save_native_result(masm, ret_type, stack_slots);
2094   rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), 0, 0, 0);
2095   restore_native_result(masm, ret_type, stack_slots);
2096   // and continue
2097   __ b(reguard_done);
2098 
2099   // SLOW PATH safepoint
2100   {
2101     __ block_comment(&quot;safepoint {&quot;);
2102     __ bind(safepoint_in_progress);
2103 
2104     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2105     // and never return here preventing us from clearing _last_native_pc down below.
2106     //
2107     save_native_result(masm, ret_type, stack_slots);
2108     __ mov(c_rarg0, rthread);
2109 #ifndef PRODUCT
2110   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2111 #endif
2112     if (!is_critical_native) {
2113       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2114     } else {
2115       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2116     }
2117     __ blr(rscratch1);
2118     __ maybe_isb();
2119     // Restore any method result value
2120     restore_native_result(masm, ret_type, stack_slots);
2121 
2122     if (is_critical_native) {
2123       // The call above performed the transition to thread_in_Java so
2124       // skip the transition logic above.
2125       __ b(after_transition);
2126     }
2127 
2128     __ b(safepoint_in_progress_done);
2129     __ block_comment(&quot;} safepoint&quot;);
2130   }
2131 
2132   // SLOW PATH dtrace support
2133   {
2134     __ block_comment(&quot;dtrace entry {&quot;);
2135     __ bind(dtrace_method_entry);
2136 
2137     // We have all of the arguments setup at this point. We must not touch any register
2138     // argument registers at this point (what if we save/restore them there are no oop?
2139 
2140     save_args(masm, total_c_args, c_arg, out_regs);
2141     __ mov_metadata(c_rarg1, method());
2142     __ call_VM_leaf(
2143       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2144       rthread, c_rarg1);
2145     restore_args(masm, total_c_args, c_arg, out_regs);
2146     __ b(dtrace_method_entry_done);
2147     __ block_comment(&quot;} dtrace entry&quot;);
2148   }
2149 
2150   {
2151     __ block_comment(&quot;dtrace exit {&quot;);
2152     __ bind(dtrace_method_exit);
2153     save_native_result(masm, ret_type, stack_slots);
2154     __ mov_metadata(c_rarg1, method());
2155     __ call_VM_leaf(
2156          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2157          rthread, c_rarg1);
2158     restore_native_result(masm, ret_type, stack_slots);
2159     __ b(dtrace_method_exit_done);
2160     __ block_comment(&quot;} dtrace exit&quot;);
2161   }
2162 
2163 
2164   __ flush();
2165 
2166   nmethod *nm = nmethod::new_native_nmethod(method,
2167                                             compile_id,
2168                                             masm-&gt;code(),
2169                                             vep_offset,
2170                                             frame_complete,
2171                                             stack_slots / VMRegImpl::slots_per_word,
2172                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2173                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2174                                             oop_maps);
2175 
2176   if (is_critical_native) {
2177     nm-&gt;set_lazy_critical_native(true);
2178   }
2179 
2180   return nm;
2181 
2182 }
2183 
2184 // this function returns the adjust size (in number of words) to a c2i adapter
2185 // activation for use during deoptimization
2186 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2187   assert(callee_locals &gt;= callee_parameters,
2188           &quot;test and remove; got more parms than locals&quot;);
2189   if (callee_locals &lt; callee_parameters)
2190     return 0;                   // No adjustment for negative locals
2191   int diff = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2192   // diff is counted in stack words
2193   return align_up(diff, 2);
2194 }
2195 
2196 
2197 //------------------------------generate_deopt_blob----------------------------
2198 void SharedRuntime::generate_deopt_blob() {
2199   // Allocate space for the code
2200   ResourceMark rm;
2201   // Setup code generation tools
2202   int pad = 0;
2203 #if INCLUDE_JVMCI
2204   if (EnableJVMCI || UseAOT) {
2205     pad += 512; // Increase the buffer size when compiling for JVMCI
2206   }
2207 #endif
2208   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2209   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2210   int frame_size_in_words;
2211   OopMap* map = NULL;
2212   OopMapSet *oop_maps = new OopMapSet();
2213 
2214   // -------------
2215   // This code enters when returning to a de-optimized nmethod.  A return
2216   // address has been pushed on the the stack, and return values are in
2217   // registers.
2218   // If we are doing a normal deopt then we were called from the patched
2219   // nmethod from the point we returned to the nmethod. So the return
2220   // address on the stack is wrong by NativeCall::instruction_size
2221   // We will adjust the value so it looks like we have the original return
2222   // address on the stack (like when we eagerly deoptimized).
2223   // In the case of an exception pending when deoptimizing, we enter
2224   // with a return address on the stack that points after the call we patched
2225   // into the exception handler. We have the following register state from,
2226   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2227   //    r0: exception oop
2228   //    r19: exception handler
2229   //    r3: throwing pc
2230   // So in this case we simply jam r3 into the useless return address and
2231   // the stack looks just like we want.
2232   //
2233   // At this point we need to de-opt.  We save the argument return
2234   // registers.  We call the first C routine, fetch_unroll_info().  This
2235   // routine captures the return values and returns a structure which
2236   // describes the current frame size and the sizes of all replacement frames.
2237   // The current frame is compiled code and may contain many inlined
2238   // functions, each with their own JVM state.  We pop the current frame, then
2239   // push all the new frames.  Then we call the C routine unpack_frames() to
2240   // populate these frames.  Finally unpack_frames() returns us the new target
2241   // address.  Notice that callee-save registers are BLOWN here; they have
2242   // already been captured in the vframeArray at the time the return PC was
2243   // patched.
2244   address start = __ pc();
2245   Label cont;
2246 
2247   // Prolog for non exception case!
2248 
2249   // Save everything in sight.
2250   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2251 
2252   // Normal deoptimization.  Save exec mode for unpack_frames.
2253   __ movw(rcpool, Deoptimization::Unpack_deopt); // callee-saved
2254   __ b(cont);
2255 
2256   int reexecute_offset = __ pc() - start;
2257 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2258   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2259     // JVMCI does not use this kind of deoptimization
2260     __ should_not_reach_here();
2261   }
2262 #endif
2263 
2264   // Reexecute case
2265   // return address is the pc describes what bci to do re-execute at
2266 
2267   // No need to update map as each call to save_live_registers will produce identical oopmap
2268   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2269 
2270   __ movw(rcpool, Deoptimization::Unpack_reexecute); // callee-saved
2271   __ b(cont);
2272 
2273 #if INCLUDE_JVMCI
2274   Label after_fetch_unroll_info_call;
2275   int implicit_exception_uncommon_trap_offset = 0;
2276   int uncommon_trap_offset = 0;
2277 
2278   if (EnableJVMCI || UseAOT) {
2279     implicit_exception_uncommon_trap_offset = __ pc() - start;
2280 
2281     __ ldr(lr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2282     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2283 
2284     uncommon_trap_offset = __ pc() - start;
2285 
2286     // Save everything in sight.
2287     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2288     // fetch_unroll_info needs to call last_java_frame()
2289     Label retaddr;
2290     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2291 
2292     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2293     __ movw(rscratch1, -1);
2294     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2295 
2296     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2297     __ mov(c_rarg0, rthread);
2298     __ movw(c_rarg2, rcpool); // exec mode
2299     __ lea(rscratch1,
2300            RuntimeAddress(CAST_FROM_FN_PTR(address,
2301                                            Deoptimization::uncommon_trap)));
2302     __ blr(rscratch1);
2303     __ bind(retaddr);
2304     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2305 
2306     __ reset_last_Java_frame(false);
2307 
2308     __ b(after_fetch_unroll_info_call);
2309   } // EnableJVMCI
2310 #endif // INCLUDE_JVMCI
2311 
2312   int exception_offset = __ pc() - start;
2313 
2314   // Prolog for exception case
2315 
2316   // all registers are dead at this entry point, except for r0, and
2317   // r3 which contain the exception oop and exception pc
2318   // respectively.  Set them in TLS and fall thru to the
2319   // unpack_with_exception_in_tls entry point.
2320 
2321   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2322   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
2323 
2324   int exception_in_tls_offset = __ pc() - start;
2325 
2326   // new implementation because exception oop is now passed in JavaThread
2327 
2328   // Prolog for exception case
2329   // All registers must be preserved because they might be used by LinearScan
2330   // Exceptiop oop and throwing PC are passed in JavaThread
2331   // tos: stack at point of call to method that threw the exception (i.e. only
2332   // args are on the stack, no return address)
2333 
2334   // The return address pushed by save_live_registers will be patched
2335   // later with the throwing pc. The correct value is not available
2336   // now because loading it from memory would destroy registers.
2337 
2338   // NB: The SP at this point must be the SP of the method that is
2339   // being deoptimized.  Deoptimization assumes that the frame created
2340   // here by save_live_registers is immediately below the method&#39;s SP.
2341   // This is a somewhat fragile mechanism.
2342 
2343   // Save everything in sight.
2344   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2345 
2346   // Now it is safe to overwrite any register
2347 
2348   // Deopt during an exception.  Save exec mode for unpack_frames.
2349   __ mov(rcpool, Deoptimization::Unpack_exception); // callee-saved
2350 
2351   // load throwing pc from JavaThread and patch it as the return address
2352   // of the current frame. Then clear the field in JavaThread
2353 
2354   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2355   __ str(r3, Address(rfp, wordSize));
2356   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2357 
2358 #ifdef ASSERT
2359   // verify that there is really an exception oop in JavaThread
2360   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2361   __ verify_oop(r0);
2362 
2363   // verify that there is no pending exception
2364   Label no_pending_exception;
2365   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2366   __ cbz(rscratch1, no_pending_exception);
2367   __ stop(&quot;must not have pending exception here&quot;);
2368   __ bind(no_pending_exception);
2369 #endif
2370 
2371   __ bind(cont);
2372 
2373   // Call C code.  Need thread and this frame, but NOT official VM entry
2374   // crud.  We cannot block on this call, no GC can happen.
2375   //
2376   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2377 
2378   // fetch_unroll_info needs to call last_java_frame().
2379 
2380   Label retaddr;
2381   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2382 #ifdef ASSERT0
2383   { Label L;
2384     __ ldr(rscratch1, Address(rthread,
2385                               JavaThread::last_Java_fp_offset()));
2386     __ cbz(rscratch1, L);
2387     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2388     __ bind(L);
2389   }
2390 #endif // ASSERT
2391   __ mov(c_rarg0, rthread);
2392   __ mov(c_rarg1, rcpool);
2393   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
2394   __ blr(rscratch1);
2395   __ bind(retaddr);
2396 
2397   // Need to have an oopmap that tells fetch_unroll_info where to
2398   // find any register it might need.
2399   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2400 
2401   __ reset_last_Java_frame(false);
2402 
2403 #if INCLUDE_JVMCI
2404   if (EnableJVMCI || UseAOT) {
2405     __ bind(after_fetch_unroll_info_call);
2406   }
2407 #endif
2408 
2409   // Load UnrollBlock* into r5
2410   __ mov(r5, r0);
2411 
2412   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2413    Label noException;
2414   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
2415   __ br(Assembler::NE, noException);
2416   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2417   // QQQ this is useless it was NULL above
2418   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2419   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
2420   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2421 
2422   __ verify_oop(r0);
2423 
2424   // Overwrite the result registers with the exception results.
2425   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2426   // I think this is useless
2427   // __ str(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2428 
2429   __ bind(noException);
2430 
2431   // Only register save data is on the stack.
2432   // Now restore the result registers.  Everything else is either dead
2433   // or captured in the vframeArray.
2434   RegisterSaver::restore_result_registers(masm);
2435 
2436   // All of the register save area has been popped of the stack. Only the
2437   // return address remains.
2438 
2439   // Pop all the frames we must move/replace.
2440   //
2441   // Frame picture (youngest to oldest)
2442   // 1: self-frame (no frame link)
2443   // 2: deopting frame  (no frame link)
2444   // 3: caller of deopting frame (could be compiled/interpreted).
2445   //
2446   // Note: by leaving the return address of self-frame on the stack
2447   // and using the size of frame 2 to adjust the stack
2448   // when we are done the return to frame 3 will still be on the stack.
2449 
2450   // Pop deoptimized frame
2451   __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2452   __ sub(r2, r2, 2 * wordSize);
2453   __ add(sp, sp, r2);
2454   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2455   // LR should now be the return address to the caller (3)
2456 
2457 #ifdef ASSERT
2458   // Compilers generate code that bang the stack by as much as the
2459   // interpreter would need. So this stack banging should never
2460   // trigger a fault. Verify that it does not on non product builds.
2461   if (UseStackBanging) {
2462     __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2463     __ bang_stack_size(r19, r2);
2464   }
2465 #endif
2466   // Load address of array of frame pcs into r2
2467   __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2468 
2469   // Trash the old pc
2470   // __ addptr(sp, wordSize);  FIXME ????
2471 
2472   // Load address of array of frame sizes into r4
2473   __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2474 
2475   // Load counter into r3
2476   __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2477 
2478   // Now adjust the caller&#39;s stack to make up for the extra locals
2479   // but record the original sp so that we can save it in the skeletal interpreter
2480   // frame and the stack walking of interpreter_sender will get the unextended sp
2481   // value and not the &quot;real&quot; sp value.
2482 
2483   const Register sender_sp = r6;
2484 
2485   __ mov(sender_sp, sp);
2486   __ ldrw(r19, Address(r5,
2487                        Deoptimization::UnrollBlock::
2488                        caller_adjustment_offset_in_bytes()));
2489   __ sub(sp, sp, r19);
2490 
2491   // Push interpreter frames in a loop
2492   __ mov(rscratch1, (address)0xDEADDEAD);        // Make a recognizable pattern
2493   __ mov(rscratch2, rscratch1);
2494   Label loop;
2495   __ bind(loop);
2496   __ ldr(r19, Address(__ post(r4, wordSize)));          // Load frame size
2497   __ sub(r19, r19, 2*wordSize);           // We&#39;ll push pc and fp by hand
2498   __ ldr(lr, Address(__ post(r2, wordSize)));  // Load pc
2499   __ enter();                           // Save old &amp; set new fp
2500   __ sub(sp, sp, r19);                  // Prolog
2501   // This value is corrected by layout_activation_impl
2502   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2503   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2504   __ mov(sender_sp, sp);               // Pass sender_sp to next frame
2505   __ sub(r3, r3, 1);                   // Decrement counter
2506   __ cbnz(r3, loop);
2507 
2508     // Re-push self-frame
2509   __ ldr(lr, Address(r2));
2510   __ enter();
2511 
2512   // Allocate a full sized register save area.  We subtract 2 because
2513   // enter() just pushed 2 words
2514   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2515 
2516   // Restore frame locals after moving the frame
2517   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2518   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2519 
2520   // Call C code.  Need thread but NOT official VM entry
2521   // crud.  We cannot block on this call, no GC can happen.  Call should
2522   // restore return values to their stack-slots with the new SP.
2523   //
2524   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2525 
2526   // Use rfp because the frames look interpreted now
2527   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2528   address the_pc = __ pc();
2529   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2530 
2531   __ mov(c_rarg0, rthread);
2532   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2533   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2534   __ blr(rscratch1);
2535 
2536   // Set an oopmap for the call site
2537   // Use the same PC we used for the last java frame
2538   oop_maps-&gt;add_gc_map(the_pc - start,
2539                        new OopMap( frame_size_in_words, 0 ));
2540 
2541   // Clear fp AND pc
2542   __ reset_last_Java_frame(true);
2543 
2544   // Collect return values
2545   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2546   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2547   // I think this is useless (throwing pc?)
2548   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2549 
2550   // Pop self-frame.
2551   __ leave();                           // Epilog
2552 
2553   // Jump to interpreter
2554   __ ret(lr);
2555 
2556   // Make sure all code is generated
2557   masm-&gt;flush();
2558 
2559   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2560   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2561 #if INCLUDE_JVMCI
2562   if (EnableJVMCI || UseAOT) {
2563     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2564     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2565   }
2566 #endif
2567 }
2568 
2569 uint SharedRuntime::out_preserve_stack_slots() {
2570   return 0;
2571 }
2572 
2573 #if COMPILER2_OR_JVMCI
2574 //------------------------------generate_uncommon_trap_blob--------------------
2575 void SharedRuntime::generate_uncommon_trap_blob() {
2576   // Allocate space for the code
2577   ResourceMark rm;
2578   // Setup code generation tools
2579   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2580   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2581 
2582   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2583 
2584   address start = __ pc();
2585 
2586   // Push self-frame.  We get here with a return address in LR
2587   // and sp should be 16 byte aligned
2588   // push rfp and retaddr by hand
2589   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2590   // we don&#39;t expect an arg reg save area
2591 #ifndef PRODUCT
2592   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2593 #endif
2594   // compiler left unloaded_class_index in j_rarg0 move to where the
2595   // runtime expects it.
2596   if (c_rarg1 != j_rarg0) {
2597     __ movw(c_rarg1, j_rarg0);
2598   }
2599 
2600   // we need to set the past SP to the stack pointer of the stub frame
2601   // and the pc to the address where this runtime call will return
2602   // although actually any pc in this code blob will do).
2603   Label retaddr;
2604   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2605 
2606   // Call C code.  Need thread but NOT official VM entry
2607   // crud.  We cannot block on this call, no GC can happen.  Call should
2608   // capture callee-saved registers as well as return values.
2609   // Thread is in rdi already.
2610   //
2611   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2612   //
2613   // n.b. 2 gp args, 0 fp args, integral return type
2614 
2615   __ mov(c_rarg0, rthread);
2616   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2617   __ lea(rscratch1,
2618          RuntimeAddress(CAST_FROM_FN_PTR(address,
2619                                          Deoptimization::uncommon_trap)));
2620   __ blr(rscratch1);
2621   __ bind(retaddr);
2622 
2623   // Set an oopmap for the call site
2624   OopMapSet* oop_maps = new OopMapSet();
2625   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2626 
2627   // location of rfp is known implicitly by the frame sender code
2628 
2629   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2630 
2631   __ reset_last_Java_frame(false);
2632 
2633   // move UnrollBlock* into r4
2634   __ mov(r4, r0);
2635 
2636 #ifdef ASSERT
2637   { Label L;
2638     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2639     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2640     __ br(Assembler::EQ, L);
2641     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2642     __ bind(L);
2643   }
2644 #endif
2645 
2646   // Pop all the frames we must move/replace.
2647   //
2648   // Frame picture (youngest to oldest)
2649   // 1: self-frame (no frame link)
2650   // 2: deopting frame  (no frame link)
2651   // 3: caller of deopting frame (could be compiled/interpreted).
2652 
2653   // Pop self-frame.  We have no frame, and must rely only on r0 and sp.
2654   __ add(sp, sp, (SimpleRuntimeFrame::framesize) &lt;&lt; LogBytesPerInt); // Epilog!
2655 
2656   // Pop deoptimized frame (int)
2657   __ ldrw(r2, Address(r4,
2658                       Deoptimization::UnrollBlock::
2659                       size_of_deoptimized_frame_offset_in_bytes()));
2660   __ sub(r2, r2, 2 * wordSize);
2661   __ add(sp, sp, r2);
2662   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2663   // LR should now be the return address to the caller (3) frame
2664 
2665 #ifdef ASSERT
2666   // Compilers generate code that bang the stack by as much as the
2667   // interpreter would need. So this stack banging should never
2668   // trigger a fault. Verify that it does not on non product builds.
2669   if (UseStackBanging) {
2670     __ ldrw(r1, Address(r4,
2671                         Deoptimization::UnrollBlock::
2672                         total_frame_sizes_offset_in_bytes()));
2673     __ bang_stack_size(r1, r2);
2674   }
2675 #endif
2676 
2677   // Load address of array of frame pcs into r2 (address*)
2678   __ ldr(r2, Address(r4,
2679                      Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2680 
2681   // Load address of array of frame sizes into r5 (intptr_t*)
2682   __ ldr(r5, Address(r4,
2683                      Deoptimization::UnrollBlock::
2684                      frame_sizes_offset_in_bytes()));
2685 
2686   // Counter
2687   __ ldrw(r3, Address(r4,
2688                       Deoptimization::UnrollBlock::
2689                       number_of_frames_offset_in_bytes())); // (int)
2690 
2691   // Now adjust the caller&#39;s stack to make up for the extra locals but
2692   // record the original sp so that we can save it in the skeletal
2693   // interpreter frame and the stack walking of interpreter_sender
2694   // will get the unextended sp value and not the &quot;real&quot; sp value.
2695 
2696   const Register sender_sp = r8;
2697 
2698   __ mov(sender_sp, sp);
2699   __ ldrw(r1, Address(r4,
2700                       Deoptimization::UnrollBlock::
2701                       caller_adjustment_offset_in_bytes())); // (int)
2702   __ sub(sp, sp, r1);
2703 
2704   // Push interpreter frames in a loop
2705   Label loop;
2706   __ bind(loop);
2707   __ ldr(r1, Address(r5, 0));       // Load frame size
2708   __ sub(r1, r1, 2 * wordSize);     // We&#39;ll push pc and rfp by hand
2709   __ ldr(lr, Address(r2, 0));       // Save return address
2710   __ enter();                       // and old rfp &amp; set new rfp
2711   __ sub(sp, sp, r1);               // Prolog
2712   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2713   // This value is corrected by layout_activation_impl
2714   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2715   __ mov(sender_sp, sp);          // Pass sender_sp to next frame
2716   __ add(r5, r5, wordSize);       // Bump array pointer (sizes)
2717   __ add(r2, r2, wordSize);       // Bump array pointer (pcs)
2718   __ subsw(r3, r3, 1);            // Decrement counter
2719   __ br(Assembler::GT, loop);
2720   __ ldr(lr, Address(r2, 0));     // save final return address
2721   // Re-push self-frame
2722   __ enter();                     // &amp; old rfp &amp; set new rfp
2723 
2724   // Use rfp because the frames look interpreted now
2725   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2726   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2727   address the_pc = __ pc();
2728   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2729 
2730   // Call C code.  Need thread but NOT official VM entry
2731   // crud.  We cannot block on this call, no GC can happen.  Call should
2732   // restore return values to their stack-slots with the new SP.
2733   // Thread is in rdi already.
2734   //
2735   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2736   //
2737   // n.b. 2 gp args, 0 fp args, integral return type
2738 
2739   // sp should already be aligned
2740   __ mov(c_rarg0, rthread);
2741   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2742   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2743   __ blr(rscratch1);
2744 
2745   // Set an oopmap for the call site
2746   // Use the same PC we used for the last java frame
2747   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
2748 
2749   // Clear fp AND pc
2750   __ reset_last_Java_frame(true);
2751 
2752   // Pop self-frame.
2753   __ leave();                 // Epilog
2754 
2755   // Jump to interpreter
2756   __ ret(lr);
2757 
2758   // Make sure all code is generated
2759   masm-&gt;flush();
2760 
2761   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
2762                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
2763 }
2764 #endif // COMPILER2_OR_JVMCI
2765 
2766 
2767 //------------------------------generate_handler_blob------
2768 //
2769 // Generate a special Compile2Runtime blob that saves all registers,
2770 // and setup oopmap.
2771 //
2772 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
2773   ResourceMark rm;
2774   OopMapSet *oop_maps = new OopMapSet();
2775   OopMap* map;
2776 
2777   // Allocate space for the code.  Setup code generation tools.
2778   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
2779   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2780 
2781   address start   = __ pc();
2782   address call_pc = NULL;
2783   int frame_size_in_words;
2784   bool cause_return = (poll_type == POLL_AT_RETURN);
2785   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
2786 
2787   // Save Integer and Float registers.
2788   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
2789 
2790   // The following is basically a call_VM.  However, we need the precise
2791   // address of the call in order to generate an oopmap. Hence, we do all the
2792   // work outselves.
2793 
2794   Label retaddr;
2795   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2796 
2797   // The return address must always be correct so that frame constructor never
2798   // sees an invalid pc.
2799 
2800   if (!cause_return) {
2801     // overwrite the return address pushed by save_live_registers
2802     // Additionally, r20 is a callee-saved register so we can look at
2803     // it later to determine if someone changed the return address for
2804     // us!
2805     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
2806     __ str(r20, Address(rfp, wordSize));
2807   }
2808 
2809   // Do the call
2810   __ mov(c_rarg0, rthread);
2811   __ lea(rscratch1, RuntimeAddress(call_ptr));
2812   __ blr(rscratch1);
2813   __ bind(retaddr);
2814 
2815   // Set an oopmap for the call site.  This oopmap will map all
2816   // oop-registers and debug-info registers as callee-saved.  This
2817   // will allow deoptimization at this safepoint to find all possible
2818   // debug-info recordings, as well as let GC find all oops.
2819 
2820   oop_maps-&gt;add_gc_map( __ pc() - start, map);
2821 
2822   Label noException;
2823 
2824   __ reset_last_Java_frame(false);
2825 
2826   __ maybe_isb();
2827   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
2828 
2829   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2830   __ cbz(rscratch1, noException);
2831 
2832   // Exception pending
2833 
2834   RegisterSaver::restore_live_registers(masm, save_vectors);
2835 
2836   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2837 
2838   // No exception case
2839   __ bind(noException);
2840 
2841   Label no_adjust, bail;
2842   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
2843     // If our stashed return pc was modified by the runtime we avoid touching it
2844     __ ldr(rscratch1, Address(rfp, wordSize));
2845     __ cmp(r20, rscratch1);
2846     __ br(Assembler::NE, no_adjust);
2847 
2848 #ifdef ASSERT
2849     // Verify the correct encoding of the poll we&#39;re about to skip.
2850     // See NativeInstruction::is_ldrw_to_zr()
2851     __ ldrw(rscratch1, Address(r20));
2852     __ ubfx(rscratch2, rscratch1, 22, 10);
2853     __ cmpw(rscratch2, 0b1011100101);
2854     __ br(Assembler::NE, bail);
2855     __ ubfx(rscratch2, rscratch1, 0, 5);
2856     __ cmpw(rscratch2, 0b11111);
2857     __ br(Assembler::NE, bail);
2858 #endif
2859     // Adjust return pc forward to step over the safepoint poll instruction
2860     __ add(r20, r20, NativeInstruction::instruction_size);
2861     __ str(r20, Address(rfp, wordSize));
2862   }
2863 
2864   __ bind(no_adjust);
2865   // Normal exit, restore registers and exit.
2866   RegisterSaver::restore_live_registers(masm, save_vectors);
2867 
2868   __ ret(lr);
2869 
2870 #ifdef ASSERT
2871   __ bind(bail);
2872   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
2873 #endif
2874 
2875   // Make sure all code is generated
2876   masm-&gt;flush();
2877 
2878   // Fill-out other meta info
2879   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
2880 }
2881 
2882 //
2883 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
2884 //
2885 // Generate a stub that calls into vm to find out the proper destination
2886 // of a java call. All the argument registers are live at this point
2887 // but since this is generic code we don&#39;t know what they are and the caller
2888 // must do any gc of the args.
2889 //
2890 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
2891   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
2892 
2893   // allocate space for the code
2894   ResourceMark rm;
2895 
2896   CodeBuffer buffer(name, 1000, 512);
2897   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
2898 
2899   int frame_size_in_words;
2900 
2901   OopMapSet *oop_maps = new OopMapSet();
2902   OopMap* map = NULL;
2903 
2904   int start = __ offset();
2905 
2906   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2907 
2908   int frame_complete = __ offset();
2909 
2910   {
2911     Label retaddr;
2912     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2913 
2914     __ mov(c_rarg0, rthread);
2915     __ lea(rscratch1, RuntimeAddress(destination));
2916 
2917     __ blr(rscratch1);
2918     __ bind(retaddr);
2919   }
2920 
2921   // Set an oopmap for the call site.
2922   // We need this not only for callee-saved registers, but also for volatile
2923   // registers that the compiler might be keeping live across a safepoint.
2924 
2925   oop_maps-&gt;add_gc_map( __ offset() - start, map);
2926 
2927   __ maybe_isb();
2928 
2929   // r0 contains the address we are going to jump to assuming no exception got installed
2930 
2931   // clear last_Java_sp
2932   __ reset_last_Java_frame(false);
2933   // check for pending exceptions
2934   Label pending;
2935   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2936   __ cbnz(rscratch1, pending);
2937 
2938   // get the returned Method*
2939   __ get_vm_result_2(rmethod, rthread);
2940   __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));
2941 
2942   // r0 is where we want to jump, overwrite rscratch1 which is saved and scratch
2943   __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));
2944   RegisterSaver::restore_live_registers(masm);
2945 
2946   // We are back the the original state on entry and ready to go.
2947 
2948   __ br(rscratch1);
2949 
2950   // Pending exception after the safepoint
2951 
2952   __ bind(pending);
2953 
2954   RegisterSaver::restore_live_registers(masm);
2955 
2956   // exception pending =&gt; remove activation and forward to exception handler
2957 
2958   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
2959 
2960   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
2961   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2962 
2963   // -------------
2964   // make sure all code is generated
2965   masm-&gt;flush();
2966 
2967   // return the  blob
2968   // frame_size_words or bytes??
2969   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
2970 }
2971 
2972 #if COMPILER2_OR_JVMCI
2973 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
2974 //
2975 //------------------------------generate_exception_blob---------------------------
2976 // creates exception blob at the end
2977 // Using exception blob, this code is jumped from a compiled method.
2978 // (see emit_exception_handler in x86_64.ad file)
2979 //
2980 // Given an exception pc at a call we call into the runtime for the
2981 // handler in this method. This handler might merely restore state
2982 // (i.e. callee save registers) unwind the frame and jump to the
2983 // exception handler for the nmethod if there is no Java level handler
2984 // for the nmethod.
2985 //
2986 // This code is entered with a jmp.
2987 //
2988 // Arguments:
2989 //   r0: exception oop
2990 //   r3: exception pc
2991 //
2992 // Results:
2993 //   r0: exception oop
2994 //   r3: exception pc in caller or ???
2995 //   destination: exception handler of caller
2996 //
2997 // Note: the exception pc MUST be at a call (precise debug information)
2998 //       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.
2999 //
3000 
3001 void OptoRuntime::generate_exception_blob() {
3002   assert(!OptoRuntime::is_callee_saved_register(R3_num), &quot;&quot;);
3003   assert(!OptoRuntime::is_callee_saved_register(R0_num), &quot;&quot;);
3004   assert(!OptoRuntime::is_callee_saved_register(R2_num), &quot;&quot;);
3005 
3006   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3007 
3008   // Allocate space for the code
3009   ResourceMark rm;
3010   // Setup code generation tools
3011   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
3012   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3013 
3014   // TODO check various assumptions made here
3015   //
3016   // make sure we do so before running this
3017 
3018   address start = __ pc();
3019 
3020   // push rfp and retaddr by hand
3021   // Exception pc is &#39;return address&#39; for stack walker
3022   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
3023   // there are no callee save registers and we don&#39;t expect an
3024   // arg reg save area
3025 #ifndef PRODUCT
3026   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
3027 #endif
3028   // Store exception in Thread object. We cannot pass any arguments to the
3029   // handle_exception call, since we do not want to make any assumption
3030   // about the size of the frame where the exception happened in.
3031   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
3032   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3033 
3034   // This call does all the hard work.  It checks if an exception handler
3035   // exists in the method.
3036   // If so, it returns the handler address.
3037   // If not, it prepares for stack-unwinding, restoring the callee-save
3038   // registers of the frame being removed.
3039   //
3040   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3041   //
3042   // n.b. 1 gp arg, 0 fp args, integral return type
3043 
3044   // the stack should always be aligned
3045   address the_pc = __ pc();
3046   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3047   __ mov(c_rarg0, rthread);
3048   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
3049   __ blr(rscratch1);
3050   __ maybe_isb();
3051 
3052   // Set an oopmap for the call site.  This oopmap will only be used if we
3053   // are unwinding the stack.  Hence, all locations will be dead.
3054   // Callee-saved registers will be the same as the frame above (i.e.,
3055   // handle_exception_stub), since they were restored when we got the
3056   // exception.
3057 
3058   OopMapSet* oop_maps = new OopMapSet();
3059 
3060   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3061 
3062   __ reset_last_Java_frame(false);
3063 
3064   // Restore callee-saved registers
3065 
3066   // rfp is an implicitly saved callee saved register (i.e. the calling
3067   // convention will save restore it in prolog/epilog) Other than that
3068   // there are no callee save registers now that adapter frames are gone.
3069   // and we dont&#39; expect an arg reg save area
3070   __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));
3071 
3072   // r0: exception handler
3073 
3074   // We have a handler in r0 (could be deopt blob).
3075   __ mov(r8, r0);
3076 
3077   // Get the exception oop
3078   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
3079   // Get the exception pc in case we are deoptimized
3080   __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));
3081 #ifdef ASSERT
3082   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3083   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3084 #endif
3085   // Clear the exception oop so GC no longer processes it as a root.
3086   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3087 
3088   // r0: exception oop
3089   // r8:  exception handler
3090   // r4: exception pc
3091   // Jump to handler
3092 
3093   __ br(r8);
3094 
3095   // Make sure all code is generated
3096   masm-&gt;flush();
3097 
3098   // Set exception blob
3099   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3100 }
3101 #endif // COMPILER2_OR_JVMCI
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
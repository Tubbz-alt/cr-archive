<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 688   leave();
 689   // If we&#39;re returning to interpreted code we will shortly be
 690   // adjusting SP to allow some space for ESP.  If we&#39;re returning to
 691   // compiled code the saved sender SP was saved in sender_sp, so this
 692   // restores it.
 693   andr(sp, esp, -16);
 694 }
 695 
 696 // Lock object
 697 //
 698 // Args:
 699 //      c_rarg1: BasicObjectLock to be used for locking
 700 //
 701 // Kills:
 702 //      r0
 703 //      c_rarg0, c_rarg1, c_rarg2, c_rarg3, .. (param regs)
 704 //      rscratch1, rscratch2 (scratch regs)
 705 void InterpreterMacroAssembler::lock_object(Register lock_reg)
 706 {
 707   assert(lock_reg == c_rarg1, &quot;The argument is only for looks. It must be c_rarg1&quot;);



 708   if (UseHeavyMonitors) {
 709     call_VM(noreg,
 710             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
 711             lock_reg);
 712   } else {
 713     Label done;
 714 
 715     const Register swap_reg = r0;
 716     const Register tmp = c_rarg2;
 717     const Register obj_reg = c_rarg3; // Will contain the oop
 718 
 719     const int obj_offset = BasicObjectLock::obj_offset_in_bytes();
 720     const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();
 721     const int mark_offset = lock_offset +
 722                             BasicLock::displaced_header_offset_in_bytes();
 723 
 724     Label slow_case;
 725 
 726     // Load object pointer into obj_reg %c_rarg3
 727     ldr(obj_reg, Address(lock_reg, obj_offset));
</pre>
<hr />
<pre>
 770 
 771     // Save the test result, for recursive case, the result is zero
 772     str(swap_reg, Address(lock_reg, mark_offset));
 773 
 774     if (PrintBiasedLockingStatistics) {
 775       br(Assembler::NE, slow_case);
 776       atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),
 777                   rscratch2, rscratch1, tmp);
 778     }
 779     br(Assembler::EQ, done);
 780 
 781     bind(slow_case);
 782 
 783     // Call the runtime routine for slow case
 784     call_VM(noreg,
 785             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
 786             lock_reg);
 787 
 788     bind(done);
 789   }









 790 }
 791 
 792 
 793 // Unlocks an object. Used in monitorexit bytecode and
 794 // remove_activation.  Throws an IllegalMonitorException if object is
 795 // not locked by current thread.
 796 //
 797 // Args:
 798 //      c_rarg1: BasicObjectLock for lock
 799 //
 800 // Kills:
 801 //      r0
 802 //      c_rarg0, c_rarg1, c_rarg2, c_rarg3, ... (param regs)
 803 //      rscratch1, rscratch2 (scratch regs)
 804 void InterpreterMacroAssembler::unlock_object(Register lock_reg)
 805 {
 806   assert(lock_reg == c_rarg1, &quot;The argument is only for looks. It must be rarg1&quot;);
 807 








 808   if (UseHeavyMonitors) {
 809     call_VM(noreg,
 810             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),
 811             lock_reg);
 812   } else {
 813     Label done;
 814 
 815     const Register swap_reg   = r0;
 816     const Register header_reg = c_rarg2;  // Will contain the old oopMark
 817     const Register obj_reg    = c_rarg3;  // Will contain the oop
 818 
 819     save_bcp(); // Save in case of exception
 820 
 821     // Convert from BasicObjectLock structure to object and BasicLock
 822     // structure Store the BasicLock address into %r0
 823     lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));
 824 
 825     // Load oop into obj_reg(%c_rarg3)
 826     ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));
 827 
</pre>
</td>
<td>
<hr />
<pre>
 688   leave();
 689   // If we&#39;re returning to interpreted code we will shortly be
 690   // adjusting SP to allow some space for ESP.  If we&#39;re returning to
 691   // compiled code the saved sender SP was saved in sender_sp, so this
 692   // restores it.
 693   andr(sp, esp, -16);
 694 }
 695 
 696 // Lock object
 697 //
 698 // Args:
 699 //      c_rarg1: BasicObjectLock to be used for locking
 700 //
 701 // Kills:
 702 //      r0
 703 //      c_rarg0, c_rarg1, c_rarg2, c_rarg3, .. (param regs)
 704 //      rscratch1, rscratch2 (scratch regs)
 705 void InterpreterMacroAssembler::lock_object(Register lock_reg)
 706 {
 707   assert(lock_reg == c_rarg1, &quot;The argument is only for looks. It must be c_rarg1&quot;);
<span class="line-added"> 708 </span>
<span class="line-added"> 709   TSAN_RUNTIME_ONLY(push_ptr(lock_reg));</span>
<span class="line-added"> 710 </span>
 711   if (UseHeavyMonitors) {
 712     call_VM(noreg,
 713             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
 714             lock_reg);
 715   } else {
 716     Label done;
 717 
 718     const Register swap_reg = r0;
 719     const Register tmp = c_rarg2;
 720     const Register obj_reg = c_rarg3; // Will contain the oop
 721 
 722     const int obj_offset = BasicObjectLock::obj_offset_in_bytes();
 723     const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();
 724     const int mark_offset = lock_offset +
 725                             BasicLock::displaced_header_offset_in_bytes();
 726 
 727     Label slow_case;
 728 
 729     // Load object pointer into obj_reg %c_rarg3
 730     ldr(obj_reg, Address(lock_reg, obj_offset));
</pre>
<hr />
<pre>
 773 
 774     // Save the test result, for recursive case, the result is zero
 775     str(swap_reg, Address(lock_reg, mark_offset));
 776 
 777     if (PrintBiasedLockingStatistics) {
 778       br(Assembler::NE, slow_case);
 779       atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),
 780                   rscratch2, rscratch1, tmp);
 781     }
 782     br(Assembler::EQ, done);
 783 
 784     bind(slow_case);
 785 
 786     // Call the runtime routine for slow case
 787     call_VM(noreg,
 788             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
 789             lock_reg);
 790 
 791     bind(done);
 792   }
<span class="line-added"> 793 </span>
<span class="line-added"> 794   TSAN_RUNTIME_ONLY(</span>
<span class="line-added"> 795     pop_ptr(lock_reg);</span>
<span class="line-added"> 796     pusha();</span>
<span class="line-added"> 797     call_VM(noreg,</span>
<span class="line-added"> 798             CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),</span>
<span class="line-added"> 799             lock_reg);</span>
<span class="line-added"> 800     popa();</span>
<span class="line-added"> 801   );</span>
 802 }
 803 
 804 
 805 // Unlocks an object. Used in monitorexit bytecode and
 806 // remove_activation.  Throws an IllegalMonitorException if object is
 807 // not locked by current thread.
 808 //
 809 // Args:
 810 //      c_rarg1: BasicObjectLock for lock
 811 //
 812 // Kills:
 813 //      r0
 814 //      c_rarg0, c_rarg1, c_rarg2, c_rarg3, ... (param regs)
 815 //      rscratch1, rscratch2 (scratch regs)
 816 void InterpreterMacroAssembler::unlock_object(Register lock_reg)
 817 {
 818   assert(lock_reg == c_rarg1, &quot;The argument is only for looks. It must be rarg1&quot;);
 819 
<span class="line-added"> 820   TSAN_RUNTIME_ONLY(</span>
<span class="line-added"> 821     pusha();</span>
<span class="line-added"> 822     call_VM(noreg,</span>
<span class="line-added"> 823             CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),</span>
<span class="line-added"> 824             lock_reg);</span>
<span class="line-added"> 825     popa();</span>
<span class="line-added"> 826   );</span>
<span class="line-added"> 827 </span>
 828   if (UseHeavyMonitors) {
 829     call_VM(noreg,
 830             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),
 831             lock_reg);
 832   } else {
 833     Label done;
 834 
 835     const Register swap_reg   = r0;
 836     const Register header_reg = c_rarg2;  // Will contain the old oopMark
 837     const Register obj_reg    = c_rarg3;  // Will contain the oop
 838 
 839     save_bcp(); // Save in case of exception
 840 
 841     // Convert from BasicObjectLock structure to object and BasicLock
 842     // structure Store the BasicLock address into %r0
 843     lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset_in_bytes()));
 844 
 845     // Load oop into obj_reg(%c_rarg3)
 846     ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()));
 847 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
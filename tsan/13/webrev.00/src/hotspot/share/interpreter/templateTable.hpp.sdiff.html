<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/templateTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/interpreter/templateTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
343   friend class InterpreterMacroAssembler;
344 
345  public:
346   // Initialization
347   static void initialize();
348   static void pd_initialize();
349 
350   // Templates
351   static Template* template_for     (Bytecodes::Code code)  { Bytecodes::check     (code); return &amp;_template_table     [code]; }
352   static Template* template_for_wide(Bytecodes::Code code)  { Bytecodes::wide_check(code); return &amp;_template_table_wide[code]; }
353 
354 #if INCLUDE_TSAN
355    typedef void (*TsanMemoryReleaseAcquireFunction)(void* /* address */);
356 
357    typedef void (*TsanMemoryReadWriteFunction)(void* /* address */,
358                                                Method* /* method */,
359                                                address /* bcp */);
360 
361    // The corresponding tsan_acquire/release function for a
362    // TsanMemoryReadWriteFunction.
<span class="line-modified">363    static TsanMemoryReleaseAcquireFunction tsan_release_acquire_method(</span>
<span class="line-removed">364        TsanMemoryReadWriteFunction tsan_function);</span>
365 
366    // Tell tsan that a member/static variable has been read from or written to.
367    // tsan_function must be one of the SharedRuntime::tsan_read/write*
368    // functions.
369    // Flags is the register that contains the field cache entry flags bitfield.
370    // Because the field may be volatile, for a write, this function must be
371    // called before the write; for a read, this function must be called after
372    // the read. This way the acquire/release is ordered correctly relative to the
373    // read/write.
<span class="line-modified">374    static void tsan_observe_get_or_put(</span>
<span class="line-modified">375        const Address &amp;field,</span>
<span class="line-modified">376        Register flags,</span>
<span class="line-modified">377        TsanMemoryReadWriteFunction tsan_function,</span>
<span class="line-removed">378        TosState tos);</span>
379 
380    // Tell tsan that an array has been read from or written to.
381    // tsan_function must be one of the SharedRuntime::tsan_read/write*
382    // functions.
383    // Unlike tsan_observe_get_or_put(), the ordering relative to the
384    // read/write does not matter since array loads/stores are never volatile.
<span class="line-modified">385    static void tsan_observe_load_or_store(</span>
<span class="line-modified">386        const Address&amp; address,</span>
<span class="line-removed">387        TsanMemoryReadWriteFunction tsan_function);</span>
388 #endif
389 
390   // Platform specifics
391 #include CPU_HEADER(templateTable)
392 
393 };
394 #endif /* !CC_INTERP */
395 
396 #endif // SHARE_INTERPRETER_TEMPLATETABLE_HPP
</pre>
</td>
<td>
<hr />
<pre>
343   friend class InterpreterMacroAssembler;
344 
345  public:
346   // Initialization
347   static void initialize();
348   static void pd_initialize();
349 
350   // Templates
351   static Template* template_for     (Bytecodes::Code code)  { Bytecodes::check     (code); return &amp;_template_table     [code]; }
352   static Template* template_for_wide(Bytecodes::Code code)  { Bytecodes::wide_check(code); return &amp;_template_table_wide[code]; }
353 
354 #if INCLUDE_TSAN
355    typedef void (*TsanMemoryReleaseAcquireFunction)(void* /* address */);
356 
357    typedef void (*TsanMemoryReadWriteFunction)(void* /* address */,
358                                                Method* /* method */,
359                                                address /* bcp */);
360 
361    // The corresponding tsan_acquire/release function for a
362    // TsanMemoryReadWriteFunction.
<span class="line-modified">363    static TsanMemoryReleaseAcquireFunction tsan_release_acquire_method(TsanMemoryReadWriteFunction tsan_function);</span>

364 
365    // Tell tsan that a member/static variable has been read from or written to.
366    // tsan_function must be one of the SharedRuntime::tsan_read/write*
367    // functions.
368    // Flags is the register that contains the field cache entry flags bitfield.
369    // Because the field may be volatile, for a write, this function must be
370    // called before the write; for a read, this function must be called after
371    // the read. This way the acquire/release is ordered correctly relative to the
372    // read/write.
<span class="line-modified">373    static void tsan_observe_get_or_put(const Address &amp;field,</span>
<span class="line-modified">374                                        Register flags,</span>
<span class="line-modified">375                                        TsanMemoryReadWriteFunction tsan_function,</span>
<span class="line-modified">376                                        TosState tos);</span>

377 
378    // Tell tsan that an array has been read from or written to.
379    // tsan_function must be one of the SharedRuntime::tsan_read/write*
380    // functions.
381    // Unlike tsan_observe_get_or_put(), the ordering relative to the
382    // read/write does not matter since array loads/stores are never volatile.
<span class="line-modified">383    static void tsan_observe_load_or_store(const Address&amp; address,</span>
<span class="line-modified">384                                           TsanMemoryReadWriteFunction tsan_function);</span>

385 #endif
386 
387   // Platform specifics
388 #include CPU_HEADER(templateTable)
389 
390 };
391 #endif /* !CC_INTERP */
392 
393 #endif // SHARE_INTERPRETER_TEMPLATETABLE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/aarch64/templateTable_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
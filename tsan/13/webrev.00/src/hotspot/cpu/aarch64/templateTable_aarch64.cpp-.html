<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/method.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 // Platform-dependent initialization
  48 
  49 void TemplateTable::pd_initialize() {
  50   // No aarch64 specific initialization
  51 }
  52 
  53 // Address computation: local variables
  54 
  55 static inline Address iaddress(int n) {
  56   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  57 }
  58 
  59 static inline Address laddress(int n) {
  60   return iaddress(n + 1);
  61 }
  62 
  63 static inline Address faddress(int n) {
  64   return iaddress(n);
  65 }
  66 
  67 static inline Address daddress(int n) {
  68   return laddress(n);
  69 }
  70 
  71 static inline Address aaddress(int n) {
  72   return iaddress(n);
  73 }
  74 
  75 static inline Address iaddress(Register r) {
  76   return Address(rlocals, r, Address::lsl(3));
  77 }
  78 
  79 static inline Address laddress(Register r, Register scratch,
  80                                InterpreterMacroAssembler* _masm) {
  81   __ lea(scratch, Address(rlocals, r, Address::lsl(3)));
  82   return Address(scratch, Interpreter::local_offset_in_bytes(1));
  83 }
  84 
  85 static inline Address faddress(Register r) {
  86   return iaddress(r);
  87 }
  88 
  89 static inline Address daddress(Register r, Register scratch,
  90                                InterpreterMacroAssembler* _masm) {
  91   return laddress(r, scratch, _masm);
  92 }
  93 
  94 static inline Address aaddress(Register r) {
  95   return iaddress(r);
  96 }
  97 
  98 static inline Address at_rsp() {
  99   return Address(esp, 0);
 100 }
 101 
 102 // At top of Java expression stack which may be different than esp().  It
 103 // isn&#39;t for category 1 objects.
 104 static inline Address at_tos   () {
 105   return Address(esp,  Interpreter::expr_offset_in_bytes(0));
 106 }
 107 
 108 static inline Address at_tos_p1() {
 109   return Address(esp,  Interpreter::expr_offset_in_bytes(1));
 110 }
 111 
 112 static inline Address at_tos_p2() {
 113   return Address(esp,  Interpreter::expr_offset_in_bytes(2));
 114 }
 115 
 116 static inline Address at_tos_p3() {
 117   return Address(esp,  Interpreter::expr_offset_in_bytes(3));
 118 }
 119 
 120 static inline Address at_tos_p4() {
 121   return Address(esp,  Interpreter::expr_offset_in_bytes(4));
 122 }
 123 
 124 static inline Address at_tos_p5() {
 125   return Address(esp,  Interpreter::expr_offset_in_bytes(5));
 126 }
 127 
 128 // Condition conversion
 129 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 130   switch (cc) {
 131   case TemplateTable::equal        : return Assembler::NE;
 132   case TemplateTable::not_equal    : return Assembler::EQ;
 133   case TemplateTable::less         : return Assembler::GE;
 134   case TemplateTable::less_equal   : return Assembler::GT;
 135   case TemplateTable::greater      : return Assembler::LE;
 136   case TemplateTable::greater_equal: return Assembler::LT;
 137   }
 138   ShouldNotReachHere();
 139   return Assembler::EQ;
 140 }
 141 
 142 
 143 // Miscelaneous helper routines
 144 // Store an oop (or NULL) at the Address described by obj.
 145 // If val == noreg this means store a NULL
 146 static void do_oop_store(InterpreterMacroAssembler* _masm,
 147                          Address dst,
 148                          Register val,
 149                          DecoratorSet decorators) {
 150   assert(val == noreg || val == r0, &quot;parameter is just for looks&quot;);
 151   __ store_heap_oop(dst, val, r10, r1, decorators);
 152 }
 153 
 154 static void do_oop_load(InterpreterMacroAssembler* _masm,
 155                         Address src,
 156                         Register dst,
 157                         DecoratorSet decorators) {
 158   __ load_heap_oop(dst, src, r10, r1, decorators);
 159 }
 160 
 161 Address TemplateTable::at_bcp(int offset) {
 162   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 163   return Address(rbcp, offset);
 164 }
 165 
 166 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 167                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 168                                    int byte_no)
 169 {
 170   if (!RewriteBytecodes)  return;
 171   Label L_patch_done;
 172 
 173   switch (bc) {
 174   case Bytecodes::_fast_aputfield:
 175   case Bytecodes::_fast_bputfield:
 176   case Bytecodes::_fast_zputfield:
 177   case Bytecodes::_fast_cputfield:
 178   case Bytecodes::_fast_dputfield:
 179   case Bytecodes::_fast_fputfield:
 180   case Bytecodes::_fast_iputfield:
 181   case Bytecodes::_fast_lputfield:
 182   case Bytecodes::_fast_sputfield:
 183     {
 184       // We skip bytecode quickening for putfield instructions when
 185       // the put_code written to the constant pool cache is zero.
 186       // This is required so that every execution of this instruction
 187       // calls out to InterpreterRuntime::resolve_get_put to do
 188       // additional, required work.
 189       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 190       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 191       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 192       __ movw(bc_reg, bc);
 193       __ cbzw(temp_reg, L_patch_done);  // don&#39;t patch
 194     }
 195     break;
 196   default:
 197     assert(byte_no == -1, &quot;sanity&quot;);
 198     // the pair bytecodes have already done the load.
 199     if (load_bc_into_bc_reg) {
 200       __ movw(bc_reg, bc);
 201     }
 202   }
 203 
 204   if (JvmtiExport::can_post_breakpoint()) {
 205     Label L_fast_patch;
 206     // if a breakpoint is present we can&#39;t rewrite the stream directly
 207     __ load_unsigned_byte(temp_reg, at_bcp(0));
 208     __ cmpw(temp_reg, Bytecodes::_breakpoint);
 209     __ br(Assembler::NE, L_fast_patch);
 210     // Let breakpoint table handling rewrite to quicker bytecode
 211     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), rmethod, rbcp, bc_reg);
 212     __ b(L_patch_done);
 213     __ bind(L_fast_patch);
 214   }
 215 
 216 #ifdef ASSERT
 217   Label L_okay;
 218   __ load_unsigned_byte(temp_reg, at_bcp(0));
 219   __ cmpw(temp_reg, (int) Bytecodes::java_code(bc));
 220   __ br(Assembler::EQ, L_okay);
 221   __ cmpw(temp_reg, bc_reg);
 222   __ br(Assembler::EQ, L_okay);
 223   __ stop(&quot;patching the wrong bytecode&quot;);
 224   __ bind(L_okay);
 225 #endif
 226 
 227   // patch bytecode
 228   __ strb(bc_reg, at_bcp(0));
 229   __ bind(L_patch_done);
 230 }
 231 
 232 
 233 // Individual instructions
 234 
 235 void TemplateTable::nop() {
 236   transition(vtos, vtos);
 237   // nothing to do
 238 }
 239 
 240 void TemplateTable::shouldnotreachhere() {
 241   transition(vtos, vtos);
 242   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 243 }
 244 
 245 void TemplateTable::aconst_null()
 246 {
 247   transition(vtos, atos);
 248   __ mov(r0, 0);
 249 }
 250 
 251 void TemplateTable::iconst(int value)
 252 {
 253   transition(vtos, itos);
 254   __ mov(r0, value);
 255 }
 256 
 257 void TemplateTable::lconst(int value)
 258 {
 259   __ mov(r0, value);
 260 }
 261 
 262 void TemplateTable::fconst(int value)
 263 {
 264   transition(vtos, ftos);
 265   switch (value) {
 266   case 0:
 267     __ fmovs(v0, zr);
 268     break;
 269   case 1:
 270     __ fmovs(v0, 1.0);
 271     break;
 272   case 2:
 273     __ fmovs(v0, 2.0);
 274     break;
 275   default:
 276     ShouldNotReachHere();
 277     break;
 278   }
 279 }
 280 
 281 void TemplateTable::dconst(int value)
 282 {
 283   transition(vtos, dtos);
 284   switch (value) {
 285   case 0:
 286     __ fmovd(v0, zr);
 287     break;
 288   case 1:
 289     __ fmovd(v0, 1.0);
 290     break;
 291   case 2:
 292     __ fmovd(v0, 2.0);
 293     break;
 294   default:
 295     ShouldNotReachHere();
 296     break;
 297   }
 298 }
 299 
 300 void TemplateTable::bipush()
 301 {
 302   transition(vtos, itos);
 303   __ load_signed_byte32(r0, at_bcp(1));
 304 }
 305 
 306 void TemplateTable::sipush()
 307 {
 308   transition(vtos, itos);
 309   __ load_unsigned_short(r0, at_bcp(1));
 310   __ revw(r0, r0);
 311   __ asrw(r0, r0, 16);
 312 }
 313 
 314 void TemplateTable::ldc(bool wide)
 315 {
 316   transition(vtos, vtos);
 317   Label call_ldc, notFloat, notClass, notInt, Done;
 318 
 319   if (wide) {
 320     __ get_unsigned_2_byte_index_at_bcp(r1, 1);
 321   } else {
 322     __ load_unsigned_byte(r1, at_bcp(1));
 323   }
 324   __ get_cpool_and_tags(r2, r0);
 325 
 326   const int base_offset = ConstantPool::header_size() * wordSize;
 327   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 328 
 329   // get type
 330   __ add(r3, r1, tags_offset);
 331   __ lea(r3, Address(r0, r3));
 332   __ ldarb(r3, r3);
 333 
 334   // unresolved class - get the resolved class
 335   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClass);
 336   __ br(Assembler::EQ, call_ldc);
 337 
 338   // unresolved class in error state - call into runtime to throw the error
 339   // from the first resolution attempt
 340   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClassInError);
 341   __ br(Assembler::EQ, call_ldc);
 342 
 343   // resolved class - need to call vm to get java mirror of the class
 344   __ cmp(r3, (u1)JVM_CONSTANT_Class);
 345   __ br(Assembler::NE, notClass);
 346 
 347   __ bind(call_ldc);
 348   __ mov(c_rarg1, wide);
 349   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), c_rarg1);
 350   __ push_ptr(r0);
 351   __ verify_oop(r0);
 352   __ b(Done);
 353 
 354   __ bind(notClass);
 355   __ cmp(r3, (u1)JVM_CONSTANT_Float);
 356   __ br(Assembler::NE, notFloat);
 357   // ftos
 358   __ adds(r1, r2, r1, Assembler::LSL, 3);
 359   __ ldrs(v0, Address(r1, base_offset));
 360   __ push_f();
 361   __ b(Done);
 362 
 363   __ bind(notFloat);
 364 
 365   __ cmp(r3, (u1)JVM_CONSTANT_Integer);
 366   __ br(Assembler::NE, notInt);
 367 
 368   // itos
 369   __ adds(r1, r2, r1, Assembler::LSL, 3);
 370   __ ldrw(r0, Address(r1, base_offset));
 371   __ push_i(r0);
 372   __ b(Done);
 373 
 374   __ bind(notInt);
 375   condy_helper(Done);
 376 
 377   __ bind(Done);
 378 }
 379 
 380 // Fast path for caching oop constants.
 381 void TemplateTable::fast_aldc(bool wide)
 382 {
 383   transition(vtos, atos);
 384 
 385   Register result = r0;
 386   Register tmp = r1;
 387   Register rarg = r2;
 388 
 389   int index_size = wide ? sizeof(u2) : sizeof(u1);
 390 
 391   Label resolved;
 392 
 393   // We are resolved if the resolved reference cache entry contains a
 394   // non-null object (String, MethodType, etc.)
 395   assert_different_registers(result, tmp);
 396   __ get_cache_index_at_bcp(tmp, 1, index_size);
 397   __ load_resolved_reference_at_index(result, tmp);
 398   __ cbnz(result, resolved);
 399 
 400   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 401 
 402   // first time invocation - must resolve first
 403   __ mov(rarg, (int)bytecode());
 404   __ call_VM(result, entry, rarg);
 405 
 406   __ bind(resolved);
 407 
 408   { // Check for the null sentinel.
 409     // If we just called the VM, it already did the mapping for us,
 410     // but it&#39;s harmless to retry.
 411     Label notNull;
 412 
 413     // Stash null_sentinel address to get its value later
 414     __ movptr(rarg, (uintptr_t)Universe::the_null_sentinel_addr());
 415     __ ldr(tmp, Address(rarg));
 416     __ cmpoop(result, tmp);
 417     __ br(Assembler::NE, notNull);
 418     __ mov(result, 0);  // NULL object reference
 419     __ bind(notNull);
 420   }
 421 
 422   if (VerifyOops) {
 423     // Safe to call with 0 result
 424     __ verify_oop(result);
 425   }
 426 }
 427 
 428 void TemplateTable::ldc2_w()
 429 {
 430   transition(vtos, vtos);
 431   Label notDouble, notLong, Done;
 432   __ get_unsigned_2_byte_index_at_bcp(r0, 1);
 433 
 434   __ get_cpool_and_tags(r1, r2);
 435   const int base_offset = ConstantPool::header_size() * wordSize;
 436   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 437 
 438   // get type
 439   __ lea(r2, Address(r2, r0, Address::lsl(0)));
 440   __ load_unsigned_byte(r2, Address(r2, tags_offset));
 441   __ cmpw(r2, (int)JVM_CONSTANT_Double);
 442   __ br(Assembler::NE, notDouble);
 443 
 444   // dtos
 445   __ lea (r2, Address(r1, r0, Address::lsl(3)));
 446   __ ldrd(v0, Address(r2, base_offset));
 447   __ push_d();
 448   __ b(Done);
 449 
 450   __ bind(notDouble);
 451   __ cmpw(r2, (int)JVM_CONSTANT_Long);
 452   __ br(Assembler::NE, notLong);
 453 
 454   // ltos
 455   __ lea(r0, Address(r1, r0, Address::lsl(3)));
 456   __ ldr(r0, Address(r0, base_offset));
 457   __ push_l();
 458   __ b(Done);
 459 
 460   __ bind(notLong);
 461   condy_helper(Done);
 462 
 463   __ bind(Done);
 464 }
 465 
 466 void TemplateTable::condy_helper(Label&amp; Done)
 467 {
 468   Register obj = r0;
 469   Register rarg = r1;
 470   Register flags = r2;
 471   Register off = r3;
 472 
 473   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 474 
 475   __ mov(rarg, (int) bytecode());
 476   __ call_VM(obj, entry, rarg);
 477 
 478   __ get_vm_result_2(flags, rthread);
 479 
 480   // VMr = obj = base address to find primitive value to push
 481   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 482   __ mov(off, flags);
 483   __ andw(off, off, ConstantPoolCacheEntry::field_index_mask);
 484 
 485   const Address field(obj, off);
 486 
 487   // What sort of thing are we loading?
 488   // x86 uses a shift and mask or wings it with a shift plus assert
 489   // the mask is not needed. aarch64 just uses bitfield extract
 490   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,
 491            ConstantPoolCacheEntry::tos_state_bits);
 492 
 493   switch (bytecode()) {
 494     case Bytecodes::_ldc:
 495     case Bytecodes::_ldc_w:
 496       {
 497         // tos in (itos, ftos, stos, btos, ctos, ztos)
 498         Label notInt, notFloat, notShort, notByte, notChar, notBool;
 499         __ cmpw(flags, itos);
 500         __ br(Assembler::NE, notInt);
 501         // itos
 502         __ ldrw(r0, field);
 503         __ push(itos);
 504         __ b(Done);
 505 
 506         __ bind(notInt);
 507         __ cmpw(flags, ftos);
 508         __ br(Assembler::NE, notFloat);
 509         // ftos
 510         __ load_float(field);
 511         __ push(ftos);
 512         __ b(Done);
 513 
 514         __ bind(notFloat);
 515         __ cmpw(flags, stos);
 516         __ br(Assembler::NE, notShort);
 517         // stos
 518         __ load_signed_short(r0, field);
 519         __ push(stos);
 520         __ b(Done);
 521 
 522         __ bind(notShort);
 523         __ cmpw(flags, btos);
 524         __ br(Assembler::NE, notByte);
 525         // btos
 526         __ load_signed_byte(r0, field);
 527         __ push(btos);
 528         __ b(Done);
 529 
 530         __ bind(notByte);
 531         __ cmpw(flags, ctos);
 532         __ br(Assembler::NE, notChar);
 533         // ctos
 534         __ load_unsigned_short(r0, field);
 535         __ push(ctos);
 536         __ b(Done);
 537 
 538         __ bind(notChar);
 539         __ cmpw(flags, ztos);
 540         __ br(Assembler::NE, notBool);
 541         // ztos
 542         __ load_signed_byte(r0, field);
 543         __ push(ztos);
 544         __ b(Done);
 545 
 546         __ bind(notBool);
 547         break;
 548       }
 549 
 550     case Bytecodes::_ldc2_w:
 551       {
 552         Label notLong, notDouble;
 553         __ cmpw(flags, ltos);
 554         __ br(Assembler::NE, notLong);
 555         // ltos
 556         __ ldr(r0, field);
 557         __ push(ltos);
 558         __ b(Done);
 559 
 560         __ bind(notLong);
 561         __ cmpw(flags, dtos);
 562         __ br(Assembler::NE, notDouble);
 563         // dtos
 564         __ load_double(field);
 565         __ push(dtos);
 566         __ b(Done);
 567 
 568        __ bind(notDouble);
 569         break;
 570       }
 571 
 572     default:
 573       ShouldNotReachHere();
 574     }
 575 
 576     __ stop(&quot;bad ldc/condy&quot;);
 577 }
 578 
 579 void TemplateTable::locals_index(Register reg, int offset)
 580 {
 581   __ ldrb(reg, at_bcp(offset));
 582   __ neg(reg, reg);
 583 }
 584 
 585 void TemplateTable::iload() {
 586   iload_internal();
 587 }
 588 
 589 void TemplateTable::nofast_iload() {
 590   iload_internal(may_not_rewrite);
 591 }
 592 
 593 void TemplateTable::iload_internal(RewriteControl rc) {
 594   transition(vtos, itos);
 595   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 596     Label rewrite, done;
 597     Register bc = r4;
 598 
 599     // get next bytecode
 600     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 601 
 602     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 603     // last two iloads in a pair.  Comparing against fast_iload means that
 604     // the next bytecode is neither an iload or a caload, and therefore
 605     // an iload pair.
 606     __ cmpw(r1, Bytecodes::_iload);
 607     __ br(Assembler::EQ, done);
 608 
 609     // if _fast_iload rewrite to _fast_iload2
 610     __ cmpw(r1, Bytecodes::_fast_iload);
 611     __ movw(bc, Bytecodes::_fast_iload2);
 612     __ br(Assembler::EQ, rewrite);
 613 
 614     // if _caload rewrite to _fast_icaload
 615     __ cmpw(r1, Bytecodes::_caload);
 616     __ movw(bc, Bytecodes::_fast_icaload);
 617     __ br(Assembler::EQ, rewrite);
 618 
 619     // else rewrite to _fast_iload
 620     __ movw(bc, Bytecodes::_fast_iload);
 621 
 622     // rewrite
 623     // bc: new bytecode
 624     __ bind(rewrite);
 625     patch_bytecode(Bytecodes::_iload, bc, r1, false);
 626     __ bind(done);
 627 
 628   }
 629 
 630   // do iload, get the local value into tos
 631   locals_index(r1);
 632   __ ldr(r0, iaddress(r1));
 633 
 634 }
 635 
 636 void TemplateTable::fast_iload2()
 637 {
 638   transition(vtos, itos);
 639   locals_index(r1);
 640   __ ldr(r0, iaddress(r1));
 641   __ push(itos);
 642   locals_index(r1, 3);
 643   __ ldr(r0, iaddress(r1));
 644 }
 645 
 646 void TemplateTable::fast_iload()
 647 {
 648   transition(vtos, itos);
 649   locals_index(r1);
 650   __ ldr(r0, iaddress(r1));
 651 }
 652 
 653 void TemplateTable::lload()
 654 {
 655   transition(vtos, ltos);
 656   __ ldrb(r1, at_bcp(1));
 657   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 658   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 659 }
 660 
 661 void TemplateTable::fload()
 662 {
 663   transition(vtos, ftos);
 664   locals_index(r1);
 665   // n.b. we use ldrd here because this is a 64 bit slot
 666   // this is comparable to the iload case
 667   __ ldrd(v0, faddress(r1));
 668 }
 669 
 670 void TemplateTable::dload()
 671 {
 672   transition(vtos, dtos);
 673   __ ldrb(r1, at_bcp(1));
 674   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 675   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 676 }
 677 
 678 void TemplateTable::aload()
 679 {
 680   transition(vtos, atos);
 681   locals_index(r1);
 682   __ ldr(r0, iaddress(r1));
 683 }
 684 
 685 void TemplateTable::locals_index_wide(Register reg) {
 686   __ ldrh(reg, at_bcp(2));
 687   __ rev16w(reg, reg);
 688   __ neg(reg, reg);
 689 }
 690 
 691 void TemplateTable::wide_iload() {
 692   transition(vtos, itos);
 693   locals_index_wide(r1);
 694   __ ldr(r0, iaddress(r1));
 695 }
 696 
 697 void TemplateTable::wide_lload()
 698 {
 699   transition(vtos, ltos);
 700   __ ldrh(r1, at_bcp(2));
 701   __ rev16w(r1, r1);
 702   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 703   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 704 }
 705 
 706 void TemplateTable::wide_fload()
 707 {
 708   transition(vtos, ftos);
 709   locals_index_wide(r1);
 710   // n.b. we use ldrd here because this is a 64 bit slot
 711   // this is comparable to the iload case
 712   __ ldrd(v0, faddress(r1));
 713 }
 714 
 715 void TemplateTable::wide_dload()
 716 {
 717   transition(vtos, dtos);
 718   __ ldrh(r1, at_bcp(2));
 719   __ rev16w(r1, r1);
 720   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 721   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 722 }
 723 
 724 void TemplateTable::wide_aload()
 725 {
 726   transition(vtos, atos);
 727   locals_index_wide(r1);
 728   __ ldr(r0, aaddress(r1));
 729 }
 730 
 731 void TemplateTable::index_check(Register array, Register index)
 732 {
 733   // destroys r1, rscratch1
 734   // check array
 735   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 736   // sign extend index for use by indexed load
 737   // __ movl2ptr(index, index);
 738   // check index
 739   Register length = rscratch1;
 740   __ ldrw(length, Address(array, arrayOopDesc::length_offset_in_bytes()));
 741   __ cmpw(index, length);
 742   if (index != r1) {
 743     // ??? convention: move aberrant index into r1 for exception message
 744     assert(r1 != array, &quot;different registers&quot;);
 745     __ mov(r1, index);
 746   }
 747   Label ok;
 748   __ br(Assembler::LO, ok);
 749     // ??? convention: move array into r3 for exception message
 750   __ mov(r3, array);
 751   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 752   __ br(rscratch1);
 753   __ bind(ok);
 754 }
 755 
 756 #if INCLUDE_TSAN
 757 
 758 void TemplateTable::tsan_observe_get_or_put(const Address &amp;field,
 759                                             Register flags,
 760                                             TsanMemoryReadWriteFunction tsan_function,
 761                                             TosState tos) {
 762   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);
 763 
 764   TsanMemoryReleaseAcquireFunction releaseAcquireFunction =
 765       tsan_release_acquire_method(tsan_function);
 766 
 767   Label done, notAcquireRelease;
 768 
 769   // We could save some instructions by only saving the registers we need.
 770   __ pusha();
 771   // pusha() doesn&#39;t save v0, which tsan_function clobbers and the
 772   // interpreter still needs.
 773   // This really only needs to be done for some of the float/double accesses,
 774   // but it&#39;s here because it&#39;s cleaner.
 775   __ push_d(v0);
 776   // For volatile reads/writes use an acquire/release.
 777   // If a reference is annotated to be ignored, assume it&#39;s safe to
 778   // access the object it&#39;s referring to and create a happens-before relation
 779   // between the accesses to this reference.
 780   if (tos == atos) {
 781     int32_t acquire_release_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift |
 782       1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift;
 783     __ mov(rscratch1, acquire_release_mask);
 784     __ tst(flags, rscratch1);
 785     __ br(Assembler::EQ, notAcquireRelease);
 786   } else {
 787     __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);
 788   }
 789 
 790   __ lea(c_rarg0, field);
 791   __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);
 792   if (ThreadSanitizerJavaMemory) {
 793     __ b(done);
 794     __ bind(notAcquireRelease);
 795 
 796     // Ignore reads/writes to final fields. They can&#39;t be racy.
 797     __ tbnz(flags, ConstantPoolCacheEntry::is_final_shift, done);
 798 
 799     // Don&#39;t report races on tsan ignored fields.
 800     __ tbnz(flags, ConstantPoolCacheEntry::is_tsan_ignore_shift, done);
 801 
 802     __ lea(c_rarg0, field);
 803     __ get_method(c_rarg1);
 804     __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),
 805                     c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);
 806 
 807     __ bind(done);
 808   } else {
 809     __ bind(notAcquireRelease);
 810   }
 811   __ pop_d(v0);
 812   __ popa();
 813 }
 814 
 815 
 816 #endif
 817 
 818 void TemplateTable::iaload()
 819 {
 820   transition(itos, itos);
 821   __ mov(r1, r0);
 822   __ pop_ptr(r0);
 823   // r0: array
 824   // r1: index
 825   index_check(r0, r1); // leaves index in r1, kills rscratch1
 826   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
 827   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 828 }
 829 
 830 void TemplateTable::laload()
 831 {
 832   transition(itos, ltos);
 833   __ mov(r1, r0);
 834   __ pop_ptr(r0);
 835   // r0: array
 836   // r1: index
 837   index_check(r0, r1); // leaves index in r1, kills rscratch1
 838   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
 839   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 840 }
 841 
 842 void TemplateTable::faload()
 843 {
 844   transition(itos, ftos);
 845   __ mov(r1, r0);
 846   __ pop_ptr(r0);
 847   // r0: array
 848   // r1: index
 849   index_check(r0, r1); // leaves index in r1, kills rscratch1
 850   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
 851   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 852 }
 853 
 854 void TemplateTable::daload()
 855 {
 856   transition(itos, dtos);
 857   __ mov(r1, r0);
 858   __ pop_ptr(r0);
 859   // r0: array
 860   // r1: index
 861   index_check(r0, r1); // leaves index in r1, kills rscratch1
 862   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
 863   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 864 }
 865 
 866 void TemplateTable::aaload()
 867 {
 868   transition(itos, atos);
 869   __ mov(r1, r0);
 870   __ pop_ptr(r0);
 871   // r0: array
 872   // r1: index
 873   index_check(r0, r1); // leaves index in r1, kills rscratch1
 874   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 875   do_oop_load(_masm,
 876               Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),
 877               r0,
 878               IS_ARRAY);
 879 }
 880 
 881 void TemplateTable::baload()
 882 {
 883   transition(itos, itos);
 884   __ mov(r1, r0);
 885   __ pop_ptr(r0);
 886   // r0: array
 887   // r1: index
 888   index_check(r0, r1); // leaves index in r1, kills rscratch1
 889   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
 890   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);
 891 }
 892 
 893 void TemplateTable::caload()
 894 {
 895   transition(itos, itos);
 896   __ mov(r1, r0);
 897   __ pop_ptr(r0);
 898   // r0: array
 899   // r1: index
 900   index_check(r0, r1); // leaves index in r1, kills rscratch1
 901   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 902   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 903 }
 904 
 905 // iload followed by caload frequent pair
 906 void TemplateTable::fast_icaload()
 907 {
 908   transition(vtos, itos);
 909   // load index out of locals
 910   locals_index(r2);
 911   __ ldr(r1, iaddress(r2));
 912 
 913   __ pop_ptr(r0);
 914 
 915   // r0: array
 916   // r1: index
 917   index_check(r0, r1); // leaves index in r1, kills rscratch1
 918   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 919   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 920 }
 921 
 922 void TemplateTable::saload()
 923 {
 924   transition(itos, itos);
 925   __ mov(r1, r0);
 926   __ pop_ptr(r0);
 927   // r0: array
 928   // r1: index
 929   index_check(r0, r1); // leaves index in r1, kills rscratch1
 930   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
 931   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 932 }
 933 
 934 void TemplateTable::iload(int n)
 935 {
 936   transition(vtos, itos);
 937   __ ldr(r0, iaddress(n));
 938 }
 939 
 940 void TemplateTable::lload(int n)
 941 {
 942   transition(vtos, ltos);
 943   __ ldr(r0, laddress(n));
 944 }
 945 
 946 void TemplateTable::fload(int n)
 947 {
 948   transition(vtos, ftos);
 949   __ ldrs(v0, faddress(n));
 950 }
 951 
 952 void TemplateTable::dload(int n)
 953 {
 954   transition(vtos, dtos);
 955   __ ldrd(v0, daddress(n));
 956 }
 957 
 958 void TemplateTable::aload(int n)
 959 {
 960   transition(vtos, atos);
 961   __ ldr(r0, iaddress(n));
 962 }
 963 
 964 void TemplateTable::aload_0() {
 965   aload_0_internal();
 966 }
 967 
 968 void TemplateTable::nofast_aload_0() {
 969   aload_0_internal(may_not_rewrite);
 970 }
 971 
 972 void TemplateTable::aload_0_internal(RewriteControl rc) {
 973   // According to bytecode histograms, the pairs:
 974   //
 975   // _aload_0, _fast_igetfield
 976   // _aload_0, _fast_agetfield
 977   // _aload_0, _fast_fgetfield
 978   //
 979   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 980   // _aload_0 bytecode checks if the next bytecode is either
 981   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 982   // rewrites the current bytecode into a pair bytecode; otherwise it
 983   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 984   // the pair check anymore.
 985   //
 986   // Note: If the next bytecode is _getfield, the rewrite must be
 987   //       delayed, otherwise we may miss an opportunity for a pair.
 988   //
 989   // Also rewrite frequent pairs
 990   //   aload_0, aload_1
 991   //   aload_0, iload_1
 992   // These bytecodes with a small amount of code are most profitable
 993   // to rewrite
 994   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 995     Label rewrite, done;
 996     const Register bc = r4;
 997 
 998     // get next bytecode
 999     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
1000 
1001     // if _getfield then wait with rewrite
1002     __ cmpw(r1, Bytecodes::Bytecodes::_getfield);
1003     __ br(Assembler::EQ, done);
1004 
1005     // if _igetfield then rewrite to _fast_iaccess_0
1006     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1007     __ cmpw(r1, Bytecodes::_fast_igetfield);
1008     __ movw(bc, Bytecodes::_fast_iaccess_0);
1009     __ br(Assembler::EQ, rewrite);
1010 
1011     // if _agetfield then rewrite to _fast_aaccess_0
1012     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1013     __ cmpw(r1, Bytecodes::_fast_agetfield);
1014     __ movw(bc, Bytecodes::_fast_aaccess_0);
1015     __ br(Assembler::EQ, rewrite);
1016 
1017     // if _fgetfield then rewrite to _fast_faccess_0
1018     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1019     __ cmpw(r1, Bytecodes::_fast_fgetfield);
1020     __ movw(bc, Bytecodes::_fast_faccess_0);
1021     __ br(Assembler::EQ, rewrite);
1022 
1023     // else rewrite to _fast_aload0
1024     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1025     __ movw(bc, Bytecodes::Bytecodes::_fast_aload_0);
1026 
1027     // rewrite
1028     // bc: new bytecode
1029     __ bind(rewrite);
1030     patch_bytecode(Bytecodes::_aload_0, bc, r1, false);
1031 
1032     __ bind(done);
1033   }
1034 
1035   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
1036   aload(0);
1037 }
1038 
1039 void TemplateTable::istore()
1040 {
1041   transition(itos, vtos);
1042   locals_index(r1);
1043   // FIXME: We&#39;re being very pernickerty here storing a jint in a
1044   // local with strw, which costs an extra instruction over what we&#39;d
1045   // be able to do with a simple str.  We should just store the whole
1046   // word.
1047   __ lea(rscratch1, iaddress(r1));
1048   __ strw(r0, Address(rscratch1));
1049 }
1050 
1051 void TemplateTable::lstore()
1052 {
1053   transition(ltos, vtos);
1054   locals_index(r1);
1055   __ str(r0, laddress(r1, rscratch1, _masm));
1056 }
1057 
1058 void TemplateTable::fstore() {
1059   transition(ftos, vtos);
1060   locals_index(r1);
1061   __ lea(rscratch1, iaddress(r1));
1062   __ strs(v0, Address(rscratch1));
1063 }
1064 
1065 void TemplateTable::dstore() {
1066   transition(dtos, vtos);
1067   locals_index(r1);
1068   __ strd(v0, daddress(r1, rscratch1, _masm));
1069 }
1070 
1071 void TemplateTable::astore()
1072 {
1073   transition(vtos, vtos);
1074   __ pop_ptr(r0);
1075   locals_index(r1);
1076   __ str(r0, aaddress(r1));
1077 }
1078 
1079 void TemplateTable::wide_istore() {
1080   transition(vtos, vtos);
1081   __ pop_i();
1082   locals_index_wide(r1);
1083   __ lea(rscratch1, iaddress(r1));
1084   __ strw(r0, Address(rscratch1));
1085 }
1086 
1087 void TemplateTable::wide_lstore() {
1088   transition(vtos, vtos);
1089   __ pop_l();
1090   locals_index_wide(r1);
1091   __ str(r0, laddress(r1, rscratch1, _masm));
1092 }
1093 
1094 void TemplateTable::wide_fstore() {
1095   transition(vtos, vtos);
1096   __ pop_f();
1097   locals_index_wide(r1);
1098   __ lea(rscratch1, faddress(r1));
1099   __ strs(v0, rscratch1);
1100 }
1101 
1102 void TemplateTable::wide_dstore() {
1103   transition(vtos, vtos);
1104   __ pop_d();
1105   locals_index_wide(r1);
1106   __ strd(v0, daddress(r1, rscratch1, _masm));
1107 }
1108 
1109 void TemplateTable::wide_astore() {
1110   transition(vtos, vtos);
1111   __ pop_ptr(r0);
1112   locals_index_wide(r1);
1113   __ str(r0, aaddress(r1));
1114 }
1115 
1116 void TemplateTable::iastore() {
1117   transition(itos, vtos);
1118   __ pop_i(r1);
1119   __ pop_ptr(r3);
1120   // r0: value
1121   // r1: index
1122   // r3: array
1123   index_check(r3, r1); // prefer index in r1
1124   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
1125   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);
1126 }
1127 
1128 void TemplateTable::lastore() {
1129   transition(ltos, vtos);
1130   __ pop_i(r1);
1131   __ pop_ptr(r3);
1132   // r0: value
1133   // r1: index
1134   // r3: array
1135   index_check(r3, r1); // prefer index in r1
1136   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
1137   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);
1138 }
1139 
1140 void TemplateTable::fastore() {
1141   transition(ftos, vtos);
1142   __ pop_i(r1);
1143   __ pop_ptr(r3);
1144   // v0: value
1145   // r1:  index
1146   // r3:  array
1147   index_check(r3, r1); // prefer index in r1
1148   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
1149   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg /* ftos */, noreg, noreg);
1150 }
1151 
1152 void TemplateTable::dastore() {
1153   transition(dtos, vtos);
1154   __ pop_i(r1);
1155   __ pop_ptr(r3);
1156   // v0: value
1157   // r1:  index
1158   // r3:  array
1159   index_check(r3, r1); // prefer index in r1
1160   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
1161   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg /* dtos */, noreg, noreg);
1162 }
1163 
1164 void TemplateTable::aastore() {
1165   Label is_null, ok_is_subtype, done;
1166   transition(vtos, vtos);
1167   // stack: ..., array, index, value
1168   __ ldr(r0, at_tos());    // value
1169   __ ldr(r2, at_tos_p1()); // index
1170   __ ldr(r3, at_tos_p2()); // array
1171 
1172   Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
1173 
1174   index_check(r3, r2);     // kills r1
1175   __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
1176 
1177   // do array store check - check for NULL value first
1178   __ cbz(r0, is_null);
1179 
1180   // Move subklass into r1
1181   __ load_klass(r1, r0);
1182   // Move superklass into r0
1183   __ load_klass(r0, r3);
1184   __ ldr(r0, Address(r0,
1185                      ObjArrayKlass::element_klass_offset()));
1186   // Compress array + index*oopSize + 12 into a single register.  Frees r2.
1187 
1188   // Generate subtype check.  Blows r2, r5
1189   // Superklass in r0.  Subklass in r1.
1190   __ gen_subtype_check(r1, ok_is_subtype);
1191 
1192   // Come here on failure
1193   // object is at TOS
1194   __ b(Interpreter::_throw_ArrayStoreException_entry);
1195 
1196   // Come here on success
1197   __ bind(ok_is_subtype);
1198 
1199   // Get the value we will store
1200   __ ldr(r0, at_tos());
1201   // Now store using the appropriate barrier
1202   do_oop_store(_masm, element_address, r0, IS_ARRAY);
1203   __ b(done);
1204 
1205   // Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]
1206   __ bind(is_null);
1207   __ profile_null_seen(r2);
1208 
1209   // Store a NULL
1210   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1211 
1212   // Pop stack arguments
1213   __ bind(done);
1214   __ add(esp, esp, 3 * Interpreter::stackElementSize);
1215 }
1216 
1217 void TemplateTable::bastore()
1218 {
1219   transition(itos, vtos);
1220   __ pop_i(r1);
1221   __ pop_ptr(r3);
1222   // r0: value
1223   // r1: index
1224   // r3: array
1225   index_check(r3, r1); // prefer index in r1
1226 
1227   // Need to check whether array is boolean or byte
1228   // since both types share the bastore bytecode.
1229   __ load_klass(r2, r3);
1230   __ ldrw(r2, Address(r2, Klass::layout_helper_offset()));
1231   int diffbit_index = exact_log2(Klass::layout_helper_boolean_diffbit());
1232   Label L_skip;
1233   __ tbz(r2, diffbit_index, L_skip);
1234   __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1235   __ bind(L_skip);
1236 
1237   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
1238   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);
1239 }
1240 
1241 void TemplateTable::castore()
1242 {
1243   transition(itos, vtos);
1244   __ pop_i(r1);
1245   __ pop_ptr(r3);
1246   // r0: value
1247   // r1: index
1248   // r3: array
1249   index_check(r3, r1); // prefer index in r1
1250   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
1251   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);
1252 }
1253 
1254 void TemplateTable::sastore()
1255 {
1256   castore();
1257 }
1258 
1259 void TemplateTable::istore(int n)
1260 {
1261   transition(itos, vtos);
1262   __ str(r0, iaddress(n));
1263 }
1264 
1265 void TemplateTable::lstore(int n)
1266 {
1267   transition(ltos, vtos);
1268   __ str(r0, laddress(n));
1269 }
1270 
1271 void TemplateTable::fstore(int n)
1272 {
1273   transition(ftos, vtos);
1274   __ strs(v0, faddress(n));
1275 }
1276 
1277 void TemplateTable::dstore(int n)
1278 {
1279   transition(dtos, vtos);
1280   __ strd(v0, daddress(n));
1281 }
1282 
1283 void TemplateTable::astore(int n)
1284 {
1285   transition(vtos, vtos);
1286   __ pop_ptr(r0);
1287   __ str(r0, iaddress(n));
1288 }
1289 
1290 void TemplateTable::pop()
1291 {
1292   transition(vtos, vtos);
1293   __ add(esp, esp, Interpreter::stackElementSize);
1294 }
1295 
1296 void TemplateTable::pop2()
1297 {
1298   transition(vtos, vtos);
1299   __ add(esp, esp, 2 * Interpreter::stackElementSize);
1300 }
1301 
1302 void TemplateTable::dup()
1303 {
1304   transition(vtos, vtos);
1305   __ ldr(r0, Address(esp, 0));
1306   __ push(r0);
1307   // stack: ..., a, a
1308 }
1309 
1310 void TemplateTable::dup_x1()
1311 {
1312   transition(vtos, vtos);
1313   // stack: ..., a, b
1314   __ ldr(r0, at_tos());  // load b
1315   __ ldr(r2, at_tos_p1());  // load a
1316   __ str(r0, at_tos_p1());  // store b
1317   __ str(r2, at_tos());  // store a
1318   __ push(r0);                  // push b
1319   // stack: ..., b, a, b
1320 }
1321 
1322 void TemplateTable::dup_x2()
1323 {
1324   transition(vtos, vtos);
1325   // stack: ..., a, b, c
1326   __ ldr(r0, at_tos());  // load c
1327   __ ldr(r2, at_tos_p2());  // load a
1328   __ str(r0, at_tos_p2());  // store c in a
1329   __ push(r0);      // push c
1330   // stack: ..., c, b, c, c
1331   __ ldr(r0, at_tos_p2());  // load b
1332   __ str(r2, at_tos_p2());  // store a in b
1333   // stack: ..., c, a, c, c
1334   __ str(r0, at_tos_p1());  // store b in c
1335   // stack: ..., c, a, b, c
1336 }
1337 
1338 void TemplateTable::dup2()
1339 {
1340   transition(vtos, vtos);
1341   // stack: ..., a, b
1342   __ ldr(r0, at_tos_p1());  // load a
1343   __ push(r0);                  // push a
1344   __ ldr(r0, at_tos_p1());  // load b
1345   __ push(r0);                  // push b
1346   // stack: ..., a, b, a, b
1347 }
1348 
1349 void TemplateTable::dup2_x1()
1350 {
1351   transition(vtos, vtos);
1352   // stack: ..., a, b, c
1353   __ ldr(r2, at_tos());  // load c
1354   __ ldr(r0, at_tos_p1());  // load b
1355   __ push(r0);                  // push b
1356   __ push(r2);                  // push c
1357   // stack: ..., a, b, c, b, c
1358   __ str(r2, at_tos_p3());  // store c in b
1359   // stack: ..., a, c, c, b, c
1360   __ ldr(r2, at_tos_p4());  // load a
1361   __ str(r2, at_tos_p2());  // store a in 2nd c
1362   // stack: ..., a, c, a, b, c
1363   __ str(r0, at_tos_p4());  // store b in a
1364   // stack: ..., b, c, a, b, c
1365 }
1366 
1367 void TemplateTable::dup2_x2()
1368 {
1369   transition(vtos, vtos);
1370   // stack: ..., a, b, c, d
1371   __ ldr(r2, at_tos());  // load d
1372   __ ldr(r0, at_tos_p1());  // load c
1373   __ push(r0)            ;      // push c
1374   __ push(r2);                  // push d
1375   // stack: ..., a, b, c, d, c, d
1376   __ ldr(r0, at_tos_p4());  // load b
1377   __ str(r0, at_tos_p2());  // store b in d
1378   __ str(r2, at_tos_p4());  // store d in b
1379   // stack: ..., a, d, c, b, c, d
1380   __ ldr(r2, at_tos_p5());  // load a
1381   __ ldr(r0, at_tos_p3());  // load c
1382   __ str(r2, at_tos_p3());  // store a in c
1383   __ str(r0, at_tos_p5());  // store c in a
1384   // stack: ..., c, d, a, b, c, d
1385 }
1386 
1387 void TemplateTable::swap()
1388 {
1389   transition(vtos, vtos);
1390   // stack: ..., a, b
1391   __ ldr(r2, at_tos_p1());  // load a
1392   __ ldr(r0, at_tos());  // load b
1393   __ str(r2, at_tos());  // store a in b
1394   __ str(r0, at_tos_p1());  // store b in a
1395   // stack: ..., b, a
1396 }
1397 
1398 void TemplateTable::iop2(Operation op)
1399 {
1400   transition(itos, itos);
1401   // r0 &lt;== r1 op r0
1402   __ pop_i(r1);
1403   switch (op) {
1404   case add  : __ addw(r0, r1, r0); break;
1405   case sub  : __ subw(r0, r1, r0); break;
1406   case mul  : __ mulw(r0, r1, r0); break;
1407   case _and : __ andw(r0, r1, r0); break;
1408   case _or  : __ orrw(r0, r1, r0); break;
1409   case _xor : __ eorw(r0, r1, r0); break;
1410   case shl  : __ lslvw(r0, r1, r0); break;
1411   case shr  : __ asrvw(r0, r1, r0); break;
1412   case ushr : __ lsrvw(r0, r1, r0);break;
1413   default   : ShouldNotReachHere();
1414   }
1415 }
1416 
1417 void TemplateTable::lop2(Operation op)
1418 {
1419   transition(ltos, ltos);
1420   // r0 &lt;== r1 op r0
1421   __ pop_l(r1);
1422   switch (op) {
1423   case add  : __ add(r0, r1, r0); break;
1424   case sub  : __ sub(r0, r1, r0); break;
1425   case mul  : __ mul(r0, r1, r0); break;
1426   case _and : __ andr(r0, r1, r0); break;
1427   case _or  : __ orr(r0, r1, r0); break;
1428   case _xor : __ eor(r0, r1, r0); break;
1429   default   : ShouldNotReachHere();
1430   }
1431 }
1432 
1433 void TemplateTable::idiv()
1434 {
1435   transition(itos, itos);
1436   // explicitly check for div0
1437   Label no_div0;
1438   __ cbnzw(r0, no_div0);
1439   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1440   __ br(rscratch1);
1441   __ bind(no_div0);
1442   __ pop_i(r1);
1443   // r0 &lt;== r1 idiv r0
1444   __ corrected_idivl(r0, r1, r0, /* want_remainder */ false);
1445 }
1446 
1447 void TemplateTable::irem()
1448 {
1449   transition(itos, itos);
1450   // explicitly check for div0
1451   Label no_div0;
1452   __ cbnzw(r0, no_div0);
1453   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1454   __ br(rscratch1);
1455   __ bind(no_div0);
1456   __ pop_i(r1);
1457   // r0 &lt;== r1 irem r0
1458   __ corrected_idivl(r0, r1, r0, /* want_remainder */ true);
1459 }
1460 
1461 void TemplateTable::lmul()
1462 {
1463   transition(ltos, ltos);
1464   __ pop_l(r1);
1465   __ mul(r0, r0, r1);
1466 }
1467 
1468 void TemplateTable::ldiv()
1469 {
1470   transition(ltos, ltos);
1471   // explicitly check for div0
1472   Label no_div0;
1473   __ cbnz(r0, no_div0);
1474   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1475   __ br(rscratch1);
1476   __ bind(no_div0);
1477   __ pop_l(r1);
1478   // r0 &lt;== r1 ldiv r0
1479   __ corrected_idivq(r0, r1, r0, /* want_remainder */ false);
1480 }
1481 
1482 void TemplateTable::lrem()
1483 {
1484   transition(ltos, ltos);
1485   // explicitly check for div0
1486   Label no_div0;
1487   __ cbnz(r0, no_div0);
1488   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1489   __ br(rscratch1);
1490   __ bind(no_div0);
1491   __ pop_l(r1);
1492   // r0 &lt;== r1 lrem r0
1493   __ corrected_idivq(r0, r1, r0, /* want_remainder */ true);
1494 }
1495 
1496 void TemplateTable::lshl()
1497 {
1498   transition(itos, ltos);
1499   // shift count is in r0
1500   __ pop_l(r1);
1501   __ lslv(r0, r1, r0);
1502 }
1503 
1504 void TemplateTable::lshr()
1505 {
1506   transition(itos, ltos);
1507   // shift count is in r0
1508   __ pop_l(r1);
1509   __ asrv(r0, r1, r0);
1510 }
1511 
1512 void TemplateTable::lushr()
1513 {
1514   transition(itos, ltos);
1515   // shift count is in r0
1516   __ pop_l(r1);
1517   __ lsrv(r0, r1, r0);
1518 }
1519 
1520 void TemplateTable::fop2(Operation op)
1521 {
1522   transition(ftos, ftos);
1523   switch (op) {
1524   case add:
1525     // n.b. use ldrd because this is a 64 bit slot
1526     __ pop_f(v1);
1527     __ fadds(v0, v1, v0);
1528     break;
1529   case sub:
1530     __ pop_f(v1);
1531     __ fsubs(v0, v1, v0);
1532     break;
1533   case mul:
1534     __ pop_f(v1);
1535     __ fmuls(v0, v1, v0);
1536     break;
1537   case div:
1538     __ pop_f(v1);
1539     __ fdivs(v0, v1, v0);
1540     break;
1541   case rem:
1542     __ fmovs(v1, v0);
1543     __ pop_f(v0);
1544     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1545     break;
1546   default:
1547     ShouldNotReachHere();
1548     break;
1549   }
1550 }
1551 
1552 void TemplateTable::dop2(Operation op)
1553 {
1554   transition(dtos, dtos);
1555   switch (op) {
1556   case add:
1557     // n.b. use ldrd because this is a 64 bit slot
1558     __ pop_d(v1);
1559     __ faddd(v0, v1, v0);
1560     break;
1561   case sub:
1562     __ pop_d(v1);
1563     __ fsubd(v0, v1, v0);
1564     break;
1565   case mul:
1566     __ pop_d(v1);
1567     __ fmuld(v0, v1, v0);
1568     break;
1569   case div:
1570     __ pop_d(v1);
1571     __ fdivd(v0, v1, v0);
1572     break;
1573   case rem:
1574     __ fmovd(v1, v0);
1575     __ pop_d(v0);
1576     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1577     break;
1578   default:
1579     ShouldNotReachHere();
1580     break;
1581   }
1582 }
1583 
1584 void TemplateTable::ineg()
1585 {
1586   transition(itos, itos);
1587   __ negw(r0, r0);
1588 
1589 }
1590 
1591 void TemplateTable::lneg()
1592 {
1593   transition(ltos, ltos);
1594   __ neg(r0, r0);
1595 }
1596 
1597 void TemplateTable::fneg()
1598 {
1599   transition(ftos, ftos);
1600   __ fnegs(v0, v0);
1601 }
1602 
1603 void TemplateTable::dneg()
1604 {
1605   transition(dtos, dtos);
1606   __ fnegd(v0, v0);
1607 }
1608 
1609 void TemplateTable::iinc()
1610 {
1611   transition(vtos, vtos);
1612   __ load_signed_byte(r1, at_bcp(2)); // get constant
1613   locals_index(r2);
1614   __ ldr(r0, iaddress(r2));
1615   __ addw(r0, r0, r1);
1616   __ str(r0, iaddress(r2));
1617 }
1618 
1619 void TemplateTable::wide_iinc()
1620 {
1621   transition(vtos, vtos);
1622   // __ mov(r1, zr);
1623   __ ldrw(r1, at_bcp(2)); // get constant and index
1624   __ rev16(r1, r1);
1625   __ ubfx(r2, r1, 0, 16);
1626   __ neg(r2, r2);
1627   __ sbfx(r1, r1, 16, 16);
1628   __ ldr(r0, iaddress(r2));
1629   __ addw(r0, r0, r1);
1630   __ str(r0, iaddress(r2));
1631 }
1632 
1633 void TemplateTable::convert()
1634 {
1635   // Checking
1636 #ifdef ASSERT
1637   {
1638     TosState tos_in  = ilgl;
1639     TosState tos_out = ilgl;
1640     switch (bytecode()) {
1641     case Bytecodes::_i2l: // fall through
1642     case Bytecodes::_i2f: // fall through
1643     case Bytecodes::_i2d: // fall through
1644     case Bytecodes::_i2b: // fall through
1645     case Bytecodes::_i2c: // fall through
1646     case Bytecodes::_i2s: tos_in = itos; break;
1647     case Bytecodes::_l2i: // fall through
1648     case Bytecodes::_l2f: // fall through
1649     case Bytecodes::_l2d: tos_in = ltos; break;
1650     case Bytecodes::_f2i: // fall through
1651     case Bytecodes::_f2l: // fall through
1652     case Bytecodes::_f2d: tos_in = ftos; break;
1653     case Bytecodes::_d2i: // fall through
1654     case Bytecodes::_d2l: // fall through
1655     case Bytecodes::_d2f: tos_in = dtos; break;
1656     default             : ShouldNotReachHere();
1657     }
1658     switch (bytecode()) {
1659     case Bytecodes::_l2i: // fall through
1660     case Bytecodes::_f2i: // fall through
1661     case Bytecodes::_d2i: // fall through
1662     case Bytecodes::_i2b: // fall through
1663     case Bytecodes::_i2c: // fall through
1664     case Bytecodes::_i2s: tos_out = itos; break;
1665     case Bytecodes::_i2l: // fall through
1666     case Bytecodes::_f2l: // fall through
1667     case Bytecodes::_d2l: tos_out = ltos; break;
1668     case Bytecodes::_i2f: // fall through
1669     case Bytecodes::_l2f: // fall through
1670     case Bytecodes::_d2f: tos_out = ftos; break;
1671     case Bytecodes::_i2d: // fall through
1672     case Bytecodes::_l2d: // fall through
1673     case Bytecodes::_f2d: tos_out = dtos; break;
1674     default             : ShouldNotReachHere();
1675     }
1676     transition(tos_in, tos_out);
1677   }
1678 #endif // ASSERT
1679   // static const int64_t is_nan = 0x8000000000000000L;
1680 
1681   // Conversion
1682   switch (bytecode()) {
1683   case Bytecodes::_i2l:
1684     __ sxtw(r0, r0);
1685     break;
1686   case Bytecodes::_i2f:
1687     __ scvtfws(v0, r0);
1688     break;
1689   case Bytecodes::_i2d:
1690     __ scvtfwd(v0, r0);
1691     break;
1692   case Bytecodes::_i2b:
1693     __ sxtbw(r0, r0);
1694     break;
1695   case Bytecodes::_i2c:
1696     __ uxthw(r0, r0);
1697     break;
1698   case Bytecodes::_i2s:
1699     __ sxthw(r0, r0);
1700     break;
1701   case Bytecodes::_l2i:
1702     __ uxtw(r0, r0);
1703     break;
1704   case Bytecodes::_l2f:
1705     __ scvtfs(v0, r0);
1706     break;
1707   case Bytecodes::_l2d:
1708     __ scvtfd(v0, r0);
1709     break;
1710   case Bytecodes::_f2i:
1711   {
1712     Label L_Okay;
1713     __ clear_fpsr();
1714     __ fcvtzsw(r0, v0);
1715     __ get_fpsr(r1);
1716     __ cbzw(r1, L_Okay);
1717     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i));
1718     __ bind(L_Okay);
1719   }
1720     break;
1721   case Bytecodes::_f2l:
1722   {
1723     Label L_Okay;
1724     __ clear_fpsr();
1725     __ fcvtzs(r0, v0);
1726     __ get_fpsr(r1);
1727     __ cbzw(r1, L_Okay);
1728     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l));
1729     __ bind(L_Okay);
1730   }
1731     break;
1732   case Bytecodes::_f2d:
1733     __ fcvts(v0, v0);
1734     break;
1735   case Bytecodes::_d2i:
1736   {
1737     Label L_Okay;
1738     __ clear_fpsr();
1739     __ fcvtzdw(r0, v0);
1740     __ get_fpsr(r1);
1741     __ cbzw(r1, L_Okay);
1742     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i));
1743     __ bind(L_Okay);
1744   }
1745     break;
1746   case Bytecodes::_d2l:
1747   {
1748     Label L_Okay;
1749     __ clear_fpsr();
1750     __ fcvtzd(r0, v0);
1751     __ get_fpsr(r1);
1752     __ cbzw(r1, L_Okay);
1753     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l));
1754     __ bind(L_Okay);
1755   }
1756     break;
1757   case Bytecodes::_d2f:
1758     __ fcvtd(v0, v0);
1759     break;
1760   default:
1761     ShouldNotReachHere();
1762   }
1763 }
1764 
1765 void TemplateTable::lcmp()
1766 {
1767   transition(ltos, itos);
1768   Label done;
1769   __ pop_l(r1);
1770   __ cmp(r1, r0);
1771   __ mov(r0, (u_int64_t)-1L);
1772   __ br(Assembler::LT, done);
1773   // __ mov(r0, 1UL);
1774   // __ csel(r0, r0, zr, Assembler::NE);
1775   // and here is a faster way
1776   __ csinc(r0, zr, zr, Assembler::EQ);
1777   __ bind(done);
1778 }
1779 
1780 void TemplateTable::float_cmp(bool is_float, int unordered_result)
1781 {
1782   Label done;
1783   if (is_float) {
1784     // XXX get rid of pop here, use ... reg, mem32
1785     __ pop_f(v1);
1786     __ fcmps(v1, v0);
1787   } else {
1788     // XXX get rid of pop here, use ... reg, mem64
1789     __ pop_d(v1);
1790     __ fcmpd(v1, v0);
1791   }
1792   if (unordered_result &lt; 0) {
1793     // we want -1 for unordered or less than, 0 for equal and 1 for
1794     // greater than.
1795     __ mov(r0, (u_int64_t)-1L);
1796     // for FP LT tests less than or unordered
1797     __ br(Assembler::LT, done);
1798     // install 0 for EQ otherwise 1
1799     __ csinc(r0, zr, zr, Assembler::EQ);
1800   } else {
1801     // we want -1 for less than, 0 for equal and 1 for unordered or
1802     // greater than.
1803     __ mov(r0, 1L);
1804     // for FP HI tests greater than or unordered
1805     __ br(Assembler::HI, done);
1806     // install 0 for EQ otherwise ~0
1807     __ csinv(r0, zr, zr, Assembler::EQ);
1808 
1809   }
1810   __ bind(done);
1811 }
1812 
1813 void TemplateTable::branch(bool is_jsr, bool is_wide)
1814 {
1815   // We might be moving to a safepoint.  The thread which calls
1816   // Interpreter::notice_safepoints() will effectively flush its cache
1817   // when it makes a system call, but we need to do something to
1818   // ensure that we see the changed dispatch table.
1819   __ membar(MacroAssembler::LoadLoad);
1820 
1821   __ profile_taken_branch(r0, r1);
1822   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
1823                              InvocationCounter::counter_offset();
1824   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
1825                               InvocationCounter::counter_offset();
1826 
1827   // load branch displacement
1828   if (!is_wide) {
1829     __ ldrh(r2, at_bcp(1));
1830     __ rev16(r2, r2);
1831     // sign extend the 16 bit value in r2
1832     __ sbfm(r2, r2, 0, 15);
1833   } else {
1834     __ ldrw(r2, at_bcp(1));
1835     __ revw(r2, r2);
1836     // sign extend the 32 bit value in r2
1837     __ sbfm(r2, r2, 0, 31);
1838   }
1839 
1840   // Handle all the JSR stuff here, then exit.
1841   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
1842   // normal-branch stuff occurring below.
1843 
1844   if (is_jsr) {
1845     // Pre-load the next target bytecode into rscratch1
1846     __ load_unsigned_byte(rscratch1, Address(rbcp, r2));
1847     // compute return address as bci
1848     __ ldr(rscratch2, Address(rmethod, Method::const_offset()));
1849     __ add(rscratch2, rscratch2,
1850            in_bytes(ConstMethod::codes_offset()) - (is_wide ? 5 : 3));
1851     __ sub(r1, rbcp, rscratch2);
1852     __ push_i(r1);
1853     // Adjust the bcp by the 16-bit displacement in r2
1854     __ add(rbcp, rbcp, r2);
1855     __ dispatch_only(vtos, /*generate_poll*/true);
1856     return;
1857   }
1858 
1859   // Normal (non-jsr) branch handling
1860 
1861   // Adjust the bcp by the displacement in r2
1862   __ add(rbcp, rbcp, r2);
1863 
1864   assert(UseLoopCounter || !UseOnStackReplacement,
1865          &quot;on-stack-replacement requires loop counters&quot;);
1866   Label backedge_counter_overflow;
1867   Label profile_method;
1868   Label dispatch;
1869   if (UseLoopCounter) {
1870     // increment backedge counter for backward branches
1871     // r0: MDO
1872     // w1: MDO bumped taken-count
1873     // r2: target offset
1874     __ cmp(r2, zr);
1875     __ br(Assembler::GT, dispatch); // count only if backward branch
1876 
1877     // ECN: FIXME: This code smells
1878     // check if MethodCounters exists
1879     Label has_counters;
1880     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1881     __ cbnz(rscratch1, has_counters);
1882     __ push(r0);
1883     __ push(r1);
1884     __ push(r2);
1885     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
1886             InterpreterRuntime::build_method_counters), rmethod);
1887     __ pop(r2);
1888     __ pop(r1);
1889     __ pop(r0);
1890     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1891     __ cbz(rscratch1, dispatch); // No MethodCounters allocated, OutOfMemory
1892     __ bind(has_counters);
1893 
1894     if (TieredCompilation) {
1895       Label no_mdo;
1896       int increment = InvocationCounter::count_increment;
1897       if (ProfileInterpreter) {
1898         // Are we profiling?
1899         __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));
1900         __ cbz(r1, no_mdo);
1901         // Increment the MDO backedge counter
1902         const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +
1903                                            in_bytes(InvocationCounter::counter_offset()));
1904         const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));
1905         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1906                                    r0, rscratch1, false, Assembler::EQ,
1907                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1908         __ b(dispatch);
1909       }
1910       __ bind(no_mdo);
1911       // Increment backedge counter in MethodCounters*
1912       __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1913       const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));
1914       __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,
1915                                  r0, rscratch2, false, Assembler::EQ,
1916                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1917     } else { // not TieredCompilation
1918       // increment counter
1919       __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));
1920       __ ldrw(r0, Address(rscratch2, be_offset));        // load backedge counter
1921       __ addw(rscratch1, r0, InvocationCounter::count_increment); // increment counter
1922       __ strw(rscratch1, Address(rscratch2, be_offset));        // store counter
1923 
1924       __ ldrw(r0, Address(rscratch2, inv_offset));    // load invocation counter
1925       __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); // and the status bits
1926       __ addw(r0, r0, rscratch1);        // add both counters
1927 
1928       if (ProfileInterpreter) {
1929         // Test to see if we should create a method data oop
1930         __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
1931         __ cmpw(r0, rscratch1);
1932         __ br(Assembler::LT, dispatch);
1933 
1934         // if no method data exists, go to profile method
1935         __ test_method_data_pointer(r0, profile_method);
1936 
1937         if (UseOnStackReplacement) {
1938           // check for overflow against w1 which is the MDO taken count
1939           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1940           __ cmpw(r1, rscratch1);
1941           __ br(Assembler::LO, dispatch); // Intel == Assembler::below
1942 
1943           // When ProfileInterpreter is on, the backedge_count comes
1944           // from the MethodData*, which value does not get reset on
1945           // the call to frequency_counter_overflow().  To avoid
1946           // excessive calls to the overflow routine while the method is
1947           // being compiled, add a second test to make sure the overflow
1948           // function is called only once every overflow_frequency.
1949           const int overflow_frequency = 1024;
1950           __ andsw(r1, r1, overflow_frequency - 1);
1951           __ br(Assembler::EQ, backedge_counter_overflow);
1952 
1953         }
1954       } else {
1955         if (UseOnStackReplacement) {
1956           // check for overflow against w0, which is the sum of the
1957           // counters
1958           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1959           __ cmpw(r0, rscratch1);
1960           __ br(Assembler::HS, backedge_counter_overflow); // Intel == Assembler::aboveEqual
1961         }
1962       }
1963     }
1964     __ bind(dispatch);
1965   }
1966 
1967   // Pre-load the next target bytecode into rscratch1
1968   __ load_unsigned_byte(rscratch1, Address(rbcp, 0));
1969 
1970   // continue with the bytecode @ target
1971   // rscratch1: target bytecode
1972   // rbcp: target bcp
1973   __ dispatch_only(vtos, /*generate_poll*/true);
1974 
1975   if (UseLoopCounter) {
1976     if (ProfileInterpreter) {
1977       // Out-of-line code to allocate method data oop.
1978       __ bind(profile_method);
1979       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
1980       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1981       __ set_method_data_pointer_for_bcp();
1982       __ b(dispatch);
1983     }
1984 
1985     if (UseOnStackReplacement) {
1986       // invocation counter overflow
1987       __ bind(backedge_counter_overflow);
1988       __ neg(r2, r2);
1989       __ add(r2, r2, rbcp);     // branch bcp
1990       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
1991       __ call_VM(noreg,
1992                  CAST_FROM_FN_PTR(address,
1993                                   InterpreterRuntime::frequency_counter_overflow),
1994                  r2);
1995       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1996 
1997       // r0: osr nmethod (osr ok) or NULL (osr not possible)
1998       // w1: target bytecode
1999       // r2: scratch
2000       __ cbz(r0, dispatch);     // test result -- no osr if null
2001       // nmethod may have been invalidated (VM may block upon call_VM return)
2002       __ ldrb(r2, Address(r0, nmethod::state_offset()));
2003       if (nmethod::in_use != 0)
2004         __ sub(r2, r2, nmethod::in_use);
2005       __ cbnz(r2, dispatch);
2006 
2007       // We have the address of an on stack replacement routine in r0
2008       // We need to prepare to execute the OSR method. First we must
2009       // migrate the locals and monitors off of the stack.
2010 
2011       __ mov(r19, r0);                             // save the nmethod
2012 
2013       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2014 
2015       // r0 is OSR buffer, move it to expected parameter location
2016       __ mov(j_rarg0, r0);
2017 
2018       // remove activation
2019       // get sender esp
2020       __ ldr(esp,
2021           Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));
2022       // remove frame anchor
2023       __ leave();
2024       // Ensure compiled code always sees stack at proper alignment
2025       __ andr(sp, esp, -16);
2026 
2027       // and begin the OSR nmethod
2028       __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));
2029       __ br(rscratch1);
2030     }
2031   }
2032 }
2033 
2034 
2035 void TemplateTable::if_0cmp(Condition cc)
2036 {
2037   transition(itos, vtos);
2038   // assume branch is more often taken than not (loops use backward branches)
2039   Label not_taken;
2040   if (cc == equal)
2041     __ cbnzw(r0, not_taken);
2042   else if (cc == not_equal)
2043     __ cbzw(r0, not_taken);
2044   else {
2045     __ andsw(zr, r0, r0);
2046     __ br(j_not(cc), not_taken);
2047   }
2048 
2049   branch(false, false);
2050   __ bind(not_taken);
2051   __ profile_not_taken_branch(r0);
2052 }
2053 
2054 void TemplateTable::if_icmp(Condition cc)
2055 {
2056   transition(itos, vtos);
2057   // assume branch is more often taken than not (loops use backward branches)
2058   Label not_taken;
2059   __ pop_i(r1);
2060   __ cmpw(r1, r0, Assembler::LSL);
2061   __ br(j_not(cc), not_taken);
2062   branch(false, false);
2063   __ bind(not_taken);
2064   __ profile_not_taken_branch(r0);
2065 }
2066 
2067 void TemplateTable::if_nullcmp(Condition cc)
2068 {
2069   transition(atos, vtos);
2070   // assume branch is more often taken than not (loops use backward branches)
2071   Label not_taken;
2072   if (cc == equal)
2073     __ cbnz(r0, not_taken);
2074   else
2075     __ cbz(r0, not_taken);
2076   branch(false, false);
2077   __ bind(not_taken);
2078   __ profile_not_taken_branch(r0);
2079 }
2080 
2081 void TemplateTable::if_acmp(Condition cc)
2082 {
2083   transition(atos, vtos);
2084   // assume branch is more often taken than not (loops use backward branches)
2085   Label not_taken;
2086   __ pop_ptr(r1);
2087   __ cmpoop(r1, r0);
2088   __ br(j_not(cc), not_taken);
2089   branch(false, false);
2090   __ bind(not_taken);
2091   __ profile_not_taken_branch(r0);
2092 }
2093 
2094 void TemplateTable::ret() {
2095   transition(vtos, vtos);
2096   // We might be moving to a safepoint.  The thread which calls
2097   // Interpreter::notice_safepoints() will effectively flush its cache
2098   // when it makes a system call, but we need to do something to
2099   // ensure that we see the changed dispatch table.
2100   __ membar(MacroAssembler::LoadLoad);
2101 
2102   locals_index(r1);
2103   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2104   __ profile_ret(r1, r2);
2105   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2106   __ lea(rbcp, Address(rbcp, r1));
2107   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2108   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2109 }
2110 
2111 void TemplateTable::wide_ret() {
2112   transition(vtos, vtos);
2113   locals_index_wide(r1);
2114   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2115   __ profile_ret(r1, r2);
2116   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2117   __ lea(rbcp, Address(rbcp, r1));
2118   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2119   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2120 }
2121 
2122 
2123 void TemplateTable::tableswitch() {
2124   Label default_case, continue_execution;
2125   transition(itos, vtos);
2126   // align rbcp
2127   __ lea(r1, at_bcp(BytesPerInt));
2128   __ andr(r1, r1, -BytesPerInt);
2129   // load lo &amp; hi
2130   __ ldrw(r2, Address(r1, BytesPerInt));
2131   __ ldrw(r3, Address(r1, 2 * BytesPerInt));
2132   __ rev32(r2, r2);
2133   __ rev32(r3, r3);
2134   // check against lo &amp; hi
2135   __ cmpw(r0, r2);
2136   __ br(Assembler::LT, default_case);
2137   __ cmpw(r0, r3);
2138   __ br(Assembler::GT, default_case);
2139   // lookup dispatch offset
2140   __ subw(r0, r0, r2);
2141   __ lea(r3, Address(r1, r0, Address::uxtw(2)));
2142   __ ldrw(r3, Address(r3, 3 * BytesPerInt));
2143   __ profile_switch_case(r0, r1, r2);
2144   // continue execution
2145   __ bind(continue_execution);
2146   __ rev32(r3, r3);
2147   __ load_unsigned_byte(rscratch1, Address(rbcp, r3, Address::sxtw(0)));
2148   __ add(rbcp, rbcp, r3, ext::sxtw);
2149   __ dispatch_only(vtos, /*generate_poll*/true);
2150   // handle default
2151   __ bind(default_case);
2152   __ profile_switch_default(r0);
2153   __ ldrw(r3, Address(r1, 0));
2154   __ b(continue_execution);
2155 }
2156 
2157 void TemplateTable::lookupswitch() {
2158   transition(itos, itos);
2159   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2160 }
2161 
2162 void TemplateTable::fast_linearswitch() {
2163   transition(itos, vtos);
2164   Label loop_entry, loop, found, continue_execution;
2165   // bswap r0 so we can avoid bswapping the table entries
2166   __ rev32(r0, r0);
2167   // align rbcp
2168   __ lea(r19, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2169                                     // this instruction (change offsets
2170                                     // below)
2171   __ andr(r19, r19, -BytesPerInt);
2172   // set counter
2173   __ ldrw(r1, Address(r19, BytesPerInt));
2174   __ rev32(r1, r1);
2175   __ b(loop_entry);
2176   // table search
2177   __ bind(loop);
2178   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2179   __ ldrw(rscratch1, Address(rscratch1, 2 * BytesPerInt));
2180   __ cmpw(r0, rscratch1);
2181   __ br(Assembler::EQ, found);
2182   __ bind(loop_entry);
2183   __ subs(r1, r1, 1);
2184   __ br(Assembler::PL, loop);
2185   // default case
2186   __ profile_switch_default(r0);
2187   __ ldrw(r3, Address(r19, 0));
2188   __ b(continue_execution);
2189   // entry found -&gt; get offset
2190   __ bind(found);
2191   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2192   __ ldrw(r3, Address(rscratch1, 3 * BytesPerInt));
2193   __ profile_switch_case(r1, r0, r19);
2194   // continue execution
2195   __ bind(continue_execution);
2196   __ rev32(r3, r3);
2197   __ add(rbcp, rbcp, r3, ext::sxtw);
2198   __ ldrb(rscratch1, Address(rbcp, 0));
2199   __ dispatch_only(vtos, /*generate_poll*/true);
2200 }
2201 
2202 void TemplateTable::fast_binaryswitch() {
2203   transition(itos, vtos);
2204   // Implementation using the following core algorithm:
2205   //
2206   // int binary_search(int key, LookupswitchPair* array, int n) {
2207   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2208   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2209   //   int i = 0;
2210   //   int j = n;
2211   //   while (i+1 &lt; j) {
2212   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2213   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2214   //     // where a stands for the array and assuming that the (inexisting)
2215   //     // element a[n] is infinitely big.
2216   //     int h = (i + j) &gt;&gt; 1;
2217   //     // i &lt; h &lt; j
2218   //     if (key &lt; array[h].fast_match()) {
2219   //       j = h;
2220   //     } else {
2221   //       i = h;
2222   //     }
2223   //   }
2224   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2225   //   // (i.e., if key is within array, i is the correct index)
2226   //   return i;
2227   // }
2228 
2229   // Register allocation
2230   const Register key   = r0; // already set (tosca)
2231   const Register array = r1;
2232   const Register i     = r2;
2233   const Register j     = r3;
2234   const Register h     = rscratch1;
2235   const Register temp  = rscratch2;
2236 
2237   // Find array start
2238   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2239                                           // get rid of this
2240                                           // instruction (change
2241                                           // offsets below)
2242   __ andr(array, array, -BytesPerInt);
2243 
2244   // Initialize i &amp; j
2245   __ mov(i, 0);                            // i = 0;
2246   __ ldrw(j, Address(array, -BytesPerInt)); // j = length(array);
2247 
2248   // Convert j into native byteordering
2249   __ rev32(j, j);
2250 
2251   // And start
2252   Label entry;
2253   __ b(entry);
2254 
2255   // binary search loop
2256   {
2257     Label loop;
2258     __ bind(loop);
2259     // int h = (i + j) &gt;&gt; 1;
2260     __ addw(h, i, j);                           // h = i + j;
2261     __ lsrw(h, h, 1);                                   // h = (i + j) &gt;&gt; 1;
2262     // if (key &lt; array[h].fast_match()) {
2263     //   j = h;
2264     // } else {
2265     //   i = h;
2266     // }
2267     // Convert array[h].match to native byte-ordering before compare
2268     __ ldr(temp, Address(array, h, Address::lsl(3)));
2269     __ rev32(temp, temp);
2270     __ cmpw(key, temp);
2271     // j = h if (key &lt;  array[h].fast_match())
2272     __ csel(j, h, j, Assembler::LT);
2273     // i = h if (key &gt;= array[h].fast_match())
2274     __ csel(i, h, i, Assembler::GE);
2275     // while (i+1 &lt; j)
2276     __ bind(entry);
2277     __ addw(h, i, 1);          // i+1
2278     __ cmpw(h, j);             // i+1 &lt; j
2279     __ br(Assembler::LT, loop);
2280   }
2281 
2282   // end of binary search, result index is i (must check again!)
2283   Label default_case;
2284   // Convert array[i].match to native byte-ordering before compare
2285   __ ldr(temp, Address(array, i, Address::lsl(3)));
2286   __ rev32(temp, temp);
2287   __ cmpw(key, temp);
2288   __ br(Assembler::NE, default_case);
2289 
2290   // entry found -&gt; j = offset
2291   __ add(j, array, i, ext::uxtx, 3);
2292   __ ldrw(j, Address(j, BytesPerInt));
2293   __ profile_switch_case(i, key, array);
2294   __ rev32(j, j);
2295   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2296   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2297   __ dispatch_only(vtos, /*generate_poll*/true);
2298 
2299   // default case -&gt; j = default offset
2300   __ bind(default_case);
2301   __ profile_switch_default(i);
2302   __ ldrw(j, Address(array, -2 * BytesPerInt));
2303   __ rev32(j, j);
2304   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2305   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2306   __ dispatch_only(vtos, /*generate_poll*/true);
2307 }
2308 
2309 
2310 void TemplateTable::_return(TosState state)
2311 {
2312   transition(state, state);
2313   assert(_desc-&gt;calls_vm(),
2314          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2315 
2316   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2317     assert(state == vtos, &quot;only valid state&quot;);
2318 
2319     __ ldr(c_rarg1, aaddress(0));
2320     __ load_klass(r3, c_rarg1);
2321     __ ldrw(r3, Address(r3, Klass::access_flags_offset()));
2322     Label skip_register_finalizer;
2323     __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2324 
2325     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), c_rarg1);
2326 
2327     __ bind(skip_register_finalizer);
2328   }
2329 
2330   // Issue a StoreStore barrier after all stores but before return
2331   // from any constructor for any class with a final field.  We don&#39;t
2332   // know if this is a finalizer, so we always do so.
2333   if (_desc-&gt;bytecode() == Bytecodes::_return)
2334     __ membar(MacroAssembler::StoreStore);
2335 
2336   // Narrow result if state is itos but result type is smaller.
2337   // Need to narrow in the return bytecode rather than in generate_return_entry
2338   // since compiled code callers expect the result to already be narrowed.
2339   if (state == itos) {
2340     __ narrow(r0);
2341   }
2342 
2343   __ remove_activation(state);
2344   __ ret(lr);
2345 }
2346 
2347 // ----------------------------------------------------------------------------
2348 // Volatile variables demand their effects be made known to all CPU&#39;s
2349 // in order.  Store buffers on most chips allow reads &amp; writes to
2350 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2351 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2352 // the interpreter does not reorder volatile references, the hardware
2353 // also must not reorder them).
2354 //
2355 // According to the new Java Memory Model (JMM):
2356 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2357 //     writes act as aquire &amp; release, so:
2358 // (2) A read cannot let unrelated NON-volatile memory refs that
2359 //     happen after the read float up to before the read.  It&#39;s OK for
2360 //     non-volatile memory refs that happen before the volatile read to
2361 //     float down below it.
2362 // (3) Similar a volatile write cannot let unrelated NON-volatile
2363 //     memory refs that happen BEFORE the write float down to after the
2364 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2365 //     volatile write to float up before it.
2366 //
2367 // We only put in barriers around volatile refs (they are expensive),
2368 // not _between_ memory refs (that would require us to track the
2369 // flavor of the previous memory refs).  Requirements (2) and (3)
2370 // require some barriers before volatile stores and after volatile
2371 // loads.  These nearly cover requirement (1) but miss the
2372 // volatile-store-volatile-load case.  This final case is placed after
2373 // volatile-stores although it could just as well go before
2374 // volatile-loads.
2375 
2376 void TemplateTable::resolve_cache_and_index(int byte_no,
2377                                             Register Rcache,
2378                                             Register index,
2379                                             size_t index_size) {
2380   const Register temp = r19;
2381   assert_different_registers(Rcache, index, temp);
2382 
2383   Label resolved, clinit_barrier_slow;
2384 
2385   Bytecodes::Code code = bytecode();
2386   switch (code) {
2387   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2388   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2389   default: break;
2390   }
2391 
2392   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2393   __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
2394   __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
2395   __ br(Assembler::EQ, resolved);
2396 
2397   // resolve first time through
2398   // Class initialization barrier slow path lands here as well.
2399   __ bind(clinit_barrier_slow);
2400   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2401   __ mov(temp, (int) code);
2402   __ call_VM(noreg, entry, temp);
2403 
2404   // Update registers with resolved info
2405   __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
2406   // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
2407   // so all clients ofthis method must be modified accordingly
2408   __ bind(resolved);
2409 
2410   // Class initialization barrier for static methods
2411   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2412     __ load_resolved_method_at_index(byte_no, temp, Rcache);
2413     __ load_method_holder(temp, temp);
2414     __ clinit_barrier(temp, rscratch1, NULL, &amp;clinit_barrier_slow);
2415   }
2416 }
2417 
2418 // The Rcache and index registers must be set before call
2419 // n.b unlike x86 cache already includes the index offset
2420 void TemplateTable::load_field_cp_cache_entry(Register obj,
2421                                               Register cache,
2422                                               Register index,
2423                                               Register off,
2424                                               Register flags,
2425                                               bool is_static = false) {
2426   assert_different_registers(cache, index, flags, off);
2427 
2428   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2429   // Field offset
2430   __ ldr(off, Address(cache, in_bytes(cp_base_offset +
2431                                           ConstantPoolCacheEntry::f2_offset())));
2432   // Flags
2433   __ ldrw(flags, Address(cache, in_bytes(cp_base_offset +
2434                                            ConstantPoolCacheEntry::flags_offset())));
2435 
2436   // klass overwrite register
2437   if (is_static) {
2438     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
2439                                         ConstantPoolCacheEntry::f1_offset())));
2440     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2441     __ ldr(obj, Address(obj, mirror_offset));
2442     __ resolve_oop_handle(obj);
2443     TSAN_RUNTIME_ONLY(
2444       // Draw a happens-before edge from the class&#39;s static initializer to
2445       // this lookup.
2446 
2447       // java_lang_Class::_init_lock_offset may not have been initialized
2448       // when generating code. It will be initialized at runtime though.
2449       // So calculate its address and read from it at runtime.
2450       __ pusha();
2451       __ mov(c_rarg0, obj);
2452       Address init_lock_offset_address((address) java_lang_Class::init_lock_offset_addr(),
2453                                        relocInfo::none);
2454       __ lea(rscratch1, init_lock_offset_address);
2455       __ ldrw(rscratch1, Address(rscratch1, 0));
2456       __ add(c_rarg0, c_rarg0, rscratch1);
2457       __ call_VM_leaf(CAST_FROM_FN_PTR(address,
2458                                        SharedRuntime::tsan_acquire),
2459                                        c_rarg0);
2460       __ popa();
2461     );
2462   }
2463 }
2464 
2465 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2466                                                Register method,
2467                                                Register itable_index,
2468                                                Register flags,
2469                                                bool is_invokevirtual,
2470                                                bool is_invokevfinal, /*unused*/
2471                                                bool is_invokedynamic) {
2472   // setup registers
2473   const Register cache = rscratch2;
2474   const Register index = r4;
2475   assert_different_registers(method, flags);
2476   assert_different_registers(method, cache, index);
2477   assert_different_registers(itable_index, flags);
2478   assert_different_registers(itable_index, cache, index);
2479   // determine constant pool cache field offsets
2480   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2481   const int method_offset = in_bytes(
2482     ConstantPoolCache::base_offset() +
2483       (is_invokevirtual
2484        ? ConstantPoolCacheEntry::f2_offset()
2485        : ConstantPoolCacheEntry::f1_offset()));
2486   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2487                                     ConstantPoolCacheEntry::flags_offset());
2488   // access constant pool cache fields
2489   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2490                                     ConstantPoolCacheEntry::f2_offset());
2491 
2492   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2493   resolve_cache_and_index(byte_no, cache, index, index_size);
2494   __ ldr(method, Address(cache, method_offset));
2495 
2496   if (itable_index != noreg) {
2497     __ ldr(itable_index, Address(cache, index_offset));
2498   }
2499   __ ldrw(flags, Address(cache, flags_offset));
2500 }
2501 
2502 
2503 // The registers cache and index expected to be set before call.
2504 // Correct values of the cache and index registers are preserved.
2505 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2506                                             bool is_static, bool has_tos) {
2507   // do the JVMTI work here to avoid disturbing the register state below
2508   // We use c_rarg registers here because we want to use the register used in
2509   // the call to the VM
2510   if (JvmtiExport::can_post_field_access()) {
2511     // Check to see if a field access watch has been set before we
2512     // take the time to call into the VM.
2513     Label L1;
2514     assert_different_registers(cache, index, r0);
2515     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2516     __ ldrw(r0, Address(rscratch1));
2517     __ cbzw(r0, L1);
2518 
2519     __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);
2520     __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));
2521 
2522     if (is_static) {
2523       __ mov(c_rarg1, zr); // NULL object reference
2524     } else {
2525       __ ldr(c_rarg1, at_tos()); // get object pointer without popping it
2526       __ verify_oop(c_rarg1);
2527     }
2528     // c_rarg1: object pointer or NULL
2529     // c_rarg2: cache entry pointer
2530     // c_rarg3: jvalue object on the stack
2531     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2532                                        InterpreterRuntime::post_field_access),
2533                c_rarg1, c_rarg2, c_rarg3);
2534     __ get_cache_and_index_at_bcp(cache, index, 1);
2535     __ bind(L1);
2536   }
2537 }
2538 
2539 void TemplateTable::pop_and_check_object(Register r)
2540 {
2541   __ pop_ptr(r);
2542   __ null_check(r);  // for field access must check obj.
2543   __ verify_oop(r);
2544 }
2545 
2546 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc)
2547 {
2548   const Register cache = r2;
2549   const Register index = r3;
2550   const Register obj   = r4;
2551   const Register off   = r19;
2552   const Register flags = r0;
2553   const Register raw_flags = r6;
2554   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2555 
2556   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2557   jvmti_post_field_access(cache, index, is_static, false);
2558   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2559 
2560   if (!is_static) {
2561     // obj is on the stack
2562     pop_and_check_object(obj);
2563   }
2564 
2565   // 8179954: We need to make sure that the code generated for
2566   // volatile accesses forms a sequentially-consistent set of
2567   // operations when combined with STLR and LDAR.  Without a leading
2568   // membar it&#39;s possible for a simple Dekker test to fail if loads
2569   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2570   // the stores in one method and we interpret the loads in another.
2571   if (! UseBarriersForVolatile) {
2572     Label notVolatile;
2573     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2574     __ membar(MacroAssembler::AnyAny);
2575     __ bind(notVolatile);
2576   }
2577 
2578   const Address field(obj, off);
2579 
2580   Label Done, notByte, notBool, notInt, notShort, notChar,
2581               notLong, notFloat, notObj, notDouble;
2582 
2583   // x86 uses a shift and mask or wings it with a shift plus assert
2584   // the mask is not needed. aarch64 just uses bitfield extract
2585   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2586            ConstantPoolCacheEntry::tos_state_bits);
2587 
2588   assert(btos == 0, &quot;change code, btos != 0&quot;);
2589   __ cbnz(flags, notByte);
2590 
2591   // Don&#39;t rewrite getstatic, only getfield
2592   if (is_static) rc = may_not_rewrite;
2593 
2594   // btos
2595   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
2596   __ push(btos);
2597   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, btos));
2598   // Rewrite bytecode to be faster
2599   if (rc == may_rewrite) {
2600     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2601   }
2602   __ b(Done);
2603 
2604   __ bind(notByte);
2605   __ cmp(flags, (u1)ztos);
2606   __ br(Assembler::NE, notBool);
2607 
2608   // ztos (same code as btos)
2609   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
2610   __ push(ztos);
2611   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, ztos));
2612   // Rewrite bytecode to be faster
2613   if (rc == may_rewrite) {
2614     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2615     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2616   }
2617   __ b(Done);
2618 
2619   __ bind(notBool);
2620   __ cmp(flags, (u1)atos);
2621   __ br(Assembler::NE, notObj);
2622   // atos
2623   do_oop_load(_masm, field, r0, IN_HEAP);
2624   __ push(atos);
2625   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,
2626                                             raw_flags,
2627                                             UseCompressedOops ? SharedRuntime::tsan_read4
2628                                                               : SharedRuntime::tsan_read8,
2629                                             atos));
2630   if (rc == may_rewrite) {
2631     patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2632   }
2633   __ b(Done);
2634 
2635   __ bind(notObj);
2636   __ cmp(flags, (u1)itos);
2637   __ br(Assembler::NE, notInt);
2638   // itos
2639   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
2640   __ push(itos);
2641   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, itos));
2642   // Rewrite bytecode to be faster
2643   if (rc == may_rewrite) {
2644     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
2645   }
2646   __ b(Done);
2647 
2648   __ bind(notInt);
2649   __ cmp(flags, (u1)ctos);
2650   __ br(Assembler::NE, notChar);
2651   // ctos
2652   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
2653   __ push(ctos);
2654   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, ctos));
2655   // Rewrite bytecode to be faster
2656   if (rc == may_rewrite) {
2657     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
2658   }
2659   __ b(Done);
2660 
2661   __ bind(notChar);
2662   __ cmp(flags, (u1)stos);
2663   __ br(Assembler::NE, notShort);
2664   // stos
2665   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
2666   __ push(stos);
2667   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, stos));
2668   // Rewrite bytecode to be faster
2669   if (rc == may_rewrite) {
2670     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
2671   }
2672   __ b(Done);
2673 
2674   __ bind(notShort);
2675   __ cmp(flags, (u1)ltos);
2676   __ br(Assembler::NE, notLong);
2677   // ltos
2678   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
2679   __ push(ltos);
2680   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, ltos));
2681   // Rewrite bytecode to be faster
2682   if (rc == may_rewrite) {
2683     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
2684   }
2685   __ b(Done);
2686 
2687   __ bind(notLong);
2688   __ cmp(flags, (u1)ftos);
2689   __ br(Assembler::NE, notFloat);
2690   // ftos
2691   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2692   __ push(ftos);
2693   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, ftos));
2694   // Rewrite bytecode to be faster
2695   if (rc == may_rewrite) {
2696     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
2697   }
2698   __ b(Done);
2699 
2700   __ bind(notFloat);
2701 #ifdef ASSERT
2702   __ cmp(flags, (u1)dtos);
2703   __ br(Assembler::NE, notDouble);
2704 #endif
2705   // dtos
2706   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2707   __ push(dtos);
2708   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, dtos));
2709   // Rewrite bytecode to be faster
2710   if (rc == may_rewrite) {
2711     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
2712   }
2713 #ifdef ASSERT
2714   __ b(Done);
2715 
2716   __ bind(notDouble);
2717   __ stop(&quot;Bad state&quot;);
2718 #endif
2719 
2720   __ bind(Done);
2721 
2722   Label notVolatile;
2723   __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2724   __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
2725   __ bind(notVolatile);
2726 }
2727 
2728 
2729 void TemplateTable::getfield(int byte_no)
2730 {
2731   getfield_or_static(byte_no, false);
2732 }
2733 
2734 void TemplateTable::nofast_getfield(int byte_no) {
2735   getfield_or_static(byte_no, false, may_not_rewrite);
2736 }
2737 
2738 void TemplateTable::getstatic(int byte_no)
2739 {
2740   getfield_or_static(byte_no, true);
2741 }
2742 
2743 // The registers cache and index expected to be set before call.
2744 // The function may destroy various registers, just not the cache and index registers.
2745 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
2746   transition(vtos, vtos);
2747 
2748   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2749 
2750   if (JvmtiExport::can_post_field_modification()) {
2751     // Check to see if a field modification watch has been set before
2752     // we take the time to call into the VM.
2753     Label L1;
2754     assert_different_registers(cache, index, r0);
2755     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2756     __ ldrw(r0, Address(rscratch1));
2757     __ cbz(r0, L1);
2758 
2759     __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);
2760 
2761     if (is_static) {
2762       // Life is simple.  Null out the object pointer.
2763       __ mov(c_rarg1, zr);
2764     } else {
2765       // Life is harder. The stack holds the value on top, followed by
2766       // the object.  We don&#39;t know the size of the value, though; it
2767       // could be one or two words depending on its type. As a result,
2768       // we must find the type to determine where the object is.
2769       __ ldrw(c_rarg3, Address(c_rarg2,
2770                                in_bytes(cp_base_offset +
2771                                         ConstantPoolCacheEntry::flags_offset())));
2772       __ lsr(c_rarg3, c_rarg3,
2773              ConstantPoolCacheEntry::tos_state_shift);
2774       ConstantPoolCacheEntry::verify_tos_state_shift();
2775       Label nope2, done, ok;
2776       __ ldr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
2777       __ cmpw(c_rarg3, ltos);
2778       __ br(Assembler::EQ, ok);
2779       __ cmpw(c_rarg3, dtos);
2780       __ br(Assembler::NE, nope2);
2781       __ bind(ok);
2782       __ ldr(c_rarg1, at_tos_p2()); // ltos (two word jvalue)
2783       __ bind(nope2);
2784     }
2785     // cache entry pointer
2786     __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));
2787     // object (tos)
2788     __ mov(c_rarg3, esp);
2789     // c_rarg1: object pointer set up above (NULL if static)
2790     // c_rarg2: cache entry pointer
2791     // c_rarg3: jvalue object on the stack
2792     __ call_VM(noreg,
2793                CAST_FROM_FN_PTR(address,
2794                                 InterpreterRuntime::post_field_modification),
2795                c_rarg1, c_rarg2, c_rarg3);
2796     __ get_cache_and_index_at_bcp(cache, index, 1);
2797     __ bind(L1);
2798   }
2799 }
2800 
2801 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2802   transition(vtos, vtos);
2803 
2804   const Register cache = r2;
2805   const Register index = r3;
2806   const Register obj   = r2;
2807   const Register off   = r19;
2808   const Register flags = r0;
2809   const Register bc    = r4;
2810 
2811   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2812   jvmti_post_field_mod(cache, index, is_static);
2813   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2814 
2815   Label Done;
2816   // save raw flags in r5
2817   __ mov(r5, flags);
2818 
2819   {
2820     Label notVolatile;
2821     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2822     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2823     __ bind(notVolatile);
2824   }
2825 
2826   // field address
2827   const Address field(obj, off);
2828 
2829   Label notByte, notBool, notInt, notShort, notChar,
2830         notLong, notFloat, notObj, notDouble;
2831 
2832   // x86 uses a shift and mask or wings it with a shift plus assert
2833   // the mask is not needed. aarch64 just uses bitfield extract
2834   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
2835 
2836   assert(btos == 0, &quot;change code, btos != 0&quot;);
2837   __ cbnz(flags, notByte);
2838 
2839   // Don&#39;t rewrite putstatic, only putfield
2840   if (is_static) rc = may_not_rewrite;
2841 
2842   // btos
2843   {
2844     __ pop(btos);
2845     if (!is_static) pop_and_check_object(obj);
2846     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, btos));
2847     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
2848     if (rc == may_rewrite) {
2849       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
2850     }
2851     __ b(Done);
2852   }
2853 
2854   __ bind(notByte);
2855   __ cmp(flags, (u1)ztos);
2856   __ br(Assembler::NE, notBool);
2857 
2858   // ztos
2859   {
2860     __ pop(ztos);
2861     if (!is_static) pop_and_check_object(obj);
2862     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, ztos));
2863     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
2864     if (rc == may_rewrite) {
2865       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
2866     }
2867     __ b(Done);
2868   }
2869 
2870   __ bind(notBool);
2871   __ cmp(flags, (u1)atos);
2872   __ br(Assembler::NE, notObj);
2873 
2874   // atos
2875   {
2876     __ pop(atos);
2877     if (!is_static) pop_and_check_object(obj);
2878     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,
2879                                               r5,
2880                                               UseCompressedOops ? SharedRuntime::tsan_write4
2881                                                                 : SharedRuntime::tsan_write8,
2882                                               atos));
2883     // Store into the field
2884     do_oop_store(_masm, field, r0, IN_HEAP);
2885     if (rc == may_rewrite) {
2886       patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
2887     }
2888     __ b(Done);
2889   }
2890 
2891   __ bind(notObj);
2892   __ cmp(flags, (u1)itos);
2893   __ br(Assembler::NE, notInt);
2894 
2895   // itos
2896   {
2897     __ pop(itos);
2898     if (!is_static) pop_and_check_object(obj);
2899     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, itos));
2900     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
2901     if (rc == may_rewrite) {
2902       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
2903     }
2904     __ b(Done);
2905   }
2906 
2907   __ bind(notInt);
2908   __ cmp(flags, (u1)ctos);
2909   __ br(Assembler::NE, notChar);
2910 
2911   // ctos
2912   {
2913     __ pop(ctos);
2914     if (!is_static) pop_and_check_object(obj);
2915     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, ctos));
2916     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
2917     if (rc == may_rewrite) {
2918       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
2919     }
2920     __ b(Done);
2921   }
2922 
2923   __ bind(notChar);
2924   __ cmp(flags, (u1)stos);
2925   __ br(Assembler::NE, notShort);
2926 
2927   // stos
2928   {
2929     __ pop(stos);
2930     if (!is_static) pop_and_check_object(obj);
2931     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, stos));
2932     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
2933     if (rc == may_rewrite) {
2934       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
2935     }
2936     __ b(Done);
2937   }
2938 
2939   __ bind(notShort);
2940   __ cmp(flags, (u1)ltos);
2941   __ br(Assembler::NE, notLong);
2942 
2943   // ltos
2944   {
2945     __ pop(ltos);
2946     if (!is_static) pop_and_check_object(obj);
2947     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, ltos));
2948     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
2949     if (rc == may_rewrite) {
2950       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
2951     }
2952     __ b(Done);
2953   }
2954 
2955   __ bind(notLong);
2956   __ cmp(flags, (u1)ftos);
2957   __ br(Assembler::NE, notFloat);
2958 
2959   // ftos
2960   {
2961     __ pop(ftos);
2962     if (!is_static) pop_and_check_object(obj);
2963     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, ftos));
2964     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
2965     if (rc == may_rewrite) {
2966       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
2967     }
2968     __ b(Done);
2969   }
2970 
2971   __ bind(notFloat);
2972 #ifdef ASSERT
2973   __ cmp(flags, (u1)dtos);
2974   __ br(Assembler::NE, notDouble);
2975 #endif
2976 
2977   // dtos
2978   {
2979     __ pop(dtos);
2980     if (!is_static) pop_and_check_object(obj);
2981     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, dtos));
2982     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
2983     if (rc == may_rewrite) {
2984       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
2985     }
2986   }
2987 
2988 #ifdef ASSERT
2989   __ b(Done);
2990 
2991   __ bind(notDouble);
2992   __ stop(&quot;Bad state&quot;);
2993 #endif
2994 
2995   __ bind(Done);
2996 
2997   {
2998     Label notVolatile;
2999     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3000     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3001     __ bind(notVolatile);
3002   }
3003 }
3004 
3005 void TemplateTable::putfield(int byte_no)
3006 {
3007   putfield_or_static(byte_no, false);
3008 }
3009 
3010 void TemplateTable::nofast_putfield(int byte_no) {
3011   putfield_or_static(byte_no, false, may_not_rewrite);
3012 }
3013 
3014 void TemplateTable::putstatic(int byte_no) {
3015   putfield_or_static(byte_no, true);
3016 }
3017 
3018 void TemplateTable::jvmti_post_fast_field_mod()
3019 {
3020   if (JvmtiExport::can_post_field_modification()) {
3021     // Check to see if a field modification watch has been set before
3022     // we take the time to call into the VM.
3023     Label L2;
3024     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3025     __ ldrw(c_rarg3, Address(rscratch1));
3026     __ cbzw(c_rarg3, L2);
3027     __ pop_ptr(r19);                  // copy the object pointer from tos
3028     __ verify_oop(r19);
3029     __ push_ptr(r19);                 // put the object pointer back on tos
3030     // Save tos values before call_VM() clobbers them. Since we have
3031     // to do it for every data type, we use the saved values as the
3032     // jvalue object.
3033     switch (bytecode()) {          // load values into the jvalue object
3034     case Bytecodes::_fast_aputfield: __ push_ptr(r0); break;
3035     case Bytecodes::_fast_bputfield: // fall through
3036     case Bytecodes::_fast_zputfield: // fall through
3037     case Bytecodes::_fast_sputfield: // fall through
3038     case Bytecodes::_fast_cputfield: // fall through
3039     case Bytecodes::_fast_iputfield: __ push_i(r0); break;
3040     case Bytecodes::_fast_dputfield: __ push_d(); break;
3041     case Bytecodes::_fast_fputfield: __ push_f(); break;
3042     case Bytecodes::_fast_lputfield: __ push_l(r0); break;
3043 
3044     default:
3045       ShouldNotReachHere();
3046     }
3047     __ mov(c_rarg3, esp);             // points to jvalue on the stack
3048     // access constant pool cache entry
3049     __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);
3050     __ verify_oop(r19);
3051     // r19: object pointer copied above
3052     // c_rarg2: cache entry pointer
3053     // c_rarg3: jvalue object on the stack
3054     __ call_VM(noreg,
3055                CAST_FROM_FN_PTR(address,
3056                                 InterpreterRuntime::post_field_modification),
3057                r19, c_rarg2, c_rarg3);
3058 
3059     switch (bytecode()) {             // restore tos values
3060     case Bytecodes::_fast_aputfield: __ pop_ptr(r0); break;
3061     case Bytecodes::_fast_bputfield: // fall through
3062     case Bytecodes::_fast_zputfield: // fall through
3063     case Bytecodes::_fast_sputfield: // fall through
3064     case Bytecodes::_fast_cputfield: // fall through
3065     case Bytecodes::_fast_iputfield: __ pop_i(r0); break;
3066     case Bytecodes::_fast_dputfield: __ pop_d(); break;
3067     case Bytecodes::_fast_fputfield: __ pop_f(); break;
3068     case Bytecodes::_fast_lputfield: __ pop_l(r0); break;
3069     default: break;
3070     }
3071     __ bind(L2);
3072   }
3073 }
3074 
3075 void TemplateTable::fast_storefield(TosState state)
3076 {
3077   transition(state, vtos);
3078 
3079   ByteSize base = ConstantPoolCache::base_offset();
3080 
3081   jvmti_post_fast_field_mod();
3082 
3083   // access constant pool cache
3084   __ get_cache_and_index_at_bcp(r2, r1, 1);
3085 
3086   // test for volatile with r3
3087   __ ldrw(r3, Address(r2, in_bytes(base +
3088                                    ConstantPoolCacheEntry::flags_offset())));
3089 
3090   // replace index with field offset from cache entry
3091   __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3092 
3093   {
3094     Label notVolatile;
3095     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3096     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
3097     __ bind(notVolatile);
3098   }
3099 
3100   Label notVolatile;
3101 
3102   // Get object from stack
3103   pop_and_check_object(r2);
3104 
3105   // field address
3106   const Address field(r2, r1);
3107 
3108   // access field
3109   switch (bytecode()) {
3110   case Bytecodes::_fast_aputfield:
3111     do_oop_store(_masm, field, r0, IN_HEAP);
3112     break;
3113   case Bytecodes::_fast_lputfield:
3114     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3115     break;
3116   case Bytecodes::_fast_iputfield:
3117     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3118     break;
3119   case Bytecodes::_fast_zputfield:
3120     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
3121     break;
3122   case Bytecodes::_fast_bputfield:
3123     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
3124     break;
3125   case Bytecodes::_fast_sputfield:
3126     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3127     break;
3128   case Bytecodes::_fast_cputfield:
3129     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3130     break;
3131   case Bytecodes::_fast_fputfield:
3132     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3133     break;
3134   case Bytecodes::_fast_dputfield:
3135     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3136     break;
3137   default:
3138     ShouldNotReachHere();
3139   }
3140 
3141   {
3142     Label notVolatile;
3143     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3144     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3145     __ bind(notVolatile);
3146   }
3147 }
3148 
3149 
3150 void TemplateTable::fast_accessfield(TosState state)
3151 {
3152   transition(atos, state);
3153   // Do the JVMTI work here to avoid disturbing the register state below
3154   if (JvmtiExport::can_post_field_access()) {
3155     // Check to see if a field access watch has been set before we
3156     // take the time to call into the VM.
3157     Label L1;
3158     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3159     __ ldrw(r2, Address(rscratch1));
3160     __ cbzw(r2, L1);
3161     // access constant pool cache entry
3162     __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);
3163     __ verify_oop(r0);
3164     __ push_ptr(r0);  // save object pointer before call_VM() clobbers it
3165     __ mov(c_rarg1, r0);
3166     // c_rarg1: object pointer copied above
3167     // c_rarg2: cache entry pointer
3168     __ call_VM(noreg,
3169                CAST_FROM_FN_PTR(address,
3170                                 InterpreterRuntime::post_field_access),
3171                c_rarg1, c_rarg2);
3172     __ pop_ptr(r0); // restore object pointer
3173     __ bind(L1);
3174   }
3175 
3176   // access constant pool cache
3177   __ get_cache_and_index_at_bcp(r2, r1, 1);
3178   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3179                                   ConstantPoolCacheEntry::f2_offset())));
3180   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3181                                    ConstantPoolCacheEntry::flags_offset())));
3182 
3183   // r0: object
3184   __ verify_oop(r0);
3185   __ null_check(r0);
3186   const Address field(r0, r1);
3187 
3188   // 8179954: We need to make sure that the code generated for
3189   // volatile accesses forms a sequentially-consistent set of
3190   // operations when combined with STLR and LDAR.  Without a leading
3191   // membar it&#39;s possible for a simple Dekker test to fail if loads
3192   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3193   // the stores in one method and we interpret the loads in another.
3194   if (! UseBarriersForVolatile) {
3195     Label notVolatile;
3196     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3197     __ membar(MacroAssembler::AnyAny);
3198     __ bind(notVolatile);
3199   }
3200 
3201   // access field
3202   switch (bytecode()) {
3203   case Bytecodes::_fast_agetfield:
3204     do_oop_load(_masm, field, r0, IN_HEAP);
3205     __ verify_oop(r0);
3206     break;
3207   case Bytecodes::_fast_lgetfield:
3208     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3209     break;
3210   case Bytecodes::_fast_igetfield:
3211     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3212     break;
3213   case Bytecodes::_fast_bgetfield:
3214     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
3215     break;
3216   case Bytecodes::_fast_sgetfield:
3217     __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
3218     break;
3219   case Bytecodes::_fast_cgetfield:
3220     __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
3221     break;
3222   case Bytecodes::_fast_fgetfield:
3223     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3224     break;
3225   case Bytecodes::_fast_dgetfield:
3226     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3227     break;
3228   default:
3229     ShouldNotReachHere();
3230   }
3231   {
3232     Label notVolatile;
3233     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3234     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3235     __ bind(notVolatile);
3236   }
3237 }
3238 
3239 void TemplateTable::fast_xaccess(TosState state)
3240 {
3241   transition(vtos, state);
3242 
3243   // get receiver
3244   __ ldr(r0, aaddress(0));
3245   // access constant pool cache
3246   __ get_cache_and_index_at_bcp(r2, r3, 2);
3247   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3248                                   ConstantPoolCacheEntry::f2_offset())));
3249 
3250   // 8179954: We need to make sure that the code generated for
3251   // volatile accesses forms a sequentially-consistent set of
3252   // operations when combined with STLR and LDAR.  Without a leading
3253   // membar it&#39;s possible for a simple Dekker test to fail if loads
3254   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3255   // the stores in one method and we interpret the loads in another.
3256   if (! UseBarriersForVolatile) {
3257     Label notVolatile;
3258     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3259                                      ConstantPoolCacheEntry::flags_offset())));
3260     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3261     __ membar(MacroAssembler::AnyAny);
3262     __ bind(notVolatile);
3263   }
3264 
3265   // make sure exception is reported in correct bcp range (getfield is
3266   // next instruction)
3267   __ increment(rbcp);
3268   __ null_check(r0);
3269   switch (state) {
3270   case itos:
3271     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3272     break;
3273   case atos:
3274     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3275     __ verify_oop(r0);
3276     break;
3277   case ftos:
3278     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3279     break;
3280   default:
3281     ShouldNotReachHere();
3282   }
3283 
3284   {
3285     Label notVolatile;
3286     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3287                                      ConstantPoolCacheEntry::flags_offset())));
3288     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3289     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3290     __ bind(notVolatile);
3291   }
3292 
3293   __ decrement(rbcp);
3294 }
3295 
3296 
3297 
3298 //-----------------------------------------------------------------------------
3299 // Calls
3300 
3301 void TemplateTable::count_calls(Register method, Register temp)
3302 {
3303   __ call_Unimplemented();
3304 }
3305 
3306 void TemplateTable::prepare_invoke(int byte_no,
3307                                    Register method, // linked method (or i-klass)
3308                                    Register index,  // itable index, MethodType, etc.
3309                                    Register recv,   // if caller wants to see it
3310                                    Register flags   // if caller wants to test it
3311                                    ) {
3312   // determine flags
3313   Bytecodes::Code code = bytecode();
3314   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3315   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3316   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3317   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3318   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3319   const bool load_receiver       = (recv  != noreg);
3320   const bool save_flags          = (flags != noreg);
3321   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3322   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3323   assert(flags == noreg || flags == r3, &quot;&quot;);
3324   assert(recv  == noreg || recv  == r2, &quot;&quot;);
3325 
3326   // setup registers &amp; access constant pool cache
3327   if (recv  == noreg)  recv  = r2;
3328   if (flags == noreg)  flags = r3;
3329   assert_different_registers(method, index, recv, flags);
3330 
3331   // save &#39;interpreter return address&#39;
3332   __ save_bcp();
3333 
3334   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3335 
3336   // maybe push appendix to arguments (just before return address)
3337   if (is_invokedynamic || is_invokehandle) {
3338     Label L_no_push;
3339     __ tbz(flags, ConstantPoolCacheEntry::has_appendix_shift, L_no_push);
3340     // Push the appendix as a trailing parameter.
3341     // This must be done before we get the receiver,
3342     // since the parameter_size includes it.
3343     __ push(r19);
3344     __ mov(r19, index);
3345     __ load_resolved_reference_at_index(index, r19);
3346     __ pop(r19);
3347     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3348     __ bind(L_no_push);
3349   }
3350 
3351   // load receiver if needed (note: no return address pushed yet)
3352   if (load_receiver) {
3353     __ andw(recv, flags, ConstantPoolCacheEntry::parameter_size_mask);
3354     // FIXME -- is this actually correct? looks like it should be 2
3355     // const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3356     // const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3357     // Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3358     // __ movptr(recv, recv_addr);
3359     __ add(rscratch1, esp, recv, ext::uxtx, 3); // FIXME: uxtb here?
3360     __ ldr(recv, Address(rscratch1, -Interpreter::expr_offset_in_bytes(1)));
3361     __ verify_oop(recv);
3362   }
3363 
3364   // compute return type
3365   // x86 uses a shift and mask or wings it with a shift plus assert
3366   // the mask is not needed. aarch64 just uses bitfield extract
3367   __ ubfxw(rscratch2, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
3368   // load return address
3369   {
3370     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3371     __ mov(rscratch1, table_addr);
3372     __ ldr(lr, Address(rscratch1, rscratch2, Address::lsl(3)));
3373   }
3374 }
3375 
3376 
3377 void TemplateTable::invokevirtual_helper(Register index,
3378                                          Register recv,
3379                                          Register flags)
3380 {
3381   // Uses temporary registers r0, r3
3382   assert_different_registers(index, recv, r0, r3);
3383   // Test for an invoke of a final method
3384   Label notFinal;
3385   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
3386 
3387   const Register method = index;  // method must be rmethod
3388   assert(method == rmethod,
3389          &quot;methodOop must be rmethod for interpreter calling convention&quot;);
3390 
3391   // do the call - the index is actually the method to call
3392   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3393 
3394   // It&#39;s final, need a null check here!
3395   __ null_check(recv);
3396 
3397   // profile this call
3398   __ profile_final_call(r0);
3399   __ profile_arguments_type(r0, method, r4, true);
3400 
3401   __ jump_from_interpreted(method, r0);
3402 
3403   __ bind(notFinal);
3404 
3405   // get receiver klass
3406   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3407   __ load_klass(r0, recv);
3408 
3409   // profile this call
3410   __ profile_virtual_call(r0, rlocals, r3);
3411 
3412   // get target methodOop &amp; entry point
3413   __ lookup_virtual_method(r0, index, method);
3414   __ profile_arguments_type(r3, method, r4, true);
3415   // FIXME -- this looks completely redundant. is it?
3416   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
3417   __ jump_from_interpreted(method, r3);
3418 }
3419 
3420 void TemplateTable::invokevirtual(int byte_no)
3421 {
3422   transition(vtos, vtos);
3423   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3424 
3425   prepare_invoke(byte_no, rmethod, noreg, r2, r3);
3426 
3427   // rmethod: index (actually a Method*)
3428   // r2: receiver
3429   // r3: flags
3430 
3431   invokevirtual_helper(rmethod, r2, r3);
3432 }
3433 
3434 void TemplateTable::invokespecial(int byte_no)
3435 {
3436   transition(vtos, vtos);
3437   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3438 
3439   prepare_invoke(byte_no, rmethod, noreg,  // get f1 Method*
3440                  r2);  // get receiver also for null check
3441   __ verify_oop(r2);
3442   __ null_check(r2);
3443   // do the call
3444   __ profile_call(r0);
3445   __ profile_arguments_type(r0, rmethod, rbcp, false);
3446   __ jump_from_interpreted(rmethod, r0);
3447 }
3448 
3449 void TemplateTable::invokestatic(int byte_no)
3450 {
3451   transition(vtos, vtos);
3452   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3453 
3454   prepare_invoke(byte_no, rmethod);  // get f1 Method*
3455   // do the call
3456   __ profile_call(r0);
3457   __ profile_arguments_type(r0, rmethod, r4, false);
3458   __ jump_from_interpreted(rmethod, r0);
3459 }
3460 
3461 void TemplateTable::fast_invokevfinal(int byte_no)
3462 {
3463   __ call_Unimplemented();
3464 }
3465 
3466 void TemplateTable::invokeinterface(int byte_no) {
3467   transition(vtos, vtos);
3468   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3469 
3470   prepare_invoke(byte_no, r0, rmethod,  // get f1 Klass*, f2 Method*
3471                  r2, r3); // recv, flags
3472 
3473   // r0: interface klass (from f1)
3474   // rmethod: method (from f2)
3475   // r2: receiver
3476   // r3: flags
3477 
3478   // First check for Object case, then private interface method,
3479   // then regular interface method.
3480 
3481   // Special case of invokeinterface called for virtual method of
3482   // java.lang.Object.  See cpCache.cpp for details.
3483   Label notObjectMethod;
3484   __ tbz(r3, ConstantPoolCacheEntry::is_forced_virtual_shift, notObjectMethod);
3485 
3486   invokevirtual_helper(rmethod, r2, r3);
3487   __ bind(notObjectMethod);
3488 
3489   Label no_such_interface;
3490 
3491   // Check for private method invocation - indicated by vfinal
3492   Label notVFinal;
3493   __ tbz(r3, ConstantPoolCacheEntry::is_vfinal_shift, notVFinal);
3494 
3495   // Get receiver klass into r3 - also a null check
3496   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3497   __ load_klass(r3, r2);
3498 
3499   Label subtype;
3500   __ check_klass_subtype(r3, r0, r4, subtype);
3501   // If we get here the typecheck failed
3502   __ b(no_such_interface);
3503   __ bind(subtype);
3504 
3505   __ profile_final_call(r0);
3506   __ profile_arguments_type(r0, rmethod, r4, true);
3507   __ jump_from_interpreted(rmethod, r0);
3508 
3509   __ bind(notVFinal);
3510 
3511   // Get receiver klass into r3 - also a null check
3512   __ restore_locals();
3513   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3514   __ load_klass(r3, r2);
3515 
3516   Label no_such_method;
3517 
3518   // Preserve method for throw_AbstractMethodErrorVerbose.
3519   __ mov(r16, rmethod);
3520   // Receiver subtype check against REFC.
3521   // Superklass in r0. Subklass in r3. Blows rscratch2, r13
3522   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3523                              r3, r0, noreg,
3524                              // outputs: scan temp. reg, scan temp. reg
3525                              rscratch2, r13,
3526                              no_such_interface,
3527                              /*return_method=*/false);
3528 
3529   // profile this call
3530   __ profile_virtual_call(r3, r13, r19);
3531 
3532   // Get declaring interface class from method, and itable index
3533 
3534   __ load_method_holder(r0, rmethod);
3535   __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
3536   __ subw(rmethod, rmethod, Method::itable_index_max);
3537   __ negw(rmethod, rmethod);
3538 
3539   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3540   __ mov(rlocals, r3);
3541   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3542                              rlocals, r0, rmethod,
3543                              // outputs: method, scan temp. reg
3544                              rmethod, r13,
3545                              no_such_interface);
3546 
3547   // rmethod,: methodOop to call
3548   // r2: receiver
3549   // Check for abstract method error
3550   // Note: This should be done more efficiently via a throw_abstract_method_error
3551   //       interpreter entry point and a conditional jump to it in case of a null
3552   //       method.
3553   __ cbz(rmethod, no_such_method);
3554 
3555   __ profile_arguments_type(r3, rmethod, r13, true);
3556 
3557   // do the call
3558   // r2: receiver
3559   // rmethod,: methodOop
3560   __ jump_from_interpreted(rmethod, r3);
3561   __ should_not_reach_here();
3562 
3563   // exception handling code follows...
3564   // note: must restore interpreter registers to canonical
3565   //       state for exception handling to work correctly!
3566 
3567   __ bind(no_such_method);
3568   // throw exception
3569   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3570   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3571   // Pass arguments for generating a verbose error message.
3572   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose), r3, r16);
3573   // the call_VM checks for exception, so we should never return here.
3574   __ should_not_reach_here();
3575 
3576   __ bind(no_such_interface);
3577   // throw exception
3578   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3579   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3580   // Pass arguments for generating a verbose error message.
3581   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3582                    InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose), r3, r0);
3583   // the call_VM checks for exception, so we should never return here.
3584   __ should_not_reach_here();
3585   return;
3586 }
3587 
3588 void TemplateTable::invokehandle(int byte_no) {
3589   transition(vtos, vtos);
3590   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3591 
3592   prepare_invoke(byte_no, rmethod, r0, r2);
3593   __ verify_method_ptr(r2);
3594   __ verify_oop(r2);
3595   __ null_check(r2);
3596 
3597   // FIXME: profile the LambdaForm also
3598 
3599   // r13 is safe to use here as a scratch reg because it is about to
3600   // be clobbered by jump_from_interpreted().
3601   __ profile_final_call(r13);
3602   __ profile_arguments_type(r13, rmethod, r4, true);
3603 
3604   __ jump_from_interpreted(rmethod, r0);
3605 }
3606 
3607 void TemplateTable::invokedynamic(int byte_no) {
3608   transition(vtos, vtos);
3609   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3610 
3611   prepare_invoke(byte_no, rmethod, r0);
3612 
3613   // r0: CallSite object (from cpool-&gt;resolved_references[])
3614   // rmethod: MH.linkToCallSite method (from f2)
3615 
3616   // Note:  r0_callsite is already pushed by prepare_invoke
3617 
3618   // %%% should make a type profile for any invokedynamic that takes a ref argument
3619   // profile this call
3620   __ profile_call(rbcp);
3621   __ profile_arguments_type(r3, rmethod, r13, false);
3622 
3623   __ verify_oop(r0);
3624 
3625   __ jump_from_interpreted(rmethod, r0);
3626 }
3627 
3628 
3629 //-----------------------------------------------------------------------------
3630 // Allocation
3631 
3632 void TemplateTable::_new() {
3633   transition(vtos, atos);
3634 
3635   __ get_unsigned_2_byte_index_at_bcp(r3, 1);
3636   Label slow_case;
3637   Label done;
3638   Label initialize_header;
3639   Label initialize_object; // including clearing the fields
3640 
3641   __ get_cpool_and_tags(r4, r0);
3642   // Make sure the class we&#39;re about to instantiate has been resolved.
3643   // This is done before loading InstanceKlass to be consistent with the order
3644   // how Constant Pool is updated (see ConstantPool::klass_at_put)
3645   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3646   __ lea(rscratch1, Address(r0, r3, Address::lsl(0)));
3647   __ lea(rscratch1, Address(rscratch1, tags_offset));
3648   __ ldarb(rscratch1, rscratch1);
3649   __ cmp(rscratch1, (u1)JVM_CONSTANT_Class);
3650   __ br(Assembler::NE, slow_case);
3651 
3652   // get InstanceKlass
3653   __ load_resolved_klass_at_offset(r4, r3, r4, rscratch1);
3654 
3655   // make sure klass is initialized &amp; doesn&#39;t have finalizer
3656   // make sure klass is fully initialized
3657   __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));
3658   __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);
3659   __ br(Assembler::NE, slow_case);
3660 
3661   // get instance_size in InstanceKlass (scaled to a count of bytes)
3662   __ ldrw(r3,
3663           Address(r4,
3664                   Klass::layout_helper_offset()));
3665   // test to see if it has a finalizer or is malformed in some way
3666   __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);
3667 
3668   // Allocate the instance:
3669   //  If TLAB is enabled:
3670   //    Try to allocate in the TLAB.
3671   //    If fails, go to the slow path.
3672   //  Else If inline contiguous allocations are enabled:
3673   //    Try to allocate in eden.
3674   //    If fails due to heap end, go to slow path.
3675   //
3676   //  If TLAB is enabled OR inline contiguous is enabled:
3677   //    Initialize the allocation.
3678   //    Exit.
3679   //
3680   //  Go to slow path.
3681   const bool allow_shared_alloc =
3682     Universe::heap()-&gt;supports_inline_contig_alloc();
3683 
3684   if (UseTLAB) {
3685     __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);
3686 
3687     if (ZeroTLAB) {
3688       // the fields have been already cleared
3689       __ b(initialize_header);
3690     } else {
3691       // initialize both the header and fields
3692       __ b(initialize_object);
3693     }
3694   } else {
3695     // Allocation in the shared Eden, if allowed.
3696     //
3697     // r3: instance size in bytes
3698     if (allow_shared_alloc) {
3699       __ eden_allocate(r0, r3, 0, r10, slow_case);
3700     }
3701   }
3702 
3703   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3704   // there is an initialize need. Otherwise, skip and go to the slow path.
3705   if (UseTLAB || allow_shared_alloc) {
3706     // The object is initialized before the header.  If the object size is
3707     // zero, go directly to the header initialization.
3708     __ bind(initialize_object);
3709     __ sub(r3, r3, sizeof(oopDesc));
3710     __ cbz(r3, initialize_header);
3711 
3712     // Initialize object fields
3713     {
3714       __ add(r2, r0, sizeof(oopDesc));
3715       Label loop;
3716       __ bind(loop);
3717       __ str(zr, Address(__ post(r2, BytesPerLong)));
3718       __ sub(r3, r3, BytesPerLong);
3719       __ cbnz(r3, loop);
3720     }
3721 
3722     // initialize object header only.
3723     __ bind(initialize_header);
3724     if (UseBiasedLocking) {
3725       __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
3726     } else {
3727       __ mov(rscratch1, (intptr_t)markWord::prototype().value());
3728     }
3729     __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
3730     __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
3731     __ store_klass(r0, r4);      // store klass last
3732 
3733     {
3734       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);
3735       // Trigger dtrace event for fastpath
3736       __ push(atos); // save the return value
3737       __ call_VM_leaf(
3738            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);
3739       __ pop(atos); // restore the return value
3740 
3741     }
3742 
3743      TSAN_RUNTIME_ONLY(
3744       // return value of new oop is in r0.
3745       __ push(atos);
3746       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj), r0);
3747       __ pop(atos);
3748     );
3749 
3750     __ b(done);
3751   }
3752 
3753   // slow case
3754   __ bind(slow_case);
3755   __ get_constant_pool(c_rarg1);
3756   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3757   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);
3758   __ verify_oop(r0);
3759 
3760   // continue
3761   __ bind(done);
3762   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3763   __ membar(Assembler::StoreStore);
3764 }
3765 
3766 void TemplateTable::newarray() {
3767   transition(itos, atos);
3768   __ load_unsigned_byte(c_rarg1, at_bcp(1));
3769   __ mov(c_rarg2, r0);
3770   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3771           c_rarg1, c_rarg2);
3772   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3773   __ membar(Assembler::StoreStore);
3774 }
3775 
3776 void TemplateTable::anewarray() {
3777   transition(itos, atos);
3778   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3779   __ get_constant_pool(c_rarg1);
3780   __ mov(c_rarg3, r0);
3781   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3782           c_rarg1, c_rarg2, c_rarg3);
3783   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3784   __ membar(Assembler::StoreStore);
3785 }
3786 
3787 void TemplateTable::arraylength() {
3788   transition(atos, itos);
3789   __ null_check(r0, arrayOopDesc::length_offset_in_bytes());
3790   __ ldrw(r0, Address(r0, arrayOopDesc::length_offset_in_bytes()));
3791 }
3792 
3793 void TemplateTable::checkcast()
3794 {
3795   transition(atos, atos);
3796   Label done, is_null, ok_is_subtype, quicked, resolved;
3797   __ cbz(r0, is_null);
3798 
3799   // Get cpool &amp; tags index
3800   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3801   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3802   // See if bytecode has already been quicked
3803   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3804   __ lea(r1, Address(rscratch1, r19));
3805   __ ldarb(r1, r1);
3806   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3807   __ br(Assembler::EQ, quicked);
3808 
3809   __ push(atos); // save receiver for result, and for GC
3810   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3811   // vm_result_2 has metadata result
3812   __ get_vm_result_2(r0, rthread);
3813   __ pop(r3); // restore receiver
3814   __ b(resolved);
3815 
3816   // Get superklass in r0 and subklass in r3
3817   __ bind(quicked);
3818   __ mov(r3, r0); // Save object in r3; r0 needed for subtype check
3819   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1); // r0 = klass
3820 
3821   __ bind(resolved);
3822   __ load_klass(r19, r3);
3823 
3824   // Generate subtype check.  Blows r2, r5.  Object in r3.
3825   // Superklass in r0.  Subklass in r19.
3826   __ gen_subtype_check(r19, ok_is_subtype);
3827 
3828   // Come here on failure
3829   __ push(r3);
3830   // object is at TOS
3831   __ b(Interpreter::_throw_ClassCastException_entry);
3832 
3833   // Come here on success
3834   __ bind(ok_is_subtype);
3835   __ mov(r0, r3); // Restore object in r3
3836 
3837   // Collect counts on whether this test sees NULLs a lot or not.
3838   if (ProfileInterpreter) {
3839     __ b(done);
3840     __ bind(is_null);
3841     __ profile_null_seen(r2);
3842   } else {
3843     __ bind(is_null);   // same as &#39;done&#39;
3844   }
3845   __ bind(done);
3846 }
3847 
3848 void TemplateTable::instanceof() {
3849   transition(atos, itos);
3850   Label done, is_null, ok_is_subtype, quicked, resolved;
3851   __ cbz(r0, is_null);
3852 
3853   // Get cpool &amp; tags index
3854   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3855   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3856   // See if bytecode has already been quicked
3857   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3858   __ lea(r1, Address(rscratch1, r19));
3859   __ ldarb(r1, r1);
3860   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3861   __ br(Assembler::EQ, quicked);
3862 
3863   __ push(atos); // save receiver for result, and for GC
3864   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3865   // vm_result_2 has metadata result
3866   __ get_vm_result_2(r0, rthread);
3867   __ pop(r3); // restore receiver
3868   __ verify_oop(r3);
3869   __ load_klass(r3, r3);
3870   __ b(resolved);
3871 
3872   // Get superklass in r0 and subklass in r3
3873   __ bind(quicked);
3874   __ load_klass(r3, r0);
3875   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1);
3876 
3877   __ bind(resolved);
3878 
3879   // Generate subtype check.  Blows r2, r5
3880   // Superklass in r0.  Subklass in r3.
3881   __ gen_subtype_check(r3, ok_is_subtype);
3882 
3883   // Come here on failure
3884   __ mov(r0, 0);
3885   __ b(done);
3886   // Come here on success
3887   __ bind(ok_is_subtype);
3888   __ mov(r0, 1);
3889 
3890   // Collect counts on whether this test sees NULLs a lot or not.
3891   if (ProfileInterpreter) {
3892     __ b(done);
3893     __ bind(is_null);
3894     __ profile_null_seen(r2);
3895   } else {
3896     __ bind(is_null);   // same as &#39;done&#39;
3897   }
3898   __ bind(done);
3899   // r0 = 0: obj == NULL or  obj is not an instanceof the specified klass
3900   // r0 = 1: obj != NULL and obj is     an instanceof the specified klass
3901 }
3902 
3903 //-----------------------------------------------------------------------------
3904 // Breakpoints
3905 void TemplateTable::_breakpoint() {
3906   // Note: We get here even if we are single stepping..
3907   // jbug inists on setting breakpoints at every bytecode
3908   // even if we are in single step mode.
3909 
3910   transition(vtos, vtos);
3911 
3912   // get the unpatched byte code
3913   __ get_method(c_rarg1);
3914   __ call_VM(noreg,
3915              CAST_FROM_FN_PTR(address,
3916                               InterpreterRuntime::get_original_bytecode_at),
3917              c_rarg1, rbcp);
3918   __ mov(r19, r0);
3919 
3920   // post the breakpoint event
3921   __ call_VM(noreg,
3922              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
3923              rmethod, rbcp);
3924 
3925   // complete the execution of original bytecode
3926   __ mov(rscratch1, r19);
3927   __ dispatch_only_normal(vtos);
3928 }
3929 
3930 //-----------------------------------------------------------------------------
3931 // Exceptions
3932 
3933 void TemplateTable::athrow() {
3934   transition(atos, vtos);
3935   __ null_check(r0);
3936   __ b(Interpreter::throw_exception_entry());
3937 }
3938 
3939 //-----------------------------------------------------------------------------
3940 // Synchronization
3941 //
3942 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
3943 //       in the assembly code structure as well
3944 //
3945 // Stack layout:
3946 //
3947 // [expressions  ] &lt;--- esp               = expression stack top
3948 // ..
3949 // [expressions  ]
3950 // [monitor entry] &lt;--- monitor block top = expression stack bot
3951 // ..
3952 // [monitor entry]
3953 // [frame data   ] &lt;--- monitor block bot
3954 // ...
3955 // [saved rbp    ] &lt;--- rbp
3956 void TemplateTable::monitorenter()
3957 {
3958   transition(atos, vtos);
3959 
3960   // check for NULL object
3961   __ null_check(r0);
3962 
3963   __ resolve(IS_NOT_NULL, r0);
3964 
3965   const Address monitor_block_top(
3966         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3967   const Address monitor_block_bot(
3968         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3969   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3970 
3971   Label allocated;
3972 
3973   // initialize entry pointer
3974   __ mov(c_rarg1, zr); // points to free slot or NULL
3975 
3976   // find a free slot in the monitor block (result in c_rarg1)
3977   {
3978     Label entry, loop, exit;
3979     __ ldr(c_rarg3, monitor_block_top); // points to current entry,
3980                                         // starting with top-most entry
3981     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3982 
3983     __ b(entry);
3984 
3985     __ bind(loop);
3986     // check if current entry is used
3987     // if not used then remember entry in c_rarg1
3988     __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));
3989     __ cmp(zr, rscratch1);
3990     __ csel(c_rarg1, c_rarg3, c_rarg1, Assembler::EQ);
3991     // check if current entry is for same object
3992     __ cmp(r0, rscratch1);
3993     // if same object then stop searching
3994     __ br(Assembler::EQ, exit);
3995     // otherwise advance to next entry
3996     __ add(c_rarg3, c_rarg3, entry_size);
3997     __ bind(entry);
3998     // check if bottom reached
3999     __ cmp(c_rarg3, c_rarg2);
4000     // if not at bottom then check this entry
4001     __ br(Assembler::NE, loop);
4002     __ bind(exit);
4003   }
4004 
4005   __ cbnz(c_rarg1, allocated); // check if a slot has been found and
4006                             // if found, continue with that on
4007 
4008   // allocate one if there&#39;s no free slot
4009   {
4010     Label entry, loop;
4011     // 1. compute new pointers            // rsp: old expression stack top
4012     __ ldr(c_rarg1, monitor_block_bot);   // c_rarg1: old expression stack bottom
4013     __ sub(esp, esp, entry_size);         // move expression stack top
4014     __ sub(c_rarg1, c_rarg1, entry_size); // move expression stack bottom
4015     __ mov(c_rarg3, esp);                 // set start value for copy loop
4016     __ str(c_rarg1, monitor_block_bot);   // set new monitor block bottom
4017 
4018     __ sub(sp, sp, entry_size);           // make room for the monitor
4019 
4020     __ b(entry);
4021     // 2. move expression stack contents
4022     __ bind(loop);
4023     __ ldr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack
4024                                                    // word from old location
4025     __ str(c_rarg2, Address(c_rarg3, 0));          // and store it at new location
4026     __ add(c_rarg3, c_rarg3, wordSize);            // advance to next word
4027     __ bind(entry);
4028     __ cmp(c_rarg3, c_rarg1);        // check if bottom reached
4029     __ br(Assembler::NE, loop);      // if not at bottom then
4030                                      // copy next word
4031   }
4032 
4033   // call run-time routine
4034   // c_rarg1: points to monitor entry
4035   __ bind(allocated);
4036 
4037   // Increment bcp to point to the next bytecode, so exception
4038   // handling for async. exceptions work correctly.
4039   // The object has already been poped from the stack, so the
4040   // expression stack looks correct.
4041   __ increment(rbcp);
4042 
4043   // store object
4044   __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
4045   __ lock_object(c_rarg1);
4046 
4047   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4048   __ save_bcp();  // in case of exception
4049   __ generate_stack_overflow_check(0);
4050 
4051   // The bcp has already been incremented. Just need to dispatch to
4052   // next instruction.
4053   __ dispatch_next(vtos);
4054 }
4055 
4056 
4057 void TemplateTable::monitorexit()
4058 {
4059   transition(atos, vtos);
4060 
4061   // check for NULL object
4062   __ null_check(r0);
4063 
4064   __ resolve(IS_NOT_NULL, r0);
4065 
4066   const Address monitor_block_top(
4067         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4068   const Address monitor_block_bot(
4069         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
4070   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4071 
4072   Label found;
4073 
4074   // find matching slot
4075   {
4076     Label entry, loop;
4077     __ ldr(c_rarg1, monitor_block_top); // points to current entry,
4078                                         // starting with top-most entry
4079     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
4080                                         // of monitor block
4081     __ b(entry);
4082 
4083     __ bind(loop);
4084     // check if current entry is for same object
4085     __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
4086     __ cmp(r0, rscratch1);
4087     // if same object then stop searching
4088     __ br(Assembler::EQ, found);
4089     // otherwise advance to next entry
4090     __ add(c_rarg1, c_rarg1, entry_size);
4091     __ bind(entry);
4092     // check if bottom reached
4093     __ cmp(c_rarg1, c_rarg2);
4094     // if not at bottom then check this entry
4095     __ br(Assembler::NE, loop);
4096   }
4097 
4098   // error handling. Unlocking was not block-structured
4099   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4100                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4101   __ should_not_reach_here();
4102 
4103   // call run-time routine
4104   __ bind(found);
4105   __ push_ptr(r0); // make sure object is on stack (contract with oopMaps)
4106   __ unlock_object(c_rarg1);
4107   __ pop_ptr(r0); // discard object
4108 }
4109 
4110 
4111 // Wide instructions
4112 void TemplateTable::wide()
4113 {
4114   __ load_unsigned_byte(r19, at_bcp(1));
4115   __ mov(rscratch1, (address)Interpreter::_wentry_point);
4116   __ ldr(rscratch1, Address(rscratch1, r19, Address::uxtw(3)));
4117   __ br(rscratch1);
4118 }
4119 
4120 
4121 // Multi arrays
4122 void TemplateTable::multianewarray() {
4123   transition(vtos, atos);
4124   __ load_unsigned_byte(r0, at_bcp(3)); // get number of dimensions
4125   // last dim is on top of stack; we want address of first one:
4126   // first_addr = last_addr + (ndims - 1) * wordSize
4127   __ lea(c_rarg1, Address(esp, r0, Address::uxtw(3)));
4128   __ sub(c_rarg1, c_rarg1, wordSize);
4129   call_VM(r0,
4130           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4131           c_rarg1);
4132   __ load_unsigned_byte(r1, at_bcp(3));
4133   __ lea(esp, Address(esp, r1, Address::uxtw(3)));
4134 }
    </pre>
  </body>
</html>
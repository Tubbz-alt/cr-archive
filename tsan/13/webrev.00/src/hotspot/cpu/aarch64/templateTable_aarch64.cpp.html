<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/method.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 // Platform-dependent initialization
  48 
  49 void TemplateTable::pd_initialize() {
  50   // No aarch64 specific initialization
  51 }
  52 
  53 // Address computation: local variables
  54 
  55 static inline Address iaddress(int n) {
  56   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  57 }
  58 
  59 static inline Address laddress(int n) {
  60   return iaddress(n + 1);
  61 }
  62 
  63 static inline Address faddress(int n) {
  64   return iaddress(n);
  65 }
  66 
  67 static inline Address daddress(int n) {
  68   return laddress(n);
  69 }
  70 
  71 static inline Address aaddress(int n) {
  72   return iaddress(n);
  73 }
  74 
  75 static inline Address iaddress(Register r) {
  76   return Address(rlocals, r, Address::lsl(3));
  77 }
  78 
  79 static inline Address laddress(Register r, Register scratch,
  80                                InterpreterMacroAssembler* _masm) {
  81   __ lea(scratch, Address(rlocals, r, Address::lsl(3)));
  82   return Address(scratch, Interpreter::local_offset_in_bytes(1));
  83 }
  84 
  85 static inline Address faddress(Register r) {
  86   return iaddress(r);
  87 }
  88 
  89 static inline Address daddress(Register r, Register scratch,
  90                                InterpreterMacroAssembler* _masm) {
  91   return laddress(r, scratch, _masm);
  92 }
  93 
  94 static inline Address aaddress(Register r) {
  95   return iaddress(r);
  96 }
  97 
  98 static inline Address at_rsp() {
  99   return Address(esp, 0);
 100 }
 101 
 102 // At top of Java expression stack which may be different than esp().  It
 103 // isn&#39;t for category 1 objects.
 104 static inline Address at_tos   () {
 105   return Address(esp,  Interpreter::expr_offset_in_bytes(0));
 106 }
 107 
 108 static inline Address at_tos_p1() {
 109   return Address(esp,  Interpreter::expr_offset_in_bytes(1));
 110 }
 111 
 112 static inline Address at_tos_p2() {
 113   return Address(esp,  Interpreter::expr_offset_in_bytes(2));
 114 }
 115 
 116 static inline Address at_tos_p3() {
 117   return Address(esp,  Interpreter::expr_offset_in_bytes(3));
 118 }
 119 
 120 static inline Address at_tos_p4() {
 121   return Address(esp,  Interpreter::expr_offset_in_bytes(4));
 122 }
 123 
 124 static inline Address at_tos_p5() {
 125   return Address(esp,  Interpreter::expr_offset_in_bytes(5));
 126 }
 127 
 128 // Condition conversion
 129 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 130   switch (cc) {
 131   case TemplateTable::equal        : return Assembler::NE;
 132   case TemplateTable::not_equal    : return Assembler::EQ;
 133   case TemplateTable::less         : return Assembler::GE;
 134   case TemplateTable::less_equal   : return Assembler::GT;
 135   case TemplateTable::greater      : return Assembler::LE;
 136   case TemplateTable::greater_equal: return Assembler::LT;
 137   }
 138   ShouldNotReachHere();
 139   return Assembler::EQ;
 140 }
 141 
 142 
 143 // Miscelaneous helper routines
 144 // Store an oop (or NULL) at the Address described by obj.
 145 // If val == noreg this means store a NULL
 146 static void do_oop_store(InterpreterMacroAssembler* _masm,
 147                          Address dst,
 148                          Register val,
 149                          DecoratorSet decorators) {
 150   assert(val == noreg || val == r0, &quot;parameter is just for looks&quot;);
 151   __ store_heap_oop(dst, val, r10, r1, decorators);
 152 }
 153 
 154 static void do_oop_load(InterpreterMacroAssembler* _masm,
 155                         Address src,
 156                         Register dst,
 157                         DecoratorSet decorators) {
 158   __ load_heap_oop(dst, src, r10, r1, decorators);
 159 }
 160 
 161 Address TemplateTable::at_bcp(int offset) {
 162   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 163   return Address(rbcp, offset);
 164 }
 165 
 166 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 167                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 168                                    int byte_no)
 169 {
 170   if (!RewriteBytecodes)  return;
 171   Label L_patch_done;
 172 
 173   switch (bc) {
 174   case Bytecodes::_fast_aputfield:
 175   case Bytecodes::_fast_bputfield:
 176   case Bytecodes::_fast_zputfield:
 177   case Bytecodes::_fast_cputfield:
 178   case Bytecodes::_fast_dputfield:
 179   case Bytecodes::_fast_fputfield:
 180   case Bytecodes::_fast_iputfield:
 181   case Bytecodes::_fast_lputfield:
 182   case Bytecodes::_fast_sputfield:
 183     {
 184       // We skip bytecode quickening for putfield instructions when
 185       // the put_code written to the constant pool cache is zero.
 186       // This is required so that every execution of this instruction
 187       // calls out to InterpreterRuntime::resolve_get_put to do
 188       // additional, required work.
 189       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 190       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 191       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 192       __ movw(bc_reg, bc);
 193       __ cbzw(temp_reg, L_patch_done);  // don&#39;t patch
 194     }
 195     break;
 196   default:
 197     assert(byte_no == -1, &quot;sanity&quot;);
 198     // the pair bytecodes have already done the load.
 199     if (load_bc_into_bc_reg) {
 200       __ movw(bc_reg, bc);
 201     }
 202   }
 203 
 204   if (JvmtiExport::can_post_breakpoint()) {
 205     Label L_fast_patch;
 206     // if a breakpoint is present we can&#39;t rewrite the stream directly
 207     __ load_unsigned_byte(temp_reg, at_bcp(0));
 208     __ cmpw(temp_reg, Bytecodes::_breakpoint);
 209     __ br(Assembler::NE, L_fast_patch);
 210     // Let breakpoint table handling rewrite to quicker bytecode
 211     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), rmethod, rbcp, bc_reg);
 212     __ b(L_patch_done);
 213     __ bind(L_fast_patch);
 214   }
 215 
 216 #ifdef ASSERT
 217   Label L_okay;
 218   __ load_unsigned_byte(temp_reg, at_bcp(0));
 219   __ cmpw(temp_reg, (int) Bytecodes::java_code(bc));
 220   __ br(Assembler::EQ, L_okay);
 221   __ cmpw(temp_reg, bc_reg);
 222   __ br(Assembler::EQ, L_okay);
 223   __ stop(&quot;patching the wrong bytecode&quot;);
 224   __ bind(L_okay);
 225 #endif
 226 
 227   // patch bytecode
 228   __ strb(bc_reg, at_bcp(0));
 229   __ bind(L_patch_done);
 230 }
 231 
 232 
 233 // Individual instructions
 234 
 235 void TemplateTable::nop() {
 236   transition(vtos, vtos);
 237   // nothing to do
 238 }
 239 
 240 void TemplateTable::shouldnotreachhere() {
 241   transition(vtos, vtos);
 242   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 243 }
 244 
 245 void TemplateTable::aconst_null()
 246 {
 247   transition(vtos, atos);
 248   __ mov(r0, 0);
 249 }
 250 
 251 void TemplateTable::iconst(int value)
 252 {
 253   transition(vtos, itos);
 254   __ mov(r0, value);
 255 }
 256 
 257 void TemplateTable::lconst(int value)
 258 {
 259   __ mov(r0, value);
 260 }
 261 
 262 void TemplateTable::fconst(int value)
 263 {
 264   transition(vtos, ftos);
 265   switch (value) {
 266   case 0:
 267     __ fmovs(v0, zr);
 268     break;
 269   case 1:
 270     __ fmovs(v0, 1.0);
 271     break;
 272   case 2:
 273     __ fmovs(v0, 2.0);
 274     break;
 275   default:
 276     ShouldNotReachHere();
 277     break;
 278   }
 279 }
 280 
 281 void TemplateTable::dconst(int value)
 282 {
 283   transition(vtos, dtos);
 284   switch (value) {
 285   case 0:
 286     __ fmovd(v0, zr);
 287     break;
 288   case 1:
 289     __ fmovd(v0, 1.0);
 290     break;
 291   case 2:
 292     __ fmovd(v0, 2.0);
 293     break;
 294   default:
 295     ShouldNotReachHere();
 296     break;
 297   }
 298 }
 299 
 300 void TemplateTable::bipush()
 301 {
 302   transition(vtos, itos);
 303   __ load_signed_byte32(r0, at_bcp(1));
 304 }
 305 
 306 void TemplateTable::sipush()
 307 {
 308   transition(vtos, itos);
 309   __ load_unsigned_short(r0, at_bcp(1));
 310   __ revw(r0, r0);
 311   __ asrw(r0, r0, 16);
 312 }
 313 
 314 void TemplateTable::ldc(bool wide)
 315 {
 316   transition(vtos, vtos);
 317   Label call_ldc, notFloat, notClass, notInt, Done;
 318 
 319   if (wide) {
 320     __ get_unsigned_2_byte_index_at_bcp(r1, 1);
 321   } else {
 322     __ load_unsigned_byte(r1, at_bcp(1));
 323   }
 324   __ get_cpool_and_tags(r2, r0);
 325 
 326   const int base_offset = ConstantPool::header_size() * wordSize;
 327   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 328 
 329   // get type
 330   __ add(r3, r1, tags_offset);
 331   __ lea(r3, Address(r0, r3));
 332   __ ldarb(r3, r3);
 333 
 334   // unresolved class - get the resolved class
 335   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClass);
 336   __ br(Assembler::EQ, call_ldc);
 337 
 338   // unresolved class in error state - call into runtime to throw the error
 339   // from the first resolution attempt
 340   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClassInError);
 341   __ br(Assembler::EQ, call_ldc);
 342 
 343   // resolved class - need to call vm to get java mirror of the class
 344   __ cmp(r3, (u1)JVM_CONSTANT_Class);
 345   __ br(Assembler::NE, notClass);
 346 
 347   __ bind(call_ldc);
 348   __ mov(c_rarg1, wide);
 349   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), c_rarg1);
 350   __ push_ptr(r0);
 351   __ verify_oop(r0);
 352   __ b(Done);
 353 
 354   __ bind(notClass);
 355   __ cmp(r3, (u1)JVM_CONSTANT_Float);
 356   __ br(Assembler::NE, notFloat);
 357   // ftos
 358   __ adds(r1, r2, r1, Assembler::LSL, 3);
 359   __ ldrs(v0, Address(r1, base_offset));
 360   __ push_f();
 361   __ b(Done);
 362 
 363   __ bind(notFloat);
 364 
 365   __ cmp(r3, (u1)JVM_CONSTANT_Integer);
 366   __ br(Assembler::NE, notInt);
 367 
 368   // itos
 369   __ adds(r1, r2, r1, Assembler::LSL, 3);
 370   __ ldrw(r0, Address(r1, base_offset));
 371   __ push_i(r0);
 372   __ b(Done);
 373 
 374   __ bind(notInt);
 375   condy_helper(Done);
 376 
 377   __ bind(Done);
 378 }
 379 
 380 // Fast path for caching oop constants.
 381 void TemplateTable::fast_aldc(bool wide)
 382 {
 383   transition(vtos, atos);
 384 
 385   Register result = r0;
 386   Register tmp = r1;
 387   Register rarg = r2;
 388 
 389   int index_size = wide ? sizeof(u2) : sizeof(u1);
 390 
 391   Label resolved;
 392 
 393   // We are resolved if the resolved reference cache entry contains a
 394   // non-null object (String, MethodType, etc.)
 395   assert_different_registers(result, tmp);
 396   __ get_cache_index_at_bcp(tmp, 1, index_size);
 397   __ load_resolved_reference_at_index(result, tmp);
 398   __ cbnz(result, resolved);
 399 
 400   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 401 
 402   // first time invocation - must resolve first
 403   __ mov(rarg, (int)bytecode());
 404   __ call_VM(result, entry, rarg);
 405 
 406   __ bind(resolved);
 407 
 408   { // Check for the null sentinel.
 409     // If we just called the VM, it already did the mapping for us,
 410     // but it&#39;s harmless to retry.
 411     Label notNull;
 412 
 413     // Stash null_sentinel address to get its value later
 414     __ movptr(rarg, (uintptr_t)Universe::the_null_sentinel_addr());
 415     __ ldr(tmp, Address(rarg));
 416     __ cmpoop(result, tmp);
 417     __ br(Assembler::NE, notNull);
 418     __ mov(result, 0);  // NULL object reference
 419     __ bind(notNull);
 420   }
 421 
 422   if (VerifyOops) {
 423     // Safe to call with 0 result
 424     __ verify_oop(result);
 425   }
 426 }
 427 
 428 void TemplateTable::ldc2_w()
 429 {
 430   transition(vtos, vtos);
 431   Label notDouble, notLong, Done;
 432   __ get_unsigned_2_byte_index_at_bcp(r0, 1);
 433 
 434   __ get_cpool_and_tags(r1, r2);
 435   const int base_offset = ConstantPool::header_size() * wordSize;
 436   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 437 
 438   // get type
 439   __ lea(r2, Address(r2, r0, Address::lsl(0)));
 440   __ load_unsigned_byte(r2, Address(r2, tags_offset));
 441   __ cmpw(r2, (int)JVM_CONSTANT_Double);
 442   __ br(Assembler::NE, notDouble);
 443 
 444   // dtos
 445   __ lea (r2, Address(r1, r0, Address::lsl(3)));
 446   __ ldrd(v0, Address(r2, base_offset));
 447   __ push_d();
 448   __ b(Done);
 449 
 450   __ bind(notDouble);
 451   __ cmpw(r2, (int)JVM_CONSTANT_Long);
 452   __ br(Assembler::NE, notLong);
 453 
 454   // ltos
 455   __ lea(r0, Address(r1, r0, Address::lsl(3)));
 456   __ ldr(r0, Address(r0, base_offset));
 457   __ push_l();
 458   __ b(Done);
 459 
 460   __ bind(notLong);
 461   condy_helper(Done);
 462 
 463   __ bind(Done);
 464 }
 465 
 466 void TemplateTable::condy_helper(Label&amp; Done)
 467 {
 468   Register obj = r0;
 469   Register rarg = r1;
 470   Register flags = r2;
 471   Register off = r3;
 472 
 473   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 474 
 475   __ mov(rarg, (int) bytecode());
 476   __ call_VM(obj, entry, rarg);
 477 
 478   __ get_vm_result_2(flags, rthread);
 479 
 480   // VMr = obj = base address to find primitive value to push
 481   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 482   __ mov(off, flags);
 483   __ andw(off, off, ConstantPoolCacheEntry::field_index_mask);
 484 
 485   const Address field(obj, off);
 486 
 487   // What sort of thing are we loading?
 488   // x86 uses a shift and mask or wings it with a shift plus assert
 489   // the mask is not needed. aarch64 just uses bitfield extract
 490   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,
 491            ConstantPoolCacheEntry::tos_state_bits);
 492 
 493   switch (bytecode()) {
 494     case Bytecodes::_ldc:
 495     case Bytecodes::_ldc_w:
 496       {
 497         // tos in (itos, ftos, stos, btos, ctos, ztos)
 498         Label notInt, notFloat, notShort, notByte, notChar, notBool;
 499         __ cmpw(flags, itos);
 500         __ br(Assembler::NE, notInt);
 501         // itos
 502         __ ldrw(r0, field);
 503         __ push(itos);
 504         __ b(Done);
 505 
 506         __ bind(notInt);
 507         __ cmpw(flags, ftos);
 508         __ br(Assembler::NE, notFloat);
 509         // ftos
 510         __ load_float(field);
 511         __ push(ftos);
 512         __ b(Done);
 513 
 514         __ bind(notFloat);
 515         __ cmpw(flags, stos);
 516         __ br(Assembler::NE, notShort);
 517         // stos
 518         __ load_signed_short(r0, field);
 519         __ push(stos);
 520         __ b(Done);
 521 
 522         __ bind(notShort);
 523         __ cmpw(flags, btos);
 524         __ br(Assembler::NE, notByte);
 525         // btos
 526         __ load_signed_byte(r0, field);
 527         __ push(btos);
 528         __ b(Done);
 529 
 530         __ bind(notByte);
 531         __ cmpw(flags, ctos);
 532         __ br(Assembler::NE, notChar);
 533         // ctos
 534         __ load_unsigned_short(r0, field);
 535         __ push(ctos);
 536         __ b(Done);
 537 
 538         __ bind(notChar);
 539         __ cmpw(flags, ztos);
 540         __ br(Assembler::NE, notBool);
 541         // ztos
 542         __ load_signed_byte(r0, field);
 543         __ push(ztos);
 544         __ b(Done);
 545 
 546         __ bind(notBool);
 547         break;
 548       }
 549 
 550     case Bytecodes::_ldc2_w:
 551       {
 552         Label notLong, notDouble;
 553         __ cmpw(flags, ltos);
 554         __ br(Assembler::NE, notLong);
 555         // ltos
 556         __ ldr(r0, field);
 557         __ push(ltos);
 558         __ b(Done);
 559 
 560         __ bind(notLong);
 561         __ cmpw(flags, dtos);
 562         __ br(Assembler::NE, notDouble);
 563         // dtos
 564         __ load_double(field);
 565         __ push(dtos);
 566         __ b(Done);
 567 
 568        __ bind(notDouble);
 569         break;
 570       }
 571 
 572     default:
 573       ShouldNotReachHere();
 574     }
 575 
 576     __ stop(&quot;bad ldc/condy&quot;);
 577 }
 578 
 579 void TemplateTable::locals_index(Register reg, int offset)
 580 {
 581   __ ldrb(reg, at_bcp(offset));
 582   __ neg(reg, reg);
 583 }
 584 
 585 void TemplateTable::iload() {
 586   iload_internal();
 587 }
 588 
 589 void TemplateTable::nofast_iload() {
 590   iload_internal(may_not_rewrite);
 591 }
 592 
 593 void TemplateTable::iload_internal(RewriteControl rc) {
 594   transition(vtos, itos);
 595   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 596     Label rewrite, done;
 597     Register bc = r4;
 598 
 599     // get next bytecode
 600     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 601 
 602     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 603     // last two iloads in a pair.  Comparing against fast_iload means that
 604     // the next bytecode is neither an iload or a caload, and therefore
 605     // an iload pair.
 606     __ cmpw(r1, Bytecodes::_iload);
 607     __ br(Assembler::EQ, done);
 608 
 609     // if _fast_iload rewrite to _fast_iload2
 610     __ cmpw(r1, Bytecodes::_fast_iload);
 611     __ movw(bc, Bytecodes::_fast_iload2);
 612     __ br(Assembler::EQ, rewrite);
 613 
 614     // if _caload rewrite to _fast_icaload
 615     __ cmpw(r1, Bytecodes::_caload);
 616     __ movw(bc, Bytecodes::_fast_icaload);
 617     __ br(Assembler::EQ, rewrite);
 618 
 619     // else rewrite to _fast_iload
 620     __ movw(bc, Bytecodes::_fast_iload);
 621 
 622     // rewrite
 623     // bc: new bytecode
 624     __ bind(rewrite);
 625     patch_bytecode(Bytecodes::_iload, bc, r1, false);
 626     __ bind(done);
 627 
 628   }
 629 
 630   // do iload, get the local value into tos
 631   locals_index(r1);
 632   __ ldr(r0, iaddress(r1));
 633 
 634 }
 635 
 636 void TemplateTable::fast_iload2()
 637 {
 638   transition(vtos, itos);
 639   locals_index(r1);
 640   __ ldr(r0, iaddress(r1));
 641   __ push(itos);
 642   locals_index(r1, 3);
 643   __ ldr(r0, iaddress(r1));
 644 }
 645 
 646 void TemplateTable::fast_iload()
 647 {
 648   transition(vtos, itos);
 649   locals_index(r1);
 650   __ ldr(r0, iaddress(r1));
 651 }
 652 
 653 void TemplateTable::lload()
 654 {
 655   transition(vtos, ltos);
 656   __ ldrb(r1, at_bcp(1));
 657   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 658   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 659 }
 660 
 661 void TemplateTable::fload()
 662 {
 663   transition(vtos, ftos);
 664   locals_index(r1);
 665   // n.b. we use ldrd here because this is a 64 bit slot
 666   // this is comparable to the iload case
 667   __ ldrd(v0, faddress(r1));
 668 }
 669 
 670 void TemplateTable::dload()
 671 {
 672   transition(vtos, dtos);
 673   __ ldrb(r1, at_bcp(1));
 674   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 675   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 676 }
 677 
 678 void TemplateTable::aload()
 679 {
 680   transition(vtos, atos);
 681   locals_index(r1);
 682   __ ldr(r0, iaddress(r1));
 683 }
 684 
 685 void TemplateTable::locals_index_wide(Register reg) {
 686   __ ldrh(reg, at_bcp(2));
 687   __ rev16w(reg, reg);
 688   __ neg(reg, reg);
 689 }
 690 
 691 void TemplateTable::wide_iload() {
 692   transition(vtos, itos);
 693   locals_index_wide(r1);
 694   __ ldr(r0, iaddress(r1));
 695 }
 696 
 697 void TemplateTable::wide_lload()
 698 {
 699   transition(vtos, ltos);
 700   __ ldrh(r1, at_bcp(2));
 701   __ rev16w(r1, r1);
 702   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 703   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 704 }
 705 
 706 void TemplateTable::wide_fload()
 707 {
 708   transition(vtos, ftos);
 709   locals_index_wide(r1);
 710   // n.b. we use ldrd here because this is a 64 bit slot
 711   // this is comparable to the iload case
 712   __ ldrd(v0, faddress(r1));
 713 }
 714 
 715 void TemplateTable::wide_dload()
 716 {
 717   transition(vtos, dtos);
 718   __ ldrh(r1, at_bcp(2));
 719   __ rev16w(r1, r1);
 720   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 721   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 722 }
 723 
 724 void TemplateTable::wide_aload()
 725 {
 726   transition(vtos, atos);
 727   locals_index_wide(r1);
 728   __ ldr(r0, aaddress(r1));
 729 }
 730 
 731 void TemplateTable::index_check(Register array, Register index)
 732 {
 733   // destroys r1, rscratch1
 734   // check array
 735   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 736   // sign extend index for use by indexed load
 737   // __ movl2ptr(index, index);
 738   // check index
 739   Register length = rscratch1;
 740   __ ldrw(length, Address(array, arrayOopDesc::length_offset_in_bytes()));
 741   __ cmpw(index, length);
 742   if (index != r1) {
 743     // ??? convention: move aberrant index into r1 for exception message
 744     assert(r1 != array, &quot;different registers&quot;);
 745     __ mov(r1, index);
 746   }
 747   Label ok;
 748   __ br(Assembler::LO, ok);
 749     // ??? convention: move array into r3 for exception message
 750   __ mov(r3, array);
 751   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 752   __ br(rscratch1);
 753   __ bind(ok);
 754 }
 755 
 756 #if INCLUDE_TSAN
 757 
 758 void TemplateTable::tsan_observe_load_or_store(const Address&amp; field,
 759                                                TsanMemoryReadWriteFunction tsan_function) {
 760   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);
 761   if (!ThreadSanitizerJavaMemory) {
 762     return;
 763   }
 764 
 765   __ pusha();
 766   __ push_d(v0);
 767   __ lea(c_rarg0, field);
 768   __ get_method(c_rarg1);
 769   __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),
 770                   c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);
 771   __ pop_d(v0);
 772   __ popa();
 773 }
 774 
 775 void TemplateTable::tsan_observe_get_or_put(const Address &amp;field,
 776                                             Register flags,
 777                                             TsanMemoryReadWriteFunction tsan_function,
 778                                             TosState tos) {
 779   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);
 780 
 781   TsanMemoryReleaseAcquireFunction releaseAcquireFunction =
 782       tsan_release_acquire_method(tsan_function);
 783 
 784   Label done, notAcquireRelease;
 785 
 786   // We could save some instructions by only saving the registers we need.
 787   __ pusha();
 788   // pusha() doesn&#39;t save v0, which tsan_function clobbers and the
 789   // interpreter still needs.
 790   // This really only needs to be done for some of the float/double accesses,
 791   // but it&#39;s here because it&#39;s cleaner.
 792   __ push_d(v0);
 793   // For volatile reads/writes use an acquire/release.
 794   // If a reference is annotated to be ignored, assume it&#39;s safe to
 795   // access the object it&#39;s referring to and create a happens-before relation
 796   // between the accesses to this reference.
 797   if (tos == atos) {
 798     int32_t acquire_release_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift |
 799       1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift;
 800     // acquire_release_mask (0x8200000) can not be encoded into &#39;tst&#39;, but it can be
 801     // encoded into just one &#39;mov&#39; instruction.
 802     __ mov(rscratch1, acquire_release_mask);
 803     __ tst(flags, rscratch1);
 804     __ br(Assembler::EQ, notAcquireRelease);
 805   } else {
 806     __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);
 807   }
 808 
 809   __ lea(c_rarg0, field);
 810   __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);
 811   if (ThreadSanitizerJavaMemory) {
 812     __ b(done);
 813     __ bind(notAcquireRelease);
 814 
 815     // Ignore reads/writes to final fields. They can&#39;t be racy.
 816     __ tbnz(flags, ConstantPoolCacheEntry::is_final_shift, done);
 817 
 818     // Don&#39;t report races on tsan ignored fields.
 819     __ tbnz(flags, ConstantPoolCacheEntry::is_tsan_ignore_shift, done);
 820 
 821     __ lea(c_rarg0, field);
 822     __ get_method(c_rarg1);
 823     __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),
 824                     c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);
 825 
 826     __ bind(done);
 827   } else {
 828     __ bind(notAcquireRelease);
 829   }
 830   __ pop_d(v0);
 831   __ popa();
 832 }
 833 
 834 
 835 #endif
 836 
 837 void TemplateTable::iaload()
 838 {
 839   transition(itos, itos);
 840   __ mov(r1, r0);
 841   __ pop_ptr(r0);
 842   // r0: array
 843   // r1: index
 844   index_check(r0, r1); // leaves index in r1, kills rscratch1
 845   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
 846   Address addr(r0, r1, Address::uxtw(2));
 847   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));
 848   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 849 }
 850 
 851 void TemplateTable::laload()
 852 {
 853   transition(itos, ltos);
 854   __ mov(r1, r0);
 855   __ pop_ptr(r0);
 856   // r0: array
 857   // r1: index
 858   index_check(r0, r1); // leaves index in r1, kills rscratch1
 859   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
 860   Address addr(r0, r1, Address::uxtw(3));
 861   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));
 862   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 863 }
 864 
 865 void TemplateTable::faload()
 866 {
 867   transition(itos, ftos);
 868   __ mov(r1, r0);
 869   __ pop_ptr(r0);
 870   // r0: array
 871   // r1: index
 872   index_check(r0, r1); // leaves index in r1, kills rscratch1
 873   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
 874   Address addr(r0, r1, Address::uxtw(2));
 875   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));
 876   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 877 }
 878 
 879 void TemplateTable::daload()
 880 {
 881   transition(itos, dtos);
 882   __ mov(r1, r0);
 883   __ pop_ptr(r0);
 884   // r0: array
 885   // r1: index
 886   index_check(r0, r1); // leaves index in r1, kills rscratch1
 887   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
 888   Address addr(r0, r1, Address::uxtw(3));
 889   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));
 890   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 891 }
 892 
 893 void TemplateTable::aaload()
 894 {
 895   transition(itos, atos);
 896   __ mov(r1, r0);
 897   __ pop_ptr(r0);
 898   // r0: array
 899   // r1: index
 900   index_check(r0, r1); // leaves index in r1, kills rscratch1
 901   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 902   Address addr(r0, r1, Address::uxtw(LogBytesPerHeapOop));
 903   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, UseCompressedOops ? SharedRuntime::tsan_read4
 904                                                                        : SharedRuntime::tsan_read8));
 905   do_oop_load(_masm, addr, r0, IS_ARRAY);
 906 }
 907 
 908 void TemplateTable::baload()
 909 {
 910   transition(itos, itos);
 911   __ mov(r1, r0);
 912   __ pop_ptr(r0);
 913   // r0: array
 914   // r1: index
 915   index_check(r0, r1); // leaves index in r1, kills rscratch1
 916   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
 917   Address addr(r0, r1, Address::uxtw(0));
 918   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));
 919   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 920 }
 921 
 922 void TemplateTable::caload()
 923 {
 924   transition(itos, itos);
 925   __ mov(r1, r0);
 926   __ pop_ptr(r0);
 927   // r0: array
 928   // r1: index
 929   index_check(r0, r1); // leaves index in r1, kills rscratch1
 930   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 931   Address addr(r0, r1, Address::uxtw(1));
 932   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));
 933   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 934 }
 935 
 936 // iload followed by caload frequent pair
 937 void TemplateTable::fast_icaload()
 938 {
 939 #ifdef ASSERT
 940   TSAN_RUNTIME_ONLY(__ stop(&quot;bytecode rewrite should have been disabled in TSAN&quot;););
 941 #endif
 942   transition(vtos, itos);
 943   // load index out of locals
 944   locals_index(r2);
 945   __ ldr(r1, iaddress(r2));
 946 
 947   __ pop_ptr(r0);
 948 
 949   // r0: array
 950   // r1: index
 951   index_check(r0, r1); // leaves index in r1, kills rscratch1
 952   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 953   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 954 }
 955 
 956 void TemplateTable::saload()
 957 {
 958   transition(itos, itos);
 959   __ mov(r1, r0);
 960   __ pop_ptr(r0);
 961   // r0: array
 962   // r1: index
 963   index_check(r0, r1); // leaves index in r1, kills rscratch1
 964   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
 965   Address addr(r0, r1, Address::uxtw(1));
 966   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));
 967   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);
 968 }
 969 
 970 void TemplateTable::iload(int n)
 971 {
 972   transition(vtos, itos);
 973   __ ldr(r0, iaddress(n));
 974 }
 975 
 976 void TemplateTable::lload(int n)
 977 {
 978   transition(vtos, ltos);
 979   __ ldr(r0, laddress(n));
 980 }
 981 
 982 void TemplateTable::fload(int n)
 983 {
 984   transition(vtos, ftos);
 985   __ ldrs(v0, faddress(n));
 986 }
 987 
 988 void TemplateTable::dload(int n)
 989 {
 990   transition(vtos, dtos);
 991   __ ldrd(v0, daddress(n));
 992 }
 993 
 994 void TemplateTable::aload(int n)
 995 {
 996   transition(vtos, atos);
 997   __ ldr(r0, iaddress(n));
 998 }
 999 
1000 void TemplateTable::aload_0() {
1001   aload_0_internal();
1002 }
1003 
1004 void TemplateTable::nofast_aload_0() {
1005   aload_0_internal(may_not_rewrite);
1006 }
1007 
1008 void TemplateTable::aload_0_internal(RewriteControl rc) {
1009   // According to bytecode histograms, the pairs:
1010   //
1011   // _aload_0, _fast_igetfield
1012   // _aload_0, _fast_agetfield
1013   // _aload_0, _fast_fgetfield
1014   //
1015   // occur frequently. If RewriteFrequentPairs is set, the (slow)
1016   // _aload_0 bytecode checks if the next bytecode is either
1017   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
1018   // rewrites the current bytecode into a pair bytecode; otherwise it
1019   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
1020   // the pair check anymore.
1021   //
1022   // Note: If the next bytecode is _getfield, the rewrite must be
1023   //       delayed, otherwise we may miss an opportunity for a pair.
1024   //
1025   // Also rewrite frequent pairs
1026   //   aload_0, aload_1
1027   //   aload_0, iload_1
1028   // These bytecodes with a small amount of code are most profitable
1029   // to rewrite
1030   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
1031     Label rewrite, done;
1032     const Register bc = r4;
1033 
1034     // get next bytecode
1035     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
1036 
1037     // if _getfield then wait with rewrite
1038     __ cmpw(r1, Bytecodes::Bytecodes::_getfield);
1039     __ br(Assembler::EQ, done);
1040 
1041     // if _igetfield then rewrite to _fast_iaccess_0
1042     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1043     __ cmpw(r1, Bytecodes::_fast_igetfield);
1044     __ movw(bc, Bytecodes::_fast_iaccess_0);
1045     __ br(Assembler::EQ, rewrite);
1046 
1047     // if _agetfield then rewrite to _fast_aaccess_0
1048     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1049     __ cmpw(r1, Bytecodes::_fast_agetfield);
1050     __ movw(bc, Bytecodes::_fast_aaccess_0);
1051     __ br(Assembler::EQ, rewrite);
1052 
1053     // if _fgetfield then rewrite to _fast_faccess_0
1054     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1055     __ cmpw(r1, Bytecodes::_fast_fgetfield);
1056     __ movw(bc, Bytecodes::_fast_faccess_0);
1057     __ br(Assembler::EQ, rewrite);
1058 
1059     // else rewrite to _fast_aload0
1060     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1061     __ movw(bc, Bytecodes::Bytecodes::_fast_aload_0);
1062 
1063     // rewrite
1064     // bc: new bytecode
1065     __ bind(rewrite);
1066     patch_bytecode(Bytecodes::_aload_0, bc, r1, false);
1067 
1068     __ bind(done);
1069   }
1070 
1071   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
1072   aload(0);
1073 }
1074 
1075 void TemplateTable::istore()
1076 {
1077   transition(itos, vtos);
1078   locals_index(r1);
1079   // FIXME: We&#39;re being very pernickerty here storing a jint in a
1080   // local with strw, which costs an extra instruction over what we&#39;d
1081   // be able to do with a simple str.  We should just store the whole
1082   // word.
1083   __ lea(rscratch1, iaddress(r1));
1084   __ strw(r0, Address(rscratch1));
1085 }
1086 
1087 void TemplateTable::lstore()
1088 {
1089   transition(ltos, vtos);
1090   locals_index(r1);
1091   __ str(r0, laddress(r1, rscratch1, _masm));
1092 }
1093 
1094 void TemplateTable::fstore() {
1095   transition(ftos, vtos);
1096   locals_index(r1);
1097   __ lea(rscratch1, iaddress(r1));
1098   __ strs(v0, Address(rscratch1));
1099 }
1100 
1101 void TemplateTable::dstore() {
1102   transition(dtos, vtos);
1103   locals_index(r1);
1104   __ strd(v0, daddress(r1, rscratch1, _masm));
1105 }
1106 
1107 void TemplateTable::astore()
1108 {
1109   transition(vtos, vtos);
1110   __ pop_ptr(r0);
1111   locals_index(r1);
1112   __ str(r0, aaddress(r1));
1113 }
1114 
1115 void TemplateTable::wide_istore() {
1116   transition(vtos, vtos);
1117   __ pop_i();
1118   locals_index_wide(r1);
1119   __ lea(rscratch1, iaddress(r1));
1120   __ strw(r0, Address(rscratch1));
1121 }
1122 
1123 void TemplateTable::wide_lstore() {
1124   transition(vtos, vtos);
1125   __ pop_l();
1126   locals_index_wide(r1);
1127   __ str(r0, laddress(r1, rscratch1, _masm));
1128 }
1129 
1130 void TemplateTable::wide_fstore() {
1131   transition(vtos, vtos);
1132   __ pop_f();
1133   locals_index_wide(r1);
1134   __ lea(rscratch1, faddress(r1));
1135   __ strs(v0, rscratch1);
1136 }
1137 
1138 void TemplateTable::wide_dstore() {
1139   transition(vtos, vtos);
1140   __ pop_d();
1141   locals_index_wide(r1);
1142   __ strd(v0, daddress(r1, rscratch1, _masm));
1143 }
1144 
1145 void TemplateTable::wide_astore() {
1146   transition(vtos, vtos);
1147   __ pop_ptr(r0);
1148   locals_index_wide(r1);
1149   __ str(r0, aaddress(r1));
1150 }
1151 
1152 void TemplateTable::iastore() {
1153   transition(itos, vtos);
1154   __ pop_i(r1);
1155   __ pop_ptr(r3);
1156   // r0: value
1157   // r1: index
1158   // r3: array
1159   index_check(r3, r1); // prefer index in r1
1160   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
1161   Address addr(r3, r1, Address::uxtw(2));
1162   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));
1163   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);
1164 }
1165 
1166 void TemplateTable::lastore() {
1167   transition(ltos, vtos);
1168   __ pop_i(r1);
1169   __ pop_ptr(r3);
1170   // r0: value
1171   // r1: index
1172   // r3: array
1173   index_check(r3, r1); // prefer index in r1
1174   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
1175   Address addr(r3, r1, Address::uxtw(3));
1176   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));
1177   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);
1178 }
1179 
1180 void TemplateTable::fastore() {
1181   transition(ftos, vtos);
1182   __ pop_i(r1);
1183   __ pop_ptr(r3);
1184   // v0: value
1185   // r1:  index
1186   // r3:  array
1187   index_check(r3, r1); // prefer index in r1
1188   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
1189   Address addr(r3, r1, Address::uxtw(2));
1190   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));
1191   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg /* ftos */, noreg, noreg);
1192 }
1193 
1194 void TemplateTable::dastore() {
1195   transition(dtos, vtos);
1196   __ pop_i(r1);
1197   __ pop_ptr(r3);
1198   // v0: value
1199   // r1:  index
1200   // r3:  array
1201   index_check(r3, r1); // prefer index in r1
1202   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
1203   Address addr(r3, r1, Address::uxtw(3));
1204   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));
1205   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg /* dtos */, noreg, noreg);
1206 }
1207 
1208 void TemplateTable::aastore() {
1209   Label is_null, ok_is_subtype, done;
1210   transition(vtos, vtos);
1211   // stack: ..., array, index, value
1212   __ ldr(r0, at_tos());    // value
1213   __ ldr(r2, at_tos_p1()); // index
1214   __ ldr(r3, at_tos_p2()); // array
1215 
1216   Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
1217 
1218   index_check(r3, r2);     // kills r1
1219   __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
1220   // do tsan write after r4 has been defined.
1221   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(element_address, UseCompressedOops ? SharedRuntime::tsan_write4
1222                                                                                   : SharedRuntime::tsan_write8));
1223   // do array store check - check for NULL value first
1224   __ cbz(r0, is_null);
1225 
1226   // Move subklass into r1
1227   __ load_klass(r1, r0);
1228   // Move superklass into r0
1229   __ load_klass(r0, r3);
1230   __ ldr(r0, Address(r0,
1231                      ObjArrayKlass::element_klass_offset()));
1232   // Compress array + index*oopSize + 12 into a single register.  Frees r2.
1233 
1234   // Generate subtype check.  Blows r2, r5
1235   // Superklass in r0.  Subklass in r1.
1236   __ gen_subtype_check(r1, ok_is_subtype);
1237 
1238   // Come here on failure
1239   // object is at TOS
1240   __ b(Interpreter::_throw_ArrayStoreException_entry);
1241 
1242   // Come here on success
1243   __ bind(ok_is_subtype);
1244 
1245   // Get the value we will store
1246   __ ldr(r0, at_tos());
1247   // Now store using the appropriate barrier
1248   do_oop_store(_masm, element_address, r0, IS_ARRAY);
1249   __ b(done);
1250 
1251   // Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]
1252   __ bind(is_null);
1253   __ profile_null_seen(r2);
1254 
1255   // Store a NULL
1256   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1257 
1258   // Pop stack arguments
1259   __ bind(done);
1260   __ add(esp, esp, 3 * Interpreter::stackElementSize);
1261 }
1262 
1263 void TemplateTable::bastore()
1264 {
1265   transition(itos, vtos);
1266   __ pop_i(r1);
1267   __ pop_ptr(r3);
1268   // r0: value
1269   // r1: index
1270   // r3: array
1271   index_check(r3, r1); // prefer index in r1
1272 
1273   // Need to check whether array is boolean or byte
1274   // since both types share the bastore bytecode.
1275   __ load_klass(r2, r3);
1276   __ ldrw(r2, Address(r2, Klass::layout_helper_offset()));
1277   int diffbit_index = exact_log2(Klass::layout_helper_boolean_diffbit());
1278   Label L_skip;
1279   __ tbz(r2, diffbit_index, L_skip);
1280   __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1281   __ bind(L_skip);
1282 
1283   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
1284   Address addr(r3, r1, Address::uxtw(0));
1285   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));
1286   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);
1287 }
1288 
1289 void TemplateTable::castore()
1290 {
1291   transition(itos, vtos);
1292   __ pop_i(r1);
1293   __ pop_ptr(r3);
1294   // r0: value
1295   // r1: index
1296   // r3: array
1297   index_check(r3, r1); // prefer index in r1
1298   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
1299   Address addr(r3, r1, Address::uxtw(1));
1300   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));
1301   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);
1302 }
1303 
1304 void TemplateTable::sastore()
1305 {
1306   castore();
1307 }
1308 
1309 void TemplateTable::istore(int n)
1310 {
1311   transition(itos, vtos);
1312   __ str(r0, iaddress(n));
1313 }
1314 
1315 void TemplateTable::lstore(int n)
1316 {
1317   transition(ltos, vtos);
1318   __ str(r0, laddress(n));
1319 }
1320 
1321 void TemplateTable::fstore(int n)
1322 {
1323   transition(ftos, vtos);
1324   __ strs(v0, faddress(n));
1325 }
1326 
1327 void TemplateTable::dstore(int n)
1328 {
1329   transition(dtos, vtos);
1330   __ strd(v0, daddress(n));
1331 }
1332 
1333 void TemplateTable::astore(int n)
1334 {
1335   transition(vtos, vtos);
1336   __ pop_ptr(r0);
1337   __ str(r0, iaddress(n));
1338 }
1339 
1340 void TemplateTable::pop()
1341 {
1342   transition(vtos, vtos);
1343   __ add(esp, esp, Interpreter::stackElementSize);
1344 }
1345 
1346 void TemplateTable::pop2()
1347 {
1348   transition(vtos, vtos);
1349   __ add(esp, esp, 2 * Interpreter::stackElementSize);
1350 }
1351 
1352 void TemplateTable::dup()
1353 {
1354   transition(vtos, vtos);
1355   __ ldr(r0, Address(esp, 0));
1356   __ push(r0);
1357   // stack: ..., a, a
1358 }
1359 
1360 void TemplateTable::dup_x1()
1361 {
1362   transition(vtos, vtos);
1363   // stack: ..., a, b
1364   __ ldr(r0, at_tos());  // load b
1365   __ ldr(r2, at_tos_p1());  // load a
1366   __ str(r0, at_tos_p1());  // store b
1367   __ str(r2, at_tos());  // store a
1368   __ push(r0);                  // push b
1369   // stack: ..., b, a, b
1370 }
1371 
1372 void TemplateTable::dup_x2()
1373 {
1374   transition(vtos, vtos);
1375   // stack: ..., a, b, c
1376   __ ldr(r0, at_tos());  // load c
1377   __ ldr(r2, at_tos_p2());  // load a
1378   __ str(r0, at_tos_p2());  // store c in a
1379   __ push(r0);      // push c
1380   // stack: ..., c, b, c, c
1381   __ ldr(r0, at_tos_p2());  // load b
1382   __ str(r2, at_tos_p2());  // store a in b
1383   // stack: ..., c, a, c, c
1384   __ str(r0, at_tos_p1());  // store b in c
1385   // stack: ..., c, a, b, c
1386 }
1387 
1388 void TemplateTable::dup2()
1389 {
1390   transition(vtos, vtos);
1391   // stack: ..., a, b
1392   __ ldr(r0, at_tos_p1());  // load a
1393   __ push(r0);                  // push a
1394   __ ldr(r0, at_tos_p1());  // load b
1395   __ push(r0);                  // push b
1396   // stack: ..., a, b, a, b
1397 }
1398 
1399 void TemplateTable::dup2_x1()
1400 {
1401   transition(vtos, vtos);
1402   // stack: ..., a, b, c
1403   __ ldr(r2, at_tos());  // load c
1404   __ ldr(r0, at_tos_p1());  // load b
1405   __ push(r0);                  // push b
1406   __ push(r2);                  // push c
1407   // stack: ..., a, b, c, b, c
1408   __ str(r2, at_tos_p3());  // store c in b
1409   // stack: ..., a, c, c, b, c
1410   __ ldr(r2, at_tos_p4());  // load a
1411   __ str(r2, at_tos_p2());  // store a in 2nd c
1412   // stack: ..., a, c, a, b, c
1413   __ str(r0, at_tos_p4());  // store b in a
1414   // stack: ..., b, c, a, b, c
1415 }
1416 
1417 void TemplateTable::dup2_x2()
1418 {
1419   transition(vtos, vtos);
1420   // stack: ..., a, b, c, d
1421   __ ldr(r2, at_tos());  // load d
1422   __ ldr(r0, at_tos_p1());  // load c
1423   __ push(r0)            ;      // push c
1424   __ push(r2);                  // push d
1425   // stack: ..., a, b, c, d, c, d
1426   __ ldr(r0, at_tos_p4());  // load b
1427   __ str(r0, at_tos_p2());  // store b in d
1428   __ str(r2, at_tos_p4());  // store d in b
1429   // stack: ..., a, d, c, b, c, d
1430   __ ldr(r2, at_tos_p5());  // load a
1431   __ ldr(r0, at_tos_p3());  // load c
1432   __ str(r2, at_tos_p3());  // store a in c
1433   __ str(r0, at_tos_p5());  // store c in a
1434   // stack: ..., c, d, a, b, c, d
1435 }
1436 
1437 void TemplateTable::swap()
1438 {
1439   transition(vtos, vtos);
1440   // stack: ..., a, b
1441   __ ldr(r2, at_tos_p1());  // load a
1442   __ ldr(r0, at_tos());  // load b
1443   __ str(r2, at_tos());  // store a in b
1444   __ str(r0, at_tos_p1());  // store b in a
1445   // stack: ..., b, a
1446 }
1447 
1448 void TemplateTable::iop2(Operation op)
1449 {
1450   transition(itos, itos);
1451   // r0 &lt;== r1 op r0
1452   __ pop_i(r1);
1453   switch (op) {
1454   case add  : __ addw(r0, r1, r0); break;
1455   case sub  : __ subw(r0, r1, r0); break;
1456   case mul  : __ mulw(r0, r1, r0); break;
1457   case _and : __ andw(r0, r1, r0); break;
1458   case _or  : __ orrw(r0, r1, r0); break;
1459   case _xor : __ eorw(r0, r1, r0); break;
1460   case shl  : __ lslvw(r0, r1, r0); break;
1461   case shr  : __ asrvw(r0, r1, r0); break;
1462   case ushr : __ lsrvw(r0, r1, r0);break;
1463   default   : ShouldNotReachHere();
1464   }
1465 }
1466 
1467 void TemplateTable::lop2(Operation op)
1468 {
1469   transition(ltos, ltos);
1470   // r0 &lt;== r1 op r0
1471   __ pop_l(r1);
1472   switch (op) {
1473   case add  : __ add(r0, r1, r0); break;
1474   case sub  : __ sub(r0, r1, r0); break;
1475   case mul  : __ mul(r0, r1, r0); break;
1476   case _and : __ andr(r0, r1, r0); break;
1477   case _or  : __ orr(r0, r1, r0); break;
1478   case _xor : __ eor(r0, r1, r0); break;
1479   default   : ShouldNotReachHere();
1480   }
1481 }
1482 
1483 void TemplateTable::idiv()
1484 {
1485   transition(itos, itos);
1486   // explicitly check for div0
1487   Label no_div0;
1488   __ cbnzw(r0, no_div0);
1489   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1490   __ br(rscratch1);
1491   __ bind(no_div0);
1492   __ pop_i(r1);
1493   // r0 &lt;== r1 idiv r0
1494   __ corrected_idivl(r0, r1, r0, /* want_remainder */ false);
1495 }
1496 
1497 void TemplateTable::irem()
1498 {
1499   transition(itos, itos);
1500   // explicitly check for div0
1501   Label no_div0;
1502   __ cbnzw(r0, no_div0);
1503   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1504   __ br(rscratch1);
1505   __ bind(no_div0);
1506   __ pop_i(r1);
1507   // r0 &lt;== r1 irem r0
1508   __ corrected_idivl(r0, r1, r0, /* want_remainder */ true);
1509 }
1510 
1511 void TemplateTable::lmul()
1512 {
1513   transition(ltos, ltos);
1514   __ pop_l(r1);
1515   __ mul(r0, r0, r1);
1516 }
1517 
1518 void TemplateTable::ldiv()
1519 {
1520   transition(ltos, ltos);
1521   // explicitly check for div0
1522   Label no_div0;
1523   __ cbnz(r0, no_div0);
1524   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1525   __ br(rscratch1);
1526   __ bind(no_div0);
1527   __ pop_l(r1);
1528   // r0 &lt;== r1 ldiv r0
1529   __ corrected_idivq(r0, r1, r0, /* want_remainder */ false);
1530 }
1531 
1532 void TemplateTable::lrem()
1533 {
1534   transition(ltos, ltos);
1535   // explicitly check for div0
1536   Label no_div0;
1537   __ cbnz(r0, no_div0);
1538   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1539   __ br(rscratch1);
1540   __ bind(no_div0);
1541   __ pop_l(r1);
1542   // r0 &lt;== r1 lrem r0
1543   __ corrected_idivq(r0, r1, r0, /* want_remainder */ true);
1544 }
1545 
1546 void TemplateTable::lshl()
1547 {
1548   transition(itos, ltos);
1549   // shift count is in r0
1550   __ pop_l(r1);
1551   __ lslv(r0, r1, r0);
1552 }
1553 
1554 void TemplateTable::lshr()
1555 {
1556   transition(itos, ltos);
1557   // shift count is in r0
1558   __ pop_l(r1);
1559   __ asrv(r0, r1, r0);
1560 }
1561 
1562 void TemplateTable::lushr()
1563 {
1564   transition(itos, ltos);
1565   // shift count is in r0
1566   __ pop_l(r1);
1567   __ lsrv(r0, r1, r0);
1568 }
1569 
1570 void TemplateTable::fop2(Operation op)
1571 {
1572   transition(ftos, ftos);
1573   switch (op) {
1574   case add:
1575     // n.b. use ldrd because this is a 64 bit slot
1576     __ pop_f(v1);
1577     __ fadds(v0, v1, v0);
1578     break;
1579   case sub:
1580     __ pop_f(v1);
1581     __ fsubs(v0, v1, v0);
1582     break;
1583   case mul:
1584     __ pop_f(v1);
1585     __ fmuls(v0, v1, v0);
1586     break;
1587   case div:
1588     __ pop_f(v1);
1589     __ fdivs(v0, v1, v0);
1590     break;
1591   case rem:
1592     __ fmovs(v1, v0);
1593     __ pop_f(v0);
1594     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1595     break;
1596   default:
1597     ShouldNotReachHere();
1598     break;
1599   }
1600 }
1601 
1602 void TemplateTable::dop2(Operation op)
1603 {
1604   transition(dtos, dtos);
1605   switch (op) {
1606   case add:
1607     // n.b. use ldrd because this is a 64 bit slot
1608     __ pop_d(v1);
1609     __ faddd(v0, v1, v0);
1610     break;
1611   case sub:
1612     __ pop_d(v1);
1613     __ fsubd(v0, v1, v0);
1614     break;
1615   case mul:
1616     __ pop_d(v1);
1617     __ fmuld(v0, v1, v0);
1618     break;
1619   case div:
1620     __ pop_d(v1);
1621     __ fdivd(v0, v1, v0);
1622     break;
1623   case rem:
1624     __ fmovd(v1, v0);
1625     __ pop_d(v0);
1626     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1627     break;
1628   default:
1629     ShouldNotReachHere();
1630     break;
1631   }
1632 }
1633 
1634 void TemplateTable::ineg()
1635 {
1636   transition(itos, itos);
1637   __ negw(r0, r0);
1638 
1639 }
1640 
1641 void TemplateTable::lneg()
1642 {
1643   transition(ltos, ltos);
1644   __ neg(r0, r0);
1645 }
1646 
1647 void TemplateTable::fneg()
1648 {
1649   transition(ftos, ftos);
1650   __ fnegs(v0, v0);
1651 }
1652 
1653 void TemplateTable::dneg()
1654 {
1655   transition(dtos, dtos);
1656   __ fnegd(v0, v0);
1657 }
1658 
1659 void TemplateTable::iinc()
1660 {
1661   transition(vtos, vtos);
1662   __ load_signed_byte(r1, at_bcp(2)); // get constant
1663   locals_index(r2);
1664   __ ldr(r0, iaddress(r2));
1665   __ addw(r0, r0, r1);
1666   __ str(r0, iaddress(r2));
1667 }
1668 
1669 void TemplateTable::wide_iinc()
1670 {
1671   transition(vtos, vtos);
1672   // __ mov(r1, zr);
1673   __ ldrw(r1, at_bcp(2)); // get constant and index
1674   __ rev16(r1, r1);
1675   __ ubfx(r2, r1, 0, 16);
1676   __ neg(r2, r2);
1677   __ sbfx(r1, r1, 16, 16);
1678   __ ldr(r0, iaddress(r2));
1679   __ addw(r0, r0, r1);
1680   __ str(r0, iaddress(r2));
1681 }
1682 
1683 void TemplateTable::convert()
1684 {
1685   // Checking
1686 #ifdef ASSERT
1687   {
1688     TosState tos_in  = ilgl;
1689     TosState tos_out = ilgl;
1690     switch (bytecode()) {
1691     case Bytecodes::_i2l: // fall through
1692     case Bytecodes::_i2f: // fall through
1693     case Bytecodes::_i2d: // fall through
1694     case Bytecodes::_i2b: // fall through
1695     case Bytecodes::_i2c: // fall through
1696     case Bytecodes::_i2s: tos_in = itos; break;
1697     case Bytecodes::_l2i: // fall through
1698     case Bytecodes::_l2f: // fall through
1699     case Bytecodes::_l2d: tos_in = ltos; break;
1700     case Bytecodes::_f2i: // fall through
1701     case Bytecodes::_f2l: // fall through
1702     case Bytecodes::_f2d: tos_in = ftos; break;
1703     case Bytecodes::_d2i: // fall through
1704     case Bytecodes::_d2l: // fall through
1705     case Bytecodes::_d2f: tos_in = dtos; break;
1706     default             : ShouldNotReachHere();
1707     }
1708     switch (bytecode()) {
1709     case Bytecodes::_l2i: // fall through
1710     case Bytecodes::_f2i: // fall through
1711     case Bytecodes::_d2i: // fall through
1712     case Bytecodes::_i2b: // fall through
1713     case Bytecodes::_i2c: // fall through
1714     case Bytecodes::_i2s: tos_out = itos; break;
1715     case Bytecodes::_i2l: // fall through
1716     case Bytecodes::_f2l: // fall through
1717     case Bytecodes::_d2l: tos_out = ltos; break;
1718     case Bytecodes::_i2f: // fall through
1719     case Bytecodes::_l2f: // fall through
1720     case Bytecodes::_d2f: tos_out = ftos; break;
1721     case Bytecodes::_i2d: // fall through
1722     case Bytecodes::_l2d: // fall through
1723     case Bytecodes::_f2d: tos_out = dtos; break;
1724     default             : ShouldNotReachHere();
1725     }
1726     transition(tos_in, tos_out);
1727   }
1728 #endif // ASSERT
1729   // static const int64_t is_nan = 0x8000000000000000L;
1730 
1731   // Conversion
1732   switch (bytecode()) {
1733   case Bytecodes::_i2l:
1734     __ sxtw(r0, r0);
1735     break;
1736   case Bytecodes::_i2f:
1737     __ scvtfws(v0, r0);
1738     break;
1739   case Bytecodes::_i2d:
1740     __ scvtfwd(v0, r0);
1741     break;
1742   case Bytecodes::_i2b:
1743     __ sxtbw(r0, r0);
1744     break;
1745   case Bytecodes::_i2c:
1746     __ uxthw(r0, r0);
1747     break;
1748   case Bytecodes::_i2s:
1749     __ sxthw(r0, r0);
1750     break;
1751   case Bytecodes::_l2i:
1752     __ uxtw(r0, r0);
1753     break;
1754   case Bytecodes::_l2f:
1755     __ scvtfs(v0, r0);
1756     break;
1757   case Bytecodes::_l2d:
1758     __ scvtfd(v0, r0);
1759     break;
1760   case Bytecodes::_f2i:
1761   {
1762     Label L_Okay;
1763     __ clear_fpsr();
1764     __ fcvtzsw(r0, v0);
1765     __ get_fpsr(r1);
1766     __ cbzw(r1, L_Okay);
1767     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i));
1768     __ bind(L_Okay);
1769   }
1770     break;
1771   case Bytecodes::_f2l:
1772   {
1773     Label L_Okay;
1774     __ clear_fpsr();
1775     __ fcvtzs(r0, v0);
1776     __ get_fpsr(r1);
1777     __ cbzw(r1, L_Okay);
1778     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l));
1779     __ bind(L_Okay);
1780   }
1781     break;
1782   case Bytecodes::_f2d:
1783     __ fcvts(v0, v0);
1784     break;
1785   case Bytecodes::_d2i:
1786   {
1787     Label L_Okay;
1788     __ clear_fpsr();
1789     __ fcvtzdw(r0, v0);
1790     __ get_fpsr(r1);
1791     __ cbzw(r1, L_Okay);
1792     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i));
1793     __ bind(L_Okay);
1794   }
1795     break;
1796   case Bytecodes::_d2l:
1797   {
1798     Label L_Okay;
1799     __ clear_fpsr();
1800     __ fcvtzd(r0, v0);
1801     __ get_fpsr(r1);
1802     __ cbzw(r1, L_Okay);
1803     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l));
1804     __ bind(L_Okay);
1805   }
1806     break;
1807   case Bytecodes::_d2f:
1808     __ fcvtd(v0, v0);
1809     break;
1810   default:
1811     ShouldNotReachHere();
1812   }
1813 }
1814 
1815 void TemplateTable::lcmp()
1816 {
1817   transition(ltos, itos);
1818   Label done;
1819   __ pop_l(r1);
1820   __ cmp(r1, r0);
1821   __ mov(r0, (u_int64_t)-1L);
1822   __ br(Assembler::LT, done);
1823   // __ mov(r0, 1UL);
1824   // __ csel(r0, r0, zr, Assembler::NE);
1825   // and here is a faster way
1826   __ csinc(r0, zr, zr, Assembler::EQ);
1827   __ bind(done);
1828 }
1829 
1830 void TemplateTable::float_cmp(bool is_float, int unordered_result)
1831 {
1832   Label done;
1833   if (is_float) {
1834     // XXX get rid of pop here, use ... reg, mem32
1835     __ pop_f(v1);
1836     __ fcmps(v1, v0);
1837   } else {
1838     // XXX get rid of pop here, use ... reg, mem64
1839     __ pop_d(v1);
1840     __ fcmpd(v1, v0);
1841   }
1842   if (unordered_result &lt; 0) {
1843     // we want -1 for unordered or less than, 0 for equal and 1 for
1844     // greater than.
1845     __ mov(r0, (u_int64_t)-1L);
1846     // for FP LT tests less than or unordered
1847     __ br(Assembler::LT, done);
1848     // install 0 for EQ otherwise 1
1849     __ csinc(r0, zr, zr, Assembler::EQ);
1850   } else {
1851     // we want -1 for less than, 0 for equal and 1 for unordered or
1852     // greater than.
1853     __ mov(r0, 1L);
1854     // for FP HI tests greater than or unordered
1855     __ br(Assembler::HI, done);
1856     // install 0 for EQ otherwise ~0
1857     __ csinv(r0, zr, zr, Assembler::EQ);
1858 
1859   }
1860   __ bind(done);
1861 }
1862 
1863 void TemplateTable::branch(bool is_jsr, bool is_wide)
1864 {
1865   // We might be moving to a safepoint.  The thread which calls
1866   // Interpreter::notice_safepoints() will effectively flush its cache
1867   // when it makes a system call, but we need to do something to
1868   // ensure that we see the changed dispatch table.
1869   __ membar(MacroAssembler::LoadLoad);
1870 
1871   __ profile_taken_branch(r0, r1);
1872   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
1873                              InvocationCounter::counter_offset();
1874   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
1875                               InvocationCounter::counter_offset();
1876 
1877   // load branch displacement
1878   if (!is_wide) {
1879     __ ldrh(r2, at_bcp(1));
1880     __ rev16(r2, r2);
1881     // sign extend the 16 bit value in r2
1882     __ sbfm(r2, r2, 0, 15);
1883   } else {
1884     __ ldrw(r2, at_bcp(1));
1885     __ revw(r2, r2);
1886     // sign extend the 32 bit value in r2
1887     __ sbfm(r2, r2, 0, 31);
1888   }
1889 
1890   // Handle all the JSR stuff here, then exit.
1891   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
1892   // normal-branch stuff occurring below.
1893 
1894   if (is_jsr) {
1895     // Pre-load the next target bytecode into rscratch1
1896     __ load_unsigned_byte(rscratch1, Address(rbcp, r2));
1897     // compute return address as bci
1898     __ ldr(rscratch2, Address(rmethod, Method::const_offset()));
1899     __ add(rscratch2, rscratch2,
1900            in_bytes(ConstMethod::codes_offset()) - (is_wide ? 5 : 3));
1901     __ sub(r1, rbcp, rscratch2);
1902     __ push_i(r1);
1903     // Adjust the bcp by the 16-bit displacement in r2
1904     __ add(rbcp, rbcp, r2);
1905     __ dispatch_only(vtos, /*generate_poll*/true);
1906     return;
1907   }
1908 
1909   // Normal (non-jsr) branch handling
1910 
1911   // Adjust the bcp by the displacement in r2
1912   __ add(rbcp, rbcp, r2);
1913 
1914   assert(UseLoopCounter || !UseOnStackReplacement,
1915          &quot;on-stack-replacement requires loop counters&quot;);
1916   Label backedge_counter_overflow;
1917   Label profile_method;
1918   Label dispatch;
1919   if (UseLoopCounter) {
1920     // increment backedge counter for backward branches
1921     // r0: MDO
1922     // w1: MDO bumped taken-count
1923     // r2: target offset
1924     __ cmp(r2, zr);
1925     __ br(Assembler::GT, dispatch); // count only if backward branch
1926 
1927     // ECN: FIXME: This code smells
1928     // check if MethodCounters exists
1929     Label has_counters;
1930     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1931     __ cbnz(rscratch1, has_counters);
1932     __ push(r0);
1933     __ push(r1);
1934     __ push(r2);
1935     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
1936             InterpreterRuntime::build_method_counters), rmethod);
1937     __ pop(r2);
1938     __ pop(r1);
1939     __ pop(r0);
1940     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1941     __ cbz(rscratch1, dispatch); // No MethodCounters allocated, OutOfMemory
1942     __ bind(has_counters);
1943 
1944     if (TieredCompilation) {
1945       Label no_mdo;
1946       int increment = InvocationCounter::count_increment;
1947       if (ProfileInterpreter) {
1948         // Are we profiling?
1949         __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));
1950         __ cbz(r1, no_mdo);
1951         // Increment the MDO backedge counter
1952         const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +
1953                                            in_bytes(InvocationCounter::counter_offset()));
1954         const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));
1955         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1956                                    r0, rscratch1, false, Assembler::EQ,
1957                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1958         __ b(dispatch);
1959       }
1960       __ bind(no_mdo);
1961       // Increment backedge counter in MethodCounters*
1962       __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1963       const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));
1964       __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,
1965                                  r0, rscratch2, false, Assembler::EQ,
1966                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1967     } else { // not TieredCompilation
1968       // increment counter
1969       __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));
1970       __ ldrw(r0, Address(rscratch2, be_offset));        // load backedge counter
1971       __ addw(rscratch1, r0, InvocationCounter::count_increment); // increment counter
1972       __ strw(rscratch1, Address(rscratch2, be_offset));        // store counter
1973 
1974       __ ldrw(r0, Address(rscratch2, inv_offset));    // load invocation counter
1975       __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); // and the status bits
1976       __ addw(r0, r0, rscratch1);        // add both counters
1977 
1978       if (ProfileInterpreter) {
1979         // Test to see if we should create a method data oop
1980         __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
1981         __ cmpw(r0, rscratch1);
1982         __ br(Assembler::LT, dispatch);
1983 
1984         // if no method data exists, go to profile method
1985         __ test_method_data_pointer(r0, profile_method);
1986 
1987         if (UseOnStackReplacement) {
1988           // check for overflow against w1 which is the MDO taken count
1989           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1990           __ cmpw(r1, rscratch1);
1991           __ br(Assembler::LO, dispatch); // Intel == Assembler::below
1992 
1993           // When ProfileInterpreter is on, the backedge_count comes
1994           // from the MethodData*, which value does not get reset on
1995           // the call to frequency_counter_overflow().  To avoid
1996           // excessive calls to the overflow routine while the method is
1997           // being compiled, add a second test to make sure the overflow
1998           // function is called only once every overflow_frequency.
1999           const int overflow_frequency = 1024;
2000           __ andsw(r1, r1, overflow_frequency - 1);
2001           __ br(Assembler::EQ, backedge_counter_overflow);
2002 
2003         }
2004       } else {
2005         if (UseOnStackReplacement) {
2006           // check for overflow against w0, which is the sum of the
2007           // counters
2008           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2009           __ cmpw(r0, rscratch1);
2010           __ br(Assembler::HS, backedge_counter_overflow); // Intel == Assembler::aboveEqual
2011         }
2012       }
2013     }
2014     __ bind(dispatch);
2015   }
2016 
2017   // Pre-load the next target bytecode into rscratch1
2018   __ load_unsigned_byte(rscratch1, Address(rbcp, 0));
2019 
2020   // continue with the bytecode @ target
2021   // rscratch1: target bytecode
2022   // rbcp: target bcp
2023   __ dispatch_only(vtos, /*generate_poll*/true);
2024 
2025   if (UseLoopCounter) {
2026     if (ProfileInterpreter) {
2027       // Out-of-line code to allocate method data oop.
2028       __ bind(profile_method);
2029       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2030       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
2031       __ set_method_data_pointer_for_bcp();
2032       __ b(dispatch);
2033     }
2034 
2035     if (UseOnStackReplacement) {
2036       // invocation counter overflow
2037       __ bind(backedge_counter_overflow);
2038       __ neg(r2, r2);
2039       __ add(r2, r2, rbcp);     // branch bcp
2040       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
2041       __ call_VM(noreg,
2042                  CAST_FROM_FN_PTR(address,
2043                                   InterpreterRuntime::frequency_counter_overflow),
2044                  r2);
2045       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
2046 
2047       // r0: osr nmethod (osr ok) or NULL (osr not possible)
2048       // w1: target bytecode
2049       // r2: scratch
2050       __ cbz(r0, dispatch);     // test result -- no osr if null
2051       // nmethod may have been invalidated (VM may block upon call_VM return)
2052       __ ldrb(r2, Address(r0, nmethod::state_offset()));
2053       if (nmethod::in_use != 0)
2054         __ sub(r2, r2, nmethod::in_use);
2055       __ cbnz(r2, dispatch);
2056 
2057       // We have the address of an on stack replacement routine in r0
2058       // We need to prepare to execute the OSR method. First we must
2059       // migrate the locals and monitors off of the stack.
2060 
2061       __ mov(r19, r0);                             // save the nmethod
2062 
2063       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2064 
2065       // r0 is OSR buffer, move it to expected parameter location
2066       __ mov(j_rarg0, r0);
2067 
2068       // remove activation
2069       // get sender esp
2070       __ ldr(esp,
2071           Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));
2072       // remove frame anchor
2073       __ leave();
2074       // Ensure compiled code always sees stack at proper alignment
2075       __ andr(sp, esp, -16);
2076 
2077       // and begin the OSR nmethod
2078       __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));
2079       __ br(rscratch1);
2080     }
2081   }
2082 }
2083 
2084 
2085 void TemplateTable::if_0cmp(Condition cc)
2086 {
2087   transition(itos, vtos);
2088   // assume branch is more often taken than not (loops use backward branches)
2089   Label not_taken;
2090   if (cc == equal)
2091     __ cbnzw(r0, not_taken);
2092   else if (cc == not_equal)
2093     __ cbzw(r0, not_taken);
2094   else {
2095     __ andsw(zr, r0, r0);
2096     __ br(j_not(cc), not_taken);
2097   }
2098 
2099   branch(false, false);
2100   __ bind(not_taken);
2101   __ profile_not_taken_branch(r0);
2102 }
2103 
2104 void TemplateTable::if_icmp(Condition cc)
2105 {
2106   transition(itos, vtos);
2107   // assume branch is more often taken than not (loops use backward branches)
2108   Label not_taken;
2109   __ pop_i(r1);
2110   __ cmpw(r1, r0, Assembler::LSL);
2111   __ br(j_not(cc), not_taken);
2112   branch(false, false);
2113   __ bind(not_taken);
2114   __ profile_not_taken_branch(r0);
2115 }
2116 
2117 void TemplateTable::if_nullcmp(Condition cc)
2118 {
2119   transition(atos, vtos);
2120   // assume branch is more often taken than not (loops use backward branches)
2121   Label not_taken;
2122   if (cc == equal)
2123     __ cbnz(r0, not_taken);
2124   else
2125     __ cbz(r0, not_taken);
2126   branch(false, false);
2127   __ bind(not_taken);
2128   __ profile_not_taken_branch(r0);
2129 }
2130 
2131 void TemplateTable::if_acmp(Condition cc)
2132 {
2133   transition(atos, vtos);
2134   // assume branch is more often taken than not (loops use backward branches)
2135   Label not_taken;
2136   __ pop_ptr(r1);
2137   __ cmpoop(r1, r0);
2138   __ br(j_not(cc), not_taken);
2139   branch(false, false);
2140   __ bind(not_taken);
2141   __ profile_not_taken_branch(r0);
2142 }
2143 
2144 void TemplateTable::ret() {
2145   transition(vtos, vtos);
2146   // We might be moving to a safepoint.  The thread which calls
2147   // Interpreter::notice_safepoints() will effectively flush its cache
2148   // when it makes a system call, but we need to do something to
2149   // ensure that we see the changed dispatch table.
2150   __ membar(MacroAssembler::LoadLoad);
2151 
2152   locals_index(r1);
2153   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2154   __ profile_ret(r1, r2);
2155   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2156   __ lea(rbcp, Address(rbcp, r1));
2157   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2158   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2159 }
2160 
2161 void TemplateTable::wide_ret() {
2162   transition(vtos, vtos);
2163   locals_index_wide(r1);
2164   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2165   __ profile_ret(r1, r2);
2166   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2167   __ lea(rbcp, Address(rbcp, r1));
2168   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2169   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2170 }
2171 
2172 
2173 void TemplateTable::tableswitch() {
2174   Label default_case, continue_execution;
2175   transition(itos, vtos);
2176   // align rbcp
2177   __ lea(r1, at_bcp(BytesPerInt));
2178   __ andr(r1, r1, -BytesPerInt);
2179   // load lo &amp; hi
2180   __ ldrw(r2, Address(r1, BytesPerInt));
2181   __ ldrw(r3, Address(r1, 2 * BytesPerInt));
2182   __ rev32(r2, r2);
2183   __ rev32(r3, r3);
2184   // check against lo &amp; hi
2185   __ cmpw(r0, r2);
2186   __ br(Assembler::LT, default_case);
2187   __ cmpw(r0, r3);
2188   __ br(Assembler::GT, default_case);
2189   // lookup dispatch offset
2190   __ subw(r0, r0, r2);
2191   __ lea(r3, Address(r1, r0, Address::uxtw(2)));
2192   __ ldrw(r3, Address(r3, 3 * BytesPerInt));
2193   __ profile_switch_case(r0, r1, r2);
2194   // continue execution
2195   __ bind(continue_execution);
2196   __ rev32(r3, r3);
2197   __ load_unsigned_byte(rscratch1, Address(rbcp, r3, Address::sxtw(0)));
2198   __ add(rbcp, rbcp, r3, ext::sxtw);
2199   __ dispatch_only(vtos, /*generate_poll*/true);
2200   // handle default
2201   __ bind(default_case);
2202   __ profile_switch_default(r0);
2203   __ ldrw(r3, Address(r1, 0));
2204   __ b(continue_execution);
2205 }
2206 
2207 void TemplateTable::lookupswitch() {
2208   transition(itos, itos);
2209   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2210 }
2211 
2212 void TemplateTable::fast_linearswitch() {
2213   transition(itos, vtos);
2214   Label loop_entry, loop, found, continue_execution;
2215   // bswap r0 so we can avoid bswapping the table entries
2216   __ rev32(r0, r0);
2217   // align rbcp
2218   __ lea(r19, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2219                                     // this instruction (change offsets
2220                                     // below)
2221   __ andr(r19, r19, -BytesPerInt);
2222   // set counter
2223   __ ldrw(r1, Address(r19, BytesPerInt));
2224   __ rev32(r1, r1);
2225   __ b(loop_entry);
2226   // table search
2227   __ bind(loop);
2228   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2229   __ ldrw(rscratch1, Address(rscratch1, 2 * BytesPerInt));
2230   __ cmpw(r0, rscratch1);
2231   __ br(Assembler::EQ, found);
2232   __ bind(loop_entry);
2233   __ subs(r1, r1, 1);
2234   __ br(Assembler::PL, loop);
2235   // default case
2236   __ profile_switch_default(r0);
2237   __ ldrw(r3, Address(r19, 0));
2238   __ b(continue_execution);
2239   // entry found -&gt; get offset
2240   __ bind(found);
2241   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2242   __ ldrw(r3, Address(rscratch1, 3 * BytesPerInt));
2243   __ profile_switch_case(r1, r0, r19);
2244   // continue execution
2245   __ bind(continue_execution);
2246   __ rev32(r3, r3);
2247   __ add(rbcp, rbcp, r3, ext::sxtw);
2248   __ ldrb(rscratch1, Address(rbcp, 0));
2249   __ dispatch_only(vtos, /*generate_poll*/true);
2250 }
2251 
2252 void TemplateTable::fast_binaryswitch() {
2253   transition(itos, vtos);
2254   // Implementation using the following core algorithm:
2255   //
2256   // int binary_search(int key, LookupswitchPair* array, int n) {
2257   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2258   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2259   //   int i = 0;
2260   //   int j = n;
2261   //   while (i+1 &lt; j) {
2262   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2263   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2264   //     // where a stands for the array and assuming that the (inexisting)
2265   //     // element a[n] is infinitely big.
2266   //     int h = (i + j) &gt;&gt; 1;
2267   //     // i &lt; h &lt; j
2268   //     if (key &lt; array[h].fast_match()) {
2269   //       j = h;
2270   //     } else {
2271   //       i = h;
2272   //     }
2273   //   }
2274   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2275   //   // (i.e., if key is within array, i is the correct index)
2276   //   return i;
2277   // }
2278 
2279   // Register allocation
2280   const Register key   = r0; // already set (tosca)
2281   const Register array = r1;
2282   const Register i     = r2;
2283   const Register j     = r3;
2284   const Register h     = rscratch1;
2285   const Register temp  = rscratch2;
2286 
2287   // Find array start
2288   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2289                                           // get rid of this
2290                                           // instruction (change
2291                                           // offsets below)
2292   __ andr(array, array, -BytesPerInt);
2293 
2294   // Initialize i &amp; j
2295   __ mov(i, 0);                            // i = 0;
2296   __ ldrw(j, Address(array, -BytesPerInt)); // j = length(array);
2297 
2298   // Convert j into native byteordering
2299   __ rev32(j, j);
2300 
2301   // And start
2302   Label entry;
2303   __ b(entry);
2304 
2305   // binary search loop
2306   {
2307     Label loop;
2308     __ bind(loop);
2309     // int h = (i + j) &gt;&gt; 1;
2310     __ addw(h, i, j);                           // h = i + j;
2311     __ lsrw(h, h, 1);                                   // h = (i + j) &gt;&gt; 1;
2312     // if (key &lt; array[h].fast_match()) {
2313     //   j = h;
2314     // } else {
2315     //   i = h;
2316     // }
2317     // Convert array[h].match to native byte-ordering before compare
2318     __ ldr(temp, Address(array, h, Address::lsl(3)));
2319     __ rev32(temp, temp);
2320     __ cmpw(key, temp);
2321     // j = h if (key &lt;  array[h].fast_match())
2322     __ csel(j, h, j, Assembler::LT);
2323     // i = h if (key &gt;= array[h].fast_match())
2324     __ csel(i, h, i, Assembler::GE);
2325     // while (i+1 &lt; j)
2326     __ bind(entry);
2327     __ addw(h, i, 1);          // i+1
2328     __ cmpw(h, j);             // i+1 &lt; j
2329     __ br(Assembler::LT, loop);
2330   }
2331 
2332   // end of binary search, result index is i (must check again!)
2333   Label default_case;
2334   // Convert array[i].match to native byte-ordering before compare
2335   __ ldr(temp, Address(array, i, Address::lsl(3)));
2336   __ rev32(temp, temp);
2337   __ cmpw(key, temp);
2338   __ br(Assembler::NE, default_case);
2339 
2340   // entry found -&gt; j = offset
2341   __ add(j, array, i, ext::uxtx, 3);
2342   __ ldrw(j, Address(j, BytesPerInt));
2343   __ profile_switch_case(i, key, array);
2344   __ rev32(j, j);
2345   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2346   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2347   __ dispatch_only(vtos, /*generate_poll*/true);
2348 
2349   // default case -&gt; j = default offset
2350   __ bind(default_case);
2351   __ profile_switch_default(i);
2352   __ ldrw(j, Address(array, -2 * BytesPerInt));
2353   __ rev32(j, j);
2354   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2355   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2356   __ dispatch_only(vtos, /*generate_poll*/true);
2357 }
2358 
2359 
2360 void TemplateTable::_return(TosState state)
2361 {
2362   transition(state, state);
2363   assert(_desc-&gt;calls_vm(),
2364          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2365 
2366   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2367     assert(state == vtos, &quot;only valid state&quot;);
2368 
2369     __ ldr(c_rarg1, aaddress(0));
2370     __ load_klass(r3, c_rarg1);
2371     __ ldrw(r3, Address(r3, Klass::access_flags_offset()));
2372     Label skip_register_finalizer;
2373     __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2374 
2375     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), c_rarg1);
2376 
2377     __ bind(skip_register_finalizer);
2378   }
2379 
2380   // Issue a StoreStore barrier after all stores but before return
2381   // from any constructor for any class with a final field.  We don&#39;t
2382   // know if this is a finalizer, so we always do so.
2383   if (_desc-&gt;bytecode() == Bytecodes::_return)
2384     __ membar(MacroAssembler::StoreStore);
2385 
2386   // Narrow result if state is itos but result type is smaller.
2387   // Need to narrow in the return bytecode rather than in generate_return_entry
2388   // since compiled code callers expect the result to already be narrowed.
2389   if (state == itos) {
2390     __ narrow(r0);
2391   }
2392 
2393   __ remove_activation(state);
2394   __ ret(lr);
2395 }
2396 
2397 // ----------------------------------------------------------------------------
2398 // Volatile variables demand their effects be made known to all CPU&#39;s
2399 // in order.  Store buffers on most chips allow reads &amp; writes to
2400 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2401 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2402 // the interpreter does not reorder volatile references, the hardware
2403 // also must not reorder them).
2404 //
2405 // According to the new Java Memory Model (JMM):
2406 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2407 //     writes act as aquire &amp; release, so:
2408 // (2) A read cannot let unrelated NON-volatile memory refs that
2409 //     happen after the read float up to before the read.  It&#39;s OK for
2410 //     non-volatile memory refs that happen before the volatile read to
2411 //     float down below it.
2412 // (3) Similar a volatile write cannot let unrelated NON-volatile
2413 //     memory refs that happen BEFORE the write float down to after the
2414 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2415 //     volatile write to float up before it.
2416 //
2417 // We only put in barriers around volatile refs (they are expensive),
2418 // not _between_ memory refs (that would require us to track the
2419 // flavor of the previous memory refs).  Requirements (2) and (3)
2420 // require some barriers before volatile stores and after volatile
2421 // loads.  These nearly cover requirement (1) but miss the
2422 // volatile-store-volatile-load case.  This final case is placed after
2423 // volatile-stores although it could just as well go before
2424 // volatile-loads.
2425 
2426 void TemplateTable::resolve_cache_and_index(int byte_no,
2427                                             Register Rcache,
2428                                             Register index,
2429                                             size_t index_size) {
2430   const Register temp = r19;
2431   assert_different_registers(Rcache, index, temp);
2432 
2433   Label resolved, clinit_barrier_slow;
2434 
2435   Bytecodes::Code code = bytecode();
2436   switch (code) {
2437   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2438   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2439   default: break;
2440   }
2441 
2442   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2443   __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
2444   __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
2445   __ br(Assembler::EQ, resolved);
2446 
2447   // resolve first time through
2448   // Class initialization barrier slow path lands here as well.
2449   __ bind(clinit_barrier_slow);
2450   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2451   __ mov(temp, (int) code);
2452   __ call_VM(noreg, entry, temp);
2453 
2454   // Update registers with resolved info
2455   __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
2456   // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
2457   // so all clients ofthis method must be modified accordingly
2458   __ bind(resolved);
2459 
2460   // Class initialization barrier for static methods
2461   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2462     __ load_resolved_method_at_index(byte_no, temp, Rcache);
2463     __ load_method_holder(temp, temp);
2464     __ clinit_barrier(temp, rscratch1, NULL, &amp;clinit_barrier_slow);
2465   }
2466 }
2467 
2468 // The Rcache and index registers must be set before call
2469 // n.b unlike x86 cache already includes the index offset
2470 void TemplateTable::load_field_cp_cache_entry(Register obj,
2471                                               Register cache,
2472                                               Register index,
2473                                               Register off,
2474                                               Register flags,
2475                                               bool is_static = false) {
2476   assert_different_registers(cache, index, flags, off);
2477 
2478   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2479   // Field offset
2480   __ ldr(off, Address(cache, in_bytes(cp_base_offset +
2481                                           ConstantPoolCacheEntry::f2_offset())));
2482   // Flags
2483   __ ldrw(flags, Address(cache, in_bytes(cp_base_offset +
2484                                            ConstantPoolCacheEntry::flags_offset())));
2485 
2486   // klass overwrite register
2487   if (is_static) {
2488     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
2489                                         ConstantPoolCacheEntry::f1_offset())));
2490     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2491     __ ldr(obj, Address(obj, mirror_offset));
2492     __ resolve_oop_handle(obj);
2493     TSAN_RUNTIME_ONLY(
2494       // Draw a happens-before edge from the class&#39;s static initializer to
2495       // this lookup.
2496 
2497       // java_lang_Class::_init_lock_offset may not have been initialized
2498       // when generating code. It will be initialized at runtime though.
2499       // So calculate its address and read from it at runtime.
2500       __ pusha();
2501       __ mov(c_rarg0, obj);
2502       Address init_lock_offset_address((address) java_lang_Class::init_lock_offset_addr(),
2503                                        relocInfo::none);
2504       __ lea(rscratch1, init_lock_offset_address);
2505       __ ldrw(rscratch1, Address(rscratch1, 0));
2506       __ add(c_rarg0, c_rarg0, rscratch1);
2507       __ call_VM_leaf(CAST_FROM_FN_PTR(address,
2508                                        SharedRuntime::tsan_acquire),
2509                                        c_rarg0);
2510       __ popa();
2511     );
2512   }
2513 }
2514 
2515 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2516                                                Register method,
2517                                                Register itable_index,
2518                                                Register flags,
2519                                                bool is_invokevirtual,
2520                                                bool is_invokevfinal, /*unused*/
2521                                                bool is_invokedynamic) {
2522   // setup registers
2523   const Register cache = rscratch2;
2524   const Register index = r4;
2525   assert_different_registers(method, flags);
2526   assert_different_registers(method, cache, index);
2527   assert_different_registers(itable_index, flags);
2528   assert_different_registers(itable_index, cache, index);
2529   // determine constant pool cache field offsets
2530   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2531   const int method_offset = in_bytes(
2532     ConstantPoolCache::base_offset() +
2533       (is_invokevirtual
2534        ? ConstantPoolCacheEntry::f2_offset()
2535        : ConstantPoolCacheEntry::f1_offset()));
2536   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2537                                     ConstantPoolCacheEntry::flags_offset());
2538   // access constant pool cache fields
2539   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2540                                     ConstantPoolCacheEntry::f2_offset());
2541 
2542   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2543   resolve_cache_and_index(byte_no, cache, index, index_size);
2544   __ ldr(method, Address(cache, method_offset));
2545 
2546   if (itable_index != noreg) {
2547     __ ldr(itable_index, Address(cache, index_offset));
2548   }
2549   __ ldrw(flags, Address(cache, flags_offset));
2550 }
2551 
2552 
2553 // The registers cache and index expected to be set before call.
2554 // Correct values of the cache and index registers are preserved.
2555 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2556                                             bool is_static, bool has_tos) {
2557   // do the JVMTI work here to avoid disturbing the register state below
2558   // We use c_rarg registers here because we want to use the register used in
2559   // the call to the VM
2560   if (JvmtiExport::can_post_field_access()) {
2561     // Check to see if a field access watch has been set before we
2562     // take the time to call into the VM.
2563     Label L1;
2564     assert_different_registers(cache, index, r0);
2565     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2566     __ ldrw(r0, Address(rscratch1));
2567     __ cbzw(r0, L1);
2568 
2569     __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);
2570     __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));
2571 
2572     if (is_static) {
2573       __ mov(c_rarg1, zr); // NULL object reference
2574     } else {
2575       __ ldr(c_rarg1, at_tos()); // get object pointer without popping it
2576       __ verify_oop(c_rarg1);
2577     }
2578     // c_rarg1: object pointer or NULL
2579     // c_rarg2: cache entry pointer
2580     // c_rarg3: jvalue object on the stack
2581     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2582                                        InterpreterRuntime::post_field_access),
2583                c_rarg1, c_rarg2, c_rarg3);
2584     __ get_cache_and_index_at_bcp(cache, index, 1);
2585     __ bind(L1);
2586   }
2587 }
2588 
2589 void TemplateTable::pop_and_check_object(Register r)
2590 {
2591   __ pop_ptr(r);
2592   __ null_check(r);  // for field access must check obj.
2593   __ verify_oop(r);
2594 }
2595 
2596 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc)
2597 {
2598   const Register cache = r2;
2599   const Register index = r3;
2600   const Register obj   = r4;
2601   const Register off   = r19;
2602   const Register flags = r0;
2603   const Register raw_flags = r6;
2604   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2605 
2606   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2607   jvmti_post_field_access(cache, index, is_static, false);
2608   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2609 
2610   if (!is_static) {
2611     // obj is on the stack
2612     pop_and_check_object(obj);
2613   }
2614 
2615   // 8179954: We need to make sure that the code generated for
2616   // volatile accesses forms a sequentially-consistent set of
2617   // operations when combined with STLR and LDAR.  Without a leading
2618   // membar it&#39;s possible for a simple Dekker test to fail if loads
2619   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2620   // the stores in one method and we interpret the loads in another.
2621   if (! UseBarriersForVolatile) {
2622     Label notVolatile;
2623     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2624     __ membar(MacroAssembler::AnyAny);
2625     __ bind(notVolatile);
2626   }
2627 
2628   const Address field(obj, off);
2629 
2630   Label Done, notByte, notBool, notInt, notShort, notChar,
2631               notLong, notFloat, notObj, notDouble;
2632 
2633   // x86 uses a shift and mask or wings it with a shift plus assert
2634   // the mask is not needed. aarch64 just uses bitfield extract
2635   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2636            ConstantPoolCacheEntry::tos_state_bits);
2637 
2638   assert(btos == 0, &quot;change code, btos != 0&quot;);
2639   __ cbnz(flags, notByte);
2640 
2641   // Don&#39;t rewrite getstatic, only getfield
2642   if (is_static) rc = may_not_rewrite;
2643 
2644   // btos
2645   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
2646   __ push(btos);
2647   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, btos));
2648   // Rewrite bytecode to be faster
2649   if (rc == may_rewrite) {
2650     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2651   }
2652   __ b(Done);
2653 
2654   __ bind(notByte);
2655   __ cmp(flags, (u1)ztos);
2656   __ br(Assembler::NE, notBool);
2657 
2658   // ztos (same code as btos)
2659   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
2660   __ push(ztos);
2661   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, ztos));
2662   // Rewrite bytecode to be faster
2663   if (rc == may_rewrite) {
2664     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2665     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2666   }
2667   __ b(Done);
2668 
2669   __ bind(notBool);
2670   __ cmp(flags, (u1)atos);
2671   __ br(Assembler::NE, notObj);
2672   // atos
2673   do_oop_load(_masm, field, r0, IN_HEAP);
2674   __ push(atos);
2675   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,
2676                                             raw_flags,
2677                                             UseCompressedOops ? SharedRuntime::tsan_read4
2678                                                               : SharedRuntime::tsan_read8,
2679                                             atos));
2680   if (rc == may_rewrite) {
2681     patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2682   }
2683   __ b(Done);
2684 
2685   __ bind(notObj);
2686   __ cmp(flags, (u1)itos);
2687   __ br(Assembler::NE, notInt);
2688   // itos
2689   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
2690   __ push(itos);
2691   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, itos));
2692   // Rewrite bytecode to be faster
2693   if (rc == may_rewrite) {
2694     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
2695   }
2696   __ b(Done);
2697 
2698   __ bind(notInt);
2699   __ cmp(flags, (u1)ctos);
2700   __ br(Assembler::NE, notChar);
2701   // ctos
2702   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
2703   __ push(ctos);
2704   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, ctos));
2705   // Rewrite bytecode to be faster
2706   if (rc == may_rewrite) {
2707     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
2708   }
2709   __ b(Done);
2710 
2711   __ bind(notChar);
2712   __ cmp(flags, (u1)stos);
2713   __ br(Assembler::NE, notShort);
2714   // stos
2715   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
2716   __ push(stos);
2717   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, stos));
2718   // Rewrite bytecode to be faster
2719   if (rc == may_rewrite) {
2720     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
2721   }
2722   __ b(Done);
2723 
2724   __ bind(notShort);
2725   __ cmp(flags, (u1)ltos);
2726   __ br(Assembler::NE, notLong);
2727   // ltos
2728   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
2729   __ push(ltos);
2730   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, ltos));
2731   // Rewrite bytecode to be faster
2732   if (rc == may_rewrite) {
2733     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
2734   }
2735   __ b(Done);
2736 
2737   __ bind(notLong);
2738   __ cmp(flags, (u1)ftos);
2739   __ br(Assembler::NE, notFloat);
2740   // ftos
2741   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2742   __ push(ftos);
2743   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, ftos));
2744   // Rewrite bytecode to be faster
2745   if (rc == may_rewrite) {
2746     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
2747   }
2748   __ b(Done);
2749 
2750   __ bind(notFloat);
2751 #ifdef ASSERT
2752   __ cmp(flags, (u1)dtos);
2753   __ br(Assembler::NE, notDouble);
2754 #endif
2755   // dtos
2756   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2757   __ push(dtos);
2758   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, dtos));
2759   // Rewrite bytecode to be faster
2760   if (rc == may_rewrite) {
2761     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
2762   }
2763 #ifdef ASSERT
2764   __ b(Done);
2765 
2766   __ bind(notDouble);
2767   __ stop(&quot;Bad state&quot;);
2768 #endif
2769 
2770   __ bind(Done);
2771 
2772   Label notVolatile;
2773   __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2774   __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
2775   __ bind(notVolatile);
2776 }
2777 
2778 
2779 void TemplateTable::getfield(int byte_no)
2780 {
2781   getfield_or_static(byte_no, false);
2782 }
2783 
2784 void TemplateTable::nofast_getfield(int byte_no) {
2785   getfield_or_static(byte_no, false, may_not_rewrite);
2786 }
2787 
2788 void TemplateTable::getstatic(int byte_no)
2789 {
2790   getfield_or_static(byte_no, true);
2791 }
2792 
2793 // The registers cache and index expected to be set before call.
2794 // The function may destroy various registers, just not the cache and index registers.
2795 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
2796   transition(vtos, vtos);
2797 
2798   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2799 
2800   if (JvmtiExport::can_post_field_modification()) {
2801     // Check to see if a field modification watch has been set before
2802     // we take the time to call into the VM.
2803     Label L1;
2804     assert_different_registers(cache, index, r0);
2805     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2806     __ ldrw(r0, Address(rscratch1));
2807     __ cbz(r0, L1);
2808 
2809     __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);
2810 
2811     if (is_static) {
2812       // Life is simple.  Null out the object pointer.
2813       __ mov(c_rarg1, zr);
2814     } else {
2815       // Life is harder. The stack holds the value on top, followed by
2816       // the object.  We don&#39;t know the size of the value, though; it
2817       // could be one or two words depending on its type. As a result,
2818       // we must find the type to determine where the object is.
2819       __ ldrw(c_rarg3, Address(c_rarg2,
2820                                in_bytes(cp_base_offset +
2821                                         ConstantPoolCacheEntry::flags_offset())));
2822       __ lsr(c_rarg3, c_rarg3,
2823              ConstantPoolCacheEntry::tos_state_shift);
2824       ConstantPoolCacheEntry::verify_tos_state_shift();
2825       Label nope2, done, ok;
2826       __ ldr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
2827       __ cmpw(c_rarg3, ltos);
2828       __ br(Assembler::EQ, ok);
2829       __ cmpw(c_rarg3, dtos);
2830       __ br(Assembler::NE, nope2);
2831       __ bind(ok);
2832       __ ldr(c_rarg1, at_tos_p2()); // ltos (two word jvalue)
2833       __ bind(nope2);
2834     }
2835     // cache entry pointer
2836     __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));
2837     // object (tos)
2838     __ mov(c_rarg3, esp);
2839     // c_rarg1: object pointer set up above (NULL if static)
2840     // c_rarg2: cache entry pointer
2841     // c_rarg3: jvalue object on the stack
2842     __ call_VM(noreg,
2843                CAST_FROM_FN_PTR(address,
2844                                 InterpreterRuntime::post_field_modification),
2845                c_rarg1, c_rarg2, c_rarg3);
2846     __ get_cache_and_index_at_bcp(cache, index, 1);
2847     __ bind(L1);
2848   }
2849 }
2850 
2851 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2852   transition(vtos, vtos);
2853 
2854   const Register cache = r2;
2855   const Register index = r3;
2856   const Register obj   = r2;
2857   const Register off   = r19;
2858   const Register flags = r0;
2859   const Register bc    = r4;
2860 
2861   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2862   jvmti_post_field_mod(cache, index, is_static);
2863   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2864 
2865   Label Done;
2866   // save raw flags in r5
2867   __ mov(r5, flags);
2868 
2869   {
2870     Label notVolatile;
2871     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2872     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2873     __ bind(notVolatile);
2874   }
2875 
2876   // field address
2877   const Address field(obj, off);
2878 
2879   Label notByte, notBool, notInt, notShort, notChar,
2880         notLong, notFloat, notObj, notDouble;
2881 
2882   // x86 uses a shift and mask or wings it with a shift plus assert
2883   // the mask is not needed. aarch64 just uses bitfield extract
2884   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
2885 
2886   assert(btos == 0, &quot;change code, btos != 0&quot;);
2887   __ cbnz(flags, notByte);
2888 
2889   // Don&#39;t rewrite putstatic, only putfield
2890   if (is_static) rc = may_not_rewrite;
2891 
2892   // btos
2893   {
2894     __ pop(btos);
2895     if (!is_static) pop_and_check_object(obj);
2896     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, btos));
2897     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
2898     if (rc == may_rewrite) {
2899       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
2900     }
2901     __ b(Done);
2902   }
2903 
2904   __ bind(notByte);
2905   __ cmp(flags, (u1)ztos);
2906   __ br(Assembler::NE, notBool);
2907 
2908   // ztos
2909   {
2910     __ pop(ztos);
2911     if (!is_static) pop_and_check_object(obj);
2912     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, ztos));
2913     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
2914     if (rc == may_rewrite) {
2915       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
2916     }
2917     __ b(Done);
2918   }
2919 
2920   __ bind(notBool);
2921   __ cmp(flags, (u1)atos);
2922   __ br(Assembler::NE, notObj);
2923 
2924   // atos
2925   {
2926     __ pop(atos);
2927     if (!is_static) pop_and_check_object(obj);
2928     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,
2929                                               r5,
2930                                               UseCompressedOops ? SharedRuntime::tsan_write4
2931                                                                 : SharedRuntime::tsan_write8,
2932                                               atos));
2933     // Store into the field
2934     do_oop_store(_masm, field, r0, IN_HEAP);
2935     if (rc == may_rewrite) {
2936       patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
2937     }
2938     __ b(Done);
2939   }
2940 
2941   __ bind(notObj);
2942   __ cmp(flags, (u1)itos);
2943   __ br(Assembler::NE, notInt);
2944 
2945   // itos
2946   {
2947     __ pop(itos);
2948     if (!is_static) pop_and_check_object(obj);
2949     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, itos));
2950     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
2951     if (rc == may_rewrite) {
2952       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
2953     }
2954     __ b(Done);
2955   }
2956 
2957   __ bind(notInt);
2958   __ cmp(flags, (u1)ctos);
2959   __ br(Assembler::NE, notChar);
2960 
2961   // ctos
2962   {
2963     __ pop(ctos);
2964     if (!is_static) pop_and_check_object(obj);
2965     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, ctos));
2966     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
2967     if (rc == may_rewrite) {
2968       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
2969     }
2970     __ b(Done);
2971   }
2972 
2973   __ bind(notChar);
2974   __ cmp(flags, (u1)stos);
2975   __ br(Assembler::NE, notShort);
2976 
2977   // stos
2978   {
2979     __ pop(stos);
2980     if (!is_static) pop_and_check_object(obj);
2981     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, stos));
2982     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
2983     if (rc == may_rewrite) {
2984       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
2985     }
2986     __ b(Done);
2987   }
2988 
2989   __ bind(notShort);
2990   __ cmp(flags, (u1)ltos);
2991   __ br(Assembler::NE, notLong);
2992 
2993   // ltos
2994   {
2995     __ pop(ltos);
2996     if (!is_static) pop_and_check_object(obj);
2997     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, ltos));
2998     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
2999     if (rc == may_rewrite) {
3000       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
3001     }
3002     __ b(Done);
3003   }
3004 
3005   __ bind(notLong);
3006   __ cmp(flags, (u1)ftos);
3007   __ br(Assembler::NE, notFloat);
3008 
3009   // ftos
3010   {
3011     __ pop(ftos);
3012     if (!is_static) pop_and_check_object(obj);
3013     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, ftos));
3014     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3015     if (rc == may_rewrite) {
3016       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
3017     }
3018     __ b(Done);
3019   }
3020 
3021   __ bind(notFloat);
3022 #ifdef ASSERT
3023   __ cmp(flags, (u1)dtos);
3024   __ br(Assembler::NE, notDouble);
3025 #endif
3026 
3027   // dtos
3028   {
3029     __ pop(dtos);
3030     if (!is_static) pop_and_check_object(obj);
3031     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, dtos));
3032     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3033     if (rc == may_rewrite) {
3034       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
3035     }
3036   }
3037 
3038 #ifdef ASSERT
3039   __ b(Done);
3040 
3041   __ bind(notDouble);
3042   __ stop(&quot;Bad state&quot;);
3043 #endif
3044 
3045   __ bind(Done);
3046 
3047   {
3048     Label notVolatile;
3049     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3050     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3051     __ bind(notVolatile);
3052   }
3053 }
3054 
3055 void TemplateTable::putfield(int byte_no)
3056 {
3057   putfield_or_static(byte_no, false);
3058 }
3059 
3060 void TemplateTable::nofast_putfield(int byte_no) {
3061   putfield_or_static(byte_no, false, may_not_rewrite);
3062 }
3063 
3064 void TemplateTable::putstatic(int byte_no) {
3065   putfield_or_static(byte_no, true);
3066 }
3067 
3068 void TemplateTable::jvmti_post_fast_field_mod()
3069 {
3070   if (JvmtiExport::can_post_field_modification()) {
3071     // Check to see if a field modification watch has been set before
3072     // we take the time to call into the VM.
3073     Label L2;
3074     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3075     __ ldrw(c_rarg3, Address(rscratch1));
3076     __ cbzw(c_rarg3, L2);
3077     __ pop_ptr(r19);                  // copy the object pointer from tos
3078     __ verify_oop(r19);
3079     __ push_ptr(r19);                 // put the object pointer back on tos
3080     // Save tos values before call_VM() clobbers them. Since we have
3081     // to do it for every data type, we use the saved values as the
3082     // jvalue object.
3083     switch (bytecode()) {          // load values into the jvalue object
3084     case Bytecodes::_fast_aputfield: __ push_ptr(r0); break;
3085     case Bytecodes::_fast_bputfield: // fall through
3086     case Bytecodes::_fast_zputfield: // fall through
3087     case Bytecodes::_fast_sputfield: // fall through
3088     case Bytecodes::_fast_cputfield: // fall through
3089     case Bytecodes::_fast_iputfield: __ push_i(r0); break;
3090     case Bytecodes::_fast_dputfield: __ push_d(); break;
3091     case Bytecodes::_fast_fputfield: __ push_f(); break;
3092     case Bytecodes::_fast_lputfield: __ push_l(r0); break;
3093 
3094     default:
3095       ShouldNotReachHere();
3096     }
3097     __ mov(c_rarg3, esp);             // points to jvalue on the stack
3098     // access constant pool cache entry
3099     __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);
3100     __ verify_oop(r19);
3101     // r19: object pointer copied above
3102     // c_rarg2: cache entry pointer
3103     // c_rarg3: jvalue object on the stack
3104     __ call_VM(noreg,
3105                CAST_FROM_FN_PTR(address,
3106                                 InterpreterRuntime::post_field_modification),
3107                r19, c_rarg2, c_rarg3);
3108 
3109     switch (bytecode()) {             // restore tos values
3110     case Bytecodes::_fast_aputfield: __ pop_ptr(r0); break;
3111     case Bytecodes::_fast_bputfield: // fall through
3112     case Bytecodes::_fast_zputfield: // fall through
3113     case Bytecodes::_fast_sputfield: // fall through
3114     case Bytecodes::_fast_cputfield: // fall through
3115     case Bytecodes::_fast_iputfield: __ pop_i(r0); break;
3116     case Bytecodes::_fast_dputfield: __ pop_d(); break;
3117     case Bytecodes::_fast_fputfield: __ pop_f(); break;
3118     case Bytecodes::_fast_lputfield: __ pop_l(r0); break;
3119     default: break;
3120     }
3121     __ bind(L2);
3122   }
3123 }
3124 
3125 void TemplateTable::fast_storefield(TosState state)
3126 {
3127   transition(state, vtos);
3128 
3129   ByteSize base = ConstantPoolCache::base_offset();
3130 
3131   jvmti_post_fast_field_mod();
3132 
3133   // access constant pool cache
3134   __ get_cache_and_index_at_bcp(r2, r1, 1);
3135 
3136   // test for volatile with r3
3137   __ ldrw(r3, Address(r2, in_bytes(base +
3138                                    ConstantPoolCacheEntry::flags_offset())));
3139 
3140   // replace index with field offset from cache entry
3141   __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3142 
3143   {
3144     Label notVolatile;
3145     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3146     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
3147     __ bind(notVolatile);
3148   }
3149 
3150   Label notVolatile;
3151 
3152   // Get object from stack
3153   pop_and_check_object(r2);
3154 
3155   // field address
3156   const Address field(r2, r1);
3157 
3158   // access field
3159   switch (bytecode()) {
3160   case Bytecodes::_fast_aputfield:
3161     do_oop_store(_masm, field, r0, IN_HEAP);
3162     break;
3163   case Bytecodes::_fast_lputfield:
3164     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3165     break;
3166   case Bytecodes::_fast_iputfield:
3167     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3168     break;
3169   case Bytecodes::_fast_zputfield:
3170     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
3171     break;
3172   case Bytecodes::_fast_bputfield:
3173     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
3174     break;
3175   case Bytecodes::_fast_sputfield:
3176     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3177     break;
3178   case Bytecodes::_fast_cputfield:
3179     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3180     break;
3181   case Bytecodes::_fast_fputfield:
3182     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3183     break;
3184   case Bytecodes::_fast_dputfield:
3185     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3186     break;
3187   default:
3188     ShouldNotReachHere();
3189   }
3190 
3191   {
3192     Label notVolatile;
3193     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3194     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3195     __ bind(notVolatile);
3196   }
3197 }
3198 
3199 
3200 void TemplateTable::fast_accessfield(TosState state)
3201 {
3202 #ifdef ASSERT
3203   TSAN_RUNTIME_ONLY(__ stop(&quot;bytecode rewrite should have been disabled in TSAN&quot;););
3204 #endif
3205   transition(atos, state);
3206   // Do the JVMTI work here to avoid disturbing the register state below
3207   if (JvmtiExport::can_post_field_access()) {
3208     // Check to see if a field access watch has been set before we
3209     // take the time to call into the VM.
3210     Label L1;
3211     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3212     __ ldrw(r2, Address(rscratch1));
3213     __ cbzw(r2, L1);
3214     // access constant pool cache entry
3215     __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);
3216     __ verify_oop(r0);
3217     __ push_ptr(r0);  // save object pointer before call_VM() clobbers it
3218     __ mov(c_rarg1, r0);
3219     // c_rarg1: object pointer copied above
3220     // c_rarg2: cache entry pointer
3221     __ call_VM(noreg,
3222                CAST_FROM_FN_PTR(address,
3223                                 InterpreterRuntime::post_field_access),
3224                c_rarg1, c_rarg2);
3225     __ pop_ptr(r0); // restore object pointer
3226     __ bind(L1);
3227   }
3228 
3229   // access constant pool cache
3230   __ get_cache_and_index_at_bcp(r2, r1, 1);
3231   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3232                                   ConstantPoolCacheEntry::f2_offset())));
3233   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3234                                    ConstantPoolCacheEntry::flags_offset())));
3235 
3236   // r0: object
3237   __ verify_oop(r0);
3238   __ null_check(r0);
3239   const Address field(r0, r1);
3240 
3241   // 8179954: We need to make sure that the code generated for
3242   // volatile accesses forms a sequentially-consistent set of
3243   // operations when combined with STLR and LDAR.  Without a leading
3244   // membar it&#39;s possible for a simple Dekker test to fail if loads
3245   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3246   // the stores in one method and we interpret the loads in another.
3247   if (! UseBarriersForVolatile) {
3248     Label notVolatile;
3249     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3250     __ membar(MacroAssembler::AnyAny);
3251     __ bind(notVolatile);
3252   }
3253 
3254   // access field
3255   switch (bytecode()) {
3256   case Bytecodes::_fast_agetfield:
3257     do_oop_load(_masm, field, r0, IN_HEAP);
3258     __ verify_oop(r0);
3259     break;
3260   case Bytecodes::_fast_lgetfield:
3261     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3262     break;
3263   case Bytecodes::_fast_igetfield:
3264     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3265     break;
3266   case Bytecodes::_fast_bgetfield:
3267     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
3268     break;
3269   case Bytecodes::_fast_sgetfield:
3270     __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
3271     break;
3272   case Bytecodes::_fast_cgetfield:
3273     __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
3274     break;
3275   case Bytecodes::_fast_fgetfield:
3276     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3277     break;
3278   case Bytecodes::_fast_dgetfield:
3279     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3280     break;
3281   default:
3282     ShouldNotReachHere();
3283   }
3284   {
3285     Label notVolatile;
3286     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3287     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3288     __ bind(notVolatile);
3289   }
3290 }
3291 
3292 void TemplateTable::fast_xaccess(TosState state)
3293 {
3294 #ifdef ASSERT
3295   TSAN_RUNTIME_ONLY(__ stop(&quot;bytecode rewrite should have been disabled in TSAN&quot;););
3296 #endif
3297   transition(vtos, state);
3298 
3299   // get receiver
3300   __ ldr(r0, aaddress(0));
3301   // access constant pool cache
3302   __ get_cache_and_index_at_bcp(r2, r3, 2);
3303   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3304                                   ConstantPoolCacheEntry::f2_offset())));
3305 
3306   // 8179954: We need to make sure that the code generated for
3307   // volatile accesses forms a sequentially-consistent set of
3308   // operations when combined with STLR and LDAR.  Without a leading
3309   // membar it&#39;s possible for a simple Dekker test to fail if loads
3310   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3311   // the stores in one method and we interpret the loads in another.
3312   if (! UseBarriersForVolatile) {
3313     Label notVolatile;
3314     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3315                                      ConstantPoolCacheEntry::flags_offset())));
3316     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3317     __ membar(MacroAssembler::AnyAny);
3318     __ bind(notVolatile);
3319   }
3320 
3321   // make sure exception is reported in correct bcp range (getfield is
3322   // next instruction)
3323   __ increment(rbcp);
3324   __ null_check(r0);
3325   switch (state) {
3326   case itos:
3327     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3328     break;
3329   case atos:
3330     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3331     __ verify_oop(r0);
3332     break;
3333   case ftos:
3334     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3335     break;
3336   default:
3337     ShouldNotReachHere();
3338   }
3339 
3340   {
3341     Label notVolatile;
3342     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3343                                      ConstantPoolCacheEntry::flags_offset())));
3344     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3345     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3346     __ bind(notVolatile);
3347   }
3348 
3349   __ decrement(rbcp);
3350 }
3351 
3352 
3353 
3354 //-----------------------------------------------------------------------------
3355 // Calls
3356 
3357 void TemplateTable::count_calls(Register method, Register temp)
3358 {
3359   __ call_Unimplemented();
3360 }
3361 
3362 void TemplateTable::prepare_invoke(int byte_no,
3363                                    Register method, // linked method (or i-klass)
3364                                    Register index,  // itable index, MethodType, etc.
3365                                    Register recv,   // if caller wants to see it
3366                                    Register flags   // if caller wants to test it
3367                                    ) {
3368   // determine flags
3369   Bytecodes::Code code = bytecode();
3370   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3371   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3372   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3373   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3374   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3375   const bool load_receiver       = (recv  != noreg);
3376   const bool save_flags          = (flags != noreg);
3377   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3378   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3379   assert(flags == noreg || flags == r3, &quot;&quot;);
3380   assert(recv  == noreg || recv  == r2, &quot;&quot;);
3381 
3382   // setup registers &amp; access constant pool cache
3383   if (recv  == noreg)  recv  = r2;
3384   if (flags == noreg)  flags = r3;
3385   assert_different_registers(method, index, recv, flags);
3386 
3387   // save &#39;interpreter return address&#39;
3388   __ save_bcp();
3389 
3390   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3391 
3392   // maybe push appendix to arguments (just before return address)
3393   if (is_invokedynamic || is_invokehandle) {
3394     Label L_no_push;
3395     __ tbz(flags, ConstantPoolCacheEntry::has_appendix_shift, L_no_push);
3396     // Push the appendix as a trailing parameter.
3397     // This must be done before we get the receiver,
3398     // since the parameter_size includes it.
3399     __ push(r19);
3400     __ mov(r19, index);
3401     __ load_resolved_reference_at_index(index, r19);
3402     __ pop(r19);
3403     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3404     __ bind(L_no_push);
3405   }
3406 
3407   // load receiver if needed (note: no return address pushed yet)
3408   if (load_receiver) {
3409     __ andw(recv, flags, ConstantPoolCacheEntry::parameter_size_mask);
3410     // FIXME -- is this actually correct? looks like it should be 2
3411     // const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3412     // const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3413     // Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3414     // __ movptr(recv, recv_addr);
3415     __ add(rscratch1, esp, recv, ext::uxtx, 3); // FIXME: uxtb here?
3416     __ ldr(recv, Address(rscratch1, -Interpreter::expr_offset_in_bytes(1)));
3417     __ verify_oop(recv);
3418   }
3419 
3420   // compute return type
3421   // x86 uses a shift and mask or wings it with a shift plus assert
3422   // the mask is not needed. aarch64 just uses bitfield extract
3423   __ ubfxw(rscratch2, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
3424   // load return address
3425   {
3426     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3427     __ mov(rscratch1, table_addr);
3428     __ ldr(lr, Address(rscratch1, rscratch2, Address::lsl(3)));
3429   }
3430 }
3431 
3432 
3433 void TemplateTable::invokevirtual_helper(Register index,
3434                                          Register recv,
3435                                          Register flags)
3436 {
3437   // Uses temporary registers r0, r3
3438   assert_different_registers(index, recv, r0, r3);
3439   // Test for an invoke of a final method
3440   Label notFinal;
3441   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
3442 
3443   const Register method = index;  // method must be rmethod
3444   assert(method == rmethod,
3445          &quot;methodOop must be rmethod for interpreter calling convention&quot;);
3446 
3447   // do the call - the index is actually the method to call
3448   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3449 
3450   // It&#39;s final, need a null check here!
3451   __ null_check(recv);
3452 
3453   // profile this call
3454   __ profile_final_call(r0);
3455   __ profile_arguments_type(r0, method, r4, true);
3456 
3457   __ jump_from_interpreted(method, r0);
3458 
3459   __ bind(notFinal);
3460 
3461   // get receiver klass
3462   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3463   __ load_klass(r0, recv);
3464 
3465   // profile this call
3466   __ profile_virtual_call(r0, rlocals, r3);
3467 
3468   // get target methodOop &amp; entry point
3469   __ lookup_virtual_method(r0, index, method);
3470   __ profile_arguments_type(r3, method, r4, true);
3471   // FIXME -- this looks completely redundant. is it?
3472   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
3473   __ jump_from_interpreted(method, r3);
3474 }
3475 
3476 void TemplateTable::invokevirtual(int byte_no)
3477 {
3478   transition(vtos, vtos);
3479   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3480 
3481   prepare_invoke(byte_no, rmethod, noreg, r2, r3);
3482 
3483   // rmethod: index (actually a Method*)
3484   // r2: receiver
3485   // r3: flags
3486 
3487   invokevirtual_helper(rmethod, r2, r3);
3488 }
3489 
3490 void TemplateTable::invokespecial(int byte_no)
3491 {
3492   transition(vtos, vtos);
3493   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3494 
3495   prepare_invoke(byte_no, rmethod, noreg,  // get f1 Method*
3496                  r2);  // get receiver also for null check
3497   __ verify_oop(r2);
3498   __ null_check(r2);
3499   // do the call
3500   __ profile_call(r0);
3501   __ profile_arguments_type(r0, rmethod, rbcp, false);
3502   __ jump_from_interpreted(rmethod, r0);
3503 }
3504 
3505 void TemplateTable::invokestatic(int byte_no)
3506 {
3507   transition(vtos, vtos);
3508   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3509 
3510   prepare_invoke(byte_no, rmethod);  // get f1 Method*
3511   // do the call
3512   __ profile_call(r0);
3513   __ profile_arguments_type(r0, rmethod, r4, false);
3514   __ jump_from_interpreted(rmethod, r0);
3515 }
3516 
3517 void TemplateTable::fast_invokevfinal(int byte_no)
3518 {
3519   __ call_Unimplemented();
3520 }
3521 
3522 void TemplateTable::invokeinterface(int byte_no) {
3523   transition(vtos, vtos);
3524   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3525 
3526   prepare_invoke(byte_no, r0, rmethod,  // get f1 Klass*, f2 Method*
3527                  r2, r3); // recv, flags
3528 
3529   // r0: interface klass (from f1)
3530   // rmethod: method (from f2)
3531   // r2: receiver
3532   // r3: flags
3533 
3534   // First check for Object case, then private interface method,
3535   // then regular interface method.
3536 
3537   // Special case of invokeinterface called for virtual method of
3538   // java.lang.Object.  See cpCache.cpp for details.
3539   Label notObjectMethod;
3540   __ tbz(r3, ConstantPoolCacheEntry::is_forced_virtual_shift, notObjectMethod);
3541 
3542   invokevirtual_helper(rmethod, r2, r3);
3543   __ bind(notObjectMethod);
3544 
3545   Label no_such_interface;
3546 
3547   // Check for private method invocation - indicated by vfinal
3548   Label notVFinal;
3549   __ tbz(r3, ConstantPoolCacheEntry::is_vfinal_shift, notVFinal);
3550 
3551   // Get receiver klass into r3 - also a null check
3552   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3553   __ load_klass(r3, r2);
3554 
3555   Label subtype;
3556   __ check_klass_subtype(r3, r0, r4, subtype);
3557   // If we get here the typecheck failed
3558   __ b(no_such_interface);
3559   __ bind(subtype);
3560 
3561   __ profile_final_call(r0);
3562   __ profile_arguments_type(r0, rmethod, r4, true);
3563   __ jump_from_interpreted(rmethod, r0);
3564 
3565   __ bind(notVFinal);
3566 
3567   // Get receiver klass into r3 - also a null check
3568   __ restore_locals();
3569   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3570   __ load_klass(r3, r2);
3571 
3572   Label no_such_method;
3573 
3574   // Preserve method for throw_AbstractMethodErrorVerbose.
3575   __ mov(r16, rmethod);
3576   // Receiver subtype check against REFC.
3577   // Superklass in r0. Subklass in r3. Blows rscratch2, r13
3578   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3579                              r3, r0, noreg,
3580                              // outputs: scan temp. reg, scan temp. reg
3581                              rscratch2, r13,
3582                              no_such_interface,
3583                              /*return_method=*/false);
3584 
3585   // profile this call
3586   __ profile_virtual_call(r3, r13, r19);
3587 
3588   // Get declaring interface class from method, and itable index
3589 
3590   __ load_method_holder(r0, rmethod);
3591   __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
3592   __ subw(rmethod, rmethod, Method::itable_index_max);
3593   __ negw(rmethod, rmethod);
3594 
3595   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3596   __ mov(rlocals, r3);
3597   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3598                              rlocals, r0, rmethod,
3599                              // outputs: method, scan temp. reg
3600                              rmethod, r13,
3601                              no_such_interface);
3602 
3603   // rmethod,: methodOop to call
3604   // r2: receiver
3605   // Check for abstract method error
3606   // Note: This should be done more efficiently via a throw_abstract_method_error
3607   //       interpreter entry point and a conditional jump to it in case of a null
3608   //       method.
3609   __ cbz(rmethod, no_such_method);
3610 
3611   __ profile_arguments_type(r3, rmethod, r13, true);
3612 
3613   // do the call
3614   // r2: receiver
3615   // rmethod,: methodOop
3616   __ jump_from_interpreted(rmethod, r3);
3617   __ should_not_reach_here();
3618 
3619   // exception handling code follows...
3620   // note: must restore interpreter registers to canonical
3621   //       state for exception handling to work correctly!
3622 
3623   __ bind(no_such_method);
3624   // throw exception
3625   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3626   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3627   // Pass arguments for generating a verbose error message.
3628   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose), r3, r16);
3629   // the call_VM checks for exception, so we should never return here.
3630   __ should_not_reach_here();
3631 
3632   __ bind(no_such_interface);
3633   // throw exception
3634   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3635   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3636   // Pass arguments for generating a verbose error message.
3637   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3638                    InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose), r3, r0);
3639   // the call_VM checks for exception, so we should never return here.
3640   __ should_not_reach_here();
3641   return;
3642 }
3643 
3644 void TemplateTable::invokehandle(int byte_no) {
3645   transition(vtos, vtos);
3646   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3647 
3648   prepare_invoke(byte_no, rmethod, r0, r2);
3649   __ verify_method_ptr(r2);
3650   __ verify_oop(r2);
3651   __ null_check(r2);
3652 
3653   // FIXME: profile the LambdaForm also
3654 
3655   // r13 is safe to use here as a scratch reg because it is about to
3656   // be clobbered by jump_from_interpreted().
3657   __ profile_final_call(r13);
3658   __ profile_arguments_type(r13, rmethod, r4, true);
3659 
3660   __ jump_from_interpreted(rmethod, r0);
3661 }
3662 
3663 void TemplateTable::invokedynamic(int byte_no) {
3664   transition(vtos, vtos);
3665   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3666 
3667   prepare_invoke(byte_no, rmethod, r0);
3668 
3669   // r0: CallSite object (from cpool-&gt;resolved_references[])
3670   // rmethod: MH.linkToCallSite method (from f2)
3671 
3672   // Note:  r0_callsite is already pushed by prepare_invoke
3673 
3674   // %%% should make a type profile for any invokedynamic that takes a ref argument
3675   // profile this call
3676   __ profile_call(rbcp);
3677   __ profile_arguments_type(r3, rmethod, r13, false);
3678 
3679   __ verify_oop(r0);
3680 
3681   __ jump_from_interpreted(rmethod, r0);
3682 }
3683 
3684 
3685 //-----------------------------------------------------------------------------
3686 // Allocation
3687 
3688 void TemplateTable::_new() {
3689   transition(vtos, atos);
3690 
3691   __ get_unsigned_2_byte_index_at_bcp(r3, 1);
3692   Label slow_case;
3693   Label done;
3694   Label initialize_header;
3695   Label initialize_object; // including clearing the fields
3696 
3697   __ get_cpool_and_tags(r4, r0);
3698   // Make sure the class we&#39;re about to instantiate has been resolved.
3699   // This is done before loading InstanceKlass to be consistent with the order
3700   // how Constant Pool is updated (see ConstantPool::klass_at_put)
3701   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3702   __ lea(rscratch1, Address(r0, r3, Address::lsl(0)));
3703   __ lea(rscratch1, Address(rscratch1, tags_offset));
3704   __ ldarb(rscratch1, rscratch1);
3705   __ cmp(rscratch1, (u1)JVM_CONSTANT_Class);
3706   __ br(Assembler::NE, slow_case);
3707 
3708   // get InstanceKlass
3709   __ load_resolved_klass_at_offset(r4, r3, r4, rscratch1);
3710 
3711   // make sure klass is initialized &amp; doesn&#39;t have finalizer
3712   // make sure klass is fully initialized
3713   __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));
3714   __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);
3715   __ br(Assembler::NE, slow_case);
3716 
3717   // get instance_size in InstanceKlass (scaled to a count of bytes)
3718   __ ldrw(r3,
3719           Address(r4,
3720                   Klass::layout_helper_offset()));
3721   // test to see if it has a finalizer or is malformed in some way
3722   __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);
3723 
3724   // Allocate the instance:
3725   //  If TLAB is enabled:
3726   //    Try to allocate in the TLAB.
3727   //    If fails, go to the slow path.
3728   //  Else If inline contiguous allocations are enabled:
3729   //    Try to allocate in eden.
3730   //    If fails due to heap end, go to slow path.
3731   //
3732   //  If TLAB is enabled OR inline contiguous is enabled:
3733   //    Initialize the allocation.
3734   //    Exit.
3735   //
3736   //  Go to slow path.
3737   const bool allow_shared_alloc =
3738     Universe::heap()-&gt;supports_inline_contig_alloc();
3739 
3740   if (UseTLAB) {
3741     __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);
3742 
3743     if (ZeroTLAB) {
3744       // the fields have been already cleared
3745       __ b(initialize_header);
3746     } else {
3747       // initialize both the header and fields
3748       __ b(initialize_object);
3749     }
3750   } else {
3751     // Allocation in the shared Eden, if allowed.
3752     //
3753     // r3: instance size in bytes
3754     if (allow_shared_alloc) {
3755       __ eden_allocate(r0, r3, 0, r10, slow_case);
3756     }
3757   }
3758 
3759   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3760   // there is an initialize need. Otherwise, skip and go to the slow path.
3761   if (UseTLAB || allow_shared_alloc) {
3762     // The object is initialized before the header.  If the object size is
3763     // zero, go directly to the header initialization.
3764     __ bind(initialize_object);
3765     __ sub(r3, r3, sizeof(oopDesc));
3766     __ cbz(r3, initialize_header);
3767 
3768     // Initialize object fields
3769     {
3770       __ add(r2, r0, sizeof(oopDesc));
3771       Label loop;
3772       __ bind(loop);
3773       __ str(zr, Address(__ post(r2, BytesPerLong)));
3774       __ sub(r3, r3, BytesPerLong);
3775       __ cbnz(r3, loop);
3776     }
3777 
3778     // initialize object header only.
3779     __ bind(initialize_header);
3780     if (UseBiasedLocking) {
3781       __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
3782     } else {
3783       __ mov(rscratch1, (intptr_t)markWord::prototype().value());
3784     }
3785     __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
3786     __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
3787     __ store_klass(r0, r4);      // store klass last
3788 
3789     {
3790       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);
3791       // Trigger dtrace event for fastpath
3792       __ push(atos); // save the return value
3793       __ call_VM_leaf(
3794            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);
3795       __ pop(atos); // restore the return value
3796 
3797     }
3798 
3799      TSAN_RUNTIME_ONLY(
3800       // return value of new oop is in r0.
3801       __ push(atos);
3802       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj), r0);
3803       __ pop(atos);
3804     );
3805 
3806     __ b(done);
3807   }
3808 
3809   // slow case
3810   __ bind(slow_case);
3811   __ get_constant_pool(c_rarg1);
3812   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3813   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);
3814   __ verify_oop(r0);
3815 
3816   // continue
3817   __ bind(done);
3818   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3819   __ membar(Assembler::StoreStore);
3820 }
3821 
3822 void TemplateTable::newarray() {
3823   transition(itos, atos);
3824   __ load_unsigned_byte(c_rarg1, at_bcp(1));
3825   __ mov(c_rarg2, r0);
3826   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3827           c_rarg1, c_rarg2);
3828   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3829   __ membar(Assembler::StoreStore);
3830 }
3831 
3832 void TemplateTable::anewarray() {
3833   transition(itos, atos);
3834   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3835   __ get_constant_pool(c_rarg1);
3836   __ mov(c_rarg3, r0);
3837   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3838           c_rarg1, c_rarg2, c_rarg3);
3839   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3840   __ membar(Assembler::StoreStore);
3841 }
3842 
3843 void TemplateTable::arraylength() {
3844   transition(atos, itos);
3845   __ null_check(r0, arrayOopDesc::length_offset_in_bytes());
3846   __ ldrw(r0, Address(r0, arrayOopDesc::length_offset_in_bytes()));
3847 }
3848 
3849 void TemplateTable::checkcast()
3850 {
3851   transition(atos, atos);
3852   Label done, is_null, ok_is_subtype, quicked, resolved;
3853   __ cbz(r0, is_null);
3854 
3855   // Get cpool &amp; tags index
3856   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3857   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3858   // See if bytecode has already been quicked
3859   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3860   __ lea(r1, Address(rscratch1, r19));
3861   __ ldarb(r1, r1);
3862   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3863   __ br(Assembler::EQ, quicked);
3864 
3865   __ push(atos); // save receiver for result, and for GC
3866   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3867   // vm_result_2 has metadata result
3868   __ get_vm_result_2(r0, rthread);
3869   __ pop(r3); // restore receiver
3870   __ b(resolved);
3871 
3872   // Get superklass in r0 and subklass in r3
3873   __ bind(quicked);
3874   __ mov(r3, r0); // Save object in r3; r0 needed for subtype check
3875   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1); // r0 = klass
3876 
3877   __ bind(resolved);
3878   __ load_klass(r19, r3);
3879 
3880   // Generate subtype check.  Blows r2, r5.  Object in r3.
3881   // Superklass in r0.  Subklass in r19.
3882   __ gen_subtype_check(r19, ok_is_subtype);
3883 
3884   // Come here on failure
3885   __ push(r3);
3886   // object is at TOS
3887   __ b(Interpreter::_throw_ClassCastException_entry);
3888 
3889   // Come here on success
3890   __ bind(ok_is_subtype);
3891   __ mov(r0, r3); // Restore object in r3
3892 
3893   // Collect counts on whether this test sees NULLs a lot or not.
3894   if (ProfileInterpreter) {
3895     __ b(done);
3896     __ bind(is_null);
3897     __ profile_null_seen(r2);
3898   } else {
3899     __ bind(is_null);   // same as &#39;done&#39;
3900   }
3901   __ bind(done);
3902 }
3903 
3904 void TemplateTable::instanceof() {
3905   transition(atos, itos);
3906   Label done, is_null, ok_is_subtype, quicked, resolved;
3907   __ cbz(r0, is_null);
3908 
3909   // Get cpool &amp; tags index
3910   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3911   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3912   // See if bytecode has already been quicked
3913   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3914   __ lea(r1, Address(rscratch1, r19));
3915   __ ldarb(r1, r1);
3916   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3917   __ br(Assembler::EQ, quicked);
3918 
3919   __ push(atos); // save receiver for result, and for GC
3920   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3921   // vm_result_2 has metadata result
3922   __ get_vm_result_2(r0, rthread);
3923   __ pop(r3); // restore receiver
3924   __ verify_oop(r3);
3925   __ load_klass(r3, r3);
3926   __ b(resolved);
3927 
3928   // Get superklass in r0 and subklass in r3
3929   __ bind(quicked);
3930   __ load_klass(r3, r0);
3931   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1);
3932 
3933   __ bind(resolved);
3934 
3935   // Generate subtype check.  Blows r2, r5
3936   // Superklass in r0.  Subklass in r3.
3937   __ gen_subtype_check(r3, ok_is_subtype);
3938 
3939   // Come here on failure
3940   __ mov(r0, 0);
3941   __ b(done);
3942   // Come here on success
3943   __ bind(ok_is_subtype);
3944   __ mov(r0, 1);
3945 
3946   // Collect counts on whether this test sees NULLs a lot or not.
3947   if (ProfileInterpreter) {
3948     __ b(done);
3949     __ bind(is_null);
3950     __ profile_null_seen(r2);
3951   } else {
3952     __ bind(is_null);   // same as &#39;done&#39;
3953   }
3954   __ bind(done);
3955   // r0 = 0: obj == NULL or  obj is not an instanceof the specified klass
3956   // r0 = 1: obj != NULL and obj is     an instanceof the specified klass
3957 }
3958 
3959 //-----------------------------------------------------------------------------
3960 // Breakpoints
3961 void TemplateTable::_breakpoint() {
3962   // Note: We get here even if we are single stepping..
3963   // jbug inists on setting breakpoints at every bytecode
3964   // even if we are in single step mode.
3965 
3966   transition(vtos, vtos);
3967 
3968   // get the unpatched byte code
3969   __ get_method(c_rarg1);
3970   __ call_VM(noreg,
3971              CAST_FROM_FN_PTR(address,
3972                               InterpreterRuntime::get_original_bytecode_at),
3973              c_rarg1, rbcp);
3974   __ mov(r19, r0);
3975 
3976   // post the breakpoint event
3977   __ call_VM(noreg,
3978              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
3979              rmethod, rbcp);
3980 
3981   // complete the execution of original bytecode
3982   __ mov(rscratch1, r19);
3983   __ dispatch_only_normal(vtos);
3984 }
3985 
3986 //-----------------------------------------------------------------------------
3987 // Exceptions
3988 
3989 void TemplateTable::athrow() {
3990   transition(atos, vtos);
3991   __ null_check(r0);
3992   __ b(Interpreter::throw_exception_entry());
3993 }
3994 
3995 //-----------------------------------------------------------------------------
3996 // Synchronization
3997 //
3998 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
3999 //       in the assembly code structure as well
4000 //
4001 // Stack layout:
4002 //
4003 // [expressions  ] &lt;--- esp               = expression stack top
4004 // ..
4005 // [expressions  ]
4006 // [monitor entry] &lt;--- monitor block top = expression stack bot
4007 // ..
4008 // [monitor entry]
4009 // [frame data   ] &lt;--- monitor block bot
4010 // ...
4011 // [saved rbp    ] &lt;--- rbp
4012 void TemplateTable::monitorenter()
4013 {
4014   transition(atos, vtos);
4015 
4016   // check for NULL object
4017   __ null_check(r0);
4018 
4019   __ resolve(IS_NOT_NULL, r0);
4020 
4021   const Address monitor_block_top(
4022         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4023   const Address monitor_block_bot(
4024         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
4025   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4026 
4027   Label allocated;
4028 
4029   // initialize entry pointer
4030   __ mov(c_rarg1, zr); // points to free slot or NULL
4031 
4032   // find a free slot in the monitor block (result in c_rarg1)
4033   {
4034     Label entry, loop, exit;
4035     __ ldr(c_rarg3, monitor_block_top); // points to current entry,
4036                                         // starting with top-most entry
4037     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
4038 
4039     __ b(entry);
4040 
4041     __ bind(loop);
4042     // check if current entry is used
4043     // if not used then remember entry in c_rarg1
4044     __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));
4045     __ cmp(zr, rscratch1);
4046     __ csel(c_rarg1, c_rarg3, c_rarg1, Assembler::EQ);
4047     // check if current entry is for same object
4048     __ cmp(r0, rscratch1);
4049     // if same object then stop searching
4050     __ br(Assembler::EQ, exit);
4051     // otherwise advance to next entry
4052     __ add(c_rarg3, c_rarg3, entry_size);
4053     __ bind(entry);
4054     // check if bottom reached
4055     __ cmp(c_rarg3, c_rarg2);
4056     // if not at bottom then check this entry
4057     __ br(Assembler::NE, loop);
4058     __ bind(exit);
4059   }
4060 
4061   __ cbnz(c_rarg1, allocated); // check if a slot has been found and
4062                             // if found, continue with that on
4063 
4064   // allocate one if there&#39;s no free slot
4065   {
4066     Label entry, loop;
4067     // 1. compute new pointers            // rsp: old expression stack top
4068     __ ldr(c_rarg1, monitor_block_bot);   // c_rarg1: old expression stack bottom
4069     __ sub(esp, esp, entry_size);         // move expression stack top
4070     __ sub(c_rarg1, c_rarg1, entry_size); // move expression stack bottom
4071     __ mov(c_rarg3, esp);                 // set start value for copy loop
4072     __ str(c_rarg1, monitor_block_bot);   // set new monitor block bottom
4073 
4074     __ sub(sp, sp, entry_size);           // make room for the monitor
4075 
4076     __ b(entry);
4077     // 2. move expression stack contents
4078     __ bind(loop);
4079     __ ldr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack
4080                                                    // word from old location
4081     __ str(c_rarg2, Address(c_rarg3, 0));          // and store it at new location
4082     __ add(c_rarg3, c_rarg3, wordSize);            // advance to next word
4083     __ bind(entry);
4084     __ cmp(c_rarg3, c_rarg1);        // check if bottom reached
4085     __ br(Assembler::NE, loop);      // if not at bottom then
4086                                      // copy next word
4087   }
4088 
4089   // call run-time routine
4090   // c_rarg1: points to monitor entry
4091   __ bind(allocated);
4092 
4093   // Increment bcp to point to the next bytecode, so exception
4094   // handling for async. exceptions work correctly.
4095   // The object has already been poped from the stack, so the
4096   // expression stack looks correct.
4097   __ increment(rbcp);
4098 
4099   // store object
4100   __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
4101   __ lock_object(c_rarg1);
4102 
4103   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4104   __ save_bcp();  // in case of exception
4105   __ generate_stack_overflow_check(0);
4106 
4107   // The bcp has already been incremented. Just need to dispatch to
4108   // next instruction.
4109   __ dispatch_next(vtos);
4110 }
4111 
4112 
4113 void TemplateTable::monitorexit()
4114 {
4115   transition(atos, vtos);
4116 
4117   // check for NULL object
4118   __ null_check(r0);
4119 
4120   __ resolve(IS_NOT_NULL, r0);
4121 
4122   const Address monitor_block_top(
4123         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4124   const Address monitor_block_bot(
4125         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
4126   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4127 
4128   Label found;
4129 
4130   // find matching slot
4131   {
4132     Label entry, loop;
4133     __ ldr(c_rarg1, monitor_block_top); // points to current entry,
4134                                         // starting with top-most entry
4135     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
4136                                         // of monitor block
4137     __ b(entry);
4138 
4139     __ bind(loop);
4140     // check if current entry is for same object
4141     __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
4142     __ cmp(r0, rscratch1);
4143     // if same object then stop searching
4144     __ br(Assembler::EQ, found);
4145     // otherwise advance to next entry
4146     __ add(c_rarg1, c_rarg1, entry_size);
4147     __ bind(entry);
4148     // check if bottom reached
4149     __ cmp(c_rarg1, c_rarg2);
4150     // if not at bottom then check this entry
4151     __ br(Assembler::NE, loop);
4152   }
4153 
4154   // error handling. Unlocking was not block-structured
4155   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4156                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4157   __ should_not_reach_here();
4158 
4159   // call run-time routine
4160   __ bind(found);
4161   __ push_ptr(r0); // make sure object is on stack (contract with oopMaps)
4162   __ unlock_object(c_rarg1);
4163   __ pop_ptr(r0); // discard object
4164 }
4165 
4166 
4167 // Wide instructions
4168 void TemplateTable::wide()
4169 {
4170   __ load_unsigned_byte(r19, at_bcp(1));
4171   __ mov(rscratch1, (address)Interpreter::_wentry_point);
4172   __ ldr(rscratch1, Address(rscratch1, r19, Address::uxtw(3)));
4173   __ br(rscratch1);
4174 }
4175 
4176 
4177 // Multi arrays
4178 void TemplateTable::multianewarray() {
4179   transition(vtos, atos);
4180   __ load_unsigned_byte(r0, at_bcp(3)); // get number of dimensions
4181   // last dim is on top of stack; we want address of first one:
4182   // first_addr = last_addr + (ndims - 1) * wordSize
4183   __ lea(c_rarg1, Address(esp, r0, Address::uxtw(3)));
4184   __ sub(c_rarg1, c_rarg1, wordSize);
4185   call_VM(r0,
4186           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4187           c_rarg1);
4188   __ load_unsigned_byte(r1, at_bcp(3));
4189   __ lea(esp, Address(esp, r1, Address::uxtw(3)));
4190 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../../share/interpreter/templateTable.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 753,10 ***</span>
<span class="line-new-header">--- 753,27 ---</span>
    __ bind(ok);
  }
  
  #if INCLUDE_TSAN
  
<span class="line-added">+ void TemplateTable::tsan_observe_load_or_store(const Address&amp; field,</span>
<span class="line-added">+                                                TsanMemoryReadWriteFunction tsan_function) {</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);</span>
<span class="line-added">+   if (!ThreadSanitizerJavaMemory) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ pusha();</span>
<span class="line-added">+   __ push_d(v0);</span>
<span class="line-added">+   __ lea(c_rarg0, field);</span>
<span class="line-added">+   __ get_method(c_rarg1);</span>
<span class="line-added">+   __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),</span>
<span class="line-added">+                   c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);</span>
<span class="line-added">+   __ pop_d(v0);</span>
<span class="line-added">+   __ popa();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void TemplateTable::tsan_observe_get_or_put(const Address &amp;field,
                                              Register flags,
                                              TsanMemoryReadWriteFunction tsan_function,
                                              TosState tos) {
    assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 778,10 ***</span>
<span class="line-new-header">--- 795,12 ---</span>
    // access the object it&#39;s referring to and create a happens-before relation
    // between the accesses to this reference.
    if (tos == atos) {
      int32_t acquire_release_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift |
        1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift;
<span class="line-added">+     // acquire_release_mask (0x8200000) can not be encoded into &#39;tst&#39;, but it can be</span>
<span class="line-added">+     // encoded into just one &#39;mov&#39; instruction.</span>
      __ mov(rscratch1, acquire_release_mask);
      __ tst(flags, rscratch1);
      __ br(Assembler::EQ, notAcquireRelease);
    } else {
      __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 822,11 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
<span class="line-modified">!   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);</span>
  }
  
  void TemplateTable::laload()
  {
    transition(itos, ltos);
<span class="line-new-header">--- 841,13 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(2));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));</span>
<span class="line-added">+   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::laload()
  {
    transition(itos, ltos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,11 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
<span class="line-modified">!   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);</span>
  }
  
  void TemplateTable::faload()
  {
    transition(itos, ftos);
<span class="line-new-header">--- 855,13 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(3));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));</span>
<span class="line-added">+   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::faload()
  {
    transition(itos, ftos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 846,11 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
<span class="line-modified">!   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);</span>
  }
  
  void TemplateTable::daload()
  {
    transition(itos, dtos);
<span class="line-new-header">--- 869,13 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(2));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));</span>
<span class="line-added">+   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::daload()
  {
    transition(itos, dtos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 858,11 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
<span class="line-modified">!   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);</span>
  }
  
  void TemplateTable::aaload()
  {
    transition(itos, atos);
<span class="line-new-header">--- 883,13 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(3));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));</span>
<span class="line-added">+   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::aaload()
  {
    transition(itos, atos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,14 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
<span class="line-modified">!   do_oop_load(_masm,</span>
<span class="line-modified">!               Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),</span>
<span class="line-modified">!               r0,</span>
<span class="line-modified">!               IS_ARRAY);</span>
  }
  
  void TemplateTable::baload()
  {
    transition(itos, itos);
<span class="line-new-header">--- 897,14 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(LogBytesPerHeapOop));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, UseCompressedOops ? SharedRuntime::tsan_read4</span>
<span class="line-modified">!                                                                        : SharedRuntime::tsan_read8));</span>
<span class="line-modified">!   do_oop_load(_masm, addr, r0, IS_ARRAY);</span>
  }
  
  void TemplateTable::baload()
  {
    transition(itos, itos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,11 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
<span class="line-modified">!   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);</span>
  }
  
  void TemplateTable::caload()
  {
    transition(itos, itos);
<span class="line-new-header">--- 912,13 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(0));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));</span>
<span class="line-added">+   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::caload()
  {
    transition(itos, itos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 897,16 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
<span class="line-modified">!   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);</span>
  }
  
  // iload followed by caload frequent pair
  void TemplateTable::fast_icaload()
  {
    transition(vtos, itos);
    // load index out of locals
    locals_index(r2);
    __ ldr(r1, iaddress(r2));
  
<span class="line-new-header">--- 926,21 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(1));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));</span>
<span class="line-added">+   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  // iload followed by caload frequent pair
  void TemplateTable::fast_icaload()
  {
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(__ stop(&quot;bytecode rewrite should have been disabled in TSAN&quot;););</span>
<span class="line-added">+ #endif</span>
    transition(vtos, itos);
    // load index out of locals
    locals_index(r2);
    __ ldr(r1, iaddress(r2));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 926,11 ***</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
<span class="line-modified">!   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);</span>
  }
  
  void TemplateTable::iload(int n)
  {
    transition(vtos, itos);
<span class="line-new-header">--- 960,13 ---</span>
    __ pop_ptr(r0);
    // r0: array
    // r1: index
    index_check(r0, r1); // leaves index in r1, kills rscratch1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
<span class="line-modified">!   Address addr(r0, r1, Address::uxtw(1));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));</span>
<span class="line-added">+   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::iload(int n)
  {
    transition(vtos, itos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1120,11 ***</span>
    // r0: value
    // r1: index
    // r3: array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
<span class="line-modified">!   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);</span>
  }
  
  void TemplateTable::lastore() {
    transition(ltos, vtos);
    __ pop_i(r1);
<span class="line-new-header">--- 1156,13 ---</span>
    // r0: value
    // r1: index
    // r3: array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
<span class="line-modified">!   Address addr(r3, r1, Address::uxtw(2));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));</span>
<span class="line-added">+   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);</span>
  }
  
  void TemplateTable::lastore() {
    transition(ltos, vtos);
    __ pop_i(r1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1132,11 ***</span>
    // r0: value
    // r1: index
    // r3: array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
<span class="line-modified">!   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);</span>
  }
  
  void TemplateTable::fastore() {
    transition(ftos, vtos);
    __ pop_i(r1);
<span class="line-new-header">--- 1170,13 ---</span>
    // r0: value
    // r1: index
    // r3: array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
<span class="line-modified">!   Address addr(r3, r1, Address::uxtw(3));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));</span>
<span class="line-added">+   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);</span>
  }
  
  void TemplateTable::fastore() {
    transition(ftos, vtos);
    __ pop_i(r1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1144,11 ***</span>
    // v0: value
    // r1:  index
    // r3:  array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
<span class="line-modified">!   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg /* ftos */, noreg, noreg);</span>
  }
  
  void TemplateTable::dastore() {
    transition(dtos, vtos);
    __ pop_i(r1);
<span class="line-new-header">--- 1184,13 ---</span>
    // v0: value
    // r1:  index
    // r3:  array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
<span class="line-modified">!   Address addr(r3, r1, Address::uxtw(2));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));</span>
<span class="line-added">+   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg /* ftos */, noreg, noreg);</span>
  }
  
  void TemplateTable::dastore() {
    transition(dtos, vtos);
    __ pop_i(r1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1156,11 ***</span>
    // v0: value
    // r1:  index
    // r3:  array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
<span class="line-modified">!   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg /* dtos */, noreg, noreg);</span>
  }
  
  void TemplateTable::aastore() {
    Label is_null, ok_is_subtype, done;
    transition(vtos, vtos);
<span class="line-new-header">--- 1198,13 ---</span>
    // v0: value
    // r1:  index
    // r3:  array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
<span class="line-modified">!   Address addr(r3, r1, Address::uxtw(3));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));</span>
<span class="line-added">+   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg /* dtos */, noreg, noreg);</span>
  }
  
  void TemplateTable::aastore() {
    Label is_null, ok_is_subtype, done;
    transition(vtos, vtos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1171,11 ***</span>
  
    Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
  
    index_check(r3, r2);     // kills r1
    __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
<span class="line-modified">! </span>
    // do array store check - check for NULL value first
    __ cbz(r0, is_null);
  
    // Move subklass into r1
    __ load_klass(r1, r0);
<span class="line-new-header">--- 1215,13 ---</span>
  
    Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
  
    index_check(r3, r2);     // kills r1
    __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
<span class="line-modified">!   // do tsan write after r4 has been defined.</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(element_address, UseCompressedOops ? SharedRuntime::tsan_write4</span>
<span class="line-added">+                                                                                   : SharedRuntime::tsan_write8));</span>
    // do array store check - check for NULL value first
    __ cbz(r0, is_null);
  
    // Move subklass into r1
    __ load_klass(r1, r0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,11 ***</span>
    __ tbz(r2, diffbit_index, L_skip);
    __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
    __ bind(L_skip);
  
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
<span class="line-modified">!   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);</span>
  }
  
  void TemplateTable::castore()
  {
    transition(itos, vtos);
<span class="line-new-header">--- 1279,13 ---</span>
    __ tbz(r2, diffbit_index, L_skip);
    __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
    __ bind(L_skip);
  
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
<span class="line-modified">!   Address addr(r3, r1, Address::uxtw(0));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));</span>
<span class="line-added">+   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);</span>
  }
  
  void TemplateTable::castore()
  {
    transition(itos, vtos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,11 ***</span>
    // r0: value
    // r1: index
    // r3: array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
<span class="line-modified">!   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);</span>
  }
  
  void TemplateTable::sastore()
  {
    castore();
<span class="line-new-header">--- 1294,13 ---</span>
    // r0: value
    // r1: index
    // r3: array
    index_check(r3, r1); // prefer index in r1
    __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
<span class="line-modified">!   Address addr(r3, r1, Address::uxtw(1));</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));</span>
<span class="line-added">+   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);</span>
  }
  
  void TemplateTable::sastore()
  {
    castore();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3147,10 ***</span>
<span class="line-new-header">--- 3197,13 ---</span>
  }
  
  
  void TemplateTable::fast_accessfield(TosState state)
  {
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(__ stop(&quot;bytecode rewrite should have been disabled in TSAN&quot;););</span>
<span class="line-added">+ #endif</span>
    transition(atos, state);
    // Do the JVMTI work here to avoid disturbing the register state below
    if (JvmtiExport::can_post_field_access()) {
      // Check to see if a field access watch has been set before we
      // take the time to call into the VM.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3236,10 ***</span>
<span class="line-new-header">--- 3289,13 ---</span>
    }
  }
  
  void TemplateTable::fast_xaccess(TosState state)
  {
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(__ stop(&quot;bytecode rewrite should have been disabled in TSAN&quot;););</span>
<span class="line-added">+ #endif</span>
    transition(vtos, state);
  
    // get receiver
    __ ldr(r0, aaddress(0));
    // access constant pool cache
</pre>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../../share/interpreter/templateTable.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1684     // and protect the arg if we must spill
1685     c_arg--;
1686   }
1687 
1688   // Change state to native (we save the return address in the thread, since it might not
1689   // be pushed on the stack when we do a stack traversal).
1690   // We use the same pc/oopMap repeatedly when we call out
1691 
1692   Label native_return;
1693   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1694 
1695   Label dtrace_method_entry, dtrace_method_entry_done;
1696   {
1697     unsigned long offset;
1698     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1699     __ ldrb(rscratch1, Address(rscratch1, offset));
1700     __ cbnzw(rscratch1, dtrace_method_entry);
1701     __ bind(dtrace_method_entry_done);
1702   }
1703 









1704   // RedefineClasses() tracing support for obsolete method entry
1705   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1706     // protect the args we&#39;ve loaded
1707     save_args(masm, total_c_args, c_arg, out_regs);
1708     __ mov_metadata(c_rarg1, method());
1709     __ call_VM_leaf(
1710       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1711       rthread, c_rarg1);
1712     restore_args(masm, total_c_args, c_arg, out_regs);
1713   }
1714 
1715   // Lock a synchronized method
1716 
1717   // Register definitions used by locking and unlocking
1718 
1719   const Register swap_reg = r0;
1720   const Register obj_reg  = r19;  // Will contain the oop
1721   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
1722   const Register old_hdr  = r13;  // value of old header at unlock time
1723   const Register tmp = lr;
</pre>
<hr />
<pre>
1915 
1916     // get address of the stack lock
1917     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1918     //  get old displaced header
1919     __ ldr(old_hdr, Address(r0, 0));
1920 
1921     // Atomic swap old header if oop still contains the stack lock
1922     Label succeed;
1923     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
1924     __ bind(succeed);
1925 
1926     // slow path re-enters here
1927     __ bind(unlock_done);
1928     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1929       restore_native_result(masm, ret_type, stack_slots);
1930     }
1931 
1932     __ bind(done);
1933   }
1934 







1935   Label dtrace_method_exit, dtrace_method_exit_done;
1936   {
1937     unsigned long offset;
1938     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1939     __ ldrb(rscratch1, Address(rscratch1, offset));
1940     __ cbnzw(rscratch1, dtrace_method_exit);
1941     __ bind(dtrace_method_exit_done);
1942   }
1943 
1944   __ reset_last_Java_frame(false);
1945 
1946   // Unbox oop result, e.g. JNIHandles::resolve result.
1947   if (is_reference_type(ret_type)) {
1948     __ resolve_jobject(r0, rthread, rscratch2);
1949   }
1950 
1951   if (CheckJNICalls) {
1952     // clear_pending_jni_exception_check
1953     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1954   }
</pre>
</td>
<td>
<hr />
<pre>
1684     // and protect the arg if we must spill
1685     c_arg--;
1686   }
1687 
1688   // Change state to native (we save the return address in the thread, since it might not
1689   // be pushed on the stack when we do a stack traversal).
1690   // We use the same pc/oopMap repeatedly when we call out
1691 
1692   Label native_return;
1693   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1694 
1695   Label dtrace_method_entry, dtrace_method_entry_done;
1696   {
1697     unsigned long offset;
1698     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1699     __ ldrb(rscratch1, Address(rscratch1, offset));
1700     __ cbnzw(rscratch1, dtrace_method_entry);
1701     __ bind(dtrace_method_entry_done);
1702   }
1703 
<span class="line-added">1704   TSAN_RUNTIME_ONLY(</span>
<span class="line-added">1705     // protect the args we&#39;ve loaded</span>
<span class="line-added">1706     save_args(masm, total_c_args, c_arg, out_regs);</span>
<span class="line-added">1707     __ call_VM(noreg,</span>
<span class="line-added">1708       CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),</span>
<span class="line-added">1709       rthread);</span>
<span class="line-added">1710     restore_args(masm, total_c_args, c_arg, out_regs);</span>
<span class="line-added">1711   );</span>
<span class="line-added">1712 </span>
1713   // RedefineClasses() tracing support for obsolete method entry
1714   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1715     // protect the args we&#39;ve loaded
1716     save_args(masm, total_c_args, c_arg, out_regs);
1717     __ mov_metadata(c_rarg1, method());
1718     __ call_VM_leaf(
1719       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1720       rthread, c_rarg1);
1721     restore_args(masm, total_c_args, c_arg, out_regs);
1722   }
1723 
1724   // Lock a synchronized method
1725 
1726   // Register definitions used by locking and unlocking
1727 
1728   const Register swap_reg = r0;
1729   const Register obj_reg  = r19;  // Will contain the oop
1730   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
1731   const Register old_hdr  = r13;  // value of old header at unlock time
1732   const Register tmp = lr;
</pre>
<hr />
<pre>
1924 
1925     // get address of the stack lock
1926     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
1927     //  get old displaced header
1928     __ ldr(old_hdr, Address(r0, 0));
1929 
1930     // Atomic swap old header if oop still contains the stack lock
1931     Label succeed;
1932     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
1933     __ bind(succeed);
1934 
1935     // slow path re-enters here
1936     __ bind(unlock_done);
1937     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
1938       restore_native_result(masm, ret_type, stack_slots);
1939     }
1940 
1941     __ bind(done);
1942   }
1943 
<span class="line-added">1944   TSAN_RUNTIME_ONLY(</span>
<span class="line-added">1945     save_native_result(masm, ret_type, stack_slots);</span>
<span class="line-added">1946     __ call_VM_leaf(</span>
<span class="line-added">1947          CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));</span>
<span class="line-added">1948     restore_native_result(masm, ret_type, stack_slots);</span>
<span class="line-added">1949   );</span>
<span class="line-added">1950 </span>
1951   Label dtrace_method_exit, dtrace_method_exit_done;
1952   {
1953     unsigned long offset;
1954     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1955     __ ldrb(rscratch1, Address(rscratch1, offset));
1956     __ cbnzw(rscratch1, dtrace_method_exit);
1957     __ bind(dtrace_method_exit_done);
1958   }
1959 
1960   __ reset_last_Java_frame(false);
1961 
1962   // Unbox oop result, e.g. JNIHandles::resolve result.
1963   if (is_reference_type(ret_type)) {
1964     __ resolve_jobject(r0, rthread, rscratch2);
1965   }
1966 
1967   if (CheckJNICalls) {
1968     // clear_pending_jni_exception_check
1969     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1970   }
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
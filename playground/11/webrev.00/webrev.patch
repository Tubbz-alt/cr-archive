diff a/src/java.base/share/classes/com/sun/crypto/provider/PBES2Parameters.java b/src/java.base/share/classes/com/sun/crypto/provider/PBES2Parameters.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/PBES2Parameters.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/PBES2Parameters.java
@@ -267,29 +267,18 @@
             throw new IOException("PBE parameter parsing error: "
                 + "not an ASN.1 OCTET STRING tag");
         }
         iCount = pBKDF2_params.data.getInteger();
 
-        DerValue prf = null;
         // keyLength INTEGER (1..MAX) OPTIONAL,
-        if (pBKDF2_params.data.available() > 0) {
-            DerValue keyLength = pBKDF2_params.data.getDerValue();
-            if (keyLength.tag == DerValue.tag_Integer) {
-                keysize = keyLength.getInteger() * 8; // keysize (in bits)
-            } else {
-                // Should be the prf
-                prf = keyLength;
-            }
+        if (pBKDF2_params.data.seeOptional(DerValue.tag_Integer)) {
+            keysize = pBKDF2_params.data.getInteger() * 8; // keysize (in bits)
         }
         // prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
         String kdfAlgo = "HmacSHA1";
-        if (prf == null) {
-            if (pBKDF2_params.data.available() > 0) {
-                prf = pBKDF2_params.data.getDerValue();
-            }
-        }
-        if (prf != null) {
+        if (pBKDF2_params.data.available() > 0) {
+            DerValue prf = pBKDF2_params.data.getDerValue();
             kdfAlgo_OID = prf.data.getOID();
             KnownOIDs o = KnownOIDs.findMatch(kdfAlgo_OID.toString());
             if (o == null || (!o.stdName().equals("HmacSHA1") &&
                 !o.stdName().equals("HmacSHA224") &&
                 !o.stdName().equals("HmacSHA256") &&
@@ -298,19 +287,14 @@
                 throw new IOException("PBE parameter parsing error: "
                         + "expecting the object identifier for a HmacSHA key "
                         + "derivation function");
             }
             kdfAlgo = o.stdName();
-
-            if (prf.data.available() != 0) {
-                // parameter is 'NULL' for all HmacSHA KDFs
-                DerValue parameter = prf.data.getDerValue();
-                if (parameter.tag != DerValue.tag_Null) {
-                    throw new IOException("PBE parameter parsing error: "
-                            + "not an ASN.1 NULL tag");
-                }
+            if (prf.data.seeOptional(t -> t == DerValue.tag_Null)) {
+                prf.data.skipDerValue();
             }
+            prf.data.atEnd();
         }
 
         return kdfAlgo;
     }
 
diff a/src/java.base/share/classes/java/security/cert/PolicyQualifierInfo.java b/src/java.base/share/classes/java/security/cert/PolicyQualifierInfo.java
--- a/src/java.base/share/classes/java/security/cert/PolicyQualifierInfo.java
+++ b/src/java.base/share/classes/java/security/cert/PolicyQualifierInfo.java
@@ -25,12 +25,14 @@
 
 package java.security.cert;
 
 import java.io.IOException;
 
+import sun.security.util.DerOutputStream;
 import sun.security.util.HexDumpEncoder;
 import sun.security.util.DerValue;
+import sun.security.util.ObjectIdentifier;
 
 /**
  * An immutable policy qualifier represented by the ASN.1 PolicyQualifierInfo
  * structure.
  *
@@ -87,10 +89,32 @@
     private byte [] mEncoded;
     private String mId;
     private byte [] mData;
     private String pqiString;
 
+    /**
+     * Creates from material.
+     * @param mId id
+     * @param mData data
+     */
+    public PolicyQualifierInfo(String mId, byte[] mData) {
+        this.mId = mId;
+        this.mData = mData;
+    }
+
+    private void encodeThis() throws IOException {
+        if (mEncoded != null) {
+            return;
+        }
+        DerOutputStream out = new DerOutputStream();
+        DerOutputStream ins = new DerOutputStream();
+        ins.putOID(ObjectIdentifier.of(mId));
+        ins.write(mData);
+        out.write(DerValue.tag_Sequence, ins);
+        mEncoded = out.toByteArray();
+    }
+
     /**
      * Creates an instance of {@code PolicyQualifierInfo} from the
      * encoded bytes. The encoded byte array is copied on construction.
      *
      * @param encoded a byte array containing the qualifier in DER encoding
@@ -132,11 +156,12 @@
      *
      * @return the ASN.1 DER encoded bytes (never {@code null}).
      * Note that a copy is returned, so the data is cloned each time
      * this method is called.
      */
-    public final byte[] getEncoded() {
+    public final byte[] getEncoded() throws IOException {
+        encodeThis();
         return mEncoded.clone();
     }
 
     /**
      * Returns the ASN.1 DER encoded form of the {@code qualifier}
diff a/src/java.base/share/classes/sun/security/pkcs/PKCS7.java b/src/java.base/share/classes/sun/security/pkcs/PKCS7.java
--- a/src/java.base/share/classes/sun/security/pkcs/PKCS7.java
+++ b/src/java.base/share/classes/sun/security/pkcs/PKCS7.java
@@ -264,10 +264,18 @@
                     bais.close();
             }
         }
     }
 
+
+    //    SignedData ::= SEQUENCE {
+    //        version CMSVersion,
+    //        digestAlgorithms DigestAlgorithmIdentifiers,
+    //        encapContentInfo EncapsulatedContentInfo,
+    //        certificates [0] IMPLICIT CertificateSet OPTIONAL,
+    //        crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
+    //        signerInfos SignerInfos }
     private void parseSignedData(DerValue val)
         throws ParsingException, IOException {
 
         DerInputStream dis = val.toDerInputStream();
 
@@ -303,11 +311,11 @@
 
         /*
          * check if certificates (implicit tag) are provided
          * (certificates are OPTIONAL)
          */
-        if ((byte)(dis.peekByte()) == (byte)0xA0) {
+        if (dis.seeOptionalContextSpecific(0)) {
             DerValue[] certVals = dis.getSet(2, true);
 
             len = certVals.length;
             certificates = new X509Certificate[len];
             int count = 0;
@@ -348,11 +356,11 @@
                 certificates = Arrays.copyOf(certificates, count);
             }
         }
 
         // check if crls (implicit tag) are provided (crls are OPTIONAL)
-        if ((byte)(dis.peekByte()) == (byte)0xA1) {
+        if (dis.seeOptionalContextSpecific(1)) {
             DerValue[] crlVals = dis.getSet(1, true);
 
             len = crlVals.length;
             crls = new X509CRL[len];
 
diff a/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java b/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java
--- a/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java
+++ b/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java
@@ -106,31 +106,20 @@
                 throw new InvalidKeyException("unknown version: " + version);
             }
             algid = AlgorithmId.parse (val.data.getDerValue ());
             key = val.data.getOctetString ();
 
-            DerValue next;
-            if (val.data.available() == 0) {
-                return;
+            if (val.data.seeOptionalContextSpecific(0)) {
+                val.data.skipDerValue();
             }
-            next = val.data.getDerValue();
-            if (next.isContextSpecific((byte)0)) {
-                if (val.data.available() == 0) {
-                    return;
-                }
-                next = val.data.getDerValue();
-            }
-
-            if (next.isContextSpecific((byte)1)) {
+            if (val.data.seeOptionalContextSpecific(1)) {
                 if (version == V1) {
                     throw new InvalidKeyException("publicKey seen in v1");
                 }
-                if (val.data.available() == 0) {
-                    return;
-                }
+                val.data.skipDerValue();
             }
-            throw new InvalidKeyException("Extra bytes");
+            val.data.atEnd();
         } catch (IOException e) {
             throw new InvalidKeyException("IOException : " + e.getMessage());
         }
     }
 
diff a/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java b/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java
--- a/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java
+++ b/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java
@@ -127,10 +127,19 @@
     }
 
     /**
      * Parses a PKCS#7 signer info.
      *
+     * SignerInfo ::= SEQUENCE {
+     *         version CMSVersion,
+     *         sid SignerIdentifier,
+     *         digestAlgorithm DigestAlgorithmIdentifier,
+     *         signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
+     *         signatureAlgorithm SignatureAlgorithmIdentifier,
+     *         signature SignatureValue,
+     *         unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
+     *
      * <p>This constructor is used only for backwards compatibility with
      * PKCS#7 blocks that were generated using JDK1.1.x.
      *
      * @param derin the ASN.1 encoding of the signer info.
      * @param oldStyle flag indicating whether or not the given signer info
@@ -160,11 +169,11 @@
             // encoded as an empty Set (Set of length zero)
             derin.getSet(0);
         } else {
             // check if set of auth attributes (implicit tag) is provided
             // (auth attributes are OPTIONAL)
-            if ((byte)(derin.peekByte()) == (byte)0xA0) {
+            if (derin.seeOptionalContextSpecific(0)) {
                 authenticatedAttributes = new PKCS9Attributes(derin);
             }
         }
 
         // digestEncryptionAlgorithmId - little RSA naming scheme -
@@ -182,12 +191,11 @@
             // encoded as an empty Set (Set of length zero)
             derin.getSet(0);
         } else {
             // check if set of unauth attributes (implicit tag) is provided
             // (unauth attributes are OPTIONAL)
-            if (derin.available() != 0
-                && (byte)(derin.peekByte()) == (byte)0xA1) {
+            if (derin.seeOptionalContextSpecific(1)) {
                 unauthenticatedAttributes =
                     new PKCS9Attributes(derin, true);// ignore unsupported attrs
             }
         }
 
diff a/src/java.base/share/classes/sun/security/timestamp/TSResponse.java b/src/java.base/share/classes/sun/security/timestamp/TSResponse.java
--- a/src/java.base/share/classes/sun/security/timestamp/TSResponse.java
+++ b/src/java.base/share/classes/sun/security/timestamp/TSResponse.java
@@ -38,11 +38,11 @@
  * The TimeStampResp ASN.1 type has the following definition:
  * <pre>
  *
  *     TimeStampResp ::= SEQUENCE {
  *         status            PKIStatusInfo,
- *         timeStampToken    TimeStampToken OPTIONAL ]
+ *         timeStampToken    TimeStampToken OPTIONAL }
  *
  *     PKIStatusInfo ::= SEQUENCE {
  *         status        PKIStatus,
  *         statusString  PKIFreeText OPTIONAL,
  *         failInfo      PKIFailureInfo OPTIONAL }
@@ -330,21 +330,18 @@
         this.status = statusInfo.data.getInteger();
         if (debug != null) {
             debug.println("timestamp response: status=" + this.status);
         }
         // Parse statusString, if present
-        if (statusInfo.data.available() > 0) {
-            byte tag = (byte)statusInfo.data.peekByte();
-            if (tag == DerValue.tag_SequenceOf) {
-                DerValue[] strings = statusInfo.data.getSequence(1);
-                statusString = new String[strings.length];
-                for (int i = 0; i < strings.length; i++) {
-                    statusString[i] = strings[i].getUTF8String();
-                    if (debug != null) {
-                        debug.println("timestamp response: statusString=" +
-                                      statusString[i]);
-                    }
+        if (statusInfo.data.seeOptional(DerValue.tag_SequenceOf)) {
+            DerValue[] strings = statusInfo.data.getSequence(1);
+            statusString = new String[strings.length];
+            for (int i = 0; i < strings.length; i++) {
+                statusString[i] = strings[i].getUTF8String();
+                if (debug != null) {
+                    debug.println("timestamp response: statusString=" +
+                            statusString[i]);
                 }
             }
         }
         // Parse failInfo, if present
         if (statusInfo.data.available() > 0) {
diff a/src/java.base/share/classes/sun/security/tools/keytool/Main.java b/src/java.base/share/classes/sun/security/tools/keytool/Main.java
--- a/src/java.base/share/classes/sun/security/tools/keytool/Main.java
+++ b/src/java.base/share/classes/sun/security/tools/keytool/Main.java
@@ -1555,11 +1555,15 @@
                         firstDate, ext);
             } else {
                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(ids.get(i)), firstDate);
             }
         }
-        X509CRLImpl crl = new X509CRLImpl(owner, firstDate, lastDate, badCerts);
+        CRLExtensions crlExts = new CRLExtensions();
+        AuthorityKeyIdentifierExtension ext = new AuthorityKeyIdentifierExtension(
+                new KeyIdentifier(signerCert.getPublicKey()), null, null);
+        crlExts.set(ext.getId(), ext);
+        X509CRLImpl crl = new X509CRLImpl(owner, firstDate, lastDate, badCerts, crlExts);
         crl.sign(privateKey, sigAlgName);
         if (rfc) {
             out.println("-----BEGIN X509 CRL-----");
             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(crl.getEncodedInternal()));
             out.println("-----END X509 CRL-----");
diff a/src/java.base/share/classes/sun/security/util/DerInputBuffer.java b/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
--- a/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
+++ b/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
@@ -59,17 +59,16 @@
         super(buf, offset, len);
         this.allowBER = allowBER;
     }
 
     DerInputBuffer dup() {
-        try {
-            DerInputBuffer retval = (DerInputBuffer)clone();
-            retval.mark(Integer.MAX_VALUE);
-            return retval;
-        } catch (CloneNotSupportedException e) {
-            throw new IllegalArgumentException(e.toString());
-        }
+        DerInputBuffer retval = new DerInputBuffer(this.buf);
+        retval.pos = this.pos;
+        retval.count = this.count;
+        retval.allowBER = this.allowBER;
+        retval.mark = this.pos;
+        return retval;
     }
 
     byte[] toByteArray() {
         int     len = available();
         if (len <= 0)
diff a/src/java.base/share/classes/sun/security/util/DerInputStream.java b/src/java.base/share/classes/sun/security/util/DerInputStream.java
--- a/src/java.base/share/classes/sun/security/util/DerInputStream.java
+++ b/src/java.base/share/classes/sun/security/util/DerInputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,11 +28,13 @@
 import java.io.InputStream;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
 import java.util.Date;
+import java.util.Optional;
 import java.util.Vector;
+import java.util.function.Predicate;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
@@ -317,10 +319,20 @@
     public void getNull() throws IOException {
         if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)
             throw new IOException("getNull, bad data");
     }
 
+    public boolean getBoolean() throws IOException {
+        if (buffer.read() != DerValue.tag_Boolean || buffer.read() != 1)
+            throw new IOException("getBoolean, bad data");
+        int next = buffer.read();
+        if (next == -1) {
+            throw new IOException("Short read of DER Boolean");
+        }
+        return next != 0;
+    }
+
     /**
      * Reads an X.200 style Object Identifier from the stream.
      */
     public ObjectIdentifier getOID() throws IOException {
         return new ObjectIdentifier(this);
@@ -525,10 +537,21 @@
                                   stringName + " string");
 
         return new String(retval, charset);
     }
 
+    public Date getTime() throws IOException {
+        int tag = buffer.read();
+        if (tag == DerValue.tag_UtcTime) {
+            return buffer.getUTCTime(getDefiniteLength(buffer));
+        } else if (tag == DerValue.tag_GeneralizedTime) {
+            return buffer.getGeneralizedTime(getDefiniteLength(buffer));
+        } else {
+            throw new IOException("Not a time value " + tag);
+        }
+    }
+
     /**
      * Get a UTC encoded time value from the input stream.
      */
     public Date getUTCTime() throws IOException {
         if (buffer.read() != DerValue.tag_UtcTime)
@@ -659,6 +682,120 @@
      * Returns the number of bytes available for reading.
      * This is most useful for testing whether the stream is
      * empty.
      */
     public int available() { return buffer.available(); }
+
+    /**
+     * Ensure there is no more data. This can be called when the last
+     * expected field is parsed and we need to make sure no unread is left.
+     */
+    public void atEnd() throws IOException {
+        if (available() != 0) {
+            throw new IOException("Extra unused bytes");
+        }
+    }
+
+    /**
+     * Detect if the tag of the next DerValue in the stream matches the rule.
+     *
+     * Attention: tag is an integer casted from a byte. i.e. could be negative.
+     *
+     * @param rule the rule to check for the tag.
+     * @return true if matches, false otherwise or stream is at end.
+     * @throws IOException if an I/O error happens
+     */
+    public boolean seeOptional(Predicate<Integer> rule) throws IOException {
+        return available() > 0 && rule.test(peekByte());
+    }
+
+    /**
+     * Detect if the tag of the next DerValue in the stream is the specified.
+     *
+     * @param tag the expected tag
+     * @return true if is, false otherwise or stream is at end.
+     * @throws IOException if an I/O error happens
+     */
+    public boolean seeOptional(byte tag) throws IOException {
+        return seeOptional(t -> t == (tag & 0xff));
+    }
+
+    /**
+     * Returns the inner DerValue if the next DerValue in the stream is
+     * an EXPLICIT context-specific value tagged by {@code n}.
+     *
+     * @param n the expected tag
+     * @return the inner DerValue, or empty if not found or stream at end
+     * @throws IOException if an I/O error happens
+     */
+    public Optional<DerValue> getOptionalExplicitContextSpecific(int n)
+            throws IOException {
+        if (seeOptionalContextSpecific(n)) {
+            DerValue v = getDerValue(); // [n]
+            DerValue sub = v.data.getDerValue(); // inside [n]
+            v.data.atEnd(); // make sure there is only one inner value
+            return Optional.of(sub);
+        } else {
+            return Optional.empty();
+        }
+    }
+
+    /**
+     * Returns the restored DerValue if the next DerValue in the stream is
+     * an IMPLICIT context-specific value tagged by {@code n}.
+     *
+     * @param n the expected tag
+     * @param tag the real tag for the IMPLICIT type
+     * @return the restored DerValue, or empty if not found or stream at end
+     * @throws IOException if an I/O error happens
+     */
+    public Optional<DerValue> getOptionalImplicitContextSpecific(int n, byte tag)
+            throws IOException {
+        if (seeOptionalContextSpecific(n)) {
+            DerValue v = getDerValue(); // [n]
+            v.resetTag(tag); // restore tag because IMPLICIT has overwritten it
+            return Optional.of(v);
+        } else {
+            return Optional.empty();
+        }
+    }
+
+    /**
+     * Detect if the next DerValue in the stream is a context-specific value
+     * tagged by {@code n}.
+     *
+     * @param n the expected tag
+     * @return true if is, false otherwise or stream is at end.
+     * @throws IOException if an I/O error happens
+     */
+    public boolean seeOptionalContextSpecific(int n) throws IOException {
+        return seeOptional(t -> (t & 0x0c0) == 0x080 && (t & 0x01f) == n);
+    }
+
+    /**
+     * Skip the next DerValue in the stream. Indefinite length DerValue
+     * is supported.
+     *
+     * @throws IOException if an I/O error happens
+     */
+    public void skipDerValue() throws IOException {
+        int unresolved = 0;
+        while (true) {
+            tag = (byte) buffer.read();
+            byte lenByte = (byte) buffer.read();
+            int length = DerInputStream.getLength(lenByte, buffer);
+            if (tag == 0) { // EOC
+                unresolved--;
+                if (unresolved < 0 || length != 0) {
+                    throw new IOException("Expected EOC");
+                }
+            } else if (length == -1) {
+                unresolved++;
+            } else {
+                buffer.skip(length);
+            }
+            if (unresolved == 0) {
+                break;
+            }
+        }
+    }
 }
diff a/src/java.base/share/classes/sun/security/util/DerValue.java b/src/java.base/share/classes/sun/security/util/DerValue.java
--- a/src/java.base/share/classes/sun/security/util/DerValue.java
+++ b/src/java.base/share/classes/sun/security/util/DerValue.java
@@ -26,11 +26,13 @@
 package sun.security.util;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
  * Represents a single DER-encoded value.  DER encoding rules are a subset
@@ -255,10 +257,11 @@
 
         // XXX must also parse BER-encoded constructed
         // values such as sequences, sets...
         tag = (byte)in.read();
         byte lenByte = (byte)in.read();
+        llen = lenlen(lenByte);
         length = DerInputStream.getLength(lenByte, in);
         if (length == -1) {  // indefinite length encoding found
             DerInputBuffer inbuf = in.dup();
             inbuf = new DerInputBuffer(
                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
@@ -372,19 +375,24 @@
         DerInputStream result = new DerInputStream(buffer);
         result.mark(Integer.MAX_VALUE);
         return result;
     }
 
+    int llen = 0;
+
     /*
      * helper routine
      */
     private DerInputStream init(boolean fullyBuffered, InputStream in,
         boolean allowBER) throws IOException {
 
         tag = (byte)in.read();
         byte lenByte = (byte)in.read();
+
+        llen = lenlen(lenByte);
         length = DerInputStream.getLength(lenByte, in);
+
         if (length == -1) { // indefinite length encoding found
             in = new ByteArrayInputStream(
                     DerIndefLenConverter.convertStream(in, lenByte, tag));
             if (tag != in.read())
                 throw new IOException
@@ -399,10 +407,18 @@
 
         buffer = new DerInputBuffer(bytes, allowBER);
         return new DerInputStream(buffer);
     }
 
+    private int lenlen(byte lenByte) {
+        if ((lenByte & 0x080) == 0x00) { // short form, 1 byte datum
+            return 1;
+        } else {                     // long form or indefinite
+            return 1 + (lenByte & 0x7f);
+        }
+    }
+
     /**
      * Encode an ASN1/DER encoded datum onto a DER output stream.
      */
     public void encode(DerOutputStream out)
     throws IOException {
@@ -608,10 +624,21 @@
             return getGeneralString();
         else
             return null;
     }
 
+    public DerValue[] getSubs(byte type) throws IOException {
+        if (tag != type) {
+            throw new IOException("Unexpected tag: " + tag);
+        }
+        List<DerValue> result = new ArrayList<>();
+        while (data.available() > 0) {
+            result.add(data.getDerValue());
+        }
+        return result.toArray(new DerValue[result.size()]);
+    }
+
     /**
      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
      * based on the parameter.  The bit string must be byte-aligned.
      *
      * @param tagImplicit if true, the tag is assumed implicit.
@@ -943,6 +970,80 @@
      */
     @Override
     public int hashCode() {
         return toString().hashCode();
     }
+
+    /**
+     * Dump the content of this DerValue into stdout, decomposing the
+     * structire in a hierachical style.
+     *
+     * Note: might not be good at deal with IMPLICIT context-specific values
+     * because it has no hint on the original tag.
+     *
+     * Note: might not work correctly for some types of data if the data
+     * inside has been read before. Also, after calling print(), the data
+     * inside might be read and subsequent reading on some type of data.
+     *
+     * @param into if true, try to treat OCTET STRING as another DerValue.
+     * @throws IOException if an I/O error occurs.
+     */
+    public void print(boolean into) throws IOException {
+        v0("", 0, this, into);
+    }
+
+    private static void v0(String indent, int offset, DerValue v, boolean into)
+            throws IOException {
+        String label = String.format("%04x:%04x [%s]   ",
+                offset, 1 + v.llen + v.length, indent);
+        String value = switch (v.tag) {
+            case DerValue.tag_Null -> "NULL";
+            case DerValue.tag_OctetString -> v.getOctetString().length + " bytes";
+            case DerValue.tag_BitString -> v.getUnalignedBitString().length() + " bits";
+            case DerValue.tag_Integer -> "int " + v.getBigInteger();
+            case DerValue.tag_Boolean -> Boolean.toString(v.getBoolean());
+            case DerValue.tag_GeneralizedTime -> v.getGeneralizedTime().toString();
+            case DerValue.tag_UtcTime -> v.getUTCTime().toString();
+            case DerValue.tag_ObjectId -> {
+                String s = v.getOID().toString();
+                KnownOIDs k = KnownOIDs.findMatch(s);
+                yield "OID " + s + (k != null ? (" (" + k.stdName() + ")") : "");
+            }
+            default -> {
+                String s = v.getAsString();
+                yield s == null ? null : ('"' + s + '"');
+            }
+        };
+        if (value != null) {
+            System.out.println(label + value);
+            if (v.tag == DerValue.tag_OctetString && into) {
+                try {
+                    v.buffer.reset();
+                    DerValue v2 = new DerValue(v.getOctetString());
+                    v0(indent + "=", 0, v2, into);
+                } catch (IOException e) {
+                    //
+                }
+            }
+        } else if (v.isConstructed()) {
+            String type = "sub";
+            if (v.isContextSpecific()) {
+                type = "[" + (v.tag & 0x1f) + "]";
+            } else if (v.isApplication()) {
+                type = "[APPLICATION " + (v.tag & 0x1f) + "]";
+            } else if (v.tag == DerValue.tag_Sequence) {
+                type = "SEQUENCE";
+            } else if (v.tag == DerValue.tag_Set) {
+                type = "SET";
+            }
+            System.out.println(label + type);
+            int pos = 0;
+            offset += 1 + v.llen;
+            for (var vv : v.getSubs(v.tag)) {
+                v0(indent + pos++, offset, vv, into);
+                offset += vv.length + vv.llen + 1;
+            }
+        } else {
+            System.out.println(label + v);
+        }
+    }
 }
diff a/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java b/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
--- a/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
@@ -153,45 +153,29 @@
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Invalid encoding for " +
                                   "AuthorityKeyIdentifierExtension.");
         }
 
-        // Note that all the fields in AuthorityKeyIdentifier are defined as
-        // being OPTIONAL, i.e., there could be an empty SEQUENCE, resulting
-        // in val.data being null.
-        while ((val.data != null) && (val.data.available() != 0)) {
-            DerValue opt = val.data.getDerValue();
-
-            // NB. this is always encoded with the IMPLICIT tag
-            // The checks only make sense if we assume implicit tagging,
-            // with explicit tagging the form is always constructed.
-            if (opt.isContextSpecific(TAG_ID) && !opt.isConstructed()) {
-                if (id != null)
-                    throw new IOException("Duplicate KeyIdentifier in " +
-                                          "AuthorityKeyIdentifier.");
-                opt.resetTag(DerValue.tag_OctetString);
-                id = new KeyIdentifier(opt);
-
-            } else if (opt.isContextSpecific(TAG_NAMES) &&
-                       opt.isConstructed()) {
-                if (names != null)
-                    throw new IOException("Duplicate GeneralNames in " +
-                                          "AuthorityKeyIdentifier.");
-                opt.resetTag(DerValue.tag_Sequence);
-                names = new GeneralNames(opt);
-
-            } else if (opt.isContextSpecific(TAG_SERIAL_NUM) &&
-                       !opt.isConstructed()) {
-                if (serialNum != null)
-                    throw new IOException("Duplicate SerialNumber in " +
-                                          "AuthorityKeyIdentifier.");
-                opt.resetTag(DerValue.tag_Integer);
-                serialNum = new SerialNumber(opt);
-            } else
-                throw new IOException("Invalid encoding of " +
-                                      "AuthorityKeyIdentifierExtension.");
+        var v = val.data.getOptionalImplicitContextSpecific(
+                TAG_ID, DerValue.tag_OctetString);
+        if (v.isPresent()) {
+            id = new KeyIdentifier(v.get());
         }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_NAMES, DerValue.tag_Sequence);
+        if (v.isPresent()) {
+            names = new GeneralNames(v.get());
+        }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_SERIAL_NUM, DerValue.tag_Integer);
+        if (v.isPresent()) {
+            serialNum = new SerialNumber(v.get().getBigInteger());
+        }
+
+        val.data.atEnd();
     }
 
     /**
      * Return the object as a string.
      */
diff a/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java b/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java
@@ -117,89 +117,78 @@
      * @param critical flag indicating if extension is critical or not
      * @param value an array containing the DER encoded bytes of the extension.
      * @exception ClassCastException if value is not an array of bytes
      * @exception IOException on error.
      */
-     public BasicConstraintsExtension(Boolean critical, Object value)
-         throws IOException
-    {
-         this.extensionId = PKIXExtensions.BasicConstraints_Id;
-         this.critical = critical.booleanValue();
-
-         this.extensionValue = (byte[]) value;
-         DerValue val = new DerValue(this.extensionValue);
-         if (val.tag != DerValue.tag_Sequence) {
-             throw new IOException("Invalid encoding of BasicConstraints");
-         }
-
-         if (val.data == null || val.data.available() == 0) {
-             // non-CA cert ("cA" field is FALSE by default), return -1
-             return;
-         }
-         DerValue opt = val.data.getDerValue();
-         if (opt.tag != DerValue.tag_Boolean) {
-             // non-CA cert ("cA" field is FALSE by default), return -1
-             return;
-         }
-
-         this.ca = opt.getBoolean();
-         if (val.data.available() == 0) {
-             // From PKIX profile:
-             // Where pathLenConstraint does not appear, there is no
-             // limit to the allowed length of the certification path.
-             this.pathLen = Integer.MAX_VALUE;
-             return;
-         }
-
-         opt = val.data.getDerValue();
-         if (opt.tag != DerValue.tag_Integer) {
-             throw new IOException("Invalid encoding of BasicConstraints");
-         }
-         this.pathLen = opt.getInteger();
-         /*
-          * Activate this check once again after PKIX profiling
-          * is a standard and this check no longer imposes an
-          * interoperability barrier.
-          * if (ca) {
-          *   if (!this.critical) {
-          *   throw new IOException("Criticality cannot be false for CA.");
-          *   }
-          * }
-          */
-     }
-
-     /**
-      * Return user readable form of extension.
-      */
-     public String toString() {
-         return super.toString() +
-             "BasicConstraints:[\n  CA:" + ca +
-             "\n  PathLen:" +
-             ((pathLen >= 0) ? String.valueOf(pathLen) : " undefined") +
-             "\n]\n";
-     }
-
-     /**
-      * Encode this extension value to the output stream.
-      *
-      * @param out the DerOutputStream to encode the extension to.
-      */
-     public void encode(OutputStream out) throws IOException {
-         DerOutputStream tmp = new DerOutputStream();
-         if (extensionValue == null) {
-             this.extensionId = PKIXExtensions.BasicConstraints_Id;
-             if (ca) {
-                 critical = true;
-             } else {
-                 critical = false;
-             }
-             encodeThis();
-         }
-         super.encode(tmp);
-
-         out.write(tmp.toByteArray());
-     }
+    public BasicConstraintsExtension(Boolean critical, Object value)
+            throws IOException {
+        this.extensionId = PKIXExtensions.BasicConstraints_Id;
+        this.critical = critical.booleanValue();
+
+        this.extensionValue = (byte[]) value;
+        DerValue val = new DerValue(this.extensionValue);
+        if (val.tag != DerValue.tag_Sequence) {
+            throw new IOException("Invalid encoding of BasicConstraints");
+        }
+
+        if (val.data.seeOptional(DerValue.tag_Boolean)) {
+            this.ca = val.data.getBoolean();
+            if (!this.ca) {
+                throw new IOException("Default cA encoded in BasicConstraints");
+            }
+        }
+        if (this.ca) {
+            if (val.data.seeOptional(DerValue.tag_Integer)) {
+                this.pathLen = val.data.getInteger();
+            } else {
+                this.pathLen = Integer.MAX_VALUE;
+            }
+        }
+        val.data.atEnd();
+        /*
+         * Activate this check once again after PKIX profiling
+         * is a standard and this check no longer imposes an
+         * interoperability barrier.
+         * if (ca) {
+         *   if (!this.critical) {
+         *   throw new IOException("Criticality cannot be false for CA.");
+         *   }
+         * }
+         */
+    }
+
+    /**
+     * Return user readable form of extension.
+     */
+    public String toString() {
+        return super.toString() +
+                "BasicConstraints:[\n  CA:" + ca +
+                "\n  PathLen:" +
+                ((pathLen >= 0) ? String.valueOf(pathLen) : " undefined") +
+                "\n]\n";
+    }
+
+    /**
+     * Encode this extension value to the output stream.
+     *
+     * @param out the DerOutputStream to encode the extension to.
+     */
+    public void encode(OutputStream out) throws IOException {
+        DerOutputStream tmp = new DerOutputStream();
+        if (extensionValue == null) {
+            this.extensionId = PKIXExtensions.BasicConstraints_Id;
+            if (ca) {
+                critical = true;
+            } else {
+                critical = false;
+            }
+            encodeThis();
+        }
+        super.encode(tmp);
+
+        out.write(tmp.toByteArray());
+    }
 
     /**
      * Set the attribute value.
      */
     public void set(String name, Object obj) throws IOException {
diff a/src/java.base/share/classes/sun/security/x509/CRLExtensions.java b/src/java.base/share/classes/sun/security/x509/CRLExtensions.java
--- a/src/java.base/share/classes/sun/security/x509/CRLExtensions.java
+++ b/src/java.base/share/classes/sun/security/x509/CRLExtensions.java
@@ -39,27 +39,11 @@
 
 import sun.security.util.*;
 
 /**
  * This class defines the CRL Extensions.
- * It is used for both CRL Extensions and CRL Entry Extensions,
- * which are defined are follows:
- * <pre>
- * TBSCertList  ::=  SEQUENCE  {
- *    version              Version OPTIONAL,   -- if present, must be v2
- *    signature            AlgorithmIdentifier,
- *    issuer               Name,
- *    thisUpdate           Time,
- *    nextUpdate           Time  OPTIONAL,
- *    revokedCertificates  SEQUENCE OF SEQUENCE  {
- *        userCertificate         CertificateSerialNumber,
- *        revocationDate          Time,
- *        crlEntryExtensions      Extensions OPTIONAL  -- if present, must be v2
- *    }  OPTIONAL,
- *    crlExtensions        [0] EXPLICIT Extensions OPTIONAL  -- if present, must be v2
- * }
- * </pre>
+ * It is used for both CRL Extensions and CRL Entry Extensions.
  *
  * @author Hemma Prafullchandra
  */
 public class CRLExtensions {
 
@@ -85,19 +69,10 @@
 
     // helper routine
     private void init(DerInputStream derStrm) throws CRLException {
         try {
             DerInputStream str = derStrm;
-
-            byte nextByte = (byte)derStrm.peekByte();
-            // check for context specific byte 0; skip it
-            if (((nextByte & 0x0c0) == 0x080) &&
-                ((nextByte & 0x01f) == 0x000)) {
-                DerValue val = str.getDerValue();
-                str = val.data;
-            }
-
             DerValue[] exts = str.getSequence(5);
             for (int i = 0; i < exts.length; i++) {
                 Extension ext = new Extension(exts[i]);
                 parseExtension(ext);
             }
diff a/src/java.base/share/classes/sun/security/x509/CertificateVersion.java b/src/java.base/share/classes/sun/security/x509/CertificateVersion.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateVersion.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateVersion.java
@@ -69,21 +69,10 @@
     // Returns the version number.
     private int getVersion() {
         return(version);
     }
 
-    // Construct the class from the passed DerValue
-    private void construct(DerValue derVal) throws IOException {
-        if (derVal.isConstructed() && derVal.isContextSpecific()) {
-            derVal = derVal.data.getDerValue();
-            version = derVal.getInteger();
-            if (derVal.data.available() != 0) {
-                throw new IOException("X.509 version, bad format");
-            }
-        }
-    }
-
     /**
      * The default constructor for this class,
      *  sets the version to 0 (i.e. X.509 version 1).
      */
     public CertificateVersion() {
@@ -105,48 +94,10 @@
             throw new IOException("X.509 Certificate version " +
                                    version + " not supported.\n");
         }
     }
 
-    /**
-     * Create the object, decoding the values from the passed DER stream.
-     *
-     * @param in the DerInputStream to read the CertificateVersion from.
-     * @exception IOException on decoding errors.
-     */
-    public CertificateVersion(DerInputStream in) throws IOException {
-        version = V1;
-        DerValue derVal = in.getDerValue();
-
-        construct(derVal);
-    }
-
-    /**
-     * Create the object, decoding the values from the passed stream.
-     *
-     * @param in the InputStream to read the CertificateVersion from.
-     * @exception IOException on decoding errors.
-     */
-    public CertificateVersion(InputStream in) throws IOException {
-        version = V1;
-        DerValue derVal = new DerValue(in);
-
-        construct(derVal);
-    }
-
-    /**
-     * Create the object, decoding the values from the passed DerValue.
-     *
-     * @param val the Der encoded value.
-     * @exception IOException on decoding errors.
-     */
-    public CertificateVersion(DerValue val) throws IOException {
-        version = V1;
-
-        construct(val);
-    }
-
     /**
      * Return the version number of the certificate.
      */
     public String toString() {
         return("Version: V" + (version+1));
diff a/src/java.base/share/classes/sun/security/x509/DistributionPoint.java b/src/java.base/share/classes/sun/security/x509/DistributionPoint.java
--- a/src/java.base/share/classes/sun/security/x509/DistributionPoint.java
+++ b/src/java.base/share/classes/sun/security/x509/DistributionPoint.java
@@ -190,55 +190,40 @@
     public DistributionPoint(DerValue val) throws IOException {
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Invalid encoding of DistributionPoint.");
         }
 
-        // Note that all the fields in DistributionPoint are defined as
-        // being OPTIONAL, i.e., there could be an empty SEQUENCE, resulting
-        // in val.data being null.
-        while ((val.data != null) && (val.data.available() != 0)) {
-            DerValue opt = val.data.getDerValue();
-
-            if (opt.isContextSpecific(TAG_DIST_PT) && opt.isConstructed()) {
-                if ((fullName != null) || (relativeName != null)) {
-                    throw new IOException("Duplicate DistributionPointName in "
-                                          + "DistributionPoint.");
-                }
-                DerValue distPnt = opt.data.getDerValue();
-                if (distPnt.isContextSpecific(TAG_FULL_NAME)
-                        && distPnt.isConstructed()) {
-                    distPnt.resetTag(DerValue.tag_Sequence);
-                    fullName = new GeneralNames(distPnt);
-                } else if (distPnt.isContextSpecific(TAG_REL_NAME)
-                        && distPnt.isConstructed()) {
-                    distPnt.resetTag(DerValue.tag_Set);
-                    relativeName = new RDN(distPnt);
-                } else {
-                    throw new IOException("Invalid DistributionPointName in "
-                                          + "DistributionPoint");
-                }
-            } else if (opt.isContextSpecific(TAG_REASONS)
-                                                && !opt.isConstructed()) {
-                if (reasonFlags != null) {
-                    throw new IOException("Duplicate Reasons in " +
-                                          "DistributionPoint.");
-                }
-                opt.resetTag(DerValue.tag_BitString);
-                reasonFlags = (opt.getUnalignedBitString()).toBooleanArray();
-            } else if (opt.isContextSpecific(TAG_ISSUER)
-                                                && opt.isConstructed()) {
-                if (crlIssuer != null) {
-                    throw new IOException("Duplicate CRLIssuer in " +
-                                          "DistributionPoint.");
-                }
-                opt.resetTag(DerValue.tag_Sequence);
-                crlIssuer = new GeneralNames(opt);
+        var v = val.data.getOptionalExplicitContextSpecific(TAG_DIST_PT);
+        if (v.isPresent()) {
+            DerValue distPnt = v.get();
+            if (distPnt.isContextSpecific(TAG_FULL_NAME)
+                    && distPnt.isConstructed()) {
+                distPnt.resetTag(DerValue.tag_Sequence);
+                fullName = new GeneralNames(distPnt);
+            } else if (distPnt.isContextSpecific(TAG_REL_NAME)
+                    && distPnt.isConstructed()) {
+                distPnt.resetTag(DerValue.tag_Set);
+                relativeName = new RDN(distPnt);
             } else {
-                throw new IOException("Invalid encoding of " +
-                                      "DistributionPoint.");
+                throw new IOException("Invalid DistributionPointName in "
+                        + "DistributionPoint");
             }
         }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_REASONS, DerValue.tag_BitString);
+        if (v.isPresent()) {
+            reasonFlags = (v.get().getUnalignedBitString()).toBooleanArray();
+        }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_ISSUER, DerValue.tag_Sequence);
+        if (v.isPresent()) {
+            crlIssuer = new GeneralNames(v.get());
+        }
+
+        val.data.atEnd();
         if ((crlIssuer == null) && (fullName == null) && (relativeName == null)) {
             throw new IOException("One of fullName, relativeName, "
                 + " and crlIssuer has to be set");
         }
     }
diff a/src/java.base/share/classes/sun/security/x509/EDIPartyName.java b/src/java.base/share/classes/sun/security/x509/EDIPartyName.java
--- a/src/java.base/share/classes/sun/security/x509/EDIPartyName.java
+++ b/src/java.base/share/classes/sun/security/x509/EDIPartyName.java
@@ -78,36 +78,25 @@
      *
      * @param derValue the encoded DER EDIPartyName.
      * @exception IOException on error.
      */
     public EDIPartyName(DerValue derValue) throws IOException {
-        DerInputStream in = new DerInputStream(derValue.toByteArray());
-        DerValue[] seq = in.getSequence(2);
-
-        int len = seq.length;
-        if (len < 1 || len > 2)
-            throw new IOException("Invalid encoding of EDIPartyName");
-
-        for (int i = 0; i < len; i++) {
-            DerValue opt = seq[i];
-            if (opt.isContextSpecific(TAG_ASSIGNER) &&
-                !opt.isConstructed()) {
-                if (assigner != null)
-                    throw new IOException("Duplicate nameAssigner found in"
-                                          + " EDIPartyName");
-                opt = opt.data.getDerValue();
-                assigner = opt.getAsString();
-            }
-            if (opt.isContextSpecific(TAG_PARTYNAME) &&
-                !opt.isConstructed()) {
-                if (party != null)
-                    throw new IOException("Duplicate partyName found in"
-                                          + " EDIPartyName");
-                opt = opt.data.getDerValue();
-                party = opt.getAsString();
-            }
+        if (derValue.tag != DerValue.tag_Sequence) {
+            throw new IOException("Invalid encoding of EDIPartyName.");
+        }
+        var v = derValue.data.getOptionalExplicitContextSpecific(TAG_ASSIGNER);
+        if (v.isPresent()) {
+            assigner = v.get().getAsString();
+        }
+        // party is in fact not OPTIONAL
+        v = derValue.data.getOptionalExplicitContextSpecific(TAG_PARTYNAME);
+        if (v.isPresent()) {
+            party = v.get().getAsString();
+        } else {
+            throw new IOException("party must be present");
         }
+        derValue.data.atEnd();
     }
 
     /**
      * Return the type of the GeneralName.
      */
diff a/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java b/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java
--- a/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java
+++ b/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java
@@ -75,26 +75,25 @@
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Invalid encoding for GeneralSubtree.");
         }
         name = new GeneralName(val.data.getDerValue(), true);
 
-        // NB. this is always encoded with the IMPLICIT tag
-        // The checks only make sense if we assume implicit tagging,
-        // with explicit tagging the form is always constructed.
-        while (val.data.available() != 0) {
-            DerValue opt = val.data.getDerValue();
-
-            if (opt.isContextSpecific(TAG_MIN) && !opt.isConstructed()) {
-                opt.resetTag(DerValue.tag_Integer);
-                minimum = opt.getInteger();
-
-            } else if (opt.isContextSpecific(TAG_MAX) && !opt.isConstructed()) {
-                opt.resetTag(DerValue.tag_Integer);
-                maximum = opt.getInteger();
-            } else
-                throw new IOException("Invalid encoding of GeneralSubtree.");
+        var v = val.data.getOptionalImplicitContextSpecific(
+                TAG_MIN, DerValue.tag_Integer);
+        if (v.isPresent()) {
+            minimum = v.get().getInteger();
+            if (minimum == 0) {
+                throw new IOException("default minimum encoded");
+            }
         }
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_MAX, DerValue.tag_Integer);
+        if (v.isPresent()) {
+            maximum = v.get().getInteger();
+        }
+
+        val.data.atEnd();
     }
 
     /**
      * Return the GeneralName.
      *
diff a/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java b/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
--- a/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
@@ -179,47 +179,59 @@
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Invalid encoding for " +
                                   "IssuingDistributionPointExtension.");
         }
 
-        // All the elements in issuingDistributionPoint are optional
-        if ((val.data == null) || (val.data.available() == 0)) {
-            return;
+        var v = val.data.getOptionalExplicitContextSpecific(
+                TAG_DISTRIBUTION_POINT);
+        if (v.isPresent()) {
+            distributionPoint = new DistributionPointName(v.get());
         }
 
-        DerInputStream in = val.data;
-        while (in != null && in.available() != 0) {
-            DerValue opt = in.getDerValue();
-
-            if (opt.isContextSpecific(TAG_DISTRIBUTION_POINT) &&
-                opt.isConstructed()) {
-                distributionPoint =
-                    new DistributionPointName(opt.data.getDerValue());
-            } else if (opt.isContextSpecific(TAG_ONLY_USER_CERTS) &&
-                       !opt.isConstructed()) {
-                opt.resetTag(DerValue.tag_Boolean);
-                hasOnlyUserCerts = opt.getBoolean();
-            } else if (opt.isContextSpecific(TAG_ONLY_CA_CERTS) &&
-                  !opt.isConstructed()) {
-                opt.resetTag(DerValue.tag_Boolean);
-                hasOnlyCACerts = opt.getBoolean();
-            } else if (opt.isContextSpecific(TAG_ONLY_SOME_REASONS) &&
-                       !opt.isConstructed()) {
-                revocationReasons = new ReasonFlags(opt); // expects tag implicit
-            } else if (opt.isContextSpecific(TAG_INDIRECT_CRL) &&
-                       !opt.isConstructed()) {
-                opt.resetTag(DerValue.tag_Boolean);
-                isIndirectCRL = opt.getBoolean();
-            } else if (opt.isContextSpecific(TAG_ONLY_ATTRIBUTE_CERTS) &&
-                       !opt.isConstructed()) {
-                opt.resetTag(DerValue.tag_Boolean);
-                hasOnlyAttributeCerts = opt.getBoolean();
-            } else {
-                throw new IOException
-                    ("Invalid encoding of IssuingDistributionPoint");
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_ONLY_USER_CERTS, DerValue.tag_Boolean);
+        if (v.isPresent()) {
+            hasOnlyUserCerts = v.get().getBoolean();
+            if (!hasOnlyUserCerts) {
+                throw new IOException("default hasOnlyUserCerts encoded");
             }
         }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_ONLY_CA_CERTS, DerValue.tag_Boolean);
+        if (v.isPresent()) {
+            hasOnlyCACerts = v.get().getBoolean();
+            if (!hasOnlyCACerts) {
+                throw new IOException("default hasOnlyCACerts encoded");
+            }
+        }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_ONLY_SOME_REASONS, DerValue.tag_BitString);
+        if (v.isPresent()) {
+            revocationReasons = new ReasonFlags(v.get());
+        }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_INDIRECT_CRL, DerValue.tag_Boolean);
+        if (v.isPresent()) {
+            isIndirectCRL = v.get().getBoolean();
+            if (!isIndirectCRL) {
+                throw new IOException("default isIndirectCRL encoded");
+            }
+        }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_ONLY_ATTRIBUTE_CERTS, DerValue.tag_Boolean);
+        if (v.isPresent()) {
+            hasOnlyAttributeCerts = v.get().getBoolean();
+            if (!hasOnlyAttributeCerts) {
+                throw new IOException("default hasOnlyAttributeCerts encoded");
+            }
+        }
+
+        val.data.atEnd();
     }
 
     /**
      * Returns the name of this attribute.
      */
diff a/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java b/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java
@@ -175,41 +175,24 @@
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Invalid encoding for" +
                                   " NameConstraintsExtension.");
         }
 
-        // NB. this is always encoded with the IMPLICIT tag
-        // The checks only make sense if we assume implicit tagging,
-        // with explicit tagging the form is always constructed.
-        // Note that all the fields in NameConstraints are defined as
-        // being OPTIONAL, i.e., there could be an empty SEQUENCE, resulting
-        // in val.data being null.
-        if (val.data == null)
-            return;
-        while (val.data.available() != 0) {
-            DerValue opt = val.data.getDerValue();
-
-            if (opt.isContextSpecific(TAG_PERMITTED) && opt.isConstructed()) {
-                if (permitted != null) {
-                    throw new IOException("Duplicate permitted " +
-                         "GeneralSubtrees in NameConstraintsExtension.");
-                }
-                opt.resetTag(DerValue.tag_Sequence);
-                permitted = new GeneralSubtrees(opt);
-
-            } else if (opt.isContextSpecific(TAG_EXCLUDED) &&
-                       opt.isConstructed()) {
-                if (excluded != null) {
-                    throw new IOException("Duplicate excluded " +
-                             "GeneralSubtrees in NameConstraintsExtension.");
-                }
-                opt.resetTag(DerValue.tag_Sequence);
-                excluded = new GeneralSubtrees(opt);
-            } else
-                throw new IOException("Invalid encoding of " +
-                                      "NameConstraintsExtension.");
+        var v = val.data.getOptionalImplicitContextSpecific(
+                TAG_PERMITTED, DerValue.tag_Sequence);
+        if (v.isPresent()) {
+            permitted = new GeneralSubtrees(v.get());
+        }
+
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_EXCLUDED, DerValue.tag_Sequence);
+        if (v.isPresent()) {
+            excluded = new GeneralSubtrees(v.get());
         }
+
+        val.data.atEnd();
+
         minMaxValid = false;
     }
 
     /**
      * Return the printable string.
diff a/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java b/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java
@@ -146,31 +146,23 @@
         this.extensionValue = (byte[]) value;
         DerValue val = new DerValue(this.extensionValue);
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Sequence tag missing for PolicyConstraint.");
         }
-        DerInputStream in = val.data;
-        while (in != null && in.available() != 0) {
-            DerValue next = in.getDerValue();
-
-            if (next.isContextSpecific(TAG_REQUIRE) && !next.isConstructed()) {
-                if (this.require != -1)
-                    throw new IOException("Duplicate requireExplicitPolicy" +
-                          "found in the PolicyConstraintsExtension");
-                next.resetTag(DerValue.tag_Integer);
-                this.require = next.getInteger();
+        var v = val.data.getOptionalImplicitContextSpecific(
+                TAG_REQUIRE, DerValue.tag_Integer);
+        if (v.isPresent()) {
+            this.require = v.get().getInteger();
+        }
 
-            } else if (next.isContextSpecific(TAG_INHIBIT) &&
-                       !next.isConstructed()) {
-                if (this.inhibit != -1)
-                    throw new IOException("Duplicate inhibitPolicyMapping" +
-                          "found in the PolicyConstraintsExtension");
-                next.resetTag(DerValue.tag_Integer);
-                this.inhibit = next.getInteger();
-            } else
-                throw new IOException("Invalid encoding of PolicyConstraint");
+        v = val.data.getOptionalImplicitContextSpecific(
+                TAG_INHIBIT, DerValue.tag_Integer);
+        if (v.isPresent()) {
+            this.inhibit = v.get().getInteger();
         }
+
+        val.data.atEnd();
     }
 
     /**
      * Return the extension as user readable string.
      */
diff a/src/java.base/share/classes/sun/security/x509/PolicyInformation.java b/src/java.base/share/classes/sun/security/x509/PolicyInformation.java
--- a/src/java.base/share/classes/sun/security/x509/PolicyInformation.java
+++ b/src/java.base/share/classes/sun/security/x509/PolicyInformation.java
@@ -102,20 +102,20 @@
     public PolicyInformation(DerValue val) throws IOException {
         if (val.tag != DerValue.tag_Sequence) {
             throw new IOException("Invalid encoding of PolicyInformation");
         }
         policyIdentifier = new CertificatePolicyId(val.data.getDerValue());
-        if (val.data.available() != 0) {
+        if (val.data.seeOptional(DerValue.tag_Sequence)) {
             policyQualifiers = new LinkedHashSet<PolicyQualifierInfo>();
             DerValue opt = val.data.getDerValue();
-            if (opt.tag != DerValue.tag_Sequence)
-                throw new IOException("Invalid encoding of PolicyInformation");
-            if (opt.data.available() == 0)
+            if (opt.data.available() == 0) {
                 throw new IOException("No data available in policyQualifiers");
-            while (opt.data.available() != 0)
+            }
+            while (opt.data.available() != 0) {
                 policyQualifiers.add(new PolicyQualifierInfo
                         (opt.data.getDerValue().toByteArray()));
+            }
         } else {
             policyQualifiers = Collections.emptySet();
         }
     }
 
diff a/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java b/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java
--- a/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java
@@ -136,42 +136,28 @@
     throws CertificateException, IOException {
         this.extensionId = PKIXExtensions.PrivateKeyUsage_Id;
         this.critical = critical.booleanValue();
 
         this.extensionValue = (byte[]) value;
-        DerInputStream str = new DerInputStream(this.extensionValue);
-        DerValue[] seq = str.getSequence(2);
-
-        // NB. this is always encoded with the IMPLICIT tag
-        // The checks only make sense if we assume implicit tagging,
-        // with explicit tagging the form is always constructed.
-        for (int i = 0; i < seq.length; i++) {
-            DerValue opt = seq[i];
-
-            if (opt.isContextSpecific(TAG_BEFORE) &&
-                !opt.isConstructed()) {
-                if (notBefore != null) {
-                    throw new CertificateParsingException(
-                        "Duplicate notBefore in PrivateKeyUsage.");
-                }
-                opt.resetTag(DerValue.tag_GeneralizedTime);
-                str = new DerInputStream(opt.toByteArray());
-                notBefore = str.getGeneralizedTime();
-
-            } else if (opt.isContextSpecific(TAG_AFTER) &&
-                       !opt.isConstructed()) {
-                if (notAfter != null) {
-                    throw new CertificateParsingException(
-                        "Duplicate notAfter in PrivateKeyUsage.");
-                }
-                opt.resetTag(DerValue.tag_GeneralizedTime);
-                str = new DerInputStream(opt.toByteArray());
-                notAfter = str.getGeneralizedTime();
-            } else
-                throw new IOException("Invalid encoding of " +
-                                      "PrivateKeyUsageExtension");
+        DerValue derValue = new DerValue(this.extensionValue);
+        if (derValue.tag != DerValue.tag_Sequence) {
+            throw new IOException("Input not a SEQUNCE");
         }
+
+        var v = derValue.data.getOptionalImplicitContextSpecific(
+                TAG_BEFORE, DerValue.tag_GeneralizedTime);
+        if (v.isPresent()) {
+            notBefore = v.get().getGeneralizedTime();
+        }
+
+        v = derValue.data.getOptionalImplicitContextSpecific(
+                TAG_AFTER, DerValue.tag_GeneralizedTime);
+        if (v.isPresent()) {
+            notAfter = v.get().getGeneralizedTime();
+        }
+
+        derValue.data.atEnd();
     }
 
     /**
      * Return the printable string.
      */
diff a/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java b/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java
--- a/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java
@@ -465,23 +465,17 @@
         DerInputStream in = derVal.toDerInputStream();
         DerValue val = in.getDerValue();
         this.serialNumber = new SerialNumber(val);
 
         // revocationDate
-        int nextByte = derVal.data.peekByte();
-        if ((byte)nextByte == DerValue.tag_UtcTime) {
-            this.revocationDate = derVal.data.getUTCTime();
-        } else if ((byte)nextByte == DerValue.tag_GeneralizedTime) {
-            this.revocationDate = derVal.data.getGeneralizedTime();
-        } else
-            throw new CRLException("Invalid encoding for revocation date");
+        this.revocationDate = derVal.data.getTime();
 
         if (derVal.data.available() == 0)
             return;  // no extensions
 
         // crlEntryExtensions
-        this.extensions = new CRLExtensions(derVal.toDerInputStream());
+        this.extensions = new CRLExtensions(derVal.data);
     }
 
     /**
      * Utility method to convert an arbitrary instance of X509CRLEntry
      * to a X509CRLEntryImpl. Does a cast if possible, otherwise reparses
diff a/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java b/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java
--- a/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java
@@ -1124,12 +1124,11 @@
         DerValue       tmp;
         byte           nextByte;
 
         // version (optional if v1)
         version = 0;   // by default, version = v1 == 0
-        nextByte = (byte)derStrm.peekByte();
-        if (nextByte == DerValue.tag_Integer) {
+        if (derStrm.seeOptional(DerValue.tag_Integer)) {
             version = derStrm.getInteger();
             if (version != 1)  // i.e. v2
                 throw new CRLException("Invalid version");
         }
         tmp = derStrm.getDerValue();
@@ -1149,38 +1148,18 @@
         }
 
         // thisUpdate
         // check if UTCTime encoded or GeneralizedTime
 
-        nextByte = (byte)derStrm.peekByte();
-        if (nextByte == DerValue.tag_UtcTime) {
-            thisUpdate = derStrm.getUTCTime();
-        } else if (nextByte == DerValue.tag_GeneralizedTime) {
-            thisUpdate = derStrm.getGeneralizedTime();
-        } else {
-            throw new CRLException("Invalid encoding for thisUpdate"
-                                   + " (tag=" + nextByte + ")");
-        }
-
-        if (derStrm.available() == 0)
-           return;     // done parsing no more optional fields present
-
-        // nextUpdate (optional)
-        nextByte = (byte)derStrm.peekByte();
-        if (nextByte == DerValue.tag_UtcTime) {
-            nextUpdate = derStrm.getUTCTime();
-        } else if (nextByte == DerValue.tag_GeneralizedTime) {
-            nextUpdate = derStrm.getGeneralizedTime();
-        } // else it is not present
+        thisUpdate = derStrm.getTime();
 
-        if (derStrm.available() == 0)
-            return;     // done parsing no more optional fields present
+        if (derStrm.seeOptional(t ->
+                t == DerValue.tag_UtcTime || t == DerValue.tag_GeneralizedTime)) {
+            nextUpdate = derStrm.getTime();
+        }
 
-        // revokedCertificates (optional)
-        nextByte = (byte)derStrm.peekByte();
-        if ((nextByte == DerValue.tag_SequenceOf)
-            && (! ((nextByte & 0x0c0) == 0x080))) {
+        if (derStrm.seeOptional(DerValue.tag_SequenceOf)) {
             DerValue[] badCerts = derStrm.getSequence(4);
 
             X500Principal crlIssuer = getIssuerX500Principal();
             X500Principal badCertIssuer = crlIssuer;
             for (int i = 0; i < badCerts.length; i++) {
@@ -1192,17 +1171,12 @@
                 revokedMap.put(issuerSerial, entry);
                 revokedList.add(entry);
             }
         }
 
-        if (derStrm.available() == 0)
-            return;     // done parsing no extensions
-
-        // crlExtensions (optional)
-        tmp = derStrm.getDerValue();
-        if (tmp.isConstructed() && tmp.isContextSpecific((byte)0)) {
-            extensions = new CRLExtensions(tmp.data);
+        if (derStrm.seeOptionalContextSpecific(0)) {
+            extensions = new CRLExtensions(derStrm.getDerValue().data);
         }
         readOnly = true;
     }
 
     /**
@@ -1218,16 +1192,14 @@
             DerValue tbsCert = derIn.getSequence(3)[0];
             DerInputStream tbsIn = tbsCert.data;
 
             DerValue tmp;
             // skip version number if present
-            byte nextByte = (byte)tbsIn.peekByte();
-            if (nextByte == DerValue.tag_Integer) {
-                tmp = tbsIn.getDerValue();
+            if (tbsIn.seeOptional(DerValue.tag_Integer)) {
+                tbsIn.skipDerValue();
             }
-
-            tmp = tbsIn.getDerValue();  // skip signature
+            tbsIn.skipDerValue();
             tmp = tbsIn.getDerValue();  // issuer
             byte[] principalBytes = tmp.toByteArray();
             return new X500Principal(principalBytes);
         } catch (Exception e) {
             throw new RuntimeException("Could not parse issuer", e);
diff a/src/java.base/share/classes/sun/security/x509/X509CertInfo.java b/src/java.base/share/classes/sun/security/x509/X509CertInfo.java
--- a/src/java.base/share/classes/sun/security/x509/X509CertInfo.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CertInfo.java
@@ -622,12 +622,28 @@
         } else {
             throw new IOException("Attribute name not recognized.");
         }
     }
 
-    /*
+    /**
      * This routine unmarshals the certificate information.
+     *
+     *    TBSCertificate  ::=  SEQUENCE  {
+     *         version         [0]  EXPLICIT Version DEFAULT v1,
+     *         serialNumber         CertificateSerialNumber,
+     *         signature            AlgorithmIdentifier,
+     *         issuer               Name,
+     *         validity             Validity,
+     *         subject              Name,
+     *         subjectPublicKeyInfo SubjectPublicKeyInfo,
+     *         issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
+     *                              -- If present, version MUST be v2 or v3
+     *         subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
+     *                              -- If present, version MUST be v2 or v3
+     *         extensions      [3]  EXPLICIT Extensions OPTIONAL
+     *                              -- If present, version MUST be v3
+     *         }
      */
     private void parse(DerValue val)
     throws CertificateParsingException, IOException {
         DerInputStream  in;
         DerValue        tmp;
@@ -638,18 +654,19 @@
         rawCertInfo = val.toByteArray();
 
         in = val.data;
 
         // Version
-        tmp = in.getDerValue();
-        if (tmp.isContextSpecific((byte)0)) {
-            version = new CertificateVersion(tmp);
-            tmp = in.getDerValue();
+        var v = in.getOptionalExplicitContextSpecific(0);
+        if (v.isPresent()) {
+            version = new CertificateVersion(v.get().getInteger());
+        } else {
+            version = new CertificateVersion(CertificateVersion.V1);
         }
 
         // Serial number ... an integer
-        serialNum = new CertificateSerialNumber(tmp);
+        serialNum = new CertificateSerialNumber(in.getBigInteger());
 
         // Algorithm Identifier
         algId = new CertificateAlgorithmId(in);
 
         // Issuer name
@@ -682,33 +699,26 @@
         } else {
             return;
         }
 
         // Get the issuerUniqueId if present
-        tmp = in.getDerValue();
-        if (tmp.isContextSpecific((byte)1)) {
-            issuerUniqueId = new UniqueIdentity(tmp);
-            if (in.available() == 0)
-                return;
-            tmp = in.getDerValue();
+        if (in.seeOptionalContextSpecific(1)) {
+            issuerUniqueId = new UniqueIdentity(in.getDerValue());
         }
 
         // Get the subjectUniqueId if present.
-        if (tmp.isContextSpecific((byte)2)) {
-            subjectUniqueId = new UniqueIdentity(tmp);
-            if (in.available() == 0)
-                return;
-            tmp = in.getDerValue();
+        if (in.seeOptionalContextSpecific(2)) {
+            subjectUniqueId = new UniqueIdentity(in.getDerValue());
         }
 
         // Get the extensions.
-        if (version.compare(CertificateVersion.V3) != 0) {
-            throw new CertificateParsingException(
-                      "Extensions not allowed in v2 certificate");
-        }
-        if (tmp.isConstructed() && tmp.isContextSpecific((byte)3)) {
-            extensions = new CertificateExtensions(tmp.data);
+        if (in.seeOptionalContextSpecific(3)) {
+            if (version.compare(CertificateVersion.V3) != 0) {
+                throw new CertificateParsingException(
+                        "Extensions not allowed in v2 certificate");
+            }
+            extensions = new CertificateExtensions(in.getDerValue().data);
         }
 
         // verify X.509 V3 Certificate
         verifyCert(subject, extensions);
 
diff a/test/jdk/sun/security/pkcs/pkcs8/PKCS8Test.java b/test/jdk/sun/security/pkcs/pkcs8/PKCS8Test.java
--- a/test/jdk/sun/security/pkcs/pkcs8/PKCS8Test.java
+++ b/test/jdk/sun/security/pkcs/pkcs8/PKCS8Test.java
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8048357 8244565
+ * @bug 8048357 8244565 8246797
  * @summary PKCS8 Standards Conformance Tests
  * @library /test/lib
  * @modules java.base/sun.security.pkcs
  *          java.base/sun.security.util
  *          java.base/sun.security.provider
@@ -83,19 +83,24 @@
         byte[] encodedOutput = decodedKey.getEncoded();
         Assert.assertTrue(Arrays.equals(encodedOutput, EXPECTED),
                 Utils.toHexString(encodedOutput));
 
         // Test additional fields
-        enlarge(0, "8000");    // attributes
-        enlarge(1, "810100");  // public key for v2
-        enlarge(1, "8000", "810100");  // both
+        String attr = "8000";
+        String pubK = "810100";
+        enlarge(0, attr);    // attributes
+        enlarge(1, pubK);  // public key for v2
+        enlarge(1, attr, pubK);  // both
 
         Assert.assertThrows(() -> enlarge(2));  // bad ver
-        Assert.assertThrows(() -> enlarge(0, "8000", "8000")); // no dup
-        Assert.assertThrows(() -> enlarge(0, "810100")); // no public in v1
-        Assert.assertThrows(() -> enlarge(1, "810100", "8000")); // bad order
-        Assert.assertThrows(() -> enlarge(1, "820100")); // bad tag
+        Assert.assertThrows(() -> enlarge(0, "4000")); // no application
+        Assert.assertThrows(() -> enlarge(0, "c000")); // no private
+        Assert.assertThrows(() -> enlarge(0, attr, attr)); // no dup
+        Assert.assertThrows(() -> enlarge(0, attr, "8200")); // no extra
+        Assert.assertThrows(() -> enlarge(0, pubK)); // no public in v1
+        Assert.assertThrows(() -> enlarge(1, pubK, attr)); // bad order
+        Assert.assertThrows(() -> enlarge(1, "8200")); // bad tag
     }
 
     /**
      * Add more fields to EXPECTED and see if it's still valid PKCS8.
      *
diff a/test/jdk/sun/security/util/DerValue/Indefinite.java b/test/jdk/sun/security/util/DerValue/Indefinite.java
--- a/test/jdk/sun/security/util/DerValue/Indefinite.java
+++ b/test/jdk/sun/security/util/DerValue/Indefinite.java
@@ -24,22 +24,46 @@
 /*
  * @test
  * @bug 6731685
  * @summary CertificateFactory.generateCertificates throws IOException on PKCS7 cert chain
  * @modules java.base/sun.security.util
+ * @library /test/lib
  */
 
 import java.io.*;
+import java.util.Arrays;
+
+import jdk.test.lib.Asserts;
 import sun.security.util.*;
 
 public class Indefinite {
 
     public static void main(String[] args) throws Exception {
         byte[] input = {
             // An OCTET-STRING in 2 parts
-            4, (byte)0x80, 4, 2, 'a', 'b', 4, 2, 'c', 'd', 0, 0,
-            // Garbage follows, may be falsely recognized as EOC
-            0, 0, 0, 0
+            0x24, (byte)0x80, 4, 2, 'a', 'b', 4, 2, 'c', 'd', 0, 0,
         };
-        new DerValue(new ByteArrayInputStream(input));
+
+        // Add some garbage, may be falsely recognized as EOC
+        new DerValue(new ByteArrayInputStream(
+                Arrays.copyOf(input, input.length + 4)));
+
+        // Make a SEQUENCE of input and (bool) true.
+        byte[] comp = new byte[input.length + 5];
+        comp[0] = DerValue.tag_Sequence;
+        comp[1] = (byte)(input.length + 3);
+        System.arraycopy(input, 0, comp, 2, input.length);
+        comp[2 + input.length] = comp[3 + input.length] = comp[4 + input.length] = 1;
+
+        // Read it
+        DerValue d = new DerValue(comp);
+        Asserts.assertEQ(new String(d.data.getDerValue().getOctetString()), "abcd");
+        Asserts.assertTrue(d.data.getBoolean());
+        d.data.atEnd();
+
+        // Or skip it
+        d = new DerValue(comp);
+        d.data.skipDerValue();
+        Asserts.assertTrue(d.data.getBoolean());
+        d.data.atEnd();
     }
 }

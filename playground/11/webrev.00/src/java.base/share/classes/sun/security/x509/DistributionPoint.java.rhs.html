<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/DistributionPoint.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.x509;
 27 
 28 import java.io.IOException;
 29 import java.util.*;
 30 
 31 import sun.security.util.BitArray;
 32 import sun.security.util.DerOutputStream;
 33 import sun.security.util.DerValue;
 34 
 35 /**
 36  * Represent the DistributionPoint sequence used in the CRL
 37  * Distribution Points Extension (OID = 2.5.29.31).
 38  * &lt;p&gt;
 39  * The ASN.1 definition for this is:
 40  * &lt;pre&gt;
 41  * DistributionPoint ::= SEQUENCE {
 42  *      distributionPoint       [0]     DistributionPointName OPTIONAL,
 43  *      reasons                 [1]     ReasonFlags OPTIONAL,
 44  *      cRLIssuer               [2]     GeneralNames OPTIONAL }
 45  *
 46  * DistributionPointName ::= CHOICE {
 47  *      fullName                [0]     GeneralNames,
 48  *      nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
 49  *
 50  * ReasonFlags ::= BIT STRING {
 51  *      unused                  (0),
 52  *      keyCompromise           (1),
 53  *      cACompromise            (2),
 54  *      affiliationChanged      (3),
 55  *      superseded              (4),
 56  *      cessationOfOperation    (5),
 57  *      certificateHold         (6),
 58  *      privilegeWithdrawn      (7),
 59  *      aACompromise            (8) }
 60  *
 61  * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 62  *
 63  * GeneralName ::= CHOICE {
 64  *         otherName                   [0] INSTANCE OF OTHER-NAME,
 65  *         rfc822Name                  [1] IA5String,
 66  *         dNSName                     [2] IA5String,
 67  *         x400Address                 [3] ORAddress,
 68  *         directoryName               [4] Name,
 69  *         ediPartyName                [5] EDIPartyName,
 70  *         uniformResourceIdentifier   [6] IA5String,
 71  *         iPAddress                   [7] OCTET STRING,
 72  *         registeredID                [8] OBJECT IDENTIFIER }
 73  *
 74  * RelativeDistinguishedName ::=
 75  *   SET OF AttributeTypeAndValue
 76  *
 77  * AttributeTypeAndValue ::= SEQUENCE {
 78  *   type     AttributeType,
 79  *   value    AttributeValue }
 80  *
 81  * AttributeType ::= OBJECT IDENTIFIER
 82  *
 83  * AttributeValue ::= ANY DEFINED BY AttributeType
 84  * &lt;/pre&gt;
 85  * &lt;p&gt;
 86  * Instances of this class are designed to be immutable. However, since this
 87  * is an internal API we do not use defensive cloning for values for
 88  * performance reasons. It is the responsibility of the consumer to ensure
 89  * that no mutable elements are modified.
 90  *
 91  * @author Anne Anderson
 92  * @author Andreas Sterbenz
 93  * @since 1.4.2
 94  * @see CRLDistributionPointsExtension
 95  */
 96 public class DistributionPoint {
 97 
 98     // reason flag bits
 99     // NOTE that these are NOT quite the same as the CRL reason code extension
100     public static final int KEY_COMPROMISE         = 1;
101     public static final int CA_COMPROMISE          = 2;
102     public static final int AFFILIATION_CHANGED    = 3;
103     public static final int SUPERSEDED             = 4;
104     public static final int CESSATION_OF_OPERATION = 5;
105     public static final int CERTIFICATE_HOLD       = 6;
106     public static final int PRIVILEGE_WITHDRAWN    = 7;
107     public static final int AA_COMPROMISE          = 8;
108 
109     private static final String[] REASON_STRINGS = {
110         null,
111         &quot;key compromise&quot;,
112         &quot;CA compromise&quot;,
113         &quot;affiliation changed&quot;,
114         &quot;superseded&quot;,
115         &quot;cessation of operation&quot;,
116         &quot;certificate hold&quot;,
117         &quot;privilege withdrawn&quot;,
118         &quot;AA compromise&quot;,
119     };
120 
121     // context specific tag values
122     private static final byte TAG_DIST_PT = 0;
123     private static final byte TAG_REASONS = 1;
124     private static final byte TAG_ISSUER = 2;
125 
126     private static final byte TAG_FULL_NAME = 0;
127     private static final byte TAG_REL_NAME = 1;
128 
129     // only one of fullName and relativeName can be set
130     private GeneralNames fullName;
131     private RDN relativeName;
132 
133     // reasonFlags or null
134     private boolean[] reasonFlags;
135 
136     // crlIssuer or null
137     private GeneralNames crlIssuer;
138 
139     // cached hashCode value
140     private volatile int hashCode;
141 
142     /**
143      * Constructor for the class using GeneralNames for DistributionPointName
144      *
145      * @param fullName the GeneralNames of the distribution point; may be null
146      * @param reasonFlags the CRL reasons included in the CRL at this distribution
147      *        point; may be null
148      * @param crlIssuer the name(s) of the CRL issuer for the CRL at this
149      *        distribution point; may be null
150      */
151     public DistributionPoint(GeneralNames fullName, boolean[] reasonFlags,
152             GeneralNames crlIssuer) {
153         if ((fullName == null) &amp;&amp; (crlIssuer == null)) {
154             throw new IllegalArgumentException
155                         (&quot;fullName and crlIssuer may not both be null&quot;);
156         }
157         this.fullName = fullName;
158         this.reasonFlags = reasonFlags;
159         this.crlIssuer = crlIssuer;
160     }
161 
162     /**
163      * Constructor for the class using RelativeDistinguishedName for
164      * DistributionPointName
165      *
166      * @param relativeName the RelativeDistinguishedName of the distribution
167      *        point; may not be null
168      * @param reasonFlags the CRL reasons included in the CRL at this distribution
169      *        point; may be null
170      * @param crlIssuer the name(s) of the CRL issuer for the CRL at this
171      *        distribution point; may not be null or empty.
172      */
173     public DistributionPoint(RDN relativeName, boolean[] reasonFlags,
174             GeneralNames crlIssuer) {
175         if ((relativeName == null) &amp;&amp; (crlIssuer == null)) {
176             throw new IllegalArgumentException
177                         (&quot;relativeName and crlIssuer may not both be null&quot;);
178         }
179         this.relativeName = relativeName;
180         this.reasonFlags = reasonFlags;
181         this.crlIssuer = crlIssuer;
182     }
183 
184     /**
185      * Create the object from the passed DER encoded form.
186      *
187      * @param val the DER encoded form of the DistributionPoint
188      * @throws IOException on error
189      */
190     public DistributionPoint(DerValue val) throws IOException {
191         if (val.tag != DerValue.tag_Sequence) {
192             throw new IOException(&quot;Invalid encoding of DistributionPoint.&quot;);
193         }
194 
<a name="1" id="anc1"></a><span class="line-modified">195         var v = val.data.getOptionalExplicitContextSpecific(TAG_DIST_PT);</span>
<span class="line-modified">196         if (v.isPresent()) {</span>
<span class="line-modified">197             DerValue distPnt = v.get();</span>
<span class="line-modified">198             if (distPnt.isContextSpecific(TAG_FULL_NAME)</span>
<span class="line-modified">199                     &amp;&amp; distPnt.isConstructed()) {</span>
<span class="line-modified">200                 distPnt.resetTag(DerValue.tag_Sequence);</span>
<span class="line-modified">201                 fullName = new GeneralNames(distPnt);</span>
<span class="line-modified">202             } else if (distPnt.isContextSpecific(TAG_REL_NAME)</span>
<span class="line-modified">203                     &amp;&amp; distPnt.isConstructed()) {</span>
<span class="line-modified">204                 distPnt.resetTag(DerValue.tag_Set);</span>
<span class="line-modified">205                 relativeName = new RDN(distPnt);</span>





























206             } else {
<a name="2" id="anc2"></a><span class="line-modified">207                 throw new IOException(&quot;Invalid DistributionPointName in &quot;</span>
<span class="line-modified">208                         + &quot;DistributionPoint&quot;);</span>
209             }
210         }
<a name="3" id="anc3"></a><span class="line-added">211 </span>
<span class="line-added">212         v = val.data.getOptionalImplicitContextSpecific(</span>
<span class="line-added">213                 TAG_REASONS, DerValue.tag_BitString);</span>
<span class="line-added">214         if (v.isPresent()) {</span>
<span class="line-added">215             reasonFlags = (v.get().getUnalignedBitString()).toBooleanArray();</span>
<span class="line-added">216         }</span>
<span class="line-added">217 </span>
<span class="line-added">218         v = val.data.getOptionalImplicitContextSpecific(</span>
<span class="line-added">219                 TAG_ISSUER, DerValue.tag_Sequence);</span>
<span class="line-added">220         if (v.isPresent()) {</span>
<span class="line-added">221             crlIssuer = new GeneralNames(v.get());</span>
<span class="line-added">222         }</span>
<span class="line-added">223 </span>
<span class="line-added">224         val.data.atEnd();</span>
225         if ((crlIssuer == null) &amp;&amp; (fullName == null) &amp;&amp; (relativeName == null)) {
226             throw new IOException(&quot;One of fullName, relativeName, &quot;
227                 + &quot; and crlIssuer has to be set&quot;);
228         }
229     }
230 
231     /**
232      * Return the full distribution point name or null if not set.
233      */
234     public GeneralNames getFullName() {
235         return fullName;
236     }
237 
238     /**
239      * Return the relative distribution point name or null if not set.
240      */
241     public RDN getRelativeName() {
242         return relativeName;
243     }
244 
245     /**
246      * Return the reason flags or null if not set.
247      */
248     public boolean[] getReasonFlags() {
249         return reasonFlags;
250     }
251 
252     /**
253      * Return the CRL issuer name or null if not set.
254      */
255     public GeneralNames getCRLIssuer() {
256         return crlIssuer;
257     }
258 
259     /**
260      * Write the DistributionPoint value to the DerOutputStream.
261      *
262      * @param out the DerOutputStream to write the extension to.
263      * @exception IOException on error.
264      */
265     public void encode(DerOutputStream out) throws IOException {
266         DerOutputStream tagged = new DerOutputStream();
267 
268         // NOTE: only one of pointNames and pointRDN can be set
269         if ((fullName != null) || (relativeName != null)) {
270             DerOutputStream distributionPoint = new DerOutputStream();
271             if (fullName != null) {
272                 DerOutputStream derOut = new DerOutputStream();
273                 fullName.encode(derOut);
274                 distributionPoint.writeImplicit(
275                     DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_FULL_NAME),
276                     derOut);
277             } else if (relativeName != null) {
278                 DerOutputStream derOut = new DerOutputStream();
279                 relativeName.encode(derOut);
280                 distributionPoint.writeImplicit(
281                     DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_REL_NAME),
282                     derOut);
283             }
284             tagged.write(
285                 DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_DIST_PT),
286                 distributionPoint);
287         }
288         if (reasonFlags != null) {
289             DerOutputStream reasons = new DerOutputStream();
290             BitArray rf = new BitArray(reasonFlags);
291             reasons.putTruncatedUnalignedBitString(rf);
292             tagged.writeImplicit(
293                 DerValue.createTag(DerValue.TAG_CONTEXT, false, TAG_REASONS),
294                 reasons);
295         }
296         if (crlIssuer != null) {
297             DerOutputStream issuer = new DerOutputStream();
298             crlIssuer.encode(issuer);
299             tagged.writeImplicit(
300                 DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_ISSUER),
301                 issuer);
302         }
303         out.write(DerValue.tag_Sequence, tagged);
304     }
305 
306     /**
307      * Compare an object to this DistributionPoint for equality.
308      *
309      * @param obj Object to be compared to this
310      * @return true if objects match; false otherwise
311      */
312     public boolean equals(Object obj) {
313         if (this == obj) {
314             return true;
315         }
316         if (obj instanceof DistributionPoint == false) {
317             return false;
318         }
319         DistributionPoint other = (DistributionPoint)obj;
320 
321         boolean equal = Objects.equals(this.fullName, other.fullName)
322                      &amp;&amp; Objects.equals(this.relativeName, other.relativeName)
323                      &amp;&amp; Objects.equals(this.crlIssuer, other.crlIssuer)
324                      &amp;&amp; Arrays.equals(this.reasonFlags, other.reasonFlags);
325         return equal;
326     }
327 
328     public int hashCode() {
329         int hash = hashCode;
330         if (hash == 0) {
331             hash = 1;
332             if (fullName != null) {
333                 hash += fullName.hashCode();
334             }
335             if (relativeName != null) {
336                 hash += relativeName.hashCode();
337             }
338             if (crlIssuer != null) {
339                 hash += crlIssuer.hashCode();
340             }
341             if (reasonFlags != null) {
342                 for (int i = 0; i &lt; reasonFlags.length; i++) {
343                     if (reasonFlags[i]) {
344                         hash += i;
345                     }
346                 }
347             }
348             hashCode = hash;
349         }
350         return hash;
351     }
352 
353     /**
354      * Return a string representation for reasonFlag bit &#39;reason&#39;.
355      */
356     private static String reasonToString(int reason) {
357         if ((reason &gt; 0) &amp;&amp; (reason &lt; REASON_STRINGS.length)) {
358             return REASON_STRINGS[reason];
359         }
360         return &quot;Unknown reason &quot; + reason;
361     }
362 
363     /**
364      * Return a printable string of the Distribution Point.
365      */
366     public String toString() {
367         StringBuilder sb = new StringBuilder();
368         sb.append(&quot;DistributionPoint:\n     &quot;);
369         if (fullName != null) {
370             sb.append(fullName);
371         }
372         if (relativeName != null) {
373             sb.append(relativeName);
374         }
375         sb.append(&#39;\n&#39;);
376 
377         if (reasonFlags != null) {
378             sb.append(&quot;   ReasonFlags:\n&quot;);
379             for (int i = 0; i &lt; reasonFlags.length; i++) {
380                 if (reasonFlags[i]) {
381                     sb.append(&quot;    &quot;)
382                         .append(reasonToString(i))
383                         .append(&#39;\n&#39;);
384                 }
385             }
386         }
387         if (crlIssuer != null) {
388             sb.append(&quot;   CRLIssuer:&quot;)
389                 .append(crlIssuer)
390                 .append(&#39;\n&#39;);
391         }
392         return sb.toString();
393     }
394 
395 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/x509/X509CRLImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X509CRLEntryImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509CertInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/x509/X509CRLImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1109 
1110         sigAlgId = AlgorithmId.parse(seq[1]);
1111         signature = seq[2].getBitString();
1112 
1113         if (seq[1].data.available() != 0)
1114             throw new CRLException(&quot;AlgorithmId field overrun&quot;);
1115 
1116         if (seq[2].data.available() != 0)
1117             throw new CRLException(&quot;Signature field overrun&quot;);
1118 
1119         // the tbsCertsList
1120         tbsCertList = seq[0].toByteArray();
1121 
1122         // parse the information
1123         DerInputStream derStrm = seq[0].data;
1124         DerValue       tmp;
1125         byte           nextByte;
1126 
1127         // version (optional if v1)
1128         version = 0;   // by default, version = v1 == 0
<span class="line-modified">1129         nextByte = (byte)derStrm.peekByte();</span>
<span class="line-removed">1130         if (nextByte == DerValue.tag_Integer) {</span>
1131             version = derStrm.getInteger();
1132             if (version != 1)  // i.e. v2
1133                 throw new CRLException(&quot;Invalid version&quot;);
1134         }
1135         tmp = derStrm.getDerValue();
1136 
1137         // signature
1138         AlgorithmId tmpId = AlgorithmId.parse(tmp);
1139 
1140         // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
1141         if (! tmpId.equals(sigAlgId))
1142             throw new CRLException(&quot;Signature algorithm mismatch&quot;);
1143         infoSigAlgId = tmpId;
1144 
1145         // issuer
1146         issuer = new X500Name(derStrm);
1147         if (issuer.isEmpty()) {
1148             throw new CRLException(&quot;Empty issuer DN not allowed in X509CRLs&quot;);
1149         }
1150 
1151         // thisUpdate
1152         // check if UTCTime encoded or GeneralizedTime
1153 
<span class="line-modified">1154         nextByte = (byte)derStrm.peekByte();</span>
<span class="line-removed">1155         if (nextByte == DerValue.tag_UtcTime) {</span>
<span class="line-removed">1156             thisUpdate = derStrm.getUTCTime();</span>
<span class="line-removed">1157         } else if (nextByte == DerValue.tag_GeneralizedTime) {</span>
<span class="line-removed">1158             thisUpdate = derStrm.getGeneralizedTime();</span>
<span class="line-removed">1159         } else {</span>
<span class="line-removed">1160             throw new CRLException(&quot;Invalid encoding for thisUpdate&quot;</span>
<span class="line-removed">1161                                    + &quot; (tag=&quot; + nextByte + &quot;)&quot;);</span>
<span class="line-removed">1162         }</span>
<span class="line-removed">1163 </span>
<span class="line-removed">1164         if (derStrm.available() == 0)</span>
<span class="line-removed">1165            return;     // done parsing no more optional fields present</span>
<span class="line-removed">1166 </span>
<span class="line-removed">1167         // nextUpdate (optional)</span>
<span class="line-removed">1168         nextByte = (byte)derStrm.peekByte();</span>
<span class="line-removed">1169         if (nextByte == DerValue.tag_UtcTime) {</span>
<span class="line-removed">1170             nextUpdate = derStrm.getUTCTime();</span>
<span class="line-removed">1171         } else if (nextByte == DerValue.tag_GeneralizedTime) {</span>
<span class="line-removed">1172             nextUpdate = derStrm.getGeneralizedTime();</span>
<span class="line-removed">1173         } // else it is not present</span>
1174 
<span class="line-modified">1175         if (derStrm.available() == 0)</span>
<span class="line-modified">1176             return;     // done parsing no more optional fields present</span>


1177 
<span class="line-modified">1178         // revokedCertificates (optional)</span>
<span class="line-removed">1179         nextByte = (byte)derStrm.peekByte();</span>
<span class="line-removed">1180         if ((nextByte == DerValue.tag_SequenceOf)</span>
<span class="line-removed">1181             &amp;&amp; (! ((nextByte &amp; 0x0c0) == 0x080))) {</span>
1182             DerValue[] badCerts = derStrm.getSequence(4);
1183 
1184             X500Principal crlIssuer = getIssuerX500Principal();
1185             X500Principal badCertIssuer = crlIssuer;
1186             for (int i = 0; i &lt; badCerts.length; i++) {
1187                 X509CRLEntryImpl entry = new X509CRLEntryImpl(badCerts[i]);
1188                 badCertIssuer = getCertIssuer(entry, badCertIssuer);
1189                 entry.setCertificateIssuer(crlIssuer, badCertIssuer);
1190                 X509IssuerSerial issuerSerial = new X509IssuerSerial
1191                     (badCertIssuer, entry.getSerialNumber());
1192                 revokedMap.put(issuerSerial, entry);
1193                 revokedList.add(entry);
1194             }
1195         }
1196 
<span class="line-modified">1197         if (derStrm.available() == 0)</span>
<span class="line-modified">1198             return;     // done parsing no extensions</span>
<span class="line-removed">1199 </span>
<span class="line-removed">1200         // crlExtensions (optional)</span>
<span class="line-removed">1201         tmp = derStrm.getDerValue();</span>
<span class="line-removed">1202         if (tmp.isConstructed() &amp;&amp; tmp.isContextSpecific((byte)0)) {</span>
<span class="line-removed">1203             extensions = new CRLExtensions(tmp.data);</span>
1204         }
1205         readOnly = true;
1206     }
1207 
1208     /**
1209      * Extract the issuer X500Principal from an X509CRL. Parses the encoded
1210      * form of the CRL to preserve the principal&#39;s ASN.1 encoding.
1211      *
1212      * Called by java.security.cert.X509CRL.getIssuerX500Principal().
1213      */
1214     public static X500Principal getIssuerX500Principal(X509CRL crl) {
1215         try {
1216             byte[] encoded = crl.getEncoded();
1217             DerInputStream derIn = new DerInputStream(encoded);
1218             DerValue tbsCert = derIn.getSequence(3)[0];
1219             DerInputStream tbsIn = tbsCert.data;
1220 
1221             DerValue tmp;
1222             // skip version number if present
<span class="line-modified">1223             byte nextByte = (byte)tbsIn.peekByte();</span>
<span class="line-modified">1224             if (nextByte == DerValue.tag_Integer) {</span>
<span class="line-removed">1225                 tmp = tbsIn.getDerValue();</span>
1226             }
<span class="line-modified">1227 </span>
<span class="line-removed">1228             tmp = tbsIn.getDerValue();  // skip signature</span>
1229             tmp = tbsIn.getDerValue();  // issuer
1230             byte[] principalBytes = tmp.toByteArray();
1231             return new X500Principal(principalBytes);
1232         } catch (Exception e) {
1233             throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
1234         }
1235     }
1236 
1237     /**
1238      * Returned the encoding of the given certificate for internal use.
1239      * Callers must guarantee that they neither modify it nor expose it
1240      * to untrusted code. Uses getEncodedInternal() if the certificate
1241      * is instance of X509CertImpl, getEncoded() otherwise.
1242      */
1243     public static byte[] getEncodedInternal(X509CRL crl) throws CRLException {
1244         if (crl instanceof X509CRLImpl) {
1245             return ((X509CRLImpl)crl).getEncodedInternal();
1246         } else {
1247             return crl.getEncoded();
1248         }
</pre>
</td>
<td>
<hr />
<pre>
1109 
1110         sigAlgId = AlgorithmId.parse(seq[1]);
1111         signature = seq[2].getBitString();
1112 
1113         if (seq[1].data.available() != 0)
1114             throw new CRLException(&quot;AlgorithmId field overrun&quot;);
1115 
1116         if (seq[2].data.available() != 0)
1117             throw new CRLException(&quot;Signature field overrun&quot;);
1118 
1119         // the tbsCertsList
1120         tbsCertList = seq[0].toByteArray();
1121 
1122         // parse the information
1123         DerInputStream derStrm = seq[0].data;
1124         DerValue       tmp;
1125         byte           nextByte;
1126 
1127         // version (optional if v1)
1128         version = 0;   // by default, version = v1 == 0
<span class="line-modified">1129         if (derStrm.seeOptional(DerValue.tag_Integer)) {</span>

1130             version = derStrm.getInteger();
1131             if (version != 1)  // i.e. v2
1132                 throw new CRLException(&quot;Invalid version&quot;);
1133         }
1134         tmp = derStrm.getDerValue();
1135 
1136         // signature
1137         AlgorithmId tmpId = AlgorithmId.parse(tmp);
1138 
1139         // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
1140         if (! tmpId.equals(sigAlgId))
1141             throw new CRLException(&quot;Signature algorithm mismatch&quot;);
1142         infoSigAlgId = tmpId;
1143 
1144         // issuer
1145         issuer = new X500Name(derStrm);
1146         if (issuer.isEmpty()) {
1147             throw new CRLException(&quot;Empty issuer DN not allowed in X509CRLs&quot;);
1148         }
1149 
1150         // thisUpdate
1151         // check if UTCTime encoded or GeneralizedTime
1152 
<span class="line-modified">1153         thisUpdate = derStrm.getTime();</span>



















1154 
<span class="line-modified">1155         if (derStrm.seeOptional(t -&gt;</span>
<span class="line-modified">1156                 t == DerValue.tag_UtcTime || t == DerValue.tag_GeneralizedTime)) {</span>
<span class="line-added">1157             nextUpdate = derStrm.getTime();</span>
<span class="line-added">1158         }</span>
1159 
<span class="line-modified">1160         if (derStrm.seeOptional(DerValue.tag_SequenceOf)) {</span>



1161             DerValue[] badCerts = derStrm.getSequence(4);
1162 
1163             X500Principal crlIssuer = getIssuerX500Principal();
1164             X500Principal badCertIssuer = crlIssuer;
1165             for (int i = 0; i &lt; badCerts.length; i++) {
1166                 X509CRLEntryImpl entry = new X509CRLEntryImpl(badCerts[i]);
1167                 badCertIssuer = getCertIssuer(entry, badCertIssuer);
1168                 entry.setCertificateIssuer(crlIssuer, badCertIssuer);
1169                 X509IssuerSerial issuerSerial = new X509IssuerSerial
1170                     (badCertIssuer, entry.getSerialNumber());
1171                 revokedMap.put(issuerSerial, entry);
1172                 revokedList.add(entry);
1173             }
1174         }
1175 
<span class="line-modified">1176         if (derStrm.seeOptionalContextSpecific(0)) {</span>
<span class="line-modified">1177             extensions = new CRLExtensions(derStrm.getDerValue().data);</span>





1178         }
1179         readOnly = true;
1180     }
1181 
1182     /**
1183      * Extract the issuer X500Principal from an X509CRL. Parses the encoded
1184      * form of the CRL to preserve the principal&#39;s ASN.1 encoding.
1185      *
1186      * Called by java.security.cert.X509CRL.getIssuerX500Principal().
1187      */
1188     public static X500Principal getIssuerX500Principal(X509CRL crl) {
1189         try {
1190             byte[] encoded = crl.getEncoded();
1191             DerInputStream derIn = new DerInputStream(encoded);
1192             DerValue tbsCert = derIn.getSequence(3)[0];
1193             DerInputStream tbsIn = tbsCert.data;
1194 
1195             DerValue tmp;
1196             // skip version number if present
<span class="line-modified">1197             if (tbsIn.seeOptional(DerValue.tag_Integer)) {</span>
<span class="line-modified">1198                 tbsIn.skipDerValue();</span>

1199             }
<span class="line-modified">1200             tbsIn.skipDerValue();</span>

1201             tmp = tbsIn.getDerValue();  // issuer
1202             byte[] principalBytes = tmp.toByteArray();
1203             return new X500Principal(principalBytes);
1204         } catch (Exception e) {
1205             throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
1206         }
1207     }
1208 
1209     /**
1210      * Returned the encoding of the given certificate for internal use.
1211      * Callers must guarantee that they neither modify it nor expose it
1212      * to untrusted code. Uses getEncodedInternal() if the certificate
1213      * is instance of X509CertImpl, getEncoded() otherwise.
1214      */
1215     public static byte[] getEncodedInternal(X509CRL crl) throws CRLException {
1216         if (crl instanceof X509CRLImpl) {
1217             return ((X509CRLImpl)crl).getEncodedInternal();
1218         } else {
1219             return crl.getEncoded();
1220         }
</pre>
</td>
</tr>
</table>
<center><a href="X509CRLEntryImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X509CertInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
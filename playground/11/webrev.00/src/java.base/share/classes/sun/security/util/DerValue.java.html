<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /**
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.util;
  27 
  28 import java.io.*;
  29 import java.math.BigInteger;
  30 import java.nio.charset.Charset;
  31 import java.util.ArrayList;
  32 import java.util.Date;
  33 import java.util.List;
  34 
  35 import static java.nio.charset.StandardCharsets.*;
  36 
  37 /**
  38  * Represents a single DER-encoded value.  DER encoding rules are a subset
  39  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
  40  * (&quot;Definite&quot; encoding) to encode any given value.
  41  *
  42  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
  43  * class represents such tagged values as they have been read (or constructed),
  44  * and provides structured access to the encoded data.
  45  *
  46  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
  47  * data encodings which are defined.  That subset is sufficient for parsing
  48  * most X.509 certificates, and working with selected additional formats
  49  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
  50  *
  51  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
  52  * and RFC 5280, section 8, we assume that this kind of string will contain
  53  * ISO-8859-1 characters only.
  54  *
  55  *
  56  * @author David Brownell
  57  * @author Amit Kapoor
  58  * @author Hemma Prafullchandra
  59  */
  60 public class DerValue {
  61     /** The tag class types */
  62     public static final byte TAG_UNIVERSAL = (byte)0x000;
  63     public static final byte TAG_APPLICATION = (byte)0x040;
  64     public static final byte TAG_CONTEXT = (byte)0x080;
  65     public static final byte TAG_PRIVATE = (byte)0x0c0;
  66 
  67     /** The DER tag of the value; one of the tag_ constants. */
  68     public byte                 tag;
  69 
  70     protected DerInputBuffer    buffer;
  71 
  72     /**
  73      * The DER-encoded data of the value, never null
  74      */
  75     public final DerInputStream data;
  76 
  77     private int                 length;
  78 
  79     /*
  80      * The type starts at the first byte of the encoding, and
  81      * is one of these tag_* values.  That may be all the type
  82      * data that is needed.
  83      */
  84 
  85     /*
  86      * These tags are the &quot;universal&quot; tags ... they mean the same
  87      * in all contexts.  (Mask with 0x1f -- five bits.)
  88      */
  89 
  90     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
  91     public static final byte    tag_Boolean = 0x01;
  92 
  93     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
  94     public static final byte    tag_Integer = 0x02;
  95 
  96     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
  97     public static final byte    tag_BitString = 0x03;
  98 
  99     /** Tag value indicating an ASN.1 &quot;OCTET STRING&quot; value. */
 100     public static final byte    tag_OctetString = 0x04;
 101 
 102     /** Tag value indicating an ASN.1 &quot;NULL&quot; value. */
 103     public static final byte    tag_Null = 0x05;
 104 
 105     /** Tag value indicating an ASN.1 &quot;OBJECT IDENTIFIER&quot; value. */
 106     public static final byte    tag_ObjectId = 0x06;
 107 
 108     /** Tag value including an ASN.1 &quot;ENUMERATED&quot; value */
 109     public static final byte    tag_Enumerated = 0x0A;
 110 
 111     /** Tag value indicating an ASN.1 &quot;UTF8String&quot; value. */
 112     public static final byte    tag_UTF8String = 0x0C;
 113 
 114     /** Tag value including a &quot;printable&quot; string */
 115     public static final byte    tag_PrintableString = 0x13;
 116 
 117     /** Tag value including a &quot;teletype&quot; string */
 118     public static final byte    tag_T61String = 0x14;
 119 
 120     /** Tag value including an ASCII string */
 121     public static final byte    tag_IA5String = 0x16;
 122 
 123     /** Tag value indicating an ASN.1 &quot;UTCTime&quot; value. */
 124     public static final byte    tag_UtcTime = 0x17;
 125 
 126     /** Tag value indicating an ASN.1 &quot;GeneralizedTime&quot; value. */
 127     public static final byte    tag_GeneralizedTime = 0x18;
 128 
 129     /** Tag value indicating an ASN.1 &quot;GenerallString&quot; value. */
 130     public static final byte    tag_GeneralString = 0x1B;
 131 
 132     /** Tag value indicating an ASN.1 &quot;UniversalString&quot; value. */
 133     public static final byte    tag_UniversalString = 0x1C;
 134 
 135     /** Tag value indicating an ASN.1 &quot;BMPString&quot; value. */
 136     public static final byte    tag_BMPString = 0x1E;
 137 
 138     // CONSTRUCTED seq/set
 139 
 140     /**
 141      * Tag value indicating an ASN.1
 142      * &quot;SEQUENCE&quot; (zero to N elements, order is significant).
 143      */
 144     public static final byte    tag_Sequence = 0x30;
 145 
 146     /**
 147      * Tag value indicating an ASN.1
 148      * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
 149      */
 150     public static final byte    tag_SequenceOf = 0x30;
 151 
 152     /**
 153      * Tag value indicating an ASN.1
 154      * &quot;SET&quot; (zero to N members, order does not matter).
 155      */
 156     public static final byte    tag_Set = 0x31;
 157 
 158     /**
 159      * Tag value indicating an ASN.1
 160      * &quot;SET OF&quot; (one to N members, order does not matter).
 161      */
 162     public static final byte    tag_SetOf = 0x31;
 163 
 164     /*
 165      * These values are the high order bits for the other kinds of tags.
 166      */
 167 
 168     /**
 169      * Returns true if the tag class is UNIVERSAL.
 170      */
 171     public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }
 172 
 173     /**
 174      * Returns true if the tag class is APPLICATION.
 175      */
 176     public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }
 177 
 178     /**
 179      * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
 180      * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
 181      */
 182     public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }
 183 
 184     /**
 185      * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.
 186      */
 187     public boolean isContextSpecific(byte cntxtTag) {
 188         if (!isContextSpecific()) {
 189             return false;
 190         }
 191         return ((tag &amp; 0x01f) == cntxtTag);
 192     }
 193 
 194     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
 195 
 196     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
 197     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
 198 
 199     /**
 200      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
 201      */
 202     public boolean isConstructed(byte constructedTag) {
 203         if (!isConstructed()) {
 204             return false;
 205         }
 206         return ((tag &amp; 0x01f) == constructedTag);
 207     }
 208 
 209     /**
 210      * Creates a PrintableString or UTF8string DER value from a string
 211      */
 212     public DerValue(String value) {
 213         boolean isPrintableString = true;
 214         for (int i = 0; i &lt; value.length(); i++) {
 215             if (!isPrintableStringChar(value.charAt(i))) {
 216                 isPrintableString = false;
 217                 break;
 218             }
 219         }
 220 
 221         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
 222     }
 223 
 224     /**
 225      * Creates a string type DER value from a String object
 226      * @param stringTag the tag for the DER value to create
 227      * @param value the String object to use for the DER value
 228      */
 229     public DerValue(byte stringTag, String value) {
 230         data = init(stringTag, value);
 231     }
 232 
 233     // Creates a DerValue from a tag and some DER-encoded data w/ additional
 234     // arg to control whether DER checks are enforced.
 235     DerValue(byte tag, byte[] data, boolean allowBER) {
 236         this.tag = tag;
 237         buffer = new DerInputBuffer(data.clone(), allowBER);
 238         length = data.length;
 239         this.data = new DerInputStream(buffer);
 240         this.data.mark(Integer.MAX_VALUE);
 241     }
 242 
 243     /**
 244      * Creates a DerValue from a tag and some DER-encoded data.
 245      *
 246      * @param tag the DER type tag
 247      * @param data the DER-encoded data
 248      */
 249     public DerValue(byte tag, byte[] data) {
 250         this(tag, data, true);
 251     }
 252 
 253     /*
 254      * package private
 255      */
 256     DerValue(DerInputBuffer in) throws IOException {
 257 
 258         // XXX must also parse BER-encoded constructed
 259         // values such as sequences, sets...
 260         tag = (byte)in.read();
 261         byte lenByte = (byte)in.read();
 262         llen = lenlen(lenByte);
 263         length = DerInputStream.getLength(lenByte, in);
 264         if (length == -1) {  // indefinite length encoding found
 265             DerInputBuffer inbuf = in.dup();
 266             inbuf = new DerInputBuffer(
 267                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
 268                     in.allowBER);
 269             if (tag != inbuf.read())
 270                 throw new IOException
 271                         (&quot;Indefinite length encoding not supported&quot;);
 272             length = DerInputStream.getDefiniteLength(inbuf);
 273             buffer = inbuf.dup();
 274             buffer.truncate(length);
 275             data = new DerInputStream(buffer);
 276             // indefinite form is encoded by sending a length field with a
 277             // length of 0. - i.e. [1000|0000].
 278             // the object is ended by sending two zero bytes.
 279             in.skip(length + 2);
 280         } else {
 281 
 282             buffer = in.dup();
 283             buffer.truncate(length);
 284             data = new DerInputStream(buffer);
 285 
 286             in.skip(length);
 287         }
 288     }
 289 
 290     // Get an ASN.1/DER encoded datum from a buffer w/ additional
 291     // arg to control whether DER checks are enforced.
 292     DerValue(byte[] buf, boolean allowBER) throws IOException {
 293         data = init(true, new ByteArrayInputStream(buf), allowBER);
 294     }
 295 
 296     /**
 297      * Get an ASN.1/DER encoded datum from a buffer.  The
 298      * entire buffer must hold exactly one datum, including
 299      * its tag and length.
 300      *
 301      * @param buf buffer holding a single DER-encoded datum.
 302      */
 303     public DerValue(byte[] buf) throws IOException {
 304         this(buf, true);
 305     }
 306 
 307     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
 308     // arg to control whether DER checks are enforced.
 309     DerValue(byte[] buf, int offset, int len, boolean allowBER)
 310         throws IOException {
 311         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
 312     }
 313 
 314     /**
 315      * Get an ASN.1/DER encoded datum from part of a buffer.
 316      * That part of the buffer must hold exactly one datum, including
 317      * its tag and length.
 318      *
 319      * @param buf the buffer
 320      * @param offset start point of the single DER-encoded dataum
 321      * @param len how many bytes are in the encoded datum
 322      */
 323     public DerValue(byte[] buf, int offset, int len) throws IOException {
 324         this(buf, offset, len, true);
 325     }
 326 
 327     // Get an ASN1/DER encoded datum from an input stream w/ additional
 328     // arg to control whether DER checks are enforced.
 329     DerValue(InputStream in, boolean allowBER) throws IOException {
 330         data = init(false, in, allowBER);
 331     }
 332 
 333     /**
 334      * Get an ASN1/DER encoded datum from an input stream.  The
 335      * stream may have additional data following the encoded datum.
 336      * In case of indefinite length encoded datum, the input stream
 337      * must hold only one datum.
 338      *
 339      * @param in the input stream holding a single DER datum,
 340      *  which may be followed by additional data
 341      */
 342     public DerValue(InputStream in) throws IOException {
 343         this(in, true);
 344     }
 345 
 346     private DerInputStream init(byte stringTag, String value) {
 347         final Charset charset;
 348 
 349         tag = stringTag;
 350 
 351         switch (stringTag) {
 352         case tag_PrintableString:
 353         case tag_IA5String:
 354         case tag_GeneralString:
 355             charset = US_ASCII;
 356             break;
 357         case tag_T61String:
 358             charset = ISO_8859_1;
 359             break;
 360         case tag_BMPString:
 361             charset = UTF_16BE;
 362             break;
 363         case tag_UTF8String:
 364             charset = UTF_8;
 365             break;
 366             // TBD: Need encoder for UniversalString before it can
 367             // be handled.
 368         default:
 369             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
 370         }
 371 
 372         byte[] buf = value.getBytes(charset);
 373         length = buf.length;
 374         buffer = new DerInputBuffer(buf, true);
 375         DerInputStream result = new DerInputStream(buffer);
 376         result.mark(Integer.MAX_VALUE);
 377         return result;
 378     }
 379 
 380     int llen = 0;
 381 
 382     /*
 383      * helper routine
 384      */
 385     private DerInputStream init(boolean fullyBuffered, InputStream in,
 386         boolean allowBER) throws IOException {
 387 
 388         tag = (byte)in.read();
 389         byte lenByte = (byte)in.read();
 390 
 391         llen = lenlen(lenByte);
 392         length = DerInputStream.getLength(lenByte, in);
 393 
 394         if (length == -1) { // indefinite length encoding found
 395             in = new ByteArrayInputStream(
 396                     DerIndefLenConverter.convertStream(in, lenByte, tag));
 397             if (tag != in.read())
 398                 throw new IOException
 399                         (&quot;Indefinite length encoding not supported&quot;);
 400             length = DerInputStream.getDefiniteLength(in);
 401         }
 402 
 403         if (fullyBuffered &amp;&amp; in.available() != length)
 404             throw new IOException(&quot;extra data given to DerValue constructor&quot;);
 405 
 406         byte[] bytes = IOUtils.readExactlyNBytes(in, length);
 407 
 408         buffer = new DerInputBuffer(bytes, allowBER);
 409         return new DerInputStream(buffer);
 410     }
 411 
 412     private int lenlen(byte lenByte) {
 413         if ((lenByte &amp; 0x080) == 0x00) { // short form, 1 byte datum
 414             return 1;
 415         } else {                     // long form or indefinite
 416             return 1 + (lenByte &amp; 0x7f);
 417         }
 418     }
 419 
 420     /**
 421      * Encode an ASN1/DER encoded datum onto a DER output stream.
 422      */
 423     public void encode(DerOutputStream out)
 424     throws IOException {
 425         out.write(tag);
 426         out.putLength(length);
 427         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
 428         if (length &gt; 0) {
 429             byte[] value = new byte[length];
 430             // always synchronized on data
 431             synchronized (data) {
 432                 buffer.reset();
 433                 if (buffer.read(value) != length) {
 434                     throw new IOException(&quot;short DER value read (encode)&quot;);
 435                 }
 436                 out.write(value);
 437             }
 438         }
 439     }
 440 
 441     public final DerInputStream getData() {
 442         return data;
 443     }
 444 
 445     public final byte getTag() {
 446         return tag;
 447     }
 448 
 449     /**
 450      * Returns an ASN.1 BOOLEAN
 451      *
 452      * @return the boolean held in this DER value
 453      */
 454     public boolean getBoolean() throws IOException {
 455         if (tag != tag_Boolean) {
 456             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
 457         }
 458         if (length != 1) {
 459             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
 460                                         + length);
 461         }
 462         if (buffer.read() != 0) {
 463             return true;
 464         }
 465         return false;
 466     }
 467 
 468     /**
 469      * Returns an ASN.1 OBJECT IDENTIFIER.
 470      *
 471      * @return the OID held in this DER value
 472      */
 473     public ObjectIdentifier getOID() throws IOException {
 474         if (tag != tag_ObjectId)
 475             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
 476         return new ObjectIdentifier(buffer);
 477     }
 478 
 479     private byte[] append(byte[] a, byte[] b) {
 480         if (a == null)
 481             return b;
 482 
 483         byte[] ret = new byte[a.length + b.length];
 484         System.arraycopy(a, 0, ret, 0, a.length);
 485         System.arraycopy(b, 0, ret, a.length, b.length);
 486 
 487         return ret;
 488     }
 489 
 490     /**
 491      * Returns an ASN.1 OCTET STRING
 492      *
 493      * @return the octet string held in this DER value
 494      */
 495     public byte[] getOctetString() throws IOException {
 496 
 497         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
 498             throw new IOException(
 499                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
 500         }
 501         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
 502         // known bug that it returns -1 instead of 0.
 503         if (length == 0) {
 504             return new byte[0];
 505         }
 506 
 507         // Only allocate the array if there are enough bytes available.
 508         // This only works for ByteArrayInputStream.
 509         // The assignment below ensures that buffer has the required type.
 510         ByteArrayInputStream arrayInput = buffer;
 511         if (arrayInput.available() &lt; length) {
 512             throw new IOException(&quot;short read on DerValue buffer&quot;);
 513         }
 514         byte[] bytes = new byte[length];
 515         arrayInput.read(bytes);
 516 
 517         if (isConstructed()) {
 518             DerInputStream in = new DerInputStream(bytes, 0, bytes.length,
 519                 buffer.allowBER);
 520             bytes = null;
 521             while (in.available() != 0) {
 522                 bytes = append(bytes, in.getOctetString());
 523             }
 524         }
 525         return bytes;
 526     }
 527 
 528     /**
 529      * Returns an ASN.1 INTEGER value as an integer.
 530      *
 531      * @return the integer held in this DER value.
 532      */
 533     public int getInteger() throws IOException {
 534         if (tag != tag_Integer) {
 535             throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);
 536         }
 537         return buffer.getInteger(data.available());
 538     }
 539 
 540     /**
 541      * Returns an ASN.1 INTEGER value as a BigInteger.
 542      *
 543      * @return the integer held in this DER value as a BigInteger.
 544      */
 545     public BigInteger getBigInteger() throws IOException {
 546         if (tag != tag_Integer)
 547             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
 548         return buffer.getBigInteger(data.available(), false);
 549     }
 550 
 551     /**
 552      * Returns an ASN.1 INTEGER value as a positive BigInteger.
 553      * This is just to deal with implementations that incorrectly encode
 554      * some values as negative.
 555      *
 556      * @return the integer held in this DER value as a BigInteger.
 557      */
 558     public BigInteger getPositiveBigInteger() throws IOException {
 559         if (tag != tag_Integer)
 560             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
 561         return buffer.getBigInteger(data.available(), true);
 562     }
 563 
 564     /**
 565      * Returns an ASN.1 ENUMERATED value.
 566      *
 567      * @return the integer held in this DER value.
 568      */
 569     public int getEnumerated() throws IOException {
 570         if (tag != tag_Enumerated) {
 571             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
 572                                   + tag);
 573         }
 574         return buffer.getInteger(data.available());
 575     }
 576 
 577     /**
 578      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
 579      *
 580      * @return the bit string held in this value
 581      */
 582     public byte[] getBitString() throws IOException {
 583         if (tag != tag_BitString)
 584             throw new IOException(
 585                 &quot;DerValue.getBitString, not a bit string &quot; + tag);
 586 
 587         return buffer.getBitString();
 588     }
 589 
 590     /**
 591      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
 592      *
 593      * @return a BitArray representing the bit string held in this value
 594      */
 595     public BitArray getUnalignedBitString() throws IOException {
 596         if (tag != tag_BitString)
 597             throw new IOException(
 598                 &quot;DerValue.getBitString, not a bit string &quot; + tag);
 599 
 600         return buffer.getUnalignedBitString();
 601     }
 602 
 603     /**
 604      * Returns the name component as a Java string, regardless of its
 605      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
 606      */
 607     // TBD: Need encoder for UniversalString before it can be handled.
 608     public String getAsString() throws IOException {
 609         if (tag == tag_UTF8String)
 610             return getUTF8String();
 611         else if (tag == tag_PrintableString)
 612             return getPrintableString();
 613         else if (tag == tag_T61String)
 614             return getT61String();
 615         else if (tag == tag_IA5String)
 616             return getIA5String();
 617         /*
 618           else if (tag == tag_UniversalString)
 619           return getUniversalString();
 620         */
 621         else if (tag == tag_BMPString)
 622             return getBMPString();
 623         else if (tag == tag_GeneralString)
 624             return getGeneralString();
 625         else
 626             return null;
 627     }
 628 
 629     public DerValue[] getSubs(byte type) throws IOException {
 630         if (tag != type) {
 631             throw new IOException(&quot;Unexpected tag: &quot; + tag);
 632         }
 633         List&lt;DerValue&gt; result = new ArrayList&lt;&gt;();
 634         while (data.available() &gt; 0) {
 635             result.add(data.getDerValue());
 636         }
 637         return result.toArray(new DerValue[result.size()]);
 638     }
 639 
 640     /**
 641      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 642      * based on the parameter.  The bit string must be byte-aligned.
 643      *
 644      * @param tagImplicit if true, the tag is assumed implicit.
 645      * @return the bit string held in this value
 646      */
 647     public byte[] getBitString(boolean tagImplicit) throws IOException {
 648         if (!tagImplicit) {
 649             if (tag != tag_BitString)
 650                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
 651                                        + tag);
 652             }
 653         return buffer.getBitString();
 654     }
 655 
 656     /**
 657      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 658      * based on the parameter.  The bit string need not be byte-aligned.
 659      *
 660      * @param tagImplicit if true, the tag is assumed implicit.
 661      * @return the bit string held in this value
 662      */
 663     public BitArray getUnalignedBitString(boolean tagImplicit)
 664     throws IOException {
 665         if (!tagImplicit) {
 666             if (tag != tag_BitString)
 667                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
 668                                        + tag);
 669             }
 670         return buffer.getUnalignedBitString();
 671     }
 672 
 673     /**
 674      * Helper routine to return all the bytes contained in the
 675      * DerInputStream associated with this object.
 676      */
 677     public byte[] getDataBytes() throws IOException {
 678         byte[] retVal = new byte[length];
 679         synchronized (data) {
 680             data.reset();
 681             data.getBytes(retVal);
 682         }
 683         return retVal;
 684     }
 685 
 686     /**
 687      * Returns an ASN.1 STRING value
 688      *
 689      * @return the printable string held in this value
 690      */
 691     public String getPrintableString()
 692     throws IOException {
 693         if (tag != tag_PrintableString)
 694             throw new IOException(
 695                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
 696 
 697         return new String(getDataBytes(), US_ASCII);
 698     }
 699 
 700     /**
 701      * Returns an ASN.1 T61 (Teletype) STRING value
 702      *
 703      * @return the teletype string held in this value
 704      */
 705     public String getT61String() throws IOException {
 706         if (tag != tag_T61String)
 707             throw new IOException(
 708                 &quot;DerValue.getT61String, not T61 &quot; + tag);
 709 
 710         return new String(getDataBytes(), ISO_8859_1);
 711     }
 712 
 713     /**
 714      * Returns an ASN.1 IA5 (ASCII) STRING value
 715      *
 716      * @return the ASCII string held in this value
 717      */
 718     public String getIA5String() throws IOException {
 719         if (tag != tag_IA5String)
 720             throw new IOException(
 721                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
 722 
 723         return new String(getDataBytes(), US_ASCII);
 724     }
 725 
 726     /**
 727      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
 728      *
 729      * @return a string corresponding to the encoded BMPString held in
 730      * this value
 731      */
 732     public String getBMPString() throws IOException {
 733         if (tag != tag_BMPString)
 734             throw new IOException(
 735                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
 736 
 737         // BMPString is the same as Unicode in big endian, unmarked
 738         // format.
 739         return new String(getDataBytes(), UTF_16BE);
 740     }
 741 
 742     /**
 743      * Returns the ASN.1 UTF-8 STRING value as a Java String.
 744      *
 745      * @return a string corresponding to the encoded UTF8String held in
 746      * this value
 747      */
 748     public String getUTF8String() throws IOException {
 749         if (tag != tag_UTF8String)
 750             throw new IOException(
 751                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
 752 
 753         return new String(getDataBytes(), UTF_8);
 754     }
 755 
 756     /**
 757      * Returns the ASN.1 GENERAL STRING value as a Java String.
 758      *
 759      * @return a string corresponding to the encoded GeneralString held in
 760      * this value
 761      */
 762     public String getGeneralString() throws IOException {
 763         if (tag != tag_GeneralString)
 764             throw new IOException(
 765                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
 766 
 767         return new String(getDataBytes(), US_ASCII);
 768     }
 769 
 770     /**
 771      * Returns a Date if the DerValue is UtcTime.
 772      *
 773      * @return the Date held in this DER value
 774      */
 775     public Date getUTCTime() throws IOException {
 776         if (tag != tag_UtcTime) {
 777             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
 778         }
 779         return buffer.getUTCTime(data.available());
 780     }
 781 
 782     /**
 783      * Returns a Date if the DerValue is GeneralizedTime.
 784      *
 785      * @return the Date held in this DER value
 786      */
 787     public Date getGeneralizedTime() throws IOException {
 788         if (tag != tag_GeneralizedTime) {
 789             throw new IOException(
 790                 &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
 791         }
 792         return buffer.getGeneralizedTime(data.available());
 793     }
 794 
 795     /**
 796      * Bitwise equality comparison.  DER encoded values have a single
 797      * encoding, so that bitwise equality of the encoded values is an
 798      * efficient way to establish equivalence of the unencoded values.
 799      *
 800      * @param o the object being compared with this one
 801      */
 802     @Override
 803     public boolean equals(Object o) {
 804         if (this == o) {
 805             return true;
 806         }
 807         if (!(o instanceof DerValue)) {
 808             return false;
 809         }
 810         DerValue other = (DerValue) o;
 811         if (tag != other.tag) {
 812             return false;
 813         }
 814         if (data == other.data) {
 815             return true;
 816         }
 817 
 818         // make sure the order of lock is always consistent to avoid a deadlock
 819         return (System.identityHashCode(this.data)
 820                 &gt; System.identityHashCode(other.data)) ?
 821                 doEquals(this, other):
 822                 doEquals(other, this);
 823     }
 824 
 825     /**
 826      * Helper for public method equals()
 827      */
 828     private static boolean doEquals(DerValue d1, DerValue d2) {
 829         synchronized (d1.data) {
 830             synchronized (d2.data) {
 831                 d1.data.reset();
 832                 d2.data.reset();
 833                 return d1.buffer.equals(d2.buffer);
 834             }
 835         }
 836     }
 837 
 838     /**
 839      * Returns a printable representation of the value.
 840      *
 841      * @return printable representation of the value
 842      */
 843     @Override
 844     public String toString() {
 845         try {
 846 
 847             String str = getAsString();
 848             if (str != null)
 849                 return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
 850             if (tag == tag_Null)
 851                 return &quot;[DerValue, null]&quot;;
 852             if (tag == tag_ObjectId)
 853                 return &quot;OID.&quot; + getOID();
 854 
 855             // integers
 856             else
 857                 return &quot;[DerValue, tag = &quot; + tag
 858                         + &quot;, length = &quot; + length + &quot;]&quot;;
 859         } catch (IOException e) {
 860             throw new IllegalArgumentException(&quot;misformatted DER value&quot;);
 861         }
 862     }
 863 
 864     /**
 865      * Returns a DER-encoded value, such that if it&#39;s passed to the
 866      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
 867      *
 868      * @return DER-encoded value, including tag and length.
 869      */
 870     public byte[] toByteArray() throws IOException {
 871         DerOutputStream out = new DerOutputStream();
 872 
 873         encode(out);
 874         data.reset();
 875         return out.toByteArray();
 876     }
 877 
 878     /**
 879      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
 880      * to return a DER stream of the members of the set or sequence.
 881      * This operation is not supported for primitive types such as
 882      * integers or bit strings.
 883      */
 884     public DerInputStream toDerInputStream() throws IOException {
 885         if (tag == tag_Sequence || tag == tag_Set)
 886             return new DerInputStream(buffer);
 887         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
 888     }
 889 
 890     /**
 891      * Get the length of the encoded value.
 892      */
 893     public int length() {
 894         return length;
 895     }
 896 
 897     /**
 898      * Determine if a character is one of the permissible characters for
 899      * PrintableString:
 900      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
 901      * plus sign, comma, hyphen, period, slash, colon, equals sign,
 902      * and question mark.
 903      *
 904      * Characters that are *not* allowed in PrintableString include
 905      * exclamation point, quotation mark, number sign, dollar sign,
 906      * percent sign, ampersand, asterisk, semicolon, less than sign,
 907      * greater than sign, at sign, left and right square brackets,
 908      * backslash, circumflex (94), underscore, back quote (96),
 909      * left and right curly brackets, vertical line, tilde,
 910      * and the control codes (0-31 and 127).
 911      *
 912      * This list is based on X.680 (the ASN.1 spec).
 913      */
 914     public static boolean isPrintableStringChar(char ch) {
 915         if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
 916             (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
 917             return true;
 918         } else {
 919             switch (ch) {
 920                 case &#39; &#39;:       /* space */
 921                 case &#39;\&#39;&#39;:      /* apostrophe */
 922                 case &#39;(&#39;:       /* left paren */
 923                 case &#39;)&#39;:       /* right paren */
 924                 case &#39;+&#39;:       /* plus */
 925                 case &#39;,&#39;:       /* comma */
 926                 case &#39;-&#39;:       /* hyphen */
 927                 case &#39;.&#39;:       /* period */
 928                 case &#39;/&#39;:       /* slash */
 929                 case &#39;:&#39;:       /* colon */
 930                 case &#39;=&#39;:       /* equals */
 931                 case &#39;?&#39;:       /* question mark */
 932                     return true;
 933                 default:
 934                     return false;
 935             }
 936         }
 937     }
 938 
 939     /**
 940      * Create the tag of the attribute.
 941      *
 942      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
 943      *               APPLICATION or PRIVATE
 944      * @param form if true, the value is constructed, otherwise it
 945      * is primitive.
 946      * @param val the tag value
 947      */
 948     public static byte createTag(byte tagClass, boolean form, byte val) {
 949         byte tag = (byte)(tagClass | val);
 950         if (form) {
 951             tag |= (byte)0x20;
 952         }
 953         return (tag);
 954     }
 955 
 956     /**
 957      * Set the tag of the attribute. Commonly used to reset the
 958      * tag value used for IMPLICIT encodings.
 959      *
 960      * @param tag the tag value
 961      */
 962     public void resetTag(byte tag) {
 963         this.tag = tag;
 964     }
 965 
 966     /**
 967      * Returns a hashcode for this DerValue.
 968      *
 969      * @return a hashcode for this DerValue.
 970      */
 971     @Override
 972     public int hashCode() {
 973         return toString().hashCode();
 974     }
 975 
 976     /**
 977      * Dump the content of this DerValue into stdout, decomposing the
 978      * structire in a hierachical style.
 979      *
 980      * Note: might not be good at deal with IMPLICIT context-specific values
 981      * because it has no hint on the original tag.
 982      *
 983      * Note: might not work correctly for some types of data if the data
 984      * inside has been read before. Also, after calling print(), the data
 985      * inside might be read and subsequent reading on some type of data.
 986      *
 987      * @param into if true, try to treat OCTET STRING as another DerValue.
 988      * @throws IOException if an I/O error occurs.
 989      */
 990     public void print(boolean into) throws IOException {
 991         v0(&quot;&quot;, 0, this, into);
 992     }
 993 
 994     private static void v0(String indent, int offset, DerValue v, boolean into)
 995             throws IOException {
 996         String label = String.format(&quot;%04x:%04x [%s]   &quot;,
 997                 offset, 1 + v.llen + v.length, indent);
 998         String value = switch (v.tag) {
 999             case DerValue.tag_Null -&gt; &quot;NULL&quot;;
1000             case DerValue.tag_OctetString -&gt; v.getOctetString().length + &quot; bytes&quot;;
1001             case DerValue.tag_BitString -&gt; v.getUnalignedBitString().length() + &quot; bits&quot;;
1002             case DerValue.tag_Integer -&gt; &quot;int &quot; + v.getBigInteger();
1003             case DerValue.tag_Boolean -&gt; Boolean.toString(v.getBoolean());
1004             case DerValue.tag_GeneralizedTime -&gt; v.getGeneralizedTime().toString();
1005             case DerValue.tag_UtcTime -&gt; v.getUTCTime().toString();
1006             case DerValue.tag_ObjectId -&gt; {
1007                 String s = v.getOID().toString();
1008                 KnownOIDs k = KnownOIDs.findMatch(s);
1009                 yield &quot;OID &quot; + s + (k != null ? (&quot; (&quot; + k.stdName() + &quot;)&quot;) : &quot;&quot;);
1010             }
1011             default -&gt; {
1012                 String s = v.getAsString();
1013                 yield s == null ? null : (&#39;&quot;&#39; + s + &#39;&quot;&#39;);
1014             }
1015         };
1016         if (value != null) {
1017             System.out.println(label + value);
1018             if (v.tag == DerValue.tag_OctetString &amp;&amp; into) {
1019                 try {
1020                     v.buffer.reset();
1021                     DerValue v2 = new DerValue(v.getOctetString());
1022                     v0(indent + &quot;=&quot;, 0, v2, into);
1023                 } catch (IOException e) {
1024                     //
1025                 }
1026             }
1027         } else if (v.isConstructed()) {
1028             String type = &quot;sub&quot;;
1029             if (v.isContextSpecific()) {
1030                 type = &quot;[&quot; + (v.tag &amp; 0x1f) + &quot;]&quot;;
1031             } else if (v.isApplication()) {
1032                 type = &quot;[APPLICATION &quot; + (v.tag &amp; 0x1f) + &quot;]&quot;;
1033             } else if (v.tag == DerValue.tag_Sequence) {
1034                 type = &quot;SEQUENCE&quot;;
1035             } else if (v.tag == DerValue.tag_Set) {
1036                 type = &quot;SET&quot;;
1037             }
1038             System.out.println(label + type);
1039             int pos = 0;
1040             offset += 1 + v.llen;
1041             for (var vv : v.getSubs(v.tag)) {
1042                 v0(indent + pos++, offset, vv, into);
1043                 offset += vv.length + vv.llen + 1;
1044             }
1045         } else {
1046             System.out.println(label + v);
1047         }
1048     }
1049 }
    </pre>
  </body>
</html>
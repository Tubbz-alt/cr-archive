diff a/src/java.base/share/classes/sun/security/util/DerValue.java b/src/java.base/share/classes/sun/security/util/DerValue.java
--- a/src/java.base/share/classes/sun/security/util/DerValue.java
+++ b/src/java.base/share/classes/sun/security/util/DerValue.java
@@ -26,11 +26,13 @@
 package sun.security.util;
 
 import java.io.*;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
  * Represents a single DER-encoded value.  DER encoding rules are a subset
@@ -255,10 +257,11 @@
 
         // XXX must also parse BER-encoded constructed
         // values such as sequences, sets...
         tag = (byte)in.read();
         byte lenByte = (byte)in.read();
+        llen = lenlen(lenByte);
         length = DerInputStream.getLength(lenByte, in);
         if (length == -1) {  // indefinite length encoding found
             DerInputBuffer inbuf = in.dup();
             inbuf = new DerInputBuffer(
                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
@@ -372,19 +375,24 @@
         DerInputStream result = new DerInputStream(buffer);
         result.mark(Integer.MAX_VALUE);
         return result;
     }
 
+    int llen = 0;
+
     /*
      * helper routine
      */
     private DerInputStream init(boolean fullyBuffered, InputStream in,
         boolean allowBER) throws IOException {
 
         tag = (byte)in.read();
         byte lenByte = (byte)in.read();
+
+        llen = lenlen(lenByte);
         length = DerInputStream.getLength(lenByte, in);
+
         if (length == -1) { // indefinite length encoding found
             in = new ByteArrayInputStream(
                     DerIndefLenConverter.convertStream(in, lenByte, tag));
             if (tag != in.read())
                 throw new IOException
@@ -399,10 +407,18 @@
 
         buffer = new DerInputBuffer(bytes, allowBER);
         return new DerInputStream(buffer);
     }
 
+    private int lenlen(byte lenByte) {
+        if ((lenByte & 0x080) == 0x00) { // short form, 1 byte datum
+            return 1;
+        } else {                     // long form or indefinite
+            return 1 + (lenByte & 0x7f);
+        }
+    }
+
     /**
      * Encode an ASN1/DER encoded datum onto a DER output stream.
      */
     public void encode(DerOutputStream out)
     throws IOException {
@@ -608,10 +624,21 @@
             return getGeneralString();
         else
             return null;
     }
 
+    public DerValue[] getSubs(byte type) throws IOException {
+        if (tag != type) {
+            throw new IOException("Unexpected tag: " + tag);
+        }
+        List<DerValue> result = new ArrayList<>();
+        while (data.available() > 0) {
+            result.add(data.getDerValue());
+        }
+        return result.toArray(new DerValue[result.size()]);
+    }
+
     /**
      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
      * based on the parameter.  The bit string must be byte-aligned.
      *
      * @param tagImplicit if true, the tag is assumed implicit.
@@ -943,6 +970,80 @@
      */
     @Override
     public int hashCode() {
         return toString().hashCode();
     }
+
+    /**
+     * Dump the content of this DerValue into stdout, decomposing the
+     * structire in a hierachical style.
+     *
+     * Note: might not be good at deal with IMPLICIT context-specific values
+     * because it has no hint on the original tag.
+     *
+     * Note: might not work correctly for some types of data if the data
+     * inside has been read before. Also, after calling print(), the data
+     * inside might be read and subsequent reading on some type of data.
+     *
+     * @param into if true, try to treat OCTET STRING as another DerValue.
+     * @throws IOException if an I/O error occurs.
+     */
+    public void print(boolean into) throws IOException {
+        v0("", 0, this, into);
+    }
+
+    private static void v0(String indent, int offset, DerValue v, boolean into)
+            throws IOException {
+        String label = String.format("%04x:%04x [%s]   ",
+                offset, 1 + v.llen + v.length, indent);
+        String value = switch (v.tag) {
+            case DerValue.tag_Null -> "NULL";
+            case DerValue.tag_OctetString -> v.getOctetString().length + " bytes";
+            case DerValue.tag_BitString -> v.getUnalignedBitString().length() + " bits";
+            case DerValue.tag_Integer -> "int " + v.getBigInteger();
+            case DerValue.tag_Boolean -> Boolean.toString(v.getBoolean());
+            case DerValue.tag_GeneralizedTime -> v.getGeneralizedTime().toString();
+            case DerValue.tag_UtcTime -> v.getUTCTime().toString();
+            case DerValue.tag_ObjectId -> {
+                String s = v.getOID().toString();
+                KnownOIDs k = KnownOIDs.findMatch(s);
+                yield "OID " + s + (k != null ? (" (" + k.stdName() + ")") : "");
+            }
+            default -> {
+                String s = v.getAsString();
+                yield s == null ? null : ('"' + s + '"');
+            }
+        };
+        if (value != null) {
+            System.out.println(label + value);
+            if (v.tag == DerValue.tag_OctetString && into) {
+                try {
+                    v.buffer.reset();
+                    DerValue v2 = new DerValue(v.getOctetString());
+                    v0(indent + "=", 0, v2, into);
+                } catch (IOException e) {
+                    //
+                }
+            }
+        } else if (v.isConstructed()) {
+            String type = "sub";
+            if (v.isContextSpecific()) {
+                type = "[" + (v.tag & 0x1f) + "]";
+            } else if (v.isApplication()) {
+                type = "[APPLICATION " + (v.tag & 0x1f) + "]";
+            } else if (v.tag == DerValue.tag_Sequence) {
+                type = "SEQUENCE";
+            } else if (v.tag == DerValue.tag_Set) {
+                type = "SET";
+            }
+            System.out.println(label + type);
+            int pos = 0;
+            offset += 1 + v.llen;
+            for (var vv : v.getSubs(v.tag)) {
+                v0(indent + pos++, offset, vv, into);
+                offset += vv.length + vv.llen + 1;
+            }
+        } else {
+            System.out.println(label + v);
+        }
+    }
 }

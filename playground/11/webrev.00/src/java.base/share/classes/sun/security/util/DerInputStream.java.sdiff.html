<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerInputBuffer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerValue.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.math.BigInteger;
 31 import java.nio.charset.Charset;
 32 import java.util.Date;

 33 import java.util.Vector;

 34 
 35 import static java.nio.charset.StandardCharsets.*;
 36 
 37 /**
 38  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 39  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 40  * the advantage that it allows only a single encoding of primitive data.
 41  * (High level data such as dates still support many encodings.)  That is,
 42  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 43  *
 44  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 45  * tagged data values.  Accordingly, this programming interface does
 46  * not expose any variant of the java.io.InputStream interface, since
 47  * that kind of input stream holds untagged data values and using that
 48  * I/O model could prevent correct parsing of the DER data.
 49  *
 50  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 51  * data encodings which are defined.  That subset is sufficient for parsing
 52  * most X.509 certificates.
 53  *
</pre>
<hr />
<pre>
302         return retval;
303     }
304 
305     /**
306      * Returns the asked number of bytes from the input stream.
307      */
308     public void getBytes(byte[] val) throws IOException {
309         if ((val.length != 0) &amp;&amp; (buffer.read(val) != val.length)) {
310             throw new IOException(&quot;Short read of DER octet string&quot;);
311         }
312     }
313 
314     /**
315      * Reads an encoded null value from the input stream.
316      */
317     public void getNull() throws IOException {
318         if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)
319             throw new IOException(&quot;getNull, bad data&quot;);
320     }
321 










322     /**
323      * Reads an X.200 style Object Identifier from the stream.
324      */
325     public ObjectIdentifier getOID() throws IOException {
326         return new ObjectIdentifier(this);
327     }
328 
329     /**
330      * Return a sequence of encoded entities.  ASN.1 sequences are
331      * ordered, and they are often used, like a &quot;struct&quot; in C or C++,
332      * to group data values.  They may have optional or context
333      * specific values.
334      *
335      * @param startLen guess about how long the sequence will be
336      *          (used to initialize an auto-growing data structure)
337      * @return array of the values in the sequence
338      */
339     public DerValue[] getSequence(int startLen) throws IOException {
340         tag = (byte)buffer.read();
341         if (tag != DerValue.tag_Sequence)
</pre>
<hr />
<pre>
510      * @param stringName a name to display in error messages
511      * @param enc the encoder to use to interpret the data. Should
512      * correspond to the stringTag above.
513      */
514     private String readString(byte stringTag, String stringName,
515                               Charset charset) throws IOException {
516 
517         if (buffer.read() != stringTag)
518             throw new IOException(&quot;DER input not a &quot; +
519                                   stringName + &quot; string&quot;);
520 
521         int length = getDefiniteLength(buffer);
522         byte[] retval = new byte[length];
523         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))
524             throw new IOException(&quot;Short read of DER &quot; +
525                                   stringName + &quot; string&quot;);
526 
527         return new String(retval, charset);
528     }
529 











530     /**
531      * Get a UTC encoded time value from the input stream.
532      */
533     public Date getUTCTime() throws IOException {
534         if (buffer.read() != DerValue.tag_UtcTime)
535             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);
536         return buffer.getUTCTime(getDefiniteLength(buffer));
537     }
538 
539     /**
540      * Get a Generalized encoded time value from the input stream.
541      */
542     public Date getGeneralizedTime() throws IOException {
543         if (buffer.read() != DerValue.tag_GeneralizedTime)
544             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);
545         return buffer.getGeneralizedTime(getDefiniteLength(buffer));
546     }
547 
548     /*
549      * Get a byte from the input stream.
</pre>
<hr />
<pre>
644      * Mark the current position in the buffer, so that
645      * a later call to &lt;code&gt;reset&lt;/code&gt; will return here.
646      */
647     public void mark(int value) { buffer.mark(value); }
648 
649 
650     /**
651      * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
652      * call.  A mark is implicitly set at the beginning of
653      * the stream when it is created.
654      */
655     public void reset() { buffer.reset(); }
656 
657 
658     /**
659      * Returns the number of bytes available for reading.
660      * This is most useful for testing whether the stream is
661      * empty.
662      */
663     public int available() { return buffer.available(); }


















































































































664 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.math.BigInteger;
 31 import java.nio.charset.Charset;
 32 import java.util.Date;
<span class="line-added"> 33 import java.util.Optional;</span>
 34 import java.util.Vector;
<span class="line-added"> 35 import java.util.function.Predicate;</span>
 36 
 37 import static java.nio.charset.StandardCharsets.*;
 38 
 39 /**
 40  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 41  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 42  * the advantage that it allows only a single encoding of primitive data.
 43  * (High level data such as dates still support many encodings.)  That is,
 44  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 45  *
 46  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 47  * tagged data values.  Accordingly, this programming interface does
 48  * not expose any variant of the java.io.InputStream interface, since
 49  * that kind of input stream holds untagged data values and using that
 50  * I/O model could prevent correct parsing of the DER data.
 51  *
 52  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 53  * data encodings which are defined.  That subset is sufficient for parsing
 54  * most X.509 certificates.
 55  *
</pre>
<hr />
<pre>
304         return retval;
305     }
306 
307     /**
308      * Returns the asked number of bytes from the input stream.
309      */
310     public void getBytes(byte[] val) throws IOException {
311         if ((val.length != 0) &amp;&amp; (buffer.read(val) != val.length)) {
312             throw new IOException(&quot;Short read of DER octet string&quot;);
313         }
314     }
315 
316     /**
317      * Reads an encoded null value from the input stream.
318      */
319     public void getNull() throws IOException {
320         if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)
321             throw new IOException(&quot;getNull, bad data&quot;);
322     }
323 
<span class="line-added">324     public boolean getBoolean() throws IOException {</span>
<span class="line-added">325         if (buffer.read() != DerValue.tag_Boolean || buffer.read() != 1)</span>
<span class="line-added">326             throw new IOException(&quot;getBoolean, bad data&quot;);</span>
<span class="line-added">327         int next = buffer.read();</span>
<span class="line-added">328         if (next == -1) {</span>
<span class="line-added">329             throw new IOException(&quot;Short read of DER Boolean&quot;);</span>
<span class="line-added">330         }</span>
<span class="line-added">331         return next != 0;</span>
<span class="line-added">332     }</span>
<span class="line-added">333 </span>
334     /**
335      * Reads an X.200 style Object Identifier from the stream.
336      */
337     public ObjectIdentifier getOID() throws IOException {
338         return new ObjectIdentifier(this);
339     }
340 
341     /**
342      * Return a sequence of encoded entities.  ASN.1 sequences are
343      * ordered, and they are often used, like a &quot;struct&quot; in C or C++,
344      * to group data values.  They may have optional or context
345      * specific values.
346      *
347      * @param startLen guess about how long the sequence will be
348      *          (used to initialize an auto-growing data structure)
349      * @return array of the values in the sequence
350      */
351     public DerValue[] getSequence(int startLen) throws IOException {
352         tag = (byte)buffer.read();
353         if (tag != DerValue.tag_Sequence)
</pre>
<hr />
<pre>
522      * @param stringName a name to display in error messages
523      * @param enc the encoder to use to interpret the data. Should
524      * correspond to the stringTag above.
525      */
526     private String readString(byte stringTag, String stringName,
527                               Charset charset) throws IOException {
528 
529         if (buffer.read() != stringTag)
530             throw new IOException(&quot;DER input not a &quot; +
531                                   stringName + &quot; string&quot;);
532 
533         int length = getDefiniteLength(buffer);
534         byte[] retval = new byte[length];
535         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))
536             throw new IOException(&quot;Short read of DER &quot; +
537                                   stringName + &quot; string&quot;);
538 
539         return new String(retval, charset);
540     }
541 
<span class="line-added">542     public Date getTime() throws IOException {</span>
<span class="line-added">543         int tag = buffer.read();</span>
<span class="line-added">544         if (tag == DerValue.tag_UtcTime) {</span>
<span class="line-added">545             return buffer.getUTCTime(getDefiniteLength(buffer));</span>
<span class="line-added">546         } else if (tag == DerValue.tag_GeneralizedTime) {</span>
<span class="line-added">547             return buffer.getGeneralizedTime(getDefiniteLength(buffer));</span>
<span class="line-added">548         } else {</span>
<span class="line-added">549             throw new IOException(&quot;Not a time value &quot; + tag);</span>
<span class="line-added">550         }</span>
<span class="line-added">551     }</span>
<span class="line-added">552 </span>
553     /**
554      * Get a UTC encoded time value from the input stream.
555      */
556     public Date getUTCTime() throws IOException {
557         if (buffer.read() != DerValue.tag_UtcTime)
558             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);
559         return buffer.getUTCTime(getDefiniteLength(buffer));
560     }
561 
562     /**
563      * Get a Generalized encoded time value from the input stream.
564      */
565     public Date getGeneralizedTime() throws IOException {
566         if (buffer.read() != DerValue.tag_GeneralizedTime)
567             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);
568         return buffer.getGeneralizedTime(getDefiniteLength(buffer));
569     }
570 
571     /*
572      * Get a byte from the input stream.
</pre>
<hr />
<pre>
667      * Mark the current position in the buffer, so that
668      * a later call to &lt;code&gt;reset&lt;/code&gt; will return here.
669      */
670     public void mark(int value) { buffer.mark(value); }
671 
672 
673     /**
674      * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
675      * call.  A mark is implicitly set at the beginning of
676      * the stream when it is created.
677      */
678     public void reset() { buffer.reset(); }
679 
680 
681     /**
682      * Returns the number of bytes available for reading.
683      * This is most useful for testing whether the stream is
684      * empty.
685      */
686     public int available() { return buffer.available(); }
<span class="line-added">687 </span>
<span class="line-added">688     /**</span>
<span class="line-added">689      * Ensure there is no more data. This can be called when the last</span>
<span class="line-added">690      * expected field is parsed and we need to make sure no unread is left.</span>
<span class="line-added">691      */</span>
<span class="line-added">692     public void atEnd() throws IOException {</span>
<span class="line-added">693         if (available() != 0) {</span>
<span class="line-added">694             throw new IOException(&quot;Extra unused bytes&quot;);</span>
<span class="line-added">695         }</span>
<span class="line-added">696     }</span>
<span class="line-added">697 </span>
<span class="line-added">698     /**</span>
<span class="line-added">699      * Detect if the tag of the next DerValue in the stream matches the rule.</span>
<span class="line-added">700      *</span>
<span class="line-added">701      * Attention: tag is an integer casted from a byte. i.e. could be negative.</span>
<span class="line-added">702      *</span>
<span class="line-added">703      * @param rule the rule to check for the tag.</span>
<span class="line-added">704      * @return true if matches, false otherwise or stream is at end.</span>
<span class="line-added">705      * @throws IOException if an I/O error happens</span>
<span class="line-added">706      */</span>
<span class="line-added">707     public boolean seeOptional(Predicate&lt;Integer&gt; rule) throws IOException {</span>
<span class="line-added">708         return available() &gt; 0 &amp;&amp; rule.test(peekByte());</span>
<span class="line-added">709     }</span>
<span class="line-added">710 </span>
<span class="line-added">711     /**</span>
<span class="line-added">712      * Detect if the tag of the next DerValue in the stream is the specified.</span>
<span class="line-added">713      *</span>
<span class="line-added">714      * @param tag the expected tag</span>
<span class="line-added">715      * @return true if is, false otherwise or stream is at end.</span>
<span class="line-added">716      * @throws IOException if an I/O error happens</span>
<span class="line-added">717      */</span>
<span class="line-added">718     public boolean seeOptional(byte tag) throws IOException {</span>
<span class="line-added">719         return seeOptional(t -&gt; t == (tag &amp; 0xff));</span>
<span class="line-added">720     }</span>
<span class="line-added">721 </span>
<span class="line-added">722     /**</span>
<span class="line-added">723      * Returns the inner DerValue if the next DerValue in the stream is</span>
<span class="line-added">724      * an EXPLICIT context-specific value tagged by {@code n}.</span>
<span class="line-added">725      *</span>
<span class="line-added">726      * @param n the expected tag</span>
<span class="line-added">727      * @return the inner DerValue, or empty if not found or stream at end</span>
<span class="line-added">728      * @throws IOException if an I/O error happens</span>
<span class="line-added">729      */</span>
<span class="line-added">730     public Optional&lt;DerValue&gt; getOptionalExplicitContextSpecific(int n)</span>
<span class="line-added">731             throws IOException {</span>
<span class="line-added">732         if (seeOptionalContextSpecific(n)) {</span>
<span class="line-added">733             DerValue v = getDerValue(); // [n]</span>
<span class="line-added">734             DerValue sub = v.data.getDerValue(); // inside [n]</span>
<span class="line-added">735             v.data.atEnd(); // make sure there is only one inner value</span>
<span class="line-added">736             return Optional.of(sub);</span>
<span class="line-added">737         } else {</span>
<span class="line-added">738             return Optional.empty();</span>
<span class="line-added">739         }</span>
<span class="line-added">740     }</span>
<span class="line-added">741 </span>
<span class="line-added">742     /**</span>
<span class="line-added">743      * Returns the restored DerValue if the next DerValue in the stream is</span>
<span class="line-added">744      * an IMPLICIT context-specific value tagged by {@code n}.</span>
<span class="line-added">745      *</span>
<span class="line-added">746      * @param n the expected tag</span>
<span class="line-added">747      * @param tag the real tag for the IMPLICIT type</span>
<span class="line-added">748      * @return the restored DerValue, or empty if not found or stream at end</span>
<span class="line-added">749      * @throws IOException if an I/O error happens</span>
<span class="line-added">750      */</span>
<span class="line-added">751     public Optional&lt;DerValue&gt; getOptionalImplicitContextSpecific(int n, byte tag)</span>
<span class="line-added">752             throws IOException {</span>
<span class="line-added">753         if (seeOptionalContextSpecific(n)) {</span>
<span class="line-added">754             DerValue v = getDerValue(); // [n]</span>
<span class="line-added">755             v.resetTag(tag); // restore tag because IMPLICIT has overwritten it</span>
<span class="line-added">756             return Optional.of(v);</span>
<span class="line-added">757         } else {</span>
<span class="line-added">758             return Optional.empty();</span>
<span class="line-added">759         }</span>
<span class="line-added">760     }</span>
<span class="line-added">761 </span>
<span class="line-added">762     /**</span>
<span class="line-added">763      * Detect if the next DerValue in the stream is a context-specific value</span>
<span class="line-added">764      * tagged by {@code n}.</span>
<span class="line-added">765      *</span>
<span class="line-added">766      * @param n the expected tag</span>
<span class="line-added">767      * @return true if is, false otherwise or stream is at end.</span>
<span class="line-added">768      * @throws IOException if an I/O error happens</span>
<span class="line-added">769      */</span>
<span class="line-added">770     public boolean seeOptionalContextSpecific(int n) throws IOException {</span>
<span class="line-added">771         return seeOptional(t -&gt; (t &amp; 0x0c0) == 0x080 &amp;&amp; (t &amp; 0x01f) == n);</span>
<span class="line-added">772     }</span>
<span class="line-added">773 </span>
<span class="line-added">774     /**</span>
<span class="line-added">775      * Skip the next DerValue in the stream. Indefinite length DerValue</span>
<span class="line-added">776      * is supported.</span>
<span class="line-added">777      *</span>
<span class="line-added">778      * @throws IOException if an I/O error happens</span>
<span class="line-added">779      */</span>
<span class="line-added">780     public void skipDerValue() throws IOException {</span>
<span class="line-added">781         int unresolved = 0;</span>
<span class="line-added">782         while (true) {</span>
<span class="line-added">783             tag = (byte) buffer.read();</span>
<span class="line-added">784             byte lenByte = (byte) buffer.read();</span>
<span class="line-added">785             int length = DerInputStream.getLength(lenByte, buffer);</span>
<span class="line-added">786             if (tag == 0) { // EOC</span>
<span class="line-added">787                 unresolved--;</span>
<span class="line-added">788                 if (unresolved &lt; 0 || length != 0) {</span>
<span class="line-added">789                     throw new IOException(&quot;Expected EOC&quot;);</span>
<span class="line-added">790                 }</span>
<span class="line-added">791             } else if (length == -1) {</span>
<span class="line-added">792                 unresolved++;</span>
<span class="line-added">793             } else {</span>
<span class="line-added">794                 buffer.skip(length);</span>
<span class="line-added">795             }</span>
<span class="line-added">796             if (unresolved == 0) {</span>
<span class="line-added">797                 break;</span>
<span class="line-added">798             }</span>
<span class="line-added">799         }</span>
<span class="line-added">800     }</span>
801 }
</pre>
</td>
</tr>
</table>
<center><a href="DerInputBuffer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerValue.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/pkcs/SignerInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.pkcs;
 27 
 28 import java.io.OutputStream;
 29 import java.io.IOException;
 30 import java.math.BigInteger;
 31 import java.security.cert.CertPathValidatorException;
 32 import java.security.cert.CertificateException;
 33 import java.security.cert.CertificateFactory;
 34 import java.security.cert.CertPath;
 35 import java.security.cert.X509Certificate;
 36 import java.security.*;
 37 import java.util.ArrayList;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.EnumSet;
 41 import java.util.Set;
 42 
 43 import sun.security.timestamp.TimestampToken;
 44 import sun.security.util.ConstraintsParameters;
 45 import sun.security.util.Debug;
 46 import sun.security.util.DerEncoder;
 47 import sun.security.util.DerInputStream;
 48 import sun.security.util.DerOutputStream;
 49 import sun.security.util.DerValue;
 50 import sun.security.util.DisabledAlgorithmConstraints;
 51 import sun.security.util.HexDumpEncoder;
 52 import sun.security.util.KeyUtil;
 53 import sun.security.util.ObjectIdentifier;
 54 import sun.security.x509.AlgorithmId;
 55 import sun.security.x509.X500Name;
 56 import sun.security.x509.KeyUsageExtension;
 57 import sun.security.util.SignatureUtil;
 58 
 59 /**
 60  * A SignerInfo, as defined in PKCS#7&#39;s signedData type.
 61  *
 62  * @author Benjamin Renaud
 63  */
 64 public class SignerInfo implements DerEncoder {
 65 
 66     // Digest and Signature restrictions
 67     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET =
 68             Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 69 
 70     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET =
 71             Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 72 
 73     private static final DisabledAlgorithmConstraints JAR_DISABLED_CHECK =
 74             new DisabledAlgorithmConstraints(
 75                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 76 
 77     BigInteger version;
 78     X500Name issuerName;
 79     BigInteger certificateSerialNumber;
 80     AlgorithmId digestAlgorithmId;
 81     AlgorithmId digestEncryptionAlgorithmId;
 82     byte[] encryptedDigest;
 83     Timestamp timestamp;
 84     private boolean hasTimestamp = true;
 85     private static final Debug debug = Debug.getInstance(&quot;jar&quot;);
 86 
 87     PKCS9Attributes authenticatedAttributes;
 88     PKCS9Attributes unauthenticatedAttributes;
 89 
 90     public SignerInfo(X500Name  issuerName,
 91                       BigInteger serial,
 92                       AlgorithmId digestAlgorithmId,
 93                       AlgorithmId digestEncryptionAlgorithmId,
 94                       byte[] encryptedDigest) {
 95         this.version = BigInteger.ONE;
 96         this.issuerName = issuerName;
 97         this.certificateSerialNumber = serial;
 98         this.digestAlgorithmId = digestAlgorithmId;
 99         this.digestEncryptionAlgorithmId = digestEncryptionAlgorithmId;
100         this.encryptedDigest = encryptedDigest;
101     }
102 
103     public SignerInfo(X500Name  issuerName,
104                       BigInteger serial,
105                       AlgorithmId digestAlgorithmId,
106                       PKCS9Attributes authenticatedAttributes,
107                       AlgorithmId digestEncryptionAlgorithmId,
108                       byte[] encryptedDigest,
109                       PKCS9Attributes unauthenticatedAttributes) {
110         this.version = BigInteger.ONE;
111         this.issuerName = issuerName;
112         this.certificateSerialNumber = serial;
113         this.digestAlgorithmId = digestAlgorithmId;
114         this.authenticatedAttributes = authenticatedAttributes;
115         this.digestEncryptionAlgorithmId = digestEncryptionAlgorithmId;
116         this.encryptedDigest = encryptedDigest;
117         this.unauthenticatedAttributes = unauthenticatedAttributes;
118     }
119 
120     /**
121      * Parses a PKCS#7 signer info.
122      */
123     public SignerInfo(DerInputStream derin)
124         throws IOException, ParsingException
125     {
126         this(derin, false);
127     }
128 
129     /**
130      * Parses a PKCS#7 signer info.
131      *
132      * SignerInfo ::= SEQUENCE {
133      *         version CMSVersion,
134      *         sid SignerIdentifier,
135      *         digestAlgorithm DigestAlgorithmIdentifier,
136      *         signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
137      *         signatureAlgorithm SignatureAlgorithmIdentifier,
138      *         signature SignatureValue,
139      *         unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
140      *
141      * &lt;p&gt;This constructor is used only for backwards compatibility with
142      * PKCS#7 blocks that were generated using JDK1.1.x.
143      *
144      * @param derin the ASN.1 encoding of the signer info.
145      * @param oldStyle flag indicating whether or not the given signer info
146      * is encoded according to JDK1.1.x.
147      */
148     public SignerInfo(DerInputStream derin, boolean oldStyle)
149         throws IOException, ParsingException
150     {
151         // version
152         version = derin.getBigInteger();
153 
154         // issuerAndSerialNumber
155         DerValue[] issuerAndSerialNumber = derin.getSequence(2);
156         byte[] issuerBytes = issuerAndSerialNumber[0].toByteArray();
157         issuerName = new X500Name(new DerValue(DerValue.tag_Sequence,
158                                                issuerBytes));
159         certificateSerialNumber = issuerAndSerialNumber[1].getBigInteger();
160 
161         // digestAlgorithmId
162         DerValue tmp = derin.getDerValue();
163 
164         digestAlgorithmId = AlgorithmId.parse(tmp);
165 
166         // authenticatedAttributes
167         if (oldStyle) {
168             // In JDK1.1.x, the authenticatedAttributes are always present,
169             // encoded as an empty Set (Set of length zero)
170             derin.getSet(0);
171         } else {
172             // check if set of auth attributes (implicit tag) is provided
173             // (auth attributes are OPTIONAL)
174             if (derin.seeOptionalContextSpecific(0)) {
175                 authenticatedAttributes = new PKCS9Attributes(derin);
176             }
177         }
178 
179         // digestEncryptionAlgorithmId - little RSA naming scheme -
180         // signature == encryption...
181         tmp = derin.getDerValue();
182 
183         digestEncryptionAlgorithmId = AlgorithmId.parse(tmp);
184 
185         // encryptedDigest
186         encryptedDigest = derin.getOctetString();
187 
188         // unauthenticatedAttributes
189         if (oldStyle) {
190             // In JDK1.1.x, the unauthenticatedAttributes are always present,
191             // encoded as an empty Set (Set of length zero)
192             derin.getSet(0);
193         } else {
194             // check if set of unauth attributes (implicit tag) is provided
195             // (unauth attributes are OPTIONAL)
196             if (derin.seeOptionalContextSpecific(1)) {
197                 unauthenticatedAttributes =
198                     new PKCS9Attributes(derin, true);// ignore unsupported attrs
199             }
200         }
201 
202         // all done
203         if (derin.available() != 0) {
204             throw new ParsingException(&quot;extra data at the end&quot;);
205         }
206     }
207 
208     public void encode(DerOutputStream out) throws IOException {
209 
210         derEncode(out);
211     }
212 
213     /**
214      * DER encode this object onto an output stream.
215      * Implements the {@code DerEncoder} interface.
216      *
217      * @param out
218      * the output stream on which to write the DER encoding.
219      *
220      * @exception IOException on encoding error.
221      */
222     public void derEncode(OutputStream out) throws IOException {
223         DerOutputStream seq = new DerOutputStream();
224         seq.putInteger(version);
225         DerOutputStream issuerAndSerialNumber = new DerOutputStream();
226         issuerName.encode(issuerAndSerialNumber);
227         issuerAndSerialNumber.putInteger(certificateSerialNumber);
228         seq.write(DerValue.tag_Sequence, issuerAndSerialNumber);
229 
230         digestAlgorithmId.encode(seq);
231 
232         // encode authenticated attributes if there are any
233         if (authenticatedAttributes != null)
234             authenticatedAttributes.encode((byte)0xA0, seq);
235 
236         digestEncryptionAlgorithmId.encode(seq);
237 
238         seq.putOctetString(encryptedDigest);
239 
240         // encode unauthenticated attributes if there are any
241         if (unauthenticatedAttributes != null)
242             unauthenticatedAttributes.encode((byte)0xA1, seq);
243 
244         DerOutputStream tmp = new DerOutputStream();
245         tmp.write(DerValue.tag_Sequence, seq);
246 
247         out.write(tmp.toByteArray());
248     }
249 
250 
251 
252     /*
253      * Returns the (user) certificate pertaining to this SignerInfo.
254      */
255     public X509Certificate getCertificate(PKCS7 block)
256         throws IOException
257     {
258         return block.getCertificate(certificateSerialNumber, issuerName);
259     }
260 
261     /*
262      * Returns the certificate chain pertaining to this SignerInfo.
263      */
264     public ArrayList&lt;X509Certificate&gt; getCertificateChain(PKCS7 block)
265         throws IOException
266     {
267         X509Certificate userCert;
268         userCert = block.getCertificate(certificateSerialNumber, issuerName);
269         if (userCert == null)
270             return null;
271 
272         ArrayList&lt;X509Certificate&gt; certList = new ArrayList&lt;&gt;();
273         certList.add(userCert);
274 
275         X509Certificate[] pkcsCerts = block.getCertificates();
276         if (pkcsCerts == null
277             || userCert.getSubjectDN().equals(userCert.getIssuerDN())) {
278             return certList;
279         }
280 
281         Principal issuer = userCert.getIssuerDN();
282         int start = 0;
283         while (true) {
284             boolean match = false;
285             int i = start;
286             while (i &lt; pkcsCerts.length) {
287                 if (issuer.equals(pkcsCerts[i].getSubjectDN())) {
288                     // next cert in chain found
289                     certList.add(pkcsCerts[i]);
290                     // if selected cert is self-signed, we&#39;re done
291                     // constructing the chain
292                     if (pkcsCerts[i].getSubjectDN().equals(
293                                             pkcsCerts[i].getIssuerDN())) {
294                         start = pkcsCerts.length;
295                     } else {
296                         issuer = pkcsCerts[i].getIssuerDN();
297                         X509Certificate tmpCert = pkcsCerts[start];
298                         pkcsCerts[start] = pkcsCerts[i];
299                         pkcsCerts[i] = tmpCert;
300                         start++;
301                     }
302                     match = true;
303                     break;
304                 } else {
305                     i++;
306                 }
307             }
308             if (!match)
309                 break;
310         }
311 
312         return certList;
313     }
314 
315     /* Returns null if verify fails, this signerInfo if
316        verify succeeds. */
317     SignerInfo verify(PKCS7 block, byte[] data)
318     throws NoSuchAlgorithmException, SignatureException {
319 
320         try {
321 
322             ContentInfo content = block.getContentInfo();
323             if (data == null) {
324                 data = content.getContentBytes();
325             }
326 
327             Timestamp timestamp = null;
328             try {
329                 timestamp = getTimestamp();
330             } catch (Exception ignore) {
331             }
332 
333             ConstraintsParameters cparams =
334                     new ConstraintsParameters(timestamp);
335             String digestAlgname = getDigestAlgorithmId().getName();
336 
337             byte[] dataSigned;
338 
339             // if there are authenticate attributes, get the message
340             // digest and compare it with the digest of data
341             if (authenticatedAttributes == null) {
342                 dataSigned = data;
343             } else {
344 
345                 // first, check content type
346                 ObjectIdentifier contentType = (ObjectIdentifier)
347                        authenticatedAttributes.getAttributeValue(
348                          PKCS9Attribute.CONTENT_TYPE_OID);
349                 if (contentType == null ||
350                     !contentType.equals(content.contentType))
351                     return null;  // contentType does not match, bad SignerInfo
352 
353                 // now, check message digest
354                 byte[] messageDigest = (byte[])
355                     authenticatedAttributes.getAttributeValue(
356                          PKCS9Attribute.MESSAGE_DIGEST_OID);
357 
358                 if (messageDigest == null) // fail if there is no message digest
359                     return null;
360 
361                 // check that digest algorithm is not restricted
362                 try {
363                     JAR_DISABLED_CHECK.permits(digestAlgname, cparams);
364                 } catch (CertPathValidatorException e) {
365                     throw new SignatureException(e.getMessage(), e);
366                 }
367 
368                 MessageDigest md = MessageDigest.getInstance(digestAlgname);
369                 byte[] computedMessageDigest = md.digest(data);
370 
371                 if (messageDigest.length != computedMessageDigest.length)
372                     return null;
373                 for (int i = 0; i &lt; messageDigest.length; i++) {
374                     if (messageDigest[i] != computedMessageDigest[i])
375                         return null;
376                 }
377 
378                 // message digest attribute matched
379                 // digest of original data
380 
381                 // the data actually signed is the DER encoding of
382                 // the authenticated attributes (tagged with
383                 // the &quot;SET OF&quot; tag, not 0xA0).
384                 dataSigned = authenticatedAttributes.getDerEncoding();
385             }
386 
387             // put together digest algorithm and encryption algorithm
388             // to form signing algorithm
389             String encryptionAlgname =
390                 getDigestEncryptionAlgorithmId().getName();
391 
392             // Workaround: sometimes the encryptionAlgname is actually
393             // a signature name
394             String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgname);
395             if (tmp != null) encryptionAlgname = tmp;
396             String algname = AlgorithmId.makeSigAlg(
397                     digestAlgname, encryptionAlgname);
398 
399             // check that jar signature algorithm is not restricted
400             try {
401                 JAR_DISABLED_CHECK.permits(algname, cparams);
402             } catch (CertPathValidatorException e) {
403                 throw new SignatureException(e.getMessage(), e);
404             }
405 
406             X509Certificate cert = getCertificate(block);
407             if (cert == null) {
408                 return null;
409             }
410             PublicKey key = cert.getPublicKey();
411 
412             // check if the public key is restricted
413             if (!JAR_DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
414                 throw new SignatureException(&quot;Public key check failed. &quot; +
415                         &quot;Disabled key used: &quot; +
416                         KeyUtil.getKeySize(key) + &quot; bit &quot; +
417                         key.getAlgorithm());
418             }
419 
420             if (cert.hasUnsupportedCriticalExtension()) {
421                 throw new SignatureException(&quot;Certificate has unsupported &quot;
422                                              + &quot;critical extension(s)&quot;);
423             }
424 
425             // Make sure that if the usage of the key in the certificate is
426             // restricted, it can be used for digital signatures.
427             // XXX We may want to check for additional extensions in the
428             // future.
429             boolean[] keyUsageBits = cert.getKeyUsage();
430             if (keyUsageBits != null) {
431                 KeyUsageExtension keyUsage;
432                 try {
433                     // We don&#39;t care whether or not this extension was marked
434                     // critical in the certificate.
435                     // We&#39;re interested only in its value (i.e., the bits set)
436                     // and treat the extension as critical.
437                     keyUsage = new KeyUsageExtension(keyUsageBits);
438                 } catch (IOException ioe) {
439                     throw new SignatureException(&quot;Failed to parse keyUsage &quot;
440                                                  + &quot;extension&quot;);
441                 }
442 
443                 boolean digSigAllowed = keyUsage.get(
444                         KeyUsageExtension.DIGITAL_SIGNATURE).booleanValue();
445 
446                 boolean nonRepuAllowed = keyUsage.get(
447                         KeyUsageExtension.NON_REPUDIATION).booleanValue();
448 
449                 if (!digSigAllowed &amp;&amp; !nonRepuAllowed) {
450                     throw new SignatureException(&quot;Key usage restricted: &quot;
451                                                  + &quot;cannot be used for &quot;
452                                                  + &quot;digital signatures&quot;);
453                 }
454             }
455 
456             Signature sig = Signature.getInstance(algname);
457 
458             AlgorithmParameters ap =
459                 digestEncryptionAlgorithmId.getParameters();
460             try {
461                 SignatureUtil.initVerifyWithParam(sig, key,
462                     SignatureUtil.getParamSpec(algname, ap));
463             } catch (ProviderException | InvalidAlgorithmParameterException |
464                      InvalidKeyException e) {
465                 throw new SignatureException(e.getMessage(), e);
466             }
467 
468             sig.update(dataSigned);
469             if (sig.verify(encryptedDigest)) {
470                 return this;
471             }
472         } catch (IOException e) {
473             throw new SignatureException(&quot;IO error verifying signature:\n&quot; +
474                                          e.getMessage());
475         }
476         return null;
477     }
478 
479     /* Verify the content of the pkcs7 block. */
480     SignerInfo verify(PKCS7 block)
481         throws NoSuchAlgorithmException, SignatureException {
482         return verify(block, null);
483     }
484 
485     public BigInteger getVersion() {
486             return version;
487     }
488 
489     public X500Name getIssuerName() {
490         return issuerName;
491     }
492 
493     public BigInteger getCertificateSerialNumber() {
494         return certificateSerialNumber;
495     }
496 
497     public AlgorithmId getDigestAlgorithmId() {
498         return digestAlgorithmId;
499     }
500 
501     public PKCS9Attributes getAuthenticatedAttributes() {
502         return authenticatedAttributes;
503     }
504 
505     public AlgorithmId getDigestEncryptionAlgorithmId() {
506         return digestEncryptionAlgorithmId;
507     }
508 
509     public byte[] getEncryptedDigest() {
510         return encryptedDigest;
511     }
512 
513     public PKCS9Attributes getUnauthenticatedAttributes() {
514         return unauthenticatedAttributes;
515     }
516 
517     /**
518      * Returns the timestamp PKCS7 data unverified.
519      * @return a PKCS7 object
520      */
521     public PKCS7 getTsToken() throws IOException {
522         if (unauthenticatedAttributes == null) {
523             return null;
524         }
525         PKCS9Attribute tsTokenAttr =
526                 unauthenticatedAttributes.getAttribute(
527                         PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID);
528         if (tsTokenAttr == null) {
529             return null;
530         }
531         return new PKCS7((byte[])tsTokenAttr.getValue());
532     }
533 
534     /*
535      * Extracts a timestamp from a PKCS7 SignerInfo.
536      *
537      * Examines the signer&#39;s unsigned attributes for a
538      * {@code signatureTimestampToken} attribute. If present,
539      * then it is parsed to extract the date and time at which the
540      * timestamp was generated.
541      *
542      * @param info A signer information element of a PKCS 7 block.
543      *
544      * @return A timestamp token or null if none is present.
545      * @throws IOException if an error is encountered while parsing the
546      *         PKCS7 data.
547      * @throws NoSuchAlgorithmException if an error is encountered while
548      *         verifying the PKCS7 object.
549      * @throws SignatureException if an error is encountered while
550      *         verifying the PKCS7 object.
551      * @throws CertificateException if an error is encountered while generating
552      *         the TSA&#39;s certpath.
553      */
554     public Timestamp getTimestamp()
555         throws IOException, NoSuchAlgorithmException, SignatureException,
556                CertificateException
557     {
558         if (timestamp != null || !hasTimestamp)
559             return timestamp;
560 
561         PKCS7 tsToken = getTsToken();
562         if (tsToken == null) {
563             hasTimestamp = false;
564             return null;
565         }
566 
567         // Extract the content (an encoded timestamp token info)
568         byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
569         // Extract the signer (the Timestamping Authority)
570         // while verifying the content
571         SignerInfo[] tsa = tsToken.verify(encTsTokenInfo);
572         // Expect only one signer
573         ArrayList&lt;X509Certificate&gt; chain = tsa[0].getCertificateChain(tsToken);
574         CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
575         CertPath tsaChain = cf.generateCertPath(chain);
576         // Create a timestamp token info object
577         TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
578         // Check that the signature timestamp applies to this signature
579         verifyTimestamp(tsTokenInfo);
580         // Create a timestamp object
581         timestamp = new Timestamp(tsTokenInfo.getDate(), tsaChain);
582         return timestamp;
583     }
584 
585     /*
586      * Check that the signature timestamp applies to this signature.
587      * Match the hash present in the signature timestamp token against the hash
588      * of this signature.
589      */
590     private void verifyTimestamp(TimestampToken token)
591         throws NoSuchAlgorithmException, SignatureException {
592         String digestAlgname = token.getHashAlgorithm().getName();
593         // check that algorithm is not restricted
594         if (!JAR_DISABLED_CHECK.permits(DIGEST_PRIMITIVE_SET, digestAlgname,
595                 null)) {
596             throw new SignatureException(&quot;Timestamp token digest check failed. &quot; +
597                     &quot;Disabled algorithm used: &quot; + digestAlgname);
598         }
599 
600         MessageDigest md =
601             MessageDigest.getInstance(digestAlgname);
602 
603         if (!Arrays.equals(token.getHashedMessage(),
604             md.digest(encryptedDigest))) {
605 
606             throw new SignatureException(&quot;Signature timestamp (#&quot; +
607                 token.getSerialNumber() + &quot;) generated on &quot; + token.getDate() +
608                 &quot; is inapplicable&quot;);
609         }
610 
611         if (debug != null) {
612             debug.println();
613             debug.println(&quot;Detected signature timestamp (#&quot; +
614                 token.getSerialNumber() + &quot;) generated on &quot; + token.getDate());
615             debug.println();
616         }
617     }
618 
619     public String toString() {
620         HexDumpEncoder hexDump = new HexDumpEncoder();
621 
622         String out = &quot;&quot;;
623 
624         out += &quot;Signer Info for (issuer): &quot; + issuerName + &quot;\n&quot;;
625         out += &quot;\tversion: &quot; + Debug.toHexString(version) + &quot;\n&quot;;
626         out += &quot;\tcertificateSerialNumber: &quot; +
627                Debug.toHexString(certificateSerialNumber) + &quot;\n&quot;;
628         out += &quot;\tdigestAlgorithmId: &quot; + digestAlgorithmId + &quot;\n&quot;;
629         if (authenticatedAttributes != null) {
630             out += &quot;\tauthenticatedAttributes: &quot; + authenticatedAttributes +
631                    &quot;\n&quot;;
632         }
633         out += &quot;\tdigestEncryptionAlgorithmId: &quot; + digestEncryptionAlgorithmId +
634             &quot;\n&quot;;
635 
636         out += &quot;\tencryptedDigest: &quot; + &quot;\n&quot; +
637             hexDump.encodeBuffer(encryptedDigest) + &quot;\n&quot;;
638         if (unauthenticatedAttributes != null) {
639             out += &quot;\tunauthenticatedAttributes: &quot; +
640                    unauthenticatedAttributes + &quot;\n&quot;;
641         }
642         return out;
643     }
644 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/pkcs/PKCS7.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.pkcs;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
 30 import java.net.URI;
 31 import java.util.*;
 32 import java.security.cert.X509Certificate;
 33 import java.security.cert.CertificateException;
 34 import java.security.cert.X509CRL;
 35 import java.security.cert.CRLException;
 36 import java.security.cert.CertificateFactory;
 37 import java.security.*;
 38 
 39 import sun.security.timestamp.*;
 40 import sun.security.util.*;
 41 import sun.security.x509.AlgorithmId;
 42 import sun.security.x509.X509CertImpl;
 43 import sun.security.x509.X509CertInfo;
 44 import sun.security.x509.X509CRLImpl;
 45 import sun.security.x509.X500Name;
 46 
 47 /**
 48  * PKCS7 as defined in RSA Laboratories PKCS7 Technical Note. Profile
 49  * Supports only {@code SignedData} ContentInfo
 50  * type, where to the type of data signed is plain Data.
 51  * For signedData, {@code crls}, {@code attributes} and
 52  * PKCS#6 Extended Certificates are not supported.
 53  *
 54  * @author Benjamin Renaud
 55  */
 56 public class PKCS7 {
 57 
 58     private ObjectIdentifier contentType;
 59 
 60     // the ASN.1 members for a signedData (and other) contentTypes
 61     private BigInteger version = null;
 62     private AlgorithmId[] digestAlgorithmIds = null;
 63     private ContentInfo contentInfo = null;
 64     private X509Certificate[] certificates = null;
 65     private X509CRL[] crls = null;
 66     private SignerInfo[] signerInfos = null;
 67 
 68     private boolean oldStyle = false; // Is this JDK1.1.x-style?
 69 
 70     private Principal[] certIssuerNames;
 71 
 72     /*
 73      * Random number generator for creating nonce values
 74      * (Lazy initialization)
 75      */
 76     private static class SecureRandomHolder {
 77         static final SecureRandom RANDOM;
 78         static {
 79             SecureRandom tmp = null;
 80             try {
 81                 tmp = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
 82             } catch (NoSuchAlgorithmException e) {
 83                 // should not happen
 84             }
 85             RANDOM = tmp;
 86         }
 87     }
 88 
 89     /*
 90      * Object identifier for the timestamping key purpose.
 91      */
 92     private static final String KP_TIMESTAMPING_OID = &quot;1.3.6.1.5.5.7.3.8&quot;;
 93 
 94     /*
 95      * Object identifier for extendedKeyUsage extension
 96      */
 97     private static final String EXTENDED_KEY_USAGE_OID = &quot;2.5.29.37&quot;;
 98 
 99     /**
100      * Unmarshals a PKCS7 block from its encoded form, parsing the
101      * encoded bytes from the InputStream.
102      *
103      * @param in an input stream holding at least one PKCS7 block.
104      * @exception ParsingException on parsing errors.
105      * @exception IOException on other errors.
106      */
107     public PKCS7(InputStream in) throws ParsingException, IOException {
108         DataInputStream dis = new DataInputStream(in);
109         byte[] data = new byte[dis.available()];
110         dis.readFully(data);
111 
112         parse(new DerInputStream(data));
113     }
114 
115     /**
116      * Unmarshals a PKCS7 block from its encoded form, parsing the
117      * encoded bytes from the DerInputStream.
118      *
119      * @param derin a DerInputStream holding at least one PKCS7 block.
120      * @exception ParsingException on parsing errors.
121      */
122     public PKCS7(DerInputStream derin) throws ParsingException {
123         parse(derin);
124     }
125 
126     /**
127      * Unmarshals a PKCS7 block from its encoded form, parsing the
128      * encoded bytes.
129      *
130      * @param bytes the encoded bytes.
131      * @exception ParsingException on parsing errors.
132      */
133     public PKCS7(byte[] bytes) throws ParsingException {
134         try {
135             DerInputStream derin = new DerInputStream(bytes);
136             parse(derin);
137         } catch (IOException ioe1) {
138             ParsingException pe = new ParsingException(
139                 &quot;Unable to parse the encoded bytes&quot;);
140             pe.initCause(ioe1);
141             throw pe;
142         }
143     }
144 
145     /*
146      * Parses a PKCS#7 block.
147      */
148     private void parse(DerInputStream derin)
149         throws ParsingException
150     {
151         try {
152             derin.mark(derin.available());
153             // try new (i.e., JDK1.2) style
154             parse(derin, false);
155         } catch (IOException ioe) {
156             try {
157                 derin.reset();
158                 // try old (i.e., JDK1.1.x) style
159                 parse(derin, true);
160                 oldStyle = true;
161             } catch (IOException ioe1) {
162                 ParsingException pe = new ParsingException(
163                     ioe1.getMessage());
164                 pe.initCause(ioe);
165                 pe.addSuppressed(ioe1);
166                 throw pe;
167             }
168         }
169     }
170 
171     /**
172      * Parses a PKCS#7 block.
173      *
174      * @param derin the ASN.1 encoding of the PKCS#7 block.
175      * @param oldStyle flag indicating whether or not the given PKCS#7 block
176      * is encoded according to JDK1.1.x.
177      */
178     private void parse(DerInputStream derin, boolean oldStyle)
179         throws IOException
180     {
181         contentInfo = new ContentInfo(derin, oldStyle);
182         contentType = contentInfo.contentType;
183         DerValue content = contentInfo.getContent();
184 
185         if (contentType.equals(ContentInfo.SIGNED_DATA_OID)) {
186             parseSignedData(content);
187         } else if (contentType.equals(ContentInfo.OLD_SIGNED_DATA_OID)) {
188             // This is for backwards compatibility with JDK 1.1.x
189             parseOldSignedData(content);
190         } else if (contentType.equals(ContentInfo.NETSCAPE_CERT_SEQUENCE_OID)){
191             parseNetscapeCertChain(content);
192         } else {
193             throw new ParsingException(&quot;content type &quot; + contentType +
194                                        &quot; not supported.&quot;);
195         }
196     }
197 
198     /**
199      * Construct an initialized PKCS7 block.
200      *
201      * @param digestAlgorithmIds the message digest algorithm identifiers.
202      * @param contentInfo the content information.
203      * @param certificates an array of X.509 certificates.
204      * @param crls an array of CRLs
205      * @param signerInfos an array of signer information.
206      */
207     public PKCS7(AlgorithmId[] digestAlgorithmIds,
208                  ContentInfo contentInfo,
209                  X509Certificate[] certificates,
210                  X509CRL[] crls,
211                  SignerInfo[] signerInfos) {
212 
213         version = BigInteger.ONE;
214         this.digestAlgorithmIds = digestAlgorithmIds;
215         this.contentInfo = contentInfo;
216         this.certificates = certificates;
217         this.crls = crls;
218         this.signerInfos = signerInfos;
219     }
220 
221     public PKCS7(AlgorithmId[] digestAlgorithmIds,
222                  ContentInfo contentInfo,
223                  X509Certificate[] certificates,
224                  SignerInfo[] signerInfos) {
225         this(digestAlgorithmIds, contentInfo, certificates, null, signerInfos);
226     }
227 
228     private void parseNetscapeCertChain(DerValue val)
229     throws ParsingException, IOException {
230         DerInputStream dis = new DerInputStream(val.toByteArray());
231         DerValue[] contents = dis.getSequence(2);
232         certificates = new X509Certificate[contents.length];
233 
234         CertificateFactory certfac = null;
235         try {
236             certfac = CertificateFactory.getInstance(&quot;X.509&quot;);
237         } catch (CertificateException ce) {
238             // do nothing
239         }
240 
241         for (int i=0; i &lt; contents.length; i++) {
242             ByteArrayInputStream bais = null;
243             try {
244                 if (certfac == null)
245                     certificates[i] = new X509CertImpl(contents[i]);
246                 else {
247                     byte[] encoded = contents[i].toByteArray();
248                     bais = new ByteArrayInputStream(encoded);
249                     certificates[i] =
250                         (X509Certificate)certfac.generateCertificate(bais);
251                     bais.close();
252                     bais = null;
253                 }
254             } catch (CertificateException ce) {
255                 ParsingException pe = new ParsingException(ce.getMessage());
256                 pe.initCause(ce);
257                 throw pe;
258             } catch (IOException ioe) {
259                 ParsingException pe = new ParsingException(ioe.getMessage());
260                 pe.initCause(ioe);
261                 throw pe;
262             } finally {
263                 if (bais != null)
264                     bais.close();
265             }
266         }
267     }
268 
<a name="1" id="anc1"></a><span class="line-added">269 </span>
<span class="line-added">270     //    SignedData ::= SEQUENCE {</span>
<span class="line-added">271     //        version CMSVersion,</span>
<span class="line-added">272     //        digestAlgorithms DigestAlgorithmIdentifiers,</span>
<span class="line-added">273     //        encapContentInfo EncapsulatedContentInfo,</span>
<span class="line-added">274     //        certificates [0] IMPLICIT CertificateSet OPTIONAL,</span>
<span class="line-added">275     //        crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,</span>
<span class="line-added">276     //        signerInfos SignerInfos }</span>
277     private void parseSignedData(DerValue val)
278         throws ParsingException, IOException {
279 
280         DerInputStream dis = val.toDerInputStream();
281 
282         // Version
283         version = dis.getBigInteger();
284 
285         // digestAlgorithmIds
286         DerValue[] digestAlgorithmIdVals = dis.getSet(1);
287         int len = digestAlgorithmIdVals.length;
288         digestAlgorithmIds = new AlgorithmId[len];
289         try {
290             for (int i = 0; i &lt; len; i++) {
291                 DerValue oid = digestAlgorithmIdVals[i];
292                 digestAlgorithmIds[i] = AlgorithmId.parse(oid);
293             }
294 
295         } catch (IOException e) {
296             ParsingException pe =
297                 new ParsingException(&quot;Error parsing digest AlgorithmId IDs: &quot; +
298                                      e.getMessage());
299             pe.initCause(e);
300             throw pe;
301         }
302         // contentInfo
303         contentInfo = new ContentInfo(dis);
304 
305         CertificateFactory certfac = null;
306         try {
307             certfac = CertificateFactory.getInstance(&quot;X.509&quot;);
308         } catch (CertificateException ce) {
309             // do nothing
310         }
311 
312         /*
313          * check if certificates (implicit tag) are provided
314          * (certificates are OPTIONAL)
315          */
<a name="2" id="anc2"></a><span class="line-modified">316         if (dis.seeOptionalContextSpecific(0)) {</span>
317             DerValue[] certVals = dis.getSet(2, true);
318 
319             len = certVals.length;
320             certificates = new X509Certificate[len];
321             int count = 0;
322 
323             for (int i = 0; i &lt; len; i++) {
324                 ByteArrayInputStream bais = null;
325                 try {
326                     byte tag = certVals[i].getTag();
327                     // We only parse the normal certificate. Other types of
328                     // CertificateChoices ignored.
329                     if (tag == DerValue.tag_Sequence) {
330                         if (certfac == null) {
331                             certificates[count] = new X509CertImpl(certVals[i]);
332                         } else {
333                             byte[] encoded = certVals[i].toByteArray();
334                             bais = new ByteArrayInputStream(encoded);
335                             certificates[count] =
336                                 (X509Certificate)certfac.generateCertificate(bais);
337                             bais.close();
338                             bais = null;
339                         }
340                         count++;
341                     }
342                 } catch (CertificateException ce) {
343                     ParsingException pe = new ParsingException(ce.getMessage());
344                     pe.initCause(ce);
345                     throw pe;
346                 } catch (IOException ioe) {
347                     ParsingException pe = new ParsingException(ioe.getMessage());
348                     pe.initCause(ioe);
349                     throw pe;
350                 } finally {
351                     if (bais != null)
352                         bais.close();
353                 }
354             }
355             if (count != len) {
356                 certificates = Arrays.copyOf(certificates, count);
357             }
358         }
359 
360         // check if crls (implicit tag) are provided (crls are OPTIONAL)
<a name="3" id="anc3"></a><span class="line-modified">361         if (dis.seeOptionalContextSpecific(1)) {</span>
362             DerValue[] crlVals = dis.getSet(1, true);
363 
364             len = crlVals.length;
365             crls = new X509CRL[len];
366 
367             for (int i = 0; i &lt; len; i++) {
368                 ByteArrayInputStream bais = null;
369                 try {
370                     if (certfac == null)
371                         crls[i] = new X509CRLImpl(crlVals[i]);
372                     else {
373                         byte[] encoded = crlVals[i].toByteArray();
374                         bais = new ByteArrayInputStream(encoded);
375                         crls[i] = (X509CRL) certfac.generateCRL(bais);
376                         bais.close();
377                         bais = null;
378                     }
379                 } catch (CRLException e) {
380                     ParsingException pe =
381                         new ParsingException(e.getMessage());
382                     pe.initCause(e);
383                     throw pe;
384                 } finally {
385                     if (bais != null)
386                         bais.close();
387                 }
388             }
389         }
390 
391         // signerInfos
392         DerValue[] signerInfoVals = dis.getSet(1);
393 
394         len = signerInfoVals.length;
395         signerInfos = new SignerInfo[len];
396 
397         for (int i = 0; i &lt; len; i++) {
398             DerInputStream in = signerInfoVals[i].toDerInputStream();
399             signerInfos[i] = new SignerInfo(in);
400         }
401     }
402 
403     /*
404      * Parses an old-style SignedData encoding (for backwards
405      * compatibility with JDK1.1.x).
406      */
407     private void parseOldSignedData(DerValue val)
408         throws ParsingException, IOException
409     {
410         DerInputStream dis = val.toDerInputStream();
411 
412         // Version
413         version = dis.getBigInteger();
414 
415         // digestAlgorithmIds
416         DerValue[] digestAlgorithmIdVals = dis.getSet(1);
417         int len = digestAlgorithmIdVals.length;
418 
419         digestAlgorithmIds = new AlgorithmId[len];
420         try {
421             for (int i = 0; i &lt; len; i++) {
422                 DerValue oid = digestAlgorithmIdVals[i];
423                 digestAlgorithmIds[i] = AlgorithmId.parse(oid);
424             }
425         } catch (IOException e) {
426             throw new ParsingException(&quot;Error parsing digest AlgorithmId IDs&quot;);
427         }
428 
429         // contentInfo
430         contentInfo = new ContentInfo(dis, true);
431 
432         // certificates
433         CertificateFactory certfac = null;
434         try {
435             certfac = CertificateFactory.getInstance(&quot;X.509&quot;);
436         } catch (CertificateException ce) {
437             // do nothing
438         }
439         DerValue[] certVals = dis.getSet(2);
440         len = certVals.length;
441         certificates = new X509Certificate[len];
442 
443         for (int i = 0; i &lt; len; i++) {
444             ByteArrayInputStream bais = null;
445             try {
446                 if (certfac == null)
447                     certificates[i] = new X509CertImpl(certVals[i]);
448                 else {
449                     byte[] encoded = certVals[i].toByteArray();
450                     bais = new ByteArrayInputStream(encoded);
451                     certificates[i] =
452                         (X509Certificate)certfac.generateCertificate(bais);
453                     bais.close();
454                     bais = null;
455                 }
456             } catch (CertificateException ce) {
457                 ParsingException pe = new ParsingException(ce.getMessage());
458                 pe.initCause(ce);
459                 throw pe;
460             } catch (IOException ioe) {
461                 ParsingException pe = new ParsingException(ioe.getMessage());
462                 pe.initCause(ioe);
463                 throw pe;
464             } finally {
465                 if (bais != null)
466                     bais.close();
467             }
468         }
469 
470         // crls are ignored.
471         dis.getSet(0);
472 
473         // signerInfos
474         DerValue[] signerInfoVals = dis.getSet(1);
475         len = signerInfoVals.length;
476         signerInfos = new SignerInfo[len];
477         for (int i = 0; i &lt; len; i++) {
478             DerInputStream in = signerInfoVals[i].toDerInputStream();
479             signerInfos[i] = new SignerInfo(in, true);
480         }
481     }
482 
483     /**
484      * Encodes the signed data to an output stream.
485      *
486      * @param out the output stream to write the encoded data to.
487      * @exception IOException on encoding errors.
488      */
489     public void encodeSignedData(OutputStream out) throws IOException {
490         DerOutputStream derout = new DerOutputStream();
491         encodeSignedData(derout);
492         out.write(derout.toByteArray());
493     }
494 
495     /**
496      * Encodes the signed data to a DerOutputStream.
497      *
498      * @param out the DerOutputStream to write the encoded data to.
499      * @exception IOException on encoding errors.
500      */
501     public void encodeSignedData(DerOutputStream out)
502         throws IOException
503     {
504         DerOutputStream signedData = new DerOutputStream();
505 
506         // version
507         signedData.putInteger(version);
508 
509         // digestAlgorithmIds
510         signedData.putOrderedSetOf(DerValue.tag_Set, digestAlgorithmIds);
511 
512         // contentInfo
513         contentInfo.encode(signedData);
514 
515         // certificates (optional)
516         if (certificates != null &amp;&amp; certificates.length != 0) {
517             // cast to X509CertImpl[] since X509CertImpl implements DerEncoder
518             X509CertImpl[] implCerts = new X509CertImpl[certificates.length];
519             for (int i = 0; i &lt; certificates.length; i++) {
520                 if (certificates[i] instanceof X509CertImpl)
521                     implCerts[i] = (X509CertImpl) certificates[i];
522                 else {
523                     try {
524                         byte[] encoded = certificates[i].getEncoded();
525                         implCerts[i] = new X509CertImpl(encoded);
526                     } catch (CertificateException ce) {
527                         throw new IOException(ce);
528                     }
529                 }
530             }
531 
532             // Add the certificate set (tagged with [0] IMPLICIT)
533             // to the signed data
534             signedData.putOrderedSetOf((byte)0xA0, implCerts);
535         }
536 
537         // CRLs (optional)
538         if (crls != null &amp;&amp; crls.length != 0) {
539             // cast to X509CRLImpl[] since X509CRLImpl implements DerEncoder
540             Set&lt;X509CRLImpl&gt; implCRLs = new HashSet&lt;&gt;(crls.length);
541             for (X509CRL crl: crls) {
542                 if (crl instanceof X509CRLImpl)
543                     implCRLs.add((X509CRLImpl) crl);
544                 else {
545                     try {
546                         byte[] encoded = crl.getEncoded();
547                         implCRLs.add(new X509CRLImpl(encoded));
548                     } catch (CRLException ce) {
549                         throw new IOException(ce);
550                     }
551                 }
552             }
553 
554             // Add the CRL set (tagged with [1] IMPLICIT)
555             // to the signed data
556             signedData.putOrderedSetOf((byte)0xA1,
557                     implCRLs.toArray(new X509CRLImpl[implCRLs.size()]));
558         }
559 
560         // signerInfos
561         signedData.putOrderedSetOf(DerValue.tag_Set, signerInfos);
562 
563         // making it a signed data block
564         DerValue signedDataSeq = new DerValue(DerValue.tag_Sequence,
565                                               signedData.toByteArray());
566 
567         // making it a content info sequence
568         ContentInfo block = new ContentInfo(ContentInfo.SIGNED_DATA_OID,
569                                             signedDataSeq);
570 
571         // writing out the contentInfo sequence
572         block.encode(out);
573     }
574 
575     /**
576      * This verifies a given SignerInfo.
577      *
578      * @param info the signer information.
579      * @param bytes the DER encoded content information.
580      *
581      * @exception NoSuchAlgorithmException on unrecognized algorithms.
582      * @exception SignatureException on signature handling errors.
583      */
584     public SignerInfo verify(SignerInfo info, byte[] bytes)
585     throws NoSuchAlgorithmException, SignatureException {
586         return info.verify(this, bytes);
587     }
588 
589     /**
590      * Returns all signerInfos which self-verify.
591      *
592      * @param bytes the DER encoded content information.
593      *
594      * @exception NoSuchAlgorithmException on unrecognized algorithms.
595      * @exception SignatureException on signature handling errors.
596      */
597     public SignerInfo[] verify(byte[] bytes)
598     throws NoSuchAlgorithmException, SignatureException {
599 
600         Vector&lt;SignerInfo&gt; intResult = new Vector&lt;&gt;();
601         for (int i = 0; i &lt; signerInfos.length; i++) {
602 
603             SignerInfo signerInfo = verify(signerInfos[i], bytes);
604             if (signerInfo != null) {
605                 intResult.addElement(signerInfo);
606             }
607         }
608         if (!intResult.isEmpty()) {
609 
610             SignerInfo[] result = new SignerInfo[intResult.size()];
611             intResult.copyInto(result);
612             return result;
613         }
614         return null;
615     }
616 
617     /**
618      * Returns all signerInfos which self-verify.
619      *
620      * @exception NoSuchAlgorithmException on unrecognized algorithms.
621      * @exception SignatureException on signature handling errors.
622      */
623     public SignerInfo[] verify()
624     throws NoSuchAlgorithmException, SignatureException {
625         return verify(null);
626     }
627 
628     /**
629      * Returns the version number of this PKCS7 block.
630      * @return the version or null if version is not specified
631      *         for the content type.
632      */
633     public  BigInteger getVersion() {
634         return version;
635     }
636 
637     /**
638      * Returns the message digest algorithms specified in this PKCS7 block.
639      * @return the array of Digest Algorithms or null if none are specified
640      *         for the content type.
641      */
642     public AlgorithmId[] getDigestAlgorithmIds() {
643         return  digestAlgorithmIds;
644     }
645 
646     /**
647      * Returns the content information specified in this PKCS7 block.
648      */
649     public ContentInfo getContentInfo() {
650         return contentInfo;
651     }
652 
653     /**
654      * Returns the X.509 certificates listed in this PKCS7 block.
655      * @return a clone of the array of X.509 certificates or null if
656      *         none are specified for the content type.
657      */
658     public X509Certificate[] getCertificates() {
659         if (certificates != null)
660             return certificates.clone();
661         else
662             return null;
663     }
664 
665     /**
666      * Returns the X.509 crls listed in this PKCS7 block.
667      * @return a clone of the array of X.509 crls or null if none
668      *         are specified for the content type.
669      */
670     public X509CRL[] getCRLs() {
671         if (crls != null)
672             return crls.clone();
673         else
674             return null;
675     }
676 
677     /**
678      * Returns the signer&#39;s information specified in this PKCS7 block.
679      * @return the array of Signer Infos or null if none are specified
680      *         for the content type.
681      */
682     public SignerInfo[] getSignerInfos() {
683         return signerInfos;
684     }
685 
686     /**
687      * Returns the X.509 certificate listed in this PKCS7 block
688      * which has a matching serial number and Issuer name, or
689      * null if one is not found.
690      *
691      * @param serial the serial number of the certificate to retrieve.
692      * @param issuerName the Distinguished Name of the Issuer.
693      */
694     public X509Certificate getCertificate(BigInteger serial, X500Name issuerName) {
695         if (certificates != null) {
696             if (certIssuerNames == null)
697                 populateCertIssuerNames();
698             for (int i = 0; i &lt; certificates.length; i++) {
699                 X509Certificate cert = certificates[i];
700                 BigInteger thisSerial = cert.getSerialNumber();
701                 if (serial.equals(thisSerial)
702                     &amp;&amp; issuerName.equals(certIssuerNames[i]))
703                 {
704                     return cert;
705                 }
706             }
707         }
708         return null;
709     }
710 
711     /**
712      * Populate array of Issuer DNs from certificates and convert
713      * each Principal to type X500Name if necessary.
714      */
715     private void populateCertIssuerNames() {
716         if (certificates == null)
717             return;
718 
719         certIssuerNames = new Principal[certificates.length];
720         for (int i = 0; i &lt; certificates.length; i++) {
721             X509Certificate cert = certificates[i];
722             Principal certIssuerName = cert.getIssuerDN();
723             if (!(certIssuerName instanceof X500Name)) {
724                 // must extract the original encoded form of DN for
725                 // subsequent name comparison checks (converting to a
726                 // String and back to an encoded DN could cause the
727                 // types of String attribute values to be changed)
728                 try {
729                     X509CertInfo tbsCert =
730                         new X509CertInfo(cert.getTBSCertificate());
731                     certIssuerName = (Principal)
732                         tbsCert.get(X509CertInfo.ISSUER + &quot;.&quot; +
733                                     X509CertInfo.DN_NAME);
734                 } catch (Exception e) {
735                     // error generating X500Name object from the cert&#39;s
736                     // issuer DN, leave name as is.
737                 }
738             }
739             certIssuerNames[i] = certIssuerName;
740         }
741     }
742 
743     /**
744      * Returns the PKCS7 block in a printable string form.
745      */
746     public String toString() {
747         String out = &quot;&quot;;
748 
749         out += contentInfo + &quot;\n&quot;;
750         if (version != null)
751             out += &quot;PKCS7 :: version: &quot; + Debug.toHexString(version) + &quot;\n&quot;;
752         if (digestAlgorithmIds != null) {
753             out += &quot;PKCS7 :: digest AlgorithmIds: \n&quot;;
754             for (int i = 0; i &lt; digestAlgorithmIds.length; i++)
755                 out += &quot;\t&quot; + digestAlgorithmIds[i] + &quot;\n&quot;;
756         }
757         if (certificates != null) {
758             out += &quot;PKCS7 :: certificates: \n&quot;;
759             for (int i = 0; i &lt; certificates.length; i++)
760                 out += &quot;\t&quot; + i + &quot;.   &quot; + certificates[i] + &quot;\n&quot;;
761         }
762         if (crls != null) {
763             out += &quot;PKCS7 :: crls: \n&quot;;
764             for (int i = 0; i &lt; crls.length; i++)
765                 out += &quot;\t&quot; + i + &quot;.   &quot; + crls[i] + &quot;\n&quot;;
766         }
767         if (signerInfos != null) {
768             out += &quot;PKCS7 :: signer infos: \n&quot;;
769             for (int i = 0; i &lt; signerInfos.length; i++)
770                 out += (&quot;\t&quot; + i + &quot;.  &quot; + signerInfos[i] + &quot;\n&quot;);
771         }
772         return out;
773     }
774 
775     /**
776      * Returns true if this is a JDK1.1.x-style PKCS#7 block, and false
777      * otherwise.
778      */
779     public boolean isOldStyle() {
780         return this.oldStyle;
781     }
782 
783     /**
784      * Assembles a PKCS #7 signed data message that optionally includes a
785      * signature timestamp.
786      *
787      * @param signature the signature bytes
788      * @param signerChain the signer&#39;s X.509 certificate chain
789      * @param content the content that is signed; specify null to not include
790      *        it in the PKCS7 data
791      * @param signatureAlgorithm the name of the signature algorithm
792      * @param tsaURI the URI of the Timestamping Authority; or null if no
793      *         timestamp is requested
794      * @param tSAPolicyID the TSAPolicyID of the Timestamping Authority as a
795      *         numerical object identifier; or null if we leave the TSA server
796      *         to choose one. This argument is only used when tsaURI is provided
797      * @return the bytes of the encoded PKCS #7 signed data message
798      * @throws NoSuchAlgorithmException The exception is thrown if the signature
799      *         algorithm is unrecognised.
800      * @throws CertificateException The exception is thrown if an error occurs
801      *         while processing the signer&#39;s certificate or the TSA&#39;s
802      *         certificate.
803      * @throws IOException The exception is thrown if an error occurs while
804      *         generating the signature timestamp or while generating the signed
805      *         data message.
806      */
807     public static byte[] generateSignedData(byte[] signature,
808                                             X509Certificate[] signerChain,
809                                             byte[] content,
810                                             String signatureAlgorithm,
811                                             URI tsaURI,
812                                             String tSAPolicyID,
813                                             String tSADigestAlg)
814         throws CertificateException, IOException, NoSuchAlgorithmException
815     {
816 
817         // Generate the timestamp token
818         PKCS9Attributes unauthAttrs = null;
819         if (tsaURI != null) {
820             // Timestamp the signature
821             HttpTimestamper tsa = new HttpTimestamper(tsaURI);
822             byte[] tsToken = generateTimestampToken(
823                     tsa, tSAPolicyID, tSADigestAlg, signature);
824 
825             // Insert the timestamp token into the PKCS #7 signer info element
826             // (as an unsigned attribute)
827             unauthAttrs =
828                 new PKCS9Attributes(new PKCS9Attribute[]{
829                     new PKCS9Attribute(
830                         PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID,
831                         tsToken)});
832         }
833 
834         // Create the SignerInfo
835         X500Name issuerName =
836             X500Name.asX500Name(signerChain[0].getIssuerX500Principal());
837         BigInteger serialNumber = signerChain[0].getSerialNumber();
838         String encAlg = AlgorithmId.getEncAlgFromSigAlg(signatureAlgorithm);
839         String digAlg = AlgorithmId.getDigAlgFromSigAlg(signatureAlgorithm);
840         if (digAlg == null) {
841             throw new UnsupportedOperationException(&quot;Unable to determine &quot; +
842                     &quot;the digest algorithm from the signature algorithm.&quot;);
843         }
844         SignerInfo signerInfo = new SignerInfo(issuerName, serialNumber,
845                                                AlgorithmId.get(digAlg), null,
846                                                AlgorithmId.get(encAlg),
847                                                signature, unauthAttrs);
848 
849         // Create the PKCS #7 signed data message
850         SignerInfo[] signerInfos = {signerInfo};
851         AlgorithmId[] algorithms = {signerInfo.getDigestAlgorithmId()};
852         // Include or exclude content
853         ContentInfo contentInfo = (content == null)
854             ? new ContentInfo(ContentInfo.DATA_OID, null)
855             : new ContentInfo(content);
856         PKCS7 pkcs7 = new PKCS7(algorithms, contentInfo,
857                                 signerChain, signerInfos);
858         ByteArrayOutputStream p7out = new ByteArrayOutputStream();
859         pkcs7.encodeSignedData(p7out);
860 
861         return p7out.toByteArray();
862     }
863 
864     /**
865      * Requests, processes and validates a timestamp token from a TSA using
866      * common defaults. Uses the following defaults in the timestamp request:
867      * SHA-1 for the hash algorithm, a 64-bit nonce, and request certificate
868      * set to true.
869      *
870      * @param tsa the timestamping authority to use
871      * @param tSAPolicyID the TSAPolicyID of the Timestamping Authority as a
872      *         numerical object identifier; or null if we leave the TSA server
873      *         to choose one
874      * @param toBeTimestamped the token that is to be timestamped
875      * @return the encoded timestamp token
876      * @throws IOException The exception is thrown if an error occurs while
877      *                     communicating with the TSA, or a non-null
878      *                     TSAPolicyID is specified in the request but it
879      *                     does not match the one in the reply
880      * @throws CertificateException The exception is thrown if the TSA&#39;s
881      *                     certificate is not permitted for timestamping.
882      */
883     private static byte[] generateTimestampToken(Timestamper tsa,
884                                                  String tSAPolicyID,
885                                                  String tSADigestAlg,
886                                                  byte[] toBeTimestamped)
887         throws IOException, CertificateException
888     {
889         // Generate a timestamp
890         MessageDigest messageDigest = null;
891         TSRequest tsQuery = null;
892         try {
893             messageDigest = MessageDigest.getInstance(tSADigestAlg);
894             tsQuery = new TSRequest(tSAPolicyID, toBeTimestamped, messageDigest);
895         } catch (NoSuchAlgorithmException e) {
896             throw new IllegalArgumentException(e);
897         }
898 
899         // Generate a nonce
900         BigInteger nonce = null;
901         if (SecureRandomHolder.RANDOM != null) {
902             nonce = new BigInteger(64, SecureRandomHolder.RANDOM);
903             tsQuery.setNonce(nonce);
904         }
905         tsQuery.requestCertificate(true);
906 
907         TSResponse tsReply = tsa.generateTimestamp(tsQuery);
908         int status = tsReply.getStatusCode();
909         // Handle TSP error
910         if (status != 0 &amp;&amp; status != 1) {
911             throw new IOException(&quot;Error generating timestamp: &quot; +
912                 tsReply.getStatusCodeAsText() + &quot; &quot; +
913                 tsReply.getFailureCodeAsText());
914         }
915 
916         if (tSAPolicyID != null &amp;&amp;
917                 !tSAPolicyID.equals(tsReply.getTimestampToken().getPolicyID())) {
918             throw new IOException(&quot;TSAPolicyID changed in &quot;
919                     + &quot;timestamp token&quot;);
920         }
921         PKCS7 tsToken = tsReply.getToken();
922 
923         TimestampToken tst = tsReply.getTimestampToken();
924         try {
925             if (!tst.getHashAlgorithm().equals(AlgorithmId.get(tSADigestAlg))) {
926                 throw new IOException(&quot;Digest algorithm not &quot; + tSADigestAlg + &quot; in &quot;
927                                       + &quot;timestamp token&quot;);
928             }
929         } catch (NoSuchAlgorithmException nase) {
930             throw new IllegalArgumentException();   // should have been caught before
931         }
932         if (!MessageDigest.isEqual(tst.getHashedMessage(),
933                                    tsQuery.getHashedMessage())) {
934             throw new IOException(&quot;Digest octets changed in timestamp token&quot;);
935         }
936 
937         BigInteger replyNonce = tst.getNonce();
938         if (replyNonce == null &amp;&amp; nonce != null) {
939             throw new IOException(&quot;Nonce missing in timestamp token&quot;);
940         }
941         if (replyNonce != null &amp;&amp; !replyNonce.equals(nonce)) {
942             throw new IOException(&quot;Nonce changed in timestamp token&quot;);
943         }
944 
945         // Examine the TSA&#39;s certificate (if present)
946         for (SignerInfo si: tsToken.getSignerInfos()) {
947             X509Certificate cert = si.getCertificate(tsToken);
948             if (cert == null) {
949                 // Error, we&#39;ve already set tsRequestCertificate = true
950                 throw new CertificateException(
951                 &quot;Certificate not included in timestamp token&quot;);
952             } else {
953                 if (!cert.getCriticalExtensionOIDs().contains(
954                         EXTENDED_KEY_USAGE_OID)) {
955                     throw new CertificateException(
956                     &quot;Certificate is not valid for timestamping&quot;);
957                 }
958                 List&lt;String&gt; keyPurposes = cert.getExtendedKeyUsage();
959                 if (keyPurposes == null ||
960                         !keyPurposes.contains(KP_TIMESTAMPING_OID)) {
961                     throw new CertificateException(
962                     &quot;Certificate is not valid for timestamping&quot;);
963                 }
964             }
965         }
966         return tsReply.getEncodedToken();
967     }
968 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
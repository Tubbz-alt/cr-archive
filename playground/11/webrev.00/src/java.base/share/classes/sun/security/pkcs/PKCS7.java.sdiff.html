<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/pkcs/PKCS7.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../java/security/cert/PolicyQualifierInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PKCS8Key.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/pkcs/PKCS7.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
249                     certificates[i] =
250                         (X509Certificate)certfac.generateCertificate(bais);
251                     bais.close();
252                     bais = null;
253                 }
254             } catch (CertificateException ce) {
255                 ParsingException pe = new ParsingException(ce.getMessage());
256                 pe.initCause(ce);
257                 throw pe;
258             } catch (IOException ioe) {
259                 ParsingException pe = new ParsingException(ioe.getMessage());
260                 pe.initCause(ioe);
261                 throw pe;
262             } finally {
263                 if (bais != null)
264                     bais.close();
265             }
266         }
267     }
268 








269     private void parseSignedData(DerValue val)
270         throws ParsingException, IOException {
271 
272         DerInputStream dis = val.toDerInputStream();
273 
274         // Version
275         version = dis.getBigInteger();
276 
277         // digestAlgorithmIds
278         DerValue[] digestAlgorithmIdVals = dis.getSet(1);
279         int len = digestAlgorithmIdVals.length;
280         digestAlgorithmIds = new AlgorithmId[len];
281         try {
282             for (int i = 0; i &lt; len; i++) {
283                 DerValue oid = digestAlgorithmIdVals[i];
284                 digestAlgorithmIds[i] = AlgorithmId.parse(oid);
285             }
286 
287         } catch (IOException e) {
288             ParsingException pe =
289                 new ParsingException(&quot;Error parsing digest AlgorithmId IDs: &quot; +
290                                      e.getMessage());
291             pe.initCause(e);
292             throw pe;
293         }
294         // contentInfo
295         contentInfo = new ContentInfo(dis);
296 
297         CertificateFactory certfac = null;
298         try {
299             certfac = CertificateFactory.getInstance(&quot;X.509&quot;);
300         } catch (CertificateException ce) {
301             // do nothing
302         }
303 
304         /*
305          * check if certificates (implicit tag) are provided
306          * (certificates are OPTIONAL)
307          */
<span class="line-modified">308         if ((byte)(dis.peekByte()) == (byte)0xA0) {</span>
309             DerValue[] certVals = dis.getSet(2, true);
310 
311             len = certVals.length;
312             certificates = new X509Certificate[len];
313             int count = 0;
314 
315             for (int i = 0; i &lt; len; i++) {
316                 ByteArrayInputStream bais = null;
317                 try {
318                     byte tag = certVals[i].getTag();
319                     // We only parse the normal certificate. Other types of
320                     // CertificateChoices ignored.
321                     if (tag == DerValue.tag_Sequence) {
322                         if (certfac == null) {
323                             certificates[count] = new X509CertImpl(certVals[i]);
324                         } else {
325                             byte[] encoded = certVals[i].toByteArray();
326                             bais = new ByteArrayInputStream(encoded);
327                             certificates[count] =
328                                 (X509Certificate)certfac.generateCertificate(bais);
</pre>
<hr />
<pre>
333                     }
334                 } catch (CertificateException ce) {
335                     ParsingException pe = new ParsingException(ce.getMessage());
336                     pe.initCause(ce);
337                     throw pe;
338                 } catch (IOException ioe) {
339                     ParsingException pe = new ParsingException(ioe.getMessage());
340                     pe.initCause(ioe);
341                     throw pe;
342                 } finally {
343                     if (bais != null)
344                         bais.close();
345                 }
346             }
347             if (count != len) {
348                 certificates = Arrays.copyOf(certificates, count);
349             }
350         }
351 
352         // check if crls (implicit tag) are provided (crls are OPTIONAL)
<span class="line-modified">353         if ((byte)(dis.peekByte()) == (byte)0xA1) {</span>
354             DerValue[] crlVals = dis.getSet(1, true);
355 
356             len = crlVals.length;
357             crls = new X509CRL[len];
358 
359             for (int i = 0; i &lt; len; i++) {
360                 ByteArrayInputStream bais = null;
361                 try {
362                     if (certfac == null)
363                         crls[i] = new X509CRLImpl(crlVals[i]);
364                     else {
365                         byte[] encoded = crlVals[i].toByteArray();
366                         bais = new ByteArrayInputStream(encoded);
367                         crls[i] = (X509CRL) certfac.generateCRL(bais);
368                         bais.close();
369                         bais = null;
370                     }
371                 } catch (CRLException e) {
372                     ParsingException pe =
373                         new ParsingException(e.getMessage());
</pre>
</td>
<td>
<hr />
<pre>
249                     certificates[i] =
250                         (X509Certificate)certfac.generateCertificate(bais);
251                     bais.close();
252                     bais = null;
253                 }
254             } catch (CertificateException ce) {
255                 ParsingException pe = new ParsingException(ce.getMessage());
256                 pe.initCause(ce);
257                 throw pe;
258             } catch (IOException ioe) {
259                 ParsingException pe = new ParsingException(ioe.getMessage());
260                 pe.initCause(ioe);
261                 throw pe;
262             } finally {
263                 if (bais != null)
264                     bais.close();
265             }
266         }
267     }
268 
<span class="line-added">269 </span>
<span class="line-added">270     //    SignedData ::= SEQUENCE {</span>
<span class="line-added">271     //        version CMSVersion,</span>
<span class="line-added">272     //        digestAlgorithms DigestAlgorithmIdentifiers,</span>
<span class="line-added">273     //        encapContentInfo EncapsulatedContentInfo,</span>
<span class="line-added">274     //        certificates [0] IMPLICIT CertificateSet OPTIONAL,</span>
<span class="line-added">275     //        crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,</span>
<span class="line-added">276     //        signerInfos SignerInfos }</span>
277     private void parseSignedData(DerValue val)
278         throws ParsingException, IOException {
279 
280         DerInputStream dis = val.toDerInputStream();
281 
282         // Version
283         version = dis.getBigInteger();
284 
285         // digestAlgorithmIds
286         DerValue[] digestAlgorithmIdVals = dis.getSet(1);
287         int len = digestAlgorithmIdVals.length;
288         digestAlgorithmIds = new AlgorithmId[len];
289         try {
290             for (int i = 0; i &lt; len; i++) {
291                 DerValue oid = digestAlgorithmIdVals[i];
292                 digestAlgorithmIds[i] = AlgorithmId.parse(oid);
293             }
294 
295         } catch (IOException e) {
296             ParsingException pe =
297                 new ParsingException(&quot;Error parsing digest AlgorithmId IDs: &quot; +
298                                      e.getMessage());
299             pe.initCause(e);
300             throw pe;
301         }
302         // contentInfo
303         contentInfo = new ContentInfo(dis);
304 
305         CertificateFactory certfac = null;
306         try {
307             certfac = CertificateFactory.getInstance(&quot;X.509&quot;);
308         } catch (CertificateException ce) {
309             // do nothing
310         }
311 
312         /*
313          * check if certificates (implicit tag) are provided
314          * (certificates are OPTIONAL)
315          */
<span class="line-modified">316         if (dis.seeOptionalContextSpecific(0)) {</span>
317             DerValue[] certVals = dis.getSet(2, true);
318 
319             len = certVals.length;
320             certificates = new X509Certificate[len];
321             int count = 0;
322 
323             for (int i = 0; i &lt; len; i++) {
324                 ByteArrayInputStream bais = null;
325                 try {
326                     byte tag = certVals[i].getTag();
327                     // We only parse the normal certificate. Other types of
328                     // CertificateChoices ignored.
329                     if (tag == DerValue.tag_Sequence) {
330                         if (certfac == null) {
331                             certificates[count] = new X509CertImpl(certVals[i]);
332                         } else {
333                             byte[] encoded = certVals[i].toByteArray();
334                             bais = new ByteArrayInputStream(encoded);
335                             certificates[count] =
336                                 (X509Certificate)certfac.generateCertificate(bais);
</pre>
<hr />
<pre>
341                     }
342                 } catch (CertificateException ce) {
343                     ParsingException pe = new ParsingException(ce.getMessage());
344                     pe.initCause(ce);
345                     throw pe;
346                 } catch (IOException ioe) {
347                     ParsingException pe = new ParsingException(ioe.getMessage());
348                     pe.initCause(ioe);
349                     throw pe;
350                 } finally {
351                     if (bais != null)
352                         bais.close();
353                 }
354             }
355             if (count != len) {
356                 certificates = Arrays.copyOf(certificates, count);
357             }
358         }
359 
360         // check if crls (implicit tag) are provided (crls are OPTIONAL)
<span class="line-modified">361         if (dis.seeOptionalContextSpecific(1)) {</span>
362             DerValue[] crlVals = dis.getSet(1, true);
363 
364             len = crlVals.length;
365             crls = new X509CRL[len];
366 
367             for (int i = 0; i &lt; len; i++) {
368                 ByteArrayInputStream bais = null;
369                 try {
370                     if (certfac == null)
371                         crls[i] = new X509CRLImpl(crlVals[i]);
372                     else {
373                         byte[] encoded = crlVals[i].toByteArray();
374                         bais = new ByteArrayInputStream(encoded);
375                         crls[i] = (X509CRL) certfac.generateCRL(bais);
376                         bais.close();
377                         bais = null;
378                     }
379                 } catch (CRLException e) {
380                     ParsingException pe =
381                         new ParsingException(e.getMessage());
</pre>
</td>
</tr>
</table>
<center><a href="../../../java/security/cert/PolicyQualifierInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PKCS8Key.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
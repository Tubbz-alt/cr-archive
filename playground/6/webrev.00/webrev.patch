diff a/src/java.base/share/classes/com/sun/crypto/provider/DHPrivateKey.java b/src/java.base/share/classes/com/sun/crypto/provider/DHPrivateKey.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/DHPrivateKey.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/DHPrivateKey.java
@@ -202,50 +202,46 @@
     /**
      * Get the encoding of the key.
      */
     public synchronized byte[] getEncoded() {
         if (this.encodedKey == null) {
-            try {
-                DerOutputStream tmp = new DerOutputStream();
+            DerOutputStream tmp = new DerOutputStream();
 
-                //
-                // version
-                //
-                tmp.putInteger(PKCS8_VERSION);
-
-                //
-                // privateKeyAlgorithm
-                //
-                DerOutputStream algid = new DerOutputStream();
+            //
+            // version
+            //
+            tmp.putInteger(PKCS8_VERSION);
 
-                // store OID
-                algid.putOID(DHPublicKey.DH_OID);
-                // encode parameters
-                DerOutputStream params = new DerOutputStream();
-                params.putInteger(this.p);
-                params.putInteger(this.g);
-                if (this.l != 0) {
-                    params.putInteger(this.l);
-                }
-                // wrap parameters into SEQUENCE
-                DerValue paramSequence = new DerValue(DerValue.tag_Sequence,
-                                                      params.toByteArray());
-                // store parameter SEQUENCE in algid
-                algid.putDerValue(paramSequence);
-                // wrap algid into SEQUENCE
-                tmp.write(DerValue.tag_Sequence, algid);
+            //
+            // privateKeyAlgorithm
+            //
+            DerOutputStream algid = new DerOutputStream();
+
+            // store OID
+            algid.putOID(DHPublicKey.DH_OID);
+            // encode parameters
+            DerOutputStream params = new DerOutputStream();
+            params.putInteger(this.p);
+            params.putInteger(this.g);
+            if (this.l != 0) {
+                params.putInteger(this.l);
+            }
+            // wrap parameters into SEQUENCE
+            DerValue paramSequence = new DerValue(DerValue.tag_Sequence,
+                    params.toByteArray());
+            // store parameter SEQUENCE in algid
+            algid.putDerValue(paramSequence);
+            // wrap algid into SEQUENCE
+            tmp.write(DerValue.tag_Sequence, algid);
 
-                // privateKey
-                tmp.putOctetString(this.key);
+            // privateKey
+            tmp.putOctetString(this.key);
 
-                // make it a SEQUENCE
-                DerOutputStream derKey = new DerOutputStream();
-                derKey.write(DerValue.tag_Sequence, tmp);
-                this.encodedKey = derKey.toByteArray();
-            } catch (IOException e) {
-                return null;
-            }
+            // make it a SEQUENCE
+            DerOutputStream derKey = new DerOutputStream();
+            derKey.write(DerValue.tag_Sequence, tmp);
+            this.encodedKey = derKey.toByteArray();
         }
         return this.encodedKey.clone();
     }
 
     /**
diff a/src/java.base/share/classes/com/sun/crypto/provider/DHPublicKey.java b/src/java.base/share/classes/com/sun/crypto/provider/DHPublicKey.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/DHPublicKey.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/DHPublicKey.java
@@ -199,43 +199,39 @@
     /**
      * Get the encoding of the key.
      */
     public synchronized byte[] getEncoded() {
         if (this.encodedKey == null) {
-            try {
-                DerOutputStream algid = new DerOutputStream();
+            DerOutputStream algid = new DerOutputStream();
 
-                // store oid in algid
-                algid.putOID(DH_OID);
+            // store oid in algid
+            algid.putOID(DH_OID);
 
-                // encode parameters
-                DerOutputStream params = new DerOutputStream();
-                params.putInteger(this.p);
-                params.putInteger(this.g);
-                if (this.l != 0) {
-                    params.putInteger(this.l);
-                }
-                // wrap parameters into SEQUENCE
-                DerValue paramSequence = new DerValue(DerValue.tag_Sequence,
-                                                      params.toByteArray());
-                // store parameter SEQUENCE in algid
-                algid.putDerValue(paramSequence);
+            // encode parameters
+            DerOutputStream params = new DerOutputStream();
+            params.putInteger(this.p);
+            params.putInteger(this.g);
+            if (this.l != 0) {
+                params.putInteger(this.l);
+            }
+            // wrap parameters into SEQUENCE
+            DerValue paramSequence = new DerValue(DerValue.tag_Sequence,
+                    params.toByteArray());
+            // store parameter SEQUENCE in algid
+            algid.putDerValue(paramSequence);
 
-                // wrap algid into SEQUENCE, and store it in key encoding
-                DerOutputStream tmpDerKey = new DerOutputStream();
-                tmpDerKey.write(DerValue.tag_Sequence, algid);
+            // wrap algid into SEQUENCE, and store it in key encoding
+            DerOutputStream tmpDerKey = new DerOutputStream();
+            tmpDerKey.write(DerValue.tag_Sequence, algid);
 
-                // store key data
-                tmpDerKey.putBitString(this.key);
+            // store key data
+            tmpDerKey.putBitString(this.key);
 
-                // wrap algid and key into SEQUENCE
-                DerOutputStream derKey = new DerOutputStream();
-                derKey.write(DerValue.tag_Sequence, tmpDerKey);
-                this.encodedKey = derKey.toByteArray();
-            } catch (IOException e) {
-                return null;
-            }
+            // wrap algid and key into SEQUENCE
+            DerOutputStream derKey = new DerOutputStream();
+            derKey.write(DerValue.tag_Sequence, tmpDerKey);
+            this.encodedKey = derKey.toByteArray();
         }
         return this.encodedKey.clone();
     }
 
     /**
diff a/src/java.base/share/classes/com/sun/crypto/provider/EncryptedPrivateKeyInfo.java b/src/java.base/share/classes/com/sun/crypto/provider/EncryptedPrivateKeyInfo.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/EncryptedPrivateKeyInfo.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/EncryptedPrivateKeyInfo.java
@@ -114,11 +114,11 @@
 
         DerOutputStream out = new DerOutputStream();
         DerOutputStream tmp = new DerOutputStream();
 
         // encode encryption algorithm
-        algid.encode(tmp);
+        algid.derEncode(tmp);
 
         // encode encrypted data
         tmp.putOctetString(encryptedData);
 
         // wrap everything into a SEQUENCE
diff a/src/java.base/share/classes/com/sun/crypto/provider/OAEPParameters.java b/src/java.base/share/classes/com/sun/crypto/provider/OAEPParameters.java
--- a/src/java.base/share/classes/com/sun/crypto/provider/OAEPParameters.java
+++ b/src/java.base/share/classes/com/sun/crypto/provider/OAEPParameters.java
@@ -195,11 +195,11 @@
             mgfDigestId = AlgorithmId.get(mgfSpec.getDigestAlgorithm());
         } catch (NoSuchAlgorithmException nase) {
             throw new IOException("AlgorithmId " +
                     mgfSpec.getDigestAlgorithm() + " impl not found");
         }
-        mgfDigestId.encode(tmp2);
+        mgfDigestId.derEncode(tmp2);
         tmp3 = new DerOutputStream();
         tmp3.write(DerValue.tag_Sequence, tmp2);
         tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)1),
                   tmp3);
 
diff a/src/java.base/share/classes/javax/crypto/EncryptedPrivateKeyInfo.java b/src/java.base/share/classes/javax/crypto/EncryptedPrivateKeyInfo.java
--- a/src/java.base/share/classes/javax/crypto/EncryptedPrivateKeyInfo.java
+++ b/src/java.base/share/classes/javax/crypto/EncryptedPrivateKeyInfo.java
@@ -382,11 +382,11 @@
         if (this.encoded == null) {
             DerOutputStream out = new DerOutputStream();
             DerOutputStream tmp = new DerOutputStream();
 
             // encode encryption algorithm
-            algid.encode(tmp);
+            algid.derEncode(tmp);
 
             // encode encrypted data
             tmp.putOctetString(encryptedData);
 
             // wrap everything into a SEQUENCE
diff a/src/java.base/share/classes/sun/security/pkcs/EncryptedPrivateKeyInfo.java b/src/java.base/share/classes/sun/security/pkcs/EncryptedPrivateKeyInfo.java
--- a/src/java.base/share/classes/sun/security/pkcs/EncryptedPrivateKeyInfo.java
+++ b/src/java.base/share/classes/sun/security/pkcs/EncryptedPrivateKeyInfo.java
@@ -122,11 +122,11 @@
 
         DerOutputStream out = new DerOutputStream();
         DerOutputStream tmp = new DerOutputStream();
 
         // encode encryption algorithm
-        algid.encode(tmp);
+        algid.derEncode(tmp);
 
         // encode encrypted data
         tmp.putOctetString(encryptedData);
 
         // wrap everything into a SEQUENCE
diff a/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java b/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java
--- a/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java
+++ b/src/java.base/share/classes/sun/security/pkcs/PKCS8Key.java
@@ -206,22 +206,17 @@
      *
      * @exception InvalidKeyException if an encoding error occurs.
      */
     private void encode() throws InvalidKeyException {
         if (encodedKey == null) {
-            try {
-                DerOutputStream out = new DerOutputStream ();
-                DerOutputStream tmp = new DerOutputStream();
-                tmp.putInteger(V1);
-                algid.encode(tmp);
-                tmp.putOctetString(key);
-                out.write(DerValue.tag_Sequence, tmp);
-                encodedKey = out.toByteArray();
-            } catch (IOException e) {
-                throw new InvalidKeyException ("IOException : " +
-                                               e.getMessage());
-            }
+            DerOutputStream out = new DerOutputStream();
+            DerOutputStream tmp = new DerOutputStream();
+            tmp.putInteger(V1);
+            algid.derEncode(tmp);
+            tmp.putOctetString(key);
+            out.write(DerValue.tag_Sequence, tmp);
+            encodedKey = out.toByteArray();
         }
     }
 
     @java.io.Serial
     protected Object writeReplace() throws java.io.ObjectStreamException {
diff a/src/java.base/share/classes/sun/security/pkcs/PKCS9Attribute.java b/src/java.base/share/classes/sun/security/pkcs/PKCS9Attribute.java
--- a/src/java.base/share/classes/sun/security/pkcs/PKCS9Attribute.java
+++ b/src/java.base/share/classes/sun/security/pkcs/PKCS9Attribute.java
@@ -498,11 +498,11 @@
      * ChallengePassword and UnstructuredAddress attributes as ASN.1
      * <code>PrintableString</code>s, without checking whether they
      * should be encoded as <code>T61String</code>s.
      */
     @Override
-    public void derEncode(OutputStream out) throws IOException {
+    public void derEncode(DerOutputStream out) {
         DerOutputStream temp = new DerOutputStream();
         temp.putOID(oid);
         switch (index) {
         case -1:    // Unknown
             temp.write((byte[])value);
@@ -571,44 +571,44 @@
                 temp.putOrderedSetOf(DerValue.tag_Set, temps);
             } // close scope
             break;
 
         case 9:     // extended-certificate attribute -- not supported
-            throw new IOException("PKCS9 extended-certificate " +
+            throw new UnsupportedOperationException("PKCS9 extended-certificate " +
                                   "attribute not supported.");
             // break unnecessary
         case 10:    // issuerAndserialNumber attribute -- not supported
-            throw new IOException("PKCS9 IssuerAndSerialNumber" +
+            throw new UnsupportedOperationException("PKCS9 IssuerAndSerialNumber" +
                                   "attribute not supported.");
             // break unnecessary
         case 11:    // RSA DSI proprietary
         case 12:    // RSA DSI proprietary
-            throw new IOException("PKCS9 RSA DSI attributes" +
+            throw new UnsupportedOperationException("PKCS9 RSA DSI attributes" +
                                   "11 and 12, not supported.");
             // break unnecessary
         case 13:    // S/MIME unused attribute
-            throw new IOException("PKCS9 attribute #13 not supported.");
+            throw new UnsupportedOperationException("PKCS9 attribute #13 not supported.");
             // break unnecessary
 
         case 14:     // ExtensionRequest
             {
                 DerOutputStream temp2 = new DerOutputStream();
                 CertificateExtensions exts = (CertificateExtensions)value;
                 try {
                     exts.encode(temp2, true);
                 } catch (CertificateException ex) {
-                    throw new IOException(ex.toString());
+                    throw new IllegalArgumentException(ex.toString());
                 }
                 temp.write(DerValue.tag_Set, temp2.toByteArray());
             }
             break;
         case 15:    // SMIMECapability
-            throw new IOException("PKCS9 attribute #15 not supported.");
+            throw new UnsupportedOperationException("PKCS9 attribute #15 not supported.");
             // break unnecessary
 
         case 16:    // SigningCertificate
-            throw new IOException(
+            throw new UnsupportedOperationException(
                 "PKCS9 SigningCertificate attribute not supported.");
             // break unnecessary
 
         case 17:    // SignatureTimestampToken
             temp.write(DerValue.tag_Set, (byte[])value);
diff a/src/java.base/share/classes/sun/security/pkcs/PKCS9Attributes.java b/src/java.base/share/classes/sun/security/pkcs/PKCS9Attributes.java
--- a/src/java.base/share/classes/sun/security/pkcs/PKCS9Attributes.java
+++ b/src/java.base/share/classes/sun/security/pkcs/PKCS9Attributes.java
@@ -232,11 +232,11 @@
      * @param tag the implicit tag to use in the DER encoding.
      * @param out the output stream on which to put the DER encoding.
      *
      * @exception IOException  on output error.
      */
-    public void encode(byte tag, OutputStream out) throws IOException {
+    public void encode(byte tag, DerOutputStream out) {
         out.write(tag);
         out.write(derEncoding, 1, derEncoding.length -1);
     }
 
     private byte[] generateDerEncoding() throws IOException {
diff a/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java b/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java
--- a/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java
+++ b/src/java.base/share/classes/sun/security/pkcs/SignerInfo.java
@@ -23,11 +23,10 @@
  * questions.
  */
 
 package sun.security.pkcs;
 
-import java.io.OutputStream;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.security.cert.CertPathValidatorException;
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
@@ -195,39 +194,35 @@
         if (derin.available() != 0) {
             throw new ParsingException("extra data at the end");
         }
     }
 
-    public void encode(DerOutputStream out) throws IOException {
-
-        derEncode(out);
-    }
-
     /**
      * DER encode this object onto an output stream.
      * Implements the {@code DerEncoder} interface.
      *
      * @param out
      * the output stream on which to write the DER encoding.
      *
      * @exception IOException on encoding error.
      */
-    public void derEncode(OutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         DerOutputStream seq = new DerOutputStream();
         seq.putInteger(version);
         DerOutputStream issuerAndSerialNumber = new DerOutputStream();
-        issuerName.encode(issuerAndSerialNumber);
+        issuerName.derEncode(issuerAndSerialNumber);
         issuerAndSerialNumber.putInteger(certificateSerialNumber);
         seq.write(DerValue.tag_Sequence, issuerAndSerialNumber);
 
-        digestAlgorithmId.encode(seq);
+        digestAlgorithmId.derEncode(seq);
 
         // encode authenticated attributes if there are any
         if (authenticatedAttributes != null)
             authenticatedAttributes.encode((byte)0xA0, seq);
 
-        digestEncryptionAlgorithmId.encode(seq);
+        digestEncryptionAlgorithmId.derEncode(seq);
 
         seq.putOctetString(encryptedDigest);
 
         // encode unauthenticated attributes if there are any
         if (unauthenticatedAttributes != null)
diff a/src/java.base/share/classes/sun/security/pkcs10/PKCS10.java b/src/java.base/share/classes/sun/security/pkcs10/PKCS10.java
--- a/src/java.base/share/classes/sun/security/pkcs10/PKCS10.java
+++ b/src/java.base/share/classes/sun/security/pkcs10/PKCS10.java
@@ -208,13 +208,13 @@
         /*
          * Encode cert request info, wrap in a sequence for signing
          */
         scratch = new DerOutputStream();
         scratch.putInteger(BigInteger.ZERO);            // PKCS #10 v1.0
-        subject.encode(scratch);                        // X.500 name
+        subject.derEncode(scratch);                        // X.500 name
         scratch.write(subjectPublicKeyInfo.getEncoded()); // public key
-        attributeSet.encode(scratch);
+        attributeSet.derEncode(scratch);
 
         out = new DerOutputStream();
         out.write(DerValue.tag_Sequence, scratch);      // wrap it!
         certificateRequestInfo = out.toByteArray();
         scratch = out;
@@ -238,11 +238,11 @@
                     : AlgorithmId.get(params);
         } catch (NoSuchAlgorithmException nsae) {
             throw new SignatureException(nsae);
         }
 
-        algId.encode(scratch);     // sig algorithm
+        algId.derEncode(scratch);     // sig algorithm
         scratch.putBitString(sig);                      // sig
 
         /*
          * Wrap those guts in a sequence
          */
diff a/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attribute.java b/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attribute.java
--- a/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attribute.java
+++ b/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attribute.java
@@ -106,11 +106,12 @@
      * @param out
      * the OutputStream on which to write the DER encoding.
      *
      * @exception IOException on encoding errors.
      */
-    public void derEncode(OutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         PKCS9Attribute attr = new PKCS9Attribute(attributeId, attributeValue);
         attr.derEncode(out);
     }
 
     /**
diff a/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attributes.java b/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attributes.java
--- a/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attributes.java
+++ b/src/java.base/share/classes/sun/security/pkcs10/PKCS10Attributes.java
@@ -84,28 +84,19 @@
             PKCS10Attribute attr = new PKCS10Attribute(attrs[i]);
             map.put(attr.getAttributeId().toString(), attr);
         }
     }
 
-    /**
-     * Encode the attributes in DER form to the stream.
-     *
-     * @param out the OutputStream to marshal the contents to.
-     * @exception IOException on encoding errors.
-     */
-    public void encode(OutputStream out) throws IOException {
-        derEncode(out);
-    }
-
     /**
      * Encode the attributes in DER form to the stream.
      * Implements the {@code DerEncoder} interface.
      *
      * @param out the OutputStream to marshal the contents to.
      * @exception IOException on encoding errors.
      */
-    public void derEncode(OutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         // first copy the elements into an array
         Collection<PKCS10Attribute> allAttrs = map.values();
         PKCS10Attribute[] attribs =
                 allAttrs.toArray(new PKCS10Attribute[map.size()]);
 
diff a/src/java.base/share/classes/sun/security/pkcs12/MacData.java b/src/java.base/share/classes/sun/security/pkcs12/MacData.java
--- a/src/java.base/share/classes/sun/security/pkcs12/MacData.java
+++ b/src/java.base/share/classes/sun/security/pkcs12/MacData.java
@@ -173,11 +173,11 @@
         DerOutputStream tmp = new DerOutputStream();
 
         DerOutputStream tmp2 = new DerOutputStream();
         // encode encryption algorithm
         AlgorithmId algid = AlgorithmId.get(digestAlgorithmName);
-        algid.encode(tmp2);
+        algid.derEncode(tmp2);
 
         // encode digest data
         tmp2.putOctetString(digest);
 
         tmp.write(DerValue.tag_Sequence, tmp2);
diff a/src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java b/src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java
--- a/src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java
+++ b/src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java
@@ -639,11 +639,11 @@
                 // Encode secret key in a PKCS#8
                 DerOutputStream pkcs8 = new DerOutputStream();
                 DerOutputStream secretKeyInfo = new DerOutputStream();
                 secretKeyInfo.putInteger(0);
                 AlgorithmId algId = AlgorithmId.get(key.getAlgorithm());
-                algId.encode(secretKeyInfo);
+                algId.derEncode(secretKeyInfo);
                 secretKeyInfo.putOctetString(key.getEncoded());
                 pkcs8.write(DerValue.tag_Sequence, secretKeyInfo);
 
                 // Encrypt the secret key (using same PBE as for private keys)
                 keyEntry.protectedSecretKey =
@@ -1888,11 +1888,11 @@
 
             AlgorithmId algId = new AlgorithmId(
                     mapPBEAlgorithmToOID(certProtectionAlgorithm),
                     cipher.getParameters());
                     // cipher.getParameters() now has IV
-            algId.encode(bytes);
+            algId.derEncode(bytes);
             byte[] encodedAlgId = bytes.toByteArray();
 
             if (debug != null) {
                 debug.println("  (Cipher algorithm: " + cipher.getAlgorithm() +
                         ")");
diff a/src/java.base/share/classes/sun/security/provider/certpath/CertId.java b/src/java.base/share/classes/sun/security/provider/certpath/CertId.java
--- a/src/java.base/share/classes/sun/security/provider/certpath/CertId.java
+++ b/src/java.base/share/classes/sun/security/provider/certpath/CertId.java
@@ -155,11 +155,11 @@
      * The hash algorithm used is SHA-1.
      */
     public void encode(DerOutputStream out) throws IOException {
 
         DerOutputStream tmp = new DerOutputStream();
-        hashAlgId.encode(tmp);
+        hashAlgId.derEncode(tmp);
         tmp.putOctetString(issuerNameHash);
         tmp.putOctetString(issuerKeyHash);
         certSerialNumber.encode(tmp);
         out.write(DerValue.tag_Sequence, tmp);
 
diff a/src/java.base/share/classes/sun/security/provider/certpath/X509CertPath.java b/src/java.base/share/classes/sun/security/provider/certpath/X509CertPath.java
--- a/src/java.base/share/classes/sun/security/provider/certpath/X509CertPath.java
+++ b/src/java.base/share/classes/sun/security/provider/certpath/X509CertPath.java
@@ -287,35 +287,29 @@
      * @exception CertificateEncodingException if an exception occurs
      */
     private byte[] encodePKIPATH() throws CertificateEncodingException {
 
         ListIterator<X509Certificate> li = certs.listIterator(certs.size());
-        try {
-            DerOutputStream bytes = new DerOutputStream();
-            // encode certs in reverse order (trust anchor to target)
-            // according to PkiPath format
-            while (li.hasPrevious()) {
-                X509Certificate cert = li.previous();
-                // check for duplicate cert
-                if (certs.lastIndexOf(cert) != certs.indexOf(cert)) {
-                    throw new CertificateEncodingException
-                        ("Duplicate Certificate");
-                }
-                // get encoded certificates
-                byte[] encoded = cert.getEncoded();
-                bytes.write(encoded);
+        DerOutputStream bytes = new DerOutputStream();
+        // encode certs in reverse order (trust anchor to target)
+        // according to PkiPath format
+        while (li.hasPrevious()) {
+            X509Certificate cert = li.previous();
+            // check for duplicate cert
+            if (certs.lastIndexOf(cert) != certs.indexOf(cert)) {
+                throw new CertificateEncodingException
+                    ("Duplicate Certificate");
             }
-
-            // Wrap the data in a SEQUENCE
-            DerOutputStream derout = new DerOutputStream();
-            derout.write(DerValue.tag_SequenceOf, bytes);
-            return derout.toByteArray();
-
-        } catch (IOException ioe) {
-           throw new CertificateEncodingException("IOException encoding " +
-                   "PkiPath data: " + ioe, ioe);
+            // get encoded certificates
+            byte[] encoded = cert.getEncoded();
+            bytes.write(encoded);
         }
+
+        // Wrap the data in a SEQUENCE
+        DerOutputStream derout = new DerOutputStream();
+        derout.write(DerValue.tag_SequenceOf, bytes);
+        return derout.toByteArray();
     }
 
     /**
      * Encode the CertPath using PKCS#7 format.
      *
diff a/src/java.base/share/classes/sun/security/rsa/PSSParameters.java b/src/java.base/share/classes/sun/security/rsa/PSSParameters.java
--- a/src/java.base/share/classes/sun/security/rsa/PSSParameters.java
+++ b/src/java.base/share/classes/sun/security/rsa/PSSParameters.java
@@ -241,11 +241,11 @@
         }
 
         if (!mgfDigestId.getOID().equals(AlgorithmId.SHA_oid)) {
             tmp2 = new DerOutputStream();
             tmp2.putOID(AlgorithmId.MGF1_oid);
-            mgfDigestId.encode(tmp2);
+            mgfDigestId.derEncode(tmp2);
             tmp3 = new DerOutputStream();
             tmp3.write(DerValue.tag_Sequence, tmp2);
             tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte) 1),
                     tmp3);
         }
diff a/src/java.base/share/classes/sun/security/rsa/RSASignature.java b/src/java.base/share/classes/sun/security/rsa/RSASignature.java
--- a/src/java.base/share/classes/sun/security/rsa/RSASignature.java
+++ b/src/java.base/share/classes/sun/security/rsa/RSASignature.java
@@ -234,11 +234,11 @@
      * Also used by the PKCS#11 provider.
      */
     public static byte[] encodeSignature(ObjectIdentifier oid, byte[] digest)
             throws IOException {
         DerOutputStream out = new DerOutputStream();
-        new AlgorithmId(oid).encode(out);
+        new AlgorithmId(oid).derEncode(out);
         out.putOctetString(digest);
         DerValue result =
             new DerValue(DerValue.tag_Sequence, out.toByteArray());
         return result.toByteArray();
     }
diff a/src/java.base/share/classes/sun/security/timestamp/TSRequest.java b/src/java.base/share/classes/sun/security/timestamp/TSRequest.java
--- a/src/java.base/share/classes/sun/security/timestamp/TSRequest.java
+++ b/src/java.base/share/classes/sun/security/timestamp/TSRequest.java
@@ -154,11 +154,11 @@
         // encode version
         request.putInteger(version);
 
         // encode messageImprint
         DerOutputStream messageImprint = new DerOutputStream();
-        hashAlgorithmId.encode(messageImprint);
+        hashAlgorithmId.derEncode(messageImprint);
         messageImprint.putOctetString(hashValue);
         request.write(DerValue.tag_Sequence, messageImprint);
 
         // encode optional elements
 
diff a/src/java.base/share/classes/sun/security/util/DerEncoder.java b/src/java.base/share/classes/sun/security/util/DerEncoder.java
--- a/src/java.base/share/classes/sun/security/util/DerEncoder.java
+++ b/src/java.base/share/classes/sun/security/util/DerEncoder.java
@@ -24,11 +24,10 @@
  */
 
 package sun.security.util;
 
 import java.io.IOException;
-import java.io.OutputStream;
 
 /**
  * Interface to an object that knows how to write its own DER
  * encoding to an output stream.
  *
@@ -39,9 +38,8 @@
     /**
      * DER encode this object and write the results to a stream.
      *
      * @param out  the stream on which the DER encoding is written.
      */
-    public void derEncode(OutputStream out)
-        throws IOException;
+    void derEncode(DerOutputStream out);
 
 }
diff a/src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java b/src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java
--- a/src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java
+++ b/src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -34,47 +34,51 @@
  * A package private utility class to convert indefinite length DER
  * encoded byte arrays to definite length DER encoded byte arrays.
  *
  * This assumes that the basic data structure is "tag, length, value"
  * triplet. In the case where the length is "indefinite", terminating
- * end-of-contents bytes are expected.
+ * end-of-contents bytes (EOC) are expected.
  *
  * @author Hemma Prafullchandra
  */
 class DerIndefLenConverter {
 
-    private static final int TAG_MASK            = 0x1f; // bits 5-1
-    private static final int FORM_MASK           = 0x20; // bits 6
-    private static final int CLASS_MASK          = 0xC0; // bits 8 and 7
-
     private static final int LEN_LONG            = 0x80; // bit 8 set
     private static final int LEN_MASK            = 0x7f; // bits 7 - 1
-    private static final int SKIP_EOC_BYTES      = 2;
 
-    private byte[] data, newData;
+    private final byte[] data;
+
+    private byte[] newData;
     private int newDataPos, dataPos, dataSize, index;
     private int unresolved = 0;
 
-    private ArrayList<Object> ndefsList = new ArrayList<Object>();
+    // After an indefinite length is seen, the current dataPos is added in this
+    // list. When its matching EOC is seen, the dataPos is substituted into the
+    // calculated definite length.
+    private ArrayList<Object> ndefsList = new ArrayList<>();
 
-    private int numOfTotalLenBytes = 0;
+    // The total length change between the original encoding and the new
+    // encoding. Each change is a "80 00 00" to a definite length.
+    private int totalLengthChange = 0;
 
     private boolean isEOC(int tag) {
-        return (((tag & TAG_MASK) == 0x00) &&  // EOC
-                ((tag & FORM_MASK) == 0x00) && // primitive
-                ((tag & CLASS_MASK) == 0x00)); // universal
+        return tag == 0;
     }
 
     // if bit 8 is set then it implies either indefinite length or long form
-    static boolean isLongForm(int lengthByte) {
+    private static boolean isLongForm(int lengthByte) {
         return ((lengthByte & LEN_LONG) == LEN_LONG);
     }
 
     /*
-     * Default package private constructor
+     * private constructor
      */
-    DerIndefLenConverter() { }
+    private DerIndefLenConverter(byte[] indefData) {
+        data = indefData;
+        dataPos=0;
+        dataSize = data.length;
+    }
 
     /**
      * Checks whether the given length byte is of the form
      * <em>Indefinite</em>.
      *
@@ -86,80 +90,82 @@
     static boolean isIndefinite(int lengthByte) {
         return (isLongForm(lengthByte) && ((lengthByte & LEN_MASK) == 0));
     }
 
     /**
-     * Parse the tag and if it is an end-of-contents tag then
-     * add the current position to the <code>eocList</code> vector.
+     * Parse the tag. If it is EOC then substitute the dataPos of its matching
+     * indefinite length in {@code ndefsList} to a definite length.
      */
     private void parseTag() throws IOException {
         if (isEOC(data[dataPos]) && (data[dataPos + 1] == 0)) {
-            int numOfEncapsulatedLenBytes = 0;
+            int lengthChanged = 0;
             Object elem = null;
-            int index;
-            for (index = ndefsList.size()-1; index >= 0; index--) {
-                // Determine the first element in the vector that does not
-                // have a matching EOC
-                elem = ndefsList.get(index);
+            int i;
+            for (i = ndefsList.size() - 1; i  >= 0; i--) {
+                elem = ndefsList.get(i);
                 if (elem instanceof Integer) {
+                    // Most recent dataPos that does not have a matching EOC
                     break;
                 } else {
-                    numOfEncapsulatedLenBytes += ((byte[])elem).length - 3;
+                    // For matched EOCs, cumulate the length changes
+                    lengthChanged += ((byte[])elem).length - 3;
                 }
             }
-            if (index < 0) {
+            if (i < 0) {
                 throw new IOException("EOC does not have matching " +
                                       "indefinite-length tag");
             }
-            int sectionLen = dataPos - ((Integer)elem).intValue() +
-                             numOfEncapsulatedLenBytes;
+            int sectionLen = dataPos - (Integer)elem + lengthChanged;
             byte[] sectionLenBytes = getLengthBytes(sectionLen);
-            ndefsList.set(index, sectionLenBytes);
+            ndefsList.set(i, sectionLenBytes);
             unresolved--;
 
             // Add the number of bytes required to represent this section
             // to the total number of length bytes,
             // and subtract the indefinite-length tag (1 byte) and
             // EOC bytes (2 bytes) for this section
-            numOfTotalLenBytes += (sectionLenBytes.length - 3);
+            totalLengthChange += (sectionLenBytes.length - 3);
         }
         dataPos++;
     }
 
     /**
-     * Write the tag and if it is an end-of-contents tag
-     * then skip the tag and its 1 byte length of zero.
+     * Copy the next tag from data to newData, skipping zero or more EOC.
      */
     private void writeTag() {
-        if (dataPos == dataSize)
-            return;
         int tag = data[dataPos++];
         if (isEOC(tag) && (data[dataPos] == 0)) {
             dataPos++;  // skip length
+            if (dataPos == dataSize) {
+                return;
+            }
             writeTag();
-        } else
-            newData[newDataPos++] = (byte)tag;
+        } else {
+            newData[newDataPos++] = (byte) tag;
+        }
     }
 
     /**
      * Parse the length and if it is an indefinite length then add
-     * the current position to the <code>ndefsList</code> vector.
+     * the current position to the {@code ndefsList} list.
      *
      * @return the length of definite length data next, or -1 if there is
      *         not enough bytes to determine it
      * @throws IOException if invalid data is read
      */
     private int parseLength() throws IOException {
-        int curLen = 0;
-        if (dataPos == dataSize)
-            return curLen;
+        if (dataPos == dataSize) {
+            // TODO if not enough bytes here, will this fail?
+            return 0;
+        }
         int lenByte = data[dataPos++] & 0xff;
         if (isIndefinite(lenByte)) {
             ndefsList.add(dataPos);
             unresolved++;
-            return curLen;
+            return 0;
         }
+        int curLen = 0;
         if (isLongForm(lenByte)) {
             lenByte &= LEN_MASK;
             if (lenByte > 4) {
                 throw new IOException("Too much data");
             }
@@ -178,17 +184,18 @@
         return curLen;
     }
 
     /**
      * Write the length and if it is an indefinite length
-     * then calculate the definite length from the positions
-     * of the indefinite length and its matching EOC terminator.
+     * then write the definite length in {@code ndefsList}.
      * Then, write the value.
      */
     private void writeLengthAndValue() throws IOException {
-        if (dataPos == dataSize)
-           return;
+        if (dataPos == dataSize) {
+            // happens when an EOC at the end is read
+            return;
+        }
         int curLen = 0;
         int lenByte = data[dataPos++] & 0xff;
         if (isIndefinite(lenByte)) {
             byte[] lenBytes = (byte[])ndefsList.get(index++);
             System.arraycopy(lenBytes, 0, newData, newDataPos,
@@ -239,65 +246,46 @@
         }
     }
 
     private byte[] getLengthBytes(int curLen) {
         byte[] lenBytes;
-        int index = 0;
+        int i = 0;
 
         if (curLen < 128) {
             lenBytes = new byte[1];
-            lenBytes[index++] = (byte)curLen;
+            lenBytes[i++] = (byte)curLen;
 
         } else if (curLen < (1 << 8)) {
             lenBytes = new byte[2];
-            lenBytes[index++] = (byte)0x81;
-            lenBytes[index++] = (byte)curLen;
+            lenBytes[i++] = (byte)0x81;
+            lenBytes[i++] = (byte)curLen;
 
         } else if (curLen < (1 << 16)) {
             lenBytes = new byte[3];
-            lenBytes[index++] = (byte)0x82;
-            lenBytes[index++] = (byte)(curLen >> 8);
-            lenBytes[index++] = (byte)curLen;
+            lenBytes[i++] = (byte)0x82;
+            lenBytes[i++] = (byte)(curLen >> 8);
+            lenBytes[i++] = (byte)curLen;
 
         } else if (curLen < (1 << 24)) {
             lenBytes = new byte[4];
-            lenBytes[index++] = (byte)0x83;
-            lenBytes[index++] = (byte)(curLen >> 16);
-            lenBytes[index++] = (byte)(curLen >> 8);
-            lenBytes[index++] = (byte)curLen;
+            lenBytes[i++] = (byte)0x83;
+            lenBytes[i++] = (byte)(curLen >> 16);
+            lenBytes[i++] = (byte)(curLen >> 8);
+            lenBytes[i++] = (byte)curLen;
 
         } else {
             lenBytes = new byte[5];
-            lenBytes[index++] = (byte)0x84;
-            lenBytes[index++] = (byte)(curLen >> 24);
-            lenBytes[index++] = (byte)(curLen >> 16);
-            lenBytes[index++] = (byte)(curLen >> 8);
-            lenBytes[index++] = (byte)curLen;
+            lenBytes[i++] = (byte)0x84;
+            lenBytes[i++] = (byte)(curLen >> 24);
+            lenBytes[i++] = (byte)(curLen >> 16);
+            lenBytes[i++] = (byte)(curLen >> 8);
+            lenBytes[i++] = (byte)curLen;
         }
 
         return lenBytes;
     }
 
-    // Returns the number of bytes needed to represent the given length
-    // in ASN.1 notation
-    private int getNumOfLenBytes(int len) {
-        int numOfLenBytes = 0;
-
-        if (len < 128) {
-            numOfLenBytes = 1;
-        } else if (len < (1 << 8)) {
-            numOfLenBytes = 2;
-        } else if (len < (1 << 16)) {
-            numOfLenBytes = 3;
-        } else if (len < (1 << 24)) {
-            numOfLenBytes = 4;
-        } else {
-            numOfLenBytes = 5;
-        }
-        return numOfLenBytes;
-    }
-
     /**
      * Parse the value;
      */
     private void parseValue(int curLen) {
         dataPos += curLen;
@@ -305,39 +293,26 @@
 
     /**
      * Write the value;
      */
     private void writeValue(int curLen) {
-        for (int i=0; i < curLen; i++)
-            newData[newDataPos++] = data[dataPos++];
+        System.arraycopy(data, dataPos, newData, newDataPos, curLen);
+        dataPos += curLen;
+        newDataPos += curLen;
     }
 
-    /**
-     * Converts a indefinite length DER encoded byte array to
-     * a definte length DER encoding.
-     *
-     * @param indefData the byte array holding the indefinite
-     *        length encoding.
-     * @return the byte array containing the definite length
-     *         DER encoding, or null if there is not enough data.
-     * @exception IOException on parsing or re-writing errors.
-     */
-    byte[] convertBytes(byte[] indefData) throws IOException {
-        data = indefData;
-        dataPos=0; index=0;
-        dataSize = data.length;
-        int len=0;
+    private byte[] convertBytesInternal() throws IOException {
         int unused = 0;
 
-        // parse and set up the vectors of all the indefinite-lengths
+        // parse and set up the list of all the indefinite-lengths
         while (dataPos < dataSize) {
             if (dataPos + 2 > dataSize) {
                 // There should be at least one tag and one length
                 return null;
             }
             parseTag();
-            len = parseLength();
+            int len = parseLength();
             if (len < 0) {
                 return null;
             }
             parseValue(len);
             if (unresolved == 0) {
@@ -349,25 +324,39 @@
 
         if (unresolved != 0) {
             return null;
         }
 
-        newData = new byte[dataSize + numOfTotalLenBytes + unused];
+        newData = new byte[dataSize + totalLengthChange + unused];
         dataPos=0; newDataPos=0; index=0;
 
         // write out the new byte array replacing all the indefinite-lengths
         // and EOCs
         while (dataPos < dataSize) {
            writeTag();
            writeLengthAndValue();
         }
-        System.arraycopy(indefData, dataSize,
-                         newData, dataSize + numOfTotalLenBytes, unused);
+        System.arraycopy(data, dataSize,
+                         newData, dataSize + totalLengthChange, unused);
 
         return newData;
     }
 
+    /**
+     * Converts a indefinite length DER encoded byte array to
+     * a definte length DER encoding.
+     *
+     * @param indefData the byte array holding the indefinite
+     *        length encoding.
+     * @return the byte array containing the definite length
+     *         DER encoding, or null if there is not enough data.
+     * @exception IOException on parsing or re-writing errors.
+     */
+    public static byte[] convertBytes(byte[] indefData) throws IOException {
+        return new DerIndefLenConverter(indefData).convertBytesInternal();
+    }
+
     /**
      * Read the input stream into a DER byte array. If an indef len BER is
      * not resolved this method will try to read more data until EOF is reached.
      * This may block.
      *
@@ -389,12 +378,11 @@
             int bytesRead = in.readNBytes(indefData, offset, readLen);
             if (bytesRead != readLen) {
                 readLen = bytesRead;
                 indefData = Arrays.copyOf(indefData, offset + bytesRead);
             }
-            DerIndefLenConverter derIn = new DerIndefLenConverter();
-            byte[] result = derIn.convertBytes(indefData);
+            byte[] result = DerIndefLenConverter.convertBytes(indefData);
             if (result == null) {
                 int next = in.read(); // This could block, but we need more
                 if (next == -1) {
                     throw new IOException("not all indef len BER resolved");
                 }
diff a/src/java.base/share/classes/sun/security/util/DerInputBuffer.java b/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
--- a/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
+++ b/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
@@ -39,11 +39,12 @@
  * anyone who could violate the "typed value stream" DER model and hence
  * corrupt the input stream of DER values.
  *
  * @author David Brownell
  */
-class DerInputBuffer extends ByteArrayInputStream implements Cloneable {
+class DerInputBuffer extends ByteArrayInputStream
+        implements Cloneable, DerEncoder {
 
     boolean allowBER = true;
 
     // used by sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
     DerInputBuffer(byte[] buf) {
@@ -70,43 +71,48 @@
         }
     }
 
     byte[] toByteArray() {
         int     len = available();
-        if (len <= 0)
+        if (len <= 0) {
             return null;
+        }
         byte[]  retval = new byte[len];
 
         System.arraycopy(buf, pos, retval, 0, len);
         return retval;
     }
 
     int peek() throws IOException {
-        if (pos >= count)
+        if (pos >= count) {
             throw new IOException("out of data");
-        else
+        } else {
             return buf[pos];
+        }
     }
 
     /**
      * Compares this DerInputBuffer for equality with the specified
      * object.
      */
     public boolean equals(Object other) {
-        if (other instanceof DerInputBuffer)
-            return equals((DerInputBuffer)other);
-        else
+        if (other instanceof DerInputBuffer) {
+            return equals((DerInputBuffer) other);
+        } else {
             return false;
+        }
     }
 
     boolean equals(DerInputBuffer other) {
-        if (this == other)
+        if (this == other) {
             return true;
+        }
 
         int max = this.available();
-        if (other.available() != max)
+        if (other.available() != max) {
             return false;
+        }
         for (int i = 0; i < max; i++) {
             if (this.buf[this.pos + i] != other.buf[other.pos + i]) {
                 return false;
             }
         }
@@ -122,18 +128,20 @@
         int retval = 0;
 
         int len = available();
         int p = pos;
 
-        for (int i = 0; i < len; i++)
+        for (int i = 0; i < len; i++) {
             retval += buf[p + i] * i;
+        }
         return retval;
     }
 
     void truncate(int len) throws IOException {
-        if (len > available())
+        if (len > available()) {
             throw new IOException("insufficient data");
+        }
         count = pos + len;
     }
 
     /**
      * Returns the integer which takes up the specified number
@@ -142,13 +150,13 @@
      * @param makePositive whether to always return a positive value,
      *   irrespective of actual encoding
      * @return the integer as a BigInteger.
      */
     BigInteger getBigInteger(int len, boolean makePositive) throws IOException {
-        if (len > available())
+        if (len > available()) {
             throw new IOException("short read of integer");
-
+        }
         if (len == 0) {
             throw new IOException("Invalid encoding: zero length Int value");
         }
 
         byte[] bytes = new byte[len];
@@ -192,13 +200,13 @@
     /**
      * Returns the bit string which takes up the specified
      * number of bytes in this buffer.
      */
     public byte[] getBitString(int len) throws IOException {
-        if (len > available())
+        if (len > available()) {
             throw new IOException("short read of bit string");
-
+        }
         if (len == 0) {
             throw new IOException("Invalid encoding: zero length bit string");
         }
 
         int numOfPadBits = buf[pos];
@@ -226,12 +234,13 @@
     /**
      * Returns the bit string which takes up the rest of this buffer.
      * The bit string need not be byte-aligned.
      */
     BitArray getUnalignedBitString() throws IOException {
-        if (pos >= count)
+        if (pos >= count) {
             return null;
+        }
         /*
          * Just copy the data into an aligned, padded octet buffer,
          * and consume the rest of the buffer.
          */
         int len = available();
@@ -254,31 +263,31 @@
      * Returns the UTC Time value that takes up the specified number
      * of bytes in this buffer.
      * @param len the number of bytes to use
      */
     public Date getUTCTime(int len) throws IOException {
-        if (len > available())
+        if (len > available()) {
             throw new IOException("short read of DER UTC Time");
-
-        if (len < 11 || len > 17)
+        }
+        if (len < 11 || len > 17) {
             throw new IOException("DER UTC Time length error");
-
+        }
         return getTime(len, false);
     }
 
     /**
      * Returns the Generalized Time value that takes up the specified
      * number of bytes in this buffer.
      * @param len the number of bytes to use
      */
     public Date getGeneralizedTime(int len) throws IOException {
-        if (len > available())
+        if (len > available()) {
             throw new IOException("short read of DER Generalized Time");
-
-        if (len < 13)
+        }
+        if (len < 13) {
             throw new IOException("DER Generalized Time length error");
-
+        }
         return getTime(len, true);
 
     }
 
     /**
@@ -320,14 +329,15 @@
         } else {
             type = "UTC";
             year = 10 * Character.digit((char)buf[pos++], 10);
             year += Character.digit((char)buf[pos++], 10);
 
-            if (year < 50)              // origin 2000
+            if (year < 50) {             // origin 2000
                 year += 2000;
-            else
+            } else {
                 year += 1900;   // origin 1900
+            }
         }
 
         month = 10 * Character.digit((char)buf[pos++], 10);
         month += Character.digit((char)buf[pos++], 10);
 
@@ -386,12 +396,12 @@
             }
         } else
             second = 0;
 
         if (month == 0 || day == 0
-            || month > 12 || day > 31
-            || hour >= 24 || minute >= 60 || second >= 60)
+                || month > 12 || day > 31
+                || hour >= 24 || minute >= 60 || second >= 60)
             throw new IOException("Parse " + type + " time, invalid format");
 
         /*
          * Generalized time can theoretically allow any precision,
          * but we're not supporting that.
@@ -403,37 +413,38 @@
         long time = gcal.getTime(date);
 
         /*
          * Finally, "Z" or "+hhmm" or "-hhmm" ... offsets change hhmm
          */
-        if (! (len == 1 || len == 5))
+        if (! (len == 1 || len == 5)) {
             throw new IOException("Parse " + type + " time, invalid offset");
+        }
 
         int hr, min;
 
         switch (buf[pos++]) {
         case '+':
             hr = 10 * Character.digit((char)buf[pos++], 10);
             hr += Character.digit((char)buf[pos++], 10);
             min = 10 * Character.digit((char)buf[pos++], 10);
             min += Character.digit((char)buf[pos++], 10);
 
-            if (hr >= 24 || min >= 60)
+            if (hr >= 24 || min >= 60) {
                 throw new IOException("Parse " + type + " time, +hhmm");
-
+            }
             time -= ((hr * 60) + min) * 60 * 1000;
             break;
 
         case '-':
             hr = 10 * Character.digit((char)buf[pos++], 10);
             hr += Character.digit((char)buf[pos++], 10);
             min = 10 * Character.digit((char)buf[pos++], 10);
             min += Character.digit((char)buf[pos++], 10);
 
-            if (hr >= 24 || min >= 60)
+            if (hr >= 24 || min >= 60) {
                 throw new IOException("Parse " + type + " time, -hhmm");
-
+            }
             time += ((hr * 60) + min) * 60 * 1000;
             break;
 
         case 'Z':
             break;
@@ -441,6 +452,11 @@
         default:
             throw new IOException("Parse " + type + " time, garbage offset");
         }
         return new Date(time);
     }
+
+    @Override
+    public void derEncode(DerOutputStream out) {
+        out.write(buf, pos, count);
+    }
 }
diff a/src/java.base/share/classes/sun/security/util/DerInputStream.java b/src/java.base/share/classes/sun/security/util/DerInputStream.java
--- a/src/java.base/share/classes/sun/security/util/DerInputStream.java
+++ b/src/java.base/share/classes/sun/security/util/DerInputStream.java
@@ -28,11 +28,10 @@
 import java.io.InputStream;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
 import java.util.Date;
-import java.util.Vector;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
@@ -94,11 +93,11 @@
      *          starting at "offset"
      * @param allowBER whether to allow constructed indefinite-length
      *          encoding as well as tolerate leading 0s
      */
     public DerInputStream(byte[] data, int offset, int len,
-        boolean allowBER) throws IOException {
+            boolean allowBER) throws IOException {
         init(data, offset, len, allowBER);
     }
 
     /**
      * Create a DER input stream from part of a data buffer.
@@ -116,11 +115,12 @@
     }
 
     /*
      * private helper routine
      */
-    private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {
+    private void init(byte[] data, int offset, int len, boolean allowBER)
+            throws IOException {
         if ((offset+2 > data.length) || (offset+len > data.length)) {
             throw new IOException("Encoding bytes too short");
         }
         // check for indefinite length encoding
         if (DerIndefLenConverter.isIndefinite(data[offset+1])) {
@@ -128,12 +128,11 @@
                 throw new IOException("Indefinite length BER encoding found");
             } else {
                 byte[] inData = new byte[len];
                 System.arraycopy(data, offset, inData, 0, len);
 
-                DerIndefLenConverter derIn = new DerIndefLenConverter();
-                byte[] result = derIn.convertBytes(inData);
+                byte[] result = DerIndefLenConverter.convertBytes(inData);
                 if (result == null) {
                     throw new IOException("not all indef len BER resolved");
                 } else {
                     buffer = new DerInputBuffer(result, allowBER);
                 }
@@ -158,11 +157,11 @@
      *          be skipped.  If this value is false, the next data read
      *          on this stream and the newly created stream will be the
      *          same.
      */
     public DerInputStream subStream(int len, boolean do_skip)
-    throws IOException {
+            throws IOException {
         DerInputBuffer newbuf = buffer.dup();
 
         newbuf.truncate(len);
         if (do_skip) {
             buffer.skip(len);
@@ -370,11 +369,11 @@
      *          (used to initialize an auto-growing data structure)
      * @param implicit if true tag is assumed implicit.
      * @return array of the values in the sequence
      */
     public DerValue[] getSet(int startLen, boolean implicit)
-        throws IOException {
+            throws IOException {
         tag = (byte)buffer.read();
         if (!implicit) {
             if (tag != DerValue.tag_Set) {
                 throw new IOException("Set tag error");
             }
@@ -397,54 +396,49 @@
            // indefinite length encoding found
            buffer = new DerInputBuffer(
                    DerIndefLenConverter.convertStream(buffer, lenByte, tag),
                    buffer.allowBER);
 
-           if (tag != buffer.read())
-                throw new IOException("Indefinite length encoding" +
-                        " not supported");
+           if (tag != buffer.read()) {
+               throw new IOException("Indefinite length encoding" +
+                       " not supported");
+           }
            len = DerInputStream.getDefiniteLength(buffer);
         }
 
-        if (len == 0)
+        if (len == 0) {
             // return empty array instead of null, which should be
             // used only for missing optionals
             return new DerValue[0];
+        }
 
         /*
          * Create a temporary stream from which to read the data,
          * unless it's not really needed.
          */
-        if (buffer.available() == len)
+        if (buffer.available() == len) {
             newstr = this;
-        else
+        } else {
             newstr = subStream(len, true);
+        }
 
         /*
          * Pull values out of the stream.
          */
-        Vector<DerValue> vec = new Vector<>(startLen);
+        List<DerValue> vec = new ArrayList<>(startLen);
         DerValue value;
 
         do {
             value = new DerValue(newstr.buffer, buffer.allowBER);
-            vec.addElement(value);
+            vec.add(value);
         } while (newstr.available() > 0);
 
-        if (newstr.available() != 0)
+        if (newstr.available() != 0) {
             throw new IOException("Extra data at end of vector");
+        }
 
-        /*
-         * Now stick them into the array we're returning.
-         */
-        int             i, max = vec.size();
-        DerValue[]      retval = new DerValue[max];
-
-        for (i = 0; i < max; i++)
-            retval[i] = vec.elementAt(i);
-
-        return retval;
+        return vec.toArray(new DerValue[vec.size()]);
     }
 
     /**
      * Get a single DER-encoded value from the input stream.
      * It can often be useful to pull a value from the stream
@@ -506,52 +500,56 @@
     /**
      * Private helper routine to read an encoded string from the input
      * stream.
      * @param stringTag the tag for the type of string to read
      * @param stringName a name to display in error messages
-     * @param enc the encoder to use to interpret the data. Should
+     * @param charset the encoder to use to interpret the data. Should
      * correspond to the stringTag above.
      */
     private String readString(byte stringTag, String stringName,
                               Charset charset) throws IOException {
 
-        if (buffer.read() != stringTag)
+        if (buffer.read() != stringTag) {
             throw new IOException("DER input not a " +
-                                  stringName + " string");
+                    stringName + " string");
+        }
 
         int length = getDefiniteLength(buffer);
         byte[] retval = new byte[length];
-        if ((length != 0) && (buffer.read(retval) != length))
+        if ((length != 0) && (buffer.read(retval) != length)) {
             throw new IOException("Short read of DER " +
-                                  stringName + " string");
+                    stringName + " string");
+        }
 
         return new String(retval, charset);
     }
 
     /**
      * Get a UTC encoded time value from the input stream.
      */
     public Date getUTCTime() throws IOException {
-        if (buffer.read() != DerValue.tag_UtcTime)
+        if (buffer.read() != DerValue.tag_UtcTime) {
             throw new IOException("DER input, UTCtime tag invalid ");
+        }
         return buffer.getUTCTime(getDefiniteLength(buffer));
     }
 
     /**
      * Get a Generalized encoded time value from the input stream.
      */
     public Date getGeneralizedTime() throws IOException {
-        if (buffer.read() != DerValue.tag_GeneralizedTime)
+        if (buffer.read() != DerValue.tag_GeneralizedTime) {
             throw new IOException("DER input, GeneralizedTime tag invalid ");
+        }
         return buffer.getGeneralizedTime(getDefiniteLength(buffer));
     }
 
     /*
      * Get a byte from the input stream.
      */
     // package private
-    int getByte() throws IOException {
+    int getByte() {
         return (0x00ff & buffer.read());
     }
 
     public int peekByte() throws IOException {
         return buffer.peek();
@@ -595,15 +593,16 @@
 
             /*
              * NOTE:  tmp == 0 indicates indefinite length encoded data.
              * tmp > 4 indicates more than 4Gb of data.
              */
-            if (tmp == 0)
+            if (tmp == 0) {
                 return -1;
-            if (tmp < 0 || tmp > 4)
-                throw new IOException(mdName + "lengthTag=" + tmp + ", "
-                    + ((tmp < 0) ? "incorrect DER encoding." : "too big."));
+            }
+            if (tmp > 4) {
+                throw new IOException(mdName + "lengthTag=" + tmp + ", too big.");
+            }
 
             value = 0x0ff & in.read();
             tmp--;
             if (value == 0) {
                 // DER requires length value be encoded in minimum number of bytes
diff a/src/java.base/share/classes/sun/security/util/DerOutputStream.java b/src/java.base/share/classes/sun/security/util/DerOutputStream.java
--- a/src/java.base/share/classes/sun/security/util/DerOutputStream.java
+++ b/src/java.base/share/classes/sun/security/util/DerOutputStream.java
@@ -24,12 +24,12 @@
  */
 
 package sun.security.util;
 
 import java.io.ByteArrayOutputStream;
-import java.io.OutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.TimeZone;
@@ -52,11 +52,11 @@
  * @author David Brownell
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
 public class DerOutputStream
-extends ByteArrayOutputStream implements DerEncoder {
+        extends ByteArrayOutputStream implements DerEncoder {
     /**
      * Construct an DER output stream.
      *
      * @param size how large a buffer to preallocate.
      */
@@ -74,11 +74,11 @@
      *
      * @param tag the DER value tag for the data, such as
      *          <em>DerValue.tag_Sequence</em>
      * @param buf buffered data, which must be DER-encoded
      */
-    public void write(byte tag, byte[] buf) throws IOException {
+    public void write(byte tag, byte[] buf) {
         write(tag);
         putLength(buf.length);
         write(buf, 0, buf.length);
     }
 
@@ -89,11 +89,11 @@
      *
      * @param tag the DER value tag for the data, such as
      *          <em>DerValue.tag_Sequence</em>
      * @param out buffered data
      */
-    public void write(byte tag, DerOutputStream out) throws IOException {
+    public void write(byte tag, DerOutputStream out) {
         write(tag);
         putLength(out.count);
         write(out.buf, 0, out.count);
     }
 
@@ -112,20 +112,19 @@
      * tagging it would be encoded as "A1 03 02 01 04".
      * Notice that the tag is A1 and not 81, this is because with
      * explicit tagging the form is always constructed.
      * @param value original value being implicitly tagged
      */
-    public void writeImplicit(byte tag, DerOutputStream value)
-    throws IOException {
+    public void writeImplicit(byte tag, DerOutputStream value) {
         write(tag);
         write(value.buf, 1, value.count-1);
     }
 
     /**
      * Marshals pre-encoded DER value onto the output stream.
      */
-    public void putDerValue(DerValue val) throws IOException {
+    public void putDerValue(DerValue val) {
         val.encode(this);
     }
 
     /*
      * PRIMITIVES -- these are "universal" ASN.1 simple types.
@@ -136,11 +135,11 @@
      */
 
     /**
      * Marshals a DER boolean on the output stream.
      */
-    public void putBoolean(boolean val) throws IOException {
+    public void putBoolean(boolean val) {
         write(DerValue.tag_Boolean);
         putLength(1);
         if (val) {
             write(0xff);
         } else {
@@ -150,45 +149,45 @@
 
     /**
      * Marshals a DER enumerated on the output stream.
      * @param i the enumerated value.
      */
-    public void putEnumerated(int i) throws IOException {
+    public void putEnumerated(int i) {
         write(DerValue.tag_Enumerated);
         putIntegerContents(i);
     }
 
     /**
      * Marshals a DER integer on the output stream.
      *
      * @param i the integer in the form of a BigInteger.
      */
-    public void putInteger(BigInteger i) throws IOException {
+    public void putInteger(BigInteger i) {
         write(DerValue.tag_Integer);
         byte[]    buf = i.toByteArray(); // least number  of bytes
         putLength(buf.length);
         write(buf, 0, buf.length);
     }
 
     /**
      * Marshals a DER integer on the output stream.
      * @param i the integer in the form of an Integer.
      */
-    public void putInteger(Integer i) throws IOException {
+    public void putInteger(Integer i) {
         putInteger(i.intValue());
     }
 
     /**
      * Marshals a DER integer on the output stream.
      * @param i the integer.
      */
-    public void putInteger(int i) throws IOException {
+    public void putInteger(int i) {
         write(DerValue.tag_Integer);
         putIntegerContents(i);
     }
 
-    private void putIntegerContents(int i) throws IOException {
+    private void putIntegerContents(int i) {
 
         byte[] bytes = new byte[4];
         int start = 0;
 
         // Obtain the four bytes of the int
@@ -204,41 +203,42 @@
         if (bytes[0] == (byte)0xff) {
 
             // Eliminate redundant 0xff
 
             for (int j = 0; j < 3; j++) {
-                if ((bytes[j] == (byte)0xff) &&
-                    ((bytes[j+1] & 0x80) == 0x80))
+                if ((bytes[j] == (byte)0xff) && ((bytes[j+1] & 0x80) == 0x80)) {
                     start++;
-                else
+                } else {
                     break;
+                }
              }
          } else if (bytes[0] == 0x00) {
 
              // Eliminate redundant 0x00
 
             for (int j = 0; j < 3; j++) {
-                if ((bytes[j] == 0x00) &&
-                    ((bytes[j+1] & 0x80) == 0))
+                if ((bytes[j] == 0x00) && ((bytes[j+1] & 0x80) == 0)) {
                     start++;
-                else
+                } else {
                     break;
+                }
             }
         }
 
         putLength(4 - start);
-        for (int k = start; k < 4; k++)
+        for (int k = start; k < 4; k++) {
             write(bytes[k]);
+        }
     }
 
     /**
      * Marshals a DER bit string on the output stream. The bit
      * string must be byte-aligned.
      *
      * @param bits the bit string, MSB first
      */
-    public void putBitString(byte[] bits) throws IOException {
+    public void putBitString(byte[] bits) {
         write(DerValue.tag_BitString);
         putLength(bits.length + 1);
         write(0);               // all of last octet is used
         write(bits);
     }
@@ -247,11 +247,11 @@
      * Marshals a DER bit string on the output stream.
      * The bit strings need not be byte-aligned.
      *
      * @param ba the bit string, MSB first
      */
-    public void putUnalignedBitString(BitArray ba) throws IOException {
+    public void putUnalignedBitString(BitArray ba) {
         byte[] bits = ba.toByteArray();
 
         write(DerValue.tag_BitString);
         putLength(bits.length + 1);
         write(bits.length*8 - ba.length()); // excess bits in last octet
@@ -262,69 +262,65 @@
      * Marshals a truncated DER bit string on the output stream.
      * The bit strings need not be byte-aligned.
      *
      * @param ba the bit string, MSB first
      */
-    public void putTruncatedUnalignedBitString(BitArray ba) throws IOException {
+    public void putTruncatedUnalignedBitString(BitArray ba) {
         putUnalignedBitString(ba.truncate());
     }
 
     /**
      * DER-encodes an ASN.1 OCTET STRING value on the output stream.
      *
      * @param octets the octet string
      */
-    public void putOctetString(byte[] octets) throws IOException {
+    public void putOctetString(byte[] octets) {
         write(DerValue.tag_OctetString, octets);
     }
 
     /**
      * Marshals a DER "null" value on the output stream.  These are
      * often used to indicate optional values which have been omitted.
      */
-    public void putNull() throws IOException {
+    public void putNull() {
         write(DerValue.tag_Null);
         putLength(0);
     }
 
     /**
      * Marshals an object identifier (OID) on the output stream.
      * Corresponds to the ASN.1 "OBJECT IDENTIFIER" construct.
      */
-    public void putOID(ObjectIdentifier oid) throws IOException {
+    public void putOID(ObjectIdentifier oid) {
         oid.encode(this);
     }
 
     /**
      * Marshals a sequence on the output stream.  This supports both
      * the ASN.1 "SEQUENCE" (zero to N values) and "SEQUENCE OF"
      * (one to N values) constructs.
      */
-    public void putSequence(DerValue[] seq) throws IOException {
+    public void putSequence(DerValue[] seq) {
         DerOutputStream bytes = new DerOutputStream();
-        int i;
-
-        for (i = 0; i < seq.length; i++)
+        for (int i = 0; i < seq.length; i++) {
             seq[i].encode(bytes);
-
+        }
         write(DerValue.tag_Sequence, bytes);
     }
 
     /**
      * Marshals the contents of a set on the output stream without
      * ordering the elements.  Ok for BER encoding, but not for DER
      * encoding.
      *
      * For DER encoding, use orderedPutSet() or orderedPutSetOf().
      */
-    public void putSet(DerValue[] set) throws IOException {
+    public void putSet(DerValue[] set) {
         DerOutputStream bytes = new DerOutputStream();
-        int i;
-
-        for (i = 0; i < set.length; i++)
+        for (int i = 0; i < set.length; i++) {
             set[i].encode(bytes);
-
+        }
         write(DerValue.tag_Set, bytes);
     }
 
     /**
      * Marshals the contents of a set on the output stream.  Sets
@@ -334,11 +330,11 @@
      * elements have the same DER encoding.
      *
      * This method supports the ASN.1 "SET OF" construct, but not
      * "SET", which uses a different order.
      */
-    public void putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {
+    public void putOrderedSetOf(byte tag, DerEncoder[] set) {
         putOrderedSet(tag, set, lexOrder);
     }
 
     /**
      * Marshals the contents of a set on the output stream.  Sets
@@ -348,11 +344,11 @@
      * elements have the same DER encoding.
      *
      * This method supports the ASN.1 "SET" construct, but not
      * "SET OF", which uses a different order.
      */
-    public void putOrderedSet(byte tag, DerEncoder[] set) throws IOException {
+    public void putOrderedSet(byte tag, DerEncoder[] set) {
         putOrderedSet(tag, set, tagOrder);
     }
 
     /**
      *  Lexicographical order comparison on byte arrays, for ordering
@@ -371,11 +367,11 @@
      * encodings of its sorted in increasing order.
      *
      * @param order the order to use when sorting encodings of components.
      */
     private void putOrderedSet(byte tag, DerEncoder[] set,
-                               Comparator<byte[]> order) throws IOException {
+                               Comparator<byte[]> order) {
         DerOutputStream[] streams = new DerOutputStream[set.length];
 
         for (int i = 0; i < set.length; i++) {
             streams[i] = new DerOutputStream();
             set[i].derEncode(streams[i]);
@@ -384,11 +380,11 @@
         // order the element encodings
         byte[][] bufs = new byte[streams.length][];
         for (int i = 0; i < streams.length; i++) {
             bufs[i] = streams[i].toByteArray();
         }
-        Arrays.<byte[]>sort(bufs, order);
+        Arrays.sort(bufs, order);
 
         DerOutputStream bytes = new DerOutputStream();
         for (int i = 0; i < streams.length; i++) {
             bytes.write(bufs[i]);
         }
@@ -397,98 +393,102 @@
     }
 
     /**
      * Marshals a string as a DER encoded UTF8String.
      */
-    public void putUTF8String(String s) throws IOException {
+    public void putUTF8String(String s) {
         writeString(s, DerValue.tag_UTF8String, UTF_8);
     }
 
     /**
      * Marshals a string as a DER encoded PrintableString.
      */
-    public void putPrintableString(String s) throws IOException {
+    public void putPrintableString(String s) {
         writeString(s, DerValue.tag_PrintableString, US_ASCII);
     }
 
     /**
      * Marshals a string as a DER encoded T61String.
      */
-    public void putT61String(String s) throws IOException {
+    public void putT61String(String s) {
         /*
          * Works for characters that are defined in both ASCII and
          * T61.
          */
         writeString(s, DerValue.tag_T61String, ISO_8859_1);
     }
 
     /**
      * Marshals a string as a DER encoded IA5String.
      */
-    public void putIA5String(String s) throws IOException {
+    public void putIA5String(String s) {
         writeString(s, DerValue.tag_IA5String, US_ASCII);
     }
 
     /**
      * Marshals a string as a DER encoded BMPString.
      */
-    public void putBMPString(String s) throws IOException {
+    public void putBMPString(String s) {
         writeString(s, DerValue.tag_BMPString, UTF_16BE);
     }
 
     /**
      * Marshals a string as a DER encoded GeneralString.
      */
-    public void putGeneralString(String s) throws IOException {
+    public void putGeneralString(String s) {
         writeString(s, DerValue.tag_GeneralString, US_ASCII);
     }
 
     /**
      * Private helper routine for writing DER encoded string values.
      * @param s the string to write
      * @param stringTag one of the DER string tags that indicate which
      * encoding should be used to write the string out.
-     * @param enc the name of the encoder that should be used corresponding
-     * to the above tag.
+     * @param charset the name of the character set to encode s
      */
-    private void writeString(String s, byte stringTag, Charset charset)
-        throws IOException {
+    private void writeString(String s, byte stringTag, Charset charset) {
 
         byte[] data = s.getBytes(charset);
         write(stringTag);
         putLength(data.length);
         write(data);
     }
 
+    // A direct copy of OutputStream::write(byte[]) but without throwing
+    // an exception.
+    public void write(byte b[]) {
+        write(b, 0, b.length);
+    }
+
     /**
      * Marshals a DER UTC time/date value.
      *
      * <P>YYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
      * and with seconds (even if seconds=0) as per RFC 5280.
      */
-    public void putUTCTime(Date d) throws IOException {
+    public void putUTCTime(Date d) {
         putTime(d, DerValue.tag_UtcTime);
     }
 
     /**
      * Marshals a DER Generalized Time/date value.
      *
      * <P>YYYYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
      * and with seconds (even if seconds=0) as per RFC 5280.
      */
-    public void putGeneralizedTime(Date d) throws IOException {
+    public void putGeneralizedTime(Date d) {
         putTime(d, DerValue.tag_GeneralizedTime);
     }
 
     /**
      * Private helper routine for marshalling a DER UTC/Generalized
      * time/date value. If the tag specified is not that for UTC Time
      * then it defaults to Generalized Time.
      * @param d the date to be marshalled
      * @param tag the tag for UTC Time or Generalized Time
      */
-    private void putTime(Date d, byte tag) throws IOException {
+    private void putTime(Date d, byte tag) {
 
         /*
          * Format the date.
          */
 
@@ -517,13 +517,12 @@
 
     /**
      * Put the encoding of the length in the stream.
      *
      * @param len the length of the attribute.
-     * @exception IOException on writing errors.
      */
-    public void putLength(int len) throws IOException {
+    public void putLength(int len) {
         if (len < 128) {
             write((byte)len);
 
         } else if (len < (1 << 8)) {
             write((byte)0x081);
@@ -564,15 +563,10 @@
             tag |= (byte)0x20;
         }
         write(tag);
     }
 
-    /**
-     *  Write the current contents of this <code>DerOutputStream</code>
-     *  to an <code>OutputStream</code>.
-     *
-     *  @exception IOException on output error.
-     */
-    public void derEncode(OutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.write(toByteArray());
     }
 }
diff a/src/java.base/share/classes/sun/security/util/DerValue.java b/src/java.base/share/classes/sun/security/util/DerValue.java
--- a/src/java.base/share/classes/sun/security/util/DerValue.java
+++ b/src/java.base/share/classes/sun/security/util/DerValue.java
@@ -60,20 +60,17 @@
     public static final byte TAG_UNIVERSAL = (byte)0x000;
     public static final byte TAG_APPLICATION = (byte)0x040;
     public static final byte TAG_CONTEXT = (byte)0x080;
     public static final byte TAG_PRIVATE = (byte)0x0c0;
 
-    /** The DER tag of the value; one of the tag_ constants. */
+    // tag of the value
     public byte                 tag;
-
+    // A ByteArrayOutputStream of content
     protected DerInputBuffer    buffer;
-
-    /**
-     * The DER-encoded data of the value, never null
-     */
+    // Always new DerInputStream(buffer)
     public final DerInputStream data;
-
+    // The length of the value. Always the same as buffer.count.
     private int                 length;
 
     /*
      * The type starts at the first byte of the encoding, and
      * is one of these tag_* values.  That may be all the type
@@ -213,12 +210,12 @@
             if (!isPrintableStringChar(value.charAt(i))) {
                 isPrintableString = false;
                 break;
             }
         }
-
-        data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
+        data = init(isPrintableString
+                ? tag_PrintableString : tag_UTF8String, value);
     }
 
     /**
      * Creates a string type DER value from a String object
      * @param stringTag the tag for the DER value to create
@@ -273,11 +270,10 @@
             // indefinite form is encoded by sending a length field with a
             // length of 0. - i.e. [1000|0000].
             // the object is ended by sending two zero bytes.
             in.skip(length + 2);
         } else {
-
             buffer = in.dup();
             buffer.truncate(length);
             data = new DerInputStream(buffer);
 
             in.skip(length);
@@ -302,11 +298,11 @@
     }
 
     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
     // arg to control whether DER checks are enforced.
     DerValue(byte[] buf, int offset, int len, boolean allowBER)
-        throws IOException {
+            throws IOException {
         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
     }
 
     /**
      * Get an ASN.1/DER encoded datum from part of a buffer.
@@ -376,48 +372,53 @@
 
     /*
      * helper routine
      */
     private DerInputStream init(boolean fullyBuffered, InputStream in,
-        boolean allowBER) throws IOException {
+            boolean allowBER) throws IOException {
 
         tag = (byte)in.read();
         byte lenByte = (byte)in.read();
         length = DerInputStream.getLength(lenByte, in);
         if (length == -1) { // indefinite length encoding found
             in = new ByteArrayInputStream(
                     DerIndefLenConverter.convertStream(in, lenByte, tag));
-            if (tag != in.read())
+            if (tag != in.read()) {
                 throw new IOException
                         ("Indefinite length encoding not supported");
+            }
             length = DerInputStream.getDefiniteLength(in);
         }
 
-        if (fullyBuffered && in.available() != length)
+        if (fullyBuffered && in.available() != length) {
             throw new IOException("extra data given to DerValue constructor");
+        }
 
         byte[] bytes = IOUtils.readExactlyNBytes(in, length);
 
         buffer = new DerInputBuffer(bytes, allowBER);
         return new DerInputStream(buffer);
     }
 
     /**
      * Encode an ASN1/DER encoded datum onto a DER output stream.
      */
-    public void encode(DerOutputStream out)
-    throws IOException {
+    public void encode(DerOutputStream out) {
         out.write(tag);
         out.putLength(length);
-        // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
         if (length > 0) {
             byte[] value = new byte[length];
             // always synchronized on data
             synchronized (data) {
                 buffer.reset();
-                if (buffer.read(value) != length) {
-                    throw new IOException("short DER value read (encode)");
+                try {
+                    if (buffer.read(value) != length) {
+                        throw new IOException("short DER value read (encode)");
+                    }
+                } catch (IOException e) {
+                    // buffer should always have length bytes
+                    throw new AssertionError("Should not happen");
                 }
                 out.write(value);
             }
         }
     }
@@ -453,18 +454,20 @@
      * Returns an ASN.1 OBJECT IDENTIFIER.
      *
      * @return the OID held in this DER value
      */
     public ObjectIdentifier getOID() throws IOException {
-        if (tag != tag_ObjectId)
+        if (tag != tag_ObjectId) {
             throw new IOException("DerValue.getOID, not an OID " + tag);
+        }
         return new ObjectIdentifier(buffer);
     }
 
     private byte[] append(byte[] a, byte[] b) {
-        if (a == null)
+        if (a == null) {
             return b;
+        }
 
         byte[] ret = new byte[a.length + b.length];
         System.arraycopy(a, 0, ret, 0, a.length);
         System.arraycopy(b, 0, ret, a.length, b.length);
 
@@ -478,11 +481,11 @@
      */
     public byte[] getOctetString() throws IOException {
 
         if (tag != tag_OctetString && !isConstructed(tag_OctetString)) {
             throw new IOException(
-                "DerValue.getOctetString, not an Octet String: " + tag);
+                    "DerValue.getOctetString, not an Octet String: " + tag);
         }
         // Note: do not attempt to call buffer.read(bytes) at all. There's a
         // known bug that it returns -1 instead of 0.
         if (length == 0) {
             return new byte[0];
@@ -525,12 +528,13 @@
      * Returns an ASN.1 INTEGER value as a BigInteger.
      *
      * @return the integer held in this DER value as a BigInteger.
      */
     public BigInteger getBigInteger() throws IOException {
-        if (tag != tag_Integer)
+        if (tag != tag_Integer) {
             throw new IOException("DerValue.getBigInteger, not an int " + tag);
+        }
         return buffer.getBigInteger(data.available(), false);
     }
 
     /**
      * Returns an ASN.1 INTEGER value as a positive BigInteger.
@@ -538,12 +542,13 @@
      * some values as negative.
      *
      * @return the integer held in this DER value as a BigInteger.
      */
     public BigInteger getPositiveBigInteger() throws IOException {
-        if (tag != tag_Integer)
+        if (tag != tag_Integer) {
             throw new IOException("DerValue.getBigInteger, not an int " + tag);
+        }
         return buffer.getBigInteger(data.available(), true);
     }
 
     /**
      * Returns an ASN.1 ENUMERATED value.
@@ -562,54 +567,55 @@
      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
      *
      * @return the bit string held in this value
      */
     public byte[] getBitString() throws IOException {
-        if (tag != tag_BitString)
+        if (tag != tag_BitString) {
             throw new IOException(
-                "DerValue.getBitString, not a bit string " + tag);
-
+                    "DerValue.getBitString, not a bit string " + tag);
+        }
         return buffer.getBitString();
     }
 
     /**
      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
      *
      * @return a BitArray representing the bit string held in this value
      */
     public BitArray getUnalignedBitString() throws IOException {
-        if (tag != tag_BitString)
+        if (tag != tag_BitString) {
             throw new IOException(
-                "DerValue.getBitString, not a bit string " + tag);
-
+                    "DerValue.getBitString, not a bit string " + tag);
+        }
         return buffer.getUnalignedBitString();
     }
 
     /**
      * Returns the name component as a Java string, regardless of its
      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
      */
     // TBD: Need encoder for UniversalString before it can be handled.
     public String getAsString() throws IOException {
-        if (tag == tag_UTF8String)
+        if (tag == tag_UTF8String) {
             return getUTF8String();
-        else if (tag == tag_PrintableString)
+        } else if (tag == tag_PrintableString) {
             return getPrintableString();
-        else if (tag == tag_T61String)
+        } else if (tag == tag_T61String) {
             return getT61String();
-        else if (tag == tag_IA5String)
+        } else if (tag == tag_IA5String) {
             return getIA5String();
         /*
-          else if (tag == tag_UniversalString)
+          } else if (tag == tag_UniversalString) {
           return getUniversalString();
         */
-        else if (tag == tag_BMPString)
+        } else if (tag == tag_BMPString) {
             return getBMPString();
-        else if (tag == tag_GeneralString)
+        } else if (tag == tag_GeneralString) {
             return getGeneralString();
-        else
+        } else {
             return null;
+        }
     }
 
     /**
      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
      * based on the parameter.  The bit string must be byte-aligned.
@@ -617,14 +623,15 @@
      * @param tagImplicit if true, the tag is assumed implicit.
      * @return the bit string held in this value
      */
     public byte[] getBitString(boolean tagImplicit) throws IOException {
         if (!tagImplicit) {
-            if (tag != tag_BitString)
+            if (tag != tag_BitString) {
                 throw new IOException("DerValue.getBitString, not a bit string "
-                                       + tag);
+                        + tag);
             }
+        }
         return buffer.getBitString();
     }
 
     /**
      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
@@ -632,16 +639,17 @@
      *
      * @param tagImplicit if true, the tag is assumed implicit.
      * @return the bit string held in this value
      */
     public BitArray getUnalignedBitString(boolean tagImplicit)
-    throws IOException {
+            throws IOException {
         if (!tagImplicit) {
-            if (tag != tag_BitString)
+            if (tag != tag_BitString) {
                 throw new IOException("DerValue.getBitString, not a bit string "
-                                       + tag);
+                        + tag);
             }
+        }
         return buffer.getUnalignedBitString();
     }
 
     /**
      * Helper routine to return all the bytes contained in the
@@ -659,86 +667,80 @@
     /**
      * Returns an ASN.1 STRING value
      *
      * @return the printable string held in this value
      */
-    public String getPrintableString()
-    throws IOException {
-        if (tag != tag_PrintableString)
+    public String getPrintableString() throws IOException {
+        if (tag != tag_PrintableString) {
             throw new IOException(
-                "DerValue.getPrintableString, not a string " + tag);
-
+                    "DerValue.getPrintableString, not a string " + tag);
+        }
         return new String(getDataBytes(), US_ASCII);
     }
 
     /**
      * Returns an ASN.1 T61 (Teletype) STRING value
      *
      * @return the teletype string held in this value
      */
     public String getT61String() throws IOException {
-        if (tag != tag_T61String)
-            throw new IOException(
-                "DerValue.getT61String, not T61 " + tag);
-
+        if (tag != tag_T61String) {
+            throw new IOException("DerValue.getT61String, not T61 " + tag);
+        }
         return new String(getDataBytes(), ISO_8859_1);
     }
 
     /**
      * Returns an ASN.1 IA5 (ASCII) STRING value
      *
      * @return the ASCII string held in this value
      */
     public String getIA5String() throws IOException {
-        if (tag != tag_IA5String)
-            throw new IOException(
-                "DerValue.getIA5String, not IA5 " + tag);
-
+        if (tag != tag_IA5String) {
+            throw new IOException("DerValue.getIA5String, not IA5 " + tag);
+        }
         return new String(getDataBytes(), US_ASCII);
     }
 
     /**
      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
      *
      * @return a string corresponding to the encoded BMPString held in
      * this value
      */
     public String getBMPString() throws IOException {
-        if (tag != tag_BMPString)
-            throw new IOException(
-                "DerValue.getBMPString, not BMP " + tag);
-
-        // BMPString is the same as Unicode in big endian, unmarked
-        // format.
+        if (tag != tag_BMPString) {
+            throw new IOException("DerValue.getBMPString, not BMP " + tag);
+        }
+        // BMPString is the same as Unicode in big endian, unmarked format.
         return new String(getDataBytes(), UTF_16BE);
     }
 
     /**
      * Returns the ASN.1 UTF-8 STRING value as a Java String.
      *
      * @return a string corresponding to the encoded UTF8String held in
      * this value
      */
     public String getUTF8String() throws IOException {
-        if (tag != tag_UTF8String)
-            throw new IOException(
-                "DerValue.getUTF8String, not UTF-8 " + tag);
-
+        if (tag != tag_UTF8String) {
+            throw new IOException("DerValue.getUTF8String, not UTF-8 " + tag);
+        }
         return new String(getDataBytes(), UTF_8);
     }
 
     /**
      * Returns the ASN.1 GENERAL STRING value as a Java String.
      *
      * @return a string corresponding to the encoded GeneralString held in
      * this value
      */
     public String getGeneralString() throws IOException {
-        if (tag != tag_GeneralString)
+        if (tag != tag_GeneralString) {
             throw new IOException(
-                "DerValue.getGeneralString, not GeneralString " + tag);
-
+                    "DerValue.getGeneralString, not GeneralString " + tag);
+        }
         return new String(getDataBytes(), US_ASCII);
     }
 
     /**
      * Returns a Date if the DerValue is UtcTime.
@@ -816,21 +818,22 @@
     @Override
     public String toString() {
         try {
 
             String str = getAsString();
-            if (str != null)
+            if (str != null) {
                 return "\"" + str + "\"";
-            if (tag == tag_Null)
+            }
+            if (tag == tag_Null) {
                 return "[DerValue, null]";
-            if (tag == tag_ObjectId)
+            } else if (tag == tag_ObjectId) {
                 return "OID." + getOID();
-
-            // integers
-            else
+            } else {
+                // integers
                 return "[DerValue, tag = " + tag
                         + ", length = " + length + "]";
+            }
         } catch (IOException e) {
             throw new IllegalArgumentException("misformatted DER value");
         }
     }
 
@@ -853,12 +856,13 @@
      * to return a DER stream of the members of the set or sequence.
      * This operation is not supported for primitive types such as
      * integers or bit strings.
      */
     public DerInputStream toDerInputStream() throws IOException {
-        if (tag == tag_Sequence || tag == tag_Set)
+        if (tag == tag_Sequence || tag == tag_Set) {
             return new DerInputStream(buffer);
+        }
         throw new IOException("toDerInputStream rejects tag type " + tag);
     }
 
     /**
      * Get the length of the encoded value.
@@ -884,11 +888,11 @@
      *
      * This list is based on X.680 (the ASN.1 spec).
      */
     public static boolean isPrintableStringChar(char ch) {
         if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
-            (ch >= '0' && ch <= '9')) {
+                (ch >= '0' && ch <= '9')) {
             return true;
         } else {
             switch (ch) {
                 case ' ':       /* space */
                 case '\'':      /* apostrophe */
diff a/src/java.base/share/classes/sun/security/util/NamedCurve.java b/src/java.base/share/classes/sun/security/util/NamedCurve.java
--- a/src/java.base/share/classes/sun/security/util/NamedCurve.java
+++ b/src/java.base/share/classes/sun/security/util/NamedCurve.java
@@ -57,15 +57,11 @@
         System.arraycopy(aliases, 0, nameAndAliases, 1, aliases.length);
 
         this.oid = ko.value();
 
         DerOutputStream out = new DerOutputStream();
-        try {
-            out.putOID(ObjectIdentifier.of(ko));
-        } catch (IOException e) {
-            throw new RuntimeException("Internal error", e);
-        }
+        out.putOID(ObjectIdentifier.of(ko));
         encoded = out.toByteArray();
     }
 
     // returns the curve's standard name followed by its aliases
     public String[] getNameAndAliases() {
diff a/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java b/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
--- a/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
+++ b/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
@@ -330,11 +330,11 @@
     }
 
     /*
      * n.b. the only public interface is DerOutputStream.putOID()
      */
-    void encode(DerOutputStream out) throws IOException {
+    void encode(DerOutputStream out) {
         out.write (DerValue.tag_ObjectId, encoding);
     }
 
     /**
      * Compares this identifier with another, for equality.
diff a/src/java.base/share/classes/sun/security/x509/AVA.java b/src/java.base/share/classes/sun/security/x509/AVA.java
--- a/src/java.base/share/classes/sun/security/x509/AVA.java
+++ b/src/java.base/share/classes/sun/security/x509/AVA.java
@@ -27,11 +27,10 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.Reader;
-import java.security.AccessController;
 import java.text.Normalizer;
 import java.util.*;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
@@ -631,27 +630,21 @@
      */
     public int hashCode() {
         return toRFC2253CanonicalString().hashCode();
     }
 
-    /*
-     * AVAs are encoded as a SEQUENCE of two elements.
-     */
-    public void encode(DerOutputStream out) throws IOException {
-        derEncode(out);
-    }
-
     /**
      * DER encode this object onto an output stream.
      * Implements the <code>DerEncoder</code> interface.
      *
      * @param out
      * the output stream on which to write the DER encoding.
      *
      * @exception IOException on encoding error.
      */
-    public void derEncode(OutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         DerOutputStream         tmp = new DerOutputStream();
         DerOutputStream         tmp2 = new DerOutputStream();
 
         tmp.putOID(oid);
         value.encode(tmp);
diff a/src/java.base/share/classes/sun/security/x509/AccessDescription.java b/src/java.base/share/classes/sun/security/x509/AccessDescription.java
--- a/src/java.base/share/classes/sun/security/x509/AccessDescription.java
+++ b/src/java.base/share/classes/sun/security/x509/AccessDescription.java
@@ -70,11 +70,11 @@
 
     public GeneralName getAccessLocation() {
         return accessLocation;
     }
 
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream tmp = new DerOutputStream();
         tmp.putOID(accessMethod);
         accessLocation.encode(tmp);
         out.write(DerValue.tag_Sequence, tmp);
     }
diff a/src/java.base/share/classes/sun/security/x509/AlgorithmId.java b/src/java.base/share/classes/sun/security/x509/AlgorithmId.java
--- a/src/java.base/share/classes/sun/security/x509/AlgorithmId.java
+++ b/src/java.base/share/classes/sun/security/x509/AlgorithmId.java
@@ -142,35 +142,34 @@
 
         // Decode (parse) the parameters
         algParams.init(params.toByteArray());
     }
 
-    /**
-     * Marshal a DER-encoded "AlgorithmID" sequence on the DER stream.
-     */
-    public final void encode(DerOutputStream out) throws IOException {
-        derEncode(out);
-    }
-
     /**
      * DER encode this object onto an output stream.
      * Implements the <code>DerEncoder</code> interface.
      *
      * @param out
      * the output stream on which to write the DER encoding.
      *
      * @exception IOException on encoding error.
      */
-    public void derEncode (OutputStream out) throws IOException {
+    @Override
+    public void derEncode (DerOutputStream out) {
         DerOutputStream bytes = new DerOutputStream();
         DerOutputStream tmp = new DerOutputStream();
 
         bytes.putOID(algid);
         // Setup params from algParams since no DER encoding is given
         if (constructedFromDer == false) {
             if (algParams != null) {
-                params = new DerValue(algParams.getEncoded());
+                // algParams should always have been initialized?
+                try {
+                    params = new DerValue(algParams.getEncoded());
+                } catch (IOException e) {
+                    throw new AssertionError(e);
+                }
             } else {
                 params = null;
             }
         }
         if (params == null) {
diff a/src/java.base/share/classes/sun/security/x509/AuthorityInfoAccessExtension.java b/src/java.base/share/classes/sun/security/x509/AuthorityInfoAccessExtension.java
--- a/src/java.base/share/classes/sun/security/x509/AuthorityInfoAccessExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/AuthorityInfoAccessExtension.java
@@ -90,11 +90,11 @@
      *
      * @param accessDescriptions the List of AccessDescription
      * @throws IOException on error
      */
     public AuthorityInfoAccessExtension(
-            List<AccessDescription> accessDescriptions) throws IOException {
+            List<AccessDescription> accessDescriptions) {
         this.extensionId = PKIXExtensions.AuthInfoAccess_Id;
         this.critical = false;
         this.accessDescriptions = accessDescriptions;
         encodeThis();
     }
@@ -147,19 +147,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = PKIXExtensions.AuthInfoAccess_Id;
             this.critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
@@ -214,11 +213,11 @@
         elements.addElement(DESCRIPTIONS);
         return elements.elements();
     }
 
      // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (accessDescriptions.isEmpty()) {
             this.extensionValue = null;
         } else {
             DerOutputStream ads = new DerOutputStream();
             for (AccessDescription accessDescription : accessDescriptions) {
diff a/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java b/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
--- a/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
@@ -78,11 +78,11 @@
     private KeyIdentifier       id = null;
     private GeneralNames        names = null;
     private SerialNumber        serialNum = null;
 
     // Encode only the extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (id == null && names == null && serialNum == null) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream seq = new DerOutputStream();
@@ -91,19 +91,15 @@
             DerOutputStream tmp1 = new DerOutputStream();
             id.encode(tmp1);
             tmp.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
                               false, TAG_ID), tmp1);
         }
-        try {
-            if (names != null) {
-                DerOutputStream tmp1 = new DerOutputStream();
-                names.encode(tmp1);
-                tmp.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                  true, TAG_NAMES), tmp1);
-            }
-        } catch (Exception e) {
-            throw new IOException(e.toString());
+        if (names != null) {
+            DerOutputStream tmp1 = new DerOutputStream();
+            names.encode(tmp1);
+            tmp.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
+                              true, TAG_NAMES), tmp1);
         }
         if (serialNum != null) {
             DerOutputStream tmp1 = new DerOutputStream();
             serialNum.encode(tmp1);
             tmp.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
@@ -216,19 +212,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on error.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             extensionId = PKIXExtensions.AuthorityKey_Id;
             critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
@@ -312,11 +307,11 @@
     }
 
     /**
      * Return the encoded key identifier, or null if not specified.
      */
-    public byte[] getEncodedKeyIdentifier() throws IOException {
+    public byte[] getEncodedKeyIdentifier() {
         if (id != null) {
             DerOutputStream derOut = new DerOutputStream();
             id.encode(derOut);
             return derOut.toByteArray();
         }
diff a/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java b/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/BasicConstraintsExtension.java
@@ -67,11 +67,11 @@
     // Private data members
     private boolean     ca = false;
     private int pathLen = -1;
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         DerOutputStream out = new DerOutputStream();
         DerOutputStream tmp = new DerOutputStream();
 
         if (ca) {
             tmp.putBoolean(ca);
@@ -181,24 +181,22 @@
      /**
       * Encode this extension value to the output stream.
       *
       * @param out the DerOutputStream to encode the extension to.
       */
-     public void encode(OutputStream out) throws IOException {
-         DerOutputStream tmp = new DerOutputStream();
+     @Override
+     public void encode(DerOutputStream out) {
          if (extensionValue == null) {
              this.extensionId = PKIXExtensions.BasicConstraints_Id;
              if (ca) {
                  critical = true;
              } else {
                  critical = false;
              }
              encodeThis();
          }
-         super.encode(tmp);
-
-         out.write(tmp.toByteArray());
+         super.encode(out);
      }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CRLDistributionPointsExtension.java b/src/java.base/share/classes/sun/security/x509/CRLDistributionPointsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/CRLDistributionPointsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/CRLDistributionPointsExtension.java
@@ -197,20 +197,21 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
+    @Override
+    public void encode(DerOutputStream out) {
         encode(out, PKIXExtensions.CRLDistributionPoints_Id, false);
     }
 
     /**
      * Write the extension to the DerOutputStream.
      * (Also called by the subclass)
      */
-    protected void encode(OutputStream out, ObjectIdentifier extensionId,
-        boolean isCritical) throws IOException {
+    protected void encode(DerOutputStream out, ObjectIdentifier extensionId,
+        boolean isCritical) {
 
         DerOutputStream tmp = new DerOutputStream();
         if (this.extensionValue == null) {
             this.extensionId = extensionId;
             this.critical = isCritical;
@@ -275,11 +276,11 @@
         elements.addElement(POINTS);
         return elements.elements();
     }
 
      // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (distributionPoints.isEmpty()) {
             this.extensionValue = null;
         } else {
             DerOutputStream pnts = new DerOutputStream();
             for (DistributionPoint point : distributionPoints) {
diff a/src/java.base/share/classes/sun/security/x509/CRLNumberExtension.java b/src/java.base/share/classes/sun/security/x509/CRLNumberExtension.java
--- a/src/java.base/share/classes/sun/security/x509/CRLNumberExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/CRLNumberExtension.java
@@ -59,11 +59,11 @@
     private BigInteger crlNumber = null;
     private String extensionName;
     private String extensionLabel;
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (crlNumber == null) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -196,31 +196,28 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         encode(out, PKIXExtensions.CRLNumber_Id, true);
     }
 
     /**
      * Write the extension to the DerOutputStream.
      * (Also called by the subclass)
      */
-    protected void encode(OutputStream out, ObjectIdentifier extensionId,
-        boolean isCritical) throws IOException {
-
-       DerOutputStream  tmp = new DerOutputStream();
+    protected void encode(DerOutputStream out, ObjectIdentifier extensionId,
+        boolean isCritical) {
 
        if (this.extensionValue == null) {
            this.extensionId = extensionId;
            this.critical = isCritical;
            encodeThis();
        }
-       super.encode(tmp);
-       out.write(tmp.toByteArray());
+       super.encode(out);
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
      * attribute.
diff a/src/java.base/share/classes/sun/security/x509/CRLReasonCodeExtension.java b/src/java.base/share/classes/sun/security/x509/CRLReasonCodeExtension.java
--- a/src/java.base/share/classes/sun/security/x509/CRLReasonCodeExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/CRLReasonCodeExtension.java
@@ -51,11 +51,11 @@
 
     private static CRLReason[] values = CRLReason.values();
 
     private int reasonCode = 0;
 
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (reasonCode == 0) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream dos = new DerOutputStream();
@@ -156,20 +156,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream  tmp = new DerOutputStream();
-
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = PKIXExtensions.ReasonCode_Id;
             this.critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
      * attribute.
diff a/src/java.base/share/classes/sun/security/x509/CertAttrSet.java b/src/java.base/share/classes/sun/security/x509/CertAttrSet.java
--- a/src/java.base/share/classes/sun/security/x509/CertAttrSet.java
+++ b/src/java.base/share/classes/sun/security/x509/CertAttrSet.java
@@ -23,10 +23,12 @@
  * questions.
  */
 
 package sun.security.x509;
 
+import sun.security.util.DerOutputStream;
+
 import java.io.IOException;
 import java.io.OutputStream;
 import java.security.cert.CertificateException;
 import java.util.Enumeration;
 
@@ -61,12 +63,11 @@
      * @param out the OutputStream to encode the attribute to.
      *
      * @exception CertificateException on encoding or validity errors.
      * @exception IOException on other errors.
      */
-    void encode(OutputStream out)
-        throws CertificateException, IOException;
+    void encode(DerOutputStream out) throws CertificateException;
 
     /**
      * Sets an attribute value within this CertAttrSet.
      *
      * @param name the name of the attribute (e.g. "x509.info.key")
diff a/src/java.base/share/classes/sun/security/x509/CertificateAlgorithmId.java b/src/java.base/share/classes/sun/security/x509/CertificateAlgorithmId.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateAlgorithmId.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateAlgorithmId.java
@@ -103,15 +103,13 @@
      * Encode the algorithm identifier in DER form to the stream.
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
-        algId.encode(tmp);
-
-        out.write(tmp.toByteArray());
+    @Override
+    public void encode(DerOutputStream out) {
+        algId.derEncode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificateExtensions.java b/src/java.base/share/classes/sun/security/x509/CertificateExtensions.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateExtensions.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateExtensions.java
@@ -150,12 +150,12 @@
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @exception CertificateException on encoding errors.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out)
-    throws CertificateException, IOException {
+    @Override
+    public void encode(DerOutputStream out) throws CertificateException {
         encode(out, false);
     }
 
     /**
      * Encode the extensions in DER form to the stream.
@@ -163,12 +163,12 @@
      * @param out the DerOutputStream to marshal the contents to.
      * @param isCertReq if true then no context specific tag is added.
      * @exception CertificateException on encoding errors.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out, boolean isCertReq)
-    throws CertificateException, IOException {
+    public void encode(DerOutputStream out, boolean isCertReq)
+            throws CertificateException {
         DerOutputStream extOut = new DerOutputStream();
         Collection<Extension> allExts = map.values();
         Object[] objs = allExts.toArray();
 
         for (int i = 0; i < objs.length; i++) {
diff a/src/java.base/share/classes/sun/security/x509/CertificateIssuerExtension.java b/src/java.base/share/classes/sun/security/x509/CertificateIssuerExtension.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateIssuerExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateIssuerExtension.java
@@ -72,11 +72,11 @@
     private GeneralNames names;
 
     /**
      * Encode this extension
      */
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (names == null || names.isEmpty()) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -177,19 +177,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to
      * @exception IOException on encoding errors
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream  tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
             extensionId = PKIXExtensions.CertificateIssuer_Id;
             critical = true;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
      * attribute.
diff a/src/java.base/share/classes/sun/security/x509/CertificateIssuerName.java b/src/java.base/share/classes/sun/security/x509/CertificateIssuerName.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateIssuerName.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateIssuerName.java
@@ -105,15 +105,13 @@
      * Encode the name in DER form to the stream.
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
-        dnName.encode(tmp);
-
-        out.write(tmp.toByteArray());
+    @Override
+    public void encode(DerOutputStream out) {
+        dnName.derEncode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificatePoliciesExtension.java b/src/java.base/share/classes/sun/security/x509/CertificatePoliciesExtension.java
--- a/src/java.base/share/classes/sun/security/x509/CertificatePoliciesExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificatePoliciesExtension.java
@@ -83,11 +83,11 @@
      * List of PolicyInformation for this object.
      */
     private List<PolicyInformation> certPolicies;
 
     // Encode this extension value.
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (certPolicies == null || certPolicies.isEmpty()) {
             this.extensionValue = null;
         } else {
             DerOutputStream os = new DerOutputStream();
             DerOutputStream tmp = new DerOutputStream();
@@ -175,19 +175,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
           extensionId = PKIXExtensions.CertificatePolicies_Id;
           critical = false;
           encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificatePolicyId.java b/src/java.base/share/classes/sun/security/x509/CertificatePolicyId.java
--- a/src/java.base/share/classes/sun/security/x509/CertificatePolicyId.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificatePolicyId.java
@@ -78,11 +78,11 @@
      * Write the CertificatePolicyId to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the object to.
      * @exception IOException on errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         out.putOID(id);
     }
 
     /**
      * Compares this CertificatePolicyId with another, for
diff a/src/java.base/share/classes/sun/security/x509/CertificatePolicyMap.java b/src/java.base/share/classes/sun/security/x509/CertificatePolicyMap.java
--- a/src/java.base/share/classes/sun/security/x509/CertificatePolicyMap.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificatePolicyMap.java
@@ -94,11 +94,11 @@
      * Write the CertificatePolicyMap to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the object to.
      * @exception IOException on errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream tmp = new DerOutputStream();
 
         issuerDomain.encode(tmp);
         subjectDomain.encode(tmp);
         out.write(DerValue.tag_Sequence,tmp);
diff a/src/java.base/share/classes/sun/security/x509/CertificatePolicySet.java b/src/java.base/share/classes/sun/security/x509/CertificatePolicySet.java
--- a/src/java.base/share/classes/sun/security/x509/CertificatePolicySet.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificatePolicySet.java
@@ -81,11 +81,11 @@
     /**
      * Encode the policy set to the output stream.
      *
      * @param out the DerOutputStream to encode the data to.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream tmp = new DerOutputStream();
 
         for (int i = 0; i < ids.size(); i++) {
             ids.elementAt(i).encode(tmp);
         }
diff a/src/java.base/share/classes/sun/security/x509/CertificateSerialNumber.java b/src/java.base/share/classes/sun/security/x509/CertificateSerialNumber.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateSerialNumber.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateSerialNumber.java
@@ -115,15 +115,13 @@
      * Encode the serial number in DER form to the stream.
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
-        serial.encode(tmp);
-
-        out.write(tmp.toByteArray());
+    @Override
+    public void encode(DerOutputStream out) {
+        serial.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificateSubjectName.java b/src/java.base/share/classes/sun/security/x509/CertificateSubjectName.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateSubjectName.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateSubjectName.java
@@ -105,15 +105,13 @@
      * Encode the name in DER form to the stream.
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
-        dnName.encode(tmp);
-
-        out.write(tmp.toByteArray());
+    @Override
+    public void encode(DerOutputStream out) {
+        dnName.derEncode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificateValidity.java b/src/java.base/share/classes/sun/security/x509/CertificateValidity.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateValidity.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateValidity.java
@@ -145,16 +145,17 @@
      * Encode the CertificateValidity period in DER form to the stream.
      *
      * @param out the OutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
+    @Override
+    public void encode(DerOutputStream out) throws CertificateException {
 
         // in cases where default constructor is used check for
         // null values
         if (notBefore == null || notAfter == null) {
-            throw new IOException("CertAttrSet:CertificateValidity:" +
+            throw new CertificateException("CertAttrSet:CertificateValidity:" +
                                   " null values to encode.\n");
         }
         DerOutputStream pair = new DerOutputStream();
 
         if (notBefore.getTime() < YR_2050) {
@@ -165,14 +166,11 @@
         if (notAfter.getTime() < YR_2050) {
             pair.putUTCTime(notAfter);
         } else {
             pair.putGeneralizedTime(notAfter);
         }
-        DerOutputStream seq = new DerOutputStream();
-        seq.write(DerValue.tag_Sequence, pair);
-
-        out.write(seq.toByteArray());
+        out.write(DerValue.tag_Sequence, pair);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificateVersion.java b/src/java.base/share/classes/sun/security/x509/CertificateVersion.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateVersion.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateVersion.java
@@ -156,23 +156,21 @@
      * Encode the CertificateVersion period in DER form to the stream.
      *
      * @param out the OutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
+    @Override
+    public void encode(DerOutputStream out) {
         // Nothing for default
         if (version == V1) {
             return;
         }
         DerOutputStream tmp = new DerOutputStream();
         tmp.putInteger(version);
 
-        DerOutputStream seq = new DerOutputStream();
-        seq.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0),
+        out.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0),
                   tmp);
-
-        out.write(seq.toByteArray());
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/CertificateX509Key.java b/src/java.base/share/classes/sun/security/x509/CertificateX509Key.java
--- a/src/java.base/share/classes/sun/security/x509/CertificateX509Key.java
+++ b/src/java.base/share/classes/sun/security/x509/CertificateX509Key.java
@@ -98,15 +98,13 @@
      * Encode the key in DER form to the stream.
      *
      * @param out the OutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
-        tmp.write(key.getEncoded());
-
-        out.write(tmp.toByteArray());
+    @Override
+    public void encode(DerOutputStream out) {
+        out.write(key.getEncoded());
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/DNSName.java b/src/java.base/share/classes/sun/security/x509/DNSName.java
--- a/src/java.base/share/classes/sun/security/x509/DNSName.java
+++ b/src/java.base/share/classes/sun/security/x509/DNSName.java
@@ -150,11 +150,12 @@
      * Encode the DNSName into the DerOutputStream.
      *
      * @param out the DER stream to encode the DNSName to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.putIA5String(name);
     }
 
     /**
      * Convert the name into user readable string.
diff a/src/java.base/share/classes/sun/security/x509/DeltaCRLIndicatorExtension.java b/src/java.base/share/classes/sun/security/x509/DeltaCRLIndicatorExtension.java
--- a/src/java.base/share/classes/sun/security/x509/DeltaCRLIndicatorExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/DeltaCRLIndicatorExtension.java
@@ -107,10 +107,10 @@
      * Writes the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-       DerOutputStream  tmp = new DerOutputStream();
-        super.encode(out, PKIXExtensions.DeltaCRLIndicator_Id, true);
+    @Override
+    public void encode(DerOutputStream out) {
+       super.encode(out, PKIXExtensions.DeltaCRLIndicator_Id, true);
     }
 }
diff a/src/java.base/share/classes/sun/security/x509/DistributionPoint.java b/src/java.base/share/classes/sun/security/x509/DistributionPoint.java
--- a/src/java.base/share/classes/sun/security/x509/DistributionPoint.java
+++ b/src/java.base/share/classes/sun/security/x509/DistributionPoint.java
@@ -275,11 +275,11 @@
      * Write the DistributionPoint value to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on error.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream tagged = new DerOutputStream();
 
         // NOTE: only one of pointNames and pointRDN can be set
         if ((fullName != null) || (relativeName != null)) {
             DerOutputStream distributionPoint = new DerOutputStream();
@@ -289,11 +289,11 @@
                 distributionPoint.writeImplicit(
                     DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_FULL_NAME),
                     derOut);
             } else if (relativeName != null) {
                 DerOutputStream derOut = new DerOutputStream();
-                relativeName.encode(derOut);
+                relativeName.derEncode(derOut);
                 distributionPoint.writeImplicit(
                     DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_REL_NAME),
                     derOut);
             }
             tagged.write(
diff a/src/java.base/share/classes/sun/security/x509/DistributionPointName.java b/src/java.base/share/classes/sun/security/x509/DistributionPointName.java
--- a/src/java.base/share/classes/sun/security/x509/DistributionPointName.java
+++ b/src/java.base/share/classes/sun/security/x509/DistributionPointName.java
@@ -26,11 +26,10 @@
 package sun.security.x509;
 
 import java.io.IOException;
 import java.util.*;
 
-import sun.security.util.BitArray;
 import sun.security.util.DerOutputStream;
 import sun.security.util.DerValue;
 
 /**
  * Represents the DistributionPointName ASN.1 type.
@@ -165,22 +164,22 @@
      * Encodes the distribution point name and writes it to the DerOutputStream.
      *
      * @param out the output stream.
      * @exception IOException on encoding error.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
 
         DerOutputStream theChoice = new DerOutputStream();
 
         if (fullName != null) {
             fullName.encode(theChoice);
             out.writeImplicit(
                 DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_FULL_NAME),
                 theChoice);
 
         } else {
-            relativeName.encode(theChoice);
+            relativeName.derEncode(theChoice);
             out.writeImplicit(
                 DerValue.createTag(DerValue.TAG_CONTEXT, true,
                     TAG_RELATIVE_NAME),
                 theChoice);
         }
diff a/src/java.base/share/classes/sun/security/x509/EDIPartyName.java b/src/java.base/share/classes/sun/security/x509/EDIPartyName.java
--- a/src/java.base/share/classes/sun/security/x509/EDIPartyName.java
+++ b/src/java.base/share/classes/sun/security/x509/EDIPartyName.java
@@ -24,10 +24,12 @@
  */
 
 package sun.security.x509;
 
 import java.io.IOException;
+import java.util.Objects;
+
 import sun.security.util.*;
 
 /**
  * This class defines the EDIPartyName of the GeneralName choice.
  * The ASN.1 syntax for this is:
@@ -46,12 +48,12 @@
 
     // Private data members
     private static final byte TAG_ASSIGNER = 0;
     private static final byte TAG_PARTYNAME = 1;
 
-    private String assigner = null;
-    private String party = null;
+    private final String assigner;
+    private final String party;
 
     private int myhash = -1;
 
     /**
      * Create the EDIPartyName object from the specified names.
@@ -59,20 +61,20 @@
      * @param assignerName the name of the assigner
      * @param partyName the name of the EDI party.
      */
     public EDIPartyName(String assignerName, String partyName) {
         this.assigner = assignerName;
-        this.party = partyName;
+        this.party = Objects.requireNonNull(partyName);
     }
 
     /**
      * Create the EDIPartyName object from the specified name.
      *
      * @param partyName the name of the EDI party.
      */
     public EDIPartyName(String partyName) {
-        this.party = partyName;
+        this(null, partyName);
     }
 
     /**
      * Create the EDIPartyName object from the passed encoded Der value.
      *
@@ -85,29 +87,37 @@
 
         int len = seq.length;
         if (len < 1 || len > 2)
             throw new IOException("Invalid encoding of EDIPartyName");
 
+        String tmpAssigner = null;
+        String tmpParty = null;
         for (int i = 0; i < len; i++) {
             DerValue opt = seq[i];
             if (opt.isContextSpecific(TAG_ASSIGNER) &&
                 !opt.isConstructed()) {
-                if (assigner != null)
+                if (tmpAssigner != null)
                     throw new IOException("Duplicate nameAssigner found in"
                                           + " EDIPartyName");
                 opt = opt.data.getDerValue();
-                assigner = opt.getAsString();
+                tmpAssigner = opt.getAsString();
             }
             if (opt.isContextSpecific(TAG_PARTYNAME) &&
                 !opt.isConstructed()) {
-                if (party != null)
+                if (tmpParty != null)
                     throw new IOException("Duplicate partyName found in"
                                           + " EDIPartyName");
                 opt = opt.data.getDerValue();
-                party = opt.getAsString();
+                tmpParty = opt.getAsString();
             }
         }
+        if (tmpParty == null) {
+            throw new IOException("partyName unfound in"
+                    + " EDIPartyName");
+        }
+        assigner = tmpAssigner;
+        party = tmpParty;
     }
 
     /**
      * Return the type of the GeneralName.
      */
@@ -119,23 +129,22 @@
      * Encode the EDI party name into the DerOutputStream.
      *
      * @param out the DER stream to encode the EDIPartyName to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         DerOutputStream tagged = new DerOutputStream();
         DerOutputStream tmp = new DerOutputStream();
 
         if (assigner != null) {
             DerOutputStream tmp2 = new DerOutputStream();
             // XXX - shd check is chars fit into PrintableString
             tmp2.putPrintableString(assigner);
             tagged.write(DerValue.createTag(DerValue.TAG_CONTEXT,
                                  false, TAG_ASSIGNER), tmp2);
         }
-        if (party == null)
-            throw  new IOException("Cannot have null partyName");
 
         // XXX - shd check is chars fit into PrintableString
         tmp.putPrintableString(party);
         tagged.write(DerValue.createTag(DerValue.TAG_CONTEXT,
                                  false, TAG_PARTYNAME), tmp);
@@ -178,28 +187,23 @@
         } else {
             if (!(this.assigner.equals(otherAssigner)))
                 return false;
         }
         String otherParty = ((EDIPartyName)other).party;
-        if (this.party == null) {
-            if (otherParty != null)
-                return false;
-        } else {
-            if (!(this.party.equals(otherParty)))
-                return false;
-        }
+        if (!(this.party.equals(otherParty)))
+            return false;
         return true;
     }
 
     /**
      * Returns the hash code value for this EDIPartyName.
      *
      * @return a hash code value.
      */
     public int hashCode() {
         if (myhash == -1) {
-            myhash = 37 + (party == null ? 1 : party.hashCode());
+            myhash = 37 + party.hashCode();
             if (assigner != null) {
                 myhash = 37 * myhash + assigner.hashCode();
             }
         }
         return myhash;
diff a/src/java.base/share/classes/sun/security/x509/ExtendedKeyUsageExtension.java b/src/java.base/share/classes/sun/security/x509/ExtendedKeyUsageExtension.java
--- a/src/java.base/share/classes/sun/security/x509/ExtendedKeyUsageExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/ExtendedKeyUsageExtension.java
@@ -96,11 +96,11 @@
      * Vector of KeyUsages for this object.
      */
     private Vector<ObjectIdentifier> keyUsages;
 
     // Encode this extension value.
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (keyUsages == null || keyUsages.isEmpty()) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -195,19 +195,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
           extensionId = PKIXExtensions.ExtendedKeyUsage_Id;
           critical = false;
           encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/Extension.java b/src/java.base/share/classes/sun/security/x509/Extension.java
--- a/src/java.base/share/classes/sun/security/x509/Extension.java
+++ b/src/java.base/share/classes/sun/security/x509/Extension.java
@@ -26,10 +26,12 @@
 package sun.security.x509;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Arrays;
+import java.util.Objects;
+
 import sun.security.util.*;
 
 /**
  * Represent a X509 Extension Attribute.
  *
@@ -163,16 +165,14 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
 
-        if (extensionId == null)
-            throw new IOException("Null OID to encode for the extension!");
-        if (extensionValue == null)
-            throw new IOException("No value to encode for the extension!");
+        Objects.requireNonNull(extensionId);
+        Objects.requireNonNull(extensionValue);
 
         DerOutputStream dos = new DerOutputStream();
 
         dos.putOID(extensionId);
         if (critical)
diff a/src/java.base/share/classes/sun/security/x509/FreshestCRLExtension.java b/src/java.base/share/classes/sun/security/x509/FreshestCRLExtension.java
--- a/src/java.base/share/classes/sun/security/x509/FreshestCRLExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/FreshestCRLExtension.java
@@ -91,9 +91,10 @@
      * Writes the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
+    @Override
+    public void encode(DerOutputStream out) {
         super.encode(out, PKIXExtensions.FreshestCRL_Id, false);
     }
 }
diff a/src/java.base/share/classes/sun/security/x509/GeneralName.java b/src/java.base/share/classes/sun/security/x509/GeneralName.java
--- a/src/java.base/share/classes/sun/security/x509/GeneralName.java
+++ b/src/java.base/share/classes/sun/security/x509/GeneralName.java
@@ -231,13 +231,13 @@
      * Encode the name to the specified DerOutputStream.
      *
      * @param out the DerOutputStream to encode the GeneralName to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream tmp = new DerOutputStream();
-        name.encode(tmp);
+        name.derEncode(tmp);
         int nameType = name.getType();
         if (nameType == GeneralNameInterface.NAME_ANY ||
             nameType == GeneralNameInterface.NAME_X400 ||
             nameType == GeneralNameInterface.NAME_EDI) {
 
diff a/src/java.base/share/classes/sun/security/x509/GeneralNameInterface.java b/src/java.base/share/classes/sun/security/x509/GeneralNameInterface.java
--- a/src/java.base/share/classes/sun/security/x509/GeneralNameInterface.java
+++ b/src/java.base/share/classes/sun/security/x509/GeneralNameInterface.java
@@ -34,11 +34,11 @@
  * implemented by all the members of the GeneralNames ASN.1 object.
  *
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
-public interface GeneralNameInterface {
+public interface GeneralNameInterface extends DerEncoder {
     /**
      * The list of names supported.
      */
     public static final int NAME_ANY = 0;
     public static final int NAME_RFC822 = 1;
@@ -63,19 +63,10 @@
      * Return the type of the general name, as
      * defined above.
      */
     int getType();
 
-    /**
-     * Encode the name to the specified DerOutputStream.
-     *
-     * @param out the DerOutputStream to encode the GeneralName to.
-     * @exception IOException thrown if the GeneralName could not be
-     *            encoded.
-     */
-    void encode(DerOutputStream out) throws IOException;
-
     /**
      * Return type of constraint inputName places on this name:<ul>
      *   <li>NAME_DIFF_TYPE = -1: input name is different type from name (i.e. does not constrain).
      *   <li>NAME_MATCH = 0: input name matches name.
      *   <li>NAME_NARROWS = 1: input name narrows name (is lower in the naming subtree)
diff a/src/java.base/share/classes/sun/security/x509/GeneralNames.java b/src/java.base/share/classes/sun/security/x509/GeneralNames.java
--- a/src/java.base/share/classes/sun/security/x509/GeneralNames.java
+++ b/src/java.base/share/classes/sun/security/x509/GeneralNames.java
@@ -109,11 +109,11 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on error.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         if (isEmpty()) {
             return;
         }
 
         DerOutputStream temp = new DerOutputStream();
diff a/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java b/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java
--- a/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java
+++ b/src/java.base/share/classes/sun/security/x509/GeneralSubtree.java
@@ -194,11 +194,11 @@
     /**
      * Encode the GeneralSubtree.
      *
      * @param out the DerOutputStream to encode this object to.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream seq = new DerOutputStream();
 
         name.encode(seq);
 
         if (minimum != MIN_DEFAULT) {
diff a/src/java.base/share/classes/sun/security/x509/GeneralSubtrees.java b/src/java.base/share/classes/sun/security/x509/GeneralSubtrees.java
--- a/src/java.base/share/classes/sun/security/x509/GeneralSubtrees.java
+++ b/src/java.base/share/classes/sun/security/x509/GeneralSubtrees.java
@@ -130,11 +130,11 @@
     /**
      * Encode the GeneralSubtrees.
      *
      * @param out the DerOutputStrean to encode this object to.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream seq = new DerOutputStream();
 
         for (int i = 0, n = size(); i < n; i++) {
             get(i).encode(seq);
         }
diff a/src/java.base/share/classes/sun/security/x509/IPAddressName.java b/src/java.base/share/classes/sun/security/x509/IPAddressName.java
--- a/src/java.base/share/classes/sun/security/x509/IPAddressName.java
+++ b/src/java.base/share/classes/sun/security/x509/IPAddressName.java
@@ -227,11 +227,12 @@
      * Encode the IPAddress name into the DerOutputStream.
      *
      * @param out the DER stream to encode the IPAddressName to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.putOctetString(address);
     }
 
     /**
      * Return a printable string of IPaddress
diff a/src/java.base/share/classes/sun/security/x509/InhibitAnyPolicyExtension.java b/src/java.base/share/classes/sun/security/x509/InhibitAnyPolicyExtension.java
--- a/src/java.base/share/classes/sun/security/x509/InhibitAnyPolicyExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/InhibitAnyPolicyExtension.java
@@ -83,11 +83,11 @@
 
     // Private data members
     private int skipCerts = Integer.MAX_VALUE;
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         DerOutputStream out = new DerOutputStream();
         out.putInteger(skipCerts);
         this.extensionValue = out.toByteArray();
     }
 
@@ -158,20 +158,18 @@
      /**
       * Encode this extension value to the output stream.
       *
       * @param out the DerOutputStream to encode the extension to.
       */
-     public void encode(OutputStream out) throws IOException {
-         DerOutputStream tmp = new DerOutputStream();
+     @Override
+     public void encode(DerOutputStream out) {
          if (extensionValue == null) {
              this.extensionId = PKIXExtensions.InhibitAnyPolicy_Id;
              critical = true;
              encodeThis();
          }
-         super.encode(tmp);
-
-         out.write(tmp.toByteArray());
+         super.encode(out);
      }
 
     /**
      * Set the attribute value.
      *
diff a/src/java.base/share/classes/sun/security/x509/InvalidityDateExtension.java b/src/java.base/share/classes/sun/security/x509/InvalidityDateExtension.java
--- a/src/java.base/share/classes/sun/security/x509/InvalidityDateExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/InvalidityDateExtension.java
@@ -66,11 +66,11 @@
     public static final String NAME = "InvalidityDate";
     public static final String DATE = "date";
 
     private Date date;
 
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (date == null) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream dos = new DerOutputStream();
@@ -175,20 +175,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to
      * @exception IOException on encoding errors
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream  tmp = new DerOutputStream();
-
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = PKIXExtensions.InvalidityDate_Id;
             this.critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
      * attribute.
diff a/src/java.base/share/classes/sun/security/x509/IssuerAlternativeNameExtension.java b/src/java.base/share/classes/sun/security/x509/IssuerAlternativeNameExtension.java
--- a/src/java.base/share/classes/sun/security/x509/IssuerAlternativeNameExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/IssuerAlternativeNameExtension.java
@@ -63,11 +63,11 @@
 
     // private data members
     GeneralNames names = null;
 
     // Encode this extension
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (names == null || names.isEmpty()) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -160,19 +160,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on encoding error.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
             extensionId = PKIXExtensions.IssuerAlternativeName_Id;
             critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java b/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
--- a/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
@@ -232,19 +232,18 @@
      * DerOutputStream.
      *
      * @param out the output stream.
      * @exception IOException on encoding error.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = PKIXExtensions.IssuingDistributionPoint_Id;
             this.critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Sets the attribute value.
      */
@@ -372,11 +371,11 @@
         elements.addElement(INDIRECT_CRL);
         return elements.elements();
     }
 
      // Encodes this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
 
         if (distributionPoint == null &&
             revocationReasons == null &&
             !hasOnlyUserCerts &&
             !hasOnlyCACerts &&
diff a/src/java.base/share/classes/sun/security/x509/KeyIdentifier.java b/src/java.base/share/classes/sun/security/x509/KeyIdentifier.java
--- a/src/java.base/share/classes/sun/security/x509/KeyIdentifier.java
+++ b/src/java.base/share/classes/sun/security/x509/KeyIdentifier.java
@@ -123,11 +123,11 @@
      * Write the KeyIdentifier to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the object to.
      * @exception IOException
      */
-    void encode(DerOutputStream out) throws IOException {
+    void encode(DerOutputStream out) {
         out.putOctetString(octetString);
     }
 
     /**
      * Returns a hash code value for this object.
diff a/src/java.base/share/classes/sun/security/x509/KeyUsageExtension.java b/src/java.base/share/classes/sun/security/x509/KeyUsageExtension.java
--- a/src/java.base/share/classes/sun/security/x509/KeyUsageExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/KeyUsageExtension.java
@@ -69,11 +69,11 @@
 
     // Private data members
     private boolean[] bitString;
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         DerOutputStream os = new DerOutputStream();
         os.putTruncatedUnalignedBitString(new BitArray(this.bitString));
         this.extensionValue = os.toByteArray();
     }
 
@@ -316,20 +316,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-       DerOutputStream  tmp = new DerOutputStream();
-
+    @Override
+    public void encode(DerOutputStream out) {
        if (this.extensionValue == null) {
            this.extensionId = PKIXExtensions.KeyUsage_Id;
            this.critical = true;
            encodeThis();
        }
-       super.encode(tmp);
-       out.write(tmp.toByteArray());
+       super.encode(out);
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
      * attribute.
diff a/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java b/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/NameConstraintsExtension.java
@@ -111,11 +111,11 @@
         }
         minMaxValid = true;
     }
 
     // Encode this extension value.
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         minMaxValid = false;
         if (permitted == null && excluded == null) {
             this.extensionValue = null;
             return;
         }
@@ -234,19 +234,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = PKIXExtensions.NameConstraints_Id;
             this.critical = true;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/NetscapeCertTypeExtension.java b/src/java.base/share/classes/sun/security/x509/NetscapeCertTypeExtension.java
--- a/src/java.base/share/classes/sun/security/x509/NetscapeCertTypeExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/NetscapeCertTypeExtension.java
@@ -113,11 +113,11 @@
         throw new IOException("Attribute name [" + name
                              + "] not recognized by CertAttrSet:NetscapeCertType.");
     }
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         DerOutputStream os = new DerOutputStream();
         os.putTruncatedUnalignedBitString(new BitArray(this.bitString));
         this.extensionValue = os.toByteArray();
     }
 
@@ -262,20 +262,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream  tmp = new DerOutputStream();
-
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = NetscapeCertType_Id;
             this.critical = true;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
      * attribute.
diff a/src/java.base/share/classes/sun/security/x509/OIDName.java b/src/java.base/share/classes/sun/security/x509/OIDName.java
--- a/src/java.base/share/classes/sun/security/x509/OIDName.java
+++ b/src/java.base/share/classes/sun/security/x509/OIDName.java
@@ -86,11 +86,12 @@
      * Encode the OID name into the DerOutputStream.
      *
      * @param out the DER stream to encode the OIDName to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.putOID(oid);
     }
 
     /**
      * Convert the name into user readable string.
diff a/src/java.base/share/classes/sun/security/x509/OtherName.java b/src/java.base/share/classes/sun/security/x509/OtherName.java
--- a/src/java.base/share/classes/sun/security/x509/OtherName.java
+++ b/src/java.base/share/classes/sun/security/x509/OtherName.java
@@ -147,14 +147,15 @@
      * Encode the Other name into the DerOutputStream.
      *
      * @param out the DER stream to encode the Other-Name to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         if (gni != null) {
             // This OtherName has a supported class
-            gni.encode(out);
+            gni.derEncode(out);
             return;
         } else {
             // This OtherName has no supporting class
             DerOutputStream tmp = new DerOutputStream();
             tmp.putOID(oid);
diff a/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java b/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/PolicyConstraintsExtension.java
@@ -73,11 +73,11 @@
 
     private int require = -1;
     private int inhibit = -1;
 
     // Encode this extension value.
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (require == -1 && inhibit == -1) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream tagged = new DerOutputStream();
@@ -199,19 +199,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
           extensionId = PKIXExtensions.PolicyConstraints_Id;
           critical = true;
           encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/PolicyInformation.java b/src/java.base/share/classes/sun/security/x509/PolicyInformation.java
--- a/src/java.base/share/classes/sun/security/x509/PolicyInformation.java
+++ b/src/java.base/share/classes/sun/security/x509/PolicyInformation.java
@@ -265,11 +265,11 @@
      * Write the PolicyInformation to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         DerOutputStream tmp = new DerOutputStream();
         policyIdentifier.encode(tmp);
         if (!policyQualifiers.isEmpty()) {
             DerOutputStream tmp2 = new DerOutputStream();
             for (PolicyQualifierInfo pq : policyQualifiers) {
diff a/src/java.base/share/classes/sun/security/x509/PolicyMappingsExtension.java b/src/java.base/share/classes/sun/security/x509/PolicyMappingsExtension.java
--- a/src/java.base/share/classes/sun/security/x509/PolicyMappingsExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/PolicyMappingsExtension.java
@@ -65,11 +65,11 @@
 
     // Private data members
     private List<CertificatePolicyMap> maps;
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (maps == null || maps.isEmpty()) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -147,19 +147,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
             extensionId = PKIXExtensions.PolicyMappings_Id;
             critical = true;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java b/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java
--- a/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/PrivateKeyUsageExtension.java
@@ -79,11 +79,11 @@
 
     private Date        notBefore = null;
     private Date        notAfter = null;
 
     // Encode this extension value.
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (notBefore == null && notAfter == null) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream seq = new DerOutputStream();
@@ -238,19 +238,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
             extensionId = PKIXExtensions.PrivateKeyUsage_Id;
             critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      * @exception CertificateException on attribute handling errors.
diff a/src/java.base/share/classes/sun/security/x509/RDN.java b/src/java.base/share/classes/sun/security/x509/RDN.java
--- a/src/java.base/share/classes/sun/security/x509/RDN.java
+++ b/src/java.base/share/classes/sun/security/x509/RDN.java
@@ -60,11 +60,11 @@
  * </pre>
  *
  * Note that instances of this class are immutable.
  *
  */
-public class RDN {
+public class RDN implements DerEncoder {
 
     // currently not private, accessed directly from X500Name
     final AVA[] assertion;
 
     // cached immutable List of the AVAs
@@ -334,11 +334,12 @@
      * Encode the RDN in DER-encoded form.
      *
      * @param out DerOutputStream to which RDN is to be written
      * @throws IOException on error
      */
-    void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.putOrderedSetOf(DerValue.tag_Set, assertion);
     }
 
     /*
      * Returns a printable form of this RDN, using RFC 1779 style catenation
diff a/src/java.base/share/classes/sun/security/x509/RFC822Name.java b/src/java.base/share/classes/sun/security/x509/RFC822Name.java
--- a/src/java.base/share/classes/sun/security/x509/RFC822Name.java
+++ b/src/java.base/share/classes/sun/security/x509/RFC822Name.java
@@ -114,11 +114,12 @@
      * Encode the RFC822 name into the DerOutputStream.
      *
      * @param out the DER stream to encode the RFC822Name to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.putIA5String(name);
     }
 
     /**
      * Convert the name into user readable string.
diff a/src/java.base/share/classes/sun/security/x509/ReasonFlags.java b/src/java.base/share/classes/sun/security/x509/ReasonFlags.java
--- a/src/java.base/share/classes/sun/security/x509/ReasonFlags.java
+++ b/src/java.base/share/classes/sun/security/x509/ReasonFlags.java
@@ -238,11 +238,11 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         out.putTruncatedUnalignedBitString(new BitArray(this.bitString));
     }
 
     /**
      * Return an enumeration of names of attributes existing within this
diff a/src/java.base/share/classes/sun/security/x509/SerialNumber.java b/src/java.base/share/classes/sun/security/x509/SerialNumber.java
--- a/src/java.base/share/classes/sun/security/x509/SerialNumber.java
+++ b/src/java.base/share/classes/sun/security/x509/SerialNumber.java
@@ -108,11 +108,11 @@
      * Encode the SerialNumber in DER form to the stream.
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @exception IOException on errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    public void encode(DerOutputStream out) {
         out.putInteger(serialNum);
     }
 
     /**
      * Return the serial number.
diff a/src/java.base/share/classes/sun/security/x509/SubjectAlternativeNameExtension.java b/src/java.base/share/classes/sun/security/x509/SubjectAlternativeNameExtension.java
--- a/src/java.base/share/classes/sun/security/x509/SubjectAlternativeNameExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/SubjectAlternativeNameExtension.java
@@ -68,11 +68,11 @@
 
     // private data members
     GeneralNames        names = null;
 
     // Encode this extension
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (names == null || names.isEmpty()) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -162,19 +162,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
             extensionId = PKIXExtensions.SubjectAlternativeName_Id;
             critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/SubjectInfoAccessExtension.java b/src/java.base/share/classes/sun/security/x509/SubjectInfoAccessExtension.java
--- a/src/java.base/share/classes/sun/security/x509/SubjectInfoAccessExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/SubjectInfoAccessExtension.java
@@ -152,19 +152,18 @@
      * Write the extension to the DerOutputStream.
      *
      * @param out the DerOutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (this.extensionValue == null) {
             this.extensionId = PKIXExtensions.SubjectInfoAccess_Id;
             this.critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
@@ -220,11 +219,11 @@
         elements.addElement(DESCRIPTIONS);
         return elements.elements();
     }
 
      // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (accessDescriptions.isEmpty()) {
             this.extensionValue = null;
         } else {
             DerOutputStream ads = new DerOutputStream();
             for (AccessDescription accessDescription : accessDescriptions) {
diff a/src/java.base/share/classes/sun/security/x509/SubjectKeyIdentifierExtension.java b/src/java.base/share/classes/sun/security/x509/SubjectKeyIdentifierExtension.java
--- a/src/java.base/share/classes/sun/security/x509/SubjectKeyIdentifierExtension.java
+++ b/src/java.base/share/classes/sun/security/x509/SubjectKeyIdentifierExtension.java
@@ -68,11 +68,11 @@
 
     // Private data member
     private KeyIdentifier id = null;
 
     // Encode this extension value
-    private void encodeThis() throws IOException {
+    private void encodeThis() {
         if (id == null) {
             this.extensionValue = null;
             return;
         }
         DerOutputStream os = new DerOutputStream();
@@ -123,19 +123,18 @@
      * Write the extension to the OutputStream.
      *
      * @param out the OutputStream to write the extension to.
      * @exception IOException on encoding errors.
      */
-    public void encode(OutputStream out) throws IOException {
-        DerOutputStream tmp = new DerOutputStream();
+    @Override
+    public void encode(DerOutputStream out) {
         if (extensionValue == null) {
             extensionId = PKIXExtensions.SubjectKey_Id;
             critical = false;
             encodeThis();
         }
-        super.encode(tmp);
-        out.write(tmp.toByteArray());
+        super.encode(out);
     }
 
     /**
      * Set the attribute value.
      */
diff a/src/java.base/share/classes/sun/security/x509/URIName.java b/src/java.base/share/classes/sun/security/x509/URIName.java
--- a/src/java.base/share/classes/sun/security/x509/URIName.java
+++ b/src/java.base/share/classes/sun/security/x509/URIName.java
@@ -197,11 +197,12 @@
      * Encode the URI name into the DerOutputStream.
      *
      * @param out the DER stream to encode the URIName to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.putIA5String(uri.toASCIIString());
     }
 
     /**
      * Convert the name into user readable string.
diff a/src/java.base/share/classes/sun/security/x509/UniqueIdentity.java b/src/java.base/share/classes/sun/security/x509/UniqueIdentity.java
--- a/src/java.base/share/classes/sun/security/x509/UniqueIdentity.java
+++ b/src/java.base/share/classes/sun/security/x509/UniqueIdentity.java
@@ -91,11 +91,11 @@
      *
      * @param out the DerOutputStream to marshal the contents to.
      * @param tag enocode it under the following tag.
      * @exception IOException on errors.
      */
-    public void encode(DerOutputStream out, byte tag) throws IOException {
+    public void encode(DerOutputStream out, byte tag) {
         byte[] bytes = id.toByteArray();
         int excessBits = bytes.length*8 - id.length();
 
         out.write(tag);
         out.putLength(bytes.length + 1);
diff a/src/java.base/share/classes/sun/security/x509/X400Address.java b/src/java.base/share/classes/sun/security/x509/X400Address.java
--- a/src/java.base/share/classes/sun/security/x509/X400Address.java
+++ b/src/java.base/share/classes/sun/security/x509/X400Address.java
@@ -367,13 +367,18 @@
      * Encode the X400 name into the DerOutputStream.
      *
      * @param out the DER stream to encode the X400Address to.
      * @exception IOException on encoding errors.
      */
-    public void encode(DerOutputStream out) throws IOException {
-        DerValue derValue = new DerValue(nameValue);
-        out.putDerValue(derValue);
+    @Override
+    public void derEncode(DerOutputStream out) {
+        try {
+            DerValue derValue = new DerValue(nameValue);
+            out.putDerValue(derValue);
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e);
+        }
     }
 
     /**
      * Return the printable string.
      */
diff a/src/java.base/share/classes/sun/security/x509/X500Name.java b/src/java.base/share/classes/sun/security/x509/X500Name.java
--- a/src/java.base/share/classes/sun/security/x509/X500Name.java
+++ b/src/java.base/share/classes/sun/security/x509/X500Name.java
@@ -805,22 +805,23 @@
      * @deprecated Use encode() instead
      * @param out where to put the DER-encoded X.500 name
      */
     @Deprecated
     public void emit(DerOutputStream out) throws IOException {
-        encode(out);
+        derEncode(out);
     }
 
     /**
      * Encodes the name in DER-encoded form.
      *
      * @param out where to put the DER-encoded X.500 name
      */
-    public void encode(DerOutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         DerOutputStream tmp = new DerOutputStream();
         for (int i = 0; i < names.length; i++) {
-            names[i].encode(tmp);
+            names[i].derEncode(tmp);
         }
         out.write(DerValue.tag_Sequence, tmp);
     }
 
     /**
@@ -831,11 +832,11 @@
     public byte[] getEncodedInternal() throws IOException {
         if (encoded == null) {
             DerOutputStream     out = new DerOutputStream();
             DerOutputStream     tmp = new DerOutputStream();
             for (int i = 0; i < names.length; i++) {
-                names[i].encode(tmp);
+                names[i].derEncode(tmp);
             }
             out.write(DerValue.tag_Sequence, tmp);
             encoded = out.toByteArray();
         }
         return encoded;
diff a/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java b/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java
--- a/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java
@@ -153,34 +153,30 @@
      * @param outStrm an output stream to which the encoded revoked
      * certificate is written.
      * @exception CRLException on encoding errors.
      */
     public void encode(DerOutputStream outStrm) throws CRLException {
-        try {
-            if (revokedCert == null) {
-                DerOutputStream tmp = new DerOutputStream();
-                // sequence { serialNumber, revocationDate, extensions }
-                serialNumber.encode(tmp);
-
-                if (revocationDate.getTime() < CertificateValidity.YR_2050) {
-                    tmp.putUTCTime(revocationDate);
-                } else {
-                    tmp.putGeneralizedTime(revocationDate);
-                }
+        if (revokedCert == null) {
+            DerOutputStream tmp = new DerOutputStream();
+            // sequence { serialNumber, revocationDate, extensions }
+            serialNumber.encode(tmp);
+
+            if (revocationDate.getTime() < CertificateValidity.YR_2050) {
+                tmp.putUTCTime(revocationDate);
+            } else {
+                tmp.putGeneralizedTime(revocationDate);
+            }
 
-                if (extensions != null)
-                    extensions.encode(tmp, isExplicit);
+            if (extensions != null)
+                extensions.encode(tmp, isExplicit);
 
-                DerOutputStream seq = new DerOutputStream();
-                seq.write(DerValue.tag_Sequence, tmp);
+            DerOutputStream seq = new DerOutputStream();
+            seq.write(DerValue.tag_Sequence, tmp);
 
-                revokedCert = seq.toByteArray();
-            }
-            outStrm.write(revokedCert);
-        } catch (IOException e) {
-             throw new CRLException("Encoding error: " + e.toString());
+            revokedCert = seq.toByteArray();
         }
+        outStrm.write(revokedCert);
     }
 
     /**
      * Returns the ASN.1 DER-encoded form of this CRL Entry,
      * which corresponds to the inner SEQUENCE.
diff a/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java b/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java
--- a/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CRLImpl.java
@@ -279,14 +279,14 @@
             DerOutputStream rCerts = new DerOutputStream();
             DerOutputStream seq = new DerOutputStream();
 
             if (version != 0) // v2 crl encode version
                 tmp.putInteger(version);
-            infoSigAlgId.encode(tmp);
+            infoSigAlgId.derEncode(tmp);
             if ((version == 0) && (issuer.toString() == null))
                 throw new CRLException("Null Issuer DN not allowed in v1 CRL");
-            issuer.encode(tmp);
+            issuer.derEncode(tmp);
 
             if (thisUpdate.getTime() < CertificateValidity.YR_2050)
                 tmp.putUTCTime(thisUpdate);
             else
                 tmp.putGeneralizedTime(thisUpdate);
@@ -483,60 +483,55 @@
      * @exception NoSuchProviderException on incorrect provider.
      * @exception SignatureException on signature errors.
      * @exception CRLException if any mandatory data was omitted.
      */
     public void sign(PrivateKey key, String algorithm, String provider)
-    throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
-        NoSuchProviderException, SignatureException {
+            throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
+            NoSuchProviderException, SignatureException {
+        if (readOnly)
+            throw new CRLException("cannot over-write existing CRL");
+        Signature sigEngine = null;
+        if (provider == null || provider.isEmpty())
+            sigEngine = Signature.getInstance(algorithm);
+        else
+            sigEngine = Signature.getInstance(algorithm, provider);
+
+        AlgorithmParameterSpec params = AlgorithmId
+                .getDefaultAlgorithmParameterSpec(algorithm, key);
         try {
-            if (readOnly)
-                throw new CRLException("cannot over-write existing CRL");
-            Signature sigEngine = null;
-            if (provider == null || provider.isEmpty())
-                sigEngine = Signature.getInstance(algorithm);
-            else
-                sigEngine = Signature.getInstance(algorithm, provider);
-
-            AlgorithmParameterSpec params = AlgorithmId
-                    .getDefaultAlgorithmParameterSpec(algorithm, key);
-            try {
-                SignatureUtil.initSignWithParam(sigEngine, key, params, null);
-            } catch (InvalidAlgorithmParameterException e) {
-                throw new SignatureException(e);
-            }
+            SignatureUtil.initSignWithParam(sigEngine, key, params, null);
+        } catch (InvalidAlgorithmParameterException e) {
+            throw new SignatureException(e);
+        }
 
-            if (params != null) {
-                sigAlgId = AlgorithmId.get(sigEngine.getParameters());
-            } else {
-                // in case the name is reset
-                sigAlgId = AlgorithmId.get(sigEngine.getAlgorithm());
-            }
-            infoSigAlgId = sigAlgId;
+        if (params != null) {
+            sigAlgId = AlgorithmId.get(sigEngine.getParameters());
+        } else {
+            // in case the name is reset
+            sigAlgId = AlgorithmId.get(sigEngine.getAlgorithm());
+        }
+        infoSigAlgId = sigAlgId;
 
-            DerOutputStream out = new DerOutputStream();
-            DerOutputStream tmp = new DerOutputStream();
+        DerOutputStream out = new DerOutputStream();
+        DerOutputStream tmp = new DerOutputStream();
 
-            // encode crl info
-            encodeInfo(tmp);
+        // encode crl info
+        encodeInfo(tmp);
 
-            // encode algorithm identifier
-            sigAlgId.encode(tmp);
+        // encode algorithm identifier
+        sigAlgId.derEncode(tmp);
 
-            // Create and encode the signature itself.
-            sigEngine.update(tbsCertList, 0, tbsCertList.length);
-            signature = sigEngine.sign();
-            tmp.putBitString(signature);
+        // Create and encode the signature itself.
+        sigEngine.update(tbsCertList, 0, tbsCertList.length);
+        signature = sigEngine.sign();
+        tmp.putBitString(signature);
 
-            // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
-            out.write(DerValue.tag_Sequence, tmp);
-            signedCRL = out.toByteArray();
-            readOnly = true;
+        // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
+        out.write(DerValue.tag_Sequence, tmp);
+        signedCRL = out.toByteArray();
+        readOnly = true;
 
-        } catch (IOException e) {
-            throw new CRLException("Error while encoding data: " +
-                                   e.getMessage());
-        }
     }
 
     /**
      * Returns a printable string of this CRL.
      *
@@ -1283,13 +1278,14 @@
             return prevCertIssuer;
         }
     }
 
     @Override
-    public void derEncode(OutputStream out) throws IOException {
-        if (signedCRL == null)
-            throw new IOException("Null CRL to encode");
+    public void derEncode(DerOutputStream out) {
+        if (signedCRL == null) {
+            throw new IllegalStateException("Null CRL to encode");
+        }
         out.write(signedCRL.clone());
     }
 
     /**
      * Immutable X.509 Certificate Issuer DN and serial number pair
diff a/src/java.base/share/classes/sun/security/x509/X509CertImpl.java b/src/java.base/share/classes/sun/security/x509/X509CertImpl.java
--- a/src/java.base/share/classes/sun/security/x509/X509CertImpl.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CertImpl.java
@@ -326,13 +326,15 @@
      *
      * @param out the output stream on which to write the DER encoding.
      *
      * @exception IOException on encoding error.
      */
-    public void derEncode(OutputStream out) throws IOException {
-        if (signedCert == null)
-            throw new IOException("Null certificate to encode");
+    @Override
+    public void derEncode(DerOutputStream out) {
+        if (signedCert == null) {
+            throw new IllegalStateException("Null certificate to encode");
+        }
         out.write(signedCert.clone());
     }
 
     /**
      * Returns the encoded form of this certificate. It is
@@ -576,54 +578,49 @@
     public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,
             String algorithm, String provider)
             throws CertificateException, NoSuchAlgorithmException,
             InvalidKeyException, InvalidAlgorithmParameterException,
             NoSuchProviderException, SignatureException {
-        try {
-            if (readOnly) {
-                throw new CertificateEncodingException(
-                        "cannot over-write existing certificate");
-            }
-            Signature sigEngine = null;
-            if (provider == null || provider.isEmpty()) {
-                sigEngine = Signature.getInstance(algorithm);
-            } else {
-                sigEngine = Signature.getInstance(algorithm, provider);
-            }
-
-            SignatureUtil.initSignWithParam(sigEngine, key, signingParams,
-                    null);
+        if (readOnly) {
+            throw new CertificateEncodingException(
+                    "cannot over-write existing certificate");
+        }
+        Signature sigEngine = null;
+        if (provider == null || provider.isEmpty()) {
+            sigEngine = Signature.getInstance(algorithm);
+        } else {
+            sigEngine = Signature.getInstance(algorithm, provider);
+        }
 
-            if (signingParams != null) {
-                algId = AlgorithmId.get(sigEngine.getParameters());
-            } else {
-                // in case the name is reset
-                algId = AlgorithmId.get(sigEngine.getAlgorithm());
-            }
-            DerOutputStream out = new DerOutputStream();
-            DerOutputStream tmp = new DerOutputStream();
+        SignatureUtil.initSignWithParam(sigEngine, key, signingParams,
+                null);
 
-            // encode certificate info
-            info.encode(tmp);
-            byte[] rawCert = tmp.toByteArray();
+        if (signingParams != null) {
+            algId = AlgorithmId.get(sigEngine.getParameters());
+        } else {
+            // in case the name is reset
+            algId = AlgorithmId.get(sigEngine.getAlgorithm());
+        }
+        DerOutputStream out = new DerOutputStream();
+        DerOutputStream tmp = new DerOutputStream();
 
-            // encode algorithm identifier
-            algId.encode(tmp);
+        // encode certificate info
+        info.encode(tmp);
+        byte[] rawCert = tmp.toByteArray();
 
-            // Create and encode the signature itself.
-            sigEngine.update(rawCert, 0, rawCert.length);
-            signature = sigEngine.sign();
-            tmp.putBitString(signature);
+        // encode algorithm identifier
+        algId.derEncode(tmp);
 
-            // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
-            out.write(DerValue.tag_Sequence, tmp);
-            signedCert = out.toByteArray();
-            readOnly = true;
+        // Create and encode the signature itself.
+        sigEngine.update(rawCert, 0, rawCert.length);
+        signature = sigEngine.sign();
+        tmp.putBitString(signature);
 
-        } catch (IOException e) {
-            throw new CertificateEncodingException(e.toString());
-      }
+        // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
+        out.write(DerValue.tag_Sequence, tmp);
+        signedCert = out.toByteArray();
+        readOnly = true;
     }
 
     /**
      * Checks that the certificate is currently valid, i.e. the current
      * time is within the specified validity period.
@@ -1603,17 +1600,11 @@
                 nameEntry.add(((OIDName) name).getOID().toString());
                 break;
             default:
                 // add DER encoded form
                 DerOutputStream derOut = new DerOutputStream();
-                try {
-                    name.encode(derOut);
-                } catch (IOException ioe) {
-                    // should not occur since name has already been decoded
-                    // from cert (this would indicate a bug in our code)
-                    throw new RuntimeException("name cannot be encoded", ioe);
-                }
+                name.derEncode(derOut);
                 nameEntry.add(derOut.toByteArray());
                 break;
             }
             newNames.add(Collections.unmodifiableList(nameEntry));
         }
diff a/src/java.base/share/classes/sun/security/x509/X509CertInfo.java b/src/java.base/share/classes/sun/security/x509/X509CertInfo.java
--- a/src/java.base/share/classes/sun/security/x509/X509CertInfo.java
+++ b/src/java.base/share/classes/sun/security/x509/X509CertInfo.java
@@ -177,12 +177,12 @@
      *
      * @param out an output stream to which the certificate is appended.
      * @exception CertificateException on encoding errors.
      * @exception IOException on other errors.
      */
-    public void encode(OutputStream out)
-    throws CertificateException, IOException {
+    @Override
+    public void encode(DerOutputStream out) throws CertificateException {
         if (rawCertInfo == null) {
             DerOutputStream tmp = new DerOutputStream();
             emit(tmp);
             rawCertInfo = tmp.toByteArray();
         }
@@ -227,12 +227,10 @@
                 DerOutputStream tmp = new DerOutputStream();
                 emit(tmp);
                 rawCertInfo = tmp.toByteArray();
             }
             return rawCertInfo.clone();
-        } catch (IOException e) {
-            throw new CertificateEncodingException(e.toString());
         } catch (CertificateException e) {
             throw new CertificateEncodingException(e.toString());
         }
     }
 
@@ -756,12 +754,11 @@
     }
 
     /*
      * Marshal the contents of a "raw" certificate into a DER sequence.
      */
-    private void emit(DerOutputStream out)
-    throws CertificateException, IOException {
+    private void emit(DerOutputStream out) throws CertificateException {
         DerOutputStream tmp = new DerOutputStream();
 
         // version number, iff not V1
         version.encode(tmp);
 
@@ -773,19 +770,19 @@
         if ((version.compare(CertificateVersion.V1) == 0) &&
             (issuer.toString() == null))
             throw new CertificateParsingException(
                       "Null issuer DN not allowed in v1 certificate");
 
-        issuer.encode(tmp);
+        issuer.derEncode(tmp);
         interval.encode(tmp);
 
         // Encode subject (principal) and associated key
         if ((version.compare(CertificateVersion.V1) == 0) &&
             (subject.toString() == null))
             throw new CertificateParsingException(
                       "Null subject DN not allowed in v1 certificate");
-        subject.encode(tmp);
+        subject.derEncode(tmp);
         pubKey.encode(tmp);
 
         // Encode issuerUniqueId & subjectUniqueId.
         if (issuerUniqueId != null) {
             issuerUniqueId.encode(tmp, DerValue.createTag(DerValue.TAG_CONTEXT,
diff a/src/java.base/share/classes/sun/security/x509/X509Key.java b/src/java.base/share/classes/sun/security/x509/X509Key.java
--- a/src/java.base/share/classes/sun/security/x509/X509Key.java
+++ b/src/java.base/share/classes/sun/security/x509/X509Key.java
@@ -469,10 +469,10 @@
      * Produce SubjectPublicKey encoding from algorithm id and key material.
      */
     static void encode(DerOutputStream out, AlgorithmId algid, BitArray key)
         throws IOException {
             DerOutputStream tmp = new DerOutputStream();
-            algid.encode(tmp);
-            tmp.putUnalignedBitString(key);
+        algid.derEncode(tmp);
+        tmp.putUnalignedBitString(key);
             out.write(DerValue.tag_Sequence, tmp);
     }
 }
diff a/src/java.security.jgss/share/classes/org/ietf/jgss/Oid.java b/src/java.security.jgss/share/classes/org/ietf/jgss/Oid.java
--- a/src/java.security.jgss/share/classes/org/ietf/jgss/Oid.java
+++ b/src/java.security.jgss/share/classes/org/ietf/jgss/Oid.java
@@ -174,15 +174,11 @@
      */
     public byte[] getDER() throws GSSException {
 
         if (derEncoding == null) {
             DerOutputStream dout = new DerOutputStream();
-            try {
-                dout.putOID(oid);
-            } catch (IOException e) {
-                throw new GSSException(GSSException.FAILURE, e.getMessage());
-            }
+            dout.putOID(oid);
             derEncoding = dout.toByteArray();
         }
 
         return derEncoding.clone();
     }
diff a/src/java.security.jgss/share/classes/sun/security/jgss/GSSHeader.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSHeader.java
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSHeader.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSHeader.java
@@ -67,12 +67,11 @@
      * prefix for a particular mechanism token.
      * @param mechOid the Oid of the mechanism which generated the token
      * @param mechTokenLength the length of the subsequent portion that
      * the mechanism will be adding.
      */
-    public GSSHeader(ObjectIdentifier mechOid, int mechTokenLength)
-        throws IOException {
+    public GSSHeader(ObjectIdentifier mechOid, int mechTokenLength) {
 
         this.mechOid = mechOid;
         DerOutputStream temp = new DerOutputStream();
         temp.putOID(mechOid);
         mechOidBytes = temp.toByteArray();
@@ -153,16 +152,13 @@
      */
     public static int getMaxMechTokenSize(ObjectIdentifier mechOid,
                                           int maxTotalSize) {
 
         int mechOidBytesSize = 0;
-        try {
-            DerOutputStream temp = new DerOutputStream();
-            temp.putOID(mechOid);
-            mechOidBytesSize = temp.toByteArray().length;
-        } catch (IOException e) {
-        }
+        DerOutputStream temp = new DerOutputStream();
+        temp.putOID(mechOid);
+        mechOidBytesSize = temp.toByteArray().length;
 
         // Subtract bytes needed for 0x60 tag and mechOidBytes
         maxTotalSize -= (1 + mechOidBytesSize);
 
         // Subtract maximum len bytes
diff a/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java b/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
--- a/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java
@@ -408,17 +408,11 @@
         } catch (IOException e) {
             throw new GSSExceptionImpl(GSSException.FAILURE,
                                        "Invalid OID String ");
         }
         DerOutputStream dout = new DerOutputStream();
-        try {
-            dout.putOID(oid);
-        } catch (IOException e) {
-            throw new GSSExceptionImpl(GSSException.FAILURE,
-                                   "Could not ASN.1 Encode "
-                                   + oid.toString());
-        }
+        dout.putOID(oid);
         oidBytes = dout.toByteArray();
 
         byte[] retVal = new byte[2
                                 + 2 + oidBytes.length
                                 + 4 + mechPortion.length];
diff a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenInit.java b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenInit.java
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenInit.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenInit.java
@@ -86,58 +86,52 @@
         super(NEG_TOKEN_INIT_ID);
         parseToken(in);
     }
 
     final byte[] encode() throws GSSException {
-        try {
-            // create negInitToken
-            DerOutputStream initToken = new DerOutputStream();
+        // create negInitToken
+        DerOutputStream initToken = new DerOutputStream();
 
-            // DER-encoded mechTypes with CONTEXT 00
-            if (mechTypes != null) {
-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                                true, (byte) 0x00), mechTypes);
-            }
+        // DER-encoded mechTypes with CONTEXT 00
+        if (mechTypes != null) {
+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                    true, (byte) 0x00), mechTypes);
+        }
 
-            // write context flags with CONTEXT 01
-            if (reqFlags != null) {
-                DerOutputStream flags = new DerOutputStream();
-                flags.putUnalignedBitString(reqFlags);
-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                                true, (byte) 0x01), flags);
-            }
+        // write context flags with CONTEXT 01
+        if (reqFlags != null) {
+            DerOutputStream flags = new DerOutputStream();
+            flags.putUnalignedBitString(reqFlags);
+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                    true, (byte) 0x01), flags);
+        }
 
-            // mechToken with CONTEXT 02
-            if (mechToken != null) {
-                DerOutputStream dataValue = new DerOutputStream();
-                dataValue.putOctetString(mechToken);
-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                                true, (byte) 0x02), dataValue);
-            }
+        // mechToken with CONTEXT 02
+        if (mechToken != null) {
+            DerOutputStream dataValue = new DerOutputStream();
+            dataValue.putOctetString(mechToken);
+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                    true, (byte) 0x02), dataValue);
+        }
 
-            // mechListMIC with CONTEXT 03
-            if (mechListMIC != null) {
-                if (DEBUG) {
-                    System.out.println("SpNegoToken NegTokenInit: " +
-                                        "sending MechListMIC");
-                }
-                DerOutputStream mic = new DerOutputStream();
-                mic.putOctetString(mechListMIC);
-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                                true, (byte) 0x03), mic);
+        // mechListMIC with CONTEXT 03
+        if (mechListMIC != null) {
+            if (DEBUG) {
+                System.out.println("SpNegoToken NegTokenInit: " +
+                        "sending MechListMIC");
             }
+            DerOutputStream mic = new DerOutputStream();
+            mic.putOctetString(mechListMIC);
+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                    true, (byte) 0x03), mic);
+        }
 
-            // insert in a SEQUENCE
-            DerOutputStream out = new DerOutputStream();
-            out.write(DerValue.tag_Sequence, initToken);
-
-            return out.toByteArray();
+        // insert in a SEQUENCE
+        DerOutputStream out = new DerOutputStream();
+        out.write(DerValue.tag_Sequence, initToken);
 
-        } catch (IOException e) {
-            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,
-                "Invalid SPNEGO NegTokenInit token : " + e.getMessage());
-        }
+        return out.toByteArray();
     }
 
     private void parseToken(byte[] in) throws GSSException {
         try {
             DerValue der = new DerValue(in);
diff a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenTarg.java b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenTarg.java
--- a/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenTarg.java
+++ b/src/java.security.jgss/share/classes/sun/security/jgss/spnego/NegTokenTarg.java
@@ -73,59 +73,53 @@
         super(NEG_TOKEN_TARG_ID);
         parseToken(in);
     }
 
     final byte[] encode() throws GSSException {
-        try {
-            // create negTargToken
-            DerOutputStream targToken = new DerOutputStream();
-
-            // write the negotiated result with CONTEXT 00
-            DerOutputStream result = new DerOutputStream();
-            result.putEnumerated(negResult);
+        // create negTargToken
+        DerOutputStream targToken = new DerOutputStream();
+
+        // write the negotiated result with CONTEXT 00
+        DerOutputStream result = new DerOutputStream();
+        result.putEnumerated(negResult);
+        targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                true, (byte) 0x00), result);
+
+        // supportedMech with CONTEXT 01
+        if (supportedMech != null) {
+            DerOutputStream mech = new DerOutputStream();
+            byte[] mechType = supportedMech.getDER();
+            mech.write(mechType);
             targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                true, (byte) 0x00), result);
-
-            // supportedMech with CONTEXT 01
-            if (supportedMech != null) {
-                DerOutputStream mech = new DerOutputStream();
-                byte[] mechType = supportedMech.getDER();
-                mech.write(mechType);
-                targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                                true, (byte) 0x01), mech);
-            }
+                    true, (byte) 0x01), mech);
+        }
 
-            // response Token with CONTEXT 02
-            if (responseToken != null) {
-                DerOutputStream rspToken = new DerOutputStream();
-                rspToken.putOctetString(responseToken);
-                targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                        true, (byte) 0x02), rspToken);
-            }
+        // response Token with CONTEXT 02
+        if (responseToken != null) {
+            DerOutputStream rspToken = new DerOutputStream();
+            rspToken.putOctetString(responseToken);
+            targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                    true, (byte) 0x02), rspToken);
+        }
 
-            // mechListMIC with CONTEXT 03
-            if (mechListMIC != null) {
-                if (DEBUG) {
-                    System.out.println("SpNegoToken NegTokenTarg: " +
-                                                "sending MechListMIC");
-                }
-                DerOutputStream mic = new DerOutputStream();
-                mic.putOctetString(mechListMIC);
-                targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
-                                        true, (byte) 0x03), mic);
+        // mechListMIC with CONTEXT 03
+        if (mechListMIC != null) {
+            if (DEBUG) {
+                System.out.println("SpNegoToken NegTokenTarg: " +
+                        "sending MechListMIC");
             }
+            DerOutputStream mic = new DerOutputStream();
+            mic.putOctetString(mechListMIC);
+            targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,
+                    true, (byte) 0x03), mic);
+        }
 
-            // insert in a SEQUENCE
-            DerOutputStream out = new DerOutputStream();
-            out.write(DerValue.tag_Sequence, targToken);
-
-            return out.toByteArray();
+        // insert in a SEQUENCE
+        DerOutputStream out = new DerOutputStream();
+        out.write(DerValue.tag_Sequence, targToken);
 
-        } catch (IOException e) {
-            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,
-                "Invalid SPNEGO NegTokenTarg token : " + e.getMessage());
-        }
+        return out.toByteArray();
     }
 
     private void parseToken(byte[] in) throws GSSException {
         try {
             DerValue der = new DerValue(in);
diff a/src/jdk.crypto.ec/share/classes/sun/security/ec/XDHPrivateKeyImpl.java b/src/jdk.crypto.ec/share/classes/sun/security/ec/XDHPrivateKeyImpl.java
--- a/src/jdk.crypto.ec/share/classes/sun/security/ec/XDHPrivateKeyImpl.java
+++ b/src/jdk.crypto.ec/share/classes/sun/security/ec/XDHPrivateKeyImpl.java
@@ -48,16 +48,12 @@
         this.paramSpec = new NamedParameterSpec(params.getName());
         this.k = k.clone();
 
         this.algid = new AlgorithmId(params.getOid());
         DerOutputStream derKey = new DerOutputStream();
-        try {
-            derKey.putOctetString(k);
-            this.key = derKey.toByteArray();
-        } catch (IOException ex) {
-            throw new AssertionError("Should not happen", ex);
-        }
+        derKey.putOctetString(k);
+        this.key = derKey.toByteArray();
         checkLength(params);
     }
 
     XDHPrivateKeyImpl(byte[] encoded) throws InvalidKeyException {
         super(encoded);
diff a/src/jdk.crypto.ec/share/classes/sun/security/ec/ed/EdDSAPrivateKeyImpl.java b/src/jdk.crypto.ec/share/classes/sun/security/ec/ed/EdDSAPrivateKeyImpl.java
--- a/src/jdk.crypto.ec/share/classes/sun/security/ec/ed/EdDSAPrivateKeyImpl.java
+++ b/src/jdk.crypto.ec/share/classes/sun/security/ec/ed/EdDSAPrivateKeyImpl.java
@@ -50,16 +50,12 @@
         this.paramSpec = new NamedParameterSpec(params.getName());
         this.algid = new AlgorithmId(params.getOid());
         this.h = h.clone();
 
         DerOutputStream derKey = new DerOutputStream();
-        try {
-            derKey.putOctetString(h);
-            this.key = derKey.toByteArray();
-        } catch (IOException ex) {
-            throw new AssertionError("Should not happen", ex);
-        }
+        derKey.putOctetString(h);
+        this.key = derKey.toByteArray();
         checkLength(params);
     }
 
     EdDSAPrivateKeyImpl(byte[] encoded) throws InvalidKeyException {
 
diff a/test/jdk/java/security/cert/X509CertSelectorTest.java b/test/jdk/java/security/cert/X509CertSelectorTest.java
--- a/test/jdk/java/security/cert/X509CertSelectorTest.java
+++ b/test/jdk/java/security/cert/X509CertSelectorTest.java
@@ -341,11 +341,11 @@
         System.out.println("X.509 Certificate Match on subjectAltName");
         // bad match
         X509CertSelector selector = new X509CertSelector();
         GeneralNameInterface dnsName = new DNSName("foo.com");
         DerOutputStream tmp = new DerOutputStream();
-        dnsName.encode(tmp);
+        dnsName.derEncode(tmp);
         selector.addSubjectAlternativeName(2, tmp.toByteArray());
         checkMatch(selector, cert, false);
 
         // good match
         DerInputStream in = new DerInputStream(cert.getExtensionValue("2.5.29.17"));
@@ -353,11 +353,11 @@
         SubjectAlternativeNameExtension ext = new SubjectAlternativeNameExtension(false, encoded);
         GeneralNames names = (GeneralNames) ext.get(SubjectAlternativeNameExtension.SUBJECT_NAME);
         GeneralName name = (GeneralName) names.get(0);
         selector.setSubjectAlternativeNames(null);
         DerOutputStream tmp2 = new DerOutputStream();
-        name.getName().encode(tmp2);
+        name.getName().derEncode(tmp2);
         selector.addSubjectAlternativeName(name.getType(), tmp2.toByteArray());
         checkMatch(selector, cert, true);
 
         // good match 2 (matches at least one)
         selector.setMatchAllSubjectAltNames(false);
@@ -414,12 +414,12 @@
                 if (tree.getName().getType() == NAME_DIRECTORY) {
                     X500Name excludedDN1 = new X500Name(tree.getName().toString());
                     X500Name excludedDN2 = new X500Name("CN=Bogus, " + tree.getName().toString());
                     DerOutputStream derDN1 = new DerOutputStream();
                     DerOutputStream derDN2 = new DerOutputStream();
-                    excludedDN1.encode(derDN1);
-                    excludedDN2.encode(derDN2);
+                    excludedDN1.derEncode(derDN1);
+                    excludedDN2.derEncode(derDN2);
                     selector = new X509CertSelector();
                     selector.addPathToName(NAME_DIRECTORY, derDN1.toByteArray());
                     checkMatch(selector, cert, false);
                     selector.setPathToNames(null);
                     selector.addPathToName(NAME_DIRECTORY, derDN2.toByteArray());
@@ -436,12 +436,12 @@
                 if (tree.getName().getType() == NAME_DIRECTORY) {
                     X500Name permittedDN1 = new X500Name(tree.getName().toString());
                     X500Name permittedDN2 = new X500Name("CN=good, " + tree.getName().toString());
                     DerOutputStream derDN1 = new DerOutputStream();
                     DerOutputStream derDN2 = new DerOutputStream();
-                    permittedDN1.encode(derDN1);
-                    permittedDN2.encode(derDN2);
+                    permittedDN1.derEncode(derDN1);
+                    permittedDN2.derEncode(derDN2);
                     selector = new X509CertSelector();
                     selector.addPathToName(NAME_DIRECTORY, derDN1.toByteArray());
                     checkMatch(selector, cert, true);
                     selector.setPathToNames(null);
                     selector.addPathToName(NAME_DIRECTORY, derDN2.toByteArray());
diff a/test/jdk/sun/security/pkcs/pkcs7/SignerOrder.java b/test/jdk/sun/security/pkcs/pkcs7/SignerOrder.java
--- a/test/jdk/sun/security/pkcs/pkcs7/SignerOrder.java
+++ b/test/jdk/sun/security/pkcs/pkcs7/SignerOrder.java
@@ -113,21 +113,21 @@
                     + "should be same");
         }
     }
 
     static void printSignerInfos(SignerInfo signerInfo) throws IOException {
-        ByteArrayOutputStream strm = new ByteArrayOutputStream();
+        DerOutputStream strm = new DerOutputStream();
         signerInfo.derEncode(strm);
         System.out.println("SignerInfo, length: "
                 + strm.toByteArray().length);
         HexPrinter.simple().format(strm.toByteArray());
         System.out.println("\n");
         strm.reset();
     }
 
     static void printSignerInfos(SignerInfo[] signerInfos) throws IOException {
-        ByteArrayOutputStream strm = new ByteArrayOutputStream();
+        DerOutputStream strm = new DerOutputStream();
         for (int i = 0; i < signerInfos.length; i++) {
             signerInfos[i].derEncode(strm);
             System.out.println("SignerInfo[" + i + "], length: "
                     + strm.toByteArray().length);
             HexPrinter.simple().format(strm.toByteArray());
diff a/test/jdk/sun/security/pkcs/pkcs9/UnknownAttribute.java b/test/jdk/sun/security/pkcs/pkcs9/UnknownAttribute.java
--- a/test/jdk/sun/security/pkcs/pkcs9/UnknownAttribute.java
+++ b/test/jdk/sun/security/pkcs/pkcs9/UnknownAttribute.java
@@ -32,10 +32,11 @@
 
 import java.io.*;
 import java.util.Arrays;
 
 import sun.security.pkcs.PKCS9Attribute;
+import sun.security.util.DerOutputStream;
 import sun.security.util.DerValue;
 import sun.security.util.ObjectIdentifier;
 import jdk.test.lib.hexdump.HexPrinter;
 
 public class UnknownAttribute {
@@ -55,11 +56,11 @@
         };
         PKCS9Attribute p2 = new PKCS9Attribute(new DerValue(data));
         if (p2.isKnown()) {
             throw new Exception();
         }
-        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        DerOutputStream bout = new DerOutputStream();
         p2.derEncode(bout);
         HexPrinter.simple().dest(System.err).format(bout.toByteArray());
         if (!Arrays.equals(data, bout.toByteArray())) {
             throw new Exception();
         }
@@ -73,11 +74,11 @@
         PKCS9Attribute p3 = new PKCS9Attribute(
                 ObjectIdentifier.of("1.2.3"), new byte[]{0x31,0x02,0x05,0x00});
         if (p3.isKnown()) {
             throw new Exception();
         }
-        bout = new ByteArrayOutputStream();
+        bout = new DerOutputStream();
         p3.derEncode(bout);
         if (!Arrays.equals(data, bout.toByteArray())) {
             throw new Exception();
         }
     }
diff a/test/jdk/sun/security/tools/keytool/ExtOptionCamelCase.java b/test/jdk/sun/security/tools/keytool/ExtOptionCamelCase.java
--- a/test/jdk/sun/security/tools/keytool/ExtOptionCamelCase.java
+++ b/test/jdk/sun/security/tools/keytool/ExtOptionCamelCase.java
@@ -32,10 +32,11 @@
  * @compile -XDignore.symbol.file ExtOptionCamelCase.java
  * @run main ExtOptionCamelCase
  */
 
 import sun.security.tools.keytool.Main;
+import sun.security.util.DerOutputStream;
 import sun.security.util.DerValue;
 import sun.security.x509.BasicConstraintsExtension;
 import sun.security.x509.CertificateExtensions;
 import sun.security.x509.Extension;
 import sun.security.x509.KeyUsageExtension;
@@ -200,11 +201,11 @@
                             null, null, List.of(option), pk, null);
 
             // ATTENTION: the extensions created above might contain raw
             // extensions (not of a subtype) and we need to store and reload
             // it to resolve them to subtypes.
-            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            DerOutputStream bout = new DerOutputStream();
             exts.encode(bout);
             exts = new CertificateExtensions(new DerValue(bout.toByteArray()).data);
 
             if (clazz == null) {
                 throw new Exception("Should fail");
diff a/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java b/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
--- a/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
+++ b/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
@@ -46,11 +46,11 @@
         byte[] ba;
         // encode
         X500Name dn1 = new X500Name(name1);
 
         deros = new DerOutputStream();
-        dn1.encode(deros);
+        dn1.derEncode(deros);
         ba = deros.toByteArray();
 
         GetDIBConstructor a = new GetDIBConstructor();
         java.security.AccessController.doPrivileged(a);
         Constructor c = a.getCons();
diff a/test/jdk/sun/security/util/DerValue/DerValueEqualsHashCode.java b/test/jdk/sun/security/util/DerValue/DerValueEqualsHashCode.java
--- a/test/jdk/sun/security/util/DerValue/DerValueEqualsHashCode.java
+++ b/test/jdk/sun/security/util/DerValue/DerValueEqualsHashCode.java
@@ -45,11 +45,11 @@
         DerOutputStream deros;
         byte[] ba;
         //
         // get busy
         deros = new DerOutputStream();
-        dn.encode(deros);
+        dn.derEncode(deros);
         ba = deros.toByteArray();
 
         DerValue dv1 = new DerValue(ba);
         DerValue dv2 = new DerValue(ba);
 
diff a/test/jdk/sun/security/util/asn1StringTypes/StringTypes.java b/test/jdk/sun/security/util/asn1StringTypes/StringTypes.java
--- a/test/jdk/sun/security/util/asn1StringTypes/StringTypes.java
+++ b/test/jdk/sun/security/util/asn1StringTypes/StringTypes.java
@@ -61,11 +61,11 @@
         derOut.putPrintableString(s);
         derOut.putIA5String(s);
         derOut.putT61String(s);
         derOut.putBMPString(s);
 
-        derOut.derEncode(fout);
+        derOut.encode(fout);
         fout.close();
 
         FileInputStream fis = new FileInputStream(fileName);
         byte[] data = new byte[fis.available()];
         fis.read(data);
diff a/test/jdk/sun/security/x509/AVA/AVAEqualsHashCode.java b/test/jdk/sun/security/x509/AVA/AVAEqualsHashCode.java
--- a/test/jdk/sun/security/x509/AVA/AVAEqualsHashCode.java
+++ b/test/jdk/sun/security/x509/AVA/AVAEqualsHashCode.java
@@ -44,11 +44,11 @@
         String name = "CN=eve s. dropper";
         X500Name dn = new X500Name(name);
         DerOutputStream deros = new DerOutputStream();
         ObjectIdentifier oid = ObjectIdentifier.of("1.2.840.113549.2.5");
 
-        dn.encode(deros);
+        dn.derEncode(deros);
         byte[] ba = deros.toByteArray();
         DerValue dv = new DerValue(ba);
 
         GetAVAConstructor a = new GetAVAConstructor();
         java.security.AccessController.doPrivileged(a);
diff a/test/jdk/sun/security/x509/X500Name/DerValueConstructor.java b/test/jdk/sun/security/x509/X500Name/DerValueConstructor.java
--- a/test/jdk/sun/security/x509/X500Name/DerValueConstructor.java
+++ b/test/jdk/sun/security/x509/X500Name/DerValueConstructor.java
@@ -45,11 +45,11 @@
 
         // encode
         X500Name dn = new X500Name(name);
         System.err.println("DEBUG: dn: " + dn.toString());
         debugDER = new DerOutputStream();
-        dn.encode(debugDER);
+        dn.derEncode(debugDER);
         ba = debugDER.toByteArray();
         System.err.print("DEBUG: encoded X500Name bytes: ");
         System.out.println(toHexString(ba));
         System.err.println();
 
diff a/test/jdk/sun/security/x509/X500Name/NullX500Name.java b/test/jdk/sun/security/x509/X500Name/NullX500Name.java
--- a/test/jdk/sun/security/x509/X500Name/NullX500Name.java
+++ b/test/jdk/sun/security/x509/X500Name/NullX500Name.java
@@ -59,11 +59,11 @@
 
         System.out.println("getType:" + subject.getType());
 
         // encode, getEncoded()
         DerOutputStream dos = new DerOutputStream();
-        subject.encode(dos);
+        subject.derEncode(dos);
         byte[] out = dos.toByteArray();
         byte[] enc = subject.getEncoded();
         HexPrinter e = HexPrinter.simple();
         if (Arrays.equals(out, enc))
             System.out.println("Success: out:" + e.toString(out));
diff a/test/lib/jdk/test/lib/security/timestamp/TsaSigner.java b/test/lib/jdk/test/lib/security/timestamp/TsaSigner.java
--- a/test/lib/jdk/test/lib/security/timestamp/TsaSigner.java
+++ b/test/lib/jdk/test/lib/security/timestamp/TsaSigner.java
@@ -176,11 +176,11 @@
 
             String digestAlgo = respParam.digestAlgo();
             print("digestAlgo", digestAlgo);
             DerOutputStream digestAlgoOut = new DerOutputStream();
             AlgorithmId digestAlgoId = AlgorithmId.get(digestAlgo);
-            digestAlgoId.encode(digestAlgoOut);
+            digestAlgoId.derEncode(digestAlgoOut);
             byte[] hashedMessage = respParam.hashedMessage();
             debug("hashedMessage", hashedMessage);
             digestAlgoOut.putOctetString(hashedMessage);
             tstInfoOut.write(DerValue.tag_Sequence, digestAlgoOut);
 

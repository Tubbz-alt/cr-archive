<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/sun/security/tools/keytool/ExtOptionCamelCase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8231950
 27  * @summary keytool -ext camel-case shorthand not working
 28  * @modules java.base/sun.security.tools.keytool
 29  *          java.base/sun.security.tools.keytool:open
 30  *          java.base/sun.security.util
 31  *          java.base/sun.security.x509
 32  * @compile -XDignore.symbol.file ExtOptionCamelCase.java
 33  * @run main ExtOptionCamelCase
 34  */
 35 
 36 import sun.security.tools.keytool.Main;
 37 import sun.security.util.DerOutputStream;
 38 import sun.security.util.DerValue;
 39 import sun.security.x509.BasicConstraintsExtension;
 40 import sun.security.x509.CertificateExtensions;
 41 import sun.security.x509.Extension;
 42 import sun.security.x509.KeyUsageExtension;
 43 
 44 import java.io.ByteArrayOutputStream;
 45 import java.lang.reflect.Constructor;
 46 import java.lang.reflect.InvocationTargetException;
 47 import java.lang.reflect.Method;
 48 import java.security.KeyPairGenerator;
 49 import java.security.PublicKey;
 50 import java.util.List;
 51 
 52 public class ExtOptionCamelCase {
 53     static Method createV3Extensions;
 54     static Constructor&lt;Main&gt; ctor;
 55     static PublicKey pk;
 56     static Method oneOf;
 57 
 58     public static void main(String[] args) throws Exception {
 59 
 60         prepare();
 61 
 62         // Unseen ext name
 63         testCreateFail(&quot;abc&quot;);
 64 
 65         // camelCase match, both cases work
 66         testCreate(&quot;bc&quot;, BasicConstraintsExtension.class);
 67         testCreate(&quot;BC&quot;, BasicConstraintsExtension.class);
 68 
 69         // Prefix match
 70         testCreate(&quot;BasicC&quot;, BasicConstraintsExtension.class);
 71 
 72         // Ambiguous, digitalSignature or dataEncipherment?
 73         testCreateFail(&quot;ku=d&quot;);
 74 
 75         // prefix match
 76         testCreate(&quot;ku:c=dig&quot;, KeyUsageExtension.class,
 77                 x -&gt; x.get(KeyUsageExtension.DIGITAL_SIGNATURE));
 78 
 79         // camelCase match
 80         testCreate(&quot;ku=kE&quot;, KeyUsageExtension.class,
 81                 x -&gt; x.get(KeyUsageExtension.KEY_ENCIPHERMENT));
 82 
 83         // camelCase match must be only 1st+CAPITALs
 84         testCreateFail(&quot;ku=KeUs&quot;);
 85 
 86         // camelCase match, must be only 1st + all CAPITALs
 87         testCreate(&quot;ku=kCS&quot;, KeyUsageExtension.class,
 88                 x -&gt; x.get(KeyUsageExtension.KEY_CERTSIGN));
 89 
 90         // ... not all CAPITALs
 91         testCreateFail(&quot;ku=kC&quot;);
 92 
 93         // ... has lowercase letters
 94         testCreateFail(&quot;ku=keCeSi&quot;);
 95 
 96         // Ambiguous, keyAgreement or keyCertSign
 97         testCreateFail(&quot;ku:c=ke&quot;);
 98 
 99         // camelCase natch
100         testCreate(&quot;ku:c=dE&quot;, KeyUsageExtension.class,
101                 x -&gt; x.get(KeyUsageExtension.DATA_ENCIPHERMENT));
102         // prefix match
103         testCreate(&quot;ku:c=de&quot;, KeyUsageExtension.class,
104                 x -&gt; x.get(KeyUsageExtension.DECIPHER_ONLY));
105 
106         // camelCase match
107         testCreate(&quot;ku:c=kA&quot;, KeyUsageExtension.class,
108                 x -&gt; x.get(KeyUsageExtension.KEY_AGREEMENT));
109 
110         // camelCase match, fallback
111         testCreate(&quot;ku:c=ka&quot;, KeyUsageExtension.class,
112                 x -&gt; x.get(KeyUsageExtension.KEY_AGREEMENT));
113 
114         // Testing oneOf() directly
115         testOneOf(&quot;a&quot;, -1, &quot;b&quot;, &quot;c&quot;); // -1 means not found
116         testOneOf(&quot;a&quot;, -2, &quot;ab&quot;, &quot;ac&quot;); // -2 means ambiguous
117 
118         testOneOf(&quot;a&quot;, 0, &quot;a&quot;, &quot;ac&quot;); //exact match
119         testOneOf(&quot;a&quot;, 0, &quot;a&quot;, &quot;b&quot;);
120         testOneOf(&quot;ac&quot;, 1, &quot;a&quot;, &quot;ac&quot;);
121 
122         testOneOf(&quot;a&quot;, 0, &quot;abc&quot;, &quot;bcd&quot;);
123         testOneOf(&quot;ab&quot;, 0, &quot;abc&quot;, &quot;ABC&quot;);
124         testOneOf(&quot;ab&quot;, 0, &quot;abc&quot;, &quot;aBC&quot;);
125         testOneOf(&quot;ab&quot;, 0, &quot;abc&quot;, &quot;Abc&quot;);
126         testOneOf(&quot;AB&quot;, 1, &quot;abc&quot;, &quot;ABC&quot;);
127         testOneOf(&quot;aB&quot;, 0, &quot;abcBcd&quot;, &quot;abcDef&quot;);
128         testOneOf(&quot;ab&quot;, -2, &quot;abcBcd&quot;, &quot;abcDef&quot;);
129         testOneOf(&quot;aB&quot;, -2, &quot;abcBcdEfg&quot;, &quot;abcDef&quot;);
130 
131         testOneOf(&quot;ab&quot;, 0, &quot;abcDef&quot;, &quot;axyBuv&quot;);
132         testOneOf(&quot;aB&quot;, 1, &quot;abcDef&quot;, &quot;axyBuv&quot;);
133         testOneOf(&quot;a&quot;, -2, &quot;abcDef&quot;, &quot;axyBuv&quot;);
134 
135         testOneOf(&quot;aBC&quot;, -1, &quot;a12BxyCuvDmn&quot;); // 12 is not removed
136         testOneOf(&quot;a12BCD&quot;, 0, &quot;a12BxyCuvDmn&quot;);
137         testOneOf(&quot;a12BC&quot;, -1, &quot;a12BxyCuvDmn&quot;); // must be full
138 
139         // Fallback
140         testOneOf(&quot;bc&quot;, 0, &quot;BasicConstraints&quot;);
141         testOneOf(&quot;BC&quot;, 0, &quot;BasicConstraints&quot;);
142         testOneOf(&quot;BasicConstraints&quot;, 0, &quot;BasicConstraints&quot;);
143         testOneOf(&quot;basicconstraints&quot;, 0, &quot;BasicConstraints&quot;);
144         testOneOf(&quot;Basic&quot;, 0, &quot;BasicConstraints&quot;);
145         testOneOf(&quot;basic&quot;, 0, &quot;BasicConstraints&quot;);
146 
147         testOneOf(&quot;BaCo&quot;, -1, &quot;BasicConstraints&quot;);
148     }
149 
150     // Expose some private methods
151     static void prepare() throws Exception {
152         createV3Extensions = Main.class.getDeclaredMethod(
153                 &quot;createV3Extensions&quot;,
154                 CertificateExtensions.class,
155                 CertificateExtensions.class,
156                 List.class,
157                 PublicKey.class,
158                 PublicKey.class);
159         createV3Extensions.setAccessible(true);
160         ctor = Main.class.getDeclaredConstructor();
161         ctor.setAccessible(true);
162         KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;);
163         pk = kpg.generateKeyPair().getPublic();
164 
165         oneOf = Main.class.getDeclaredMethod(
166                 &quot;oneOf&quot;, String.class, String[].class);
167         oneOf.setAccessible(true);
168     }
169 
170     /**
171      * Ensures the given type of extension is created with the option
172      */
173     static &lt;T extends Extension&gt; void testCreate(String option, Class&lt;T&gt; clazz)
174             throws Exception {
175         testCreate(option, clazz, null);
176     }
177 
178     /**
179      * Ensures an option is invalid and will be rejected
180      */
181     static &lt;T extends Extension&gt; void testCreateFail(String option)
182             throws Exception {
183         testCreate(option, null, null);
184     }
185 
186     /**
187      * Ensures the given type of extension is created and match the rule
188      * with the option.
189      *
190      * @param option the -ext option provided to keytool
191      * @param clazz the expected extension to create, null means none
192      * @param rule a predicate to check if the extension created is acceptable
193      * @param &lt;T&gt; the extected extension type
194      * @throws Exception if test result is unexpected
195      */
196     static &lt;T extends Extension&gt; void testCreate(String option, Class&lt;T&gt; clazz,
197             PredicateWithException&lt;T&gt; rule) throws Exception {
198         try {
199             CertificateExtensions exts = (CertificateExtensions)
200                     createV3Extensions.invoke(ctor.newInstance(),
201                             null, null, List.of(option), pk, null);
202 
203             // ATTENTION: the extensions created above might contain raw
204             // extensions (not of a subtype) and we need to store and reload
205             // it to resolve them to subtypes.
206             DerOutputStream bout = new DerOutputStream();
207             exts.encode(bout);
208             exts = new CertificateExtensions(new DerValue(bout.toByteArray()).data);
209 
210             if (clazz == null) {
211                 throw new Exception(&quot;Should fail&quot;);
212             } else {
213                 for (Extension e : exts.getAllExtensions()) {
214                     if (e.getClass() == clazz) {
215                         if (rule == null || rule.test((T) e)) {
216                             return;
217                         }
218                     }
219                 }
220                 throw new Exception(&quot;Unexpected result: &quot; + exts);
221             }
222         } catch (InvocationTargetException e) {
223             if (clazz == null) {
224                 return;
225             } else {
226                 throw e;
227             }
228         }
229     }
230 
231     @FunctionalInterface
232     interface PredicateWithException&lt;T&gt; {
233         boolean test(T t) throws Exception;
234     }
235 
236     /**
237      * Ensures oneOf returns the expected result.
238      *
239      * @param s input
240      * @param expected expected value, -2 if ambiguous, -1 if no match
241      * @param items existing strings to match
242      * @throws Exception if test result is unexpected
243      */
244     static void testOneOf(String s, int expected, String... items)
245             throws Exception {
246         try {
247             int res = (int)oneOf.invoke(null, s, items);
248             if (expected == -2) {
249                 throw new Exception(&quot;Should fail&quot;);
250             } else {
251                 if (expected != res) {
252                     throw new Exception(
253                             &quot;Expected &quot; + expected + &quot;, actually &quot; + res);
254                 }
255             }
256         } catch (InvocationTargetException e) {
257             if (expected == -2) {
258                 return;
259             } else {
260                 throw e;
261             }
262         }
263     }
264 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/x509/X509CertImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.BufferedInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.InputStreamReader;
  34 import java.io.OutputStream;
  35 import java.math.BigInteger;
  36 import java.security.*;
  37 import java.security.spec.AlgorithmParameterSpec;
  38 import java.security.cert.*;
  39 import java.security.cert.Certificate;
  40 import java.util.*;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 
  43 import javax.security.auth.x500.X500Principal;
  44 
  45 import sun.security.util.*;
  46 import sun.security.provider.X509Factory;
  47 
  48 import static java.nio.charset.StandardCharsets.US_ASCII;
  49 
  50 /**
  51  * The X509CertImpl class represents an X.509 certificate. These certificates
  52  * are widely used to support authentication and other functionality in
  53  * Internet security systems.  Common applications include Privacy Enhanced
  54  * Mail (PEM), Transport Layer Security (SSL), code signing for trusted
  55  * software distribution, and Secure Electronic Transactions (SET).  There
  56  * is a commercial infrastructure ready to manage large scale deployments
  57  * of X.509 identity certificates.
  58  *
  59  * &lt;P&gt;These certificates are managed and vouched for by &lt;em&gt;Certificate
  60  * Authorities&lt;/em&gt; (CAs).  CAs are services which create certificates by
  61  * placing data in the X.509 standard format and then digitally signing
  62  * that data.  Such signatures are quite difficult to forge.  CAs act as
  63  * trusted third parties, making introductions between agents who have no
  64  * direct knowledge of each other.  CA certificates are either signed by
  65  * themselves, or by some other CA such as a &quot;root&quot; CA.
  66  *
  67  * &lt;P&gt; Standards relating to X.509 Public Key Infrastructure for the Internet
  68  * can be referenced in RFC 5280.
  69  *
  70  * @author Dave Brownell
  71  * @author Amit Kapoor
  72  * @author Hemma Prafullchandra
  73  * @see X509CertInfo
  74  */
  75 @SuppressWarnings(&quot;serial&quot;) // See writeReplace method in Certificate
  76 public class X509CertImpl extends X509Certificate implements DerEncoder {
  77 
  78     @java.io.Serial
  79     private static final long serialVersionUID = -3457612960190864406L;
  80 
  81     private static final char DOT = &#39;.&#39;;
  82     /**
  83      * Public attribute names.
  84      */
  85     public static final String NAME = &quot;x509&quot;;
  86     public static final String INFO = X509CertInfo.NAME;
  87     public static final String ALG_ID = &quot;algorithm&quot;;
  88     public static final String SIGNATURE = &quot;signature&quot;;
  89     public static final String SIGNED_CERT = &quot;signed_cert&quot;;
  90 
  91     /**
  92      * The following are defined for ease-of-use. These
  93      * are the most frequently retrieved attributes.
  94      */
  95     // x509.info.subject.dname
  96     public static final String SUBJECT_DN = NAME + DOT + INFO + DOT +
  97                                X509CertInfo.SUBJECT + DOT + X509CertInfo.DN_NAME;
  98     // x509.info.issuer.dname
  99     public static final String ISSUER_DN = NAME + DOT + INFO + DOT +
 100                                X509CertInfo.ISSUER + DOT + X509CertInfo.DN_NAME;
 101     // x509.info.serialNumber.number
 102     public static final String SERIAL_ID = NAME + DOT + INFO + DOT +
 103                                X509CertInfo.SERIAL_NUMBER + DOT +
 104                                CertificateSerialNumber.NUMBER;
 105     // x509.info.key.value
 106     public static final String PUBLIC_KEY = NAME + DOT + INFO + DOT +
 107                                X509CertInfo.KEY + DOT +
 108                                CertificateX509Key.KEY;
 109 
 110     // x509.info.version.value
 111     public static final String VERSION = NAME + DOT + INFO + DOT +
 112                                X509CertInfo.VERSION + DOT +
 113                                CertificateVersion.VERSION;
 114 
 115     // x509.algorithm
 116     public static final String SIG_ALG = NAME + DOT + ALG_ID;
 117 
 118     // x509.signature
 119     public static final String SIG = NAME + DOT + SIGNATURE;
 120 
 121     // when we sign and decode we set this to true
 122     // this is our means to make certificates immutable
 123     private boolean readOnly = false;
 124 
 125     // Certificate data, and its envelope
 126     private byte[]              signedCert = null;
 127     protected X509CertInfo      info = null;
 128     protected AlgorithmId       algId = null;
 129     protected byte[]            signature = null;
 130 
 131     // number of standard key usage bits.
 132     private static final int NUM_STANDARD_KEY_USAGE = 9;
 133 
 134     // SubjectAlterntativeNames cache
 135     private Collection&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
 136 
 137     // IssuerAlternativeNames cache
 138     private Collection&lt;List&lt;?&gt;&gt; issuerAlternativeNames;
 139 
 140     // ExtendedKeyUsage cache
 141     private List&lt;String&gt; extKeyUsage;
 142 
 143     // AuthorityInformationAccess cache
 144     private Set&lt;AccessDescription&gt; authInfoAccess;
 145 
 146     /**
 147      * PublicKey that has previously been used to verify
 148      * the signature of this certificate. Null if the certificate has not
 149      * yet been verified.
 150      */
 151     private PublicKey verifiedPublicKey;
 152     /**
 153      * If verifiedPublicKey is not null, name of the provider used to
 154      * successfully verify the signature of this certificate, or the
 155      * empty String if no provider was explicitly specified.
 156      */
 157     private String verifiedProvider;
 158     /**
 159      * If verifiedPublicKey is not null, result of the verification using
 160      * verifiedPublicKey and verifiedProvider. If true, verification was
 161      * successful, if false, it failed.
 162      */
 163     private boolean verificationResult;
 164 
 165     /**
 166      * Default constructor.
 167      */
 168     public X509CertImpl() { }
 169 
 170     /**
 171      * Unmarshals a certificate from its encoded form, parsing the
 172      * encoded bytes.  This form of constructor is used by agents which
 173      * need to examine and use certificate contents.  That is, this is
 174      * one of the more commonly used constructors.  Note that the buffer
 175      * must include only a certificate, and no &quot;garbage&quot; may be left at
 176      * the end.  If you need to ignore data at the end of a certificate,
 177      * use another constructor.
 178      *
 179      * @param certData the encoded bytes, with no trailing padding.
 180      * @exception CertificateException on parsing and initialization errors.
 181      */
 182     public X509CertImpl(byte[] certData) throws CertificateException {
 183         try {
 184             parse(new DerValue(certData));
 185         } catch (IOException e) {
 186             signedCert = null;
 187             throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);
 188         }
 189     }
 190 
 191     /**
 192      * unmarshals an X.509 certificate from an input stream.  If the
 193      * certificate is RFC1421 hex-encoded, then it must begin with
 194      * the line X509Factory.BEGIN_CERT and end with the line
 195      * X509Factory.END_CERT.
 196      *
 197      * @param in an input stream holding at least one certificate that may
 198      *        be either DER-encoded or RFC1421 hex-encoded version of the
 199      *        DER-encoded certificate.
 200      * @exception CertificateException on parsing and initialization errors.
 201      */
 202     public X509CertImpl(InputStream in) throws CertificateException {
 203 
 204         DerValue der = null;
 205 
 206         BufferedInputStream inBuffered = new BufferedInputStream(in);
 207 
 208         // First try reading stream as HEX-encoded DER-encoded bytes,
 209         // since not mistakable for raw DER
 210         try {
 211             inBuffered.mark(Integer.MAX_VALUE);
 212             der = readRFC1421Cert(inBuffered);
 213         } catch (IOException ioe) {
 214             try {
 215                 // Next, try reading stream as raw DER-encoded bytes
 216                 inBuffered.reset();
 217                 der = new DerValue(inBuffered);
 218             } catch (IOException ioe1) {
 219                 throw new CertificateException(&quot;Input stream must be &quot; +
 220                                                &quot;either DER-encoded bytes &quot; +
 221                                                &quot;or RFC1421 hex-encoded &quot; +
 222                                                &quot;DER-encoded bytes: &quot; +
 223                                                ioe1.getMessage(), ioe1);
 224             }
 225         }
 226         try {
 227             parse(der);
 228         } catch (IOException ioe) {
 229             signedCert = null;
 230             throw new CertificateException(&quot;Unable to parse DER value of &quot; +
 231                                            &quot;certificate, &quot; + ioe, ioe);
 232         }
 233     }
 234 
 235     /**
 236      * read input stream as HEX-encoded DER-encoded bytes
 237      *
 238      * @param in InputStream to read
 239      * @return DerValue corresponding to decoded HEX-encoded bytes
 240      * @throws IOException if stream can not be interpreted as RFC1421
 241      *                     encoded bytes
 242      */
 243     private DerValue readRFC1421Cert(InputStream in) throws IOException {
 244         DerValue der = null;
 245         String line = null;
 246         BufferedReader certBufferedReader =
 247             new BufferedReader(new InputStreamReader(in, US_ASCII));
 248         try {
 249             line = certBufferedReader.readLine();
 250         } catch (IOException ioe1) {
 251             throw new IOException(&quot;Unable to read InputStream: &quot; +
 252                                   ioe1.getMessage());
 253         }
 254         if (line.equals(X509Factory.BEGIN_CERT)) {
 255             /* stream appears to be hex-encoded bytes */
 256             ByteArrayOutputStream decstream = new ByteArrayOutputStream();
 257             try {
 258                 while ((line = certBufferedReader.readLine()) != null) {
 259                     if (line.equals(X509Factory.END_CERT)) {
 260                         der = new DerValue(decstream.toByteArray());
 261                         break;
 262                     } else {
 263                         decstream.write(Pem.decode(line));
 264                     }
 265                 }
 266             } catch (IOException ioe2) {
 267                 throw new IOException(&quot;Unable to read InputStream: &quot;
 268                                       + ioe2.getMessage());
 269             }
 270         } else {
 271             throw new IOException(&quot;InputStream is not RFC1421 hex-encoded &quot; +
 272                                   &quot;DER bytes&quot;);
 273         }
 274         return der;
 275     }
 276 
 277     /**
 278      * Construct an initialized X509 Certificate. The certificate is stored
 279      * in raw form and has to be signed to be useful.
 280      *
 281      * @param certInfo the X509CertificateInfo which the Certificate is to be
 282      *             created from.
 283      */
 284     public X509CertImpl(X509CertInfo certInfo) {
 285         this.info = certInfo;
 286     }
 287 
 288     /**
 289      * Unmarshal a certificate from its encoded form, parsing a DER value.
 290      * This form of constructor is used by agents which need to examine
 291      * and use certificate contents.
 292      *
 293      * @param derVal the der value containing the encoded cert.
 294      * @exception CertificateException on parsing and initialization errors.
 295      */
 296     public X509CertImpl(DerValue derVal) throws CertificateException {
 297         try {
 298             parse(derVal);
 299         } catch (IOException e) {
 300             signedCert = null;
 301             throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);
 302         }
 303     }
 304 
 305     /**
 306      * Appends the certificate to an output stream.
 307      *
 308      * @param out an input stream to which the certificate is appended.
 309      * @exception CertificateEncodingException on encoding errors.
 310      */
 311     public void encode(OutputStream out)
 312     throws CertificateEncodingException {
 313         if (signedCert == null)
 314             throw new CertificateEncodingException(
 315                           &quot;Null certificate to encode&quot;);
 316         try {
 317             out.write(signedCert.clone());
 318         } catch (IOException e) {
 319             throw new CertificateEncodingException(e.toString());
 320         }
 321     }
 322 
 323     /**
 324      * DER encode this object onto an output stream.
 325      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 326      *
 327      * @param out the output stream on which to write the DER encoding.
 328      *
 329      * @exception IOException on encoding error.
 330      */
 331     @Override
 332     public void derEncode(DerOutputStream out) {
 333         if (signedCert == null) {
 334             throw new IllegalStateException(&quot;Null certificate to encode&quot;);
 335         }
 336         out.write(signedCert.clone());
 337     }
 338 
 339     /**
 340      * Returns the encoded form of this certificate. It is
 341      * assumed that each certificate type would have only a single
 342      * form of encoding; for example, X.509 certificates would
 343      * be encoded as ASN.1 DER.
 344      *
 345      * @exception CertificateEncodingException if an encoding error occurs.
 346      */
 347     public byte[] getEncoded() throws CertificateEncodingException {
 348         return getEncodedInternal().clone();
 349     }
 350 
 351     /**
 352      * Returned the encoding as an uncloned byte array. Callers must
 353      * guarantee that they neither modify it nor expose it to untrusted
 354      * code.
 355      */
 356     public byte[] getEncodedInternal() throws CertificateEncodingException {
 357         if (signedCert == null) {
 358             throw new CertificateEncodingException(
 359                           &quot;Null certificate to encode&quot;);
 360         }
 361         return signedCert;
 362     }
 363 
 364     /**
 365      * Throws an exception if the certificate was not signed using the
 366      * verification key provided.  Successfully verifying a certificate
 367      * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
 368      * it represents.
 369      *
 370      * @param key the public key used for verification.
 371      *
 372      * @exception InvalidKeyException on incorrect key.
 373      * @exception NoSuchAlgorithmException on unsupported signature
 374      * algorithms.
 375      * @exception NoSuchProviderException if there&#39;s no default provider.
 376      * @exception SignatureException on signature errors.
 377      * @exception CertificateException on encoding errors.
 378      */
 379     public void verify(PublicKey key)
 380     throws CertificateException, NoSuchAlgorithmException,
 381         InvalidKeyException, NoSuchProviderException, SignatureException {
 382         verify(key, &quot;&quot;);
 383     }
 384 
 385     /**
 386      * Throws an exception if the certificate was not signed using the
 387      * verification key provided.  Successfully verifying a certificate
 388      * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
 389      * it represents.
 390      *
 391      * @param key the public key used for verification.
 392      * @param sigProvider the name of the provider.
 393      *
 394      * @exception NoSuchAlgorithmException on unsupported signature
 395      * algorithms.
 396      * @exception InvalidKeyException on incorrect key.
 397      * @exception NoSuchProviderException on incorrect provider.
 398      * @exception SignatureException on signature errors.
 399      * @exception CertificateException on encoding errors.
 400      */
 401     public synchronized void verify(PublicKey key, String sigProvider)
 402             throws CertificateException, NoSuchAlgorithmException,
 403             InvalidKeyException, NoSuchProviderException, SignatureException {
 404         if (sigProvider == null) {
 405             sigProvider = &quot;&quot;;
 406         }
 407         if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
 408             // this certificate has already been verified using
 409             // this public key. Make sure providers match, too.
 410             if (sigProvider.equals(verifiedProvider)) {
 411                 if (verificationResult) {
 412                     return;
 413                 } else {
 414                     throw new SignatureException(&quot;Signature does not match.&quot;);
 415                 }
 416             }
 417         }
 418         if (signedCert == null) {
 419             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 420         }
 421         // Verify the signature ...
 422         Signature sigVerf = null;
 423         String sigName = algId.getName();
 424         if (sigProvider.isEmpty()) {
 425             sigVerf = Signature.getInstance(sigName);
 426         } else {
 427             sigVerf = Signature.getInstance(sigName, sigProvider);
 428         }
 429 
 430         try {
 431             SignatureUtil.initVerifyWithParam(sigVerf, key,
 432                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 433         } catch (ProviderException e) {
 434             throw new CertificateException(e.getMessage(), e.getCause());
 435         } catch (InvalidAlgorithmParameterException e) {
 436             throw new CertificateException(e);
 437         }
 438 
 439         byte[] rawCert = info.getEncodedInfo();
 440         sigVerf.update(rawCert, 0, rawCert.length);
 441 
 442         // verify may throw SignatureException for invalid encodings, etc.
 443         verificationResult = sigVerf.verify(signature);
 444         verifiedPublicKey = key;
 445         verifiedProvider = sigProvider;
 446 
 447         if (verificationResult == false) {
 448             throw new SignatureException(&quot;Signature does not match.&quot;);
 449         }
 450     }
 451 
 452     /**
 453      * Throws an exception if the certificate was not signed using the
 454      * verification key provided.  This method uses the signature verification
 455      * engine supplied by the specified provider. Note that the specified
 456      * Provider object does not have to be registered in the provider list.
 457      * Successfully verifying a certificate does &lt;em&gt;not&lt;/em&gt; indicate that one
 458      * should trust the entity which it represents.
 459      *
 460      * @param key the public key used for verification.
 461      * @param sigProvider the provider.
 462      *
 463      * @exception NoSuchAlgorithmException on unsupported signature
 464      * algorithms.
 465      * @exception InvalidKeyException on incorrect key.
 466      * @exception SignatureException on signature errors.
 467      * @exception CertificateException on encoding errors.
 468      */
 469     public synchronized void verify(PublicKey key, Provider sigProvider)
 470             throws CertificateException, NoSuchAlgorithmException,
 471             InvalidKeyException, SignatureException {
 472         if (signedCert == null) {
 473             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
 474         }
 475         // Verify the signature ...
 476         Signature sigVerf = null;
 477         String sigName = algId.getName();
 478         if (sigProvider == null) {
 479             sigVerf = Signature.getInstance(sigName);
 480         } else {
 481             sigVerf = Signature.getInstance(sigName, sigProvider);
 482         }
 483 
 484         try {
 485             SignatureUtil.initVerifyWithParam(sigVerf, key,
 486                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 487         } catch (ProviderException e) {
 488             throw new CertificateException(e.getMessage(), e.getCause());
 489         } catch (InvalidAlgorithmParameterException e) {
 490             throw new CertificateException(e);
 491         }
 492 
 493         byte[] rawCert = info.getEncodedInfo();
 494         sigVerf.update(rawCert, 0, rawCert.length);
 495 
 496         // verify may throw SignatureException for invalid encodings, etc.
 497         verificationResult = sigVerf.verify(signature);
 498         verifiedPublicKey = key;
 499 
 500         if (verificationResult == false) {
 501             throw new SignatureException(&quot;Signature does not match.&quot;);
 502         }
 503     }
 504 
 505     /**
 506      * Creates an X.509 certificate, and signs it using the given key
 507      * (associating a signature algorithm and an X.500 name).
 508      * This operation is used to implement the certificate generation
 509      * functionality of a certificate authority.
 510      *
 511      * @param key the private key used for signing.
 512      * @param algorithm the name of the signature algorithm used.
 513      *
 514      * @exception InvalidKeyException on incorrect key.
 515      * @exception NoSuchAlgorithmException on unsupported signature
 516      * algorithms.
 517      * @exception NoSuchProviderException if there&#39;s no default provider.
 518      * @exception SignatureException on signature errors.
 519      * @exception CertificateException on encoding errors.
 520      */
 521     public void sign(PrivateKey key, String algorithm)
 522     throws CertificateException, NoSuchAlgorithmException,
 523         InvalidKeyException, NoSuchProviderException, SignatureException {
 524         sign(key, algorithm, null);
 525     }
 526 
 527     /**
 528      * Creates an X.509 certificate, and signs it using the given key
 529      * (associating a signature algorithm and an X.500 name).
 530      * This operation is used to implement the certificate generation
 531      * functionality of a certificate authority.
 532      *
 533      * @param key the private key used for signing.
 534      * @param algorithm the name of the signature algorithm used.
 535      * @param provider the name of the provider.
 536      *
 537      * @exception NoSuchAlgorithmException on unsupported signature
 538      * algorithms.
 539      * @exception InvalidKeyException on incorrect key.
 540      * @exception NoSuchProviderException on incorrect provider.
 541      * @exception SignatureException on signature errors.
 542      * @exception CertificateException on encoding errors.
 543      */
 544     public void sign(PrivateKey key, String algorithm, String provider)
 545     throws CertificateException, NoSuchAlgorithmException,
 546         InvalidKeyException, NoSuchProviderException, SignatureException {
 547         try {
 548             sign(key, null, algorithm, provider);
 549         } catch (InvalidAlgorithmParameterException e) {
 550             // should not happen; re-throw just in case
 551             throw new SignatureException(e);
 552         }
 553     }
 554 
 555     /**
 556      * Creates an X.509 certificate, and signs it using the given key
 557      * (associating a signature algorithm and an X.500 name), signature
 558      * parameters, and security provider. If the given provider name
 559      * is null or empty, the implementation look up will be based on
 560      * provider configurations.
 561      * This operation is used to implement the certificate generation
 562      * functionality of a certificate authority.
 563      *
 564      * @param key the private key used for signing
 565      * @param signingParams the parameters used for signing
 566      * @param algorithm the name of the signature algorithm used
 567      * @param provider the name of the provider, may be null
 568      *
 569      * @exception NoSuchAlgorithmException on unsupported signature
 570      *            algorithms
 571      * @exception InvalidKeyException on incorrect key
 572      * @exception InvalidAlgorithmParameterException on invalid signature
 573      *            parameters
 574      * @exception NoSuchProviderException on incorrect provider
 575      * @exception SignatureException on signature errors
 576      * @exception CertificateException on encoding errors
 577      */
 578     public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,
 579             String algorithm, String provider)
 580             throws CertificateException, NoSuchAlgorithmException,
 581             InvalidKeyException, InvalidAlgorithmParameterException,
 582             NoSuchProviderException, SignatureException {
 583         if (readOnly) {
 584             throw new CertificateEncodingException(
 585                     &quot;cannot over-write existing certificate&quot;);
 586         }
 587         Signature sigEngine = null;
 588         if (provider == null || provider.isEmpty()) {
 589             sigEngine = Signature.getInstance(algorithm);
 590         } else {
 591             sigEngine = Signature.getInstance(algorithm, provider);
 592         }
 593 
 594         SignatureUtil.initSignWithParam(sigEngine, key, signingParams,
 595                 null);
 596 
 597         if (signingParams != null) {
 598             algId = AlgorithmId.get(sigEngine.getParameters());
 599         } else {
 600             // in case the name is reset
 601             algId = AlgorithmId.get(sigEngine.getAlgorithm());
 602         }
 603         DerOutputStream out = new DerOutputStream();
 604         DerOutputStream tmp = new DerOutputStream();
 605 
 606         // encode certificate info
 607         info.encode(tmp);
 608         byte[] rawCert = tmp.toByteArray();
 609 
 610         // encode algorithm identifier
 611         algId.derEncode(tmp);
 612 
 613         // Create and encode the signature itself.
 614         sigEngine.update(rawCert, 0, rawCert.length);
 615         signature = sigEngine.sign();
 616         tmp.putBitString(signature);
 617 
 618         // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
 619         out.write(DerValue.tag_Sequence, tmp);
 620         signedCert = out.toByteArray();
 621         readOnly = true;
 622     }
 623 
 624     /**
 625      * Checks that the certificate is currently valid, i.e. the current
 626      * time is within the specified validity period.
 627      *
 628      * @exception CertificateExpiredException if the certificate has expired.
 629      * @exception CertificateNotYetValidException if the certificate is not
 630      * yet valid.
 631      */
 632     public void checkValidity()
 633     throws CertificateExpiredException, CertificateNotYetValidException {
 634         Date date = new Date();
 635         checkValidity(date);
 636     }
 637 
 638     /**
 639      * Checks that the specified date is within the certificate&#39;s
 640      * validity period, or basically if the certificate would be
 641      * valid at the specified date/time.
 642      *
 643      * @param date the Date to check against to see if this certificate
 644      *        is valid at that date/time.
 645      *
 646      * @exception CertificateExpiredException if the certificate has expired
 647      * with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
 648      * @exception CertificateNotYetValidException if the certificate is not
 649      * yet valid with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
 650      */
 651     public void checkValidity(Date date)
 652     throws CertificateExpiredException, CertificateNotYetValidException {
 653 
 654         CertificateValidity interval = null;
 655         try {
 656             interval = (CertificateValidity)info.get(CertificateValidity.NAME);
 657         } catch (Exception e) {
 658             throw new CertificateNotYetValidException(&quot;Incorrect validity period&quot;);
 659         }
 660         if (interval == null)
 661             throw new CertificateNotYetValidException(&quot;Null validity period&quot;);
 662         interval.valid(date);
 663     }
 664 
 665     /**
 666      * Return the requested attribute from the certificate.
 667      *
 668      * Note that the X509CertInfo is not cloned for performance reasons.
 669      * Callers must ensure that they do not modify it. All other
 670      * attributes are cloned.
 671      *
 672      * @param name the name of the attribute.
 673      * @exception CertificateParsingException on invalid attribute identifier.
 674      */
 675     public Object get(String name)
 676     throws CertificateParsingException {
 677         X509AttributeName attr = new X509AttributeName(name);
 678         String id = attr.getPrefix();
 679         if (!(id.equalsIgnoreCase(NAME))) {
 680             throw new CertificateParsingException(&quot;Invalid root of &quot;
 681                           + &quot;attribute name, expected [&quot; + NAME +
 682                           &quot;], received &quot; + &quot;[&quot; + id + &quot;]&quot;);
 683         }
 684         attr = new X509AttributeName(attr.getSuffix());
 685         id = attr.getPrefix();
 686 
 687         if (id.equalsIgnoreCase(INFO)) {
 688             if (info == null) {
 689                 return null;
 690             }
 691             if (attr.getSuffix() != null) {
 692                 try {
 693                     return info.get(attr.getSuffix());
 694                 } catch (IOException e) {
 695                     throw new CertificateParsingException(e.toString());
 696                 } catch (CertificateException e) {
 697                     throw new CertificateParsingException(e.toString());
 698                 }
 699             } else {
 700                 return info;
 701             }
 702         } else if (id.equalsIgnoreCase(ALG_ID)) {
 703             return(algId);
 704         } else if (id.equalsIgnoreCase(SIGNATURE)) {
 705             if (signature != null)
 706                 return signature.clone();
 707             else
 708                 return null;
 709         } else if (id.equalsIgnoreCase(SIGNED_CERT)) {
 710             if (signedCert != null)
 711                 return signedCert.clone();
 712             else
 713                 return null;
 714         } else {
 715             throw new CertificateParsingException(&quot;Attribute name not &quot;
 716                  + &quot;recognized or get() not allowed for the same: &quot; + id);
 717         }
 718     }
 719 
 720     /**
 721      * Set the requested attribute in the certificate.
 722      *
 723      * @param name the name of the attribute.
 724      * @param obj the value of the attribute.
 725      * @exception CertificateException on invalid attribute identifier.
 726      * @exception IOException on encoding error of attribute.
 727      */
 728     public void set(String name, Object obj)
 729     throws CertificateException, IOException {
 730         // check if immutable
 731         if (readOnly)
 732             throw new CertificateException(&quot;cannot over-write existing&quot;
 733                                            + &quot; certificate&quot;);
 734 
 735         X509AttributeName attr = new X509AttributeName(name);
 736         String id = attr.getPrefix();
 737         if (!(id.equalsIgnoreCase(NAME))) {
 738             throw new CertificateException(&quot;Invalid root of attribute name,&quot;
 739                            + &quot; expected [&quot; + NAME + &quot;], received &quot; + id);
 740         }
 741         attr = new X509AttributeName(attr.getSuffix());
 742         id = attr.getPrefix();
 743 
 744         if (id.equalsIgnoreCase(INFO)) {
 745             if (attr.getSuffix() == null) {
 746                 if (!(obj instanceof X509CertInfo)) {
 747                     throw new CertificateException(&quot;Attribute value should&quot;
 748                                     + &quot; be of type X509CertInfo.&quot;);
 749                 }
 750                 info = (X509CertInfo)obj;
 751                 signedCert = null;  //reset this as certificate data has changed
 752             } else {
 753                 info.set(attr.getSuffix(), obj);
 754                 signedCert = null;  //reset this as certificate data has changed
 755             }
 756         } else {
 757             throw new CertificateException(&quot;Attribute name not recognized or &quot; +
 758                               &quot;set() not allowed for the same: &quot; + id);
 759         }
 760     }
 761 
 762     /**
 763      * Delete the requested attribute from the certificate.
 764      *
 765      * @param name the name of the attribute.
 766      * @exception CertificateException on invalid attribute identifier.
 767      * @exception IOException on other errors.
 768      */
 769     public void delete(String name)
 770     throws CertificateException, IOException {
 771         // check if immutable
 772         if (readOnly)
 773             throw new CertificateException(&quot;cannot over-write existing&quot;
 774                                            + &quot; certificate&quot;);
 775 
 776         X509AttributeName attr = new X509AttributeName(name);
 777         String id = attr.getPrefix();
 778         if (!(id.equalsIgnoreCase(NAME))) {
 779             throw new CertificateException(&quot;Invalid root of attribute name,&quot;
 780                                    + &quot; expected [&quot;
 781                                    + NAME + &quot;], received &quot; + id);
 782         }
 783         attr = new X509AttributeName(attr.getSuffix());
 784         id = attr.getPrefix();
 785 
 786         if (id.equalsIgnoreCase(INFO)) {
 787             if (attr.getSuffix() != null) {
 788                 info = null;
 789             } else {
 790                 info.delete(attr.getSuffix());
 791             }
 792         } else if (id.equalsIgnoreCase(ALG_ID)) {
 793             algId = null;
 794         } else if (id.equalsIgnoreCase(SIGNATURE)) {
 795             signature = null;
 796         } else if (id.equalsIgnoreCase(SIGNED_CERT)) {
 797             signedCert = null;
 798         } else {
 799             throw new CertificateException(&quot;Attribute name not recognized or &quot; +
 800                               &quot;delete() not allowed for the same: &quot; + id);
 801         }
 802     }
 803 
 804     /**
 805      * Return an enumeration of names of attributes existing within this
 806      * attribute.
 807      */
 808     public Enumeration&lt;String&gt; getElements() {
 809         AttributeNameEnumeration elements = new AttributeNameEnumeration();
 810         elements.addElement(NAME + DOT + INFO);
 811         elements.addElement(NAME + DOT + ALG_ID);
 812         elements.addElement(NAME + DOT + SIGNATURE);
 813         elements.addElement(NAME + DOT + SIGNED_CERT);
 814 
 815         return elements.elements();
 816     }
 817 
 818     /**
 819      * Return the name of this attribute.
 820      */
 821     public String getName() {
 822         return(NAME);
 823     }
 824 
 825     /**
 826      * Returns a printable representation of the certificate.  This does not
 827      * contain all the information available to distinguish this from any
 828      * other certificate.  The certificate must be fully constructed
 829      * before this function may be called.
 830      */
 831     public String toString() {
 832         if (info == null || algId == null || signature == null)
 833             return &quot;&quot;;
 834 
 835         HexDumpEncoder encoder = new HexDumpEncoder();
 836         return &quot;[\n&quot; + info + &#39;\n&#39; +
 837             &quot;  Algorithm: [&quot; + algId + &quot;]\n&quot; +
 838             &quot;  Signature:\n&quot; + encoder.encodeBuffer(signature) + &quot;\n]&quot;;
 839     }
 840 
 841     // the strongly typed gets, as per java.security.cert.X509Certificate
 842 
 843     /**
 844      * Gets the publickey from this certificate.
 845      *
 846      * @return the publickey.
 847      */
 848     public PublicKey getPublicKey() {
 849         if (info == null)
 850             return null;
 851         try {
 852             PublicKey key = (PublicKey)info.get(CertificateX509Key.NAME
 853                                 + DOT + CertificateX509Key.KEY);
 854             return key;
 855         } catch (Exception e) {
 856             return null;
 857         }
 858     }
 859 
 860     /**
 861      * Gets the version number from the certificate.
 862      *
 863      * @return the version number, i.e. 1, 2 or 3.
 864      */
 865     public int getVersion() {
 866         if (info == null)
 867             return -1;
 868         try {
 869             int vers = ((Integer)info.get(CertificateVersion.NAME
 870                         + DOT + CertificateVersion.VERSION)).intValue();
 871             return vers+1;
 872         } catch (Exception e) {
 873             return -1;
 874         }
 875     }
 876 
 877     /**
 878      * Gets the serial number from the certificate.
 879      *
 880      * @return the serial number.
 881      */
 882     public BigInteger getSerialNumber() {
 883         SerialNumber ser = getSerialNumberObject();
 884 
 885         return ser != null ? ser.getNumber() : null;
 886     }
 887 
 888     /**
 889      * Gets the serial number from the certificate as
 890      * a SerialNumber object.
 891      *
 892      * @return the serial number.
 893      */
 894     public SerialNumber getSerialNumberObject() {
 895         if (info == null)
 896             return null;
 897         try {
 898             SerialNumber ser = (SerialNumber)info.get(
 899                               CertificateSerialNumber.NAME + DOT +
 900                               CertificateSerialNumber.NUMBER);
 901            return ser;
 902         } catch (Exception e) {
 903             return null;
 904         }
 905     }
 906 
 907 
 908     /**
 909      * Gets the subject distinguished name from the certificate.
 910      *
 911      * @return the subject name.
 912      */
 913     public Principal getSubjectDN() {
 914         if (info == null)
 915             return null;
 916         try {
 917             Principal subject = (Principal)info.get(X509CertInfo.SUBJECT + DOT +
 918                                                     X509CertInfo.DN_NAME);
 919             return subject;
 920         } catch (Exception e) {
 921             return null;
 922         }
 923     }
 924 
 925     /**
 926      * Get subject name as X500Principal. Overrides implementation in
 927      * X509Certificate with a slightly more efficient version that is
 928      * also aware of X509CertImpl mutability.
 929      */
 930     public X500Principal getSubjectX500Principal() {
 931         if (info == null) {
 932             return null;
 933         }
 934         try {
 935             X500Principal subject = (X500Principal)info.get(
 936                                             X509CertInfo.SUBJECT + DOT +
 937                                             &quot;x500principal&quot;);
 938             return subject;
 939         } catch (Exception e) {
 940             return null;
 941         }
 942     }
 943 
 944     /**
 945      * Gets the issuer distinguished name from the certificate.
 946      *
 947      * @return the issuer name.
 948      */
 949     public Principal getIssuerDN() {
 950         if (info == null)
 951             return null;
 952         try {
 953             Principal issuer = (Principal)info.get(X509CertInfo.ISSUER + DOT +
 954                                                    X509CertInfo.DN_NAME);
 955             return issuer;
 956         } catch (Exception e) {
 957             return null;
 958         }
 959     }
 960 
 961     /**
 962      * Get issuer name as X500Principal. Overrides implementation in
 963      * X509Certificate with a slightly more efficient version that is
 964      * also aware of X509CertImpl mutability.
 965      */
 966     public X500Principal getIssuerX500Principal() {
 967         if (info == null) {
 968             return null;
 969         }
 970         try {
 971             X500Principal issuer = (X500Principal)info.get(
 972                                             X509CertInfo.ISSUER + DOT +
 973                                             &quot;x500principal&quot;);
 974             return issuer;
 975         } catch (Exception e) {
 976             return null;
 977         }
 978     }
 979 
 980     /**
 981      * Gets the notBefore date from the validity period of the certificate.
 982      *
 983      * @return the start date of the validity period.
 984      */
 985     public Date getNotBefore() {
 986         if (info == null)
 987             return null;
 988         try {
 989             Date d = (Date) info.get(CertificateValidity.NAME + DOT +
 990                                         CertificateValidity.NOT_BEFORE);
 991             return d;
 992         } catch (Exception e) {
 993             return null;
 994         }
 995     }
 996 
 997     /**
 998      * Gets the notAfter date from the validity period of the certificate.
 999      *
1000      * @return the end date of the validity period.
1001      */
1002     public Date getNotAfter() {
1003         if (info == null)
1004             return null;
1005         try {
1006             Date d = (Date) info.get(CertificateValidity.NAME + DOT +
1007                                      CertificateValidity.NOT_AFTER);
1008             return d;
1009         } catch (Exception e) {
1010             return null;
1011         }
1012     }
1013 
1014     /**
1015      * Gets the DER encoded certificate informations, the
1016      * &lt;code&gt;tbsCertificate&lt;/code&gt; from this certificate.
1017      * This can be used to verify the signature independently.
1018      *
1019      * @return the DER encoded certificate information.
1020      * @exception CertificateEncodingException if an encoding error occurs.
1021      */
1022     public byte[] getTBSCertificate() throws CertificateEncodingException {
1023         if (info != null) {
1024             return info.getEncodedInfo();
1025         } else
1026             throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
1027     }
1028 
1029     /**
1030      * Gets the raw Signature bits from the certificate.
1031      *
1032      * @return the signature.
1033      */
1034     public byte[] getSignature() {
1035         if (signature == null)
1036             return null;
1037         return signature.clone();
1038     }
1039 
1040     /**
1041      * Gets the signature algorithm name for the certificate
1042      * signature algorithm.
1043      * For example, the string &quot;SHA-1/DSA&quot; or &quot;DSS&quot;.
1044      *
1045      * @return the signature algorithm name.
1046      */
1047     public String getSigAlgName() {
1048         if (algId == null)
1049             return null;
1050         return (algId.getName());
1051     }
1052 
1053     /**
1054      * Gets the signature algorithm OID string from the certificate.
1055      * For example, the string &quot;1.2.840.10040.4.3&quot;
1056      *
1057      * @return the signature algorithm oid string.
1058      */
1059     public String getSigAlgOID() {
1060         if (algId == null)
1061             return null;
1062         ObjectIdentifier oid = algId.getOID();
1063         return (oid.toString());
1064     }
1065 
1066     /**
1067      * Gets the DER encoded signature algorithm parameters from this
1068      * certificate&#39;s signature algorithm.
1069      *
1070      * @return the DER encoded signature algorithm parameters, or
1071      *         null if no parameters are present.
1072      */
1073     public byte[] getSigAlgParams() {
1074         if (algId == null)
1075             return null;
1076         try {
1077             return algId.getEncodedParams();
1078         } catch (IOException e) {
1079             return null;
1080         }
1081     }
1082 
1083     /**
1084      * Gets the Issuer Unique Identity from the certificate.
1085      *
1086      * @return the Issuer Unique Identity.
1087      */
1088     public boolean[] getIssuerUniqueID() {
1089         if (info == null)
1090             return null;
1091         try {
1092             UniqueIdentity id = (UniqueIdentity)info.get(
1093                                  X509CertInfo.ISSUER_ID);
1094             if (id == null)
1095                 return null;
1096             else
1097                 return (id.getId());
1098         } catch (Exception e) {
1099             return null;
1100         }
1101     }
1102 
1103     /**
1104      * Gets the Subject Unique Identity from the certificate.
1105      *
1106      * @return the Subject Unique Identity.
1107      */
1108     public boolean[] getSubjectUniqueID() {
1109         if (info == null)
1110             return null;
1111         try {
1112             UniqueIdentity id = (UniqueIdentity)info.get(
1113                                  X509CertInfo.SUBJECT_ID);
1114             if (id == null)
1115                 return null;
1116             else
1117                 return (id.getId());
1118         } catch (Exception e) {
1119             return null;
1120         }
1121     }
1122 
1123     public KeyIdentifier getAuthKeyId() {
1124         AuthorityKeyIdentifierExtension aki
1125             = getAuthorityKeyIdentifierExtension();
1126         if (aki != null) {
1127             try {
1128                 return (KeyIdentifier)aki.get(
1129                     AuthorityKeyIdentifierExtension.KEY_ID);
1130             } catch (IOException ioe) {} // not possible
1131         }
1132         return null;
1133     }
1134 
1135     /**
1136      * Returns the subject&#39;s key identifier, or null
1137      */
1138     public KeyIdentifier getSubjectKeyId() {
1139         SubjectKeyIdentifierExtension ski = getSubjectKeyIdentifierExtension();
1140         if (ski != null) {
1141             try {
1142                 return ski.get(SubjectKeyIdentifierExtension.KEY_ID);
1143             } catch (IOException ioe) {} // not possible
1144         }
1145         return null;
1146     }
1147 
1148     /**
1149      * Get AuthorityKeyIdentifier extension
1150      * @return AuthorityKeyIdentifier object or null (if no such object
1151      * in certificate)
1152      */
1153     public AuthorityKeyIdentifierExtension getAuthorityKeyIdentifierExtension()
1154     {
1155         return (AuthorityKeyIdentifierExtension)
1156             getExtension(PKIXExtensions.AuthorityKey_Id);
1157     }
1158 
1159     /**
1160      * Get BasicConstraints extension
1161      * @return BasicConstraints object or null (if no such object in
1162      * certificate)
1163      */
1164     public BasicConstraintsExtension getBasicConstraintsExtension() {
1165         return (BasicConstraintsExtension)
1166             getExtension(PKIXExtensions.BasicConstraints_Id);
1167     }
1168 
1169     /**
1170      * Get CertificatePoliciesExtension
1171      * @return CertificatePoliciesExtension or null (if no such object in
1172      * certificate)
1173      */
1174     public CertificatePoliciesExtension getCertificatePoliciesExtension() {
1175         return (CertificatePoliciesExtension)
1176             getExtension(PKIXExtensions.CertificatePolicies_Id);
1177     }
1178 
1179     /**
1180      * Get ExtendedKeyUsage extension
1181      * @return ExtendedKeyUsage extension object or null (if no such object
1182      * in certificate)
1183      */
1184     public ExtendedKeyUsageExtension getExtendedKeyUsageExtension() {
1185         return (ExtendedKeyUsageExtension)
1186             getExtension(PKIXExtensions.ExtendedKeyUsage_Id);
1187     }
1188 
1189     /**
1190      * Get IssuerAlternativeName extension
1191      * @return IssuerAlternativeName object or null (if no such object in
1192      * certificate)
1193      */
1194     public IssuerAlternativeNameExtension getIssuerAlternativeNameExtension() {
1195         return (IssuerAlternativeNameExtension)
1196             getExtension(PKIXExtensions.IssuerAlternativeName_Id);
1197     }
1198 
1199     /**
1200      * Get NameConstraints extension
1201      * @return NameConstraints object or null (if no such object in certificate)
1202      */
1203     public NameConstraintsExtension getNameConstraintsExtension() {
1204         return (NameConstraintsExtension)
1205             getExtension(PKIXExtensions.NameConstraints_Id);
1206     }
1207 
1208     /**
1209      * Get PolicyConstraints extension
1210      * @return PolicyConstraints object or null (if no such object in
1211      * certificate)
1212      */
1213     public PolicyConstraintsExtension getPolicyConstraintsExtension() {
1214         return (PolicyConstraintsExtension)
1215             getExtension(PKIXExtensions.PolicyConstraints_Id);
1216     }
1217 
1218     /**
1219      * Get PolicyMappingsExtension extension
1220      * @return PolicyMappingsExtension object or null (if no such object
1221      * in certificate)
1222      */
1223     public PolicyMappingsExtension getPolicyMappingsExtension() {
1224         return (PolicyMappingsExtension)
1225             getExtension(PKIXExtensions.PolicyMappings_Id);
1226     }
1227 
1228     /**
1229      * Get PrivateKeyUsage extension
1230      * @return PrivateKeyUsage object or null (if no such object in certificate)
1231      */
1232     public PrivateKeyUsageExtension getPrivateKeyUsageExtension() {
1233         return (PrivateKeyUsageExtension)
1234             getExtension(PKIXExtensions.PrivateKeyUsage_Id);
1235     }
1236 
1237     /**
1238      * Get SubjectAlternativeName extension
1239      * @return SubjectAlternativeName object or null (if no such object in
1240      * certificate)
1241      */
1242     public SubjectAlternativeNameExtension getSubjectAlternativeNameExtension()
1243     {
1244         return (SubjectAlternativeNameExtension)
1245             getExtension(PKIXExtensions.SubjectAlternativeName_Id);
1246     }
1247 
1248     /**
1249      * Get SubjectKeyIdentifier extension
1250      * @return SubjectKeyIdentifier object or null (if no such object in
1251      * certificate)
1252      */
1253     public SubjectKeyIdentifierExtension getSubjectKeyIdentifierExtension() {
1254         return (SubjectKeyIdentifierExtension)
1255             getExtension(PKIXExtensions.SubjectKey_Id);
1256     }
1257 
1258     /**
1259      * Get CRLDistributionPoints extension
1260      * @return CRLDistributionPoints object or null (if no such object in
1261      * certificate)
1262      */
1263     public CRLDistributionPointsExtension getCRLDistributionPointsExtension() {
1264         return (CRLDistributionPointsExtension)
1265             getExtension(PKIXExtensions.CRLDistributionPoints_Id);
1266     }
1267 
1268     /**
1269      * Return true if a critical extension is found that is
1270      * not supported, otherwise return false.
1271      */
1272     public boolean hasUnsupportedCriticalExtension() {
1273         if (info == null)
1274             return false;
1275         try {
1276             CertificateExtensions exts = (CertificateExtensions)info.get(
1277                                          CertificateExtensions.NAME);
1278             if (exts == null)
1279                 return false;
1280             return exts.hasUnsupportedCriticalExtension();
1281         } catch (Exception e) {
1282             return false;
1283         }
1284     }
1285 
1286     /**
1287      * Gets a Set of the extension(s) marked CRITICAL in the
1288      * certificate. In the returned set, each extension is
1289      * represented by its OID string.
1290      *
1291      * @return a set of the extension oid strings in the
1292      * certificate that are marked critical.
1293      */
1294     public Set&lt;String&gt; getCriticalExtensionOIDs() {
1295         if (info == null) {
1296             return null;
1297         }
1298         try {
1299             CertificateExtensions exts = (CertificateExtensions)info.get(
1300                                          CertificateExtensions.NAME);
1301             if (exts == null) {
1302                 return null;
1303             }
1304             Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
1305             for (Extension ex : exts.getAllExtensions()) {
1306                 if (ex.isCritical()) {
1307                     extSet.add(ex.getExtensionId().toString());
1308                 }
1309             }
1310             return extSet;
1311         } catch (Exception e) {
1312             return null;
1313         }
1314     }
1315 
1316     /**
1317      * Gets a Set of the extension(s) marked NON-CRITICAL in the
1318      * certificate. In the returned set, each extension is
1319      * represented by its OID string.
1320      *
1321      * @return a set of the extension oid strings in the
1322      * certificate that are NOT marked critical.
1323      */
1324     public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
1325         if (info == null) {
1326             return null;
1327         }
1328         try {
1329             CertificateExtensions exts = (CertificateExtensions)info.get(
1330                                          CertificateExtensions.NAME);
1331             if (exts == null) {
1332                 return null;
1333             }
1334             Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
1335             for (Extension ex : exts.getAllExtensions()) {
1336                 if (!ex.isCritical()) {
1337                     extSet.add(ex.getExtensionId().toString());
1338                 }
1339             }
1340             extSet.addAll(exts.getUnparseableExtensions().keySet());
1341             return extSet;
1342         } catch (Exception e) {
1343             return null;
1344         }
1345     }
1346 
1347     /**
1348      * Gets the extension identified by the given ObjectIdentifier
1349      *
1350      * @param oid the Object Identifier value for the extension.
1351      * @return Extension or null if certificate does not contain this
1352      *         extension
1353      */
1354     public Extension getExtension(ObjectIdentifier oid) {
1355         if (info == null) {
1356             return null;
1357         }
1358         try {
1359             CertificateExtensions extensions;
1360             try {
1361                 extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);
1362             } catch (CertificateException ce) {
1363                 return null;
1364             }
1365             if (extensions == null) {
1366                 return null;
1367             } else {
1368                 Extension ex = extensions.getExtension(oid.toString());
1369                 if (ex != null) {
1370                     return ex;
1371                 }
1372                 for (Extension ex2: extensions.getAllExtensions()) {
1373                     if (ex2.getExtensionId().equals(oid)) {
1374                         //XXXX May want to consider cloning this
1375                         return ex2;
1376                     }
1377                 }
1378                 /* no such extension in this certificate */
1379                 return null;
1380             }
1381         } catch (IOException ioe) {
1382             return null;
1383         }
1384     }
1385 
1386     public Extension getUnparseableExtension(ObjectIdentifier oid) {
1387         if (info == null) {
1388             return null;
1389         }
1390         try {
1391             CertificateExtensions extensions;
1392             try {
1393                 extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);
1394             } catch (CertificateException ce) {
1395                 return null;
1396             }
1397             if (extensions == null) {
1398                 return null;
1399             } else {
1400                 return extensions.getUnparseableExtensions().get(oid.toString());
1401             }
1402         } catch (IOException ioe) {
1403             return null;
1404         }
1405     }
1406 
1407     /**
1408      * Gets the DER encoded extension identified by the given
1409      * oid String.
1410      *
1411      * @param oid the Object Identifier value for the extension.
1412      */
1413     public byte[] getExtensionValue(String oid) {
1414         try {
1415             ObjectIdentifier findOID = ObjectIdentifier.of(oid);
1416             String extAlias = OIDMap.getName(findOID);
1417             Extension certExt = null;
1418             CertificateExtensions exts = (CertificateExtensions)info.get(
1419                                      CertificateExtensions.NAME);
1420 
1421             if (extAlias == null) { // may be unknown
1422                 // get the extensions, search thru&#39; for this oid
1423                 if (exts == null) {
1424                     return null;
1425                 }
1426 
1427                 for (Extension ex : exts.getAllExtensions()) {
1428                     ObjectIdentifier inCertOID = ex.getExtensionId();
1429                     if (inCertOID.equals(findOID)) {
1430                         certExt = ex;
1431                         break;
1432                     }
1433                 }
1434             } else { // there&#39;s sub-class that can handle this extension
1435                 try {
1436                     certExt = (Extension)this.get(extAlias);
1437                 } catch (CertificateException e) {
1438                     // get() throws an Exception instead of returning null, ignore
1439                 }
1440             }
1441             if (certExt == null) {
1442                 if (exts != null) {
1443                     certExt = exts.getUnparseableExtensions().get(oid);
1444                 }
1445                 if (certExt == null) {
1446                     return null;
1447                 }
1448             }
1449             byte[] extData = certExt.getExtensionValue();
1450             if (extData == null) {
1451                 return null;
1452             }
1453             DerOutputStream out = new DerOutputStream();
1454             out.putOctetString(extData);
1455             return out.toByteArray();
1456         } catch (Exception e) {
1457             return null;
1458         }
1459     }
1460 
1461     /**
1462      * Get a boolean array representing the bits of the KeyUsage extension,
1463      * (oid = 2.5.29.15).
1464      * @return the bit values of this extension as an array of booleans.
1465      */
1466     public boolean[] getKeyUsage() {
1467         try {
1468             String extAlias = OIDMap.getName(PKIXExtensions.KeyUsage_Id);
1469             if (extAlias == null)
1470                 return null;
1471 
1472             KeyUsageExtension certExt = (KeyUsageExtension)this.get(extAlias);
1473             if (certExt == null)
1474                 return null;
1475 
1476             boolean[] ret = certExt.getBits();
1477             if (ret.length &lt; NUM_STANDARD_KEY_USAGE) {
1478                 boolean[] usageBits = new boolean[NUM_STANDARD_KEY_USAGE];
1479                 System.arraycopy(ret, 0, usageBits, 0, ret.length);
1480                 ret = usageBits;
1481             }
1482             return ret;
1483         } catch (Exception e) {
1484             return null;
1485         }
1486     }
1487 
1488     /**
1489      * This method are the overridden implementation of
1490      * getExtendedKeyUsage method in X509Certificate in the Sun
1491      * provider. It is better performance-wise since it returns cached
1492      * values.
1493      */
1494     public synchronized List&lt;String&gt; getExtendedKeyUsage()
1495         throws CertificateParsingException {
1496         if (readOnly &amp;&amp; extKeyUsage != null) {
1497             return extKeyUsage;
1498         } else {
1499             ExtendedKeyUsageExtension ext = getExtendedKeyUsageExtension();
1500             if (ext == null) {
1501                 return null;
1502             }
1503             extKeyUsage =
1504                 Collections.unmodifiableList(ext.getExtendedKeyUsage());
1505             return extKeyUsage;
1506         }
1507     }
1508 
1509     /**
1510      * This static method is the default implementation of the
1511      * getExtendedKeyUsage method in X509Certificate. A
1512      * X509Certificate provider generally should overwrite this to
1513      * provide among other things caching for better performance.
1514      */
1515     public static List&lt;String&gt; getExtendedKeyUsage(X509Certificate cert)
1516         throws CertificateParsingException {
1517         try {
1518             byte[] ext = cert.getExtensionValue
1519                     (KnownOIDs.extendedKeyUsage.value());
1520             if (ext == null)
1521                 return null;
1522             DerValue val = new DerValue(ext);
1523             byte[] data = val.getOctetString();
1524 
1525             ExtendedKeyUsageExtension ekuExt =
1526                 new ExtendedKeyUsageExtension(Boolean.FALSE, data);
1527             return Collections.unmodifiableList(ekuExt.getExtendedKeyUsage());
1528         } catch (IOException ioe) {
1529             throw new CertificateParsingException(ioe);
1530         }
1531     }
1532 
1533     /**
1534      * Get the certificate constraints path length from
1535      * the critical BasicConstraints extension, (oid = 2.5.29.19).
1536      * @return the length of the constraint.
1537      */
1538     public int getBasicConstraints() {
1539         try {
1540             String extAlias = OIDMap.getName(PKIXExtensions.BasicConstraints_Id);
1541             if (extAlias == null)
1542                 return -1;
1543             BasicConstraintsExtension certExt =
1544                         (BasicConstraintsExtension)this.get(extAlias);
1545             if (certExt == null)
1546                 return -1;
1547 
1548             if (((Boolean)certExt.get(BasicConstraintsExtension.IS_CA)
1549                  ).booleanValue() == true)
1550                 return ((Integer)certExt.get(
1551                         BasicConstraintsExtension.PATH_LEN)).intValue();
1552             else
1553                 return -1;
1554         } catch (Exception e) {
1555             return -1;
1556         }
1557     }
1558 
1559     /**
1560      * Converts a GeneralNames structure into an immutable Collection of
1561      * alternative names (subject or issuer) in the form required by
1562      * {@link #getSubjectAlternativeNames} or
1563      * {@link #getIssuerAlternativeNames}.
1564      *
1565      * @param names the GeneralNames to be converted
1566      * @return an immutable Collection of alternative names
1567      */
1568     private static Collection&lt;List&lt;?&gt;&gt; makeAltNames(GeneralNames names) {
1569         if (names.isEmpty()) {
1570             return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1571         }
1572         List&lt;List&lt;?&gt;&gt; newNames = new ArrayList&lt;&gt;();
1573         for (GeneralName gname : names.names()) {
1574             GeneralNameInterface name = gname.getName();
1575             List&lt;Object&gt; nameEntry = new ArrayList&lt;&gt;(2);
1576             nameEntry.add(Integer.valueOf(name.getType()));
1577             switch (name.getType()) {
1578             case GeneralNameInterface.NAME_RFC822:
1579                 nameEntry.add(((RFC822Name) name).getName());
1580                 break;
1581             case GeneralNameInterface.NAME_DNS:
1582                 nameEntry.add(((DNSName) name).getName());
1583                 break;
1584             case GeneralNameInterface.NAME_DIRECTORY:
1585                 nameEntry.add(((X500Name) name).getRFC2253Name());
1586                 break;
1587             case GeneralNameInterface.NAME_URI:
1588                 nameEntry.add(((URIName) name).getName());
1589                 break;
1590             case GeneralNameInterface.NAME_IP:
1591                 try {
1592                     nameEntry.add(((IPAddressName) name).getName());
1593                 } catch (IOException ioe) {
1594                     // IPAddressName in cert is bogus
1595                     throw new RuntimeException(&quot;IPAddress cannot be parsed&quot;,
1596                         ioe);
1597                 }
1598                 break;
1599             case GeneralNameInterface.NAME_OID:
1600                 nameEntry.add(((OIDName) name).getOID().toString());
1601                 break;
1602             default:
1603                 // add DER encoded form
1604                 DerOutputStream derOut = new DerOutputStream();
1605                 name.derEncode(derOut);
1606                 nameEntry.add(derOut.toByteArray());
1607                 break;
1608             }
1609             newNames.add(Collections.unmodifiableList(nameEntry));
1610         }
1611         return Collections.unmodifiableCollection(newNames);
1612     }
1613 
1614     /**
1615      * Checks a Collection of altNames and clones any name entries of type
1616      * byte [].
1617      */ // only partially generified due to javac bug
1618     private static Collection&lt;List&lt;?&gt;&gt; cloneAltNames(Collection&lt;List&lt;?&gt;&gt; altNames) {
1619         boolean mustClone = false;
1620         for (List&lt;?&gt; nameEntry : altNames) {
1621             if (nameEntry.get(1) instanceof byte[]) {
1622                 // must clone names
1623                 mustClone = true;
1624             }
1625         }
1626         if (mustClone) {
1627             List&lt;List&lt;?&gt;&gt; namesCopy = new ArrayList&lt;&gt;();
1628             for (List&lt;?&gt; nameEntry : altNames) {
1629                 Object nameObject = nameEntry.get(1);
1630                 if (nameObject instanceof byte[]) {
1631                     List&lt;Object&gt; nameEntryCopy =
1632                                         new ArrayList&lt;&gt;(nameEntry);
1633                     nameEntryCopy.set(1, ((byte[])nameObject).clone());
1634                     namesCopy.add(Collections.unmodifiableList(nameEntryCopy));
1635                 } else {
1636                     namesCopy.add(nameEntry);
1637                 }
1638             }
1639             return Collections.unmodifiableCollection(namesCopy);
1640         } else {
1641             return altNames;
1642         }
1643     }
1644 
1645     /**
1646      * This method are the overridden implementation of
1647      * getSubjectAlternativeNames method in X509Certificate in the Sun
1648      * provider. It is better performance-wise since it returns cached
1649      * values.
1650      */
1651     public synchronized Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames()
1652         throws CertificateParsingException {
1653         // return cached value if we can
1654         if (readOnly &amp;&amp; subjectAlternativeNames != null)  {
1655             return cloneAltNames(subjectAlternativeNames);
1656         }
1657         SubjectAlternativeNameExtension subjectAltNameExt =
1658             getSubjectAlternativeNameExtension();
1659         if (subjectAltNameExt == null) {
1660             return null;
1661         }
1662         GeneralNames names;
1663         try {
1664             names = subjectAltNameExt.get(
1665                     SubjectAlternativeNameExtension.SUBJECT_NAME);
1666         } catch (IOException ioe) {
1667             // should not occur
1668             return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1669         }
1670         subjectAlternativeNames = makeAltNames(names);
1671         return subjectAlternativeNames;
1672     }
1673 
1674     /**
1675      * This static method is the default implementation of the
1676      * getSubjectAlternaitveNames method in X509Certificate. A
1677      * X509Certificate provider generally should overwrite this to
1678      * provide among other things caching for better performance.
1679      */
1680     public static Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames(X509Certificate cert)
1681         throws CertificateParsingException {
1682         try {
1683             byte[] ext = cert.getExtensionValue
1684                     (KnownOIDs.SubjectAlternativeName.value());
1685             if (ext == null) {
1686                 return null;
1687             }
1688             DerValue val = new DerValue(ext);
1689             byte[] data = val.getOctetString();
1690 
1691             SubjectAlternativeNameExtension subjectAltNameExt =
1692                 new SubjectAlternativeNameExtension(Boolean.FALSE,
1693                                                     data);
1694 
1695             GeneralNames names;
1696             try {
1697                 names = subjectAltNameExt.get(
1698                         SubjectAlternativeNameExtension.SUBJECT_NAME);
1699             }  catch (IOException ioe) {
1700                 // should not occur
1701                 return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1702             }
1703             return makeAltNames(names);
1704         } catch (IOException ioe) {
1705             throw new CertificateParsingException(ioe);
1706         }
1707     }
1708 
1709     /**
1710      * This method are the overridden implementation of
1711      * getIssuerAlternativeNames method in X509Certificate in the Sun
1712      * provider. It is better performance-wise since it returns cached
1713      * values.
1714      */
1715     public synchronized Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames()
1716         throws CertificateParsingException {
1717         // return cached value if we can
1718         if (readOnly &amp;&amp; issuerAlternativeNames != null) {
1719             return cloneAltNames(issuerAlternativeNames);
1720         }
1721         IssuerAlternativeNameExtension issuerAltNameExt =
1722             getIssuerAlternativeNameExtension();
1723         if (issuerAltNameExt == null) {
1724             return null;
1725         }
1726         GeneralNames names;
1727         try {
1728             names = issuerAltNameExt.get(
1729                     IssuerAlternativeNameExtension.ISSUER_NAME);
1730         } catch (IOException ioe) {
1731             // should not occur
1732             return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1733         }
1734         issuerAlternativeNames = makeAltNames(names);
1735         return issuerAlternativeNames;
1736     }
1737 
1738     /**
1739      * This static method is the default implementation of the
1740      * getIssuerAlternaitveNames method in X509Certificate. A
1741      * X509Certificate provider generally should overwrite this to
1742      * provide among other things caching for better performance.
1743      */
1744     public static Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames(X509Certificate cert)
1745         throws CertificateParsingException {
1746         try {
1747             byte[] ext = cert.getExtensionValue
1748                     (KnownOIDs.IssuerAlternativeName.value());
1749             if (ext == null) {
1750                 return null;
1751             }
1752 
1753             DerValue val = new DerValue(ext);
1754             byte[] data = val.getOctetString();
1755 
1756             IssuerAlternativeNameExtension issuerAltNameExt =
1757                 new IssuerAlternativeNameExtension(Boolean.FALSE,
1758                                                     data);
1759             GeneralNames names;
1760             try {
1761                 names = issuerAltNameExt.get(
1762                         IssuerAlternativeNameExtension.ISSUER_NAME);
1763             }  catch (IOException ioe) {
1764                 // should not occur
1765                 return Collections.&lt;List&lt;?&gt;&gt;emptySet();
1766             }
1767             return makeAltNames(names);
1768         } catch (IOException ioe) {
1769             throw new CertificateParsingException(ioe);
1770         }
1771     }
1772 
1773     public AuthorityInfoAccessExtension getAuthorityInfoAccessExtension() {
1774         return (AuthorityInfoAccessExtension)
1775             getExtension(PKIXExtensions.AuthInfoAccess_Id);
1776     }
1777 
1778     /************************************************************/
1779 
1780     /*
1781      * Cert is a SIGNED ASN.1 macro, a three elment sequence:
1782      *
1783      *  - Data to be signed (ToBeSigned) -- the &quot;raw&quot; cert
1784      *  - Signature algorithm (SigAlgId)
1785      *  - The signature bits
1786      *
1787      * This routine unmarshals the certificate, saving the signature
1788      * parts away for later verification.
1789      */
1790     private void parse(DerValue val)
1791     throws CertificateException, IOException {
1792         // check if can over write the certificate
1793         if (readOnly)
1794             throw new CertificateParsingException(
1795                       &quot;cannot over-write existing certificate&quot;);
1796 
1797         if (val.data == null || val.tag != DerValue.tag_Sequence)
1798             throw new CertificateParsingException(
1799                       &quot;invalid DER-encoded certificate data&quot;);
1800 
1801         signedCert = val.toByteArray();
1802         DerValue[] seq = new DerValue[3];
1803 
1804         seq[0] = val.data.getDerValue();
1805         seq[1] = val.data.getDerValue();
1806         seq[2] = val.data.getDerValue();
1807 
1808         if (val.data.available() != 0) {
1809             throw new CertificateParsingException(&quot;signed overrun, bytes = &quot;
1810                                      + val.data.available());
1811         }
1812         if (seq[0].tag != DerValue.tag_Sequence) {
1813             throw new CertificateParsingException(&quot;signed fields invalid&quot;);
1814         }
1815 
1816         algId = AlgorithmId.parse(seq[1]);
1817         signature = seq[2].getBitString();
1818 
1819         if (seq[1].data.available() != 0) {
1820             throw new CertificateParsingException(&quot;algid field overrun&quot;);
1821         }
1822         if (seq[2].data.available() != 0)
1823             throw new CertificateParsingException(&quot;signed fields overrun&quot;);
1824 
1825         // The CertificateInfo
1826         info = new X509CertInfo(seq[0]);
1827 
1828         // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
1829         AlgorithmId infoSigAlg = (AlgorithmId)info.get(
1830                                               CertificateAlgorithmId.NAME
1831                                               + DOT +
1832                                               CertificateAlgorithmId.ALGORITHM);
1833         if (! algId.equals(infoSigAlg))
1834             throw new CertificateException(&quot;Signature algorithm mismatch&quot;);
1835         readOnly = true;
1836     }
1837 
1838     /**
1839      * Extract the subject or issuer X500Principal from an X509Certificate.
1840      * Parses the encoded form of the cert to preserve the principal&#39;s
1841      * ASN.1 encoding.
1842      */
1843     private static X500Principal getX500Principal(X509Certificate cert,
1844             boolean getIssuer) throws Exception {
1845         byte[] encoded = cert.getEncoded();
1846         DerInputStream derIn = new DerInputStream(encoded);
1847         DerValue tbsCert = derIn.getSequence(3)[0];
1848         DerInputStream tbsIn = tbsCert.data;
1849         DerValue tmp;
1850         tmp = tbsIn.getDerValue();
1851         // skip version number if present
1852         if (tmp.isContextSpecific((byte)0)) {
1853           tmp = tbsIn.getDerValue();
1854         }
1855         // tmp always contains serial number now
1856         tmp = tbsIn.getDerValue();              // skip signature
1857         tmp = tbsIn.getDerValue();              // issuer
1858         if (getIssuer == false) {
1859             tmp = tbsIn.getDerValue();          // skip validity
1860             tmp = tbsIn.getDerValue();          // subject
1861         }
1862         byte[] principalBytes = tmp.toByteArray();
1863         return new X500Principal(principalBytes);
1864     }
1865 
1866     /**
1867      * Extract the subject X500Principal from an X509Certificate.
1868      * Called from java.security.cert.X509Certificate.getSubjectX500Principal().
1869      */
1870     public static X500Principal getSubjectX500Principal(X509Certificate cert) {
1871         try {
1872             return getX500Principal(cert, false);
1873         } catch (Exception e) {
1874             throw new RuntimeException(&quot;Could not parse subject&quot;, e);
1875         }
1876     }
1877 
1878     /**
1879      * Extract the issuer X500Principal from an X509Certificate.
1880      * Called from java.security.cert.X509Certificate.getIssuerX500Principal().
1881      */
1882     public static X500Principal getIssuerX500Principal(X509Certificate cert) {
1883         try {
1884             return getX500Principal(cert, true);
1885         } catch (Exception e) {
1886             throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
1887         }
1888     }
1889 
1890     /**
1891      * Returned the encoding of the given certificate for internal use.
1892      * Callers must guarantee that they neither modify it nor expose it
1893      * to untrusted code. Uses getEncodedInternal() if the certificate
1894      * is instance of X509CertImpl, getEncoded() otherwise.
1895      */
1896     public static byte[] getEncodedInternal(Certificate cert)
1897             throws CertificateEncodingException {
1898         if (cert instanceof X509CertImpl) {
1899             return ((X509CertImpl)cert).getEncodedInternal();
1900         } else {
1901             return cert.getEncoded();
1902         }
1903     }
1904 
1905     /**
1906      * Utility method to convert an arbitrary instance of X509Certificate
1907      * to a X509CertImpl. Does a cast if possible, otherwise reparses
1908      * the encoding.
1909      */
1910     public static X509CertImpl toImpl(X509Certificate cert)
1911             throws CertificateException {
1912         if (cert instanceof X509CertImpl) {
1913             return (X509CertImpl)cert;
1914         } else {
1915             return X509Factory.intern(cert);
1916         }
1917     }
1918 
1919     /**
1920      * Utility method to test if a certificate is self-issued. This is
1921      * the case iff the subject and issuer X500Principals are equal.
1922      */
1923     public static boolean isSelfIssued(X509Certificate cert) {
1924         X500Principal subject = cert.getSubjectX500Principal();
1925         X500Principal issuer = cert.getIssuerX500Principal();
1926         return subject.equals(issuer);
1927     }
1928 
1929     /**
1930      * Utility method to test if a certificate is self-signed. This is
1931      * the case iff the subject and issuer X500Principals are equal
1932      * AND the certificate&#39;s subject public key can be used to verify
1933      * the certificate. In case of exception, returns false.
1934      */
1935     public static boolean isSelfSigned(X509Certificate cert,
1936         String sigProvider) {
1937         if (isSelfIssued(cert)) {
1938             try {
1939                 if (sigProvider == null) {
1940                     cert.verify(cert.getPublicKey());
1941                 } else {
1942                     cert.verify(cert.getPublicKey(), sigProvider);
1943                 }
1944                 return true;
1945             } catch (Exception e) {
1946                 // In case of exception, return false
1947             }
1948         }
1949         return false;
1950     }
1951 
1952     private ConcurrentHashMap&lt;String,String&gt; fingerprints =
1953             new ConcurrentHashMap&lt;&gt;(2);
1954 
1955     public String getFingerprint(String algorithm) {
1956         return fingerprints.computeIfAbsent(algorithm,
1957             x -&gt; getFingerprint(x, this));
1958     }
1959 
1960     /**
1961      * Gets the requested finger print of the certificate. The result
1962      * only contains 0-9 and A-F. No small case, no colon.
1963      */
1964     public static String getFingerprint(String algorithm,
1965             X509Certificate cert) {
1966         try {
1967             byte[] encCertInfo = cert.getEncoded();
1968             MessageDigest md = MessageDigest.getInstance(algorithm);
1969             byte[] digest = md.digest(encCertInfo);
1970             StringBuilder sb = new StringBuilder(digest.length * 2);
1971             for (int i = 0; i &lt; digest.length; i++) {
1972                 byte2hex(digest[i], sb);
1973             }
1974             return sb.toString();
1975         } catch (NoSuchAlgorithmException | CertificateEncodingException e) {
1976             // ignored
1977         }
1978         return &quot;&quot;;
1979     }
1980 
1981     /**
1982      * Converts a byte to hex digit and writes to the supplied builder
1983      */
1984     private static void byte2hex(byte b, StringBuilder buf) {
1985         char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,
1986                 &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
1987         int high = ((b &amp; 0xf0) &gt;&gt; 4);
1988         int low = (b &amp; 0x0f);
1989         buf.append(hexChars[high])
1990             .append(hexChars[low]);
1991     }
1992 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/pkcs12/PKCS12KeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs12;
  27 
  28 import java.io.*;
  29 import java.security.AccessController;
  30 import java.security.MessageDigest;
  31 import java.security.NoSuchAlgorithmException;
  32 import java.security.Key;
  33 import java.security.KeyFactory;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreSpi;
  36 import java.security.KeyStoreException;
  37 import java.security.PKCS12Attribute;
  38 import java.security.PrivateKey;
  39 import java.security.PrivilegedAction;
  40 import java.security.UnrecoverableEntryException;
  41 import java.security.UnrecoverableKeyException;
  42 import java.security.SecureRandom;
  43 import java.security.Security;
  44 import java.security.cert.Certificate;
  45 import java.security.cert.CertificateFactory;
  46 import java.security.cert.X509Certificate;
  47 import java.security.cert.CertificateException;
  48 import java.security.spec.AlgorithmParameterSpec;
  49 import java.security.spec.InvalidParameterSpecException;
  50 import java.security.spec.KeySpec;
  51 import java.security.spec.PKCS8EncodedKeySpec;
  52 import java.util.*;
  53 
  54 import static java.nio.charset.StandardCharsets.UTF_8;
  55 
  56 import java.security.AlgorithmParameters;
  57 import java.security.InvalidAlgorithmParameterException;
  58 import javax.crypto.spec.PBEParameterSpec;
  59 import javax.crypto.spec.PBEKeySpec;
  60 import javax.crypto.spec.SecretKeySpec;
  61 import javax.crypto.SecretKeyFactory;
  62 import javax.crypto.SecretKey;
  63 import javax.crypto.Cipher;
  64 import javax.crypto.Mac;
  65 import javax.security.auth.DestroyFailedException;
  66 import javax.security.auth.x500.X500Principal;
  67 
  68 import sun.security.tools.KeyStoreUtil;
  69 import sun.security.util.*;
  70 import sun.security.pkcs.ContentInfo;
  71 import sun.security.x509.AlgorithmId;
  72 import sun.security.pkcs.EncryptedPrivateKeyInfo;
  73 import sun.security.provider.JavaKeyStore.JKS;
  74 import sun.security.x509.AuthorityKeyIdentifierExtension;
  75 
  76 
  77 /**
  78  * This class provides the keystore implementation referred to as &quot;PKCS12&quot;.
  79  * Implements the PKCS#12 PFX protected using the Password privacy mode.
  80  * The contents are protected using Password integrity mode.
  81  *
  82  * Currently these PBE algorithms are used by default:
  83  *  - PBEWithSHA1AndDESede to encrypt private keys, iteration count 50000.
  84  *  - PBEWithSHA1AndRC2_40 to encrypt certificates, iteration count 50000.
  85  *
  86  * The default Mac algorithm is  HmacPBESHA1, iteration count 100000.
  87  *
  88  * Supported encryption of various implementations :
  89  *
  90  * Software and mode.     Certificate encryption  Private key encryption
  91  * ---------------------------------------------------------------------
  92  * MSIE4 (domestic            40 bit RC2.            40 bit RC2
  93  * and xport versions)
  94  * PKCS#12 export.
  95  *
  96  * MSIE4, 5 (domestic         40 bit RC2,            40 bit RC2,
  97  * and export versions)       3 key triple DES       3 key triple DES
  98  * PKCS#12 import.
  99  *
 100  * MSIE5                      40 bit RC2             3 key triple DES,
 101  * PKCS#12 export.                                   with SHA1 (168 bits)
 102  *
 103  * Netscape Communicator      40 bit RC2             3 key triple DES,
 104  * (domestic and export                              with SHA1 (168 bits)
 105  * versions) PKCS#12 export
 106  *
 107  * Netscape Communicator      40 bit ciphers only    All.
 108  * (export version)
 109  * PKCS#12 import.
 110  *
 111  * Netscape Communicator      All.                   All.
 112  * (domestic or fortified
 113  * version) PKCS#12 import.
 114  *
 115  * OpenSSL PKCS#12 code.      All.                   All.
 116  * ---------------------------------------------------------------------
 117  *
 118  * NOTE: PKCS12 KeyStore supports PrivateKeyEntry and TrustedCertficateEntry.
 119  * PKCS#12 is mainly used to deliver private keys with their associated
 120  * certificate chain and aliases. In a PKCS12 keystore, entries are
 121  * identified by the alias, and a localKeyId is required to match the
 122  * private key with the certificate. Trusted certificate entries are identified
 123  * by the presence of an trustedKeyUsage attribute.
 124  *
 125  * @author Seema Malkani
 126  * @author Jeff Nisewanger
 127  * @author Jan Luehe
 128  *
 129  * @see java.security.KeyStoreSpi
 130  */
 131 public final class PKCS12KeyStore extends KeyStoreSpi {
 132 
 133     // special PKCS12 keystore that supports PKCS12 and JKS file formats
 134     public static final class DualFormatPKCS12 extends KeyStoreDelegator {
 135         public DualFormatPKCS12() {
 136             super(&quot;PKCS12&quot;, PKCS12KeyStore.class, &quot;JKS&quot;, JKS.class);
 137         }
 138     }
 139 
 140     public static final int VERSION_3 = 3;
 141 
 142     private static final int MAX_ITERATION_COUNT = 5000000;
 143     private static final int SALT_LEN = 20;
 144 
 145     private static final KnownOIDs[] CORE_ATTRIBUTES = {
 146         KnownOIDs.FriendlyName,
 147         KnownOIDs.LocalKeyID,
 148         KnownOIDs.ORACLE_TrustedKeyUsage
 149     };
 150 
 151     private static final Debug debug = Debug.getInstance(&quot;pkcs12&quot;);
 152 
 153     private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID =
 154             ObjectIdentifier.of(KnownOIDs.PKCS8ShroudedKeyBag);
 155     private static final ObjectIdentifier CertBag_OID =
 156             ObjectIdentifier.of(KnownOIDs.CertBag);
 157     private static final ObjectIdentifier SecretBag_OID =
 158             ObjectIdentifier.of(KnownOIDs.SecretBag);
 159 
 160     private static final ObjectIdentifier PKCS9FriendlyName_OID =
 161             ObjectIdentifier.of(KnownOIDs.FriendlyName);
 162     private static final ObjectIdentifier PKCS9LocalKeyId_OID =
 163             ObjectIdentifier.of(KnownOIDs.LocalKeyID);
 164     private static final ObjectIdentifier PKCS9CertType_OID =
 165             ObjectIdentifier.of(KnownOIDs.CertTypeX509);
 166     private static final ObjectIdentifier pbes2_OID =
 167             ObjectIdentifier.of(KnownOIDs.PBES2);
 168 
 169     /*
 170      * Temporary Oracle OID
 171      *
 172      * {joint-iso-itu-t(2) country(16) us(840) organization(1)
 173      *  oracle(113894) jdk(746875) crypto(1) id-at-trustedKeyUsage(1)}
 174      */
 175     private static final ObjectIdentifier TrustedKeyUsage_OID =
 176             ObjectIdentifier.of(KnownOIDs.ORACLE_TrustedKeyUsage);
 177 
 178     private static final ObjectIdentifier[] AnyUsage = new ObjectIdentifier[] {
 179                 ObjectIdentifier.of(KnownOIDs.anyExtendedKeyUsage)
 180             };
 181 
 182     private int counter = 0;
 183 
 184     // private key count
 185     // Note: This is a workaround to allow null localKeyID attribute
 186     // in pkcs12 with one private key entry and associated cert-chain
 187     private int privateKeyCount = 0;
 188 
 189     // secret key count
 190     private int secretKeyCount = 0;
 191 
 192     // certificate count
 193     private int certificateCount = 0;
 194 
 195     // Alg/params used for *this* keystore. Initialized as -1 for ic and
 196     // null for algorithm names. When an existing file is read, they will be
 197     // assigned inside engineLoad() so storing an existing keystore uses the
 198     // old alg/params. This makes sure if a keystore is created password-less
 199     // it will be password-less forever. Otherwise, engineStore() will read
 200     // the default values. These fields are always reset when load() is called.
 201     private String certProtectionAlgorithm = null;
 202     private int certPbeIterationCount = -1;
 203     private String macAlgorithm = null;
 204     private int macIterationCount = -1;
 205 
 206     // the source of randomness
 207     private SecureRandom random;
 208 
 209     // A keystore entry and associated attributes
 210     private static class Entry {
 211         Date date; // the creation date of this entry
 212         String alias;
 213         byte[] keyId;
 214         Set&lt;KeyStore.Entry.Attribute&gt; attributes;
 215     }
 216 
 217     // A key entry
 218     private static class KeyEntry extends Entry {
 219     }
 220 
 221     // A private key entry and its supporting certificate chain
 222     private static class PrivateKeyEntry extends KeyEntry {
 223         byte[] protectedPrivKey;
 224         Certificate[] chain;
 225     };
 226 
 227     // A secret key
 228     private static class SecretKeyEntry extends KeyEntry {
 229         byte[] protectedSecretKey;
 230     };
 231 
 232     // A certificate entry
 233     private static class CertEntry extends Entry {
 234         final X509Certificate cert;
 235         ObjectIdentifier[] trustedKeyUsage;
 236 
 237         CertEntry(X509Certificate cert, byte[] keyId, String alias) {
 238             this(cert, keyId, alias, null, null);
 239         }
 240 
 241         CertEntry(X509Certificate cert, byte[] keyId, String alias,
 242                 ObjectIdentifier[] trustedKeyUsage,
 243                 Set&lt;? extends KeyStore.Entry.Attribute&gt; attributes) {
 244             this.date = new Date();
 245             this.cert = cert;
 246             this.keyId = keyId;
 247             this.alias = alias;
 248             this.trustedKeyUsage = trustedKeyUsage;
 249             this.attributes = new HashSet&lt;&gt;();
 250             if (attributes != null) {
 251                 this.attributes.addAll(attributes);
 252             }
 253         }
 254     }
 255 
 256     /**
 257      * Retries an action with password &quot;\0&quot; if &quot;&quot; fails.
 258      * @param &lt;T&gt; the return type
 259      */
 260     @FunctionalInterface
 261     private interface RetryWithZero&lt;T&gt; {
 262 
 263         T tryOnce(char[] password) throws Exception;
 264 
 265         static &lt;S&gt; S run(RetryWithZero&lt;S&gt; f, char[] password) throws Exception {
 266             try {
 267                 return f.tryOnce(password);
 268             } catch (Exception e) {
 269                 if (password.length == 0) {
 270                     // Retry using an empty password with a NUL terminator.
 271                     if (debug != null) {
 272                         debug.println(&quot;Retry with a NUL password&quot;);
 273                     }
 274                     return f.tryOnce(new char[1]);
 275                 }
 276                 throw e;
 277             }
 278         }
 279     }
 280 
 281     /**
 282      * Private keys and certificates are stored in a map.
 283      * Map entries are keyed by alias names.
 284      */
 285     private Map&lt;String, Entry&gt; entries =
 286         Collections.synchronizedMap(new LinkedHashMap&lt;String, Entry&gt;());
 287 
 288     private ArrayList&lt;KeyEntry&gt; keyList = new ArrayList&lt;KeyEntry&gt;();
 289     private List&lt;X509Certificate&gt; allCerts = new ArrayList&lt;&gt;();
 290     private ArrayList&lt;CertEntry&gt; certEntries = new ArrayList&lt;CertEntry&gt;();
 291 
 292     /**
 293      * Returns the key associated with the given alias, using the given
 294      * password to recover it.
 295      *
 296      * @param alias the alias name
 297      * @param password the password for recovering the key
 298      *
 299      * @return the requested key, or null if the given alias does not exist
 300      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
 301      *
 302      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 303      * key cannot be found
 304      * @exception UnrecoverableKeyException if the key cannot be recovered
 305      * (e.g., the given password is wrong).
 306      */
 307     public Key engineGetKey(String alias, char[] password)
 308         throws NoSuchAlgorithmException, UnrecoverableKeyException
 309     {
 310         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 311         Key key = null;
 312 
 313         if (entry == null || (!(entry instanceof KeyEntry))) {
 314             return null;
 315         }
 316 
 317         // get the encoded private key or secret key
 318         byte[] encrBytes = null;
 319         if (entry instanceof PrivateKeyEntry) {
 320             encrBytes = ((PrivateKeyEntry) entry).protectedPrivKey;
 321         } else if (entry instanceof SecretKeyEntry) {
 322             encrBytes = ((SecretKeyEntry) entry).protectedSecretKey;
 323         } else {
 324             throw new UnrecoverableKeyException(&quot;Error locating key&quot;);
 325         }
 326 
 327         byte[] encryptedKey;
 328         AlgorithmParameters algParams;
 329         ObjectIdentifier algOid;
 330 
 331         try {
 332             // get the encrypted private key
 333             EncryptedPrivateKeyInfo encrInfo =
 334                         new EncryptedPrivateKeyInfo(encrBytes);
 335             encryptedKey = encrInfo.getEncryptedData();
 336 
 337             // parse Algorithm parameters
 338             DerValue val = new DerValue(encrInfo.getAlgorithm().encode());
 339             DerInputStream in = val.toDerInputStream();
 340             algOid = in.getOID();
 341             algParams = parseAlgParameters(algOid, in);
 342 
 343         } catch (IOException ioe) {
 344             UnrecoverableKeyException uke =
 345                 new UnrecoverableKeyException(&quot;Private key not stored as &quot;
 346                                  + &quot;PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe);
 347             uke.initCause(ioe);
 348             throw uke;
 349         }
 350 
 351        try {
 352             PBEParameterSpec pbeSpec;
 353             int ic;
 354 
 355             if (algParams != null) {
 356                 try {
 357                     pbeSpec =
 358                         algParams.getParameterSpec(PBEParameterSpec.class);
 359                 } catch (InvalidParameterSpecException ipse) {
 360                     throw new IOException(&quot;Invalid PBE algorithm parameters&quot;);
 361                 }
 362                 ic = pbeSpec.getIterationCount();
 363 
 364                 if (ic &gt; MAX_ITERATION_COUNT) {
 365                     throw new IOException(&quot;key PBE iteration count too large&quot;);
 366                 }
 367             } else {
 368                 ic = 0;
 369             }
 370 
 371             key = RetryWithZero.run(pass -&gt; {
 372                 // Use JCE
 373                 SecretKey skey = getPBEKey(pass);
 374                 Cipher cipher = Cipher.getInstance(
 375                         mapPBEParamsToAlgorithm(algOid, algParams));
 376                 cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
 377                 byte[] keyInfo = cipher.doFinal(encryptedKey);
 378                 /*
 379                  * Parse the key algorithm and then use a JCA key factory
 380                  * to re-create the key.
 381                  */
 382                 DerValue val = new DerValue(keyInfo);
 383                 DerInputStream in = val.toDerInputStream();
 384                 int i = in.getInteger();
 385                 DerValue[] value = in.getSequence(2);
 386                 AlgorithmId algId = new AlgorithmId(value[0].getOID());
 387                 String keyAlgo = algId.getName();
 388 
 389                 // decode private key
 390                 if (entry instanceof PrivateKeyEntry) {
 391                     KeyFactory kfac = KeyFactory.getInstance(keyAlgo);
 392                     PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(keyInfo);
 393                     Key tmp = kfac.generatePrivate(kspec);
 394 
 395                     if (debug != null) {
 396                         debug.println(&quot;Retrieved a protected private key at alias&quot; +
 397                                 &quot; &#39;&quot; + alias + &quot;&#39; (&quot; +
 398                                 mapPBEParamsToAlgorithm(algOid, algParams) +
 399                                 &quot; iterations: &quot; + ic + &quot;)&quot;);
 400                     }
 401                     return tmp;
 402                     // decode secret key
 403                 } else {
 404                     byte[] keyBytes = in.getOctetString();
 405                     SecretKeySpec secretKeySpec =
 406                             new SecretKeySpec(keyBytes, keyAlgo);
 407 
 408                     // Special handling required for PBE: needs a PBEKeySpec
 409                     Key tmp;
 410                     if (keyAlgo.startsWith(&quot;PBE&quot;)) {
 411                         SecretKeyFactory sKeyFactory =
 412                                 SecretKeyFactory.getInstance(keyAlgo);
 413                         KeySpec pbeKeySpec =
 414                                 sKeyFactory.getKeySpec(secretKeySpec, PBEKeySpec.class);
 415                         tmp = sKeyFactory.generateSecret(pbeKeySpec);
 416                     } else {
 417                         tmp = secretKeySpec;
 418                     }
 419 
 420                     if (debug != null) {
 421                         debug.println(&quot;Retrieved a protected secret key at alias &quot; +
 422                                 &quot;&#39;&quot; + alias + &quot;&#39; (&quot; +
 423                                 mapPBEParamsToAlgorithm(algOid, algParams) +
 424                                 &quot; iterations: &quot; + ic + &quot;)&quot;);
 425                     }
 426                     return tmp;
 427                 }
 428             }, password);
 429 
 430         } catch (Exception e) {
 431             UnrecoverableKeyException uke =
 432                 new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
 433                                         e.getMessage());
 434             uke.initCause(e);
 435             throw uke;
 436         }
 437         return key;
 438     }
 439 
 440     /**
 441      * Returns the certificate chain associated with the given alias.
 442      *
 443      * @param alias the alias name
 444      *
 445      * @return the certificate chain (ordered with the user&#39;s certificate first
 446      * and the root certificate authority last), or null if the given alias
 447      * does not exist or does not contain a certificate chain (i.e., the given
 448      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
 449      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
 450      */
 451     public Certificate[] engineGetCertificateChain(String alias) {
 452         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 453         if (entry != null &amp;&amp; entry instanceof PrivateKeyEntry) {
 454             if (((PrivateKeyEntry) entry).chain == null) {
 455                 return null;
 456             } else {
 457 
 458                 if (debug != null) {
 459                     debug.println(&quot;Retrieved a &quot; +
 460                         ((PrivateKeyEntry) entry).chain.length +
 461                         &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 462                 }
 463 
 464                 return ((PrivateKeyEntry) entry).chain.clone();
 465             }
 466         } else {
 467             return null;
 468         }
 469     }
 470 
 471     /**
 472      * Returns the certificate associated with the given alias.
 473      *
 474      * &lt;p&gt;If the given alias name identifies a
 475      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
 476      * entry is returned. If the given alias name identifies a
 477      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
 478      * entry is returned, or null if that entry does not have a certificate
 479      * chain.
 480      *
 481      * @param alias the alias name
 482      *
 483      * @return the certificate, or null if the given alias does not exist or
 484      * does not contain a certificate.
 485      */
 486     public Certificate engineGetCertificate(String alias) {
 487         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 488         if (entry == null) {
 489             return null;
 490         }
 491         if (entry instanceof CertEntry &amp;&amp;
 492             ((CertEntry) entry).trustedKeyUsage != null) {
 493 
 494             if (debug != null) {
 495                 if (Arrays.equals(AnyUsage,
 496                     ((CertEntry) entry).trustedKeyUsage)) {
 497                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 498                         &quot;&#39; (trusted for any purpose)&quot;);
 499                 } else {
 500                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 501                         &quot;&#39; (trusted for limited purposes)&quot;);
 502                 }
 503             }
 504 
 505             return ((CertEntry) entry).cert;
 506 
 507         } else if (entry instanceof PrivateKeyEntry) {
 508             if (((PrivateKeyEntry) entry).chain == null) {
 509                 return null;
 510             } else {
 511 
 512                 if (debug != null) {
 513                     debug.println(&quot;Retrieved a certificate at alias &#39;&quot; + alias +
 514                         &quot;&#39;&quot;);
 515                 }
 516 
 517                 return ((PrivateKeyEntry) entry).chain[0];
 518             }
 519 
 520         } else {
 521             return null;
 522         }
 523     }
 524 
 525     /**
 526      * Returns the creation date of the entry identified by the given alias.
 527      *
 528      * @param alias the alias name
 529      *
 530      * @return the creation date of this entry, or null if the given alias does
 531      * not exist
 532      */
 533     public Date engineGetCreationDate(String alias) {
 534         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 535         if (entry != null) {
 536             return new Date(entry.date.getTime());
 537         } else {
 538             return null;
 539         }
 540     }
 541 
 542     /**
 543      * Assigns the given key to the given alias, protecting it with the given
 544      * password.
 545      *
 546      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 547      * it must be accompanied by a certificate chain certifying the
 548      * corresponding public key.
 549      *
 550      * &lt;p&gt;If the given alias already exists, the keystore information
 551      * associated with it is overridden by the given key (and possibly
 552      * certificate chain).
 553      *
 554      * @param alias the alias name
 555      * @param key the key to be associated with the alias
 556      * @param password the password to protect the key
 557      * @param chain the certificate chain for the corresponding public
 558      * key (only required if the given key is of type
 559      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 560      *
 561      * @exception KeyStoreException if the given key cannot be protected, or
 562      * this operation fails for some other reason
 563      */
 564     public synchronized void engineSetKeyEntry(String alias, Key key,
 565                         char[] password, Certificate[] chain)
 566         throws KeyStoreException
 567     {
 568         KeyStore.PasswordProtection passwordProtection =
 569             new KeyStore.PasswordProtection(password);
 570 
 571         try {
 572             setKeyEntry(alias, key, passwordProtection, chain, null);
 573 
 574         } finally {
 575             try {
 576                 passwordProtection.destroy();
 577             } catch (DestroyFailedException dfe) {
 578                 // ignore
 579             }
 580         }
 581     }
 582 
 583     /*
 584      * Sets a key entry (with attributes, when present)
 585      */
 586     private void setKeyEntry(String alias, Key key,
 587         KeyStore.PasswordProtection passwordProtection, Certificate[] chain,
 588         Set&lt;KeyStore.Entry.Attribute&gt; attributes)
 589             throws KeyStoreException
 590     {
 591         try {
 592             Entry entry;
 593 
 594             if (key instanceof PrivateKey) {
 595                 // Check that all the certs are X.509 certs
 596                 checkX509Certs(chain);
 597 
 598                 PrivateKeyEntry keyEntry = new PrivateKeyEntry();
 599                 keyEntry.date = new Date();
 600 
 601                 if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||
 602                     (key.getFormat().equals(&quot;PKCS8&quot;))) {
 603 
 604                     if (debug != null) {
 605                         debug.println(
 606                             &quot;Setting a protected private key at alias &#39;&quot; +
 607                             alias + &quot;&#39;&quot;);
 608                         }
 609 
 610                     // Encrypt the private key
 611                     keyEntry.protectedPrivKey =
 612                         encryptPrivateKey(key.getEncoded(), passwordProtection);
 613                 } else {
 614                     throw new KeyStoreException(&quot;Private key is not encoded&quot; +
 615                                 &quot;as PKCS#8&quot;);
 616                 }
 617 
 618                 // clone the chain
 619                 if (chain != null) {
 620                     // validate cert-chain
 621                     if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain)))
 622                        throw new KeyStoreException(&quot;Certificate chain is &quot; +
 623                                                 &quot;not valid&quot;);
 624                     keyEntry.chain = chain.clone();
 625                     certificateCount += chain.length;
 626 
 627                     if (debug != null) {
 628                         debug.println(&quot;Setting a &quot; + chain.length +
 629                             &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 630                     }
 631                 }
 632                 privateKeyCount++;
 633                 entry = keyEntry;
 634 
 635             } else if (key instanceof SecretKey) {
 636                 SecretKeyEntry keyEntry = new SecretKeyEntry();
 637                 keyEntry.date = new Date();
 638 
 639                 // Encode secret key in a PKCS#8
 640                 DerOutputStream pkcs8 = new DerOutputStream();
 641                 DerOutputStream secretKeyInfo = new DerOutputStream();
 642                 secretKeyInfo.putInteger(0);
 643                 AlgorithmId algId = AlgorithmId.get(key.getAlgorithm());
 644                 algId.derEncode(secretKeyInfo);
 645                 secretKeyInfo.putOctetString(key.getEncoded());
 646                 pkcs8.write(DerValue.tag_Sequence, secretKeyInfo);
 647 
 648                 // Encrypt the secret key (using same PBE as for private keys)
 649                 keyEntry.protectedSecretKey =
 650                     encryptPrivateKey(pkcs8.toByteArray(), passwordProtection);
 651 
 652                 if (debug != null) {
 653                     debug.println(&quot;Setting a protected secret key at alias &#39;&quot; +
 654                         alias + &quot;&#39;&quot;);
 655                 }
 656                 secretKeyCount++;
 657                 entry = keyEntry;
 658 
 659             } else {
 660                 throw new KeyStoreException(&quot;Unsupported Key type&quot;);
 661             }
 662 
 663             entry.attributes = new HashSet&lt;&gt;();
 664             if (attributes != null) {
 665                 entry.attributes.addAll(attributes);
 666             }
 667             // set the keyId to current date
 668             entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(UTF_8);
 669             // set the alias
 670             entry.alias = alias.toLowerCase(Locale.ENGLISH);
 671             // add the entry
 672             entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 673 
 674         } catch (KeyStoreException kse) {
 675             throw kse;
 676         } catch (Exception nsae) {
 677             throw new KeyStoreException(&quot;Key protection&quot; +
 678                        &quot; algorithm not found: &quot; + nsae, nsae);
 679         }
 680     }
 681 
 682     /**
 683      * Assigns the given key (that has already been protected) to the given
 684      * alias.
 685      *
 686      * &lt;p&gt;If the protected key is of type
 687      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 688      * certificate chain certifying the corresponding public key. If the
 689      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 690      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 691      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 692      *
 693      * &lt;p&gt;If the given alias already exists, the keystore information
 694      * associated with it is overridden by the given key (and possibly
 695      * certificate chain).
 696      *
 697      * @param alias the alias name
 698      * @param key the key (in protected format) to be associated with the alias
 699      * @param chain the certificate chain for the corresponding public
 700      * key (only useful if the protected key is of type
 701      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 702      *
 703      * @exception KeyStoreException if this operation fails.
 704      */
 705     public synchronized void engineSetKeyEntry(String alias, byte[] key,
 706                                   Certificate[] chain)
 707         throws KeyStoreException
 708     {
 709         // Check that all the certs are X.509 certs
 710         checkX509Certs(chain);
 711 
 712         // Private key must be encoded as EncryptedPrivateKeyInfo
 713         // as defined in PKCS#8
 714         try {
 715             new EncryptedPrivateKeyInfo(key);
 716         } catch (IOException ioe) {
 717             throw new KeyStoreException(&quot;Private key is not stored&quot;
 718                     + &quot; as PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe, ioe);
 719         }
 720 
 721         PrivateKeyEntry entry = new PrivateKeyEntry();
 722         entry.date = new Date();
 723 
 724         if (debug != null) {
 725             debug.println(&quot;Setting a protected private key at alias &#39;&quot; +
 726                 alias + &quot;&#39;&quot;);
 727         }
 728 
 729         // set the keyId to current date
 730         entry.keyId = (&quot;Time &quot; + (entry.date).getTime()).getBytes(UTF_8);
 731         // set the alias
 732         entry.alias = alias.toLowerCase(Locale.ENGLISH);
 733 
 734         entry.protectedPrivKey = key.clone();
 735         if (chain != null) {
 736             // validate cert-chain
 737             if ((chain.length &gt; 1) &amp;&amp; (!validateChain(chain))) {
 738                 throw new KeyStoreException(&quot;Certificate chain is &quot;
 739                         + &quot;not valid&quot;);
 740             }
 741             entry.chain = chain.clone();
 742             certificateCount += chain.length;
 743 
 744             if (debug != null) {
 745                 debug.println(&quot;Setting a &quot; + entry.chain.length +
 746                     &quot;-certificate chain at alias &#39;&quot; + alias + &quot;&#39;&quot;);
 747             }
 748         }
 749 
 750         // add the entry
 751         privateKeyCount++;
 752         entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
 753     }
 754 
 755 
 756     /*
 757      * Generate random salt
 758      */
 759     private byte[] getSalt()
 760     {
 761         // Generate a random salt.
 762         byte[] salt = new byte[SALT_LEN];
 763         if (random == null) {
 764            random = new SecureRandom();
 765         }
 766         random.nextBytes(salt);
 767         return salt;
 768     }
 769 
 770     /*
 771      * Generate PBE Algorithm Parameters
 772      */
 773     private AlgorithmParameters getPBEAlgorithmParameters(
 774             String algorithm, int iterationCount) throws IOException {
 775         AlgorithmParameters algParams = null;
 776 
 777         // create PBE parameters from salt and iteration count
 778         PBEParameterSpec paramSpec =
 779                 new PBEParameterSpec(getSalt(), iterationCount);
 780         try {
 781            algParams = AlgorithmParameters.getInstance(algorithm);
 782            algParams.init(paramSpec);
 783         } catch (Exception e) {
 784            throw new IOException(&quot;getPBEAlgorithmParameters failed: &quot; +
 785                                  e.getMessage(), e);
 786         }
 787         return algParams;
 788     }
 789 
 790     /*
 791      * parse Algorithm Parameters
 792      */
 793     private AlgorithmParameters parseAlgParameters(ObjectIdentifier algorithm,
 794         DerInputStream in) throws IOException
 795     {
 796         AlgorithmParameters algParams = null;
 797         try {
 798             DerValue params;
 799             if (in.available() == 0) {
 800                 params = null;
 801             } else {
 802                 params = in.getDerValue();
 803                 if (params.tag == DerValue.tag_Null) {
 804                    params = null;
 805                 }
 806             }
 807             if (params != null) {
 808                 if (algorithm.equals(pbes2_OID)) {
 809                     algParams = AlgorithmParameters.getInstance(&quot;PBES2&quot;);
 810                 } else {
 811                     algParams = AlgorithmParameters.getInstance(&quot;PBE&quot;);
 812                 }
 813                 algParams.init(params.toByteArray());
 814             }
 815         } catch (Exception e) {
 816            throw new IOException(&quot;parseAlgParameters failed: &quot; +
 817                                  e.getMessage(), e);
 818         }
 819         return algParams;
 820     }
 821 
 822     /*
 823      * Generate PBE key
 824      */
 825     private SecretKey getPBEKey(char[] password) throws IOException
 826     {
 827         SecretKey skey = null;
 828 
 829         try {
 830             PBEKeySpec keySpec = new PBEKeySpec(password);
 831             SecretKeyFactory skFac = SecretKeyFactory.getInstance(&quot;PBE&quot;);
 832             skey = skFac.generateSecret(keySpec);
 833             keySpec.clearPassword();
 834         } catch (Exception e) {
 835            throw new IOException(&quot;getSecretKey failed: &quot; +
 836                                  e.getMessage(), e);
 837         }
 838         return skey;
 839     }
 840 
 841     /*
 842      * Encrypt private key or secret key using Password-based encryption (PBE)
 843      * as defined in PKCS#5.
 844      *
 845      * NOTE: By default, pbeWithSHAAnd3-KeyTripleDES-CBC algorithmID is
 846      *       used to derive the key and IV.
 847      *
 848      * @return encrypted private key or secret key encoded as
 849      *         EncryptedPrivateKeyInfo
 850      */
 851     private byte[] encryptPrivateKey(byte[] data,
 852         KeyStore.PasswordProtection passwordProtection)
 853         throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException
 854     {
 855         byte[] key = null;
 856 
 857         try {
 858             String algorithm;
 859             AlgorithmParameters algParams;
 860             AlgorithmId algid;
 861 
 862             // Initialize PBE algorithm and parameters
 863             algorithm = passwordProtection.getProtectionAlgorithm();
 864             if (algorithm != null) {
 865                 AlgorithmParameterSpec algParamSpec =
 866                     passwordProtection.getProtectionParameters();
 867                 if (algParamSpec != null) {
 868                     algParams = AlgorithmParameters.getInstance(algorithm);
 869                     algParams.init(algParamSpec);
 870                 } else {
 871                     algParams = getPBEAlgorithmParameters(algorithm,
 872                             defaultKeyPbeIterationCount());
 873                 }
 874             } else {
 875                 // Check default key protection algorithm for PKCS12 keystores
 876                 algorithm = defaultKeyProtectionAlgorithm();
 877                 algParams = getPBEAlgorithmParameters(algorithm,
 878                         defaultKeyPbeIterationCount());
 879             }
 880 
 881             ObjectIdentifier pbeOID = mapPBEAlgorithmToOID(algorithm);
 882             if (pbeOID == null) {
 883                     throw new IOException(&quot;PBE algorithm &#39;&quot; + algorithm +
 884                         &quot; &#39;is not supported for key entry protection&quot;);
 885             }
 886 
 887             // Use JCE
 888             SecretKey skey = getPBEKey(passwordProtection.getPassword());
 889             Cipher cipher = Cipher.getInstance(algorithm);
 890             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
 891             byte[] encryptedKey = cipher.doFinal(data);
 892             algid = new AlgorithmId(pbeOID, cipher.getParameters());
 893 
 894             if (debug != null) {
 895                 debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +
 896                     &quot;)&quot;);
 897             }
 898 
 899             // wrap encrypted private key in EncryptedPrivateKeyInfo
 900             // as defined in PKCS#8
 901             EncryptedPrivateKeyInfo encrInfo =
 902                 new EncryptedPrivateKeyInfo(algid, encryptedKey);
 903             key = encrInfo.getEncoded();
 904         } catch (Exception e) {
 905             UnrecoverableKeyException uke =
 906                 new UnrecoverableKeyException(&quot;Encrypt Private Key failed: &quot;
 907                                                 + e.getMessage());
 908             uke.initCause(e);
 909             throw uke;
 910         }
 911 
 912         return key;
 913     }
 914 
 915     /*
 916      * Map a PBE algorithm name onto its object identifier
 917      */
 918     private static ObjectIdentifier mapPBEAlgorithmToOID(String algorithm)
 919         throws NoSuchAlgorithmException {
 920         // Check for PBES2 algorithms
 921         if (algorithm.toLowerCase(Locale.ENGLISH).startsWith(&quot;pbewithhmacsha&quot;)) {
 922             return pbes2_OID;
 923         }
 924         return AlgorithmId.get(algorithm).getOID();
 925     }
 926 
 927     /*
 928      * Map a PBE algorithm parameters onto its algorithm name
 929      */
 930     private static String mapPBEParamsToAlgorithm(ObjectIdentifier algorithm,
 931         AlgorithmParameters algParams) throws NoSuchAlgorithmException {
 932         // Check for PBES2 algorithms
 933         if (algorithm.equals(pbes2_OID) &amp;&amp; algParams != null) {
 934             return algParams.toString();
 935         }
 936         return new AlgorithmId(algorithm).getName();
 937     }
 938 
 939     /**
 940      * Assigns the given certificate to the given alias.
 941      *
 942      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
 943      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
 944      * overridden by the given certificate.
 945      *
 946      * @param alias the alias name
 947      * @param cert the certificate
 948      *
 949      * @exception KeyStoreException if the given alias already exists and does
 950      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation fails
 951      * for some other reason.
 952      */
 953     public synchronized void engineSetCertificateEntry(String alias,
 954         Certificate cert) throws KeyStoreException
 955     {
 956         setCertEntry(alias, cert, null);
 957     }
 958 
 959     /*
 960      * Sets a trusted cert entry (with attributes, when present)
 961      */
 962     private void setCertEntry(String alias, Certificate cert,
 963         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws KeyStoreException {
 964 
 965         // Check that the cert is an X.509 cert
 966         if (cert != null &amp;&amp; (!(cert instanceof X509Certificate))) {
 967             throw new KeyStoreException(
 968                 &quot;Only X.509 certificates are supported - rejecting class: &quot; +
 969                 cert.getClass().getName());
 970         }
 971 
 972         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
 973         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
 974             throw new KeyStoreException(&quot;Cannot overwrite own certificate&quot;);
 975         }
 976 
 977         CertEntry certEntry =
 978             new CertEntry((X509Certificate) cert, null, alias, AnyUsage,
 979                 attributes);
 980         certificateCount++;
 981         entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
 982 
 983         if (debug != null) {
 984             debug.println(&quot;Setting a trusted certificate at alias &#39;&quot; + alias +
 985                 &quot;&#39;&quot;);
 986         }
 987     }
 988 
 989     /**
 990      * Deletes the entry identified by the given alias from this keystore.
 991      *
 992      * @param alias the alias name
 993      *
 994      * @exception KeyStoreException if the entry cannot be removed.
 995      */
 996     public synchronized void engineDeleteEntry(String alias)
 997         throws KeyStoreException
 998     {
 999         if (debug != null) {
1000             debug.println(&quot;Removing entry at alias &#39;&quot; + alias + &quot;&#39;&quot;);
1001         }
1002 
1003         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1004         if (entry instanceof PrivateKeyEntry) {
1005             PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;
1006             if (keyEntry.chain != null) {
1007                 certificateCount -= keyEntry.chain.length;
1008             }
1009             privateKeyCount--;
1010         } else if (entry instanceof CertEntry) {
1011             certificateCount--;
1012         } else if (entry instanceof SecretKeyEntry) {
1013             secretKeyCount--;
1014         }
1015         entries.remove(alias.toLowerCase(Locale.ENGLISH));
1016     }
1017 
1018     /**
1019      * Lists all the alias names of this keystore.
1020      *
1021      * @return enumeration of the alias names
1022      */
1023     public Enumeration&lt;String&gt; engineAliases() {
1024         return Collections.enumeration(entries.keySet());
1025     }
1026 
1027     /**
1028      * Checks if the given alias exists in this keystore.
1029      *
1030      * @param alias the alias name
1031      *
1032      * @return true if the alias exists, false otherwise
1033      */
1034     public boolean engineContainsAlias(String alias) {
1035         return entries.containsKey(alias.toLowerCase(Locale.ENGLISH));
1036     }
1037 
1038     /**
1039      * Retrieves the number of entries in this keystore.
1040      *
1041      * @return the number of entries in this keystore
1042      */
1043     public int engineSize() {
1044         return entries.size();
1045     }
1046 
1047     /**
1048      * Returns true if the entry identified by the given alias is a
1049      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
1050      *
1051      * @return true if the entry identified by the given alias is a
1052      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
1053      */
1054     public boolean engineIsKeyEntry(String alias) {
1055         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1056         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
1057             return true;
1058         } else {
1059             return false;
1060         }
1061     }
1062 
1063     /**
1064      * Returns true if the entry identified by the given alias is a
1065      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
1066      *
1067      * @return true if the entry identified by the given alias is a
1068      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
1069      */
1070     public boolean engineIsCertificateEntry(String alias) {
1071         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1072         if (entry != null &amp;&amp; entry instanceof CertEntry &amp;&amp;
1073             ((CertEntry) entry).trustedKeyUsage != null) {
1074             return true;
1075         } else {
1076             return false;
1077         }
1078     }
1079 
1080     /**
1081      * Determines if the keystore {@code Entry} for the specified
1082      * {@code alias} is an instance or subclass of the specified
1083      * {@code entryClass}.
1084      *
1085      * @param alias the alias name
1086      * @param entryClass the entry class
1087      *
1088      * @return true if the keystore {@code Entry} for the specified
1089      *          {@code alias} is an instance or subclass of the
1090      *          specified {@code entryClass}, false otherwise
1091      *
1092      * @since 1.5
1093      */
1094     @Override
1095     public boolean
1096         engineEntryInstanceOf(String alias,
1097                               Class&lt;? extends KeyStore.Entry&gt; entryClass)
1098     {
1099         if (entryClass == KeyStore.TrustedCertificateEntry.class) {
1100             return engineIsCertificateEntry(alias);
1101         }
1102 
1103         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1104         if (entryClass == KeyStore.PrivateKeyEntry.class) {
1105             return (entry != null &amp;&amp; entry instanceof PrivateKeyEntry);
1106         }
1107         if (entryClass == KeyStore.SecretKeyEntry.class) {
1108             return (entry != null &amp;&amp; entry instanceof SecretKeyEntry);
1109         }
1110         return false;
1111     }
1112 
1113     /**
1114      * Returns the (alias) name of the first keystore entry whose certificate
1115      * matches the given certificate.
1116      *
1117      * &lt;p&gt;This method attempts to match the given certificate with each
1118      * keystore entry. If the entry being considered
1119      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
1120      * compared to that entry&#39;s certificate. If the entry being considered is
1121      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
1122      * element of that entry&#39;s certificate chain (if a chain exists).
1123      *
1124      * @param cert the certificate to match with.
1125      *
1126      * @return the (alias) name of the first entry with matching certificate,
1127      * or null if no such entry exists in this keystore.
1128      */
1129     public String engineGetCertificateAlias(Certificate cert) {
1130         Certificate certElem = null;
1131 
1132         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1133             String alias = e.nextElement();
1134             Entry entry = entries.get(alias);
1135             if (entry instanceof PrivateKeyEntry) {
1136                 if (((PrivateKeyEntry) entry).chain != null) {
1137                     certElem = ((PrivateKeyEntry) entry).chain[0];
1138                 }
1139             } else if (entry instanceof CertEntry &amp;&amp;
1140                     ((CertEntry) entry).trustedKeyUsage != null) {
1141                 certElem = ((CertEntry) entry).cert;
1142             } else {
1143                 continue;
1144             }
1145             if (certElem != null &amp;&amp; certElem.equals(cert)) {
1146                 return alias;
1147             }
1148         }
1149         return null;
1150     }
1151 
1152     /**
1153      * Stores this keystore to the given output stream, and protects its
1154      * integrity with the given password.
1155      *
1156      * @param stream the output stream to which this keystore is written.
1157      * @param password the password to generate the keystore integrity check
1158      *
1159      * @exception IOException if there was an I/O problem with data
1160      * @exception NoSuchAlgorithmException if the appropriate data integrity
1161      * algorithm could not be found
1162      * @exception CertificateException if any of the certificates included in
1163      * the keystore data could not be stored
1164      */
1165     public synchronized void engineStore(OutputStream stream, char[] password)
1166         throws IOException, NoSuchAlgorithmException, CertificateException
1167     {
1168 
1169         // -- Create PFX
1170         DerOutputStream pfx = new DerOutputStream();
1171 
1172         // PFX version (always write the latest version)
1173         DerOutputStream version = new DerOutputStream();
1174         version.putInteger(VERSION_3);
1175         byte[] pfxVersion = version.toByteArray();
1176         pfx.write(pfxVersion);
1177 
1178         // -- Create AuthSafe
1179         DerOutputStream authSafe = new DerOutputStream();
1180 
1181         // -- Create ContentInfos
1182         DerOutputStream authSafeContentInfo = new DerOutputStream();
1183 
1184         // -- create safeContent Data ContentInfo
1185         if (privateKeyCount &gt; 0 || secretKeyCount &gt; 0) {
1186 
1187             if (debug != null) {
1188                 debug.println(&quot;Storing &quot; + (privateKeyCount + secretKeyCount) +
1189                     &quot; protected key(s) in a PKCS#7 data&quot;);
1190             }
1191 
1192             byte[] safeContentData = createSafeContent();
1193             ContentInfo dataContentInfo = new ContentInfo(safeContentData);
1194             dataContentInfo.encode(authSafeContentInfo);
1195         }
1196 
1197         // -- create EncryptedContentInfo
1198         if (certificateCount &gt; 0) {
1199 
1200             if (certProtectionAlgorithm == null) {
1201                 certProtectionAlgorithm = defaultCertProtectionAlgorithm();
1202             }
1203             if (certPbeIterationCount &lt; 0) {
1204                 certPbeIterationCount = defaultCertPbeIterationCount();
1205             }
1206 
1207             if (debug != null) {
1208                 debug.println(&quot;Storing &quot; + certificateCount +
1209                     &quot; certificate(s) in a PKCS#7 encryptedData&quot;);
1210             }
1211 
1212             byte[] encrData = createEncryptedData(password);
1213             if (!certProtectionAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1214                 ContentInfo encrContentInfo =
1215                         new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,
1216                                 new DerValue(encrData));
1217                 encrContentInfo.encode(authSafeContentInfo);
1218             } else {
1219                 ContentInfo dataContentInfo = new ContentInfo(encrData);
1220                 dataContentInfo.encode(authSafeContentInfo);
1221             }
1222         }
1223 
1224         // wrap as SequenceOf ContentInfos
1225         DerOutputStream cInfo = new DerOutputStream();
1226         cInfo.write(DerValue.tag_SequenceOf, authSafeContentInfo);
1227         byte[] authenticatedSafe = cInfo.toByteArray();
1228 
1229         // Create Encapsulated ContentInfo
1230         ContentInfo contentInfo = new ContentInfo(authenticatedSafe);
1231         contentInfo.encode(authSafe);
1232         byte[] authSafeData = authSafe.toByteArray();
1233         pfx.write(authSafeData);
1234 
1235         // -- MAC
1236         if (macAlgorithm == null) {
1237             macAlgorithm = defaultMacAlgorithm();
1238         }
1239         if (macIterationCount &lt; 0) {
1240             macIterationCount = defaultMacIterationCount();
1241         }
1242         if (!macAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1243             byte[] macData = calculateMac(password, authenticatedSafe);
1244             pfx.write(macData);
1245         }
1246         // write PFX to output stream
1247         DerOutputStream pfxout = new DerOutputStream();
1248         pfxout.write(DerValue.tag_Sequence, pfx);
1249         byte[] pfxData = pfxout.toByteArray();
1250         stream.write(pfxData);
1251         stream.flush();
1252     }
1253 
1254     /**
1255      * Gets a &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias
1256      * with the specified protection parameter.
1257      *
1258      * @param alias get the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for this alias
1259      * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
1260      *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
1261      *          which may be &lt;code&gt;null&lt;/code&gt;
1262      *
1263      * @return the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias,
1264      *          or &lt;code&gt;null&lt;/code&gt; if there is no such entry
1265      *
1266      * @exception KeyStoreException if the operation failed
1267      * @exception NoSuchAlgorithmException if the algorithm for recovering the
1268      *          entry cannot be found
1269      * @exception UnrecoverableEntryException if the specified
1270      *          &lt;code&gt;protParam&lt;/code&gt; were insufficient or invalid
1271      * @exception UnrecoverableKeyException if the entry is a
1272      *          &lt;code&gt;PrivateKeyEntry&lt;/code&gt; or &lt;code&gt;SecretKeyEntry&lt;/code&gt;
1273      *          and the specified &lt;code&gt;protParam&lt;/code&gt; does not contain
1274      *          the information needed to recover the key (e.g. wrong password)
1275      *
1276      * @since 1.5
1277      */
1278     @Override
1279     public KeyStore.Entry engineGetEntry(String alias,
1280                         KeyStore.ProtectionParameter protParam)
1281                 throws KeyStoreException, NoSuchAlgorithmException,
1282                 UnrecoverableEntryException {
1283 
1284         if (!engineContainsAlias(alias)) {
1285             return null;
1286         }
1287 
1288         Entry entry = entries.get(alias.toLowerCase(Locale.ENGLISH));
1289         if (protParam == null) {
1290             if (engineIsCertificateEntry(alias)) {
1291                 if (entry instanceof CertEntry &amp;&amp;
1292                     ((CertEntry) entry).trustedKeyUsage != null) {
1293 
1294                     if (debug != null) {
1295                         debug.println(&quot;Retrieved a trusted certificate at &quot; +
1296                             &quot;alias &#39;&quot; + alias + &quot;&#39;&quot;);
1297                     }
1298 
1299                     return new KeyStore.TrustedCertificateEntry(
1300                         ((CertEntry)entry).cert, getAttributes(entry));
1301                 }
1302             } else {
1303                 throw new UnrecoverableKeyException
1304                         (&quot;requested entry requires a password&quot;);
1305             }
1306         }
1307 
1308         if (protParam instanceof KeyStore.PasswordProtection) {
1309             if (engineIsCertificateEntry(alias)) {
1310                 throw new UnsupportedOperationException
1311                     (&quot;trusted certificate entries are not password-protected&quot;);
1312             } else if (engineIsKeyEntry(alias)) {
1313                 KeyStore.PasswordProtection pp =
1314                         (KeyStore.PasswordProtection)protParam;
1315                 char[] password = pp.getPassword();
1316 
1317                 Key key = engineGetKey(alias, password);
1318                 if (key instanceof PrivateKey) {
1319                     Certificate[] chain = engineGetCertificateChain(alias);
1320 
1321                     return new KeyStore.PrivateKeyEntry((PrivateKey)key, chain,
1322                         getAttributes(entry));
1323 
1324                 } else if (key instanceof SecretKey) {
1325 
1326                     return new KeyStore.SecretKeyEntry((SecretKey)key,
1327                         getAttributes(entry));
1328                 }
1329             } else if (!engineIsKeyEntry(alias)) {
1330                 throw new UnsupportedOperationException
1331                     (&quot;untrusted certificate entries are not &quot; +
1332                         &quot;password-protected&quot;);
1333             }
1334         }
1335 
1336         throw new UnsupportedOperationException();
1337     }
1338 
1339     /**
1340      * Saves a &lt;code&gt;KeyStore.Entry&lt;/code&gt; under the specified alias.
1341      * The specified protection parameter is used to protect the
1342      * &lt;code&gt;Entry&lt;/code&gt;.
1343      *
1344      * &lt;p&gt; If an entry already exists for the specified alias,
1345      * it is overridden.
1346      *
1347      * @param alias save the &lt;code&gt;KeyStore.Entry&lt;/code&gt; under this alias
1348      * @param entry the &lt;code&gt;Entry&lt;/code&gt; to save
1349      * @param protParam the &lt;code&gt;ProtectionParameter&lt;/code&gt;
1350      *          used to protect the &lt;code&gt;Entry&lt;/code&gt;,
1351      *          which may be &lt;code&gt;null&lt;/code&gt;
1352      *
1353      * @exception KeyStoreException if this operation fails
1354      *
1355      * @since 1.5
1356      */
1357     @Override
1358     public synchronized void engineSetEntry(String alias, KeyStore.Entry entry,
1359         KeyStore.ProtectionParameter protParam) throws KeyStoreException {
1360 
1361         // get password
1362         if (protParam != null &amp;&amp;
1363             !(protParam instanceof KeyStore.PasswordProtection)) {
1364             throw new KeyStoreException(&quot;unsupported protection parameter&quot;);
1365         }
1366         KeyStore.PasswordProtection pProtect = null;
1367         if (protParam != null) {
1368             pProtect = (KeyStore.PasswordProtection)protParam;
1369         }
1370 
1371         // set entry
1372         if (entry instanceof KeyStore.TrustedCertificateEntry) {
1373             if (protParam != null &amp;&amp; pProtect.getPassword() != null) {
1374                 // pre-1.5 style setCertificateEntry did not allow password
1375                 throw new KeyStoreException
1376                     (&quot;trusted certificate entries are not password-protected&quot;);
1377             } else {
1378                 KeyStore.TrustedCertificateEntry tce =
1379                         (KeyStore.TrustedCertificateEntry)entry;
1380                 setCertEntry(alias, tce.getTrustedCertificate(),
1381                     tce.getAttributes());
1382 
1383                 return;
1384             }
1385         } else if (entry instanceof KeyStore.PrivateKeyEntry) {
1386             if (pProtect == null || pProtect.getPassword() == null) {
1387                 // pre-1.5 style setKeyEntry required password
1388                 throw new KeyStoreException
1389                     (&quot;non-null password required to create PrivateKeyEntry&quot;);
1390             } else {
1391                 KeyStore.PrivateKeyEntry pke = (KeyStore.PrivateKeyEntry)entry;
1392                 setKeyEntry(alias, pke.getPrivateKey(), pProtect,
1393                     pke.getCertificateChain(), pke.getAttributes());
1394 
1395                 return;
1396             }
1397         } else if (entry instanceof KeyStore.SecretKeyEntry) {
1398             if (pProtect == null || pProtect.getPassword() == null) {
1399                 // pre-1.5 style setKeyEntry required password
1400                 throw new KeyStoreException
1401                     (&quot;non-null password required to create SecretKeyEntry&quot;);
1402             } else {
1403                 KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;
1404                 setKeyEntry(alias, ske.getSecretKey(), pProtect,
1405                     (Certificate[])null, ske.getAttributes());
1406 
1407                 return;
1408             }
1409         }
1410 
1411         throw new KeyStoreException
1412                 (&quot;unsupported entry type: &quot; + entry.getClass().getName());
1413     }
1414 
1415     /*
1416      * Assemble the entry attributes
1417      */
1418     private Set&lt;KeyStore.Entry.Attribute&gt; getAttributes(Entry entry) {
1419 
1420         if (entry.attributes == null) {
1421             entry.attributes = new HashSet&lt;&gt;();
1422         }
1423 
1424         // friendlyName
1425         entry.attributes.add(new PKCS12Attribute(
1426             PKCS9FriendlyName_OID.toString(), entry.alias));
1427 
1428         // localKeyID
1429         byte[] keyIdValue = entry.keyId;
1430         if (keyIdValue != null) {
1431             entry.attributes.add(new PKCS12Attribute(
1432                 PKCS9LocalKeyId_OID.toString(), Debug.toString(keyIdValue)));
1433         }
1434 
1435         // trustedKeyUsage
1436         if (entry instanceof CertEntry) {
1437             ObjectIdentifier[] trustedKeyUsageValue =
1438                 ((CertEntry) entry).trustedKeyUsage;
1439             if (trustedKeyUsageValue != null) {
1440                 if (trustedKeyUsageValue.length == 1) { // omit brackets
1441                     entry.attributes.add(new PKCS12Attribute(
1442                         TrustedKeyUsage_OID.toString(),
1443                         trustedKeyUsageValue[0].toString()));
1444                 } else { // multi-valued
1445                     entry.attributes.add(new PKCS12Attribute(
1446                         TrustedKeyUsage_OID.toString(),
1447                         Arrays.toString(trustedKeyUsageValue)));
1448                 }
1449             }
1450         }
1451 
1452         return entry.attributes;
1453     }
1454 
1455     /*
1456      * Calculate MAC using HMAC algorithm (required for password integrity)
1457      *
1458      * Hash-based MAC algorithm combines secret key with message digest to
1459      * create a message authentication code (MAC)
1460      */
1461     private byte[] calculateMac(char[] passwd, byte[] data)
1462         throws IOException
1463     {
1464         byte[] mData = null;
1465         String algName = macAlgorithm.substring(7);
1466 
1467         try {
1468             // Generate a random salt.
1469             byte[] salt = getSalt();
1470 
1471             // generate MAC (MAC key is generated within JCE)
1472             Mac m = Mac.getInstance(macAlgorithm);
1473             PBEParameterSpec params =
1474                         new PBEParameterSpec(salt, macIterationCount);
1475             SecretKey key = getPBEKey(passwd);
1476             m.init(key, params);
1477             m.update(data);
1478             byte[] macResult = m.doFinal();
1479 
1480             // encode as MacData
1481             MacData macData = new MacData(algName, macResult, salt,
1482                     macIterationCount);
1483             DerOutputStream bytes = new DerOutputStream();
1484             bytes.write(macData.getEncoded());
1485             mData = bytes.toByteArray();
1486         } catch (Exception e) {
1487             throw new IOException(&quot;calculateMac failed: &quot; + e, e);
1488         }
1489         return mData;
1490     }
1491 
1492 
1493     /*
1494      * Validate Certificate Chain
1495      */
1496     private boolean validateChain(Certificate[] certChain)
1497     {
1498         for (int i = 0; i &lt; certChain.length-1; i++) {
1499             X500Principal issuerDN =
1500                 ((X509Certificate)certChain[i]).getIssuerX500Principal();
1501             X500Principal subjectDN =
1502                 ((X509Certificate)certChain[i+1]).getSubjectX500Principal();
1503             if (!(issuerDN.equals(subjectDN)))
1504                 return false;
1505         }
1506 
1507         // Check for loops in the chain. If there are repeated certs,
1508         // the Set of certs in the chain will contain fewer certs than
1509         // the chain
1510         Set&lt;Certificate&gt; set = new HashSet&lt;&gt;(Arrays.asList(certChain));
1511         return set.size() == certChain.length;
1512     }
1513 
1514     /*
1515      * Check that all the certificates are X.509 certificates
1516      */
1517     private static void checkX509Certs(Certificate[] certs)
1518             throws KeyStoreException {
1519         if (certs != null) {
1520             for (Certificate cert : certs) {
1521                 if (!(cert instanceof X509Certificate)) {
1522                     throw new KeyStoreException(
1523                         &quot;Only X.509 certificates are supported - &quot; +
1524                         &quot;rejecting class: &quot; + cert.getClass().getName());
1525                 }
1526             }
1527         }
1528     }
1529 
1530     /*
1531      * Create PKCS#12 Attributes, friendlyName, localKeyId and trustedKeyUsage.
1532      *
1533      * Although attributes are optional, they could be required.
1534      * For e.g. localKeyId attribute is required to match the
1535      * private key with the associated end-entity certificate.
1536      * The trustedKeyUsage attribute is used to denote a trusted certificate.
1537      *
1538      * PKCS8ShroudedKeyBags include unique localKeyID and friendlyName.
1539      * CertBags may or may not include attributes depending on the type
1540      * of Certificate. In end-entity certificates, localKeyID should be
1541      * unique, and the corresponding private key should have the same
1542      * localKeyID. For trusted CA certs in the cert-chain, localKeyID
1543      * attribute is not required, hence most vendors don&#39;t include it.
1544      * NSS/Netscape require it to be unique or null, where as IE/OpenSSL
1545      * ignore it.
1546      *
1547      * Here is a list of pkcs12 attribute values in CertBags.
1548      *
1549      * PKCS12 Attribute       NSS/Netscape    IE     OpenSSL    J2SE
1550      * --------------------------------------------------------------
1551      * LocalKeyId
1552      * (In EE cert only,
1553      *  NULL in CA certs)      true          true     true      true
1554      *
1555      * friendlyName            unique        same/    same/     unique
1556      *                                       unique   unique/
1557      *                                                null
1558      * trustedKeyUsage         -             -        -         true
1559      *
1560      * Note: OpenSSL adds friendlyName for end-entity cert only, and
1561      * removes the localKeyID and friendlyName for CA certs.
1562      * If the CertBag did not have a friendlyName, most vendors will
1563      * add it, and assign it to the DN of the cert.
1564      */
1565     private byte[] getBagAttributes(String alias, byte[] keyId,
1566         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
1567         return getBagAttributes(alias, keyId, null, attributes);
1568     }
1569 
1570     private byte[] getBagAttributes(String alias, byte[] keyId,
1571         ObjectIdentifier[] trustedUsage,
1572         Set&lt;KeyStore.Entry.Attribute&gt; attributes) throws IOException {
1573 
1574         byte[] localKeyID = null;
1575         byte[] friendlyName = null;
1576         byte[] trustedKeyUsage = null;
1577 
1578         // return null if all three attributes are null
1579         if ((alias == null) &amp;&amp; (keyId == null) &amp;&amp; (trustedKeyUsage == null)) {
1580             return null;
1581         }
1582 
1583         // SafeBag Attributes
1584         DerOutputStream bagAttrs = new DerOutputStream();
1585 
1586         // Encode the friendlyname oid.
1587         if (alias != null) {
1588             DerOutputStream bagAttr1 = new DerOutputStream();
1589             bagAttr1.putOID(PKCS9FriendlyName_OID);
1590             DerOutputStream bagAttrContent1 = new DerOutputStream();
1591             DerOutputStream bagAttrValue1 = new DerOutputStream();
1592             bagAttrContent1.putBMPString(alias);
1593             bagAttr1.write(DerValue.tag_Set, bagAttrContent1);
1594             bagAttrValue1.write(DerValue.tag_Sequence, bagAttr1);
1595             friendlyName = bagAttrValue1.toByteArray();
1596         }
1597 
1598         // Encode the localkeyId oid.
1599         if (keyId != null) {
1600             DerOutputStream bagAttr2 = new DerOutputStream();
1601             bagAttr2.putOID(PKCS9LocalKeyId_OID);
1602             DerOutputStream bagAttrContent2 = new DerOutputStream();
1603             DerOutputStream bagAttrValue2 = new DerOutputStream();
1604             bagAttrContent2.putOctetString(keyId);
1605             bagAttr2.write(DerValue.tag_Set, bagAttrContent2);
1606             bagAttrValue2.write(DerValue.tag_Sequence, bagAttr2);
1607             localKeyID = bagAttrValue2.toByteArray();
1608         }
1609 
1610         // Encode the trustedKeyUsage oid.
1611         if (trustedUsage != null) {
1612             DerOutputStream bagAttr3 = new DerOutputStream();
1613             bagAttr3.putOID(TrustedKeyUsage_OID);
1614             DerOutputStream bagAttrContent3 = new DerOutputStream();
1615             DerOutputStream bagAttrValue3 = new DerOutputStream();
1616             for (ObjectIdentifier usage : trustedUsage) {
1617                 bagAttrContent3.putOID(usage);
1618             }
1619             bagAttr3.write(DerValue.tag_Set, bagAttrContent3);
1620             bagAttrValue3.write(DerValue.tag_Sequence, bagAttr3);
1621             trustedKeyUsage = bagAttrValue3.toByteArray();
1622         }
1623 
1624         DerOutputStream attrs = new DerOutputStream();
1625         if (friendlyName != null) {
1626             attrs.write(friendlyName);
1627         }
1628         if (localKeyID != null) {
1629             attrs.write(localKeyID);
1630         }
1631         if (trustedKeyUsage != null) {
1632             attrs.write(trustedKeyUsage);
1633         }
1634 
1635         if (attributes != null) {
1636             for (KeyStore.Entry.Attribute attribute : attributes) {
1637                 String attributeName = attribute.getName();
1638                 // skip friendlyName, localKeyId and trustedKeyUsage
1639                 if (CORE_ATTRIBUTES[0].value().equals(attributeName) ||
1640                     CORE_ATTRIBUTES[1].value().equals(attributeName) ||
1641                     CORE_ATTRIBUTES[2].value().equals(attributeName)) {
1642                     continue;
1643                 }
1644                 attrs.write(((PKCS12Attribute) attribute).getEncoded());
1645             }
1646         }
1647 
1648         bagAttrs.write(DerValue.tag_Set, attrs);
1649         return bagAttrs.toByteArray();
1650     }
1651 
1652     /*
1653      * Create EncryptedData content type, that contains EncryptedContentInfo.
1654      * Includes certificates in individual SafeBags of type CertBag.
1655      * Each CertBag may include pkcs12 attributes
1656      * (see comments in getBagAttributes)
1657      */
1658     private byte[] createEncryptedData(char[] password)
1659         throws CertificateException, IOException
1660     {
1661         DerOutputStream out = new DerOutputStream();
1662         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1663 
1664             String alias = e.nextElement();
1665             Entry entry = entries.get(alias);
1666 
1667             // certificate chain
1668             Certificate[] certs;
1669 
1670             if (entry instanceof PrivateKeyEntry) {
1671                 PrivateKeyEntry keyEntry = (PrivateKeyEntry) entry;
1672                 if (keyEntry.chain != null) {
1673                     certs = keyEntry.chain;
1674                 } else {
1675                     certs = new Certificate[0];
1676                 }
1677             } else if (entry instanceof CertEntry) {
1678                 certs = new Certificate[]{((CertEntry) entry).cert};
1679             } else {
1680                 certs = new Certificate[0];
1681             }
1682 
1683             for (int i = 0; i &lt; certs.length; i++) {
1684                 // create SafeBag of Type CertBag
1685                 DerOutputStream safeBag = new DerOutputStream();
1686                 safeBag.putOID(CertBag_OID);
1687 
1688                 // create a CertBag
1689                 DerOutputStream certBag = new DerOutputStream();
1690                 certBag.putOID(PKCS9CertType_OID);
1691 
1692                 // write encoded certs in a context-specific tag
1693                 DerOutputStream certValue = new DerOutputStream();
1694                 X509Certificate cert = (X509Certificate) certs[i];
1695                 certValue.putOctetString(cert.getEncoded());
1696                 certBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1697                                         true, (byte) 0), certValue);
1698 
1699                 // wrap CertBag in a Sequence
1700                 DerOutputStream certout = new DerOutputStream();
1701                 certout.write(DerValue.tag_Sequence, certBag);
1702                 byte[] certBagValue = certout.toByteArray();
1703 
1704                 // Wrap the CertBag encoding in a context-specific tag.
1705                 DerOutputStream bagValue = new DerOutputStream();
1706                 bagValue.write(certBagValue);
1707                 // write SafeBag Value
1708                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1709                                 true, (byte) 0), bagValue);
1710 
1711                 // write SafeBag Attributes
1712                 // All Certs should have a unique friendlyName.
1713                 // This change is made to meet NSS requirements.
1714                 byte[] bagAttrs = null;
1715                 if (i == 0) {
1716                     // Only End-Entity Cert should have a localKeyId.
1717                     if (entry instanceof KeyEntry) {
1718                         KeyEntry keyEntry = (KeyEntry) entry;
1719                         bagAttrs =
1720                             getBagAttributes(keyEntry.alias, keyEntry.keyId,
1721                                 keyEntry.attributes);
1722                     } else {
1723                         CertEntry certEntry = (CertEntry) entry;
1724                         bagAttrs =
1725                             getBagAttributes(certEntry.alias, certEntry.keyId,
1726                                 certEntry.trustedKeyUsage,
1727                                 certEntry.attributes);
1728                     }
1729                 } else {
1730                     // Trusted root CA certs and Intermediate CA certs do not
1731                     // need to have a localKeyId, and hence localKeyId is null
1732                     // This change is made to meet NSS/Netscape requirements.
1733                     // NSS pkcs12 library requires trusted CA certs in the
1734                     // certificate chain to have unique or null localKeyID.
1735                     // However, IE/OpenSSL do not impose this restriction.
1736                     bagAttrs = getBagAttributes(
1737                             cert.getSubjectX500Principal().getName(), null,
1738                             entry.attributes);
1739                 }
1740                 if (bagAttrs != null) {
1741                     safeBag.write(bagAttrs);
1742                 }
1743 
1744                 // wrap as Sequence
1745                 out.write(DerValue.tag_Sequence, safeBag);
1746             } // for cert-chain
1747         }
1748 
1749         // wrap as SequenceOf SafeBag
1750         DerOutputStream safeBagValue = new DerOutputStream();
1751         safeBagValue.write(DerValue.tag_SequenceOf, out);
1752         byte[] safeBagData = safeBagValue.toByteArray();
1753 
1754         // encrypt the content (EncryptedContentInfo)
1755         if (!certProtectionAlgorithm.equalsIgnoreCase(&quot;NONE&quot;)) {
1756             byte[] encrContentInfo = encryptContent(safeBagData, password);
1757 
1758             // -- SEQUENCE of EncryptedData
1759             DerOutputStream encrData = new DerOutputStream();
1760             DerOutputStream encrDataContent = new DerOutputStream();
1761             encrData.putInteger(0);
1762             encrData.write(encrContentInfo);
1763             encrDataContent.write(DerValue.tag_Sequence, encrData);
1764             return encrDataContent.toByteArray();
1765         } else {
1766             return safeBagData;
1767         }
1768     }
1769 
1770     /*
1771      * Create SafeContent Data content type.
1772      * Includes encrypted secret key in a SafeBag of type SecretBag.
1773      * Includes encrypted private key in a SafeBag of type PKCS8ShroudedKeyBag.
1774      * Each PKCS8ShroudedKeyBag includes pkcs12 attributes
1775      * (see comments in getBagAttributes)
1776      */
1777     private byte[] createSafeContent()
1778         throws CertificateException, IOException {
1779 
1780         DerOutputStream out = new DerOutputStream();
1781         for (Enumeration&lt;String&gt; e = engineAliases(); e.hasMoreElements(); ) {
1782 
1783             String alias = e.nextElement();
1784             Entry entry = entries.get(alias);
1785             if (entry == null || (!(entry instanceof KeyEntry))) {
1786                 continue;
1787             }
1788             DerOutputStream safeBag = new DerOutputStream();
1789             KeyEntry keyEntry = (KeyEntry) entry;
1790 
1791             // DER encode the private key
1792             if (keyEntry instanceof PrivateKeyEntry) {
1793                 // Create SafeBag of type pkcs8ShroudedKeyBag
1794                 safeBag.putOID(PKCS8ShroudedKeyBag_OID);
1795 
1796                 // get the encrypted private key
1797                 byte[] encrBytes = ((PrivateKeyEntry)keyEntry).protectedPrivKey;
1798                 EncryptedPrivateKeyInfo encrInfo = null;
1799                 try {
1800                     encrInfo = new EncryptedPrivateKeyInfo(encrBytes);
1801 
1802                 } catch (IOException ioe) {
1803                     throw new IOException(&quot;Private key not stored as &quot;
1804                             + &quot;PKCS#8 EncryptedPrivateKeyInfo&quot;
1805                             + ioe.getMessage());
1806                 }
1807 
1808                 // Wrap the EncryptedPrivateKeyInfo in a context-specific tag.
1809                 DerOutputStream bagValue = new DerOutputStream();
1810                 bagValue.write(encrInfo.getEncoded());
1811                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1812                                 true, (byte) 0), bagValue);
1813 
1814             // DER encode the secret key
1815             } else if (keyEntry instanceof SecretKeyEntry) {
1816                 // Create SafeBag of type SecretBag
1817                 safeBag.putOID(SecretBag_OID);
1818 
1819                 // Create a SecretBag
1820                 DerOutputStream secretBag = new DerOutputStream();
1821                 secretBag.putOID(PKCS8ShroudedKeyBag_OID);
1822 
1823                 // Write secret key in a context-specific tag
1824                 DerOutputStream secretKeyValue = new DerOutputStream();
1825                 secretKeyValue.putOctetString(
1826                     ((SecretKeyEntry) keyEntry).protectedSecretKey);
1827                 secretBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1828                                         true, (byte) 0), secretKeyValue);
1829 
1830                 // Wrap SecretBag in a Sequence
1831                 DerOutputStream secretBagSeq = new DerOutputStream();
1832                 secretBagSeq.write(DerValue.tag_Sequence, secretBag);
1833                 byte[] secretBagValue = secretBagSeq.toByteArray();
1834 
1835                 // Wrap the secret bag in a context-specific tag.
1836                 DerOutputStream bagValue = new DerOutputStream();
1837                 bagValue.write(secretBagValue);
1838 
1839                 // Write SafeBag value
1840                 safeBag.write(DerValue.createTag(DerValue.TAG_CONTEXT,
1841                                     true, (byte) 0), bagValue);
1842             } else {
1843                 continue; // skip this entry
1844             }
1845 
1846             // write SafeBag Attributes
1847             byte[] bagAttrs =
1848                 getBagAttributes(alias, entry.keyId, entry.attributes);
1849             safeBag.write(bagAttrs);
1850 
1851             // wrap as Sequence
1852             out.write(DerValue.tag_Sequence, safeBag);
1853         }
1854 
1855         // wrap as Sequence
1856         DerOutputStream safeBagValue = new DerOutputStream();
1857         safeBagValue.write(DerValue.tag_Sequence, out);
1858         return safeBagValue.toByteArray();
1859     }
1860 
1861 
1862     /*
1863      * Encrypt the contents using Password-based (PBE) encryption
1864      * as defined in PKCS #5.
1865      *
1866      * NOTE: Currently pbeWithSHAAnd40BiteRC2-CBC algorithmID is used
1867      *       to derive the key and IV.
1868      *
1869      * @return encrypted contents encoded as EncryptedContentInfo
1870      */
1871     private byte[] encryptContent(byte[] data, char[] password)
1872         throws IOException {
1873 
1874         byte[] encryptedData = null;
1875 
1876 
1877         try {
1878             // create AlgorithmParameters
1879             AlgorithmParameters algParams = getPBEAlgorithmParameters(
1880                     certProtectionAlgorithm, certPbeIterationCount);
1881             DerOutputStream bytes = new DerOutputStream();
1882 
1883             // Use JCE
1884             SecretKey skey = getPBEKey(password);
1885             Cipher cipher = Cipher.getInstance(certProtectionAlgorithm);
1886             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
1887             encryptedData = cipher.doFinal(data);
1888 
1889             AlgorithmId algId = new AlgorithmId(
1890                     mapPBEAlgorithmToOID(certProtectionAlgorithm),
1891                     cipher.getParameters());
1892                     // cipher.getParameters() now has IV
1893             algId.derEncode(bytes);
1894             byte[] encodedAlgId = bytes.toByteArray();
1895 
1896             if (debug != null) {
1897                 debug.println(&quot;  (Cipher algorithm: &quot; + cipher.getAlgorithm() +
1898                         &quot;)&quot;);
1899             }
1900 
1901             // create EncryptedContentInfo
1902             DerOutputStream bytes2 = new DerOutputStream();
1903             bytes2.putOID(ContentInfo.DATA_OID);
1904             bytes2.write(encodedAlgId);
1905 
1906             // Wrap encrypted data in a context-specific tag.
1907             DerOutputStream tmpout2 = new DerOutputStream();
1908             tmpout2.putOctetString(encryptedData);
1909             bytes2.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,
1910                     false, (byte) 0), tmpout2);
1911 
1912             // wrap EncryptedContentInfo in a Sequence
1913             DerOutputStream out = new DerOutputStream();
1914             out.write(DerValue.tag_Sequence, bytes2);
1915             return out.toByteArray();
1916         } catch (IOException ioe) {
1917             throw ioe;
1918         } catch (Exception e) {
1919             throw new IOException(&quot;Failed to encrypt&quot; +
1920                     &quot; safe contents entry: &quot; + e, e);
1921         }
1922     }
1923 
1924     /**
1925      * Loads the keystore from the given input stream.
1926      *
1927      * &lt;p&gt;If a password is given, it is used to check the integrity of the
1928      * keystore data. Otherwise, the integrity of the keystore is not checked.
1929      *
1930      * @param stream the input stream from which the keystore is loaded
1931      * @param password the (optional) password used to check the integrity of
1932      * the keystore.
1933      *
1934      * @exception IOException if there is an I/O or format problem with the
1935      * keystore data
1936      * @exception NoSuchAlgorithmException if the algorithm used to check
1937      * the integrity of the keystore cannot be found
1938      * @exception CertificateException if any of the certificates in the
1939      * keystore could not be loaded
1940      */
1941     public synchronized void engineLoad(InputStream stream, char[] password)
1942         throws IOException, NoSuchAlgorithmException, CertificateException
1943     {
1944 
1945         // Reset config when loading a different keystore.
1946         certProtectionAlgorithm = null;
1947         certPbeIterationCount = -1;
1948         macAlgorithm = null;
1949         macIterationCount = -1;
1950 
1951         if (stream == null)
1952            return;
1953 
1954         // reset the counter
1955         counter = 0;
1956 
1957         DerValue val = new DerValue(stream);
1958         DerInputStream s = val.toDerInputStream();
1959         int version = s.getInteger();
1960 
1961         if (version != VERSION_3) {
1962            throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);
1963         }
1964 
1965         entries.clear();
1966 
1967         /*
1968          * Read the authSafe.
1969          */
1970         byte[] authSafeData;
1971         ContentInfo authSafe = new ContentInfo(s);
1972         ObjectIdentifier contentType = authSafe.getContentType();
1973 
1974         if (contentType.equals(ContentInfo.DATA_OID)) {
1975            authSafeData = authSafe.getData();
1976         } else /* signed data */ {
1977            throw new IOException(&quot;public key protected PKCS12 not supported&quot;);
1978         }
1979 
1980         DerInputStream as = new DerInputStream(authSafeData);
1981         DerValue[] safeContentsArray = as.getSequence(2);
1982         int count = safeContentsArray.length;
1983 
1984         // reset the counters at the start
1985         privateKeyCount = 0;
1986         secretKeyCount = 0;
1987         certificateCount = 0;
1988 
1989         boolean seeEncBag = false;
1990 
1991         /*
1992          * Spin over the ContentInfos.
1993          */
1994         for (int i = 0; i &lt; count; i++) {
1995             ContentInfo safeContents;
1996             DerInputStream sci;
1997             byte[] eAlgId = null;
1998 
1999             sci = new DerInputStream(safeContentsArray[i].toByteArray());
2000             safeContents = new ContentInfo(sci);
2001             contentType = safeContents.getContentType();
2002             if (contentType.equals(ContentInfo.DATA_OID)) {
2003 
2004                 if (debug != null) {
2005                     debug.println(&quot;Loading PKCS#7 data&quot;);
2006                 }
2007 
2008                 loadSafeContents(new DerInputStream(safeContents.getData()));
2009             } else if (contentType.equals(ContentInfo.ENCRYPTED_DATA_OID)) {
2010                 if (password == null) {
2011 
2012                     if (debug != null) {
2013                         debug.println(&quot;Warning: skipping PKCS#7 encryptedData&quot; +
2014                             &quot; - no password was supplied&quot;);
2015                     }
2016                     // No password to decrypt ENCRYPTED_DATA_OID. *Skip it*.
2017                     // This means user will see a PrivateKeyEntry without
2018                     // certificates and a whole TrustedCertificateEntry will
2019                     // be lost. This is not a perfect solution but alternative
2020                     // solutions are more disruptive:
2021                     //
2022                     // We cannot just fail, since KeyStore.load(is, null)
2023                     // has been known to never fail because of a null password.
2024                     //
2025                     // We cannot just throw away the whole PrivateKeyEntry,
2026                     // this is too silent and no one will notice anything.
2027                     //
2028                     // We also cannot fail when getCertificate() on such a
2029                     // PrivateKeyEntry is called, since the method has not
2030                     // specified this behavior.
2031                     continue;
2032                 }
2033 
2034                 DerInputStream edi =
2035                                 safeContents.getContent().toDerInputStream();
2036                 int edVersion = edi.getInteger();
2037                 DerValue[] seq = edi.getSequence(2);
2038                 ObjectIdentifier edContentType = seq[0].getOID();
2039                 eAlgId = seq[1].toByteArray();
2040                 if (!seq[2].isContextSpecific((byte)0)) {
2041                    throw new IOException(&quot;encrypted content not present!&quot;);
2042                 }
2043                 byte newTag = DerValue.tag_OctetString;
2044                 if (seq[2].isConstructed())
2045                    newTag |= 0x20;
2046                 seq[2].resetTag(newTag);
2047                 byte[] rawData = seq[2].getOctetString();
2048 
2049                 // parse Algorithm parameters
2050                 DerInputStream in = seq[1].toDerInputStream();
2051                 ObjectIdentifier algOid = in.getOID();
2052                 AlgorithmParameters algParams = parseAlgParameters(algOid, in);
2053 
2054                 PBEParameterSpec pbeSpec;
2055                 int ic = 0;
2056 
2057                 if (algParams != null) {
2058                     try {
2059                         pbeSpec =
2060                             algParams.getParameterSpec(PBEParameterSpec.class);
2061                     } catch (InvalidParameterSpecException ipse) {
2062                         throw new IOException(
2063                             &quot;Invalid PBE algorithm parameters&quot;);
2064                     }
2065                     ic = pbeSpec.getIterationCount();
2066 
2067                     if (ic &gt; MAX_ITERATION_COUNT) {
2068                         throw new IOException(&quot;cert PBE iteration count too large&quot;);
2069                     }
2070 
2071                     certProtectionAlgorithm
2072                             = mapPBEParamsToAlgorithm(algOid, algParams);
2073                     certPbeIterationCount = ic;
2074                     seeEncBag = true;
2075                 }
2076 
2077                 if (debug != null) {
2078                     debug.println(&quot;Loading PKCS#7 encryptedData &quot; +
2079                         &quot;(&quot; + mapPBEParamsToAlgorithm(algOid, algParams) +
2080                         &quot; iterations: &quot; + ic + &quot;)&quot;);
2081                 }
2082 
2083                 try {
2084                     RetryWithZero.run(pass -&gt; {
2085                         // Use JCE
2086                         SecretKey skey = getPBEKey(pass);
2087                         Cipher cipher = Cipher.getInstance(
2088                                 mapPBEParamsToAlgorithm(algOid, algParams));
2089                         cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
2090                         loadSafeContents(new DerInputStream(cipher.doFinal(rawData)));
2091                         return null;
2092                     }, password);
2093                 } catch (Exception e) {
2094                     throw new IOException(&quot;keystore password was incorrect&quot;,
2095                             new UnrecoverableKeyException(
2096                                     &quot;failed to decrypt safe contents entry: &quot; + e));
2097                 }
2098             } else {
2099                 throw new IOException(&quot;public key protected PKCS12&quot; +
2100                                         &quot; not supported&quot;);
2101             }
2102         }
2103 
2104         // No ENCRYPTED_DATA_OID but see certificate. Must be passwordless.
2105         if (!seeEncBag &amp;&amp; certificateCount &gt; 0) {
2106             certProtectionAlgorithm = &quot;NONE&quot;;
2107         }
2108 
2109         // The MacData is optional.
2110         if (s.available() &gt; 0) {
2111             // If there is no password, we cannot fail. KeyStore.load(is, null)
2112             // has been known to never fail because of a null password.
2113             if (password != null) {
2114                 MacData macData = new MacData(s);
2115                 int ic = macData.getIterations();
2116 
2117                 try {
2118                     if (ic &gt; MAX_ITERATION_COUNT) {
2119                         throw new InvalidAlgorithmParameterException(
2120                                 &quot;MAC iteration count too large: &quot; + ic);
2121                     }
2122 
2123                     String algName =
2124                             macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);
2125 
2126                     // Change SHA-1 to SHA1
2127                     algName = algName.replace(&quot;-&quot;, &quot;&quot;);
2128 
2129                     macAlgorithm = &quot;HmacPBE&quot; + algName;
2130                     macIterationCount = ic;
2131 
2132                     // generate MAC (MAC key is created within JCE)
2133                     Mac m = Mac.getInstance(macAlgorithm);
2134                     PBEParameterSpec params =
2135                             new PBEParameterSpec(macData.getSalt(), ic);
2136 
2137                     RetryWithZero.run(pass -&gt; {
2138                         SecretKey key = getPBEKey(pass);
2139                         m.init(key, params);
2140                         m.update(authSafeData);
2141                         byte[] macResult = m.doFinal();
2142 
2143                         if (debug != null) {
2144                             debug.println(&quot;Checking keystore integrity &quot; +
2145                                     &quot;(&quot; + m.getAlgorithm() + &quot; iterations: &quot; + ic + &quot;)&quot;);
2146                         }
2147 
2148                         if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {
2149                             throw new UnrecoverableKeyException(&quot;Failed PKCS12&quot; +
2150                                     &quot; integrity checking&quot;);
2151                         }
2152                         return (Void) null;
2153                     }, password);
2154                 } catch (Exception e) {
2155                     throw new IOException(&quot;Integrity check failed: &quot; + e, e);
2156                 }
2157             }
2158         } else {
2159             macAlgorithm = &quot;NONE&quot;;
2160         }
2161 
2162         /*
2163          * Match up private keys with certificate chains.
2164          */
2165         PrivateKeyEntry[] list =
2166             keyList.toArray(new PrivateKeyEntry[keyList.size()]);
2167         for (int m = 0; m &lt; list.length; m++) {
2168             PrivateKeyEntry entry = list[m];
2169             if (entry.keyId != null) {
2170                 ArrayList&lt;X509Certificate&gt; chain =
2171                                 new ArrayList&lt;X509Certificate&gt;();
2172                 X509Certificate cert = findMatchedCertificate(entry);
2173 
2174                 mainloop:
2175                 while (cert != null) {
2176                     // Check for loops in the certificate chain
2177                     if (!chain.isEmpty()) {
2178                         for (X509Certificate chainCert : chain) {
2179                             if (cert.equals(chainCert)) {
2180                                 if (debug != null) {
2181                                     debug.println(&quot;Loop detected in &quot; +
2182                                         &quot;certificate chain. Skip adding &quot; +
2183                                         &quot;repeated cert to chain. Subject: &quot; +
2184                                         cert.getSubjectX500Principal()
2185                                             .toString());
2186                                 }
2187                                 break mainloop;
2188                             }
2189                         }
2190                     }
2191                     chain.add(cert);
2192                     if (KeyStoreUtil.isSelfSigned(cert)) {
2193                         break;
2194                     }
2195                     cert = findIssuer(cert);
2196                 }
2197                 /* Update existing KeyEntry in entries table */
2198                 if (chain.size() &gt; 0) {
2199                     entry.chain = chain.toArray(new Certificate[chain.size()]);
2200                 } else {
2201                     // Remove private key entries where there is no associated
2202                     // certs. Most likely the keystore is loaded with a null
2203                     // password.
2204                     entries.remove(entry);
2205                 }
2206             }
2207         }
2208 
2209         if (debug != null) {
2210             debug.println(&quot;PKCS12KeyStore load: private key count: &quot; +
2211                     privateKeyCount + &quot;. secret key count: &quot; + secretKeyCount +
2212                     &quot;. certificate count: &quot; + certificateCount);
2213         }
2214 
2215         certEntries.clear();
2216         allCerts.clear();
2217         keyList.clear();
2218     }
2219 
2220     /**
2221      * Find the issuer of input in allCerts. If the input has an
2222      * AuthorityKeyIdentifier extension and the keyId inside matches
2223      * the keyId of the SubjectKeyIdentifier of a cert. This cert is
2224      * returned. Otherwise, a cert whose subjectDN is the same as the
2225      * input&#39;s issuerDN is returned.
2226      *
2227      * @param input the input certificate
2228      * @return the isssuer, or null if none matches
2229      */
2230     private X509Certificate findIssuer(X509Certificate input) {
2231 
2232         X509Certificate fallback = null; // the DN match
2233         X500Principal issuerPrinc = input.getIssuerX500Principal();
2234 
2235         // AuthorityKeyIdentifier value encoded as an OCTET STRING
2236         byte[] issuerIdExtension = input.getExtensionValue(
2237                 KnownOIDs.AuthorityKeyID.value());
2238         byte[] issuerId = null;
2239 
2240         if (issuerIdExtension != null) {
2241             try {
2242                 issuerId = new AuthorityKeyIdentifierExtension(
2243                             false,
2244                             new DerValue(issuerIdExtension).getOctetString())
2245                         .getEncodedKeyIdentifier();
2246             } catch (IOException e) {
2247                 // ignored. issuerId is still null
2248             }
2249         }
2250 
2251         for (X509Certificate cert : allCerts) {
2252             if (cert.getSubjectX500Principal().equals(issuerPrinc)) {
2253                 if (issuerId != null) {
2254                     // SubjectKeyIdentifier value encoded as an OCTET STRING
2255                     byte[] subjectIdExtension = cert.getExtensionValue(
2256                             KnownOIDs.SubjectKeyID.value());
2257                     byte[] subjectId = null;
2258                     if (subjectIdExtension != null) {
2259                         try {
2260                             subjectId = new DerValue(subjectIdExtension)
2261                                     .getOctetString();
2262                         } catch (IOException e) {
2263                             // ignored. issuerId is still null
2264                         }
2265                     }
2266                     if (subjectId != null) {
2267                         if (Arrays.equals(issuerId, subjectId)) {
2268                             // keyId exact match!
2269                             return cert;
2270                         } else {
2271                             // Different keyId. Not a fallback.
2272                             continue;
2273                         }
2274                     } else {
2275                         // A DN match with no subjectId
2276                         fallback = cert;
2277                     }
2278                 } else { // if there is no issuerId, return the 1st DN match
2279                     return cert;
2280                 }
2281             }
2282         }
2283         return fallback;
2284     }
2285 
2286     /**
2287      * Returns if a pkcs12 file is password-less. This means no cert is
2288      * encrypted and there is no Mac. Please note that the private key
2289      * can be encrypted.
2290      *
2291      * This is a simplified version of {@link #engineLoad} that only looks
2292      * at the ContentInfo types.
2293      *
2294      * @param f the pkcs12 file
2295      * @return if it&#39;s password-less
2296      * @throws IOException
2297      */
2298     public static boolean isPasswordless(File f) throws IOException {
2299 
2300         try (FileInputStream stream = new FileInputStream(f)) {
2301             DerValue val = new DerValue(stream);
2302             DerInputStream s = val.toDerInputStream();
2303 
2304             s.getInteger(); // skip version
2305 
2306             ContentInfo authSafe = new ContentInfo(s);
2307             DerInputStream as = new DerInputStream(authSafe.getData());
2308             for (DerValue seq : as.getSequence(2)) {
2309                 DerInputStream sci = new DerInputStream(seq.toByteArray());
2310                 ContentInfo safeContents = new ContentInfo(sci);
2311                 if (safeContents.getContentType()
2312                         .equals(ContentInfo.ENCRYPTED_DATA_OID)) {
2313                     // Certificate encrypted
2314                     return false;
2315                 }
2316             }
2317 
2318             if (s.available() &gt; 0) {
2319                 // The MacData exists.
2320                 return false;
2321             }
2322         }
2323         return true;
2324     }
2325 
2326     /**
2327      * Locates a matched CertEntry from certEntries, and returns its cert.
2328      * @param entry the KeyEntry to match
2329      * @return a certificate, null if not found
2330      */
2331     private X509Certificate findMatchedCertificate(PrivateKeyEntry entry) {
2332         CertEntry keyIdMatch = null;
2333         CertEntry aliasMatch = null;
2334         for (CertEntry ce: certEntries) {
2335             if (Arrays.equals(entry.keyId, ce.keyId)) {
2336                 keyIdMatch = ce;
2337                 if (entry.alias.equalsIgnoreCase(ce.alias)) {
2338                     // Full match!
2339                     return ce.cert;
2340                 }
2341             } else if (entry.alias.equalsIgnoreCase(ce.alias)) {
2342                 aliasMatch = ce;
2343             }
2344         }
2345         // keyId match first, for compatibility
2346         if (keyIdMatch != null) return keyIdMatch.cert;
2347         else if (aliasMatch != null) return aliasMatch.cert;
2348         else return null;
2349     }
2350 
2351     private void loadSafeContents(DerInputStream stream)
2352         throws IOException, NoSuchAlgorithmException, CertificateException
2353     {
2354         DerValue[] safeBags = stream.getSequence(2);
2355         int count = safeBags.length;
2356 
2357         /*
2358          * Spin over the SafeBags.
2359          */
2360         for (int i = 0; i &lt; count; i++) {
2361             ObjectIdentifier bagId;
2362             DerInputStream sbi;
2363             DerValue bagValue;
2364             Object bagItem = null;
2365 
2366             sbi = safeBags[i].toDerInputStream();
2367             bagId = sbi.getOID();
2368             bagValue = sbi.getDerValue();
2369             if (!bagValue.isContextSpecific((byte)0)) {
2370                 throw new IOException(&quot;unsupported PKCS12 bag value type &quot;
2371                                         + bagValue.tag);
2372             }
2373             bagValue = bagValue.data.getDerValue();
2374             if (bagId.equals(PKCS8ShroudedKeyBag_OID)) {
2375                 PrivateKeyEntry kEntry = new PrivateKeyEntry();
2376                 kEntry.protectedPrivKey = bagValue.toByteArray();
2377                 bagItem = kEntry;
2378                 privateKeyCount++;
2379             } else if (bagId.equals(CertBag_OID)) {
2380                 DerInputStream cs = new DerInputStream(bagValue.toByteArray());
2381                 DerValue[] certValues = cs.getSequence(2);
2382                 ObjectIdentifier certId = certValues[0].getOID();
2383                 if (!certValues[1].isContextSpecific((byte)0)) {
2384                     throw new IOException(&quot;unsupported PKCS12 cert value type &quot;
2385                                         + certValues[1].tag);
2386                 }
2387                 DerValue certValue = certValues[1].data.getDerValue();
2388                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X509&quot;);
2389                 X509Certificate cert;
2390                 cert = (X509Certificate)cf.generateCertificate
2391                         (new ByteArrayInputStream(certValue.getOctetString()));
2392                 bagItem = cert;
2393                 certificateCount++;
2394             } else if (bagId.equals(SecretBag_OID)) {
2395                 DerInputStream ss = new DerInputStream(bagValue.toByteArray());
2396                 DerValue[] secretValues = ss.getSequence(2);
2397                 ObjectIdentifier secretId = secretValues[0].getOID();
2398                 if (!secretValues[1].isContextSpecific((byte)0)) {
2399                     throw new IOException(
2400                         &quot;unsupported PKCS12 secret value type &quot;
2401                                         + secretValues[1].tag);
2402                 }
2403                 DerValue secretValue = secretValues[1].data.getDerValue();
2404                 SecretKeyEntry kEntry = new SecretKeyEntry();
2405                 kEntry.protectedSecretKey = secretValue.getOctetString();
2406                 bagItem = kEntry;
2407                 secretKeyCount++;
2408             } else {
2409 
2410                 if (debug != null) {
2411                     debug.println(&quot;Unsupported PKCS12 bag type: &quot; + bagId);
2412                 }
2413             }
2414 
2415             DerValue[] attrSet;
2416             try {
2417                 attrSet = sbi.getSet(3);
2418             } catch (IOException e) {
2419                 // entry does not have attributes
2420                 // Note: CA certs can have no attributes
2421                 // OpenSSL generates pkcs12 with no attr for CA certs.
2422                 attrSet = null;
2423             }
2424 
2425             String alias = null;
2426             byte[] keyId = null;
2427             ObjectIdentifier[] trustedKeyUsage = null;
2428             Set&lt;PKCS12Attribute&gt; attributes = new HashSet&lt;&gt;();
2429 
2430             if (attrSet != null) {
2431                 for (int j = 0; j &lt; attrSet.length; j++) {
2432                     byte[] encoded = attrSet[j].toByteArray();
2433                     DerInputStream as = new DerInputStream(encoded);
2434                     DerValue[] attrSeq = as.getSequence(2);
2435                     ObjectIdentifier attrId = attrSeq[0].getOID();
2436                     DerInputStream vs =
2437                         new DerInputStream(attrSeq[1].toByteArray());
2438                     DerValue[] valSet;
2439                     try {
2440                         valSet = vs.getSet(1);
2441                     } catch (IOException e) {
2442                         throw new IOException(&quot;Attribute &quot; + attrId +
2443                                 &quot; should have a value &quot; + e.getMessage());
2444                     }
2445                     if (attrId.equals(PKCS9FriendlyName_OID)) {
2446                         alias = valSet[0].getBMPString();
2447                     } else if (attrId.equals(PKCS9LocalKeyId_OID)) {
2448                         keyId = valSet[0].getOctetString();
2449                     } else if
2450                         (attrId.equals(TrustedKeyUsage_OID)) {
2451                         trustedKeyUsage = new ObjectIdentifier[valSet.length];
2452                         for (int k = 0; k &lt; valSet.length; k++) {
2453                             trustedKeyUsage[k] = valSet[k].getOID();
2454                         }
2455                     } else {
2456                         attributes.add(new PKCS12Attribute(encoded));
2457                     }
2458                 }
2459             }
2460 
2461             /*
2462              * As per PKCS12 v1.0 friendlyname (alias) and localKeyId (keyId)
2463              * are optional PKCS12 bagAttributes. But entries in the keyStore
2464              * are identified by their alias. Hence we need to have an
2465              * Unfriendlyname in the alias, if alias is null. The keyId
2466              * attribute is required to match the private key with the
2467              * certificate. If we get a bagItem of type KeyEntry with a
2468              * null keyId, we should skip it entirely.
2469              */
2470             if (bagItem instanceof KeyEntry) {
2471                 KeyEntry entry = (KeyEntry)bagItem;
2472 
2473                 if (keyId == null) {
2474                     if (bagItem instanceof PrivateKeyEntry) {
2475                        // Insert a localKeyID for the privateKey
2476                        // Note: This is a workaround to allow null localKeyID
2477                        // attribute in pkcs12 with one private key entry and
2478                        // associated cert-chain
2479                        if (privateKeyCount == 1) {
2480                             keyId = &quot;01&quot;.getBytes(UTF_8);
2481                        } else {
2482                             continue;
2483                        }
2484                     } else {
2485                         // keyId in a SecretKeyEntry is not significant
2486                         keyId = &quot;00&quot;.getBytes(UTF_8);
2487                     }
2488                 }
2489                 entry.keyId = keyId;
2490                 // restore date if it exists
2491                 String keyIdStr = new String(keyId, UTF_8);
2492                 Date date = null;
2493                 if (keyIdStr.startsWith(&quot;Time &quot;)) {
2494                     try {
2495                         date = new Date(
2496                                 Long.parseLong(keyIdStr.substring(5)));
2497                     } catch (Exception e) {
2498                         date = null;
2499                     }
2500                 }
2501                 if (date == null) {
2502                     date = new Date();
2503                 }
2504                 entry.date = date;
2505 
2506                 if (bagItem instanceof PrivateKeyEntry) {
2507                     keyList.add((PrivateKeyEntry) entry);
2508                 }
2509                 if (entry.attributes == null) {
2510                     entry.attributes = new HashSet&lt;&gt;();
2511                 }
2512                 entry.attributes.addAll(attributes);
2513                 if (alias == null) {
2514                    alias = getUnfriendlyName();
2515                 }
2516                 entry.alias = alias;
2517                 entries.put(alias.toLowerCase(Locale.ENGLISH), entry);
2518 
2519             } else if (bagItem instanceof X509Certificate) {
2520                 X509Certificate cert = (X509Certificate)bagItem;
2521                 // Insert a localKeyID for the corresponding cert
2522                 // Note: This is a workaround to allow null localKeyID
2523                 // attribute in pkcs12 with one private key entry and
2524                 // associated cert-chain
2525                 if ((keyId == null) &amp;&amp; (privateKeyCount == 1)) {
2526                     // insert localKeyID only for EE cert or self-signed cert
2527                     if (i == 0) {
2528                         keyId = &quot;01&quot;.getBytes(UTF_8);
2529                     }
2530                 }
2531                 // Trusted certificate
2532                 if (trustedKeyUsage != null) {
2533                     if (alias == null) {
2534                         alias = getUnfriendlyName();
2535                     }
2536                     CertEntry certEntry =
2537                         new CertEntry(cert, keyId, alias, trustedKeyUsage,
2538                             attributes);
2539                     entries.put(alias.toLowerCase(Locale.ENGLISH), certEntry);
2540                 } else {
2541                     certEntries.add(new CertEntry(cert, keyId, alias));
2542                 }
2543                 allCerts.add(cert);
2544             }
2545         }
2546     }
2547 
2548     private String getUnfriendlyName() {
2549         counter++;
2550         return (String.valueOf(counter));
2551     }
2552 
2553     /*
2554      * PKCS12 permitted first 24 bytes:
2555      *
2556      * 30 80 02 01 03 30 80 06 09 2A 86 48 86 F7 0D 01 07 01 A0 80 24 80 04 --
2557      * 30 82 -- -- 02 01 03 30 82 -- -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 8-
2558      * 30 -- 02 01 03 30 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 -- 04 -- -- --
2559      * 30 81 -- 02 01 03 30 81 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 81 -- 04
2560      * 30 82 -- -- 02 01 03 30 81 -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0 81 --
2561      * 30 83 -- -- -- 02 01 03 30 82 -- -- 06 09 2A 86 48 86 F7 0D 01 07 01 A0
2562      * 30 83 -- -- -- 02 01 03 30 83 -- -- -- 06 09 2A 86 48 86 F7 0D 01 07 01
2563      * 30 84 -- -- -- -- 02 01 03 30 83 -- -- -- 06 09 2A 86 48 86 F7 0D 01 07
2564      * 30 84 -- -- -- -- 02 01 03 30 84 -- -- -- -- 06 09 2A 86 48 86 F7 0D 01
2565      */
2566 
2567     private static final long[][] PKCS12_HEADER_PATTERNS = {
2568         { 0x3080020103308006L, 0x092A864886F70D01L, 0x0701A08024800400L },
2569         { 0x3082000002010330L, 0x82000006092A8648L, 0x86F70D010701A080L },
2570         { 0x3000020103300006L, 0x092A864886F70D01L, 0x0701A00004000000L },
2571         { 0x3081000201033081L, 0x0006092A864886F7L, 0x0D010701A0810004L },
2572         { 0x3082000002010330L, 0x810006092A864886L, 0xF70D010701A08100L },
2573         { 0x3083000000020103L, 0x3082000006092A86L, 0x4886F70D010701A0L },
2574         { 0x3083000000020103L, 0x308300000006092AL, 0x864886F70D010701L },
2575         { 0x3084000000000201L, 0x0330830000000609L, 0x2A864886F70D0107L },
2576         { 0x3084000000000201L, 0x0330840000000006L, 0x092A864886F70D01L }
2577     };
2578 
2579     private static final long[][] PKCS12_HEADER_MASKS = {
2580         { 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFF00L },
2581         { 0xFFFF0000FFFFFFFFL, 0xFF0000FFFFFFFFFFL, 0xFFFFFFFFFFFFFFF0L },
2582         { 0xFF00FFFFFFFF00FFL, 0xFFFFFFFFFFFFFFFFL, 0xFFFFFF00FF000000L },
2583         { 0xFFFF00FFFFFFFFFFL, 0x00FFFFFFFFFFFFFFL, 0xFFFFFFFFFFFF00FFL },
2584         { 0xFFFF0000FFFFFFFFL, 0xFF00FFFFFFFFFFFFL, 0xFFFFFFFFFFFFFF00L },
2585         { 0xFFFF000000FFFFFFL, 0xFFFF0000FFFFFFFFL, 0xFFFFFFFFFFFFFFFFL },
2586         { 0xFFFF000000FFFFFFL, 0xFFFF000000FFFFFFL, 0xFFFFFFFFFFFFFFFFL },
2587         { 0xFFFF00000000FFFFL, 0xFFFFFF000000FFFFL, 0xFFFFFFFFFFFFFFFFL },
2588         { 0xFFFF00000000FFFFL, 0xFFFFFF00000000FFL, 0xFFFFFFFFFFFFFFFFL }
2589     };
2590 
2591     /**
2592      * Probe the first few bytes of the keystore data stream for a valid
2593      * PKCS12 keystore encoding.
2594      */
2595     @Override
2596     public boolean engineProbe(InputStream stream) throws IOException {
2597 
2598         DataInputStream dataStream;
2599         if (stream instanceof DataInputStream) {
2600             dataStream = (DataInputStream)stream;
2601         } else {
2602             dataStream = new DataInputStream(stream);
2603         }
2604 
2605         long firstPeek = dataStream.readLong();
2606         long nextPeek = dataStream.readLong();
2607         long finalPeek = dataStream.readLong();
2608         boolean result = false;
2609 
2610         for (int i = 0; i &lt; PKCS12_HEADER_PATTERNS.length; i++) {
2611             if (PKCS12_HEADER_PATTERNS[i][0] ==
2612                     (firstPeek &amp; PKCS12_HEADER_MASKS[i][0]) &amp;&amp;
2613                 (PKCS12_HEADER_PATTERNS[i][1] ==
2614                     (nextPeek &amp; PKCS12_HEADER_MASKS[i][1])) &amp;&amp;
2615                 (PKCS12_HEADER_PATTERNS[i][2] ==
2616                     (finalPeek &amp; PKCS12_HEADER_MASKS[i][2]))) {
2617                 result = true;
2618                 break;
2619             }
2620         }
2621 
2622         return result;
2623     }
2624 
2625     // 8076190: Customizing the generation of a PKCS12 keystore
2626 
2627     private static String defaultCertProtectionAlgorithm() {
2628         String result = SecurityProperties.privilegedGetOverridable(
2629                 &quot;keystore.pkcs12.certProtectionAlgorithm&quot;);
2630         return (result != null &amp;&amp; !result.isEmpty())
2631                 ? result : &quot;PBEWithSHA1AndRC2_40&quot;;
2632     }
2633 
2634     private static int defaultCertPbeIterationCount() {
2635         String result = SecurityProperties.privilegedGetOverridable(
2636                 &quot;keystore.pkcs12.certPbeIterationCount&quot;);
2637         return (result != null &amp;&amp; !result.isEmpty())
2638                 ? string2IC(&quot;certPbeIterationCount&quot;, result) : 50000;
2639     }
2640 
2641     // Read both &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
2642     // &quot;keystore.PKCS12.keyProtectionAlgorithm&quot; for compatibility.
2643     private static String defaultKeyProtectionAlgorithm() {
2644         String result = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
2645             public String run() {
2646                 String result;
2647                 String name1 = &quot;keystore.pkcs12.keyProtectionAlgorithm&quot;;
2648                 String name2 = &quot;keystore.PKCS12.keyProtectionAlgorithm&quot;;
2649                 result = System.getProperty(name1);
2650                 if (result != null) {
2651                     return result;
2652                 }
2653                 result = System.getProperty(name2);
2654                 if (result != null) {
2655                     return result;
2656                 }
2657                 result = Security.getProperty(name1);
2658                 if (result != null) {
2659                     return result;
2660                 }
2661                 return Security.getProperty(name2);
2662             }
2663         });
2664         return (result != null &amp;&amp; !result.isEmpty())
2665                 ? result : &quot;PBEWithSHA1AndDESede&quot;;
2666     }
2667 
2668     private static int defaultKeyPbeIterationCount() {
2669         String result = SecurityProperties.privilegedGetOverridable(
2670                 &quot;keystore.pkcs12.keyPbeIterationCount&quot;);
2671         return (result != null &amp;&amp; !result.isEmpty())
2672                 ? string2IC(&quot;keyPbeIterationCount&quot;, result) : 50000;
2673     }
2674 
2675     private static String defaultMacAlgorithm() {
2676         String result = SecurityProperties.privilegedGetOverridable(
2677                 &quot;keystore.pkcs12.macAlgorithm&quot;);
2678         return (result != null &amp;&amp; !result.isEmpty())
2679                 ? result : &quot;HmacPBESHA1&quot;;
2680     }
2681 
2682     private static int defaultMacIterationCount() {
2683         String result = SecurityProperties.privilegedGetOverridable(
2684                 &quot;keystore.pkcs12.macIterationCount&quot;);
2685         return (result != null &amp;&amp; !result.isEmpty())
2686                 ? string2IC(&quot;macIterationCount&quot;, result) : 100000;
2687     }
2688 
2689     private static int string2IC(String type, String value) {
2690         int number;
2691         try {
2692             number = Integer.parseInt(value);
2693         } catch (NumberFormatException e) {
2694             throw new IllegalArgumentException(&quot;keystore.pkcs12.&quot; + type
2695                     + &quot; is not a number: &quot; + value);
2696         }
2697         if (number &lt;= 0 || number &gt; MAX_ITERATION_COUNT) {
2698             throw new IllegalArgumentException(&quot;Invalid keystore.pkcs12.&quot;
2699                     + type + &quot;: &quot; + value);
2700         }
2701         return number;
2702     }
2703 }
    </pre>
  </body>
</html>
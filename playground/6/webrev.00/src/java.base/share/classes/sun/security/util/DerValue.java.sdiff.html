<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NamedCurve.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerValue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45  * data encodings which are defined.  That subset is sufficient for parsing
 46  * most X.509 certificates, and working with selected additional formats
 47  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 48  *
 49  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 50  * and RFC 5280, section 8, we assume that this kind of string will contain
 51  * ISO-8859-1 characters only.
 52  *
 53  *
 54  * @author David Brownell
 55  * @author Amit Kapoor
 56  * @author Hemma Prafullchandra
 57  */
 58 public class DerValue {
 59     /** The tag class types */
 60     public static final byte TAG_UNIVERSAL = (byte)0x000;
 61     public static final byte TAG_APPLICATION = (byte)0x040;
 62     public static final byte TAG_CONTEXT = (byte)0x080;
 63     public static final byte TAG_PRIVATE = (byte)0x0c0;
 64 
<span class="line-modified"> 65     /** The DER tag of the value; one of the tag_ constants. */</span>
 66     public byte                 tag;
<span class="line-modified"> 67 </span>
 68     protected DerInputBuffer    buffer;
<span class="line-modified"> 69 </span>
<span class="line-removed"> 70     /**</span>
<span class="line-removed"> 71      * The DER-encoded data of the value, never null</span>
<span class="line-removed"> 72      */</span>
 73     public final DerInputStream data;
<span class="line-modified"> 74 </span>
 75     private int                 length;
 76 
 77     /*
 78      * The type starts at the first byte of the encoding, and
 79      * is one of these tag_* values.  That may be all the type
 80      * data that is needed.
 81      */
 82 
 83     /*
 84      * These tags are the &quot;universal&quot; tags ... they mean the same
 85      * in all contexts.  (Mask with 0x1f -- five bits.)
 86      */
 87 
 88     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
 89     public static final byte    tag_Boolean = 0x01;
 90 
 91     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
 92     public static final byte    tag_Integer = 0x02;
 93 
 94     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
</pre>
<hr />
<pre>
198      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
199      */
200     public boolean isConstructed(byte constructedTag) {
201         if (!isConstructed()) {
202             return false;
203         }
204         return ((tag &amp; 0x01f) == constructedTag);
205     }
206 
207     /**
208      * Creates a PrintableString or UTF8string DER value from a string
209      */
210     public DerValue(String value) {
211         boolean isPrintableString = true;
212         for (int i = 0; i &lt; value.length(); i++) {
213             if (!isPrintableStringChar(value.charAt(i))) {
214                 isPrintableString = false;
215                 break;
216             }
217         }
<span class="line-modified">218 </span>
<span class="line-modified">219         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);</span>
220     }
221 
222     /**
223      * Creates a string type DER value from a String object
224      * @param stringTag the tag for the DER value to create
225      * @param value the String object to use for the DER value
226      */
227     public DerValue(byte stringTag, String value) {
228         data = init(stringTag, value);
229     }
230 
231     // Creates a DerValue from a tag and some DER-encoded data w/ additional
232     // arg to control whether DER checks are enforced.
233     DerValue(byte tag, byte[] data, boolean allowBER) {
234         this.tag = tag;
235         buffer = new DerInputBuffer(data.clone(), allowBER);
236         length = data.length;
237         this.data = new DerInputStream(buffer);
238         this.data.mark(Integer.MAX_VALUE);
239     }
</pre>
<hr />
<pre>
258         tag = (byte)in.read();
259         byte lenByte = (byte)in.read();
260         length = DerInputStream.getLength(lenByte, in);
261         if (length == -1) {  // indefinite length encoding found
262             DerInputBuffer inbuf = in.dup();
263             inbuf = new DerInputBuffer(
264                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
265                     in.allowBER);
266             if (tag != inbuf.read())
267                 throw new IOException
268                         (&quot;Indefinite length encoding not supported&quot;);
269             length = DerInputStream.getDefiniteLength(inbuf);
270             buffer = inbuf.dup();
271             buffer.truncate(length);
272             data = new DerInputStream(buffer);
273             // indefinite form is encoded by sending a length field with a
274             // length of 0. - i.e. [1000|0000].
275             // the object is ended by sending two zero bytes.
276             in.skip(length + 2);
277         } else {
<span class="line-removed">278 </span>
279             buffer = in.dup();
280             buffer.truncate(length);
281             data = new DerInputStream(buffer);
282 
283             in.skip(length);
284         }
285     }
286 
287     // Get an ASN.1/DER encoded datum from a buffer w/ additional
288     // arg to control whether DER checks are enforced.
289     DerValue(byte[] buf, boolean allowBER) throws IOException {
290         data = init(true, new ByteArrayInputStream(buf), allowBER);
291     }
292 
293     /**
294      * Get an ASN.1/DER encoded datum from a buffer.  The
295      * entire buffer must hold exactly one datum, including
296      * its tag and length.
297      *
298      * @param buf buffer holding a single DER-encoded datum.
299      */
300     public DerValue(byte[] buf) throws IOException {
301         this(buf, true);
302     }
303 
304     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
305     // arg to control whether DER checks are enforced.
306     DerValue(byte[] buf, int offset, int len, boolean allowBER)
<span class="line-modified">307         throws IOException {</span>
308         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
309     }
310 
311     /**
312      * Get an ASN.1/DER encoded datum from part of a buffer.
313      * That part of the buffer must hold exactly one datum, including
314      * its tag and length.
315      *
316      * @param buf the buffer
317      * @param offset start point of the single DER-encoded dataum
318      * @param len how many bytes are in the encoded datum
319      */
320     public DerValue(byte[] buf, int offset, int len) throws IOException {
321         this(buf, offset, len, true);
322     }
323 
324     // Get an ASN1/DER encoded datum from an input stream w/ additional
325     // arg to control whether DER checks are enforced.
326     DerValue(InputStream in, boolean allowBER) throws IOException {
327         data = init(false, in, allowBER);
</pre>
<hr />
<pre>
361             charset = UTF_8;
362             break;
363             // TBD: Need encoder for UniversalString before it can
364             // be handled.
365         default:
366             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
367         }
368 
369         byte[] buf = value.getBytes(charset);
370         length = buf.length;
371         buffer = new DerInputBuffer(buf, true);
372         DerInputStream result = new DerInputStream(buffer);
373         result.mark(Integer.MAX_VALUE);
374         return result;
375     }
376 
377     /*
378      * helper routine
379      */
380     private DerInputStream init(boolean fullyBuffered, InputStream in,
<span class="line-modified">381         boolean allowBER) throws IOException {</span>
382 
383         tag = (byte)in.read();
384         byte lenByte = (byte)in.read();
385         length = DerInputStream.getLength(lenByte, in);
386         if (length == -1) { // indefinite length encoding found
387             in = new ByteArrayInputStream(
388                     DerIndefLenConverter.convertStream(in, lenByte, tag));
<span class="line-modified">389             if (tag != in.read())</span>
390                 throw new IOException
391                         (&quot;Indefinite length encoding not supported&quot;);

392             length = DerInputStream.getDefiniteLength(in);
393         }
394 
<span class="line-modified">395         if (fullyBuffered &amp;&amp; in.available() != length)</span>
396             throw new IOException(&quot;extra data given to DerValue constructor&quot;);

397 
398         byte[] bytes = IOUtils.readExactlyNBytes(in, length);
399 
400         buffer = new DerInputBuffer(bytes, allowBER);
401         return new DerInputStream(buffer);
402     }
403 
404     /**
405      * Encode an ASN1/DER encoded datum onto a DER output stream.
406      */
<span class="line-modified">407     public void encode(DerOutputStream out)</span>
<span class="line-removed">408     throws IOException {</span>
409         out.write(tag);
410         out.putLength(length);
<span class="line-removed">411         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)</span>
412         if (length &gt; 0) {
413             byte[] value = new byte[length];
414             // always synchronized on data
415             synchronized (data) {
416                 buffer.reset();
<span class="line-modified">417                 if (buffer.read(value) != length) {</span>
<span class="line-modified">418                     throw new IOException(&quot;short DER value read (encode)&quot;);</span>





419                 }
420                 out.write(value);
421             }
422         }
423     }
424 
425     public final DerInputStream getData() {
426         return data;
427     }
428 
429     public final byte getTag() {
430         return tag;
431     }
432 
433     /**
434      * Returns an ASN.1 BOOLEAN
435      *
436      * @return the boolean held in this DER value
437      */
438     public boolean getBoolean() throws IOException {
439         if (tag != tag_Boolean) {
440             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
441         }
442         if (length != 1) {
443             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
444                                         + length);
445         }
446         if (buffer.read() != 0) {
447             return true;
448         }
449         return false;
450     }
451 
452     /**
453      * Returns an ASN.1 OBJECT IDENTIFIER.
454      *
455      * @return the OID held in this DER value
456      */
457     public ObjectIdentifier getOID() throws IOException {
<span class="line-modified">458         if (tag != tag_ObjectId)</span>
459             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);

460         return new ObjectIdentifier(buffer);
461     }
462 
463     private byte[] append(byte[] a, byte[] b) {
<span class="line-modified">464         if (a == null)</span>
465             return b;

466 
467         byte[] ret = new byte[a.length + b.length];
468         System.arraycopy(a, 0, ret, 0, a.length);
469         System.arraycopy(b, 0, ret, a.length, b.length);
470 
471         return ret;
472     }
473 
474     /**
475      * Returns an ASN.1 OCTET STRING
476      *
477      * @return the octet string held in this DER value
478      */
479     public byte[] getOctetString() throws IOException {
480 
481         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
482             throw new IOException(
<span class="line-modified">483                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);</span>
484         }
485         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
486         // known bug that it returns -1 instead of 0.
487         if (length == 0) {
488             return new byte[0];
489         }
490 
491         // Only allocate the array if there are enough bytes available.
492         // This only works for ByteArrayInputStream.
493         // The assignment below ensures that buffer has the required type.
494         ByteArrayInputStream arrayInput = buffer;
495         if (arrayInput.available() &lt; length) {
496             throw new IOException(&quot;short read on DerValue buffer&quot;);
497         }
498         byte[] bytes = new byte[length];
499         arrayInput.read(bytes);
500 
501         if (isConstructed()) {
502             DerInputStream in = new DerInputStream(bytes, 0, bytes.length,
503                 buffer.allowBER);
</pre>
<hr />
<pre>
510     }
511 
512     /**
513      * Returns an ASN.1 INTEGER value as an integer.
514      *
515      * @return the integer held in this DER value.
516      */
517     public int getInteger() throws IOException {
518         if (tag != tag_Integer) {
519             throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);
520         }
521         return buffer.getInteger(data.available());
522     }
523 
524     /**
525      * Returns an ASN.1 INTEGER value as a BigInteger.
526      *
527      * @return the integer held in this DER value as a BigInteger.
528      */
529     public BigInteger getBigInteger() throws IOException {
<span class="line-modified">530         if (tag != tag_Integer)</span>
531             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);

532         return buffer.getBigInteger(data.available(), false);
533     }
534 
535     /**
536      * Returns an ASN.1 INTEGER value as a positive BigInteger.
537      * This is just to deal with implementations that incorrectly encode
538      * some values as negative.
539      *
540      * @return the integer held in this DER value as a BigInteger.
541      */
542     public BigInteger getPositiveBigInteger() throws IOException {
<span class="line-modified">543         if (tag != tag_Integer)</span>
544             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);

545         return buffer.getBigInteger(data.available(), true);
546     }
547 
548     /**
549      * Returns an ASN.1 ENUMERATED value.
550      *
551      * @return the integer held in this DER value.
552      */
553     public int getEnumerated() throws IOException {
554         if (tag != tag_Enumerated) {
555             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
556                                   + tag);
557         }
558         return buffer.getInteger(data.available());
559     }
560 
561     /**
562      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
563      *
564      * @return the bit string held in this value
565      */
566     public byte[] getBitString() throws IOException {
<span class="line-modified">567         if (tag != tag_BitString)</span>
568             throw new IOException(
<span class="line-modified">569                 &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-modified">570 </span>
571         return buffer.getBitString();
572     }
573 
574     /**
575      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
576      *
577      * @return a BitArray representing the bit string held in this value
578      */
579     public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified">580         if (tag != tag_BitString)</span>
581             throw new IOException(
<span class="line-modified">582                 &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-modified">583 </span>
584         return buffer.getUnalignedBitString();
585     }
586 
587     /**
588      * Returns the name component as a Java string, regardless of its
589      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
590      */
591     // TBD: Need encoder for UniversalString before it can be handled.
592     public String getAsString() throws IOException {
<span class="line-modified">593         if (tag == tag_UTF8String)</span>
594             return getUTF8String();
<span class="line-modified">595         else if (tag == tag_PrintableString)</span>
596             return getPrintableString();
<span class="line-modified">597         else if (tag == tag_T61String)</span>
598             return getT61String();
<span class="line-modified">599         else if (tag == tag_IA5String)</span>
600             return getIA5String();
601         /*
<span class="line-modified">602           else if (tag == tag_UniversalString)</span>
603           return getUniversalString();
604         */
<span class="line-modified">605         else if (tag == tag_BMPString)</span>
606             return getBMPString();
<span class="line-modified">607         else if (tag == tag_GeneralString)</span>
608             return getGeneralString();
<span class="line-modified">609         else</span>
610             return null;

611     }
612 
613     /**
614      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
615      * based on the parameter.  The bit string must be byte-aligned.
616      *
617      * @param tagImplicit if true, the tag is assumed implicit.
618      * @return the bit string held in this value
619      */
620     public byte[] getBitString(boolean tagImplicit) throws IOException {
621         if (!tagImplicit) {
<span class="line-modified">622             if (tag != tag_BitString)</span>
623                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">624                                        + tag);</span>
625             }

626         return buffer.getBitString();
627     }
628 
629     /**
630      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
631      * based on the parameter.  The bit string need not be byte-aligned.
632      *
633      * @param tagImplicit if true, the tag is assumed implicit.
634      * @return the bit string held in this value
635      */
636     public BitArray getUnalignedBitString(boolean tagImplicit)
<span class="line-modified">637     throws IOException {</span>
638         if (!tagImplicit) {
<span class="line-modified">639             if (tag != tag_BitString)</span>
640                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">641                                        + tag);</span>
642             }

643         return buffer.getUnalignedBitString();
644     }
645 
646     /**
647      * Helper routine to return all the bytes contained in the
648      * DerInputStream associated with this object.
649      */
650     public byte[] getDataBytes() throws IOException {
651         byte[] retVal = new byte[length];
652         synchronized (data) {
653             data.reset();
654             data.getBytes(retVal);
655         }
656         return retVal;
657     }
658 
659     /**
660      * Returns an ASN.1 STRING value
661      *
662      * @return the printable string held in this value
663      */
<span class="line-modified">664     public String getPrintableString()</span>
<span class="line-modified">665     throws IOException {</span>
<span class="line-removed">666         if (tag != tag_PrintableString)</span>
667             throw new IOException(
<span class="line-modified">668                 &quot;DerValue.getPrintableString, not a string &quot; + tag);</span>
<span class="line-modified">669 </span>
670         return new String(getDataBytes(), US_ASCII);
671     }
672 
673     /**
674      * Returns an ASN.1 T61 (Teletype) STRING value
675      *
676      * @return the teletype string held in this value
677      */
678     public String getT61String() throws IOException {
<span class="line-modified">679         if (tag != tag_T61String)</span>
<span class="line-modified">680             throw new IOException(</span>
<span class="line-modified">681                 &quot;DerValue.getT61String, not T61 &quot; + tag);</span>
<span class="line-removed">682 </span>
683         return new String(getDataBytes(), ISO_8859_1);
684     }
685 
686     /**
687      * Returns an ASN.1 IA5 (ASCII) STRING value
688      *
689      * @return the ASCII string held in this value
690      */
691     public String getIA5String() throws IOException {
<span class="line-modified">692         if (tag != tag_IA5String)</span>
<span class="line-modified">693             throw new IOException(</span>
<span class="line-modified">694                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);</span>
<span class="line-removed">695 </span>
696         return new String(getDataBytes(), US_ASCII);
697     }
698 
699     /**
700      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
701      *
702      * @return a string corresponding to the encoded BMPString held in
703      * this value
704      */
705     public String getBMPString() throws IOException {
<span class="line-modified">706         if (tag != tag_BMPString)</span>
<span class="line-modified">707             throw new IOException(</span>
<span class="line-modified">708                 &quot;DerValue.getBMPString, not BMP &quot; + tag);</span>
<span class="line-modified">709 </span>
<span class="line-removed">710         // BMPString is the same as Unicode in big endian, unmarked</span>
<span class="line-removed">711         // format.</span>
712         return new String(getDataBytes(), UTF_16BE);
713     }
714 
715     /**
716      * Returns the ASN.1 UTF-8 STRING value as a Java String.
717      *
718      * @return a string corresponding to the encoded UTF8String held in
719      * this value
720      */
721     public String getUTF8String() throws IOException {
<span class="line-modified">722         if (tag != tag_UTF8String)</span>
<span class="line-modified">723             throw new IOException(</span>
<span class="line-modified">724                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);</span>
<span class="line-removed">725 </span>
726         return new String(getDataBytes(), UTF_8);
727     }
728 
729     /**
730      * Returns the ASN.1 GENERAL STRING value as a Java String.
731      *
732      * @return a string corresponding to the encoded GeneralString held in
733      * this value
734      */
735     public String getGeneralString() throws IOException {
<span class="line-modified">736         if (tag != tag_GeneralString)</span>
737             throw new IOException(
<span class="line-modified">738                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);</span>
<span class="line-modified">739 </span>
740         return new String(getDataBytes(), US_ASCII);
741     }
742 
743     /**
744      * Returns a Date if the DerValue is UtcTime.
745      *
746      * @return the Date held in this DER value
747      */
748     public Date getUTCTime() throws IOException {
749         if (tag != tag_UtcTime) {
750             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
751         }
752         return buffer.getUTCTime(data.available());
753     }
754 
755     /**
756      * Returns a Date if the DerValue is GeneralizedTime.
757      *
758      * @return the Date held in this DER value
759      */
</pre>
<hr />
<pre>
801     private static boolean doEquals(DerValue d1, DerValue d2) {
802         synchronized (d1.data) {
803             synchronized (d2.data) {
804                 d1.data.reset();
805                 d2.data.reset();
806                 return d1.buffer.equals(d2.buffer);
807             }
808         }
809     }
810 
811     /**
812      * Returns a printable representation of the value.
813      *
814      * @return printable representation of the value
815      */
816     @Override
817     public String toString() {
818         try {
819 
820             String str = getAsString();
<span class="line-modified">821             if (str != null)</span>
822                 return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
<span class="line-modified">823             if (tag == tag_Null)</span>

824                 return &quot;[DerValue, null]&quot;;
<span class="line-modified">825             if (tag == tag_ObjectId)</span>
826                 return &quot;OID.&quot; + getOID();
<span class="line-modified">827 </span>
<span class="line-modified">828             // integers</span>
<span class="line-removed">829             else</span>
830                 return &quot;[DerValue, tag = &quot; + tag
831                         + &quot;, length = &quot; + length + &quot;]&quot;;

832         } catch (IOException e) {
833             throw new IllegalArgumentException(&quot;misformatted DER value&quot;);
834         }
835     }
836 
837     /**
838      * Returns a DER-encoded value, such that if it&#39;s passed to the
839      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
840      *
841      * @return DER-encoded value, including tag and length.
842      */
843     public byte[] toByteArray() throws IOException {
844         DerOutputStream out = new DerOutputStream();
845 
846         encode(out);
847         data.reset();
848         return out.toByteArray();
849     }
850 
851     /**
852      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
853      * to return a DER stream of the members of the set or sequence.
854      * This operation is not supported for primitive types such as
855      * integers or bit strings.
856      */
857     public DerInputStream toDerInputStream() throws IOException {
<span class="line-modified">858         if (tag == tag_Sequence || tag == tag_Set)</span>
859             return new DerInputStream(buffer);

860         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
861     }
862 
863     /**
864      * Get the length of the encoded value.
865      */
866     public int length() {
867         return length;
868     }
869 
870     /**
871      * Determine if a character is one of the permissible characters for
872      * PrintableString:
873      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
874      * plus sign, comma, hyphen, period, slash, colon, equals sign,
875      * and question mark.
876      *
877      * Characters that are *not* allowed in PrintableString include
878      * exclamation point, quotation mark, number sign, dollar sign,
879      * percent sign, ampersand, asterisk, semicolon, less than sign,
880      * greater than sign, at sign, left and right square brackets,
881      * backslash, circumflex (94), underscore, back quote (96),
882      * left and right curly brackets, vertical line, tilde,
883      * and the control codes (0-31 and 127).
884      *
885      * This list is based on X.680 (the ASN.1 spec).
886      */
887     public static boolean isPrintableStringChar(char ch) {
888         if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
<span class="line-modified">889             (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {</span>
890             return true;
891         } else {
892             switch (ch) {
893                 case &#39; &#39;:       /* space */
894                 case &#39;\&#39;&#39;:      /* apostrophe */
895                 case &#39;(&#39;:       /* left paren */
896                 case &#39;)&#39;:       /* right paren */
897                 case &#39;+&#39;:       /* plus */
898                 case &#39;,&#39;:       /* comma */
899                 case &#39;-&#39;:       /* hyphen */
900                 case &#39;.&#39;:       /* period */
901                 case &#39;/&#39;:       /* slash */
902                 case &#39;:&#39;:       /* colon */
903                 case &#39;=&#39;:       /* equals */
904                 case &#39;?&#39;:       /* question mark */
905                     return true;
906                 default:
907                     return false;
908             }
909         }
</pre>
</td>
<td>
<hr />
<pre>
 45  * data encodings which are defined.  That subset is sufficient for parsing
 46  * most X.509 certificates, and working with selected additional formats
 47  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 48  *
 49  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 50  * and RFC 5280, section 8, we assume that this kind of string will contain
 51  * ISO-8859-1 characters only.
 52  *
 53  *
 54  * @author David Brownell
 55  * @author Amit Kapoor
 56  * @author Hemma Prafullchandra
 57  */
 58 public class DerValue {
 59     /** The tag class types */
 60     public static final byte TAG_UNIVERSAL = (byte)0x000;
 61     public static final byte TAG_APPLICATION = (byte)0x040;
 62     public static final byte TAG_CONTEXT = (byte)0x080;
 63     public static final byte TAG_PRIVATE = (byte)0x0c0;
 64 
<span class="line-modified"> 65     // tag of the value</span>
 66     public byte                 tag;
<span class="line-modified"> 67     // A ByteArrayOutputStream of content</span>
 68     protected DerInputBuffer    buffer;
<span class="line-modified"> 69     // Always new DerInputStream(buffer)</span>



 70     public final DerInputStream data;
<span class="line-modified"> 71     // The length of the value. Always the same as buffer.count.</span>
 72     private int                 length;
 73 
 74     /*
 75      * The type starts at the first byte of the encoding, and
 76      * is one of these tag_* values.  That may be all the type
 77      * data that is needed.
 78      */
 79 
 80     /*
 81      * These tags are the &quot;universal&quot; tags ... they mean the same
 82      * in all contexts.  (Mask with 0x1f -- five bits.)
 83      */
 84 
 85     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
 86     public static final byte    tag_Boolean = 0x01;
 87 
 88     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
 89     public static final byte    tag_Integer = 0x02;
 90 
 91     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
</pre>
<hr />
<pre>
195      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
196      */
197     public boolean isConstructed(byte constructedTag) {
198         if (!isConstructed()) {
199             return false;
200         }
201         return ((tag &amp; 0x01f) == constructedTag);
202     }
203 
204     /**
205      * Creates a PrintableString or UTF8string DER value from a string
206      */
207     public DerValue(String value) {
208         boolean isPrintableString = true;
209         for (int i = 0; i &lt; value.length(); i++) {
210             if (!isPrintableStringChar(value.charAt(i))) {
211                 isPrintableString = false;
212                 break;
213             }
214         }
<span class="line-modified">215         data = init(isPrintableString</span>
<span class="line-modified">216                 ? tag_PrintableString : tag_UTF8String, value);</span>
217     }
218 
219     /**
220      * Creates a string type DER value from a String object
221      * @param stringTag the tag for the DER value to create
222      * @param value the String object to use for the DER value
223      */
224     public DerValue(byte stringTag, String value) {
225         data = init(stringTag, value);
226     }
227 
228     // Creates a DerValue from a tag and some DER-encoded data w/ additional
229     // arg to control whether DER checks are enforced.
230     DerValue(byte tag, byte[] data, boolean allowBER) {
231         this.tag = tag;
232         buffer = new DerInputBuffer(data.clone(), allowBER);
233         length = data.length;
234         this.data = new DerInputStream(buffer);
235         this.data.mark(Integer.MAX_VALUE);
236     }
</pre>
<hr />
<pre>
255         tag = (byte)in.read();
256         byte lenByte = (byte)in.read();
257         length = DerInputStream.getLength(lenByte, in);
258         if (length == -1) {  // indefinite length encoding found
259             DerInputBuffer inbuf = in.dup();
260             inbuf = new DerInputBuffer(
261                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
262                     in.allowBER);
263             if (tag != inbuf.read())
264                 throw new IOException
265                         (&quot;Indefinite length encoding not supported&quot;);
266             length = DerInputStream.getDefiniteLength(inbuf);
267             buffer = inbuf.dup();
268             buffer.truncate(length);
269             data = new DerInputStream(buffer);
270             // indefinite form is encoded by sending a length field with a
271             // length of 0. - i.e. [1000|0000].
272             // the object is ended by sending two zero bytes.
273             in.skip(length + 2);
274         } else {

275             buffer = in.dup();
276             buffer.truncate(length);
277             data = new DerInputStream(buffer);
278 
279             in.skip(length);
280         }
281     }
282 
283     // Get an ASN.1/DER encoded datum from a buffer w/ additional
284     // arg to control whether DER checks are enforced.
285     DerValue(byte[] buf, boolean allowBER) throws IOException {
286         data = init(true, new ByteArrayInputStream(buf), allowBER);
287     }
288 
289     /**
290      * Get an ASN.1/DER encoded datum from a buffer.  The
291      * entire buffer must hold exactly one datum, including
292      * its tag and length.
293      *
294      * @param buf buffer holding a single DER-encoded datum.
295      */
296     public DerValue(byte[] buf) throws IOException {
297         this(buf, true);
298     }
299 
300     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
301     // arg to control whether DER checks are enforced.
302     DerValue(byte[] buf, int offset, int len, boolean allowBER)
<span class="line-modified">303             throws IOException {</span>
304         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
305     }
306 
307     /**
308      * Get an ASN.1/DER encoded datum from part of a buffer.
309      * That part of the buffer must hold exactly one datum, including
310      * its tag and length.
311      *
312      * @param buf the buffer
313      * @param offset start point of the single DER-encoded dataum
314      * @param len how many bytes are in the encoded datum
315      */
316     public DerValue(byte[] buf, int offset, int len) throws IOException {
317         this(buf, offset, len, true);
318     }
319 
320     // Get an ASN1/DER encoded datum from an input stream w/ additional
321     // arg to control whether DER checks are enforced.
322     DerValue(InputStream in, boolean allowBER) throws IOException {
323         data = init(false, in, allowBER);
</pre>
<hr />
<pre>
357             charset = UTF_8;
358             break;
359             // TBD: Need encoder for UniversalString before it can
360             // be handled.
361         default:
362             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
363         }
364 
365         byte[] buf = value.getBytes(charset);
366         length = buf.length;
367         buffer = new DerInputBuffer(buf, true);
368         DerInputStream result = new DerInputStream(buffer);
369         result.mark(Integer.MAX_VALUE);
370         return result;
371     }
372 
373     /*
374      * helper routine
375      */
376     private DerInputStream init(boolean fullyBuffered, InputStream in,
<span class="line-modified">377             boolean allowBER) throws IOException {</span>
378 
379         tag = (byte)in.read();
380         byte lenByte = (byte)in.read();
381         length = DerInputStream.getLength(lenByte, in);
382         if (length == -1) { // indefinite length encoding found
383             in = new ByteArrayInputStream(
384                     DerIndefLenConverter.convertStream(in, lenByte, tag));
<span class="line-modified">385             if (tag != in.read()) {</span>
386                 throw new IOException
387                         (&quot;Indefinite length encoding not supported&quot;);
<span class="line-added">388             }</span>
389             length = DerInputStream.getDefiniteLength(in);
390         }
391 
<span class="line-modified">392         if (fullyBuffered &amp;&amp; in.available() != length) {</span>
393             throw new IOException(&quot;extra data given to DerValue constructor&quot;);
<span class="line-added">394         }</span>
395 
396         byte[] bytes = IOUtils.readExactlyNBytes(in, length);
397 
398         buffer = new DerInputBuffer(bytes, allowBER);
399         return new DerInputStream(buffer);
400     }
401 
402     /**
403      * Encode an ASN1/DER encoded datum onto a DER output stream.
404      */
<span class="line-modified">405     public void encode(DerOutputStream out) {</span>

406         out.write(tag);
407         out.putLength(length);

408         if (length &gt; 0) {
409             byte[] value = new byte[length];
410             // always synchronized on data
411             synchronized (data) {
412                 buffer.reset();
<span class="line-modified">413                 try {</span>
<span class="line-modified">414                     if (buffer.read(value) != length) {</span>
<span class="line-added">415                         throw new IOException(&quot;short DER value read (encode)&quot;);</span>
<span class="line-added">416                     }</span>
<span class="line-added">417                 } catch (IOException e) {</span>
<span class="line-added">418                     // buffer should always have length bytes</span>
<span class="line-added">419                     throw new AssertionError(&quot;Should not happen&quot;);</span>
420                 }
421                 out.write(value);
422             }
423         }
424     }
425 
426     public final DerInputStream getData() {
427         return data;
428     }
429 
430     public final byte getTag() {
431         return tag;
432     }
433 
434     /**
435      * Returns an ASN.1 BOOLEAN
436      *
437      * @return the boolean held in this DER value
438      */
439     public boolean getBoolean() throws IOException {
440         if (tag != tag_Boolean) {
441             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
442         }
443         if (length != 1) {
444             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
445                                         + length);
446         }
447         if (buffer.read() != 0) {
448             return true;
449         }
450         return false;
451     }
452 
453     /**
454      * Returns an ASN.1 OBJECT IDENTIFIER.
455      *
456      * @return the OID held in this DER value
457      */
458     public ObjectIdentifier getOID() throws IOException {
<span class="line-modified">459         if (tag != tag_ObjectId) {</span>
460             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
<span class="line-added">461         }</span>
462         return new ObjectIdentifier(buffer);
463     }
464 
465     private byte[] append(byte[] a, byte[] b) {
<span class="line-modified">466         if (a == null) {</span>
467             return b;
<span class="line-added">468         }</span>
469 
470         byte[] ret = new byte[a.length + b.length];
471         System.arraycopy(a, 0, ret, 0, a.length);
472         System.arraycopy(b, 0, ret, a.length, b.length);
473 
474         return ret;
475     }
476 
477     /**
478      * Returns an ASN.1 OCTET STRING
479      *
480      * @return the octet string held in this DER value
481      */
482     public byte[] getOctetString() throws IOException {
483 
484         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
485             throw new IOException(
<span class="line-modified">486                     &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);</span>
487         }
488         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
489         // known bug that it returns -1 instead of 0.
490         if (length == 0) {
491             return new byte[0];
492         }
493 
494         // Only allocate the array if there are enough bytes available.
495         // This only works for ByteArrayInputStream.
496         // The assignment below ensures that buffer has the required type.
497         ByteArrayInputStream arrayInput = buffer;
498         if (arrayInput.available() &lt; length) {
499             throw new IOException(&quot;short read on DerValue buffer&quot;);
500         }
501         byte[] bytes = new byte[length];
502         arrayInput.read(bytes);
503 
504         if (isConstructed()) {
505             DerInputStream in = new DerInputStream(bytes, 0, bytes.length,
506                 buffer.allowBER);
</pre>
<hr />
<pre>
513     }
514 
515     /**
516      * Returns an ASN.1 INTEGER value as an integer.
517      *
518      * @return the integer held in this DER value.
519      */
520     public int getInteger() throws IOException {
521         if (tag != tag_Integer) {
522             throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);
523         }
524         return buffer.getInteger(data.available());
525     }
526 
527     /**
528      * Returns an ASN.1 INTEGER value as a BigInteger.
529      *
530      * @return the integer held in this DER value as a BigInteger.
531      */
532     public BigInteger getBigInteger() throws IOException {
<span class="line-modified">533         if (tag != tag_Integer) {</span>
534             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<span class="line-added">535         }</span>
536         return buffer.getBigInteger(data.available(), false);
537     }
538 
539     /**
540      * Returns an ASN.1 INTEGER value as a positive BigInteger.
541      * This is just to deal with implementations that incorrectly encode
542      * some values as negative.
543      *
544      * @return the integer held in this DER value as a BigInteger.
545      */
546     public BigInteger getPositiveBigInteger() throws IOException {
<span class="line-modified">547         if (tag != tag_Integer) {</span>
548             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<span class="line-added">549         }</span>
550         return buffer.getBigInteger(data.available(), true);
551     }
552 
553     /**
554      * Returns an ASN.1 ENUMERATED value.
555      *
556      * @return the integer held in this DER value.
557      */
558     public int getEnumerated() throws IOException {
559         if (tag != tag_Enumerated) {
560             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
561                                   + tag);
562         }
563         return buffer.getInteger(data.available());
564     }
565 
566     /**
567      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
568      *
569      * @return the bit string held in this value
570      */
571     public byte[] getBitString() throws IOException {
<span class="line-modified">572         if (tag != tag_BitString) {</span>
573             throw new IOException(
<span class="line-modified">574                     &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-modified">575         }</span>
576         return buffer.getBitString();
577     }
578 
579     /**
580      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
581      *
582      * @return a BitArray representing the bit string held in this value
583      */
584     public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified">585         if (tag != tag_BitString) {</span>
586             throw new IOException(
<span class="line-modified">587                     &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-modified">588         }</span>
589         return buffer.getUnalignedBitString();
590     }
591 
592     /**
593      * Returns the name component as a Java string, regardless of its
594      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
595      */
596     // TBD: Need encoder for UniversalString before it can be handled.
597     public String getAsString() throws IOException {
<span class="line-modified">598         if (tag == tag_UTF8String) {</span>
599             return getUTF8String();
<span class="line-modified">600         } else if (tag == tag_PrintableString) {</span>
601             return getPrintableString();
<span class="line-modified">602         } else if (tag == tag_T61String) {</span>
603             return getT61String();
<span class="line-modified">604         } else if (tag == tag_IA5String) {</span>
605             return getIA5String();
606         /*
<span class="line-modified">607           } else if (tag == tag_UniversalString) {</span>
608           return getUniversalString();
609         */
<span class="line-modified">610         } else if (tag == tag_BMPString) {</span>
611             return getBMPString();
<span class="line-modified">612         } else if (tag == tag_GeneralString) {</span>
613             return getGeneralString();
<span class="line-modified">614         } else {</span>
615             return null;
<span class="line-added">616         }</span>
617     }
618 
619     /**
620      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
621      * based on the parameter.  The bit string must be byte-aligned.
622      *
623      * @param tagImplicit if true, the tag is assumed implicit.
624      * @return the bit string held in this value
625      */
626     public byte[] getBitString(boolean tagImplicit) throws IOException {
627         if (!tagImplicit) {
<span class="line-modified">628             if (tag != tag_BitString) {</span>
629                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">630                         + tag);</span>
631             }
<span class="line-added">632         }</span>
633         return buffer.getBitString();
634     }
635 
636     /**
637      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
638      * based on the parameter.  The bit string need not be byte-aligned.
639      *
640      * @param tagImplicit if true, the tag is assumed implicit.
641      * @return the bit string held in this value
642      */
643     public BitArray getUnalignedBitString(boolean tagImplicit)
<span class="line-modified">644             throws IOException {</span>
645         if (!tagImplicit) {
<span class="line-modified">646             if (tag != tag_BitString) {</span>
647                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">648                         + tag);</span>
649             }
<span class="line-added">650         }</span>
651         return buffer.getUnalignedBitString();
652     }
653 
654     /**
655      * Helper routine to return all the bytes contained in the
656      * DerInputStream associated with this object.
657      */
658     public byte[] getDataBytes() throws IOException {
659         byte[] retVal = new byte[length];
660         synchronized (data) {
661             data.reset();
662             data.getBytes(retVal);
663         }
664         return retVal;
665     }
666 
667     /**
668      * Returns an ASN.1 STRING value
669      *
670      * @return the printable string held in this value
671      */
<span class="line-modified">672     public String getPrintableString() throws IOException {</span>
<span class="line-modified">673         if (tag != tag_PrintableString) {</span>

674             throw new IOException(
<span class="line-modified">675                     &quot;DerValue.getPrintableString, not a string &quot; + tag);</span>
<span class="line-modified">676         }</span>
677         return new String(getDataBytes(), US_ASCII);
678     }
679 
680     /**
681      * Returns an ASN.1 T61 (Teletype) STRING value
682      *
683      * @return the teletype string held in this value
684      */
685     public String getT61String() throws IOException {
<span class="line-modified">686         if (tag != tag_T61String) {</span>
<span class="line-modified">687             throw new IOException(&quot;DerValue.getT61String, not T61 &quot; + tag);</span>
<span class="line-modified">688         }</span>

689         return new String(getDataBytes(), ISO_8859_1);
690     }
691 
692     /**
693      * Returns an ASN.1 IA5 (ASCII) STRING value
694      *
695      * @return the ASCII string held in this value
696      */
697     public String getIA5String() throws IOException {
<span class="line-modified">698         if (tag != tag_IA5String) {</span>
<span class="line-modified">699             throw new IOException(&quot;DerValue.getIA5String, not IA5 &quot; + tag);</span>
<span class="line-modified">700         }</span>

701         return new String(getDataBytes(), US_ASCII);
702     }
703 
704     /**
705      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
706      *
707      * @return a string corresponding to the encoded BMPString held in
708      * this value
709      */
710     public String getBMPString() throws IOException {
<span class="line-modified">711         if (tag != tag_BMPString) {</span>
<span class="line-modified">712             throw new IOException(&quot;DerValue.getBMPString, not BMP &quot; + tag);</span>
<span class="line-modified">713         }</span>
<span class="line-modified">714         // BMPString is the same as Unicode in big endian, unmarked format.</span>


715         return new String(getDataBytes(), UTF_16BE);
716     }
717 
718     /**
719      * Returns the ASN.1 UTF-8 STRING value as a Java String.
720      *
721      * @return a string corresponding to the encoded UTF8String held in
722      * this value
723      */
724     public String getUTF8String() throws IOException {
<span class="line-modified">725         if (tag != tag_UTF8String) {</span>
<span class="line-modified">726             throw new IOException(&quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);</span>
<span class="line-modified">727         }</span>

728         return new String(getDataBytes(), UTF_8);
729     }
730 
731     /**
732      * Returns the ASN.1 GENERAL STRING value as a Java String.
733      *
734      * @return a string corresponding to the encoded GeneralString held in
735      * this value
736      */
737     public String getGeneralString() throws IOException {
<span class="line-modified">738         if (tag != tag_GeneralString) {</span>
739             throw new IOException(
<span class="line-modified">740                     &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);</span>
<span class="line-modified">741         }</span>
742         return new String(getDataBytes(), US_ASCII);
743     }
744 
745     /**
746      * Returns a Date if the DerValue is UtcTime.
747      *
748      * @return the Date held in this DER value
749      */
750     public Date getUTCTime() throws IOException {
751         if (tag != tag_UtcTime) {
752             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
753         }
754         return buffer.getUTCTime(data.available());
755     }
756 
757     /**
758      * Returns a Date if the DerValue is GeneralizedTime.
759      *
760      * @return the Date held in this DER value
761      */
</pre>
<hr />
<pre>
803     private static boolean doEquals(DerValue d1, DerValue d2) {
804         synchronized (d1.data) {
805             synchronized (d2.data) {
806                 d1.data.reset();
807                 d2.data.reset();
808                 return d1.buffer.equals(d2.buffer);
809             }
810         }
811     }
812 
813     /**
814      * Returns a printable representation of the value.
815      *
816      * @return printable representation of the value
817      */
818     @Override
819     public String toString() {
820         try {
821 
822             String str = getAsString();
<span class="line-modified">823             if (str != null) {</span>
824                 return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
<span class="line-modified">825             }</span>
<span class="line-added">826             if (tag == tag_Null) {</span>
827                 return &quot;[DerValue, null]&quot;;
<span class="line-modified">828             } else if (tag == tag_ObjectId) {</span>
829                 return &quot;OID.&quot; + getOID();
<span class="line-modified">830             } else {</span>
<span class="line-modified">831                 // integers</span>

832                 return &quot;[DerValue, tag = &quot; + tag
833                         + &quot;, length = &quot; + length + &quot;]&quot;;
<span class="line-added">834             }</span>
835         } catch (IOException e) {
836             throw new IllegalArgumentException(&quot;misformatted DER value&quot;);
837         }
838     }
839 
840     /**
841      * Returns a DER-encoded value, such that if it&#39;s passed to the
842      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
843      *
844      * @return DER-encoded value, including tag and length.
845      */
846     public byte[] toByteArray() throws IOException {
847         DerOutputStream out = new DerOutputStream();
848 
849         encode(out);
850         data.reset();
851         return out.toByteArray();
852     }
853 
854     /**
855      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
856      * to return a DER stream of the members of the set or sequence.
857      * This operation is not supported for primitive types such as
858      * integers or bit strings.
859      */
860     public DerInputStream toDerInputStream() throws IOException {
<span class="line-modified">861         if (tag == tag_Sequence || tag == tag_Set) {</span>
862             return new DerInputStream(buffer);
<span class="line-added">863         }</span>
864         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
865     }
866 
867     /**
868      * Get the length of the encoded value.
869      */
870     public int length() {
871         return length;
872     }
873 
874     /**
875      * Determine if a character is one of the permissible characters for
876      * PrintableString:
877      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
878      * plus sign, comma, hyphen, period, slash, colon, equals sign,
879      * and question mark.
880      *
881      * Characters that are *not* allowed in PrintableString include
882      * exclamation point, quotation mark, number sign, dollar sign,
883      * percent sign, ampersand, asterisk, semicolon, less than sign,
884      * greater than sign, at sign, left and right square brackets,
885      * backslash, circumflex (94), underscore, back quote (96),
886      * left and right curly brackets, vertical line, tilde,
887      * and the control codes (0-31 and 127).
888      *
889      * This list is based on X.680 (the ASN.1 spec).
890      */
891     public static boolean isPrintableStringChar(char ch) {
892         if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
<span class="line-modified">893                 (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {</span>
894             return true;
895         } else {
896             switch (ch) {
897                 case &#39; &#39;:       /* space */
898                 case &#39;\&#39;&#39;:      /* apostrophe */
899                 case &#39;(&#39;:       /* left paren */
900                 case &#39;)&#39;:       /* right paren */
901                 case &#39;+&#39;:       /* plus */
902                 case &#39;,&#39;:       /* comma */
903                 case &#39;-&#39;:       /* hyphen */
904                 case &#39;.&#39;:       /* period */
905                 case &#39;/&#39;:       /* slash */
906                 case &#39;:&#39;:       /* colon */
907                 case &#39;=&#39;:       /* equals */
908                 case &#39;?&#39;:       /* question mark */
909                     return true;
910                 default:
911                     return false;
912             }
913         }
</pre>
</td>
</tr>
</table>
<center><a href="DerOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="NamedCurve.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
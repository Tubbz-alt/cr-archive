diff a/src/java.base/share/classes/sun/security/util/DerOutputStream.java b/src/java.base/share/classes/sun/security/util/DerOutputStream.java
--- a/src/java.base/share/classes/sun/security/util/DerOutputStream.java
+++ b/src/java.base/share/classes/sun/security/util/DerOutputStream.java
@@ -24,12 +24,12 @@
  */
 
 package sun.security.util;
 
 import java.io.ByteArrayOutputStream;
-import java.io.OutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.TimeZone;
@@ -52,11 +52,11 @@
  * @author David Brownell
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
 public class DerOutputStream
-extends ByteArrayOutputStream implements DerEncoder {
+        extends ByteArrayOutputStream implements DerEncoder {
     /**
      * Construct an DER output stream.
      *
      * @param size how large a buffer to preallocate.
      */
@@ -74,11 +74,11 @@
      *
      * @param tag the DER value tag for the data, such as
      *          <em>DerValue.tag_Sequence</em>
      * @param buf buffered data, which must be DER-encoded
      */
-    public void write(byte tag, byte[] buf) throws IOException {
+    public void write(byte tag, byte[] buf) {
         write(tag);
         putLength(buf.length);
         write(buf, 0, buf.length);
     }
 
@@ -89,11 +89,11 @@
      *
      * @param tag the DER value tag for the data, such as
      *          <em>DerValue.tag_Sequence</em>
      * @param out buffered data
      */
-    public void write(byte tag, DerOutputStream out) throws IOException {
+    public void write(byte tag, DerOutputStream out) {
         write(tag);
         putLength(out.count);
         write(out.buf, 0, out.count);
     }
 
@@ -112,20 +112,19 @@
      * tagging it would be encoded as "A1 03 02 01 04".
      * Notice that the tag is A1 and not 81, this is because with
      * explicit tagging the form is always constructed.
      * @param value original value being implicitly tagged
      */
-    public void writeImplicit(byte tag, DerOutputStream value)
-    throws IOException {
+    public void writeImplicit(byte tag, DerOutputStream value) {
         write(tag);
         write(value.buf, 1, value.count-1);
     }
 
     /**
      * Marshals pre-encoded DER value onto the output stream.
      */
-    public void putDerValue(DerValue val) throws IOException {
+    public void putDerValue(DerValue val) {
         val.encode(this);
     }
 
     /*
      * PRIMITIVES -- these are "universal" ASN.1 simple types.
@@ -136,11 +135,11 @@
      */
 
     /**
      * Marshals a DER boolean on the output stream.
      */
-    public void putBoolean(boolean val) throws IOException {
+    public void putBoolean(boolean val) {
         write(DerValue.tag_Boolean);
         putLength(1);
         if (val) {
             write(0xff);
         } else {
@@ -150,45 +149,45 @@
 
     /**
      * Marshals a DER enumerated on the output stream.
      * @param i the enumerated value.
      */
-    public void putEnumerated(int i) throws IOException {
+    public void putEnumerated(int i) {
         write(DerValue.tag_Enumerated);
         putIntegerContents(i);
     }
 
     /**
      * Marshals a DER integer on the output stream.
      *
      * @param i the integer in the form of a BigInteger.
      */
-    public void putInteger(BigInteger i) throws IOException {
+    public void putInteger(BigInteger i) {
         write(DerValue.tag_Integer);
         byte[]    buf = i.toByteArray(); // least number  of bytes
         putLength(buf.length);
         write(buf, 0, buf.length);
     }
 
     /**
      * Marshals a DER integer on the output stream.
      * @param i the integer in the form of an Integer.
      */
-    public void putInteger(Integer i) throws IOException {
+    public void putInteger(Integer i) {
         putInteger(i.intValue());
     }
 
     /**
      * Marshals a DER integer on the output stream.
      * @param i the integer.
      */
-    public void putInteger(int i) throws IOException {
+    public void putInteger(int i) {
         write(DerValue.tag_Integer);
         putIntegerContents(i);
     }
 
-    private void putIntegerContents(int i) throws IOException {
+    private void putIntegerContents(int i) {
 
         byte[] bytes = new byte[4];
         int start = 0;
 
         // Obtain the four bytes of the int
@@ -204,41 +203,42 @@
         if (bytes[0] == (byte)0xff) {
 
             // Eliminate redundant 0xff
 
             for (int j = 0; j < 3; j++) {
-                if ((bytes[j] == (byte)0xff) &&
-                    ((bytes[j+1] & 0x80) == 0x80))
+                if ((bytes[j] == (byte)0xff) && ((bytes[j+1] & 0x80) == 0x80)) {
                     start++;
-                else
+                } else {
                     break;
+                }
              }
          } else if (bytes[0] == 0x00) {
 
              // Eliminate redundant 0x00
 
             for (int j = 0; j < 3; j++) {
-                if ((bytes[j] == 0x00) &&
-                    ((bytes[j+1] & 0x80) == 0))
+                if ((bytes[j] == 0x00) && ((bytes[j+1] & 0x80) == 0)) {
                     start++;
-                else
+                } else {
                     break;
+                }
             }
         }
 
         putLength(4 - start);
-        for (int k = start; k < 4; k++)
+        for (int k = start; k < 4; k++) {
             write(bytes[k]);
+        }
     }
 
     /**
      * Marshals a DER bit string on the output stream. The bit
      * string must be byte-aligned.
      *
      * @param bits the bit string, MSB first
      */
-    public void putBitString(byte[] bits) throws IOException {
+    public void putBitString(byte[] bits) {
         write(DerValue.tag_BitString);
         putLength(bits.length + 1);
         write(0);               // all of last octet is used
         write(bits);
     }
@@ -247,11 +247,11 @@
      * Marshals a DER bit string on the output stream.
      * The bit strings need not be byte-aligned.
      *
      * @param ba the bit string, MSB first
      */
-    public void putUnalignedBitString(BitArray ba) throws IOException {
+    public void putUnalignedBitString(BitArray ba) {
         byte[] bits = ba.toByteArray();
 
         write(DerValue.tag_BitString);
         putLength(bits.length + 1);
         write(bits.length*8 - ba.length()); // excess bits in last octet
@@ -262,69 +262,65 @@
      * Marshals a truncated DER bit string on the output stream.
      * The bit strings need not be byte-aligned.
      *
      * @param ba the bit string, MSB first
      */
-    public void putTruncatedUnalignedBitString(BitArray ba) throws IOException {
+    public void putTruncatedUnalignedBitString(BitArray ba) {
         putUnalignedBitString(ba.truncate());
     }
 
     /**
      * DER-encodes an ASN.1 OCTET STRING value on the output stream.
      *
      * @param octets the octet string
      */
-    public void putOctetString(byte[] octets) throws IOException {
+    public void putOctetString(byte[] octets) {
         write(DerValue.tag_OctetString, octets);
     }
 
     /**
      * Marshals a DER "null" value on the output stream.  These are
      * often used to indicate optional values which have been omitted.
      */
-    public void putNull() throws IOException {
+    public void putNull() {
         write(DerValue.tag_Null);
         putLength(0);
     }
 
     /**
      * Marshals an object identifier (OID) on the output stream.
      * Corresponds to the ASN.1 "OBJECT IDENTIFIER" construct.
      */
-    public void putOID(ObjectIdentifier oid) throws IOException {
+    public void putOID(ObjectIdentifier oid) {
         oid.encode(this);
     }
 
     /**
      * Marshals a sequence on the output stream.  This supports both
      * the ASN.1 "SEQUENCE" (zero to N values) and "SEQUENCE OF"
      * (one to N values) constructs.
      */
-    public void putSequence(DerValue[] seq) throws IOException {
+    public void putSequence(DerValue[] seq) {
         DerOutputStream bytes = new DerOutputStream();
-        int i;
-
-        for (i = 0; i < seq.length; i++)
+        for (int i = 0; i < seq.length; i++) {
             seq[i].encode(bytes);
-
+        }
         write(DerValue.tag_Sequence, bytes);
     }
 
     /**
      * Marshals the contents of a set on the output stream without
      * ordering the elements.  Ok for BER encoding, but not for DER
      * encoding.
      *
      * For DER encoding, use orderedPutSet() or orderedPutSetOf().
      */
-    public void putSet(DerValue[] set) throws IOException {
+    public void putSet(DerValue[] set) {
         DerOutputStream bytes = new DerOutputStream();
-        int i;
-
-        for (i = 0; i < set.length; i++)
+        for (int i = 0; i < set.length; i++) {
             set[i].encode(bytes);
-
+        }
         write(DerValue.tag_Set, bytes);
     }
 
     /**
      * Marshals the contents of a set on the output stream.  Sets
@@ -334,11 +330,11 @@
      * elements have the same DER encoding.
      *
      * This method supports the ASN.1 "SET OF" construct, but not
      * "SET", which uses a different order.
      */
-    public void putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {
+    public void putOrderedSetOf(byte tag, DerEncoder[] set) {
         putOrderedSet(tag, set, lexOrder);
     }
 
     /**
      * Marshals the contents of a set on the output stream.  Sets
@@ -348,11 +344,11 @@
      * elements have the same DER encoding.
      *
      * This method supports the ASN.1 "SET" construct, but not
      * "SET OF", which uses a different order.
      */
-    public void putOrderedSet(byte tag, DerEncoder[] set) throws IOException {
+    public void putOrderedSet(byte tag, DerEncoder[] set) {
         putOrderedSet(tag, set, tagOrder);
     }
 
     /**
      *  Lexicographical order comparison on byte arrays, for ordering
@@ -371,11 +367,11 @@
      * encodings of its sorted in increasing order.
      *
      * @param order the order to use when sorting encodings of components.
      */
     private void putOrderedSet(byte tag, DerEncoder[] set,
-                               Comparator<byte[]> order) throws IOException {
+                               Comparator<byte[]> order) {
         DerOutputStream[] streams = new DerOutputStream[set.length];
 
         for (int i = 0; i < set.length; i++) {
             streams[i] = new DerOutputStream();
             set[i].derEncode(streams[i]);
@@ -384,11 +380,11 @@
         // order the element encodings
         byte[][] bufs = new byte[streams.length][];
         for (int i = 0; i < streams.length; i++) {
             bufs[i] = streams[i].toByteArray();
         }
-        Arrays.<byte[]>sort(bufs, order);
+        Arrays.sort(bufs, order);
 
         DerOutputStream bytes = new DerOutputStream();
         for (int i = 0; i < streams.length; i++) {
             bytes.write(bufs[i]);
         }
@@ -397,98 +393,102 @@
     }
 
     /**
      * Marshals a string as a DER encoded UTF8String.
      */
-    public void putUTF8String(String s) throws IOException {
+    public void putUTF8String(String s) {
         writeString(s, DerValue.tag_UTF8String, UTF_8);
     }
 
     /**
      * Marshals a string as a DER encoded PrintableString.
      */
-    public void putPrintableString(String s) throws IOException {
+    public void putPrintableString(String s) {
         writeString(s, DerValue.tag_PrintableString, US_ASCII);
     }
 
     /**
      * Marshals a string as a DER encoded T61String.
      */
-    public void putT61String(String s) throws IOException {
+    public void putT61String(String s) {
         /*
          * Works for characters that are defined in both ASCII and
          * T61.
          */
         writeString(s, DerValue.tag_T61String, ISO_8859_1);
     }
 
     /**
      * Marshals a string as a DER encoded IA5String.
      */
-    public void putIA5String(String s) throws IOException {
+    public void putIA5String(String s) {
         writeString(s, DerValue.tag_IA5String, US_ASCII);
     }
 
     /**
      * Marshals a string as a DER encoded BMPString.
      */
-    public void putBMPString(String s) throws IOException {
+    public void putBMPString(String s) {
         writeString(s, DerValue.tag_BMPString, UTF_16BE);
     }
 
     /**
      * Marshals a string as a DER encoded GeneralString.
      */
-    public void putGeneralString(String s) throws IOException {
+    public void putGeneralString(String s) {
         writeString(s, DerValue.tag_GeneralString, US_ASCII);
     }
 
     /**
      * Private helper routine for writing DER encoded string values.
      * @param s the string to write
      * @param stringTag one of the DER string tags that indicate which
      * encoding should be used to write the string out.
-     * @param enc the name of the encoder that should be used corresponding
-     * to the above tag.
+     * @param charset the name of the character set to encode s
      */
-    private void writeString(String s, byte stringTag, Charset charset)
-        throws IOException {
+    private void writeString(String s, byte stringTag, Charset charset) {
 
         byte[] data = s.getBytes(charset);
         write(stringTag);
         putLength(data.length);
         write(data);
     }
 
+    // A direct copy of OutputStream::write(byte[]) but without throwing
+    // an exception.
+    public void write(byte b[]) {
+        write(b, 0, b.length);
+    }
+
     /**
      * Marshals a DER UTC time/date value.
      *
      * <P>YYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
      * and with seconds (even if seconds=0) as per RFC 5280.
      */
-    public void putUTCTime(Date d) throws IOException {
+    public void putUTCTime(Date d) {
         putTime(d, DerValue.tag_UtcTime);
     }
 
     /**
      * Marshals a DER Generalized Time/date value.
      *
      * <P>YYYYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
      * and with seconds (even if seconds=0) as per RFC 5280.
      */
-    public void putGeneralizedTime(Date d) throws IOException {
+    public void putGeneralizedTime(Date d) {
         putTime(d, DerValue.tag_GeneralizedTime);
     }
 
     /**
      * Private helper routine for marshalling a DER UTC/Generalized
      * time/date value. If the tag specified is not that for UTC Time
      * then it defaults to Generalized Time.
      * @param d the date to be marshalled
      * @param tag the tag for UTC Time or Generalized Time
      */
-    private void putTime(Date d, byte tag) throws IOException {
+    private void putTime(Date d, byte tag) {
 
         /*
          * Format the date.
          */
 
@@ -517,13 +517,12 @@
 
     /**
      * Put the encoding of the length in the stream.
      *
      * @param len the length of the attribute.
-     * @exception IOException on writing errors.
      */
-    public void putLength(int len) throws IOException {
+    public void putLength(int len) {
         if (len < 128) {
             write((byte)len);
 
         } else if (len < (1 << 8)) {
             write((byte)0x081);
@@ -564,15 +563,10 @@
             tag |= (byte)0x20;
         }
         write(tag);
     }
 
-    /**
-     *  Write the current contents of this <code>DerOutputStream</code>
-     *  to an <code>OutputStream</code>.
-     *
-     *  @exception IOException on output error.
-     */
-    public void derEncode(OutputStream out) throws IOException {
+    @Override
+    public void derEncode(DerOutputStream out) {
         out.write(toByteArray());
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/X509CRLEntryImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.x509;
 27 
 28 import java.io.IOException;
 29 import java.security.cert.CRLException;
 30 import java.security.cert.CRLReason;
 31 import java.security.cert.X509CRLEntry;
 32 import java.math.BigInteger;
 33 import java.util.*;
 34 
 35 import javax.security.auth.x500.X500Principal;
 36 
 37 import sun.security.util.*;
 38 import sun.security.util.HexDumpEncoder;
 39 
 40 /**
 41  * &lt;p&gt;Abstract class for a revoked certificate in a CRL.
 42  * This class is for each entry in the &lt;code&gt;revokedCertificates&lt;/code&gt;,
 43  * so it deals with the inner &lt;em&gt;SEQUENCE&lt;/em&gt;.
 44  * The ASN.1 definition for this is:
 45  * &lt;pre&gt;
 46  * revokedCertificates    SEQUENCE OF SEQUENCE  {
 47  *     userCertificate    CertificateSerialNumber,
 48  *     revocationDate     ChoiceOfTime,
 49  *     crlEntryExtensions Extensions OPTIONAL
 50  *                        -- if present, must be v2
 51  * }  OPTIONAL
 52  *
 53  * CertificateSerialNumber  ::=  INTEGER
 54  *
 55  * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
 56  *
 57  * Extension  ::=  SEQUENCE  {
 58  *     extnId        OBJECT IDENTIFIER,
 59  *     critical      BOOLEAN DEFAULT FALSE,
 60  *     extnValue     OCTET STRING
 61  *                   -- contains a DER encoding of a value
 62  *                   -- of the type registered for use with
 63  *                   -- the extnId object identifier value
 64  * }
 65  * &lt;/pre&gt;
 66  *
 67  * @author Hemma Prafullchandra
 68  */
 69 
 70 public class X509CRLEntryImpl extends X509CRLEntry
 71         implements Comparable&lt;X509CRLEntryImpl&gt; {
 72 
 73     private SerialNumber serialNumber = null;
 74     private Date revocationDate = null;
 75     private CRLExtensions extensions = null;
 76     private byte[] revokedCert = null;
 77     private X500Principal certIssuer;
 78 
 79     private static final boolean isExplicit = false;
 80 
 81     /**
 82      * Constructs a revoked certificate entry using the given
 83      * serial number and revocation date.
 84      *
 85      * @param num the serial number of the revoked certificate.
 86      * @param date the Date on which revocation took place.
 87      */
 88     public X509CRLEntryImpl(BigInteger num, Date date) {
 89         this.serialNumber = new SerialNumber(num);
 90         this.revocationDate = date;
 91     }
 92 
 93     /**
 94      * Constructs a revoked certificate entry using the given
 95      * serial number, revocation date and the entry
 96      * extensions.
 97      *
 98      * @param num the serial number of the revoked certificate.
 99      * @param date the Date on which revocation took place.
100      * @param crlEntryExts the extensions for this entry.
101      */
102     public X509CRLEntryImpl(BigInteger num, Date date,
103                            CRLExtensions crlEntryExts) {
104         this.serialNumber = new SerialNumber(num);
105         this.revocationDate = date;
106         this.extensions = crlEntryExts;
107     }
108 
109     /**
110      * Unmarshals a revoked certificate from its encoded form.
111      *
112      * @param revokedCert the encoded bytes.
113      * @exception CRLException on parsing errors.
114      */
115     public X509CRLEntryImpl(byte[] revokedCert) throws CRLException {
116         try {
117             parse(new DerValue(revokedCert));
118         } catch (IOException e) {
119             this.revokedCert = null;
120             throw new CRLException(&quot;Parsing error: &quot; + e.toString());
121         }
122     }
123 
124     /**
125      * Unmarshals a revoked certificate from its encoded form.
126      *
127      * @param derValue the DER value containing the revoked certificate.
128      * @exception CRLException on parsing errors.
129      */
130     public X509CRLEntryImpl(DerValue derValue) throws CRLException {
131         try {
132             parse(derValue);
133         } catch (IOException e) {
134             revokedCert = null;
135             throw new CRLException(&quot;Parsing error: &quot; + e.toString());
136         }
137     }
138 
139     /**
140      * Returns true if this revoked certificate entry has
141      * extensions, otherwise false.
142      *
143      * @return true if this CRL entry has extensions, otherwise
144      * false.
145      */
146     public boolean hasExtensions() {
147         return (extensions != null);
148     }
149 
150     /**
151      * Encodes the revoked certificate to an output stream.
152      *
153      * @param outStrm an output stream to which the encoded revoked
154      * certificate is written.
155      * @exception CRLException on encoding errors.
156      */
157     public void encode(DerOutputStream outStrm) throws CRLException {
<a name="1" id="anc1"></a><span class="line-modified">158         if (revokedCert == null) {</span>
<span class="line-modified">159             DerOutputStream tmp = new DerOutputStream();</span>
<span class="line-modified">160             // sequence { serialNumber, revocationDate, extensions }</span>
<span class="line-modified">161             serialNumber.encode(tmp);</span>
<span class="line-modified">162 </span>
<span class="line-modified">163             if (revocationDate.getTime() &lt; CertificateValidity.YR_2050) {</span>
<span class="line-modified">164                 tmp.putUTCTime(revocationDate);</span>
<span class="line-modified">165             } else {</span>
<span class="line-modified">166                 tmp.putGeneralizedTime(revocationDate);</span>
<span class="line-modified">167             }</span>

168 
<a name="2" id="anc2"></a><span class="line-modified">169             if (extensions != null)</span>
<span class="line-modified">170                 extensions.encode(tmp, isExplicit);</span>
171 
<a name="3" id="anc3"></a><span class="line-modified">172             DerOutputStream seq = new DerOutputStream();</span>
<span class="line-modified">173             seq.write(DerValue.tag_Sequence, tmp);</span>
174 
<a name="4" id="anc4"></a><span class="line-modified">175             revokedCert = seq.toByteArray();</span>




176         }
<a name="5" id="anc5"></a><span class="line-added">177         outStrm.write(revokedCert);</span>
178     }
179 
180     /**
181      * Returns the ASN.1 DER-encoded form of this CRL Entry,
182      * which corresponds to the inner SEQUENCE.
183      *
184      * @exception CRLException if an encoding error occurs.
185      */
186     public byte[] getEncoded() throws CRLException {
187         return getEncoded0().clone();
188     }
189 
190     // Called internally to avoid clone
191     private byte[] getEncoded0() throws CRLException {
192         if (revokedCert == null)
193             this.encode(new DerOutputStream());
194         return revokedCert;
195     }
196 
197     @Override
198     public X500Principal getCertificateIssuer() {
199         return certIssuer;
200     }
201 
202     void setCertificateIssuer(X500Principal crlIssuer, X500Principal certIssuer) {
203         if (crlIssuer.equals(certIssuer)) {
204             this.certIssuer = null;
205         } else {
206             this.certIssuer = certIssuer;
207         }
208     }
209 
210     /**
211      * Gets the serial number from this X509CRLEntry,
212      * i.e. the &lt;em&gt;userCertificate&lt;/em&gt;.
213      *
214      * @return the serial number.
215      */
216     public BigInteger getSerialNumber() {
217         return serialNumber.getNumber();
218     }
219 
220     /**
221      * Gets the revocation date from this X509CRLEntry,
222      * the &lt;em&gt;revocationDate&lt;/em&gt;.
223      *
224      * @return the revocation date.
225      */
226     public Date getRevocationDate() {
227         return new Date(revocationDate.getTime());
228     }
229 
230     /**
231      * This method is the overridden implementation of the getRevocationReason
232      * method in X509CRLEntry. It is better performance-wise since it returns
233      * cached values.
234      */
235     @Override
236     public CRLReason getRevocationReason() {
237         Extension ext = getExtension(PKIXExtensions.ReasonCode_Id);
238         if (ext == null) {
239             return null;
240         }
241         CRLReasonCodeExtension rcExt = (CRLReasonCodeExtension) ext;
242         return rcExt.getReasonCode();
243     }
244 
245     /**
246      * This static method is the default implementation of the
247      * getRevocationReason method in X509CRLEntry.
248      */
249     public static CRLReason getRevocationReason(X509CRLEntry crlEntry) {
250         try {
251             byte[] ext = crlEntry.getExtensionValue
252                     (KnownOIDs.ReasonCode.value());
253             if (ext == null) {
254                 return null;
255             }
256             DerValue val = new DerValue(ext);
257             byte[] data = val.getOctetString();
258 
259             CRLReasonCodeExtension rcExt =
260                 new CRLReasonCodeExtension(Boolean.FALSE, data);
261             return rcExt.getReasonCode();
262         } catch (IOException ioe) {
263             return null;
264         }
265     }
266 
267     /**
268      * get Reason Code from CRL entry.
269      *
270      * @return Integer or null, if no such extension
271      * @throws IOException on error
272      */
273     public Integer getReasonCode() throws IOException {
274         Object obj = getExtension(PKIXExtensions.ReasonCode_Id);
275         if (obj == null)
276             return null;
277         CRLReasonCodeExtension reasonCode = (CRLReasonCodeExtension)obj;
278         return reasonCode.get(CRLReasonCodeExtension.REASON);
279     }
280 
281     /**
282      * Returns a printable string of this revoked certificate.
283      *
284      * @return value of this revoked certificate in a printable form.
285      */
286     @Override
287     public String toString() {
288         StringBuilder sb = new StringBuilder();
289 
290         sb.append(serialNumber)
291             .append(&quot;  On: &quot;)
292             .append(revocationDate);
293         if (certIssuer != null) {
294             sb.append(&quot;\n    Certificate issuer: &quot;)
295                 .append(certIssuer);
296         }
297         if (extensions != null) {
298             Collection&lt;Extension&gt; allEntryExts = extensions.getAllExtensions();
299             Extension[] exts = allEntryExts.toArray(new Extension[0]);
300 
301             sb.append(&quot;\n    CRL Entry Extensions: &quot;)
302                 .append(exts.length);
303             for (int i = 0; i &lt; exts.length; i++) {
304                 sb.append(&quot;\n    [&quot;)
305                     .append(i+1)
306                     .append(&quot;]: &quot;);
307                 Extension ext = exts[i];
308                 try {
309                     if (OIDMap.getClass(ext.getExtensionId()) == null) {
310                         sb.append(ext);
311                         byte[] extValue = ext.getExtensionValue();
312                         if (extValue != null) {
313                             DerOutputStream out = new DerOutputStream();
314                             out.putOctetString(extValue);
315                             extValue = out.toByteArray();
316                             HexDumpEncoder enc = new HexDumpEncoder();
317                             sb.append(&quot;Extension unknown: &quot;)
318                                 .append(&quot;DER encoded OCTET string =\n&quot;)
319                                 .append(enc.encodeBuffer(extValue))
320                                 .append(&#39;\n&#39;);
321                         }
322                     } else {
323                         sb.append(ext); //sub-class exists
324                     }
325                 } catch (Exception e) {
326                     sb.append(&quot;, Error parsing this extension&quot;);
327                 }
328             }
329         }
330         sb.append(&#39;\n&#39;);
331         return sb.toString();
332     }
333 
334     /**
335      * Return true if a critical extension is found that is
336      * not supported, otherwise return false.
337      */
338     public boolean hasUnsupportedCriticalExtension() {
339         if (extensions == null)
340             return false;
341         return extensions.hasUnsupportedCriticalExtension();
342     }
343 
344     /**
345      * Gets a Set of the extension(s) marked CRITICAL in this
346      * X509CRLEntry.  In the returned set, each extension is
347      * represented by its OID string.
348      *
349      * @return a set of the extension oid strings in the
350      * Object that are marked critical.
351      */
352     public Set&lt;String&gt; getCriticalExtensionOIDs() {
353         if (extensions == null) {
354             return null;
355         }
356         Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
357         for (Extension ex : extensions.getAllExtensions()) {
358             if (ex.isCritical()) {
359                 extSet.add(ex.getExtensionId().toString());
360             }
361         }
362         return extSet;
363     }
364 
365     /**
366      * Gets a Set of the extension(s) marked NON-CRITICAL in this
367      * X509CRLEntry. In the returned set, each extension is
368      * represented by its OID string.
369      *
370      * @return a set of the extension oid strings in the
371      * Object that are marked critical.
372      */
373     public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
374         if (extensions == null) {
375             return null;
376         }
377         Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
378         for (Extension ex : extensions.getAllExtensions()) {
379             if (!ex.isCritical()) {
380                 extSet.add(ex.getExtensionId().toString());
381             }
382         }
383         return extSet;
384     }
385 
386     /**
387      * Gets the DER encoded OCTET string for the extension value
388      * (&lt;em&gt;extnValue&lt;/em&gt;) identified by the passed in oid String.
389      * The &lt;code&gt;oid&lt;/code&gt; string is
390      * represented by a set of positive whole number separated
391      * by &quot;.&quot;, that means,&lt;br&gt;
392      * &amp;lt;positive whole number&amp;gt;.&amp;lt;positive whole number&amp;gt;.&amp;lt;positive
393      * whole number&amp;gt;.&amp;lt;...&amp;gt;
394      *
395      * @param oid the Object Identifier value for the extension.
396      * @return the DER encoded octet string of the extension value.
397      */
398     public byte[] getExtensionValue(String oid) {
399         if (extensions == null)
400             return null;
401         try {
402             String extAlias = OIDMap.getName(ObjectIdentifier.of(oid));
403             Extension crlExt = null;
404 
405             if (extAlias == null) { // may be unknown
406                 ObjectIdentifier findOID = ObjectIdentifier.of(oid);
407                 Extension ex = null;
408                 ObjectIdentifier inCertOID;
409                 for (Enumeration&lt;Extension&gt; e = extensions.getElements();
410                                                  e.hasMoreElements();) {
411                     ex = e.nextElement();
412                     inCertOID = ex.getExtensionId();
413                     if (inCertOID.equals(findOID)) {
414                         crlExt = ex;
415                         break;
416                     }
417                 }
418             } else
419                 crlExt = extensions.get(extAlias);
420             if (crlExt == null)
421                 return null;
422             byte[] extData = crlExt.getExtensionValue();
423             if (extData == null)
424                 return null;
425 
426             DerOutputStream out = new DerOutputStream();
427             out.putOctetString(extData);
428             return out.toByteArray();
429         } catch (Exception e) {
430             return null;
431         }
432     }
433 
434     /**
435      * get an extension
436      *
437      * @param oid ObjectIdentifier of extension desired
438      * @return Extension of type {@code &lt;extension&gt;} or null, if not found
439      */
440     public Extension getExtension(ObjectIdentifier oid) {
441         if (extensions == null)
442             return null;
443 
444         // following returns null if no such OID in map
445         //XXX consider cloning this
446         return extensions.get(OIDMap.getName(oid));
447     }
448 
449     private void parse(DerValue derVal)
450     throws CRLException, IOException {
451 
452         if (derVal.tag != DerValue.tag_Sequence) {
453             throw new CRLException(&quot;Invalid encoded RevokedCertificate, &quot; +
454                                   &quot;starting sequence tag missing.&quot;);
455         }
456         if (derVal.data.available() == 0)
457             throw new CRLException(&quot;No data encoded for RevokedCertificates&quot;);
458 
459         revokedCert = derVal.toByteArray();
460         // serial number
461         DerInputStream in = derVal.toDerInputStream();
462         DerValue val = in.getDerValue();
463         this.serialNumber = new SerialNumber(val);
464 
465         // revocationDate
466         int nextByte = derVal.data.peekByte();
467         if ((byte)nextByte == DerValue.tag_UtcTime) {
468             this.revocationDate = derVal.data.getUTCTime();
469         } else if ((byte)nextByte == DerValue.tag_GeneralizedTime) {
470             this.revocationDate = derVal.data.getGeneralizedTime();
471         } else
472             throw new CRLException(&quot;Invalid encoding for revocation date&quot;);
473 
474         if (derVal.data.available() == 0)
475             return;  // no extensions
476 
477         // crlEntryExtensions
478         this.extensions = new CRLExtensions(derVal.toDerInputStream());
479     }
480 
481     /**
482      * Utility method to convert an arbitrary instance of X509CRLEntry
483      * to a X509CRLEntryImpl. Does a cast if possible, otherwise reparses
484      * the encoding.
485      */
486     public static X509CRLEntryImpl toImpl(X509CRLEntry entry)
487             throws CRLException {
488         if (entry instanceof X509CRLEntryImpl) {
489             return (X509CRLEntryImpl)entry;
490         } else {
491             return new X509CRLEntryImpl(entry.getEncoded());
492         }
493     }
494 
495     /**
496      * Returns the CertificateIssuerExtension
497      *
498      * @return the CertificateIssuerExtension, or null if it does not exist
499      */
500     CertificateIssuerExtension getCertificateIssuerExtension() {
501         return (CertificateIssuerExtension)
502             getExtension(PKIXExtensions.CertificateIssuer_Id);
503     }
504 
505     /**
506      * Returns all extensions for this entry in a map
507      * @return the extension map, can be empty, but not null
508      */
509     public Map&lt;String, java.security.cert.Extension&gt; getExtensions() {
510         if (extensions == null) {
511             return Collections.emptyMap();
512         }
513         Collection&lt;Extension&gt; exts = extensions.getAllExtensions();
514         Map&lt;String, java.security.cert.Extension&gt; map = new TreeMap&lt;&gt;();
515         for (Extension ext : exts) {
516             map.put(ext.getId(), ext);
517         }
518         return map;
519     }
520 
521     @Override
522     public int compareTo(X509CRLEntryImpl that) {
523         int compSerial = getSerialNumber().compareTo(that.getSerialNumber());
524         if (compSerial != 0) {
525             return compSerial;
526         }
527         try {
528             byte[] thisEncoded = this.getEncoded0();
529             byte[] thatEncoded = that.getEncoded0();
530             for (int i=0; i&lt;thisEncoded.length &amp;&amp; i&lt;thatEncoded.length; i++) {
531                 int a = thisEncoded[i] &amp; 0xff;
532                 int b = thatEncoded[i] &amp; 0xff;
533                 if (a != b) return a-b;
534             }
535             return thisEncoded.length -thatEncoded.length;
536         } catch (CRLException ce) {
537             return -1;
538         }
539     }
540 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
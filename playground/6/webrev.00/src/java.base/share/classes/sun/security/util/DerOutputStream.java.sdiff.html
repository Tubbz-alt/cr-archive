<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerValue.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.ByteArrayOutputStream;
<span class="line-removed"> 29 import java.io.OutputStream;</span>
 30 import java.io.IOException;

 31 import java.math.BigInteger;
 32 import java.nio.charset.Charset;
 33 import java.text.SimpleDateFormat;
 34 import java.util.Date;
 35 import java.util.TimeZone;
 36 import java.util.Comparator;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 
 40 import static java.nio.charset.StandardCharsets.*;
 41 
 42 /**
 43  * Output stream marshaling DER-encoded data.  This is eventually provided
 44  * in the form of a byte array; there is no advance limit on the size of
 45  * that byte array.
 46  *
 47  * &lt;P&gt;At this time, this class supports only a subset of the types of
 48  * DER data encodings which are defined.  That subset is sufficient for
 49  * generating most X.509 certificates.
 50  *
 51  *
 52  * @author David Brownell
 53  * @author Amit Kapoor
 54  * @author Hemma Prafullchandra
 55  */
 56 public class DerOutputStream
<span class="line-modified"> 57 extends ByteArrayOutputStream implements DerEncoder {</span>
 58     /**
 59      * Construct an DER output stream.
 60      *
 61      * @param size how large a buffer to preallocate.
 62      */
 63     public DerOutputStream(int size) { super(size); }
 64 
 65     /**
 66      * Construct an DER output stream.
 67      */
 68     public DerOutputStream() { }
 69 
 70     /**
 71      * Writes tagged, pre-marshaled data.  This calcuates and encodes
 72      * the length, so that the output data is the standard triple of
 73      * { tag, length, data } used by all DER values.
 74      *
 75      * @param tag the DER value tag for the data, such as
 76      *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
 77      * @param buf buffered data, which must be DER-encoded
 78      */
<span class="line-modified"> 79     public void write(byte tag, byte[] buf) throws IOException {</span>
 80         write(tag);
 81         putLength(buf.length);
 82         write(buf, 0, buf.length);
 83     }
 84 
 85     /**
 86      * Writes tagged data using buffer-to-buffer copy.  As above,
 87      * this writes a standard DER record.  This is often used when
 88      * efficiently encapsulating values in sequences.
 89      *
 90      * @param tag the DER value tag for the data, such as
 91      *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
 92      * @param out buffered data
 93      */
<span class="line-modified"> 94     public void write(byte tag, DerOutputStream out) throws IOException {</span>
 95         write(tag);
 96         putLength(out.count);
 97         write(out.buf, 0, out.count);
 98     }
 99 
100     /**
101      * Writes implicitly tagged data using buffer-to-buffer copy.  As above,
102      * this writes a standard DER record.  This is often used when
103      * efficiently encapsulating implicitly tagged values.
104      *
105      * @param tag the DER value of the context-specific tag that replaces
106      * original tag of the value in the output, such as in
107      * &lt;pre&gt;
108      *          &lt;em&gt; {@code &lt;field&gt; [N] IMPLICIT &lt;type&gt;}&lt;/em&gt;
109      * &lt;/pre&gt;
110      * For example, &lt;em&gt;FooLength [1] IMPLICIT INTEGER&lt;/em&gt;, with value=4;
111      * would be encoded as &quot;81 01 04&quot;  whereas in explicit
112      * tagging it would be encoded as &quot;A1 03 02 01 04&quot;.
113      * Notice that the tag is A1 and not 81, this is because with
114      * explicit tagging the form is always constructed.
115      * @param value original value being implicitly tagged
116      */
<span class="line-modified">117     public void writeImplicit(byte tag, DerOutputStream value)</span>
<span class="line-removed">118     throws IOException {</span>
119         write(tag);
120         write(value.buf, 1, value.count-1);
121     }
122 
123     /**
124      * Marshals pre-encoded DER value onto the output stream.
125      */
<span class="line-modified">126     public void putDerValue(DerValue val) throws IOException {</span>
127         val.encode(this);
128     }
129 
130     /*
131      * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.
132      *
133      *  BOOLEAN, INTEGER, BIT STRING, OCTET STRING, NULL
134      *  OBJECT IDENTIFIER, SEQUENCE(OF), SET(OF)
135      *  PrintableString, T61String, IA5String, UTCTime
136      */
137 
138     /**
139      * Marshals a DER boolean on the output stream.
140      */
<span class="line-modified">141     public void putBoolean(boolean val) throws IOException {</span>
142         write(DerValue.tag_Boolean);
143         putLength(1);
144         if (val) {
145             write(0xff);
146         } else {
147             write(0);
148         }
149     }
150 
151     /**
152      * Marshals a DER enumerated on the output stream.
153      * @param i the enumerated value.
154      */
<span class="line-modified">155     public void putEnumerated(int i) throws IOException {</span>
156         write(DerValue.tag_Enumerated);
157         putIntegerContents(i);
158     }
159 
160     /**
161      * Marshals a DER integer on the output stream.
162      *
163      * @param i the integer in the form of a BigInteger.
164      */
<span class="line-modified">165     public void putInteger(BigInteger i) throws IOException {</span>
166         write(DerValue.tag_Integer);
167         byte[]    buf = i.toByteArray(); // least number  of bytes
168         putLength(buf.length);
169         write(buf, 0, buf.length);
170     }
171 
172     /**
173      * Marshals a DER integer on the output stream.
174      * @param i the integer in the form of an Integer.
175      */
<span class="line-modified">176     public void putInteger(Integer i) throws IOException {</span>
177         putInteger(i.intValue());
178     }
179 
180     /**
181      * Marshals a DER integer on the output stream.
182      * @param i the integer.
183      */
<span class="line-modified">184     public void putInteger(int i) throws IOException {</span>
185         write(DerValue.tag_Integer);
186         putIntegerContents(i);
187     }
188 
<span class="line-modified">189     private void putIntegerContents(int i) throws IOException {</span>
190 
191         byte[] bytes = new byte[4];
192         int start = 0;
193 
194         // Obtain the four bytes of the int
195 
196         bytes[3] = (byte) (i &amp; 0xff);
197         bytes[2] = (byte)((i &amp; 0xff00) &gt;&gt;&gt; 8);
198         bytes[1] = (byte)((i &amp; 0xff0000) &gt;&gt;&gt; 16);
199         bytes[0] = (byte)((i &amp; 0xff000000) &gt;&gt;&gt; 24);
200 
201         // Reduce them to the least number of bytes needed to
202         // represent this int
203 
204         if (bytes[0] == (byte)0xff) {
205 
206             // Eliminate redundant 0xff
207 
208             for (int j = 0; j &lt; 3; j++) {
<span class="line-modified">209                 if ((bytes[j] == (byte)0xff) &amp;&amp;</span>
<span class="line-removed">210                     ((bytes[j+1] &amp; 0x80) == 0x80))</span>
211                     start++;
<span class="line-modified">212                 else</span>
213                     break;

214              }
215          } else if (bytes[0] == 0x00) {
216 
217              // Eliminate redundant 0x00
218 
219             for (int j = 0; j &lt; 3; j++) {
<span class="line-modified">220                 if ((bytes[j] == 0x00) &amp;&amp;</span>
<span class="line-removed">221                     ((bytes[j+1] &amp; 0x80) == 0))</span>
222                     start++;
<span class="line-modified">223                 else</span>
224                     break;

225             }
226         }
227 
228         putLength(4 - start);
<span class="line-modified">229         for (int k = start; k &lt; 4; k++)</span>
230             write(bytes[k]);

231     }
232 
233     /**
234      * Marshals a DER bit string on the output stream. The bit
235      * string must be byte-aligned.
236      *
237      * @param bits the bit string, MSB first
238      */
<span class="line-modified">239     public void putBitString(byte[] bits) throws IOException {</span>
240         write(DerValue.tag_BitString);
241         putLength(bits.length + 1);
242         write(0);               // all of last octet is used
243         write(bits);
244     }
245 
246     /**
247      * Marshals a DER bit string on the output stream.
248      * The bit strings need not be byte-aligned.
249      *
250      * @param ba the bit string, MSB first
251      */
<span class="line-modified">252     public void putUnalignedBitString(BitArray ba) throws IOException {</span>
253         byte[] bits = ba.toByteArray();
254 
255         write(DerValue.tag_BitString);
256         putLength(bits.length + 1);
257         write(bits.length*8 - ba.length()); // excess bits in last octet
258         write(bits);
259     }
260 
261     /**
262      * Marshals a truncated DER bit string on the output stream.
263      * The bit strings need not be byte-aligned.
264      *
265      * @param ba the bit string, MSB first
266      */
<span class="line-modified">267     public void putTruncatedUnalignedBitString(BitArray ba) throws IOException {</span>
268         putUnalignedBitString(ba.truncate());
269     }
270 
271     /**
272      * DER-encodes an ASN.1 OCTET STRING value on the output stream.
273      *
274      * @param octets the octet string
275      */
<span class="line-modified">276     public void putOctetString(byte[] octets) throws IOException {</span>
277         write(DerValue.tag_OctetString, octets);
278     }
279 
280     /**
281      * Marshals a DER &quot;null&quot; value on the output stream.  These are
282      * often used to indicate optional values which have been omitted.
283      */
<span class="line-modified">284     public void putNull() throws IOException {</span>
285         write(DerValue.tag_Null);
286         putLength(0);
287     }
288 
289     /**
290      * Marshals an object identifier (OID) on the output stream.
291      * Corresponds to the ASN.1 &quot;OBJECT IDENTIFIER&quot; construct.
292      */
<span class="line-modified">293     public void putOID(ObjectIdentifier oid) throws IOException {</span>
294         oid.encode(this);
295     }
296 
297     /**
298      * Marshals a sequence on the output stream.  This supports both
299      * the ASN.1 &quot;SEQUENCE&quot; (zero to N values) and &quot;SEQUENCE OF&quot;
300      * (one to N values) constructs.
301      */
<span class="line-modified">302     public void putSequence(DerValue[] seq) throws IOException {</span>
303         DerOutputStream bytes = new DerOutputStream();
<span class="line-modified">304         int i;</span>
<span class="line-removed">305 </span>
<span class="line-removed">306         for (i = 0; i &lt; seq.length; i++)</span>
307             seq[i].encode(bytes);
<span class="line-modified">308 </span>
309         write(DerValue.tag_Sequence, bytes);
310     }
311 
312     /**
313      * Marshals the contents of a set on the output stream without
314      * ordering the elements.  Ok for BER encoding, but not for DER
315      * encoding.
316      *
317      * For DER encoding, use orderedPutSet() or orderedPutSetOf().
318      */
<span class="line-modified">319     public void putSet(DerValue[] set) throws IOException {</span>
320         DerOutputStream bytes = new DerOutputStream();
<span class="line-modified">321         int i;</span>
<span class="line-removed">322 </span>
<span class="line-removed">323         for (i = 0; i &lt; set.length; i++)</span>
324             set[i].encode(bytes);
<span class="line-modified">325 </span>
326         write(DerValue.tag_Set, bytes);
327     }
328 
329     /**
330      * Marshals the contents of a set on the output stream.  Sets
331      * are semantically unordered, but DER requires that encodings of
332      * set elements be sorted into ascending lexicographical order
333      * before being output.  Hence sets with the same tags and
334      * elements have the same DER encoding.
335      *
336      * This method supports the ASN.1 &quot;SET OF&quot; construct, but not
337      * &quot;SET&quot;, which uses a different order.
338      */
<span class="line-modified">339     public void putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {</span>
340         putOrderedSet(tag, set, lexOrder);
341     }
342 
343     /**
344      * Marshals the contents of a set on the output stream.  Sets
345      * are semantically unordered, but DER requires that encodings of
346      * set elements be sorted into ascending tag order
347      * before being output.  Hence sets with the same tags and
348      * elements have the same DER encoding.
349      *
350      * This method supports the ASN.1 &quot;SET&quot; construct, but not
351      * &quot;SET OF&quot;, which uses a different order.
352      */
<span class="line-modified">353     public void putOrderedSet(byte tag, DerEncoder[] set) throws IOException {</span>
354         putOrderedSet(tag, set, tagOrder);
355     }
356 
357     /**
358      *  Lexicographical order comparison on byte arrays, for ordering
359      *  elements of a SET OF objects in DER encoding.
360      */
361     private static ByteArrayLexOrder lexOrder = new ByteArrayLexOrder();
362 
363     /**
364      *  Tag order comparison on byte arrays, for ordering elements of
365      *  SET objects in DER encoding.
366      */
367     private static ByteArrayTagOrder tagOrder = new ByteArrayTagOrder();
368 
369     /**
370      * Marshals a the contents of a set on the output stream with the
371      * encodings of its sorted in increasing order.
372      *
373      * @param order the order to use when sorting encodings of components.
374      */
375     private void putOrderedSet(byte tag, DerEncoder[] set,
<span class="line-modified">376                                Comparator&lt;byte[]&gt; order) throws IOException {</span>
377         DerOutputStream[] streams = new DerOutputStream[set.length];
378 
379         for (int i = 0; i &lt; set.length; i++) {
380             streams[i] = new DerOutputStream();
381             set[i].derEncode(streams[i]);
382         }
383 
384         // order the element encodings
385         byte[][] bufs = new byte[streams.length][];
386         for (int i = 0; i &lt; streams.length; i++) {
387             bufs[i] = streams[i].toByteArray();
388         }
<span class="line-modified">389         Arrays.&lt;byte[]&gt;sort(bufs, order);</span>
390 
391         DerOutputStream bytes = new DerOutputStream();
392         for (int i = 0; i &lt; streams.length; i++) {
393             bytes.write(bufs[i]);
394         }
395         write(tag, bytes);
396 
397     }
398 
399     /**
400      * Marshals a string as a DER encoded UTF8String.
401      */
<span class="line-modified">402     public void putUTF8String(String s) throws IOException {</span>
403         writeString(s, DerValue.tag_UTF8String, UTF_8);
404     }
405 
406     /**
407      * Marshals a string as a DER encoded PrintableString.
408      */
<span class="line-modified">409     public void putPrintableString(String s) throws IOException {</span>
410         writeString(s, DerValue.tag_PrintableString, US_ASCII);
411     }
412 
413     /**
414      * Marshals a string as a DER encoded T61String.
415      */
<span class="line-modified">416     public void putT61String(String s) throws IOException {</span>
417         /*
418          * Works for characters that are defined in both ASCII and
419          * T61.
420          */
421         writeString(s, DerValue.tag_T61String, ISO_8859_1);
422     }
423 
424     /**
425      * Marshals a string as a DER encoded IA5String.
426      */
<span class="line-modified">427     public void putIA5String(String s) throws IOException {</span>
428         writeString(s, DerValue.tag_IA5String, US_ASCII);
429     }
430 
431     /**
432      * Marshals a string as a DER encoded BMPString.
433      */
<span class="line-modified">434     public void putBMPString(String s) throws IOException {</span>
435         writeString(s, DerValue.tag_BMPString, UTF_16BE);
436     }
437 
438     /**
439      * Marshals a string as a DER encoded GeneralString.
440      */
<span class="line-modified">441     public void putGeneralString(String s) throws IOException {</span>
442         writeString(s, DerValue.tag_GeneralString, US_ASCII);
443     }
444 
445     /**
446      * Private helper routine for writing DER encoded string values.
447      * @param s the string to write
448      * @param stringTag one of the DER string tags that indicate which
449      * encoding should be used to write the string out.
<span class="line-modified">450      * @param enc the name of the encoder that should be used corresponding</span>
<span class="line-removed">451      * to the above tag.</span>
452      */
<span class="line-modified">453     private void writeString(String s, byte stringTag, Charset charset)</span>
<span class="line-removed">454         throws IOException {</span>
455 
456         byte[] data = s.getBytes(charset);
457         write(stringTag);
458         putLength(data.length);
459         write(data);
460     }
461 






462     /**
463      * Marshals a DER UTC time/date value.
464      *
465      * &lt;P&gt;YYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
466      * and with seconds (even if seconds=0) as per RFC 5280.
467      */
<span class="line-modified">468     public void putUTCTime(Date d) throws IOException {</span>
469         putTime(d, DerValue.tag_UtcTime);
470     }
471 
472     /**
473      * Marshals a DER Generalized Time/date value.
474      *
475      * &lt;P&gt;YYYYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
476      * and with seconds (even if seconds=0) as per RFC 5280.
477      */
<span class="line-modified">478     public void putGeneralizedTime(Date d) throws IOException {</span>
479         putTime(d, DerValue.tag_GeneralizedTime);
480     }
481 
482     /**
483      * Private helper routine for marshalling a DER UTC/Generalized
484      * time/date value. If the tag specified is not that for UTC Time
485      * then it defaults to Generalized Time.
486      * @param d the date to be marshalled
487      * @param tag the tag for UTC Time or Generalized Time
488      */
<span class="line-modified">489     private void putTime(Date d, byte tag) throws IOException {</span>
490 
491         /*
492          * Format the date.
493          */
494 
495         TimeZone tz = TimeZone.getTimeZone(&quot;GMT&quot;);
496         String pattern = null;
497 
498         if (tag == DerValue.tag_UtcTime) {
499             pattern = &quot;yyMMddHHmmss&#39;Z&#39;&quot;;
500         } else {
501             tag = DerValue.tag_GeneralizedTime;
502             pattern = &quot;yyyyMMddHHmmss&#39;Z&#39;&quot;;
503         }
504 
505         SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.US);
506         sdf.setTimeZone(tz);
507         byte[] time = (sdf.format(d)).getBytes(ISO_8859_1);
508 
509         /*
510          * Write the formatted date.
511          */
512 
513         write(tag);
514         putLength(time.length);
515         write(time);
516     }
517 
518     /**
519      * Put the encoding of the length in the stream.
520      *
521      * @param len the length of the attribute.
<span class="line-removed">522      * @exception IOException on writing errors.</span>
523      */
<span class="line-modified">524     public void putLength(int len) throws IOException {</span>
525         if (len &lt; 128) {
526             write((byte)len);
527 
528         } else if (len &lt; (1 &lt;&lt; 8)) {
529             write((byte)0x081);
530             write((byte)len);
531 
532         } else if (len &lt; (1 &lt;&lt; 16)) {
533             write((byte)0x082);
534             write((byte)(len &gt;&gt; 8));
535             write((byte)len);
536 
537         } else if (len &lt; (1 &lt;&lt; 24)) {
538             write((byte)0x083);
539             write((byte)(len &gt;&gt; 16));
540             write((byte)(len &gt;&gt; 8));
541             write((byte)len);
542 
543         } else {
544             write((byte)0x084);
</pre>
<hr />
<pre>
549         }
550     }
551 
552     /**
553      * Put the tag of the attribute in the stream.
554      *
555      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
556      *        APPLICATION or PRIVATE
557      * @param form if true, the value is constructed, otherwise it is
558      * primitive.
559      * @param val the tag value
560      */
561     public void putTag(byte tagClass, boolean form, byte val) {
562         byte tag = (byte)(tagClass | val);
563         if (form) {
564             tag |= (byte)0x20;
565         }
566         write(tag);
567     }
568 
<span class="line-modified">569     /**</span>
<span class="line-modified">570      *  Write the current contents of this &lt;code&gt;DerOutputStream&lt;/code&gt;</span>
<span class="line-removed">571      *  to an &lt;code&gt;OutputStream&lt;/code&gt;.</span>
<span class="line-removed">572      *</span>
<span class="line-removed">573      *  @exception IOException on output error.</span>
<span class="line-removed">574      */</span>
<span class="line-removed">575     public void derEncode(OutputStream out) throws IOException {</span>
576         out.write(toByteArray());
577     }
578 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.ByteArrayOutputStream;

 29 import java.io.IOException;
<span class="line-added"> 30 import java.io.OutputStream;</span>
 31 import java.math.BigInteger;
 32 import java.nio.charset.Charset;
 33 import java.text.SimpleDateFormat;
 34 import java.util.Date;
 35 import java.util.TimeZone;
 36 import java.util.Comparator;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 
 40 import static java.nio.charset.StandardCharsets.*;
 41 
 42 /**
 43  * Output stream marshaling DER-encoded data.  This is eventually provided
 44  * in the form of a byte array; there is no advance limit on the size of
 45  * that byte array.
 46  *
 47  * &lt;P&gt;At this time, this class supports only a subset of the types of
 48  * DER data encodings which are defined.  That subset is sufficient for
 49  * generating most X.509 certificates.
 50  *
 51  *
 52  * @author David Brownell
 53  * @author Amit Kapoor
 54  * @author Hemma Prafullchandra
 55  */
 56 public class DerOutputStream
<span class="line-modified"> 57         extends ByteArrayOutputStream implements DerEncoder {</span>
 58     /**
 59      * Construct an DER output stream.
 60      *
 61      * @param size how large a buffer to preallocate.
 62      */
 63     public DerOutputStream(int size) { super(size); }
 64 
 65     /**
 66      * Construct an DER output stream.
 67      */
 68     public DerOutputStream() { }
 69 
 70     /**
 71      * Writes tagged, pre-marshaled data.  This calcuates and encodes
 72      * the length, so that the output data is the standard triple of
 73      * { tag, length, data } used by all DER values.
 74      *
 75      * @param tag the DER value tag for the data, such as
 76      *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
 77      * @param buf buffered data, which must be DER-encoded
 78      */
<span class="line-modified"> 79     public void write(byte tag, byte[] buf) {</span>
 80         write(tag);
 81         putLength(buf.length);
 82         write(buf, 0, buf.length);
 83     }
 84 
 85     /**
 86      * Writes tagged data using buffer-to-buffer copy.  As above,
 87      * this writes a standard DER record.  This is often used when
 88      * efficiently encapsulating values in sequences.
 89      *
 90      * @param tag the DER value tag for the data, such as
 91      *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
 92      * @param out buffered data
 93      */
<span class="line-modified"> 94     public void write(byte tag, DerOutputStream out) {</span>
 95         write(tag);
 96         putLength(out.count);
 97         write(out.buf, 0, out.count);
 98     }
 99 
100     /**
101      * Writes implicitly tagged data using buffer-to-buffer copy.  As above,
102      * this writes a standard DER record.  This is often used when
103      * efficiently encapsulating implicitly tagged values.
104      *
105      * @param tag the DER value of the context-specific tag that replaces
106      * original tag of the value in the output, such as in
107      * &lt;pre&gt;
108      *          &lt;em&gt; {@code &lt;field&gt; [N] IMPLICIT &lt;type&gt;}&lt;/em&gt;
109      * &lt;/pre&gt;
110      * For example, &lt;em&gt;FooLength [1] IMPLICIT INTEGER&lt;/em&gt;, with value=4;
111      * would be encoded as &quot;81 01 04&quot;  whereas in explicit
112      * tagging it would be encoded as &quot;A1 03 02 01 04&quot;.
113      * Notice that the tag is A1 and not 81, this is because with
114      * explicit tagging the form is always constructed.
115      * @param value original value being implicitly tagged
116      */
<span class="line-modified">117     public void writeImplicit(byte tag, DerOutputStream value) {</span>

118         write(tag);
119         write(value.buf, 1, value.count-1);
120     }
121 
122     /**
123      * Marshals pre-encoded DER value onto the output stream.
124      */
<span class="line-modified">125     public void putDerValue(DerValue val) {</span>
126         val.encode(this);
127     }
128 
129     /*
130      * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.
131      *
132      *  BOOLEAN, INTEGER, BIT STRING, OCTET STRING, NULL
133      *  OBJECT IDENTIFIER, SEQUENCE(OF), SET(OF)
134      *  PrintableString, T61String, IA5String, UTCTime
135      */
136 
137     /**
138      * Marshals a DER boolean on the output stream.
139      */
<span class="line-modified">140     public void putBoolean(boolean val) {</span>
141         write(DerValue.tag_Boolean);
142         putLength(1);
143         if (val) {
144             write(0xff);
145         } else {
146             write(0);
147         }
148     }
149 
150     /**
151      * Marshals a DER enumerated on the output stream.
152      * @param i the enumerated value.
153      */
<span class="line-modified">154     public void putEnumerated(int i) {</span>
155         write(DerValue.tag_Enumerated);
156         putIntegerContents(i);
157     }
158 
159     /**
160      * Marshals a DER integer on the output stream.
161      *
162      * @param i the integer in the form of a BigInteger.
163      */
<span class="line-modified">164     public void putInteger(BigInteger i) {</span>
165         write(DerValue.tag_Integer);
166         byte[]    buf = i.toByteArray(); // least number  of bytes
167         putLength(buf.length);
168         write(buf, 0, buf.length);
169     }
170 
171     /**
172      * Marshals a DER integer on the output stream.
173      * @param i the integer in the form of an Integer.
174      */
<span class="line-modified">175     public void putInteger(Integer i) {</span>
176         putInteger(i.intValue());
177     }
178 
179     /**
180      * Marshals a DER integer on the output stream.
181      * @param i the integer.
182      */
<span class="line-modified">183     public void putInteger(int i) {</span>
184         write(DerValue.tag_Integer);
185         putIntegerContents(i);
186     }
187 
<span class="line-modified">188     private void putIntegerContents(int i) {</span>
189 
190         byte[] bytes = new byte[4];
191         int start = 0;
192 
193         // Obtain the four bytes of the int
194 
195         bytes[3] = (byte) (i &amp; 0xff);
196         bytes[2] = (byte)((i &amp; 0xff00) &gt;&gt;&gt; 8);
197         bytes[1] = (byte)((i &amp; 0xff0000) &gt;&gt;&gt; 16);
198         bytes[0] = (byte)((i &amp; 0xff000000) &gt;&gt;&gt; 24);
199 
200         // Reduce them to the least number of bytes needed to
201         // represent this int
202 
203         if (bytes[0] == (byte)0xff) {
204 
205             // Eliminate redundant 0xff
206 
207             for (int j = 0; j &lt; 3; j++) {
<span class="line-modified">208                 if ((bytes[j] == (byte)0xff) &amp;&amp; ((bytes[j+1] &amp; 0x80) == 0x80)) {</span>

209                     start++;
<span class="line-modified">210                 } else {</span>
211                     break;
<span class="line-added">212                 }</span>
213              }
214          } else if (bytes[0] == 0x00) {
215 
216              // Eliminate redundant 0x00
217 
218             for (int j = 0; j &lt; 3; j++) {
<span class="line-modified">219                 if ((bytes[j] == 0x00) &amp;&amp; ((bytes[j+1] &amp; 0x80) == 0)) {</span>

220                     start++;
<span class="line-modified">221                 } else {</span>
222                     break;
<span class="line-added">223                 }</span>
224             }
225         }
226 
227         putLength(4 - start);
<span class="line-modified">228         for (int k = start; k &lt; 4; k++) {</span>
229             write(bytes[k]);
<span class="line-added">230         }</span>
231     }
232 
233     /**
234      * Marshals a DER bit string on the output stream. The bit
235      * string must be byte-aligned.
236      *
237      * @param bits the bit string, MSB first
238      */
<span class="line-modified">239     public void putBitString(byte[] bits) {</span>
240         write(DerValue.tag_BitString);
241         putLength(bits.length + 1);
242         write(0);               // all of last octet is used
243         write(bits);
244     }
245 
246     /**
247      * Marshals a DER bit string on the output stream.
248      * The bit strings need not be byte-aligned.
249      *
250      * @param ba the bit string, MSB first
251      */
<span class="line-modified">252     public void putUnalignedBitString(BitArray ba) {</span>
253         byte[] bits = ba.toByteArray();
254 
255         write(DerValue.tag_BitString);
256         putLength(bits.length + 1);
257         write(bits.length*8 - ba.length()); // excess bits in last octet
258         write(bits);
259     }
260 
261     /**
262      * Marshals a truncated DER bit string on the output stream.
263      * The bit strings need not be byte-aligned.
264      *
265      * @param ba the bit string, MSB first
266      */
<span class="line-modified">267     public void putTruncatedUnalignedBitString(BitArray ba) {</span>
268         putUnalignedBitString(ba.truncate());
269     }
270 
271     /**
272      * DER-encodes an ASN.1 OCTET STRING value on the output stream.
273      *
274      * @param octets the octet string
275      */
<span class="line-modified">276     public void putOctetString(byte[] octets) {</span>
277         write(DerValue.tag_OctetString, octets);
278     }
279 
280     /**
281      * Marshals a DER &quot;null&quot; value on the output stream.  These are
282      * often used to indicate optional values which have been omitted.
283      */
<span class="line-modified">284     public void putNull() {</span>
285         write(DerValue.tag_Null);
286         putLength(0);
287     }
288 
289     /**
290      * Marshals an object identifier (OID) on the output stream.
291      * Corresponds to the ASN.1 &quot;OBJECT IDENTIFIER&quot; construct.
292      */
<span class="line-modified">293     public void putOID(ObjectIdentifier oid) {</span>
294         oid.encode(this);
295     }
296 
297     /**
298      * Marshals a sequence on the output stream.  This supports both
299      * the ASN.1 &quot;SEQUENCE&quot; (zero to N values) and &quot;SEQUENCE OF&quot;
300      * (one to N values) constructs.
301      */
<span class="line-modified">302     public void putSequence(DerValue[] seq) {</span>
303         DerOutputStream bytes = new DerOutputStream();
<span class="line-modified">304         for (int i = 0; i &lt; seq.length; i++) {</span>


305             seq[i].encode(bytes);
<span class="line-modified">306         }</span>
307         write(DerValue.tag_Sequence, bytes);
308     }
309 
310     /**
311      * Marshals the contents of a set on the output stream without
312      * ordering the elements.  Ok for BER encoding, but not for DER
313      * encoding.
314      *
315      * For DER encoding, use orderedPutSet() or orderedPutSetOf().
316      */
<span class="line-modified">317     public void putSet(DerValue[] set) {</span>
318         DerOutputStream bytes = new DerOutputStream();
<span class="line-modified">319         for (int i = 0; i &lt; set.length; i++) {</span>


320             set[i].encode(bytes);
<span class="line-modified">321         }</span>
322         write(DerValue.tag_Set, bytes);
323     }
324 
325     /**
326      * Marshals the contents of a set on the output stream.  Sets
327      * are semantically unordered, but DER requires that encodings of
328      * set elements be sorted into ascending lexicographical order
329      * before being output.  Hence sets with the same tags and
330      * elements have the same DER encoding.
331      *
332      * This method supports the ASN.1 &quot;SET OF&quot; construct, but not
333      * &quot;SET&quot;, which uses a different order.
334      */
<span class="line-modified">335     public void putOrderedSetOf(byte tag, DerEncoder[] set) {</span>
336         putOrderedSet(tag, set, lexOrder);
337     }
338 
339     /**
340      * Marshals the contents of a set on the output stream.  Sets
341      * are semantically unordered, but DER requires that encodings of
342      * set elements be sorted into ascending tag order
343      * before being output.  Hence sets with the same tags and
344      * elements have the same DER encoding.
345      *
346      * This method supports the ASN.1 &quot;SET&quot; construct, but not
347      * &quot;SET OF&quot;, which uses a different order.
348      */
<span class="line-modified">349     public void putOrderedSet(byte tag, DerEncoder[] set) {</span>
350         putOrderedSet(tag, set, tagOrder);
351     }
352 
353     /**
354      *  Lexicographical order comparison on byte arrays, for ordering
355      *  elements of a SET OF objects in DER encoding.
356      */
357     private static ByteArrayLexOrder lexOrder = new ByteArrayLexOrder();
358 
359     /**
360      *  Tag order comparison on byte arrays, for ordering elements of
361      *  SET objects in DER encoding.
362      */
363     private static ByteArrayTagOrder tagOrder = new ByteArrayTagOrder();
364 
365     /**
366      * Marshals a the contents of a set on the output stream with the
367      * encodings of its sorted in increasing order.
368      *
369      * @param order the order to use when sorting encodings of components.
370      */
371     private void putOrderedSet(byte tag, DerEncoder[] set,
<span class="line-modified">372                                Comparator&lt;byte[]&gt; order) {</span>
373         DerOutputStream[] streams = new DerOutputStream[set.length];
374 
375         for (int i = 0; i &lt; set.length; i++) {
376             streams[i] = new DerOutputStream();
377             set[i].derEncode(streams[i]);
378         }
379 
380         // order the element encodings
381         byte[][] bufs = new byte[streams.length][];
382         for (int i = 0; i &lt; streams.length; i++) {
383             bufs[i] = streams[i].toByteArray();
384         }
<span class="line-modified">385         Arrays.sort(bufs, order);</span>
386 
387         DerOutputStream bytes = new DerOutputStream();
388         for (int i = 0; i &lt; streams.length; i++) {
389             bytes.write(bufs[i]);
390         }
391         write(tag, bytes);
392 
393     }
394 
395     /**
396      * Marshals a string as a DER encoded UTF8String.
397      */
<span class="line-modified">398     public void putUTF8String(String s) {</span>
399         writeString(s, DerValue.tag_UTF8String, UTF_8);
400     }
401 
402     /**
403      * Marshals a string as a DER encoded PrintableString.
404      */
<span class="line-modified">405     public void putPrintableString(String s) {</span>
406         writeString(s, DerValue.tag_PrintableString, US_ASCII);
407     }
408 
409     /**
410      * Marshals a string as a DER encoded T61String.
411      */
<span class="line-modified">412     public void putT61String(String s) {</span>
413         /*
414          * Works for characters that are defined in both ASCII and
415          * T61.
416          */
417         writeString(s, DerValue.tag_T61String, ISO_8859_1);
418     }
419 
420     /**
421      * Marshals a string as a DER encoded IA5String.
422      */
<span class="line-modified">423     public void putIA5String(String s) {</span>
424         writeString(s, DerValue.tag_IA5String, US_ASCII);
425     }
426 
427     /**
428      * Marshals a string as a DER encoded BMPString.
429      */
<span class="line-modified">430     public void putBMPString(String s) {</span>
431         writeString(s, DerValue.tag_BMPString, UTF_16BE);
432     }
433 
434     /**
435      * Marshals a string as a DER encoded GeneralString.
436      */
<span class="line-modified">437     public void putGeneralString(String s) {</span>
438         writeString(s, DerValue.tag_GeneralString, US_ASCII);
439     }
440 
441     /**
442      * Private helper routine for writing DER encoded string values.
443      * @param s the string to write
444      * @param stringTag one of the DER string tags that indicate which
445      * encoding should be used to write the string out.
<span class="line-modified">446      * @param charset the name of the character set to encode s</span>

447      */
<span class="line-modified">448     private void writeString(String s, byte stringTag, Charset charset) {</span>

449 
450         byte[] data = s.getBytes(charset);
451         write(stringTag);
452         putLength(data.length);
453         write(data);
454     }
455 
<span class="line-added">456     // A direct copy of OutputStream::write(byte[]) but without throwing</span>
<span class="line-added">457     // an exception.</span>
<span class="line-added">458     public void write(byte b[]) {</span>
<span class="line-added">459         write(b, 0, b.length);</span>
<span class="line-added">460     }</span>
<span class="line-added">461 </span>
462     /**
463      * Marshals a DER UTC time/date value.
464      *
465      * &lt;P&gt;YYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
466      * and with seconds (even if seconds=0) as per RFC 5280.
467      */
<span class="line-modified">468     public void putUTCTime(Date d) {</span>
469         putTime(d, DerValue.tag_UtcTime);
470     }
471 
472     /**
473      * Marshals a DER Generalized Time/date value.
474      *
475      * &lt;P&gt;YYYYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
476      * and with seconds (even if seconds=0) as per RFC 5280.
477      */
<span class="line-modified">478     public void putGeneralizedTime(Date d) {</span>
479         putTime(d, DerValue.tag_GeneralizedTime);
480     }
481 
482     /**
483      * Private helper routine for marshalling a DER UTC/Generalized
484      * time/date value. If the tag specified is not that for UTC Time
485      * then it defaults to Generalized Time.
486      * @param d the date to be marshalled
487      * @param tag the tag for UTC Time or Generalized Time
488      */
<span class="line-modified">489     private void putTime(Date d, byte tag) {</span>
490 
491         /*
492          * Format the date.
493          */
494 
495         TimeZone tz = TimeZone.getTimeZone(&quot;GMT&quot;);
496         String pattern = null;
497 
498         if (tag == DerValue.tag_UtcTime) {
499             pattern = &quot;yyMMddHHmmss&#39;Z&#39;&quot;;
500         } else {
501             tag = DerValue.tag_GeneralizedTime;
502             pattern = &quot;yyyyMMddHHmmss&#39;Z&#39;&quot;;
503         }
504 
505         SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.US);
506         sdf.setTimeZone(tz);
507         byte[] time = (sdf.format(d)).getBytes(ISO_8859_1);
508 
509         /*
510          * Write the formatted date.
511          */
512 
513         write(tag);
514         putLength(time.length);
515         write(time);
516     }
517 
518     /**
519      * Put the encoding of the length in the stream.
520      *
521      * @param len the length of the attribute.

522      */
<span class="line-modified">523     public void putLength(int len) {</span>
524         if (len &lt; 128) {
525             write((byte)len);
526 
527         } else if (len &lt; (1 &lt;&lt; 8)) {
528             write((byte)0x081);
529             write((byte)len);
530 
531         } else if (len &lt; (1 &lt;&lt; 16)) {
532             write((byte)0x082);
533             write((byte)(len &gt;&gt; 8));
534             write((byte)len);
535 
536         } else if (len &lt; (1 &lt;&lt; 24)) {
537             write((byte)0x083);
538             write((byte)(len &gt;&gt; 16));
539             write((byte)(len &gt;&gt; 8));
540             write((byte)len);
541 
542         } else {
543             write((byte)0x084);
</pre>
<hr />
<pre>
548         }
549     }
550 
551     /**
552      * Put the tag of the attribute in the stream.
553      *
554      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
555      *        APPLICATION or PRIVATE
556      * @param form if true, the value is constructed, otherwise it is
557      * primitive.
558      * @param val the tag value
559      */
560     public void putTag(byte tagClass, boolean form, byte val) {
561         byte tag = (byte)(tagClass | val);
562         if (form) {
563             tag |= (byte)0x20;
564         }
565         write(tag);
566     }
567 
<span class="line-modified">568     @Override</span>
<span class="line-modified">569     public void derEncode(DerOutputStream out) {</span>





570         out.write(toByteArray());
571     }
572 }
</pre>
</td>
</tr>
</table>
<center><a href="DerInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerValue.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
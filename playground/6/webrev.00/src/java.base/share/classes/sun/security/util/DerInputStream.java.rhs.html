<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DerInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.math.BigInteger;
 31 import java.nio.charset.Charset;
 32 import java.util.Date;
<a name="1" id="anc1"></a>
 33 
 34 import static java.nio.charset.StandardCharsets.*;
 35 
 36 /**
 37  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 38  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 39  * the advantage that it allows only a single encoding of primitive data.
 40  * (High level data such as dates still support many encodings.)  That is,
 41  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 42  *
 43  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 44  * tagged data values.  Accordingly, this programming interface does
 45  * not expose any variant of the java.io.InputStream interface, since
 46  * that kind of input stream holds untagged data values and using that
 47  * I/O model could prevent correct parsing of the DER data.
 48  *
 49  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 50  * data encodings which are defined.  That subset is sufficient for parsing
 51  * most X.509 certificates.
 52  *
 53  *
 54  * @author David Brownell
 55  * @author Amit Kapoor
 56  * @author Hemma Prafullchandra
 57  */
 58 
 59 public class DerInputStream {
 60 
 61     /*
 62      * This version only supports fully buffered DER.  This is easy to
 63      * work with, though if large objects are manipulated DER becomes
 64      * awkward to deal with.  That&#39;s where BER is useful, since BER
 65      * handles streaming data relatively well.
 66      */
 67     DerInputBuffer      buffer;
 68 
 69     /** The DER tag of the value; one of the tag_ constants. */
 70     public byte         tag;
 71 
 72     /**
 73      * Create a DER input stream from a data buffer.  The buffer is not
 74      * copied, it is shared.  Accordingly, the buffer should be treated
 75      * as read-only.
 76      *
 77      * @param data the buffer from which to create the string (CONSUMED)
 78      */
 79     public DerInputStream(byte[] data) throws IOException {
 80         init(data, 0, data.length, true);
 81     }
 82 
 83     /**
 84      * Create a DER input stream from part of a data buffer with
 85      * additional arg to control whether DER checks are enforced.
 86      * The buffer is not copied, it is shared.  Accordingly, the
 87      * buffer should be treated as read-only.
 88      *
 89      * @param data the buffer from which to create the string (CONSUMED)
 90      * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will
 91      *          be read as DER input in the new stream
 92      * @param len how long a chunk of the buffer to use,
 93      *          starting at &quot;offset&quot;
 94      * @param allowBER whether to allow constructed indefinite-length
 95      *          encoding as well as tolerate leading 0s
 96      */
 97     public DerInputStream(byte[] data, int offset, int len,
<a name="2" id="anc2"></a><span class="line-modified"> 98             boolean allowBER) throws IOException {</span>
 99         init(data, offset, len, allowBER);
100     }
101 
102     /**
103      * Create a DER input stream from part of a data buffer.
104      * The buffer is not copied, it is shared.  Accordingly, the
105      * buffer should be treated as read-only.
106      *
107      * @param data the buffer from which to create the string (CONSUMED)
108      * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will
109      *          be read as DER input in the new stream
110      * @param len how long a chunk of the buffer to use,
111      *          starting at &quot;offset&quot;
112      */
113     public DerInputStream(byte[] data, int offset, int len) throws IOException {
114         init(data, offset, len, true);
115     }
116 
117     /*
118      * private helper routine
119      */
<a name="3" id="anc3"></a><span class="line-modified">120     private void init(byte[] data, int offset, int len, boolean allowBER)</span>
<span class="line-added">121             throws IOException {</span>
122         if ((offset+2 &gt; data.length) || (offset+len &gt; data.length)) {
123             throw new IOException(&quot;Encoding bytes too short&quot;);
124         }
125         // check for indefinite length encoding
126         if (DerIndefLenConverter.isIndefinite(data[offset+1])) {
127             if (!allowBER) {
128                 throw new IOException(&quot;Indefinite length BER encoding found&quot;);
129             } else {
130                 byte[] inData = new byte[len];
131                 System.arraycopy(data, offset, inData, 0, len);
132 
<a name="4" id="anc4"></a><span class="line-modified">133                 byte[] result = DerIndefLenConverter.convertBytes(inData);</span>

134                 if (result == null) {
135                     throw new IOException(&quot;not all indef len BER resolved&quot;);
136                 } else {
137                     buffer = new DerInputBuffer(result, allowBER);
138                 }
139             }
140         } else {
141             buffer = new DerInputBuffer(data, offset, len, allowBER);
142         }
143         buffer.mark(Integer.MAX_VALUE);
144     }
145 
146     DerInputStream(DerInputBuffer buf) {
147         buffer = buf;
148         buffer.mark(Integer.MAX_VALUE);
149     }
150 
151     /**
152      * Creates a new DER input stream from part of this input stream.
153      *
154      * @param len how long a chunk of the current input stream to use,
155      *          starting at the current position.
156      * @param do_skip true if the existing data in the input stream should
157      *          be skipped.  If this value is false, the next data read
158      *          on this stream and the newly created stream will be the
159      *          same.
160      */
161     public DerInputStream subStream(int len, boolean do_skip)
<a name="5" id="anc5"></a><span class="line-modified">162             throws IOException {</span>
163         DerInputBuffer newbuf = buffer.dup();
164 
165         newbuf.truncate(len);
166         if (do_skip) {
167             buffer.skip(len);
168         }
169         return new DerInputStream(newbuf);
170     }
171 
172     /**
173      * Return what has been written to this DerInputStream
174      * as a byte array. Useful for debugging.
175      */
176     public byte[] toByteArray() {
177         return buffer.toByteArray();
178     }
179 
180     /*
181      * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.
182      *
183      *  INTEGER, ENUMERATED, BIT STRING, OCTET STRING, NULL
184      *  OBJECT IDENTIFIER, SEQUENCE (OF), SET (OF)
185      *  UTF8String, PrintableString, T61String, IA5String, UTCTime,
186      *  GeneralizedTime, BMPString.
187      * Note: UniversalString not supported till encoder is available.
188      */
189 
190     /**
191      * Get an integer from the input stream as an integer.
192      *
193      * @return the integer held in this DER input stream.
194      */
195     public int getInteger() throws IOException {
196         if (buffer.read() != DerValue.tag_Integer) {
197             throw new IOException(&quot;DER input, Integer tag error&quot;);
198         }
199         return buffer.getInteger(getDefiniteLength(buffer));
200     }
201 
202     /**
203      * Get a integer from the input stream as a BigInteger object.
204      *
205      * @return the integer held in this DER input stream.
206      */
207     public BigInteger getBigInteger() throws IOException {
208         if (buffer.read() != DerValue.tag_Integer) {
209             throw new IOException(&quot;DER input, Integer tag error&quot;);
210         }
211         return buffer.getBigInteger(getDefiniteLength(buffer), false);
212     }
213 
214     /**
215      * Returns an ASN.1 INTEGER value as a positive BigInteger.
216      * This is just to deal with implementations that incorrectly encode
217      * some values as negative.
218      *
219      * @return the integer held in this DER value as a BigInteger.
220      */
221     public BigInteger getPositiveBigInteger() throws IOException {
222         if (buffer.read() != DerValue.tag_Integer) {
223             throw new IOException(&quot;DER input, Integer tag error&quot;);
224         }
225         return buffer.getBigInteger(getDefiniteLength(buffer), true);
226     }
227 
228     /**
229      * Get an enumerated from the input stream.
230      *
231      * @return the integer held in this DER input stream.
232      */
233     public int getEnumerated() throws IOException {
234         if (buffer.read() != DerValue.tag_Enumerated) {
235             throw new IOException(&quot;DER input, Enumerated tag error&quot;);
236         }
237         return buffer.getInteger(getDefiniteLength(buffer));
238     }
239 
240     /**
241      * Get a bit string from the input stream. Padded bits (if any)
242      * will be stripped off before the bit string is returned.
243      */
244     public byte[] getBitString() throws IOException {
245         if (buffer.read() != DerValue.tag_BitString)
246             throw new IOException(&quot;DER input not an bit string&quot;);
247 
248         return buffer.getBitString(getDefiniteLength(buffer));
249     }
250 
251     /**
252      * Get a bit string from the input stream.  The bit string need
253      * not be byte-aligned.
254      */
255     public BitArray getUnalignedBitString() throws IOException {
256         if (buffer.read() != DerValue.tag_BitString) {
257             throw new IOException(&quot;DER input not a bit string&quot;);
258         }
259 
260         int length = getDefiniteLength(buffer);
261 
262         if (length == 0) {
263             return new BitArray(0);
264         }
265 
266         /*
267          * First byte = number of excess bits in the last octet of the
268          * representation.
269          */
270         length--;
271         int excessBits = buffer.read();
272         if (excessBits &lt; 0) {
273             throw new IOException(&quot;Unused bits of bit string invalid&quot;);
274         }
275         int validBits = length*8 - excessBits;
276         if (validBits &lt; 0) {
277             throw new IOException(&quot;Valid bits of bit string invalid&quot;);
278         }
279 
280         byte[] repn = new byte[length];
281 
282         if ((length != 0) &amp;&amp; (buffer.read(repn) != length)) {
283             throw new IOException(&quot;Short read of DER bit string&quot;);
284         }
285 
286         return new BitArray(validBits, repn);
287     }
288 
289     /**
290      * Returns an ASN.1 OCTET STRING from the input stream.
291      */
292     public byte[] getOctetString() throws IOException {
293         if (buffer.read() != DerValue.tag_OctetString)
294             throw new IOException(&quot;DER input not an octet string&quot;);
295 
296         int length = getDefiniteLength(buffer);
297         byte[] retval = new byte[length];
298         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))
299             throw new IOException(&quot;Short read of DER octet string&quot;);
300 
301         return retval;
302     }
303 
304     /**
305      * Returns the asked number of bytes from the input stream.
306      */
307     public void getBytes(byte[] val) throws IOException {
308         if ((val.length != 0) &amp;&amp; (buffer.read(val) != val.length)) {
309             throw new IOException(&quot;Short read of DER octet string&quot;);
310         }
311     }
312 
313     /**
314      * Reads an encoded null value from the input stream.
315      */
316     public void getNull() throws IOException {
317         if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)
318             throw new IOException(&quot;getNull, bad data&quot;);
319     }
320 
321     /**
322      * Reads an X.200 style Object Identifier from the stream.
323      */
324     public ObjectIdentifier getOID() throws IOException {
325         return new ObjectIdentifier(this);
326     }
327 
328     /**
329      * Return a sequence of encoded entities.  ASN.1 sequences are
330      * ordered, and they are often used, like a &quot;struct&quot; in C or C++,
331      * to group data values.  They may have optional or context
332      * specific values.
333      *
334      * @param startLen guess about how long the sequence will be
335      *          (used to initialize an auto-growing data structure)
336      * @return array of the values in the sequence
337      */
338     public DerValue[] getSequence(int startLen) throws IOException {
339         tag = (byte)buffer.read();
340         if (tag != DerValue.tag_Sequence)
341             throw new IOException(&quot;Sequence tag error&quot;);
342         return readVector(startLen);
343     }
344 
345     /**
346      * Return a set of encoded entities.  ASN.1 sets are unordered,
347      * though DER may specify an order for some kinds of sets (such
348      * as the attributes in an X.500 relative distinguished name)
349      * to facilitate binary comparisons of encoded values.
350      *
351      * @param startLen guess about how large the set will be
352      *          (used to initialize an auto-growing data structure)
353      * @return array of the values in the sequence
354      */
355     public DerValue[] getSet(int startLen) throws IOException {
356         tag = (byte)buffer.read();
357         if (tag != DerValue.tag_Set)
358             throw new IOException(&quot;Set tag error&quot;);
359         return readVector(startLen);
360     }
361 
362     /**
363      * Return a set of encoded entities.  ASN.1 sets are unordered,
364      * though DER may specify an order for some kinds of sets (such
365      * as the attributes in an X.500 relative distinguished name)
366      * to facilitate binary comparisons of encoded values.
367      *
368      * @param startLen guess about how large the set will be
369      *          (used to initialize an auto-growing data structure)
370      * @param implicit if true tag is assumed implicit.
371      * @return array of the values in the sequence
372      */
373     public DerValue[] getSet(int startLen, boolean implicit)
<a name="6" id="anc6"></a><span class="line-modified">374             throws IOException {</span>
375         tag = (byte)buffer.read();
376         if (!implicit) {
377             if (tag != DerValue.tag_Set) {
378                 throw new IOException(&quot;Set tag error&quot;);
379             }
380         }
381         return (readVector(startLen));
382     }
383 
384     /*
385      * Read a &quot;vector&quot; of values ... set or sequence have the
386      * same encoding, except for the initial tag, so both use
387      * this same helper routine.
388      */
389     protected DerValue[] readVector(int startLen) throws IOException {
390         DerInputStream  newstr;
391 
392         byte lenByte = (byte)buffer.read();
393         int len = getLength(lenByte, buffer);
394 
395         if (len == -1) {
396            // indefinite length encoding found
397            buffer = new DerInputBuffer(
398                    DerIndefLenConverter.convertStream(buffer, lenByte, tag),
399                    buffer.allowBER);
400 
<a name="7" id="anc7"></a><span class="line-modified">401            if (tag != buffer.read()) {</span>
<span class="line-modified">402                throw new IOException(&quot;Indefinite length encoding&quot; +</span>
<span class="line-modified">403                        &quot; not supported&quot;);</span>
<span class="line-added">404            }</span>
405            len = DerInputStream.getDefiniteLength(buffer);
406         }
407 
<a name="8" id="anc8"></a><span class="line-modified">408         if (len == 0) {</span>
409             // return empty array instead of null, which should be
410             // used only for missing optionals
411             return new DerValue[0];
<a name="9" id="anc9"></a><span class="line-added">412         }</span>
413 
414         /*
415          * Create a temporary stream from which to read the data,
416          * unless it&#39;s not really needed.
417          */
<a name="10" id="anc10"></a><span class="line-modified">418         if (buffer.available() == len) {</span>
419             newstr = this;
<a name="11" id="anc11"></a><span class="line-modified">420         } else {</span>
421             newstr = subStream(len, true);
<a name="12" id="anc12"></a><span class="line-added">422         }</span>
423 
424         /*
425          * Pull values out of the stream.
426          */
<a name="13" id="anc13"></a><span class="line-modified">427         List&lt;DerValue&gt; vec = new ArrayList&lt;&gt;(startLen);</span>
428         DerValue value;
429 
430         do {
431             value = new DerValue(newstr.buffer, buffer.allowBER);
<a name="14" id="anc14"></a><span class="line-modified">432             vec.add(value);</span>
433         } while (newstr.available() &gt; 0);
434 
<a name="15" id="anc15"></a><span class="line-modified">435         if (newstr.available() != 0) {</span>
436             throw new IOException(&quot;Extra data at end of vector&quot;);
<a name="16" id="anc16"></a><span class="line-added">437         }</span>
438 
<a name="17" id="anc17"></a><span class="line-modified">439         return vec.toArray(new DerValue[vec.size()]);</span>









440     }
441 
442     /**
443      * Get a single DER-encoded value from the input stream.
444      * It can often be useful to pull a value from the stream
445      * and defer parsing it.  For example, you can pull a nested
446      * sequence out with one call, and only examine its elements
447      * later when you really need to.
448      */
449     public DerValue getDerValue() throws IOException {
450         return new DerValue(buffer);
451     }
452 
453     /**
454      * Read a string that was encoded as a UTF8String DER value.
455      */
456     public String getUTF8String() throws IOException {
457         return readString(DerValue.tag_UTF8String, &quot;UTF-8&quot;, UTF_8);
458     }
459 
460     /**
461      * Read a string that was encoded as a PrintableString DER value.
462      */
463     public String getPrintableString() throws IOException {
464         return readString(DerValue.tag_PrintableString, &quot;Printable&quot;,
465                           US_ASCII);
466     }
467 
468     /**
469      * Read a string that was encoded as a T61String DER value.
470      */
471     public String getT61String() throws IOException {
472         /*
473          * Works for common characters between T61 and ASCII.
474          */
475         return readString(DerValue.tag_T61String, &quot;T61&quot;, ISO_8859_1);
476     }
477 
478     /**
479      * Read a string that was encoded as a IA5String DER value.
480      */
481     public String getIA5String() throws IOException {
482         return readString(DerValue.tag_IA5String, &quot;IA5&quot;, US_ASCII);
483     }
484 
485     /**
486      * Read a string that was encoded as a BMPString DER value.
487      */
488     public String getBMPString() throws IOException {
489         return readString(DerValue.tag_BMPString, &quot;BMP&quot;, UTF_16BE);
490     }
491 
492     /**
493      * Read a string that was encoded as a GeneralString DER value.
494      */
495     public String getGeneralString() throws IOException {
496         return readString(DerValue.tag_GeneralString, &quot;General&quot;,
497                           US_ASCII);
498     }
499 
500     /**
501      * Private helper routine to read an encoded string from the input
502      * stream.
503      * @param stringTag the tag for the type of string to read
504      * @param stringName a name to display in error messages
<a name="18" id="anc18"></a><span class="line-modified">505      * @param charset the encoder to use to interpret the data. Should</span>
506      * correspond to the stringTag above.
507      */
508     private String readString(byte stringTag, String stringName,
509                               Charset charset) throws IOException {
510 
<a name="19" id="anc19"></a><span class="line-modified">511         if (buffer.read() != stringTag) {</span>
512             throw new IOException(&quot;DER input not a &quot; +
<a name="20" id="anc20"></a><span class="line-modified">513                     stringName + &quot; string&quot;);</span>
<span class="line-added">514         }</span>
515 
516         int length = getDefiniteLength(buffer);
517         byte[] retval = new byte[length];
<a name="21" id="anc21"></a><span class="line-modified">518         if ((length != 0) &amp;&amp; (buffer.read(retval) != length)) {</span>
519             throw new IOException(&quot;Short read of DER &quot; +
<a name="22" id="anc22"></a><span class="line-modified">520                     stringName + &quot; string&quot;);</span>
<span class="line-added">521         }</span>
522 
523         return new String(retval, charset);
524     }
525 
526     /**
527      * Get a UTC encoded time value from the input stream.
528      */
529     public Date getUTCTime() throws IOException {
<a name="23" id="anc23"></a><span class="line-modified">530         if (buffer.read() != DerValue.tag_UtcTime) {</span>
531             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);
<a name="24" id="anc24"></a><span class="line-added">532         }</span>
533         return buffer.getUTCTime(getDefiniteLength(buffer));
534     }
535 
536     /**
537      * Get a Generalized encoded time value from the input stream.
538      */
539     public Date getGeneralizedTime() throws IOException {
<a name="25" id="anc25"></a><span class="line-modified">540         if (buffer.read() != DerValue.tag_GeneralizedTime) {</span>
541             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);
<a name="26" id="anc26"></a><span class="line-added">542         }</span>
543         return buffer.getGeneralizedTime(getDefiniteLength(buffer));
544     }
545 
546     /*
547      * Get a byte from the input stream.
548      */
549     // package private
<a name="27" id="anc27"></a><span class="line-modified">550     int getByte() {</span>
551         return (0x00ff &amp; buffer.read());
552     }
553 
554     public int peekByte() throws IOException {
555         return buffer.peek();
556     }
557 
558     // package private
559     int getLength() throws IOException {
560         return getLength(buffer);
561     }
562 
563     /*
564      * Get a length from the input stream, allowing for at most 32 bits of
565      * encoding to be used.  (Not the same as getting a tagged integer!)
566      *
567      * @return the length or -1 if indefinite length found.
568      * @exception IOException on parsing error or unsupported lengths.
569      */
570     static int getLength(InputStream in) throws IOException {
571         return getLength(in.read(), in);
572     }
573 
574     /*
575      * Get a length from the input stream, allowing for at most 32 bits of
576      * encoding to be used.  (Not the same as getting a tagged integer!)
577      *
578      * @return the length or -1 if indefinite length found.
579      * @exception IOException on parsing error or unsupported lengths.
580      */
581     static int getLength(int lenByte, InputStream in) throws IOException {
582         int value, tmp;
583         if (lenByte == -1) {
584             throw new IOException(&quot;Short read of DER length&quot;);
585         }
586 
587         String mdName = &quot;DerInputStream.getLength(): &quot;;
588         tmp = lenByte;
589         if ((tmp &amp; 0x080) == 0x00) { // short form, 1 byte datum
590             value = tmp;
591         } else {                     // long form or indefinite
592             tmp &amp;= 0x07f;
593 
594             /*
595              * NOTE:  tmp == 0 indicates indefinite length encoded data.
596              * tmp &gt; 4 indicates more than 4Gb of data.
597              */
<a name="28" id="anc28"></a><span class="line-modified">598             if (tmp == 0) {</span>
599                 return -1;
<a name="29" id="anc29"></a><span class="line-modified">600             }</span>
<span class="line-modified">601             if (tmp &gt; 4) {</span>
<span class="line-modified">602                 throw new IOException(mdName + &quot;lengthTag=&quot; + tmp + &quot;, too big.&quot;);</span>
<span class="line-added">603             }</span>
604 
605             value = 0x0ff &amp; in.read();
606             tmp--;
607             if (value == 0) {
608                 // DER requires length value be encoded in minimum number of bytes
609                 throw new IOException(mdName + &quot;Redundant length bytes found&quot;);
610             }
611             while (tmp-- &gt; 0) {
612                 value &lt;&lt;= 8;
613                 value += 0x0ff &amp; in.read();
614             }
615             if (value &lt; 0) {
616                 throw new IOException(mdName + &quot;Invalid length bytes&quot;);
617             } else if (value &lt;= 127) {
618                 throw new IOException(mdName + &quot;Should use short form for length&quot;);
619             }
620         }
621         return value;
622     }
623 
624     int getDefiniteLength() throws IOException {
625         return getDefiniteLength(buffer);
626     }
627 
628     /*
629      * Get a length from the input stream.
630      *
631      * @return the length
632      * @exception IOException on parsing error or if indefinite length found.
633      */
634     static int getDefiniteLength(InputStream in) throws IOException {
635         int len = getLength(in);
636         if (len &lt; 0) {
637             throw new IOException(&quot;Indefinite length encoding not supported&quot;);
638         }
639         return len;
640     }
641 
642     /**
643      * Mark the current position in the buffer, so that
644      * a later call to &lt;code&gt;reset&lt;/code&gt; will return here.
645      */
646     public void mark(int value) { buffer.mark(value); }
647 
648 
649     /**
650      * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
651      * call.  A mark is implicitly set at the beginning of
652      * the stream when it is created.
653      */
654     public void reset() { buffer.reset(); }
655 
656 
657     /**
658      * Returns the number of bytes available for reading.
659      * This is most useful for testing whether the stream is
660      * empty.
661      */
662     public int available() { return buffer.available(); }
663 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
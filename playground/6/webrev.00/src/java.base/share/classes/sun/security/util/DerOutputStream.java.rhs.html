<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DerOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.ByteArrayOutputStream;
<a name="1" id="anc1"></a>
 29 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-added"> 30 import java.io.OutputStream;</span>
 31 import java.math.BigInteger;
 32 import java.nio.charset.Charset;
 33 import java.text.SimpleDateFormat;
 34 import java.util.Date;
 35 import java.util.TimeZone;
 36 import java.util.Comparator;
 37 import java.util.Arrays;
 38 import java.util.Locale;
 39 
 40 import static java.nio.charset.StandardCharsets.*;
 41 
 42 /**
 43  * Output stream marshaling DER-encoded data.  This is eventually provided
 44  * in the form of a byte array; there is no advance limit on the size of
 45  * that byte array.
 46  *
 47  * &lt;P&gt;At this time, this class supports only a subset of the types of
 48  * DER data encodings which are defined.  That subset is sufficient for
 49  * generating most X.509 certificates.
 50  *
 51  *
 52  * @author David Brownell
 53  * @author Amit Kapoor
 54  * @author Hemma Prafullchandra
 55  */
 56 public class DerOutputStream
<a name="3" id="anc3"></a><span class="line-modified"> 57         extends ByteArrayOutputStream implements DerEncoder {</span>
 58     /**
 59      * Construct an DER output stream.
 60      *
 61      * @param size how large a buffer to preallocate.
 62      */
 63     public DerOutputStream(int size) { super(size); }
 64 
 65     /**
 66      * Construct an DER output stream.
 67      */
 68     public DerOutputStream() { }
 69 
 70     /**
 71      * Writes tagged, pre-marshaled data.  This calcuates and encodes
 72      * the length, so that the output data is the standard triple of
 73      * { tag, length, data } used by all DER values.
 74      *
 75      * @param tag the DER value tag for the data, such as
 76      *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
 77      * @param buf buffered data, which must be DER-encoded
 78      */
<a name="4" id="anc4"></a><span class="line-modified"> 79     public void write(byte tag, byte[] buf) {</span>
 80         write(tag);
 81         putLength(buf.length);
 82         write(buf, 0, buf.length);
 83     }
 84 
 85     /**
 86      * Writes tagged data using buffer-to-buffer copy.  As above,
 87      * this writes a standard DER record.  This is often used when
 88      * efficiently encapsulating values in sequences.
 89      *
 90      * @param tag the DER value tag for the data, such as
 91      *          &lt;em&gt;DerValue.tag_Sequence&lt;/em&gt;
 92      * @param out buffered data
 93      */
<a name="5" id="anc5"></a><span class="line-modified"> 94     public void write(byte tag, DerOutputStream out) {</span>
 95         write(tag);
 96         putLength(out.count);
 97         write(out.buf, 0, out.count);
 98     }
 99 
100     /**
101      * Writes implicitly tagged data using buffer-to-buffer copy.  As above,
102      * this writes a standard DER record.  This is often used when
103      * efficiently encapsulating implicitly tagged values.
104      *
105      * @param tag the DER value of the context-specific tag that replaces
106      * original tag of the value in the output, such as in
107      * &lt;pre&gt;
108      *          &lt;em&gt; {@code &lt;field&gt; [N] IMPLICIT &lt;type&gt;}&lt;/em&gt;
109      * &lt;/pre&gt;
110      * For example, &lt;em&gt;FooLength [1] IMPLICIT INTEGER&lt;/em&gt;, with value=4;
111      * would be encoded as &quot;81 01 04&quot;  whereas in explicit
112      * tagging it would be encoded as &quot;A1 03 02 01 04&quot;.
113      * Notice that the tag is A1 and not 81, this is because with
114      * explicit tagging the form is always constructed.
115      * @param value original value being implicitly tagged
116      */
<a name="6" id="anc6"></a><span class="line-modified">117     public void writeImplicit(byte tag, DerOutputStream value) {</span>

118         write(tag);
119         write(value.buf, 1, value.count-1);
120     }
121 
122     /**
123      * Marshals pre-encoded DER value onto the output stream.
124      */
<a name="7" id="anc7"></a><span class="line-modified">125     public void putDerValue(DerValue val) {</span>
126         val.encode(this);
127     }
128 
129     /*
130      * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.
131      *
132      *  BOOLEAN, INTEGER, BIT STRING, OCTET STRING, NULL
133      *  OBJECT IDENTIFIER, SEQUENCE(OF), SET(OF)
134      *  PrintableString, T61String, IA5String, UTCTime
135      */
136 
137     /**
138      * Marshals a DER boolean on the output stream.
139      */
<a name="8" id="anc8"></a><span class="line-modified">140     public void putBoolean(boolean val) {</span>
141         write(DerValue.tag_Boolean);
142         putLength(1);
143         if (val) {
144             write(0xff);
145         } else {
146             write(0);
147         }
148     }
149 
150     /**
151      * Marshals a DER enumerated on the output stream.
152      * @param i the enumerated value.
153      */
<a name="9" id="anc9"></a><span class="line-modified">154     public void putEnumerated(int i) {</span>
155         write(DerValue.tag_Enumerated);
156         putIntegerContents(i);
157     }
158 
159     /**
160      * Marshals a DER integer on the output stream.
161      *
162      * @param i the integer in the form of a BigInteger.
163      */
<a name="10" id="anc10"></a><span class="line-modified">164     public void putInteger(BigInteger i) {</span>
165         write(DerValue.tag_Integer);
166         byte[]    buf = i.toByteArray(); // least number  of bytes
167         putLength(buf.length);
168         write(buf, 0, buf.length);
169     }
170 
171     /**
172      * Marshals a DER integer on the output stream.
173      * @param i the integer in the form of an Integer.
174      */
<a name="11" id="anc11"></a><span class="line-modified">175     public void putInteger(Integer i) {</span>
176         putInteger(i.intValue());
177     }
178 
179     /**
180      * Marshals a DER integer on the output stream.
181      * @param i the integer.
182      */
<a name="12" id="anc12"></a><span class="line-modified">183     public void putInteger(int i) {</span>
184         write(DerValue.tag_Integer);
185         putIntegerContents(i);
186     }
187 
<a name="13" id="anc13"></a><span class="line-modified">188     private void putIntegerContents(int i) {</span>
189 
190         byte[] bytes = new byte[4];
191         int start = 0;
192 
193         // Obtain the four bytes of the int
194 
195         bytes[3] = (byte) (i &amp; 0xff);
196         bytes[2] = (byte)((i &amp; 0xff00) &gt;&gt;&gt; 8);
197         bytes[1] = (byte)((i &amp; 0xff0000) &gt;&gt;&gt; 16);
198         bytes[0] = (byte)((i &amp; 0xff000000) &gt;&gt;&gt; 24);
199 
200         // Reduce them to the least number of bytes needed to
201         // represent this int
202 
203         if (bytes[0] == (byte)0xff) {
204 
205             // Eliminate redundant 0xff
206 
207             for (int j = 0; j &lt; 3; j++) {
<a name="14" id="anc14"></a><span class="line-modified">208                 if ((bytes[j] == (byte)0xff) &amp;&amp; ((bytes[j+1] &amp; 0x80) == 0x80)) {</span>

209                     start++;
<a name="15" id="anc15"></a><span class="line-modified">210                 } else {</span>
211                     break;
<a name="16" id="anc16"></a><span class="line-added">212                 }</span>
213              }
214          } else if (bytes[0] == 0x00) {
215 
216              // Eliminate redundant 0x00
217 
218             for (int j = 0; j &lt; 3; j++) {
<a name="17" id="anc17"></a><span class="line-modified">219                 if ((bytes[j] == 0x00) &amp;&amp; ((bytes[j+1] &amp; 0x80) == 0)) {</span>

220                     start++;
<a name="18" id="anc18"></a><span class="line-modified">221                 } else {</span>
222                     break;
<a name="19" id="anc19"></a><span class="line-added">223                 }</span>
224             }
225         }
226 
227         putLength(4 - start);
<a name="20" id="anc20"></a><span class="line-modified">228         for (int k = start; k &lt; 4; k++) {</span>
229             write(bytes[k]);
<a name="21" id="anc21"></a><span class="line-added">230         }</span>
231     }
232 
233     /**
234      * Marshals a DER bit string on the output stream. The bit
235      * string must be byte-aligned.
236      *
237      * @param bits the bit string, MSB first
238      */
<a name="22" id="anc22"></a><span class="line-modified">239     public void putBitString(byte[] bits) {</span>
240         write(DerValue.tag_BitString);
241         putLength(bits.length + 1);
242         write(0);               // all of last octet is used
243         write(bits);
244     }
245 
246     /**
247      * Marshals a DER bit string on the output stream.
248      * The bit strings need not be byte-aligned.
249      *
250      * @param ba the bit string, MSB first
251      */
<a name="23" id="anc23"></a><span class="line-modified">252     public void putUnalignedBitString(BitArray ba) {</span>
253         byte[] bits = ba.toByteArray();
254 
255         write(DerValue.tag_BitString);
256         putLength(bits.length + 1);
257         write(bits.length*8 - ba.length()); // excess bits in last octet
258         write(bits);
259     }
260 
261     /**
262      * Marshals a truncated DER bit string on the output stream.
263      * The bit strings need not be byte-aligned.
264      *
265      * @param ba the bit string, MSB first
266      */
<a name="24" id="anc24"></a><span class="line-modified">267     public void putTruncatedUnalignedBitString(BitArray ba) {</span>
268         putUnalignedBitString(ba.truncate());
269     }
270 
271     /**
272      * DER-encodes an ASN.1 OCTET STRING value on the output stream.
273      *
274      * @param octets the octet string
275      */
<a name="25" id="anc25"></a><span class="line-modified">276     public void putOctetString(byte[] octets) {</span>
277         write(DerValue.tag_OctetString, octets);
278     }
279 
280     /**
281      * Marshals a DER &quot;null&quot; value on the output stream.  These are
282      * often used to indicate optional values which have been omitted.
283      */
<a name="26" id="anc26"></a><span class="line-modified">284     public void putNull() {</span>
285         write(DerValue.tag_Null);
286         putLength(0);
287     }
288 
289     /**
290      * Marshals an object identifier (OID) on the output stream.
291      * Corresponds to the ASN.1 &quot;OBJECT IDENTIFIER&quot; construct.
292      */
<a name="27" id="anc27"></a><span class="line-modified">293     public void putOID(ObjectIdentifier oid) {</span>
294         oid.encode(this);
295     }
296 
297     /**
298      * Marshals a sequence on the output stream.  This supports both
299      * the ASN.1 &quot;SEQUENCE&quot; (zero to N values) and &quot;SEQUENCE OF&quot;
300      * (one to N values) constructs.
301      */
<a name="28" id="anc28"></a><span class="line-modified">302     public void putSequence(DerValue[] seq) {</span>
303         DerOutputStream bytes = new DerOutputStream();
<a name="29" id="anc29"></a><span class="line-modified">304         for (int i = 0; i &lt; seq.length; i++) {</span>


305             seq[i].encode(bytes);
<a name="30" id="anc30"></a><span class="line-modified">306         }</span>
307         write(DerValue.tag_Sequence, bytes);
308     }
309 
310     /**
311      * Marshals the contents of a set on the output stream without
312      * ordering the elements.  Ok for BER encoding, but not for DER
313      * encoding.
314      *
315      * For DER encoding, use orderedPutSet() or orderedPutSetOf().
316      */
<a name="31" id="anc31"></a><span class="line-modified">317     public void putSet(DerValue[] set) {</span>
318         DerOutputStream bytes = new DerOutputStream();
<a name="32" id="anc32"></a><span class="line-modified">319         for (int i = 0; i &lt; set.length; i++) {</span>


320             set[i].encode(bytes);
<a name="33" id="anc33"></a><span class="line-modified">321         }</span>
322         write(DerValue.tag_Set, bytes);
323     }
324 
325     /**
326      * Marshals the contents of a set on the output stream.  Sets
327      * are semantically unordered, but DER requires that encodings of
328      * set elements be sorted into ascending lexicographical order
329      * before being output.  Hence sets with the same tags and
330      * elements have the same DER encoding.
331      *
332      * This method supports the ASN.1 &quot;SET OF&quot; construct, but not
333      * &quot;SET&quot;, which uses a different order.
334      */
<a name="34" id="anc34"></a><span class="line-modified">335     public void putOrderedSetOf(byte tag, DerEncoder[] set) {</span>
336         putOrderedSet(tag, set, lexOrder);
337     }
338 
339     /**
340      * Marshals the contents of a set on the output stream.  Sets
341      * are semantically unordered, but DER requires that encodings of
342      * set elements be sorted into ascending tag order
343      * before being output.  Hence sets with the same tags and
344      * elements have the same DER encoding.
345      *
346      * This method supports the ASN.1 &quot;SET&quot; construct, but not
347      * &quot;SET OF&quot;, which uses a different order.
348      */
<a name="35" id="anc35"></a><span class="line-modified">349     public void putOrderedSet(byte tag, DerEncoder[] set) {</span>
350         putOrderedSet(tag, set, tagOrder);
351     }
352 
353     /**
354      *  Lexicographical order comparison on byte arrays, for ordering
355      *  elements of a SET OF objects in DER encoding.
356      */
357     private static ByteArrayLexOrder lexOrder = new ByteArrayLexOrder();
358 
359     /**
360      *  Tag order comparison on byte arrays, for ordering elements of
361      *  SET objects in DER encoding.
362      */
363     private static ByteArrayTagOrder tagOrder = new ByteArrayTagOrder();
364 
365     /**
366      * Marshals a the contents of a set on the output stream with the
367      * encodings of its sorted in increasing order.
368      *
369      * @param order the order to use when sorting encodings of components.
370      */
371     private void putOrderedSet(byte tag, DerEncoder[] set,
<a name="36" id="anc36"></a><span class="line-modified">372                                Comparator&lt;byte[]&gt; order) {</span>
373         DerOutputStream[] streams = new DerOutputStream[set.length];
374 
375         for (int i = 0; i &lt; set.length; i++) {
376             streams[i] = new DerOutputStream();
377             set[i].derEncode(streams[i]);
378         }
379 
380         // order the element encodings
381         byte[][] bufs = new byte[streams.length][];
382         for (int i = 0; i &lt; streams.length; i++) {
383             bufs[i] = streams[i].toByteArray();
384         }
<a name="37" id="anc37"></a><span class="line-modified">385         Arrays.sort(bufs, order);</span>
386 
387         DerOutputStream bytes = new DerOutputStream();
388         for (int i = 0; i &lt; streams.length; i++) {
389             bytes.write(bufs[i]);
390         }
391         write(tag, bytes);
392 
393     }
394 
395     /**
396      * Marshals a string as a DER encoded UTF8String.
397      */
<a name="38" id="anc38"></a><span class="line-modified">398     public void putUTF8String(String s) {</span>
399         writeString(s, DerValue.tag_UTF8String, UTF_8);
400     }
401 
402     /**
403      * Marshals a string as a DER encoded PrintableString.
404      */
<a name="39" id="anc39"></a><span class="line-modified">405     public void putPrintableString(String s) {</span>
406         writeString(s, DerValue.tag_PrintableString, US_ASCII);
407     }
408 
409     /**
410      * Marshals a string as a DER encoded T61String.
411      */
<a name="40" id="anc40"></a><span class="line-modified">412     public void putT61String(String s) {</span>
413         /*
414          * Works for characters that are defined in both ASCII and
415          * T61.
416          */
417         writeString(s, DerValue.tag_T61String, ISO_8859_1);
418     }
419 
420     /**
421      * Marshals a string as a DER encoded IA5String.
422      */
<a name="41" id="anc41"></a><span class="line-modified">423     public void putIA5String(String s) {</span>
424         writeString(s, DerValue.tag_IA5String, US_ASCII);
425     }
426 
427     /**
428      * Marshals a string as a DER encoded BMPString.
429      */
<a name="42" id="anc42"></a><span class="line-modified">430     public void putBMPString(String s) {</span>
431         writeString(s, DerValue.tag_BMPString, UTF_16BE);
432     }
433 
434     /**
435      * Marshals a string as a DER encoded GeneralString.
436      */
<a name="43" id="anc43"></a><span class="line-modified">437     public void putGeneralString(String s) {</span>
438         writeString(s, DerValue.tag_GeneralString, US_ASCII);
439     }
440 
441     /**
442      * Private helper routine for writing DER encoded string values.
443      * @param s the string to write
444      * @param stringTag one of the DER string tags that indicate which
445      * encoding should be used to write the string out.
<a name="44" id="anc44"></a><span class="line-modified">446      * @param charset the name of the character set to encode s</span>

447      */
<a name="45" id="anc45"></a><span class="line-modified">448     private void writeString(String s, byte stringTag, Charset charset) {</span>

449 
450         byte[] data = s.getBytes(charset);
451         write(stringTag);
452         putLength(data.length);
453         write(data);
454     }
455 
<a name="46" id="anc46"></a><span class="line-added">456     // A direct copy of OutputStream::write(byte[]) but without throwing</span>
<span class="line-added">457     // an exception.</span>
<span class="line-added">458     public void write(byte b[]) {</span>
<span class="line-added">459         write(b, 0, b.length);</span>
<span class="line-added">460     }</span>
<span class="line-added">461 </span>
462     /**
463      * Marshals a DER UTC time/date value.
464      *
465      * &lt;P&gt;YYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
466      * and with seconds (even if seconds=0) as per RFC 5280.
467      */
<a name="47" id="anc47"></a><span class="line-modified">468     public void putUTCTime(Date d) {</span>
469         putTime(d, DerValue.tag_UtcTime);
470     }
471 
472     /**
473      * Marshals a DER Generalized Time/date value.
474      *
475      * &lt;P&gt;YYYYMMDDhhmmss{Z|+hhmm|-hhmm} ... emits only using Zulu time
476      * and with seconds (even if seconds=0) as per RFC 5280.
477      */
<a name="48" id="anc48"></a><span class="line-modified">478     public void putGeneralizedTime(Date d) {</span>
479         putTime(d, DerValue.tag_GeneralizedTime);
480     }
481 
482     /**
483      * Private helper routine for marshalling a DER UTC/Generalized
484      * time/date value. If the tag specified is not that for UTC Time
485      * then it defaults to Generalized Time.
486      * @param d the date to be marshalled
487      * @param tag the tag for UTC Time or Generalized Time
488      */
<a name="49" id="anc49"></a><span class="line-modified">489     private void putTime(Date d, byte tag) {</span>
490 
491         /*
492          * Format the date.
493          */
494 
495         TimeZone tz = TimeZone.getTimeZone(&quot;GMT&quot;);
496         String pattern = null;
497 
498         if (tag == DerValue.tag_UtcTime) {
499             pattern = &quot;yyMMddHHmmss&#39;Z&#39;&quot;;
500         } else {
501             tag = DerValue.tag_GeneralizedTime;
502             pattern = &quot;yyyyMMddHHmmss&#39;Z&#39;&quot;;
503         }
504 
505         SimpleDateFormat sdf = new SimpleDateFormat(pattern, Locale.US);
506         sdf.setTimeZone(tz);
507         byte[] time = (sdf.format(d)).getBytes(ISO_8859_1);
508 
509         /*
510          * Write the formatted date.
511          */
512 
513         write(tag);
514         putLength(time.length);
515         write(time);
516     }
517 
518     /**
519      * Put the encoding of the length in the stream.
520      *
521      * @param len the length of the attribute.
<a name="50" id="anc50"></a>
522      */
<a name="51" id="anc51"></a><span class="line-modified">523     public void putLength(int len) {</span>
524         if (len &lt; 128) {
525             write((byte)len);
526 
527         } else if (len &lt; (1 &lt;&lt; 8)) {
528             write((byte)0x081);
529             write((byte)len);
530 
531         } else if (len &lt; (1 &lt;&lt; 16)) {
532             write((byte)0x082);
533             write((byte)(len &gt;&gt; 8));
534             write((byte)len);
535 
536         } else if (len &lt; (1 &lt;&lt; 24)) {
537             write((byte)0x083);
538             write((byte)(len &gt;&gt; 16));
539             write((byte)(len &gt;&gt; 8));
540             write((byte)len);
541 
542         } else {
543             write((byte)0x084);
544             write((byte)(len &gt;&gt; 24));
545             write((byte)(len &gt;&gt; 16));
546             write((byte)(len &gt;&gt; 8));
547             write((byte)len);
548         }
549     }
550 
551     /**
552      * Put the tag of the attribute in the stream.
553      *
554      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
555      *        APPLICATION or PRIVATE
556      * @param form if true, the value is constructed, otherwise it is
557      * primitive.
558      * @param val the tag value
559      */
560     public void putTag(byte tagClass, boolean form, byte val) {
561         byte tag = (byte)(tagClass | val);
562         if (form) {
563             tag |= (byte)0x20;
564         }
565         write(tag);
566     }
567 
<a name="52" id="anc52"></a><span class="line-modified">568     @Override</span>
<span class="line-modified">569     public void derEncode(DerOutputStream out) {</span>





570         out.write(toByteArray());
571     }
572 }
<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>
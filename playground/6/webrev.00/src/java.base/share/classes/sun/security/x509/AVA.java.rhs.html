<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/AVA.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.io.OutputStream;
  31 import java.io.Reader;
<a name="1" id="anc1"></a>
  32 import java.text.Normalizer;
  33 import java.util.*;
  34 
  35 import static java.nio.charset.StandardCharsets.UTF_8;
  36 
  37 import sun.security.action.GetBooleanAction;
  38 import sun.security.util.*;
  39 import sun.security.pkcs.PKCS9Attribute;
  40 
  41 
  42 /**
  43  * X.500 Attribute-Value-Assertion (AVA):  an attribute, as identified by
  44  * some attribute ID, has some particular value.  Values are as a rule ASN.1
  45  * printable strings.  A conventional set of type IDs is recognized when
  46  * parsing (and generating) RFC 1779, 2253 or 4514 syntax strings.
  47  *
  48  * &lt;P&gt;AVAs are components of X.500 relative names.  Think of them as being
  49  * individual fields of a database record.  The attribute ID is how you
  50  * identify the field, and the value is part of a particular record.
  51  * &lt;p&gt;
  52  * Note that instances of this class are immutable.
  53  *
  54  * @see X500Name
  55  * @see RDN
  56  *
  57  *
  58  * @author David Brownell
  59  * @author Amit Kapoor
  60  * @author Hemma Prafullchandra
  61  */
  62 public class AVA implements DerEncoder {
  63 
  64     private static final Debug debug = Debug.getInstance(&quot;x509&quot;, &quot;\t[AVA]&quot;);
  65     // See CR 6391482: if enabled this flag preserves the old but incorrect
  66     // PrintableString encoding for DomainComponent. It may need to be set to
  67     // avoid breaking preexisting certificates generated with sun.security APIs.
  68     private static final boolean PRESERVE_OLD_DC_ENCODING = GetBooleanAction
  69             .privilegedGetProperty(&quot;com.sun.security.preserveOldDCEncoding&quot;);
  70 
  71     /**
  72      * DEFAULT format allows both RFC1779 and RFC2253 syntax and
  73      * additional keywords.
  74      */
  75     static final int DEFAULT = 1;
  76     /**
  77      * RFC1779 specifies format according to RFC1779.
  78      */
  79     static final int RFC1779 = 2;
  80     /**
  81      * RFC2253 specifies format according to RFC2253.
  82      */
  83     static final int RFC2253 = 3;
  84 
  85     // currently not private, accessed directly from RDN
  86     final ObjectIdentifier oid;
  87     final DerValue value;
  88 
  89     /*
  90      * If the value has any of these characters in it, it must be quoted.
  91      * Backslash and quote characters must also be individually escaped.
  92      * Leading and trailing spaces, also multiple internal spaces, also
  93      * call for quoting the whole string.
  94      */
  95     private static final String specialChars1779 = &quot;,=\n+&lt;&gt;#;\\\&quot;&quot;;
  96 
  97     /*
  98      * In RFC2253, if the value has any of these characters in it, it
  99      * must be quoted by a preceding \.
 100      */
 101     private static final String specialChars2253 = &quot;,=+&lt;&gt;#;\\\&quot;&quot;;
 102 
 103     /*
 104      * includes special chars from RFC1779 and RFC2253, as well as &#39; &#39; from
 105      * RFC 4514.
 106      */
 107     private static final String specialCharsDefault = &quot;,=\n+&lt;&gt;#;\\\&quot; &quot;;
 108     private static final String escapedDefault = &quot;,+&lt;&gt;;\&quot;&quot;;
 109 
 110     /*
 111      * Values that aren&#39;t printable strings are emitted as BER-encoded
 112      * hex data.
 113      */
 114     private static final String hexDigits = &quot;0123456789ABCDEF&quot;;
 115 
 116     public AVA(ObjectIdentifier type, DerValue val) {
 117         if ((type == null) || (val == null)) {
 118             throw new NullPointerException();
 119         }
 120         oid = type;
 121         value = val;
 122     }
 123 
 124     /**
 125      * Parse an RFC 1779, 2253 or 4514 style AVA string:  CN=fee fie foe fum
 126      * or perhaps with quotes.  Not all defined AVA tags are supported;
 127      * of current note are X.400 related ones (PRMD, ADMD, etc).
 128      *
 129      * This terminates at unescaped AVA separators (&quot;+&quot;) or RDN
 130      * separators (&quot;,&quot;, &quot;;&quot;), and removes cosmetic whitespace at the end of
 131      * values.
 132      */
 133     AVA(Reader in) throws IOException {
 134         this(in, DEFAULT);
 135     }
 136 
 137     /**
 138      * Parse an RFC 1779, 2253 or 4514 style AVA string:  CN=fee fie foe fum
 139      * or perhaps with quotes. Additional keywords can be specified in the
 140      * keyword/OID map.
 141      *
 142      * This terminates at unescaped AVA separators (&quot;+&quot;) or RDN
 143      * separators (&quot;,&quot;, &quot;;&quot;), and removes cosmetic whitespace at the end of
 144      * values.
 145      */
 146     AVA(Reader in, Map&lt;String, String&gt; keywordMap) throws IOException {
 147         this(in, DEFAULT, keywordMap);
 148     }
 149 
 150     /**
 151      * Parse an AVA string formatted according to format.
 152      */
 153     AVA(Reader in, int format) throws IOException {
 154         this(in, format, Collections.&lt;String, String&gt;emptyMap());
 155     }
 156 
 157     /**
 158      * Parse an AVA string formatted according to format.
 159      *
 160      * @param in Reader containing AVA String
 161      * @param format parsing format
 162      * @param keywordMap a Map where a keyword String maps to a corresponding
 163      *   OID String. Each AVA keyword will be mapped to the corresponding OID.
 164      *   If an entry does not exist, it will fallback to the builtin
 165      *   keyword/OID mapping.
 166      * @throws IOException if the AVA String is not valid in the specified
 167      *   format or an OID String from the keywordMap is improperly formatted
 168      */
 169     AVA(Reader in, int format, Map&lt;String, String&gt; keywordMap)
 170         throws IOException {
 171         // assume format is one of DEFAULT or RFC2253
 172 
 173         StringBuilder   temp = new StringBuilder();
 174         int             c;
 175 
 176         /*
 177          * First get the keyword indicating the attribute&#39;s type,
 178          * and map it to the appropriate OID.
 179          */
 180         while (true) {
 181             c = readChar(in, &quot;Incorrect AVA format&quot;);
 182             if (c == &#39;=&#39;) {
 183                 break;
 184             }
 185             temp.append((char)c);
 186         }
 187 
 188         oid = AVAKeyword.getOID(temp.toString(), format, keywordMap);
 189 
 190         /*
 191          * Now parse the value.  &quot;#hex&quot;, a quoted string, or a string
 192          * terminated by &quot;+&quot;, &quot;,&quot;, &quot;;&quot;.  Whitespace before or after
 193          * the value is stripped away unless format is RFC2253.
 194          */
 195         temp.setLength(0);
 196         if (format == RFC2253) {
 197             // read next character
 198             c = in.read();
 199             if (c == &#39; &#39;) {
 200                 throw new IOException(&quot;Incorrect AVA RFC2253 format - &quot; +
 201                                       &quot;leading space must be escaped&quot;);
 202             }
 203         } else {
 204             // read next character skipping whitespace
 205             do {
 206                 c = in.read();
 207             } while ((c == &#39; &#39;) || (c == &#39;\n&#39;));
 208         }
 209         if (c == -1) {
 210             // empty value
 211             value = new DerValue(&quot;&quot;);
 212             return;
 213         }
 214 
 215         if (c == &#39;#&#39;) {
 216             value = parseHexString(in, format);
 217         } else if ((c == &#39;&quot;&#39;) &amp;&amp; (format != RFC2253)) {
 218             value = parseQuotedString(in, temp);
 219         } else {
 220             value = parseString(in, c, format, temp);
 221         }
 222     }
 223 
 224     /**
 225      * Get the ObjectIdentifier of this AVA.
 226      */
 227     public ObjectIdentifier getObjectIdentifier() {
 228         return oid;
 229     }
 230 
 231     /**
 232      * Get the value of this AVA as a DerValue.
 233      */
 234     public DerValue getDerValue() {
 235         return value;
 236     }
 237 
 238     /**
 239      * Get the value of this AVA as a String.
 240      *
 241      * @exception RuntimeException if we could not obtain the string form
 242      *    (should not occur)
 243      */
 244     public String getValueString() {
 245         try {
 246             String s = value.getAsString();
 247             if (s == null) {
 248                 throw new RuntimeException(&quot;AVA string is null&quot;);
 249             }
 250             return s;
 251         } catch (IOException e) {
 252             // should not occur
 253             throw new RuntimeException(&quot;AVA error: &quot; + e, e);
 254         }
 255     }
 256 
 257     private static DerValue parseHexString
 258         (Reader in, int format) throws IOException {
 259 
 260         int c;
 261         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 262         byte b = 0;
 263         int cNdx = 0;
 264         while (true) {
 265             c = in.read();
 266 
 267             if (isTerminator(c, format)) {
 268                 break;
 269             }
 270 
 271             int cVal = hexDigits.indexOf(Character.toUpperCase((char)c));
 272 
 273             if (cVal == -1) {
 274                 throw new IOException(&quot;AVA parse, invalid hex &quot; +
 275                                               &quot;digit: &quot;+ (char)c);
 276             }
 277 
 278             if ((cNdx % 2) == 1) {
 279                 b = (byte)((b * 16) + (byte)(cVal));
 280                 baos.write(b);
 281             } else {
 282                 b = (byte)(cVal);
 283             }
 284             cNdx++;
 285         }
 286 
 287         // throw exception if no hex digits
 288         if (cNdx == 0) {
 289             throw new IOException(&quot;AVA parse, zero hex digits&quot;);
 290         }
 291 
 292         // throw exception if odd number of hex digits
 293         if (cNdx % 2 == 1) {
 294             throw new IOException(&quot;AVA parse, odd number of hex digits&quot;);
 295         }
 296 
 297         return new DerValue(baos.toByteArray());
 298     }
 299 
 300     private DerValue parseQuotedString
 301         (Reader in, StringBuilder temp) throws IOException {
 302 
 303         // RFC1779 specifies that an entire RDN may be enclosed in double
 304         // quotes. In this case the syntax is any sequence of
 305         // backslash-specialChar, backslash-backslash,
 306         // backslash-doublequote, or character other than backslash or
 307         // doublequote.
 308         int c = readChar(in, &quot;Quoted string did not end in quote&quot;);
 309 
 310         List&lt;Byte&gt; embeddedHex = new ArrayList&lt;&gt;();
 311         boolean isPrintableString = true;
 312         while (c != &#39;&quot;&#39;) {
 313             if (c == &#39;\\&#39;) {
 314                 c = readChar(in, &quot;Quoted string did not end in quote&quot;);
 315 
 316                 // check for embedded hex pairs
 317                 Byte hexByte = null;
 318                 if ((hexByte = getEmbeddedHexPair(c, in)) != null) {
 319 
 320                     // always encode AVAs with embedded hex as UTF8
 321                     isPrintableString = false;
 322 
 323                     // append consecutive embedded hex
 324                     // as single string later
 325                     embeddedHex.add(hexByte);
 326                     c = in.read();
 327                     continue;
 328                 }
 329 
 330                 if (specialChars1779.indexOf((char)c) &lt; 0) {
 331                     throw new IOException
 332                         (&quot;Invalid escaped character in AVA: &quot; +
 333                         (char)c);
 334                 }
 335             }
 336 
 337             // add embedded hex bytes before next char
 338             if (embeddedHex.size() &gt; 0) {
 339                 String hexString = getEmbeddedHexString(embeddedHex);
 340                 temp.append(hexString);
 341                 embeddedHex.clear();
 342             }
 343 
 344             // check for non-PrintableString chars
 345             isPrintableString &amp;= DerValue.isPrintableStringChar((char)c);
 346             temp.append((char)c);
 347             c = readChar(in, &quot;Quoted string did not end in quote&quot;);
 348         }
 349 
 350         // add trailing embedded hex bytes
 351         if (embeddedHex.size() &gt; 0) {
 352             String hexString = getEmbeddedHexString(embeddedHex);
 353             temp.append(hexString);
 354             embeddedHex.clear();
 355         }
 356 
 357         do {
 358             c = in.read();
 359         } while ((c == &#39;\n&#39;) || (c == &#39; &#39;));
 360         if (c != -1) {
 361             throw new IOException(&quot;AVA had characters other than &quot;
 362                     + &quot;whitespace after terminating quote&quot;);
 363         }
 364 
 365         // encode as PrintableString unless value contains
 366         // non-PrintableString chars
 367         if (this.oid.equals(PKCS9Attribute.EMAIL_ADDRESS_OID) ||
 368             (this.oid.equals(X500Name.DOMAIN_COMPONENT_OID) &amp;&amp;
 369                 PRESERVE_OLD_DC_ENCODING == false)) {
 370             // EmailAddress and DomainComponent must be IA5String
 371             return new DerValue(DerValue.tag_IA5String,
 372                                         temp.toString().trim());
 373         } else if (isPrintableString) {
 374             return new DerValue(temp.toString().trim());
 375         } else {
 376             return new DerValue(DerValue.tag_UTF8String,
 377                                         temp.toString().trim());
 378         }
 379     }
 380 
 381     private DerValue parseString
 382         (Reader in, int c, int format, StringBuilder temp) throws IOException {
 383 
 384         List&lt;Byte&gt; embeddedHex = new ArrayList&lt;&gt;();
 385         boolean isPrintableString = true;
 386         boolean escape = false;
 387         boolean leadingChar = true;
 388         int spaceCount = 0;
 389         do {
 390             escape = false;
 391             if (c == &#39;\\&#39;) {
 392                 escape = true;
 393                 c = readChar(in, &quot;Invalid trailing backslash&quot;);
 394 
 395                 // check for embedded hex pairs
 396                 Byte hexByte = null;
 397                 if ((hexByte = getEmbeddedHexPair(c, in)) != null) {
 398 
 399                     // always encode AVAs with embedded hex as UTF8
 400                     isPrintableString = false;
 401 
 402                     // append consecutive embedded hex
 403                     // as single string later
 404                     embeddedHex.add(hexByte);
 405                     c = in.read();
 406                     leadingChar = false;
 407                     continue;
 408                 }
 409 
 410                 // check if character was improperly escaped
 411                 if (format == DEFAULT &amp;&amp;
 412                        specialCharsDefault.indexOf((char)c) == -1) {
 413                     throw new IOException
 414                         (&quot;Invalid escaped character in AVA: &#39;&quot; +
 415                         (char)c + &quot;&#39;&quot;);
 416                 } else if (format == RFC2253) {
 417                     if (c == &#39; &#39;) {
 418                         // only leading/trailing space can be escaped
 419                         if (!leadingChar &amp;&amp; !trailingSpace(in)) {
 420                             throw new IOException
 421                                     (&quot;Invalid escaped space character &quot; +
 422                                     &quot;in AVA.  Only a leading or trailing &quot; +
 423                                     &quot;space character can be escaped.&quot;);
 424                         }
 425                     } else if (c == &#39;#&#39;) {
 426                         // only leading &#39;#&#39; can be escaped
 427                         if (!leadingChar) {
 428                             throw new IOException
 429                                 (&quot;Invalid escaped &#39;#&#39; character in AVA.  &quot; +
 430                                 &quot;Only a leading &#39;#&#39; can be escaped.&quot;);
 431                         }
 432                     } else if (specialChars2253.indexOf((char)c) == -1) {
 433                         throw new IOException
 434                                 (&quot;Invalid escaped character in AVA: &#39;&quot; +
 435                                 (char)c + &quot;&#39;&quot;);
 436                     }
 437                 }
 438             } else {
 439                 // check if character should have been escaped
 440                 if (format == RFC2253) {
 441                     if (specialChars2253.indexOf((char)c) != -1) {
 442                         throw new IOException
 443                                 (&quot;Character &#39;&quot; + (char)c +
 444                                  &quot;&#39; in AVA appears without escape&quot;);
 445                     }
 446                 } else if (escapedDefault.indexOf((char)c) != -1) {
 447                     throw new IOException
 448                             (&quot;Character &#39;&quot; + (char)c +
 449                             &quot;&#39; in AVA appears without escape&quot;);
 450                 }
 451             }
 452 
 453             // add embedded hex bytes before next char
 454             if (embeddedHex.size() &gt; 0) {
 455                 // add space(s) before embedded hex bytes
 456                 for (int i = 0; i &lt; spaceCount; i++) {
 457                     temp.append(&#39; &#39;);
 458                 }
 459                 spaceCount = 0;
 460 
 461                 String hexString = getEmbeddedHexString(embeddedHex);
 462                 temp.append(hexString);
 463                 embeddedHex.clear();
 464             }
 465 
 466             // check for non-PrintableString chars
 467             isPrintableString &amp;= DerValue.isPrintableStringChar((char)c);
 468             if (c == &#39; &#39; &amp;&amp; escape == false) {
 469                 // do not add non-escaped spaces yet
 470                 // (non-escaped trailing spaces are ignored)
 471                 spaceCount++;
 472             } else {
 473                 // add space(s)
 474                 for (int i = 0; i &lt; spaceCount; i++) {
 475                     temp.append(&#39; &#39;);
 476                 }
 477                 spaceCount = 0;
 478                 temp.append((char)c);
 479             }
 480             c = in.read();
 481             leadingChar = false;
 482         } while (isTerminator(c, format) == false);
 483 
 484         if (format == RFC2253 &amp;&amp; spaceCount &gt; 0) {
 485             throw new IOException(&quot;Incorrect AVA RFC2253 format - &quot; +
 486                                         &quot;trailing space must be escaped&quot;);
 487         }
 488 
 489         // add trailing embedded hex bytes
 490         if (embeddedHex.size() &gt; 0) {
 491             String hexString = getEmbeddedHexString(embeddedHex);
 492             temp.append(hexString);
 493             embeddedHex.clear();
 494         }
 495 
 496         // encode as PrintableString unless value contains
 497         // non-PrintableString chars
 498         if (this.oid.equals(PKCS9Attribute.EMAIL_ADDRESS_OID) ||
 499             (this.oid.equals(X500Name.DOMAIN_COMPONENT_OID) &amp;&amp;
 500                 PRESERVE_OLD_DC_ENCODING == false)) {
 501             // EmailAddress and DomainComponent must be IA5String
 502             return new DerValue(DerValue.tag_IA5String, temp.toString());
 503         } else if (isPrintableString) {
 504             return new DerValue(temp.toString());
 505         } else {
 506             return new DerValue(DerValue.tag_UTF8String, temp.toString());
 507         }
 508     }
 509 
 510     private static Byte getEmbeddedHexPair(int c1, Reader in)
 511         throws IOException {
 512 
 513         if (hexDigits.indexOf(Character.toUpperCase((char)c1)) &gt;= 0) {
 514             int c2 = readChar(in, &quot;unexpected EOF - &quot; +
 515                         &quot;escaped hex value must include two valid digits&quot;);
 516 
 517             if (hexDigits.indexOf(Character.toUpperCase((char)c2)) &gt;= 0) {
 518                 int hi = Character.digit((char)c1, 16);
 519                 int lo = Character.digit((char)c2, 16);
 520                 return (byte)((hi&lt;&lt;4) + lo);
 521             } else {
 522                 throw new IOException
 523                         (&quot;escaped hex value must include two valid digits&quot;);
 524             }
 525         }
 526         return null;
 527     }
 528 
 529     private static String getEmbeddedHexString(List&lt;Byte&gt; hexList) {
 530         int n = hexList.size();
 531         byte[] hexBytes = new byte[n];
 532         for (int i = 0; i &lt; n; i++) {
 533             hexBytes[i] = hexList.get(i).byteValue();
 534         }
 535         return new String(hexBytes, UTF_8);
 536     }
 537 
 538     private static boolean isTerminator(int ch, int format) {
 539         switch (ch) {
 540         case -1:
 541         case &#39;+&#39;:
 542         case &#39;,&#39;:
 543             return true;
 544         case &#39;;&#39;:
 545             return format != RFC2253;
 546         default:
 547             return false;
 548         }
 549     }
 550 
 551     private static int readChar(Reader in, String errMsg) throws IOException {
 552         int c = in.read();
 553         if (c == -1) {
 554             throw new IOException(errMsg);
 555         }
 556         return c;
 557     }
 558 
 559     private static boolean trailingSpace(Reader in) throws IOException {
 560 
 561         boolean trailing = false;
 562 
 563         if (!in.markSupported()) {
 564             // oh well
 565             return true;
 566         } else {
 567             // make readAheadLimit huge -
 568             // in practice, AVA was passed a StringReader from X500Name,
 569             // and StringReader ignores readAheadLimit anyways
 570             in.mark(9999);
 571             while (true) {
 572                 int nextChar = in.read();
 573                 if (nextChar == -1) {
 574                     trailing = true;
 575                     break;
 576                 } else if (nextChar == &#39; &#39;) {
 577                     continue;
 578                 } else if (nextChar == &#39;\\&#39;) {
 579                     int followingChar = in.read();
 580                     if (followingChar != &#39; &#39;) {
 581                         trailing = false;
 582                         break;
 583                     }
 584                 } else {
 585                     trailing = false;
 586                     break;
 587                 }
 588             }
 589 
 590             in.reset();
 591             return trailing;
 592         }
 593     }
 594 
 595     AVA(DerValue derval) throws IOException {
 596         // Individual attribute value assertions are SEQUENCE of two values.
 597         // That&#39;d be a &quot;struct&quot; outside of ASN.1.
 598         if (derval.tag != DerValue.tag_Sequence) {
 599             throw new IOException(&quot;AVA not a sequence&quot;);
 600         }
 601         oid = derval.data.getOID();
 602         value = derval.data.getDerValue();
 603 
 604         if (derval.data.available() != 0) {
 605             throw new IOException(&quot;AVA, extra bytes = &quot;
 606                 + derval.data.available());
 607         }
 608     }
 609 
 610     AVA(DerInputStream in) throws IOException {
 611         this(in.getDerValue());
 612     }
 613 
 614     public boolean equals(Object obj) {
 615         if (this == obj) {
 616             return true;
 617         }
 618         if (obj instanceof AVA == false) {
 619             return false;
 620         }
 621         AVA other = (AVA)obj;
 622         return this.toRFC2253CanonicalString().equals
 623                                 (other.toRFC2253CanonicalString());
 624     }
 625 
 626     /**
 627      * Returns a hashcode for this AVA.
 628      *
 629      * @return a hashcode for this AVA.
 630      */
 631     public int hashCode() {
 632         return toRFC2253CanonicalString().hashCode();
 633     }
 634 
<a name="2" id="anc2"></a>






 635     /**
 636      * DER encode this object onto an output stream.
 637      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 638      *
 639      * @param out
 640      * the output stream on which to write the DER encoding.
 641      *
 642      * @exception IOException on encoding error.
 643      */
<a name="3" id="anc3"></a><span class="line-modified"> 644     @Override</span>
<span class="line-added"> 645     public void derEncode(DerOutputStream out) {</span>
 646         DerOutputStream         tmp = new DerOutputStream();
 647         DerOutputStream         tmp2 = new DerOutputStream();
 648 
 649         tmp.putOID(oid);
 650         value.encode(tmp);
 651         tmp2.write(DerValue.tag_Sequence, tmp);
 652         out.write(tmp2.toByteArray());
 653     }
 654 
 655     private String toKeyword(int format, Map&lt;String, String&gt; oidMap) {
 656         return AVAKeyword.getKeyword(oid, format, oidMap);
 657     }
 658 
 659     /**
 660      * Returns a printable form of this attribute, using RFC 1779
 661      * syntax for individual attribute/value assertions.
 662      */
 663     public String toString() {
 664         return toKeywordValueString
 665             (toKeyword(DEFAULT, Collections.&lt;String, String&gt;emptyMap()));
 666     }
 667 
 668     /**
 669      * Returns a printable form of this attribute, using RFC 1779
 670      * syntax for individual attribute/value assertions. It only
 671      * emits standardised keywords.
 672      */
 673     public String toRFC1779String() {
 674         return toRFC1779String(Collections.&lt;String, String&gt;emptyMap());
 675     }
 676 
 677     /**
 678      * Returns a printable form of this attribute, using RFC 1779
 679      * syntax for individual attribute/value assertions. It
 680      * emits standardised keywords, as well as keywords contained in the
 681      * OID/keyword map.
 682      */
 683     public String toRFC1779String(Map&lt;String, String&gt; oidMap) {
 684         return toKeywordValueString(toKeyword(RFC1779, oidMap));
 685     }
 686 
 687     /**
 688      * Returns a printable form of this attribute, using RFC 2253
 689      * syntax for individual attribute/value assertions. It only
 690      * emits standardised keywords.
 691      */
 692     public String toRFC2253String() {
 693         return toRFC2253String(Collections.&lt;String, String&gt;emptyMap());
 694     }
 695 
 696     /**
 697      * Returns a printable form of this attribute, using RFC 2253
 698      * syntax for individual attribute/value assertions. It
 699      * emits standardised keywords, as well as keywords contained in the
 700      * OID/keyword map.
 701      */
 702     public String toRFC2253String(Map&lt;String, String&gt; oidMap) {
 703         /*
 704          * Section 2.3: The AttributeTypeAndValue is encoded as the string
 705          * representation of the AttributeType, followed by an equals character
 706          * (&#39;=&#39; ASCII 61), followed by the string representation of the
 707          * AttributeValue. The encoding of the AttributeValue is given in
 708          * section 2.4.
 709          */
 710         StringBuilder typeAndValue = new StringBuilder(100);
 711         typeAndValue.append(toKeyword(RFC2253, oidMap));
 712         typeAndValue.append(&#39;=&#39;);
 713 
 714         /*
 715          * Section 2.4: Converting an AttributeValue from ASN.1 to a String.
 716          * If the AttributeValue is of a type which does not have a string
 717          * representation defined for it, then it is simply encoded as an
 718          * octothorpe character (&#39;#&#39; ASCII 35) followed by the hexadecimal
 719          * representation of each of the bytes of the BER encoding of the X.500
 720          * AttributeValue.  This form SHOULD be used if the AttributeType is of
 721          * the dotted-decimal form.
 722          */
 723         if ((typeAndValue.charAt(0) &gt;= &#39;0&#39; &amp;&amp; typeAndValue.charAt(0) &lt;= &#39;9&#39;) ||
 724             !isDerString(value, false))
 725         {
 726             byte[] data = null;
 727             try {
 728                 data = value.toByteArray();
 729             } catch (IOException ie) {
 730                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 731             }
 732             typeAndValue.append(&#39;#&#39;);
 733             for (int j = 0; j &lt; data.length; j++) {
 734                 byte b = data[j];
 735                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 736                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 737             }
 738         } else {
 739             /*
 740              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 741              * has a string representation, the value is converted first to a
 742              * UTF-8 string according to its syntax specification.
 743              *
 744              * NOTE: this implementation only emits DirectoryStrings of the
 745              * types returned by isDerString().
 746              */
 747             String valStr = null;
 748             try {
 749                 valStr = new String(value.getDataBytes(), UTF_8);
 750             } catch (IOException ie) {
 751                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 752             }
 753 
 754             /*
 755              * 2.4 (cont): If the UTF-8 string does not have any of the
 756              * following characters which need escaping, then that string can be
 757              * used as the string representation of the value.
 758              *
 759              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 760              *       string
 761              *   o   a space character occurring at the end of the string
 762              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 763              *
 764              * Implementations MAY escape other characters.
 765              *
 766              * NOTE: this implementation also recognizes &quot;=&quot; and &quot;#&quot; as
 767              * characters which need escaping, and null which is escaped as
 768              * &#39;\00&#39; (see RFC 4514).
 769              *
 770              * If a character to be escaped is one of the list shown above, then
 771              * it is prefixed by a backslash (&#39;\&#39; ASCII 92).
 772              *
 773              * Otherwise the character to be escaped is replaced by a backslash
 774              * and two hex digits, which form a single byte in the code of the
 775              * character.
 776              */
 777             final String escapees = &quot;,=+&lt;&gt;#;\&quot;\\&quot;;
 778             StringBuilder sbuffer = new StringBuilder();
 779 
 780             for (int i = 0; i &lt; valStr.length(); i++) {
 781                 char c = valStr.charAt(i);
 782                 if (DerValue.isPrintableStringChar(c) ||
 783                     escapees.indexOf(c) &gt;= 0) {
 784 
 785                     // escape escapees
 786                     if (escapees.indexOf(c) &gt;= 0) {
 787                         sbuffer.append(&#39;\\&#39;);
 788                     }
 789 
 790                     // append printable/escaped char
 791                     sbuffer.append(c);
 792 
 793                 } else if (c == &#39;\u0000&#39;) {
 794                     // escape null character
 795                     sbuffer.append(&quot;\\00&quot;);
 796 
 797                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 798 
 799                     // embed non-printable/non-escaped char
 800                     // as escaped hex pairs for debugging
 801                     byte[] valueBytes = Character.toString(c).getBytes(UTF_8);
 802                     for (int j = 0; j &lt; valueBytes.length; j++) {
 803                         sbuffer.append(&#39;\\&#39;);
 804                         char hexChar = Character.forDigit
 805                                 (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
 806                         sbuffer.append(Character.toUpperCase(hexChar));
 807                         hexChar = Character.forDigit
 808                                 (0xF &amp; (valueBytes[j]), 16);
 809                         sbuffer.append(Character.toUpperCase(hexChar));
 810                     }
 811                 } else {
 812 
 813                     // append non-printable/non-escaped char
 814                     sbuffer.append(c);
 815                 }
 816             }
 817 
 818             char[] chars = sbuffer.toString().toCharArray();
 819             sbuffer = new StringBuilder();
 820 
 821             // Find leading and trailing whitespace.
 822             int lead;   // index of first char that is not leading whitespace
 823             for (lead = 0; lead &lt; chars.length; lead++) {
 824                 if (chars[lead] != &#39; &#39; &amp;&amp; chars[lead] != &#39;\r&#39;) {
 825                     break;
 826                 }
 827             }
 828             int trail;  // index of last char that is not trailing whitespace
 829             for (trail = chars.length - 1; trail &gt;= 0; trail--) {
 830                 if (chars[trail] != &#39; &#39; &amp;&amp; chars[trail] != &#39;\r&#39;) {
 831                     break;
 832                 }
 833             }
 834 
 835             // escape leading and trailing whitespace
 836             for (int i = 0; i &lt; chars.length; i++) {
 837                 char c = chars[i];
 838                 if (i &lt; lead || i &gt; trail) {
 839                     sbuffer.append(&#39;\\&#39;);
 840                 }
 841                 sbuffer.append(c);
 842             }
 843             typeAndValue.append(sbuffer);
 844         }
 845         return typeAndValue.toString();
 846     }
 847 
 848     public String toRFC2253CanonicalString() {
 849         /*
 850          * Section 2.3: The AttributeTypeAndValue is encoded as the string
 851          * representation of the AttributeType, followed by an equals character
 852          * (&#39;=&#39; ASCII 61), followed by the string representation of the
 853          * AttributeValue. The encoding of the AttributeValue is given in
 854          * section 2.4.
 855          */
 856         StringBuilder typeAndValue = new StringBuilder(40);
 857         typeAndValue.append
 858             (toKeyword(RFC2253, Collections.&lt;String, String&gt;emptyMap()));
 859         typeAndValue.append(&#39;=&#39;);
 860 
 861         /*
 862          * Section 2.4: Converting an AttributeValue from ASN.1 to a String.
 863          * If the AttributeValue is of a type which does not have a string
 864          * representation defined for it, then it is simply encoded as an
 865          * octothorpe character (&#39;#&#39; ASCII 35) followed by the hexadecimal
 866          * representation of each of the bytes of the BER encoding of the X.500
 867          * AttributeValue.  This form SHOULD be used if the AttributeType is of
 868          * the dotted-decimal form.
 869          */
 870         if ((typeAndValue.charAt(0) &gt;= &#39;0&#39; &amp;&amp; typeAndValue.charAt(0) &lt;= &#39;9&#39;) ||
 871             !isDerString(value, true))
 872         {
 873             byte[] data = null;
 874             try {
 875                 data = value.toByteArray();
 876             } catch (IOException ie) {
 877                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 878             }
 879             typeAndValue.append(&#39;#&#39;);
 880             for (int j = 0; j &lt; data.length; j++) {
 881                 byte b = data[j];
 882                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 883                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 884             }
 885         } else {
 886             /*
 887              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 888              * has a string representation, the value is converted first to a
 889              * UTF-8 string according to its syntax specification.
 890              *
 891              * NOTE: this implementation only emits DirectoryStrings of the
 892              * types returned by isDerString().
 893              */
 894             String valStr = null;
 895             try {
 896                 valStr = new String(value.getDataBytes(), UTF_8);
 897             } catch (IOException ie) {
 898                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 899             }
 900 
 901             /*
 902              * 2.4 (cont): If the UTF-8 string does not have any of the
 903              * following characters which need escaping, then that string can be
 904              * used as the string representation of the value.
 905              *
 906              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 907              *       string
 908              *   o   a space character occurring at the end of the string
 909              *
 910              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 911              *
 912              * If a character to be escaped is one of the list shown above, then
 913              * it is prefixed by a backslash (&#39;\&#39; ASCII 92).
 914              *
 915              * Otherwise the character to be escaped is replaced by a backslash
 916              * and two hex digits, which form a single byte in the code of the
 917              * character.
 918              */
 919             final String escapees = &quot;,+&lt;&gt;;\&quot;\\&quot;;
 920             StringBuilder sbuffer = new StringBuilder();
 921             boolean previousWhite = false;
 922 
 923             for (int i = 0; i &lt; valStr.length(); i++) {
 924                 char c = valStr.charAt(i);
 925 
 926                 if (DerValue.isPrintableStringChar(c) ||
 927                     escapees.indexOf(c) &gt;= 0 ||
 928                     (i == 0 &amp;&amp; c == &#39;#&#39;)) {
 929 
 930                     // escape leading &#39;#&#39; and escapees
 931                     if ((i == 0 &amp;&amp; c == &#39;#&#39;) || escapees.indexOf(c) &gt;= 0) {
 932                         sbuffer.append(&#39;\\&#39;);
 933                     }
 934 
 935                     // convert multiple whitespace to single whitespace
 936                     if (!Character.isWhitespace(c)) {
 937                         previousWhite = false;
 938                         sbuffer.append(c);
 939                     } else {
 940                         if (previousWhite == false) {
 941                             // add single whitespace
 942                             previousWhite = true;
 943                             sbuffer.append(c);
 944                         } else {
 945                             // ignore subsequent consecutive whitespace
 946                             continue;
 947                         }
 948                     }
 949 
 950                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 951 
 952                     // embed non-printable/non-escaped char
 953                     // as escaped hex pairs for debugging
 954 
 955                     previousWhite = false;
 956 
 957                     byte[] valueBytes = Character.toString(c).getBytes(UTF_8);
 958                     for (int j = 0; j &lt; valueBytes.length; j++) {
 959                         sbuffer.append(&#39;\\&#39;);
 960                         sbuffer.append(Character.forDigit
 961                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16));
 962                         sbuffer.append(Character.forDigit
 963                                         (0xF &amp; (valueBytes[j]), 16));
 964                     }
 965                 } else {
 966 
 967                     // append non-printable/non-escaped char
 968 
 969                     previousWhite = false;
 970                     sbuffer.append(c);
 971                 }
 972             }
 973 
 974             // remove leading and trailing whitespace from value
 975             typeAndValue.append(sbuffer.toString().trim());
 976         }
 977 
 978         String canon = typeAndValue.toString();
 979         canon = canon.toUpperCase(Locale.US).toLowerCase(Locale.US);
 980         return Normalizer.normalize(canon, Normalizer.Form.NFKD);
 981     }
 982 
 983     /*
 984      * Return true if DerValue can be represented as a String.
 985      */
 986     private static boolean isDerString(DerValue value, boolean canonical) {
 987         if (canonical) {
 988             switch (value.tag) {
 989                 case DerValue.tag_PrintableString:
 990                 case DerValue.tag_UTF8String:
 991                     return true;
 992                 default:
 993                     return false;
 994             }
 995         } else {
 996             switch (value.tag) {
 997                 case DerValue.tag_PrintableString:
 998                 case DerValue.tag_T61String:
 999                 case DerValue.tag_IA5String:
1000                 case DerValue.tag_GeneralString:
1001                 case DerValue.tag_BMPString:
1002                 case DerValue.tag_UTF8String:
1003                     return true;
1004                 default:
1005                     return false;
1006             }
1007         }
1008     }
1009 
1010     boolean hasRFC2253Keyword() {
1011         return AVAKeyword.hasKeyword(oid, RFC2253);
1012     }
1013 
1014     private String toKeywordValueString(String keyword) {
1015         /*
1016          * Construct the value with as little copying and garbage
1017          * production as practical.  First the keyword (mandatory),
1018          * then the equals sign, finally the value.
1019          */
1020         StringBuilder   retval = new StringBuilder(40);
1021 
1022         retval.append(keyword);
1023         retval.append(&#39;=&#39;);
1024 
1025         try {
1026             String valStr = value.getAsString();
1027 
1028             if (valStr == null) {
1029 
1030                 // RFC 1779 specifies that attribute values associated
1031                 // with non-standard keyword attributes may be represented
1032                 // using the hex format below.  This will be used only
1033                 // when the value is not a string type
1034 
1035                 byte[] data = value.toByteArray();
1036 
1037                 retval.append(&#39;#&#39;);
1038                 for (int i = 0; i &lt; data.length; i++) {
1039                     retval.append(hexDigits.charAt((data [i] &gt;&gt; 4) &amp; 0x0f));
1040                     retval.append(hexDigits.charAt(data [i] &amp; 0x0f));
1041                 }
1042 
1043             } else {
1044 
1045                 boolean quoteNeeded = false;
1046                 StringBuilder sbuffer = new StringBuilder();
1047                 boolean previousWhite = false;
1048                 final String escapees = &quot;,+=\n&lt;&gt;#;\\\&quot;&quot;;
1049 
1050                 /*
1051                  * Special characters (e.g. AVA list separators) cause strings
1052                  * to need quoting, or at least escaping.  So do leading or
1053                  * trailing spaces, and multiple internal spaces.
1054                  */
1055                 int length = valStr.length();
1056                 boolean alreadyQuoted =
1057                     (length &gt; 1 &amp;&amp; valStr.charAt(0) == &#39;\&quot;&#39;
1058                      &amp;&amp; valStr.charAt(length - 1) == &#39;\&quot;&#39;);
1059 
1060                 for (int i = 0; i &lt; length; i++) {
1061                     char c = valStr.charAt(i);
1062                     if (alreadyQuoted &amp;&amp; (i == 0 || i == length - 1)) {
1063                         sbuffer.append(c);
1064                         continue;
1065                     }
1066                     if (DerValue.isPrintableStringChar(c) ||
1067                         escapees.indexOf(c) &gt;= 0) {
1068 
1069                         // quote if leading whitespace or special chars
1070                         if (!quoteNeeded &amp;&amp;
1071                             ((i == 0 &amp;&amp; (c == &#39; &#39; || c == &#39;\n&#39;)) ||
1072                                 escapees.indexOf(c) &gt;= 0)) {
1073                             quoteNeeded = true;
1074                         }
1075 
1076                         // quote if multiple internal whitespace
1077                         if (!(c == &#39; &#39; || c == &#39;\n&#39;)) {
1078                             // escape &#39;&quot;&#39; and &#39;\&#39;
1079                             if (c == &#39;&quot;&#39; || c == &#39;\\&#39;) {
1080                                 sbuffer.append(&#39;\\&#39;);
1081                             }
1082                             previousWhite = false;
1083                         } else {
1084                             if (!quoteNeeded &amp;&amp; previousWhite) {
1085                                 quoteNeeded = true;
1086                             }
1087                             previousWhite = true;
1088                         }
1089 
1090                         sbuffer.append(c);
1091 
1092                     } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
1093 
1094                         // embed non-printable/non-escaped char
1095                         // as escaped hex pairs for debugging
1096 
1097                         previousWhite = false;
1098 
1099                         // embed escaped hex pairs
1100                         byte[] valueBytes =
1101                                 Character.toString(c).getBytes(UTF_8);
1102                         for (int j = 0; j &lt; valueBytes.length; j++) {
1103                             sbuffer.append(&#39;\\&#39;);
1104                             char hexChar = Character.forDigit
1105                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
1106                             sbuffer.append(Character.toUpperCase(hexChar));
1107                             hexChar = Character.forDigit
1108                                         (0xF &amp; (valueBytes[j]), 16);
1109                             sbuffer.append(Character.toUpperCase(hexChar));
1110                         }
1111                     } else {
1112 
1113                         // append non-printable/non-escaped char
1114 
1115                         previousWhite = false;
1116                         sbuffer.append(c);
1117                     }
1118                 }
1119 
1120                 // quote if trailing whitespace
1121                 if (sbuffer.length() &gt; 0) {
1122                     char trailChar = sbuffer.charAt(sbuffer.length() - 1);
1123                     if (trailChar == &#39; &#39; || trailChar == &#39;\n&#39;) {
1124                         quoteNeeded = true;
1125                     }
1126                 }
1127 
1128                 // Emit the string ... quote it if needed
1129                 // if string is already quoted, don&#39;t re-quote
1130                 if (!alreadyQuoted &amp;&amp; quoteNeeded) {
1131                     retval.append(&#39;\&quot;&#39;)
1132                         .append(sbuffer)
1133                         .append(&#39;\&quot;&#39;);
1134                 } else {
1135                     retval.append(sbuffer);
1136                 }
1137             }
1138         } catch (IOException e) {
1139             throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
1140         }
1141 
1142         return retval.toString();
1143     }
1144 
1145 }
1146 
1147 /**
1148  * Helper class that allows conversion from String to ObjectIdentifier and
1149  * vice versa according to RFC1779, RFC2253, and an augmented version of
1150  * those standards.
1151  */
1152 class AVAKeyword {
1153 
1154     private static final Map&lt;ObjectIdentifier,AVAKeyword&gt; oidMap;
1155     private static final Map&lt;String,AVAKeyword&gt; keywordMap;
1156 
1157     private String keyword;
1158     private ObjectIdentifier oid;
1159     private boolean rfc1779Compliant, rfc2253Compliant;
1160 
1161     private AVAKeyword(String keyword, ObjectIdentifier oid,
1162                boolean rfc1779Compliant, boolean rfc2253Compliant) {
1163         this.keyword = keyword;
1164         this.oid = oid;
1165         this.rfc1779Compliant = rfc1779Compliant;
1166         this.rfc2253Compliant = rfc2253Compliant;
1167 
1168         // register it
1169         oidMap.put(oid, this);
1170         keywordMap.put(keyword, this);
1171     }
1172 
1173     private boolean isCompliant(int standard) {
1174         switch (standard) {
1175         case AVA.RFC1779:
1176             return rfc1779Compliant;
1177         case AVA.RFC2253:
1178             return rfc2253Compliant;
1179         case AVA.DEFAULT:
1180             return true;
1181         default:
1182             // should not occur, internal error
1183             throw new IllegalArgumentException(&quot;Invalid standard &quot; + standard);
1184         }
1185     }
1186 
1187     /**
1188      * Get an object identifier representing the specified keyword (or
1189      * string encoded object identifier) in the given standard.
1190      *
1191      * @param keywordMap a Map where a keyword String maps to a corresponding
1192      *   OID String. Each AVA keyword will be mapped to the corresponding OID.
1193      *   If an entry does not exist, it will fallback to the builtin
1194      *   keyword/OID mapping.
1195      * @throws IOException If the keyword is not valid in the specified standard
1196      *   or the OID String to which a keyword maps to is improperly formatted.
1197      */
1198     static ObjectIdentifier getOID
1199         (String keyword, int standard, Map&lt;String, String&gt; extraKeywordMap)
1200             throws IOException {
1201 
1202         keyword = keyword.toUpperCase(Locale.ENGLISH);
1203         if (standard == AVA.RFC2253) {
1204             if (keyword.startsWith(&quot; &quot;) || keyword.endsWith(&quot; &quot;)) {
1205                 throw new IOException(&quot;Invalid leading or trailing space &quot; +
1206                         &quot;in keyword \&quot;&quot; + keyword + &quot;\&quot;&quot;);
1207             }
1208         } else {
1209             keyword = keyword.trim();
1210         }
1211 
1212         // check user-specified keyword map first, then fallback to built-in
1213         // map
1214         String oidString = extraKeywordMap.get(keyword);
1215         if (oidString == null) {
1216             AVAKeyword ak = keywordMap.get(keyword);
1217             if ((ak != null) &amp;&amp; ak.isCompliant(standard)) {
1218                 return ak.oid;
1219             }
1220         } else {
1221             return ObjectIdentifier.of(oidString);
1222         }
1223 
1224         // no keyword found, check if OID string
1225         if (standard == AVA.DEFAULT &amp;&amp; keyword.startsWith(&quot;OID.&quot;)) {
1226             keyword = keyword.substring(4);
1227         }
1228 
1229         boolean number = false;
1230         if (!keyword.isEmpty()) {
1231             char ch = keyword.charAt(0);
1232             if ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) {
1233                 number = true;
1234             }
1235         }
1236         if (number == false) {
1237             throw new IOException(&quot;Invalid keyword \&quot;&quot; + keyword + &quot;\&quot;&quot;);
1238         }
1239         return ObjectIdentifier.of(keyword);
1240     }
1241 
1242     /**
1243      * Get a keyword for the given ObjectIdentifier according to standard.
1244      * If no keyword is available, the ObjectIdentifier is encoded as a
1245      * String.
1246      */
1247     static String getKeyword(ObjectIdentifier oid, int standard) {
1248         return getKeyword
1249             (oid, standard, Collections.&lt;String, String&gt;emptyMap());
1250     }
1251 
1252     /**
1253      * Get a keyword for the given ObjectIdentifier according to standard.
1254      * Checks the extraOidMap for a keyword first, then falls back to the
1255      * builtin/default set. If no keyword is available, the ObjectIdentifier
1256      * is encoded as a String.
1257      */
1258     static String getKeyword
1259         (ObjectIdentifier oid, int standard, Map&lt;String, String&gt; extraOidMap) {
1260 
1261         // check extraOidMap first, then fallback to built-in map
1262         String oidString = oid.toString();
1263         String keywordString = extraOidMap.get(oidString);
1264         if (keywordString == null) {
1265             AVAKeyword ak = oidMap.get(oid);
1266             if ((ak != null) &amp;&amp; ak.isCompliant(standard)) {
1267                 return ak.keyword;
1268             }
1269         } else {
1270             if (keywordString.isEmpty()) {
1271                 throw new IllegalArgumentException(&quot;keyword cannot be empty&quot;);
1272             }
1273             keywordString = keywordString.trim();
1274             char c = keywordString.charAt(0);
1275             if (c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97)) {
1276                 throw new IllegalArgumentException
1277                     (&quot;keyword does not start with letter&quot;);
1278             }
1279             for (int i=1; i&lt;keywordString.length(); i++) {
1280                 c = keywordString.charAt(i);
1281                 if ((c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97)) &amp;&amp;
1282                     (c &lt; 48 || c &gt; 57) &amp;&amp; c != &#39;_&#39;) {
1283                     throw new IllegalArgumentException
1284                     (&quot;keyword character is not a letter, digit, or underscore&quot;);
1285                 }
1286             }
1287             return keywordString;
1288         }
1289         // no compliant keyword, use OID
1290         if (standard == AVA.RFC2253) {
1291             return oidString;
1292         } else {
1293             return &quot;OID.&quot; + oidString;
1294         }
1295     }
1296 
1297     /**
1298      * Test if oid has an associated keyword in standard.
1299      */
1300     static boolean hasKeyword(ObjectIdentifier oid, int standard) {
1301         AVAKeyword ak = oidMap.get(oid);
1302         if (ak == null) {
1303             return false;
1304         }
1305         return ak.isCompliant(standard);
1306     }
1307 
1308     static {
1309         oidMap = new HashMap&lt;ObjectIdentifier,AVAKeyword&gt;();
1310         keywordMap = new HashMap&lt;String,AVAKeyword&gt;();
1311 
1312         // NOTE if multiple keywords are available for one OID, order
1313         // is significant!! Preferred *LAST*.
1314         new AVAKeyword(&quot;CN&quot;,           X500Name.commonName_oid,   true,  true);
1315         new AVAKeyword(&quot;C&quot;,            X500Name.countryName_oid,  true,  true);
1316         new AVAKeyword(&quot;L&quot;,            X500Name.localityName_oid, true,  true);
1317         new AVAKeyword(&quot;S&quot;,            X500Name.stateName_oid,    false, false);
1318         new AVAKeyword(&quot;ST&quot;,           X500Name.stateName_oid,    true,  true);
1319         new AVAKeyword(&quot;O&quot;,            X500Name.orgName_oid,      true,  true);
1320         new AVAKeyword(&quot;OU&quot;,           X500Name.orgUnitName_oid,  true,  true);
1321         new AVAKeyword(&quot;T&quot;,            X500Name.title_oid,        false, false);
1322         new AVAKeyword(&quot;IP&quot;,           X500Name.ipAddress_oid,    false, false);
1323         new AVAKeyword(&quot;STREET&quot;,       X500Name.streetAddress_oid,true,  true);
1324         new AVAKeyword(&quot;DC&quot;,           X500Name.DOMAIN_COMPONENT_OID,
1325                                                                   false, true);
1326         new AVAKeyword(&quot;DNQUALIFIER&quot;,  X500Name.DNQUALIFIER_OID,  false, false);
1327         new AVAKeyword(&quot;DNQ&quot;,          X500Name.DNQUALIFIER_OID,  false, false);
1328         new AVAKeyword(&quot;SURNAME&quot;,      X500Name.SURNAME_OID,      false, false);
1329         new AVAKeyword(&quot;GIVENNAME&quot;,    X500Name.GIVENNAME_OID,    false, false);
1330         new AVAKeyword(&quot;INITIALS&quot;,     X500Name.INITIALS_OID,     false, false);
1331         new AVAKeyword(&quot;GENERATION&quot;,   X500Name.GENERATIONQUALIFIER_OID,
1332                                                                   false, false);
1333         new AVAKeyword(&quot;EMAIL&quot;, PKCS9Attribute.EMAIL_ADDRESS_OID, false, false);
1334         new AVAKeyword(&quot;EMAILADDRESS&quot;, PKCS9Attribute.EMAIL_ADDRESS_OID,
1335                                                                   false, false);
1336         new AVAKeyword(&quot;UID&quot;,          X500Name.userid_oid,       false, true);
1337         new AVAKeyword(&quot;SERIALNUMBER&quot;, X500Name.SERIALNUMBER_OID, false, false);
1338     }
1339 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/X509CRLImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.InputStream;
  29 import java.io.OutputStream;
  30 import java.io.IOException;
  31 import java.math.BigInteger;
  32 import java.security.cert.Certificate;
  33 import java.security.cert.X509CRL;
  34 import java.security.cert.X509Certificate;
  35 import java.security.cert.X509CRLEntry;
  36 import java.security.cert.CRLException;
  37 import java.security.*;
  38 import java.security.spec.AlgorithmParameterSpec;
  39 import java.util.*;
  40 
  41 import javax.security.auth.x500.X500Principal;
  42 
  43 import sun.security.provider.X509Factory;
  44 import sun.security.util.*;
  45 
  46 /**
  47  * &lt;p&gt;
  48  * An implementation for X509 CRL (Certificate Revocation List).
  49  * &lt;p&gt;
  50  * The X.509 v2 CRL format is described below in ASN.1:
  51  * &lt;pre&gt;
  52  * CertificateList  ::=  SEQUENCE  {
  53  *     tbsCertList          TBSCertList,
  54  *     signatureAlgorithm   AlgorithmIdentifier,
  55  *     signature            BIT STRING  }
  56  * &lt;/pre&gt;
  57  * More information can be found in
  58  * &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280: Internet X.509
  59  * Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.
  60  * &lt;p&gt;
  61  * The ASN.1 definition of &lt;code&gt;tbsCertList&lt;/code&gt; is:
  62  * &lt;pre&gt;
  63  * TBSCertList  ::=  SEQUENCE  {
  64  *     version                 Version OPTIONAL,
  65  *                             -- if present, must be v2
  66  *     signature               AlgorithmIdentifier,
  67  *     issuer                  Name,
  68  *     thisUpdate              ChoiceOfTime,
  69  *     nextUpdate              ChoiceOfTime OPTIONAL,
  70  *     revokedCertificates     SEQUENCE OF SEQUENCE  {
  71  *         userCertificate         CertificateSerialNumber,
  72  *         revocationDate          ChoiceOfTime,
  73  *         crlEntryExtensions      Extensions OPTIONAL
  74  *                                 -- if present, must be v2
  75  *         }  OPTIONAL,
  76  *     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
  77  *                                  -- if present, must be v2
  78  *     }
  79  * &lt;/pre&gt;
  80  *
  81  * @author Hemma Prafullchandra
  82  * @see X509CRL
  83  */
  84 public class X509CRLImpl extends X509CRL implements DerEncoder {
  85 
  86     // CRL data, and its envelope
  87     private byte[]      signedCRL = null; // DER encoded crl
  88     private byte[]      signature = null; // raw signature bits
  89     private byte[]      tbsCertList = null; // DER encoded &quot;to-be-signed&quot; CRL
  90     private AlgorithmId sigAlgId = null; // sig alg in CRL
  91 
  92     // crl information
  93     private int              version;
  94     private AlgorithmId      infoSigAlgId; // sig alg in &quot;to-be-signed&quot; crl
  95     private X500Name         issuer = null;
  96     private X500Principal    issuerPrincipal = null;
  97     private Date             thisUpdate = null;
  98     private Date             nextUpdate = null;
  99     private Map&lt;X509IssuerSerial,X509CRLEntry&gt; revokedMap = new TreeMap&lt;&gt;();
 100     private List&lt;X509CRLEntry&gt; revokedList = new LinkedList&lt;&gt;();
 101     private CRLExtensions    extensions = null;
 102     private static final boolean isExplicit = true;
 103 
 104     private boolean readOnly = false;
 105 
 106     /**
 107      * PublicKey that has previously been used to successfully verify
 108      * the signature of this CRL. Null if the CRL has not
 109      * yet been verified (successfully).
 110      */
 111     private PublicKey verifiedPublicKey;
 112     /**
 113      * If verifiedPublicKey is not null, name of the provider used to
 114      * successfully verify the signature of this CRL, or the
 115      * empty String if no provider was explicitly specified.
 116      */
 117     private String verifiedProvider;
 118 
 119     /**
 120      * Not to be used. As it would lead to cases of uninitialized
 121      * CRL objects.
 122      */
 123     private X509CRLImpl() { }
 124 
 125     /**
 126      * Unmarshals an X.509 CRL from its encoded form, parsing the encoded
 127      * bytes.  This form of constructor is used by agents which
 128      * need to examine and use CRL contents. Note that the buffer
 129      * must include only one CRL, and no &quot;garbage&quot; may be left at
 130      * the end.
 131      *
 132      * @param crlData the encoded bytes, with no trailing padding.
 133      * @exception CRLException on parsing errors.
 134      */
 135     public X509CRLImpl(byte[] crlData) throws CRLException {
 136         try {
 137             parse(new DerValue(crlData));
 138         } catch (IOException e) {
 139             signedCRL = null;
 140             throw new CRLException(&quot;Parsing error: &quot; + e.getMessage());
 141         }
 142     }
 143 
 144     /**
 145      * Unmarshals an X.509 CRL from an DER value.
 146      *
 147      * @param val a DER value holding at least one CRL
 148      * @exception CRLException on parsing errors.
 149      */
 150     public X509CRLImpl(DerValue val) throws CRLException {
 151         try {
 152             parse(val);
 153         } catch (IOException e) {
 154             signedCRL = null;
 155             throw new CRLException(&quot;Parsing error: &quot; + e.getMessage());
 156         }
 157     }
 158 
 159     /**
 160      * Unmarshals an X.509 CRL from an input stream. Only one CRL
 161      * is expected at the end of the input stream.
 162      *
 163      * @param inStrm an input stream holding at least one CRL
 164      * @exception CRLException on parsing errors.
 165      */
 166     public X509CRLImpl(InputStream inStrm) throws CRLException {
 167         try {
 168             parse(new DerValue(inStrm));
 169         } catch (IOException e) {
 170             signedCRL = null;
 171             throw new CRLException(&quot;Parsing error: &quot; + e.getMessage());
 172         }
 173     }
 174 
 175     /**
 176      * Initial CRL constructor, no revoked certs, and no extensions.
 177      *
 178      * @param issuer the name of the CA issuing this CRL.
 179      * @param thisDate the Date of this issue.
 180      * @param nextDate the Date of the next CRL.
 181      */
 182     public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate) {
 183         this.issuer = issuer;
 184         this.thisUpdate = thisDate;
 185         this.nextUpdate = nextDate;
 186     }
 187 
 188     /**
 189      * CRL constructor, revoked certs, no extensions.
 190      *
 191      * @param issuer the name of the CA issuing this CRL.
 192      * @param thisDate the Date of this issue.
 193      * @param nextDate the Date of the next CRL.
 194      * @param badCerts the array of CRL entries.
 195      *
 196      * @exception CRLException on parsing/construction errors.
 197      */
 198     public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate,
 199                        X509CRLEntry[] badCerts)
 200         throws CRLException
 201     {
 202         this.issuer = issuer;
 203         this.thisUpdate = thisDate;
 204         this.nextUpdate = nextDate;
 205         if (badCerts != null) {
 206             X500Principal crlIssuer = getIssuerX500Principal();
 207             X500Principal badCertIssuer = crlIssuer;
 208             for (int i = 0; i &lt; badCerts.length; i++) {
 209                 X509CRLEntryImpl badCert = (X509CRLEntryImpl)badCerts[i];
 210                 try {
 211                     badCertIssuer = getCertIssuer(badCert, badCertIssuer);
 212                 } catch (IOException ioe) {
 213                     throw new CRLException(ioe);
 214                 }
 215                 badCert.setCertificateIssuer(crlIssuer, badCertIssuer);
 216                 X509IssuerSerial issuerSerial = new X509IssuerSerial
 217                     (badCertIssuer, badCert.getSerialNumber());
 218                 this.revokedMap.put(issuerSerial, badCert);
 219                 this.revokedList.add(badCert);
 220                 if (badCert.hasExtensions()) {
 221                     this.version = 1;
 222                 }
 223             }
 224         }
 225     }
 226 
 227     /**
 228      * CRL constructor, revoked certs and extensions.
 229      *
 230      * @param issuer the name of the CA issuing this CRL.
 231      * @param thisDate the Date of this issue.
 232      * @param nextDate the Date of the next CRL.
 233      * @param badCerts the array of CRL entries.
 234      * @param crlExts the CRL extensions.
 235      *
 236      * @exception CRLException on parsing/construction errors.
 237      */
 238     public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate,
 239                X509CRLEntry[] badCerts, CRLExtensions crlExts)
 240         throws CRLException
 241     {
 242         this(issuer, thisDate, nextDate, badCerts);
 243         if (crlExts != null) {
 244             this.extensions = crlExts;
 245             this.version = 1;
 246         }
 247     }
 248 
 249     /**
 250      * Returned the encoding as an uncloned byte array. Callers must
 251      * guarantee that they neither modify it nor expose it to untrusted
 252      * code.
 253      */
 254     public byte[] getEncodedInternal() throws CRLException {
 255         if (signedCRL == null) {
 256             throw new CRLException(&quot;Null CRL to encode&quot;);
 257         }
 258         return signedCRL;
 259     }
 260 
 261     /**
 262      * Returns the ASN.1 DER encoded form of this CRL.
 263      *
 264      * @exception CRLException if an encoding error occurs.
 265      */
 266     public byte[] getEncoded() throws CRLException {
 267         return getEncodedInternal().clone();
 268     }
 269 
 270     /**
 271      * Encodes the &quot;to-be-signed&quot; CRL to the OutputStream.
 272      *
 273      * @param out the OutputStream to write to.
 274      * @exception CRLException on encoding errors.
 275      */
 276     public void encodeInfo(OutputStream out) throws CRLException {
 277         try {
 278             DerOutputStream tmp = new DerOutputStream();
 279             DerOutputStream rCerts = new DerOutputStream();
 280             DerOutputStream seq = new DerOutputStream();
 281 
 282             if (version != 0) // v2 crl encode version
 283                 tmp.putInteger(version);
<a name="1" id="anc1"></a><span class="line-modified"> 284             infoSigAlgId.derEncode(tmp);</span>
 285             if ((version == 0) &amp;&amp; (issuer.toString() == null))
 286                 throw new CRLException(&quot;Null Issuer DN not allowed in v1 CRL&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 287             issuer.derEncode(tmp);</span>
 288 
 289             if (thisUpdate.getTime() &lt; CertificateValidity.YR_2050)
 290                 tmp.putUTCTime(thisUpdate);
 291             else
 292                 tmp.putGeneralizedTime(thisUpdate);
 293 
 294             if (nextUpdate != null) {
 295                 if (nextUpdate.getTime() &lt; CertificateValidity.YR_2050)
 296                     tmp.putUTCTime(nextUpdate);
 297                 else
 298                     tmp.putGeneralizedTime(nextUpdate);
 299             }
 300 
 301             if (!revokedList.isEmpty()) {
 302                 for (X509CRLEntry entry : revokedList) {
 303                     ((X509CRLEntryImpl)entry).encode(rCerts);
 304                 }
 305                 tmp.write(DerValue.tag_Sequence, rCerts);
 306             }
 307 
 308             if (extensions != null)
 309                 extensions.encode(tmp, isExplicit);
 310 
 311             seq.write(DerValue.tag_Sequence, tmp);
 312 
 313             tbsCertList = seq.toByteArray();
 314             out.write(tbsCertList);
 315         } catch (IOException e) {
 316              throw new CRLException(&quot;Encoding error: &quot; + e.getMessage());
 317         }
 318     }
 319 
 320     /**
 321      * Verifies that this CRL was signed using the
 322      * private key that corresponds to the given public key.
 323      *
 324      * @param key the PublicKey used to carry out the verification.
 325      *
 326      * @exception NoSuchAlgorithmException on unsupported signature
 327      * algorithms.
 328      * @exception InvalidKeyException on incorrect key.
 329      * @exception NoSuchProviderException if there&#39;s no default provider.
 330      * @exception SignatureException on signature errors.
 331      * @exception CRLException on encoding errors.
 332      */
 333     public void verify(PublicKey key)
 334     throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 335            NoSuchProviderException, SignatureException {
 336         verify(key, &quot;&quot;);
 337     }
 338 
 339     /**
 340      * Verifies that this CRL was signed using the
 341      * private key that corresponds to the given public key,
 342      * and that the signature verification was computed by
 343      * the given provider.
 344      *
 345      * @param key the PublicKey used to carry out the verification.
 346      * @param sigProvider the name of the signature provider.
 347      *
 348      * @exception NoSuchAlgorithmException on unsupported signature
 349      * algorithms.
 350      * @exception InvalidKeyException on incorrect key.
 351      * @exception NoSuchProviderException on incorrect provider.
 352      * @exception SignatureException on signature errors.
 353      * @exception CRLException on encoding errors.
 354      */
 355     public synchronized void verify(PublicKey key, String sigProvider)
 356             throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 357             NoSuchProviderException, SignatureException {
 358 
 359         if (sigProvider == null) {
 360             sigProvider = &quot;&quot;;
 361         }
 362         if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
 363             // this CRL has already been successfully verified using
 364             // this public key. Make sure providers match, too.
 365             if (sigProvider.equals(verifiedProvider)) {
 366                 return;
 367             }
 368         }
 369         if (signedCRL == null) {
 370             throw new CRLException(&quot;Uninitialized CRL&quot;);
 371         }
 372         Signature   sigVerf = null;
 373         String sigName = sigAlgId.getName();
 374         if (sigProvider.isEmpty()) {
 375             sigVerf = Signature.getInstance(sigName);
 376         } else {
 377             sigVerf = Signature.getInstance(sigName, sigProvider);
 378         }
 379 
 380         try {
 381             SignatureUtil.initVerifyWithParam(sigVerf, key,
 382                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 383         } catch (ProviderException e) {
 384             throw new CRLException(e.getMessage(), e.getCause());
 385         } catch (InvalidAlgorithmParameterException e) {
 386             throw new CRLException(e);
 387         }
 388 
 389         if (tbsCertList == null) {
 390             throw new CRLException(&quot;Uninitialized CRL&quot;);
 391         }
 392 
 393         sigVerf.update(tbsCertList, 0, tbsCertList.length);
 394 
 395         if (!sigVerf.verify(signature)) {
 396             throw new SignatureException(&quot;Signature does not match.&quot;);
 397         }
 398         verifiedPublicKey = key;
 399         verifiedProvider = sigProvider;
 400     }
 401 
 402     /**
 403      * Verifies that this CRL was signed using the
 404      * private key that corresponds to the given public key,
 405      * and that the signature verification was computed by
 406      * the given provider. Note that the specified Provider object
 407      * does not have to be registered in the provider list.
 408      *
 409      * @param key the PublicKey used to carry out the verification.
 410      * @param sigProvider the signature provider.
 411      *
 412      * @exception NoSuchAlgorithmException on unsupported signature
 413      * algorithms.
 414      * @exception InvalidKeyException on incorrect key.
 415      * @exception SignatureException on signature errors.
 416      * @exception CRLException on encoding errors.
 417      */
 418     public synchronized void verify(PublicKey key, Provider sigProvider)
 419             throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 420             SignatureException {
 421 
 422         if (signedCRL == null) {
 423             throw new CRLException(&quot;Uninitialized CRL&quot;);
 424         }
 425         Signature sigVerf = null;
 426         String sigName = sigAlgId.getName();
 427         if (sigProvider == null) {
 428             sigVerf = Signature.getInstance(sigName);
 429         } else {
 430             sigVerf = Signature.getInstance(sigName, sigProvider);
 431         }
 432 
 433         try {
 434             SignatureUtil.initVerifyWithParam(sigVerf, key,
 435                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 436         } catch (ProviderException e) {
 437             throw new CRLException(e.getMessage(), e.getCause());
 438         } catch (InvalidAlgorithmParameterException e) {
 439             throw new CRLException(e);
 440         }
 441 
 442         if (tbsCertList == null) {
 443             throw new CRLException(&quot;Uninitialized CRL&quot;);
 444         }
 445 
 446         sigVerf.update(tbsCertList, 0, tbsCertList.length);
 447 
 448         if (!sigVerf.verify(signature)) {
 449             throw new SignatureException(&quot;Signature does not match.&quot;);
 450         }
 451         verifiedPublicKey = key;
 452     }
 453 
 454     /**
 455      * Encodes an X.509 CRL, and signs it using the given key.
 456      *
 457      * @param key the private key used for signing.
 458      * @param algorithm the name of the signature algorithm used.
 459      *
 460      * @exception NoSuchAlgorithmException on unsupported signature
 461      * algorithms.
 462      * @exception InvalidKeyException on incorrect key.
 463      * @exception NoSuchProviderException on incorrect provider.
 464      * @exception SignatureException on signature errors.
 465      * @exception CRLException if any mandatory data was omitted.
 466      */
 467     public void sign(PrivateKey key, String algorithm)
 468     throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 469         NoSuchProviderException, SignatureException {
 470         sign(key, algorithm, null);
 471     }
 472 
 473     /**
 474      * Encodes an X.509 CRL, and signs it using the given key.
 475      *
 476      * @param key the private key used for signing.
 477      * @param algorithm the name of the signature algorithm used.
 478      * @param provider the name of the provider.
 479      *
 480      * @exception NoSuchAlgorithmException on unsupported signature
 481      * algorithms.
 482      * @exception InvalidKeyException on incorrect key.
 483      * @exception NoSuchProviderException on incorrect provider.
 484      * @exception SignatureException on signature errors.
 485      * @exception CRLException if any mandatory data was omitted.
 486      */
 487     public void sign(PrivateKey key, String algorithm, String provider)
<a name="3" id="anc3"></a><span class="line-modified"> 488             throws CRLException, NoSuchAlgorithmException, InvalidKeyException,</span>
<span class="line-modified"> 489             NoSuchProviderException, SignatureException {</span>
<span class="line-added"> 490         if (readOnly)</span>
<span class="line-added"> 491             throw new CRLException(&quot;cannot over-write existing CRL&quot;);</span>
<span class="line-added"> 492         Signature sigEngine = null;</span>
<span class="line-added"> 493         if (provider == null || provider.isEmpty())</span>
<span class="line-added"> 494             sigEngine = Signature.getInstance(algorithm);</span>
<span class="line-added"> 495         else</span>
<span class="line-added"> 496             sigEngine = Signature.getInstance(algorithm, provider);</span>
<span class="line-added"> 497 </span>
<span class="line-added"> 498         AlgorithmParameterSpec params = AlgorithmId</span>
<span class="line-added"> 499                 .getDefaultAlgorithmParameterSpec(algorithm, key);</span>
 500         try {
<a name="4" id="anc4"></a><span class="line-modified"> 501             SignatureUtil.initSignWithParam(sigEngine, key, params, null);</span>
<span class="line-modified"> 502         } catch (InvalidAlgorithmParameterException e) {</span>
<span class="line-modified"> 503             throw new SignatureException(e);</span>
<span class="line-modified"> 504         }</span>











 505 
<a name="5" id="anc5"></a><span class="line-modified"> 506         if (params != null) {</span>
<span class="line-modified"> 507             sigAlgId = AlgorithmId.get(sigEngine.getParameters());</span>
<span class="line-modified"> 508         } else {</span>
<span class="line-modified"> 509             // in case the name is reset</span>
<span class="line-modified"> 510             sigAlgId = AlgorithmId.get(sigEngine.getAlgorithm());</span>
<span class="line-modified"> 511         }</span>
<span class="line-modified"> 512         infoSigAlgId = sigAlgId;</span>
 513 
<a name="6" id="anc6"></a><span class="line-modified"> 514         DerOutputStream out = new DerOutputStream();</span>
<span class="line-modified"> 515         DerOutputStream tmp = new DerOutputStream();</span>
 516 
<a name="7" id="anc7"></a><span class="line-modified"> 517         // encode crl info</span>
<span class="line-modified"> 518         encodeInfo(tmp);</span>
 519 
<a name="8" id="anc8"></a><span class="line-modified"> 520         // encode algorithm identifier</span>
<span class="line-modified"> 521         sigAlgId.derEncode(tmp);</span>
 522 
<a name="9" id="anc9"></a><span class="line-modified"> 523         // Create and encode the signature itself.</span>
<span class="line-modified"> 524         sigEngine.update(tbsCertList, 0, tbsCertList.length);</span>
<span class="line-modified"> 525         signature = sigEngine.sign();</span>
<span class="line-modified"> 526         tmp.putBitString(signature);</span>
 527 
<a name="10" id="anc10"></a><span class="line-modified"> 528         // Wrap the signed data in a SEQUENCE { data, algorithm, sig }</span>
<span class="line-modified"> 529         out.write(DerValue.tag_Sequence, tmp);</span>
<span class="line-modified"> 530         signedCRL = out.toByteArray();</span>
<span class="line-modified"> 531         readOnly = true;</span>
 532 
<a name="11" id="anc11"></a>



 533     }
 534 
 535     /**
 536      * Returns a printable string of this CRL.
 537      *
 538      * @return value of this CRL in a printable form.
 539      */
 540     public String toString() {
 541         return toStringWithAlgName(&quot;&quot; + sigAlgId);
 542     }
 543 
 544     // Specifically created for keytool to append a (weak) label to sigAlg
 545     public String toStringWithAlgName(String name) {
 546         StringBuilder sb = new StringBuilder();
 547         sb.append(&quot;X.509 CRL v&quot;)
 548             .append(version+1)
 549             .append(&#39;\n&#39;);
 550         if (sigAlgId != null)
 551             sb.append(&quot;Signature Algorithm: &quot;)
 552                 .append(name)
 553                 .append(&quot;, OID=&quot;)
 554                 .append(sigAlgId.getOID())
 555                 .append(&#39;\n&#39;);
 556         if (issuer != null)
 557             sb.append(&quot;Issuer: &quot;)
 558                 .append(issuer)
 559                 .append(&#39;\n&#39;);
 560         if (thisUpdate != null)
 561             sb.append(&quot;\nThis Update: &quot;)
 562                 .append(thisUpdate)
 563                 .append(&#39;\n&#39;);
 564         if (nextUpdate != null)
 565             sb.append(&quot;Next Update: &quot;)
 566                 .append(nextUpdate)
 567                 .append(&#39;\n&#39;);
 568         if (revokedList.isEmpty())
 569             sb.append(&quot;\nNO certificates have been revoked\n&quot;);
 570         else {
 571             sb.append(&quot;\nRevoked Certificates: &quot;)
 572                 .append(revokedList.size());
 573             int i = 1;
 574             for (X509CRLEntry entry: revokedList) {
 575                 sb.append(&quot;\n[&quot;)
 576                     .append(i++)
 577                     .append(&quot;] &quot;)
 578                     .append(entry);
 579             }
 580         }
 581         if (extensions != null) {
 582             Collection&lt;Extension&gt; allExts = extensions.getAllExtensions();
 583             Object[] objs = allExts.toArray();
 584             sb.append(&quot;\nCRL Extensions: &quot;)
 585                 .append(objs.length);
 586             for (int i = 0; i &lt; objs.length; i++) {
 587                 sb.append(&quot;\n[&quot;).append(i+1).append(&quot;]: &quot;);
 588                 Extension ext = (Extension)objs[i];
 589                 try {
 590                     if (OIDMap.getClass(ext.getExtensionId()) == null) {
 591                         sb.append(ext);
 592                         byte[] extValue = ext.getExtensionValue();
 593                         if (extValue != null) {
 594                             DerOutputStream out = new DerOutputStream();
 595                             out.putOctetString(extValue);
 596                             extValue = out.toByteArray();
 597                             HexDumpEncoder enc = new HexDumpEncoder();
 598                             sb.append(&quot;Extension unknown: &quot;)
 599                                 .append(&quot;DER encoded OCTET string =\n&quot;)
 600                                 .append(enc.encodeBuffer(extValue))
 601                                 .append(&#39;\n&#39;);
 602                         }
 603                     } else {
 604                         sb.append(ext); // sub-class exists
 605                     }
 606                 } catch (Exception e) {
 607                     sb.append(&quot;, Error parsing this extension&quot;);
 608                 }
 609             }
 610         }
 611         if (signature != null) {
 612             HexDumpEncoder encoder = new HexDumpEncoder();
 613             sb.append(&quot;\nSignature:\n&quot;)
 614                 .append(encoder.encodeBuffer(signature))
 615                 .append(&#39;\n&#39;);
 616         } else {
 617             sb.append(&quot;NOT signed yet\n&quot;);
 618         }
 619         return sb.toString();
 620     }
 621 
 622     /**
 623      * Checks whether the given certificate is on this CRL.
 624      *
 625      * @param cert the certificate to check for.
 626      * @return true if the given certificate is on this CRL,
 627      * false otherwise.
 628      */
 629     public boolean isRevoked(Certificate cert) {
 630         if (revokedMap.isEmpty() || (!(cert instanceof X509Certificate))) {
 631             return false;
 632         }
 633         X509Certificate xcert = (X509Certificate) cert;
 634         X509IssuerSerial issuerSerial = new X509IssuerSerial(xcert);
 635         return revokedMap.containsKey(issuerSerial);
 636     }
 637 
 638     /**
 639      * Gets the version number from this CRL.
 640      * The ASN.1 definition for this is:
 641      * &lt;pre&gt;
 642      * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
 643      *             -- v3 does not apply to CRLs but appears for consistency
 644      *             -- with definition of Version for certs
 645      * &lt;/pre&gt;
 646      * @return the version number, i.e. 1 or 2.
 647      */
 648     public int getVersion() {
 649         return version+1;
 650     }
 651 
 652     /**
 653      * Gets the issuer distinguished name from this CRL.
 654      * The issuer name identifies the entity who has signed (and
 655      * issued the CRL). The issuer name field contains an
 656      * X.500 distinguished name (DN).
 657      * The ASN.1 definition for this is:
 658      * &lt;pre&gt;
 659      * issuer    Name
 660      *
 661      * Name ::= CHOICE { RDNSequence }
 662      * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 663      * RelativeDistinguishedName ::=
 664      *     SET OF AttributeValueAssertion
 665      *
 666      * AttributeValueAssertion ::= SEQUENCE {
 667      *                               AttributeType,
 668      *                               AttributeValue }
 669      * AttributeType ::= OBJECT IDENTIFIER
 670      * AttributeValue ::= ANY
 671      * &lt;/pre&gt;
 672      * The Name describes a hierarchical name composed of attributes,
 673      * such as country name, and corresponding values, such as US.
 674      * The type of the component AttributeValue is determined by the
 675      * AttributeType; in general it will be a directoryString.
 676      * A directoryString is usually one of PrintableString,
 677      * TeletexString or UniversalString.
 678      * @return the issuer name.
 679      */
 680     public Principal getIssuerDN() {
 681         return (Principal)issuer;
 682     }
 683 
 684     /**
 685      * Return the issuer as X500Principal. Overrides method in X509CRL
 686      * to provide a slightly more efficient version.
 687      */
 688     public X500Principal getIssuerX500Principal() {
 689         if (issuerPrincipal == null) {
 690             issuerPrincipal = issuer.asX500Principal();
 691         }
 692         return issuerPrincipal;
 693     }
 694 
 695     /**
 696      * Gets the thisUpdate date from the CRL.
 697      * The ASN.1 definition for this is:
 698      *
 699      * @return the thisUpdate date from the CRL.
 700      */
 701     public Date getThisUpdate() {
 702         return (new Date(thisUpdate.getTime()));
 703     }
 704 
 705     /**
 706      * Gets the nextUpdate date from the CRL.
 707      *
 708      * @return the nextUpdate date from the CRL, or null if
 709      * not present.
 710      */
 711     public Date getNextUpdate() {
 712         if (nextUpdate == null)
 713             return null;
 714         return (new Date(nextUpdate.getTime()));
 715     }
 716 
 717     /**
 718      * Gets the CRL entry with the given serial number from this CRL.
 719      *
 720      * @return the entry with the given serial number, or &lt;code&gt;null&lt;/code&gt; if
 721      * no such entry exists in the CRL.
 722      * @see X509CRLEntry
 723      */
 724     public X509CRLEntry getRevokedCertificate(BigInteger serialNumber) {
 725         if (revokedMap.isEmpty()) {
 726             return null;
 727         }
 728         // assume this is a direct CRL entry (cert and CRL issuer are the same)
 729         X509IssuerSerial issuerSerial = new X509IssuerSerial
 730             (getIssuerX500Principal(), serialNumber);
 731         return revokedMap.get(issuerSerial);
 732     }
 733 
 734     /**
 735      * Gets the CRL entry for the given certificate.
 736      */
 737     public X509CRLEntry getRevokedCertificate(X509Certificate cert) {
 738         if (revokedMap.isEmpty()) {
 739             return null;
 740         }
 741         X509IssuerSerial issuerSerial = new X509IssuerSerial(cert);
 742         return revokedMap.get(issuerSerial);
 743     }
 744 
 745     /**
 746      * Gets all the revoked certificates from the CRL.
 747      * A Set of X509CRLEntry.
 748      *
 749      * @return all the revoked certificates or &lt;code&gt;null&lt;/code&gt; if there are
 750      * none.
 751      * @see X509CRLEntry
 752      */
 753     public Set&lt;X509CRLEntry&gt; getRevokedCertificates() {
 754         if (revokedList.isEmpty()) {
 755             return null;
 756         } else {
 757             return new TreeSet&lt;X509CRLEntry&gt;(revokedList);
 758         }
 759     }
 760 
 761     /**
 762      * Gets the DER encoded CRL information, the
 763      * &lt;code&gt;tbsCertList&lt;/code&gt; from this CRL.
 764      * This can be used to verify the signature independently.
 765      *
 766      * @return the DER encoded CRL information.
 767      * @exception CRLException on encoding errors.
 768      */
 769     public byte[] getTBSCertList() throws CRLException {
 770         if (tbsCertList == null)
 771             throw new CRLException(&quot;Uninitialized CRL&quot;);
 772         return tbsCertList.clone();
 773     }
 774 
 775     /**
 776      * Gets the raw Signature bits from the CRL.
 777      *
 778      * @return the signature.
 779      */
 780     public byte[] getSignature() {
 781         if (signature == null)
 782             return null;
 783         return signature.clone();
 784     }
 785 
 786     /**
 787      * Gets the signature algorithm name for the CRL
 788      * signature algorithm. For example, the string &quot;SHA1withDSA&quot;.
 789      * The ASN.1 definition for this is:
 790      * &lt;pre&gt;
 791      * AlgorithmIdentifier  ::=  SEQUENCE  {
 792      *     algorithm               OBJECT IDENTIFIER,
 793      *     parameters              ANY DEFINED BY algorithm OPTIONAL  }
 794      *                             -- contains a value of the type
 795      *                             -- registered for use with the
 796      *                             -- algorithm object identifier value
 797      * &lt;/pre&gt;
 798      *
 799      * @return the signature algorithm name.
 800      */
 801     public String getSigAlgName() {
 802         if (sigAlgId == null)
 803             return null;
 804         return sigAlgId.getName();
 805     }
 806 
 807     /**
 808      * Gets the signature algorithm OID string from the CRL.
 809      * An OID is represented by a set of positive whole number separated
 810      * by &quot;.&quot;, that means,&lt;br&gt;
 811      * &amp;lt;positive whole number&amp;gt;.&amp;lt;positive whole number&amp;gt;.&amp;lt;...&amp;gt;
 812      * For example, the string &quot;1.2.840.10040.4.3&quot; identifies the SHA-1
 813      * with DSA signature algorithm defined in
 814      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3279.txt&quot;&gt;RFC 3279: Algorithms and
 815      * Identifiers for the Internet X.509 Public Key Infrastructure Certificate
 816      * and CRL Profile&lt;/a&gt;.
 817      *
 818      * @return the signature algorithm oid string.
 819      */
 820     public String getSigAlgOID() {
 821         if (sigAlgId == null)
 822             return null;
 823         ObjectIdentifier oid = sigAlgId.getOID();
 824         return oid.toString();
 825     }
 826 
 827     /**
 828      * Gets the DER encoded signature algorithm parameters from this
 829      * CRL&#39;s signature algorithm. In most cases, the signature
 830      * algorithm parameters are null, the parameters are usually
 831      * supplied with the Public Key.
 832      *
 833      * @return the DER encoded signature algorithm parameters, or
 834      *         null if no parameters are present.
 835      */
 836     public byte[] getSigAlgParams() {
 837         if (sigAlgId == null)
 838             return null;
 839         try {
 840             return sigAlgId.getEncodedParams();
 841         } catch (IOException e) {
 842             return null;
 843         }
 844     }
 845 
 846     /**
 847      * Gets the signature AlgorithmId from the CRL.
 848      *
 849      * @return the signature AlgorithmId
 850      */
 851     public AlgorithmId getSigAlgId() {
 852         return sigAlgId;
 853     }
 854 
 855     /**
 856      * return the AuthorityKeyIdentifier, if any.
 857      *
 858      * @return AuthorityKeyIdentifier or null
 859      *         (if no AuthorityKeyIdentifierExtension)
 860      * @throws IOException on error
 861      */
 862     public KeyIdentifier getAuthKeyId() throws IOException {
 863         AuthorityKeyIdentifierExtension aki = getAuthKeyIdExtension();
 864         if (aki != null) {
 865             KeyIdentifier keyId = (KeyIdentifier)aki.get(
 866                     AuthorityKeyIdentifierExtension.KEY_ID);
 867             return keyId;
 868         } else {
 869             return null;
 870         }
 871     }
 872 
 873     /**
 874      * return the AuthorityKeyIdentifierExtension, if any.
 875      *
 876      * @return AuthorityKeyIdentifierExtension or null (if no such extension)
 877      * @throws IOException on error
 878      */
 879     public AuthorityKeyIdentifierExtension getAuthKeyIdExtension()
 880         throws IOException {
 881         Object obj = getExtension(PKIXExtensions.AuthorityKey_Id);
 882         return (AuthorityKeyIdentifierExtension)obj;
 883     }
 884 
 885     /**
 886      * return the CRLNumberExtension, if any.
 887      *
 888      * @return CRLNumberExtension or null (if no such extension)
 889      * @throws IOException on error
 890      */
 891     public CRLNumberExtension getCRLNumberExtension() throws IOException {
 892         Object obj = getExtension(PKIXExtensions.CRLNumber_Id);
 893         return (CRLNumberExtension)obj;
 894     }
 895 
 896     /**
 897      * return the CRL number from the CRLNumberExtension, if any.
 898      *
 899      * @return number or null (if no such extension)
 900      * @throws IOException on error
 901      */
 902     public BigInteger getCRLNumber() throws IOException {
 903         CRLNumberExtension numExt = getCRLNumberExtension();
 904         if (numExt != null) {
 905             BigInteger num = numExt.get(CRLNumberExtension.NUMBER);
 906             return num;
 907         } else {
 908             return null;
 909         }
 910     }
 911 
 912     /**
 913      * return the DeltaCRLIndicatorExtension, if any.
 914      *
 915      * @return DeltaCRLIndicatorExtension or null (if no such extension)
 916      * @throws IOException on error
 917      */
 918     public DeltaCRLIndicatorExtension getDeltaCRLIndicatorExtension()
 919         throws IOException {
 920 
 921         Object obj = getExtension(PKIXExtensions.DeltaCRLIndicator_Id);
 922         return (DeltaCRLIndicatorExtension)obj;
 923     }
 924 
 925     /**
 926      * return the base CRL number from the DeltaCRLIndicatorExtension, if any.
 927      *
 928      * @return number or null (if no such extension)
 929      * @throws IOException on error
 930      */
 931     public BigInteger getBaseCRLNumber() throws IOException {
 932         DeltaCRLIndicatorExtension dciExt = getDeltaCRLIndicatorExtension();
 933         if (dciExt != null) {
 934             BigInteger num = dciExt.get(DeltaCRLIndicatorExtension.NUMBER);
 935             return num;
 936         } else {
 937             return null;
 938         }
 939     }
 940 
 941     /**
 942      * return the IssuerAlternativeNameExtension, if any.
 943      *
 944      * @return IssuerAlternativeNameExtension or null (if no such extension)
 945      * @throws IOException on error
 946      */
 947     public IssuerAlternativeNameExtension getIssuerAltNameExtension()
 948         throws IOException {
 949         Object obj = getExtension(PKIXExtensions.IssuerAlternativeName_Id);
 950         return (IssuerAlternativeNameExtension)obj;
 951     }
 952 
 953     /**
 954      * return the IssuingDistributionPointExtension, if any.
 955      *
 956      * @return IssuingDistributionPointExtension or null
 957      *         (if no such extension)
 958      * @throws IOException on error
 959      */
 960     public IssuingDistributionPointExtension
 961         getIssuingDistributionPointExtension() throws IOException {
 962 
 963         Object obj = getExtension(PKIXExtensions.IssuingDistributionPoint_Id);
 964         return (IssuingDistributionPointExtension) obj;
 965     }
 966 
 967     /**
 968      * Return true if a critical extension is found that is
 969      * not supported, otherwise return false.
 970      */
 971     public boolean hasUnsupportedCriticalExtension() {
 972         if (extensions == null)
 973             return false;
 974         return extensions.hasUnsupportedCriticalExtension();
 975     }
 976 
 977     /**
 978      * Gets a Set of the extension(s) marked CRITICAL in the
 979      * CRL. In the returned set, each extension is represented by
 980      * its OID string.
 981      *
 982      * @return a set of the extension oid strings in the
 983      * CRL that are marked critical.
 984      */
 985     public Set&lt;String&gt; getCriticalExtensionOIDs() {
 986         if (extensions == null) {
 987             return null;
 988         }
 989         Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
 990         for (Extension ex : extensions.getAllExtensions()) {
 991             if (ex.isCritical()) {
 992                 extSet.add(ex.getExtensionId().toString());
 993             }
 994         }
 995         return extSet;
 996     }
 997 
 998     /**
 999      * Gets a Set of the extension(s) marked NON-CRITICAL in the
1000      * CRL. In the returned set, each extension is represented by
1001      * its OID string.
1002      *
1003      * @return a set of the extension oid strings in the
1004      * CRL that are NOT marked critical.
1005      */
1006     public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
1007         if (extensions == null) {
1008             return null;
1009         }
1010         Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
1011         for (Extension ex : extensions.getAllExtensions()) {
1012             if (!ex.isCritical()) {
1013                 extSet.add(ex.getExtensionId().toString());
1014             }
1015         }
1016         return extSet;
1017     }
1018 
1019     /**
1020      * Gets the DER encoded OCTET string for the extension value
1021      * (&lt;code&gt;extnValue&lt;/code&gt;) identified by the passed in oid String.
1022      * The &lt;code&gt;oid&lt;/code&gt; string is
1023      * represented by a set of positive whole number separated
1024      * by &quot;.&quot;, that means,&lt;br&gt;
1025      * &amp;lt;positive whole number&amp;gt;.&amp;lt;positive whole number&amp;gt;.&amp;lt;...&amp;gt;
1026      *
1027      * @param oid the Object Identifier value for the extension.
1028      * @return the der encoded octet string of the extension value.
1029      */
1030     public byte[] getExtensionValue(String oid) {
1031         if (extensions == null)
1032             return null;
1033         try {
1034             String extAlias = OIDMap.getName(ObjectIdentifier.of(oid));
1035             Extension crlExt = null;
1036 
1037             if (extAlias == null) { // may be unknown
1038                 ObjectIdentifier findOID = ObjectIdentifier.of(oid);
1039                 Extension ex = null;
1040                 ObjectIdentifier inCertOID;
1041                 for (Enumeration&lt;Extension&gt; e = extensions.getElements();
1042                                                  e.hasMoreElements();) {
1043                     ex = e.nextElement();
1044                     inCertOID = ex.getExtensionId();
1045                     if (inCertOID.equals(findOID)) {
1046                         crlExt = ex;
1047                         break;
1048                     }
1049                 }
1050             } else
1051                 crlExt = extensions.get(extAlias);
1052             if (crlExt == null)
1053                 return null;
1054             byte[] extData = crlExt.getExtensionValue();
1055             if (extData == null)
1056                 return null;
1057             DerOutputStream out = new DerOutputStream();
1058             out.putOctetString(extData);
1059             return out.toByteArray();
1060         } catch (Exception e) {
1061             return null;
1062         }
1063     }
1064 
1065     /**
1066      * get an extension
1067      *
1068      * @param oid ObjectIdentifier of extension desired
1069      * @return Object of type {@code &lt;extension&gt;} or null, if not found
1070      * @throws IOException on error
1071      */
1072     public Object getExtension(ObjectIdentifier oid) {
1073         if (extensions == null)
1074             return null;
1075 
1076         // XXX Consider cloning this
1077         return extensions.get(OIDMap.getName(oid));
1078     }
1079 
1080     /*
1081      * Parses an X.509 CRL, should be used only by constructors.
1082      */
1083     private void parse(DerValue val) throws CRLException, IOException {
1084         // check if can over write the certificate
1085         if (readOnly)
1086             throw new CRLException(&quot;cannot over-write existing CRL&quot;);
1087 
1088         if ( val.getData() == null || val.tag != DerValue.tag_Sequence)
1089             throw new CRLException(&quot;Invalid DER-encoded CRL data&quot;);
1090 
1091         signedCRL = val.toByteArray();
1092         DerValue[] seq = new DerValue[3];
1093 
1094         seq[0] = val.data.getDerValue();
1095         seq[1] = val.data.getDerValue();
1096         seq[2] = val.data.getDerValue();
1097 
1098         if (val.data.available() != 0)
1099             throw new CRLException(&quot;signed overrun, bytes = &quot;
1100                                      + val.data.available());
1101 
1102         if (seq[0].tag != DerValue.tag_Sequence)
1103             throw new CRLException(&quot;signed CRL fields invalid&quot;);
1104 
1105         sigAlgId = AlgorithmId.parse(seq[1]);
1106         signature = seq[2].getBitString();
1107 
1108         if (seq[1].data.available() != 0)
1109             throw new CRLException(&quot;AlgorithmId field overrun&quot;);
1110 
1111         if (seq[2].data.available() != 0)
1112             throw new CRLException(&quot;Signature field overrun&quot;);
1113 
1114         // the tbsCertsList
1115         tbsCertList = seq[0].toByteArray();
1116 
1117         // parse the information
1118         DerInputStream derStrm = seq[0].data;
1119         DerValue       tmp;
1120         byte           nextByte;
1121 
1122         // version (optional if v1)
1123         version = 0;   // by default, version = v1 == 0
1124         nextByte = (byte)derStrm.peekByte();
1125         if (nextByte == DerValue.tag_Integer) {
1126             version = derStrm.getInteger();
1127             if (version != 1)  // i.e. v2
1128                 throw new CRLException(&quot;Invalid version&quot;);
1129         }
1130         tmp = derStrm.getDerValue();
1131 
1132         // signature
1133         AlgorithmId tmpId = AlgorithmId.parse(tmp);
1134 
1135         // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
1136         if (! tmpId.equals(sigAlgId))
1137             throw new CRLException(&quot;Signature algorithm mismatch&quot;);
1138         infoSigAlgId = tmpId;
1139 
1140         // issuer
1141         issuer = new X500Name(derStrm);
1142         if (issuer.isEmpty()) {
1143             throw new CRLException(&quot;Empty issuer DN not allowed in X509CRLs&quot;);
1144         }
1145 
1146         // thisUpdate
1147         // check if UTCTime encoded or GeneralizedTime
1148 
1149         nextByte = (byte)derStrm.peekByte();
1150         if (nextByte == DerValue.tag_UtcTime) {
1151             thisUpdate = derStrm.getUTCTime();
1152         } else if (nextByte == DerValue.tag_GeneralizedTime) {
1153             thisUpdate = derStrm.getGeneralizedTime();
1154         } else {
1155             throw new CRLException(&quot;Invalid encoding for thisUpdate&quot;
1156                                    + &quot; (tag=&quot; + nextByte + &quot;)&quot;);
1157         }
1158 
1159         if (derStrm.available() == 0)
1160            return;     // done parsing no more optional fields present
1161 
1162         // nextUpdate (optional)
1163         nextByte = (byte)derStrm.peekByte();
1164         if (nextByte == DerValue.tag_UtcTime) {
1165             nextUpdate = derStrm.getUTCTime();
1166         } else if (nextByte == DerValue.tag_GeneralizedTime) {
1167             nextUpdate = derStrm.getGeneralizedTime();
1168         } // else it is not present
1169 
1170         if (derStrm.available() == 0)
1171             return;     // done parsing no more optional fields present
1172 
1173         // revokedCertificates (optional)
1174         nextByte = (byte)derStrm.peekByte();
1175         if ((nextByte == DerValue.tag_SequenceOf)
1176             &amp;&amp; (! ((nextByte &amp; 0x0c0) == 0x080))) {
1177             DerValue[] badCerts = derStrm.getSequence(4);
1178 
1179             X500Principal crlIssuer = getIssuerX500Principal();
1180             X500Principal badCertIssuer = crlIssuer;
1181             for (int i = 0; i &lt; badCerts.length; i++) {
1182                 X509CRLEntryImpl entry = new X509CRLEntryImpl(badCerts[i]);
1183                 badCertIssuer = getCertIssuer(entry, badCertIssuer);
1184                 entry.setCertificateIssuer(crlIssuer, badCertIssuer);
1185                 X509IssuerSerial issuerSerial = new X509IssuerSerial
1186                     (badCertIssuer, entry.getSerialNumber());
1187                 revokedMap.put(issuerSerial, entry);
1188                 revokedList.add(entry);
1189             }
1190         }
1191 
1192         if (derStrm.available() == 0)
1193             return;     // done parsing no extensions
1194 
1195         // crlExtensions (optional)
1196         tmp = derStrm.getDerValue();
1197         if (tmp.isConstructed() &amp;&amp; tmp.isContextSpecific((byte)0)) {
1198             extensions = new CRLExtensions(tmp.data);
1199         }
1200         readOnly = true;
1201     }
1202 
1203     /**
1204      * Extract the issuer X500Principal from an X509CRL. Parses the encoded
1205      * form of the CRL to preserve the principal&#39;s ASN.1 encoding.
1206      *
1207      * Called by java.security.cert.X509CRL.getIssuerX500Principal().
1208      */
1209     public static X500Principal getIssuerX500Principal(X509CRL crl) {
1210         try {
1211             byte[] encoded = crl.getEncoded();
1212             DerInputStream derIn = new DerInputStream(encoded);
1213             DerValue tbsCert = derIn.getSequence(3)[0];
1214             DerInputStream tbsIn = tbsCert.data;
1215 
1216             DerValue tmp;
1217             // skip version number if present
1218             byte nextByte = (byte)tbsIn.peekByte();
1219             if (nextByte == DerValue.tag_Integer) {
1220                 tmp = tbsIn.getDerValue();
1221             }
1222 
1223             tmp = tbsIn.getDerValue();  // skip signature
1224             tmp = tbsIn.getDerValue();  // issuer
1225             byte[] principalBytes = tmp.toByteArray();
1226             return new X500Principal(principalBytes);
1227         } catch (Exception e) {
1228             throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
1229         }
1230     }
1231 
1232     /**
1233      * Returned the encoding of the given certificate for internal use.
1234      * Callers must guarantee that they neither modify it nor expose it
1235      * to untrusted code. Uses getEncodedInternal() if the certificate
1236      * is instance of X509CertImpl, getEncoded() otherwise.
1237      */
1238     public static byte[] getEncodedInternal(X509CRL crl) throws CRLException {
1239         if (crl instanceof X509CRLImpl) {
1240             return ((X509CRLImpl)crl).getEncodedInternal();
1241         } else {
1242             return crl.getEncoded();
1243         }
1244     }
1245 
1246     /**
1247      * Utility method to convert an arbitrary instance of X509CRL
1248      * to a X509CRLImpl. Does a cast if possible, otherwise reparses
1249      * the encoding.
1250      */
1251     public static X509CRLImpl toImpl(X509CRL crl)
1252             throws CRLException {
1253         if (crl instanceof X509CRLImpl) {
1254             return (X509CRLImpl)crl;
1255         } else {
1256             return X509Factory.intern(crl);
1257         }
1258     }
1259 
1260     /**
1261      * Returns the X500 certificate issuer DN of a CRL entry.
1262      *
1263      * @param entry the entry to check
1264      * @param prevCertIssuer the previous entry&#39;s certificate issuer
1265      * @return the X500Principal in a CertificateIssuerExtension, or
1266      *   prevCertIssuer if it does not exist
1267      */
1268     private X500Principal getCertIssuer(X509CRLEntryImpl entry,
1269         X500Principal prevCertIssuer) throws IOException {
1270 
1271         CertificateIssuerExtension ciExt =
1272             entry.getCertificateIssuerExtension();
1273         if (ciExt != null) {
1274             GeneralNames names = ciExt.get(CertificateIssuerExtension.ISSUER);
1275             X500Name issuerDN = (X500Name) names.get(0).getName();
1276             return issuerDN.asX500Principal();
1277         } else {
1278             return prevCertIssuer;
1279         }
1280     }
1281 
1282     @Override
<a name="12" id="anc12"></a><span class="line-modified">1283     public void derEncode(DerOutputStream out) {</span>
<span class="line-modified">1284         if (signedCRL == null) {</span>
<span class="line-modified">1285             throw new IllegalStateException(&quot;Null CRL to encode&quot;);</span>
<span class="line-added">1286         }</span>
1287         out.write(signedCRL.clone());
1288     }
1289 
1290     /**
1291      * Immutable X.509 Certificate Issuer DN and serial number pair
1292      */
1293     private static final class X509IssuerSerial
1294             implements Comparable&lt;X509IssuerSerial&gt; {
1295         final X500Principal issuer;
1296         final BigInteger serial;
1297         volatile int hashcode;
1298 
1299         /**
1300          * Create an X509IssuerSerial.
1301          *
1302          * @param issuer the issuer DN
1303          * @param serial the serial number
1304          */
1305         X509IssuerSerial(X500Principal issuer, BigInteger serial) {
1306             this.issuer = issuer;
1307             this.serial = serial;
1308         }
1309 
1310         /**
1311          * Construct an X509IssuerSerial from an X509Certificate.
1312          */
1313         X509IssuerSerial(X509Certificate cert) {
1314             this(cert.getIssuerX500Principal(), cert.getSerialNumber());
1315         }
1316 
1317         /**
1318          * Returns the issuer.
1319          *
1320          * @return the issuer
1321          */
1322         X500Principal getIssuer() {
1323             return issuer;
1324         }
1325 
1326         /**
1327          * Returns the serial number.
1328          *
1329          * @return the serial number
1330          */
1331         BigInteger getSerial() {
1332             return serial;
1333         }
1334 
1335         /**
1336          * Compares this X509Serial with another and returns true if they
1337          * are equivalent.
1338          *
1339          * @param o the other object to compare with
1340          * @return true if equal, false otherwise
1341          */
1342         public boolean equals(Object o) {
1343             if (o == this) {
1344                 return true;
1345             }
1346 
1347             if (!(o instanceof X509IssuerSerial)) {
1348                 return false;
1349             }
1350 
1351             X509IssuerSerial other = (X509IssuerSerial) o;
1352             if (serial.equals(other.getSerial()) &amp;&amp;
1353                 issuer.equals(other.getIssuer())) {
1354                 return true;
1355             }
1356             return false;
1357         }
1358 
1359         /**
1360          * Returns a hash code value for this X509IssuerSerial.
1361          *
1362          * @return the hash code value
1363          */
1364         public int hashCode() {
1365             int h = hashcode;
1366             if (h == 0) {
1367                 h = 17;
1368                 h = 37*h + issuer.hashCode();
1369                 h = 37*h + serial.hashCode();
1370                 if (h != 0) {
1371                     hashcode = h;
1372                 }
1373             }
1374             return h;
1375         }
1376 
1377         @Override
1378         public int compareTo(X509IssuerSerial another) {
1379             int cissuer = issuer.toString()
1380                     .compareTo(another.issuer.toString());
1381             if (cissuer != 0) return cissuer;
1382             return this.serial.compareTo(another.serial);
1383         }
1384     }
1385 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
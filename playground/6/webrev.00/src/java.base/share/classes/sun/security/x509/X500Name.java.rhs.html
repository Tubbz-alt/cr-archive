<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/X500Name.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.lang.reflect.*;
  29 import java.io.IOException;
  30 import java.security.PrivilegedExceptionAction;
  31 import java.security.AccessController;
  32 import java.security.Principal;
  33 import java.util.*;
  34 import java.util.StringJoiner;
  35 
  36 import sun.security.util.*;
  37 import javax.security.auth.x500.X500Principal;
  38 
  39 /**
  40  * Note:  As of 1.4, the public class,
  41  * javax.security.auth.x500.X500Principal,
  42  * should be used when parsing, generating, and comparing X.500 DNs.
  43  * This class contains other useful methods for checking name constraints
  44  * and retrieving DNs by keyword.
  45  *
  46  * &lt;p&gt; X.500 names are used to identify entities, such as those which are
  47  * identified by X.509 certificates.  They are world-wide, hierarchical,
  48  * and descriptive.  Entities can be identified by attributes, and in
  49  * some systems can be searched for according to those attributes.
  50  * &lt;p&gt;
  51  * The ASN.1 for this is:
  52  * &lt;pre&gt;
  53  * GeneralName ::= CHOICE {
  54  * ....
  55  *     directoryName                   [4]     Name,
  56  * ....
  57  * Name ::= CHOICE {
  58  *   RDNSequence }
  59  *
  60  * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
  61  *
  62  * RelativeDistinguishedName ::=
  63  *   SET OF AttributeTypeAndValue
  64  *
  65  * AttributeTypeAndValue ::= SEQUENCE {
  66  *   type     AttributeType,
  67  *   value    AttributeValue }
  68  *
  69  * AttributeType ::= OBJECT IDENTIFIER
  70  *
  71  * AttributeValue ::= ANY DEFINED BY AttributeType
  72  * ....
  73  * DirectoryString ::= CHOICE {
  74  *       teletexString           TeletexString (SIZE (1..MAX)),
  75  *       printableString         PrintableString (SIZE (1..MAX)),
  76  *       universalString         UniversalString (SIZE (1..MAX)),
  77  *       utf8String              UTF8String (SIZE (1.. MAX)),
  78  *       bmpString               BMPString (SIZE (1..MAX)) }
  79  * &lt;/pre&gt;
  80  * &lt;p&gt;
  81  * This specification requires only a subset of the name comparison
  82  * functionality specified in the X.500 series of specifications.  The
  83  * requirements for conforming implementations are as follows:
  84  * &lt;ol TYPE=a&gt;
  85  * &lt;li&gt;attribute values encoded in different types (e.g.,
  86  *    PrintableString and BMPString) may be assumed to represent
  87  *    different strings;
  88  *
  89  * &lt;li&gt;attribute values in types other than PrintableString are case
  90  *    sensitive (this permits matching of attribute values as binary
  91  *    objects);
  92  *
  93  * &lt;li&gt;attribute values in PrintableString are not case sensitive
  94  *    (e.g., &quot;Marianne Swanson&quot; is the same as &quot;MARIANNE SWANSON&quot;); and
  95  *
  96  * &lt;li&gt;attribute values in PrintableString are compared after
  97  *    removing leading and trailing white space and converting internal
  98  *    substrings of one or more consecutive white space characters to a
  99  *    single space.
 100  * &lt;/ol&gt;
 101  * &lt;p&gt;
 102  * These name comparison rules permit a certificate user to validate
 103  * certificates issued using languages or encodings unfamiliar to the
 104  * certificate user.
 105  * &lt;p&gt;
 106  * In addition, implementations of this specification MAY use these
 107  * comparison rules to process unfamiliar attribute types for name
 108  * chaining. This allows implementations to process certificates with
 109  * unfamiliar attributes in the issuer name.
 110  * &lt;p&gt;
 111  * Note that the comparison rules defined in the X.500 series of
 112  * specifications indicate that the character sets used to encode data
 113  * in distinguished names are irrelevant.  The characters themselves are
 114  * compared without regard to encoding. Implementations of the profile
 115  * are permitted to use the comparison algorithm defined in the X.500
 116  * series.  Such an implementation will recognize a superset of name
 117  * matches recognized by the algorithm specified above.
 118  * &lt;p&gt;
 119  * Note that instances of this class are immutable.
 120  *
 121  * @author David Brownell
 122  * @author Amit Kapoor
 123  * @author Hemma Prafullchandra
 124  * @see GeneralName
 125  * @see GeneralNames
 126  * @see GeneralNameInterface
 127  */
 128 
 129 public class X500Name implements GeneralNameInterface, Principal {
 130 
 131     private String dn; // roughly RFC 1779 DN, or null
 132     private String rfc1779Dn; // RFC 1779 compliant DN, or null
 133     private String rfc2253Dn; // RFC 2253 DN, or null
 134     private String canonicalDn; // canonical RFC 2253 DN or null
 135     private RDN[] names;        // RDNs (never null)
 136     private X500Principal x500Principal;
 137     private byte[] encoded;
 138 
 139     // cached immutable list of the RDNs and all the AVAs
 140     private volatile List&lt;RDN&gt; rdnList;
 141     private volatile List&lt;AVA&gt; allAvaList;
 142 
 143     /**
 144      * Constructs a name from a conventionally formatted string, such
 145      * as &quot;CN=Dave, OU=JavaSoft, O=Sun Microsystems, C=US&quot;.
 146      * (RFC 1779, 2253, or 4514 style).
 147      *
 148      * @param dname the X.500 Distinguished Name
 149      */
 150     public X500Name(String dname) throws IOException {
 151         this(dname, Collections.&lt;String, String&gt;emptyMap());
 152     }
 153 
 154     /**
 155      * Constructs a name from a conventionally formatted string, such
 156      * as &quot;CN=Dave, OU=JavaSoft, O=Sun Microsystems, C=US&quot;.
 157      * (RFC 1779, 2253, or 4514 style).
 158      *
 159      * @param dname the X.500 Distinguished Name
 160      * @param keywordMap an additional keyword/OID map
 161      */
 162     public X500Name(String dname, Map&lt;String, String&gt; keywordMap)
 163         throws IOException {
 164         parseDN(dname, keywordMap);
 165     }
 166 
 167     /**
 168      * Constructs a name from a string formatted according to format.
 169      * Currently, the formats DEFAULT and RFC2253 are supported.
 170      * DEFAULT is the default format used by the X500Name(String)
 171      * constructor. RFC2253 is the format strictly according to RFC2253
 172      * without extensions.
 173      *
 174      * @param dname the X.500 Distinguished Name
 175      * @param format the specified format of the String DN
 176      */
 177     public X500Name(String dname, String format) throws IOException {
 178         if (dname == null) {
 179             throw new NullPointerException(&quot;Name must not be null&quot;);
 180         }
 181         if (format.equalsIgnoreCase(&quot;RFC2253&quot;)) {
 182             parseRFC2253DN(dname);
 183         } else if (format.equalsIgnoreCase(&quot;DEFAULT&quot;)) {
 184             parseDN(dname, Collections.&lt;String, String&gt;emptyMap());
 185         } else {
 186             throw new IOException(&quot;Unsupported format &quot; + format);
 187         }
 188     }
 189 
 190     /**
 191      * Constructs a name from fields common in enterprise application
 192      * environments.
 193      *
 194      * &lt;P&gt;&lt;EM&gt;&lt;STRONG&gt;NOTE:&lt;/STRONG&gt;  The behaviour when any of
 195      * these strings contain characters outside the ASCII range
 196      * is unspecified in currently relevant standards.&lt;/EM&gt;
 197      *
 198      * @param commonName common name of a person, e.g. &quot;Vivette Davis&quot;
 199      * @param organizationUnit small organization name, e.g. &quot;Purchasing&quot;
 200      * @param organizationName large organization name, e.g. &quot;Onizuka, Inc.&quot;
 201      * @param country two letter country code, e.g. &quot;CH&quot;
 202      */
 203     public X500Name(String commonName, String organizationUnit,
 204                      String organizationName, String country)
 205     throws IOException {
 206         names = new RDN[4];
 207         /*
 208          * NOTE:  it&#39;s only on output that little-endian
 209          * ordering is used.
 210          */
 211         names[3] = new RDN(1);
 212         names[3].assertion[0] = new AVA(commonName_oid,
 213                 new DerValue(commonName));
 214         names[2] = new RDN(1);
 215         names[2].assertion[0] = new AVA(orgUnitName_oid,
 216                 new DerValue(organizationUnit));
 217         names[1] = new RDN(1);
 218         names[1].assertion[0] = new AVA(orgName_oid,
 219                 new DerValue(organizationName));
 220         names[0] = new RDN(1);
 221         names[0].assertion[0] = new AVA(countryName_oid,
 222                 new DerValue(country));
 223     }
 224 
 225     /**
 226      * Constructs a name from fields common in Internet application
 227      * environments.
 228      *
 229      * &lt;P&gt;&lt;EM&gt;&lt;STRONG&gt;NOTE:&lt;/STRONG&gt;  The behaviour when any of
 230      * these strings contain characters outside the ASCII range
 231      * is unspecified in currently relevant standards.&lt;/EM&gt;
 232      *
 233      * @param commonName common name of a person, e.g. &quot;Vivette Davis&quot;
 234      * @param organizationUnit small organization name, e.g. &quot;Purchasing&quot;
 235      * @param organizationName large organization name, e.g. &quot;Onizuka, Inc.&quot;
 236      * @param localityName locality (city) name, e.g. &quot;Palo Alto&quot;
 237      * @param stateName state name, e.g. &quot;California&quot;
 238      * @param country two letter country code, e.g. &quot;CH&quot;
 239      */
 240     public X500Name(String commonName, String organizationUnit,
 241                     String organizationName, String localityName,
 242                     String stateName, String country)
 243     throws IOException {
 244         names = new RDN[6];
 245         /*
 246          * NOTE:  it&#39;s only on output that little-endian
 247          * ordering is used.
 248          */
 249         names[5] = new RDN(1);
 250         names[5].assertion[0] = new AVA(commonName_oid,
 251                 new DerValue(commonName));
 252         names[4] = new RDN(1);
 253         names[4].assertion[0] = new AVA(orgUnitName_oid,
 254                 new DerValue(organizationUnit));
 255         names[3] = new RDN(1);
 256         names[3].assertion[0] = new AVA(orgName_oid,
 257                 new DerValue(organizationName));
 258         names[2] = new RDN(1);
 259         names[2].assertion[0] = new AVA(localityName_oid,
 260                 new DerValue(localityName));
 261         names[1] = new RDN(1);
 262         names[1].assertion[0] = new AVA(stateName_oid,
 263                 new DerValue(stateName));
 264         names[0] = new RDN(1);
 265         names[0].assertion[0] = new AVA(countryName_oid,
 266                 new DerValue(country));
 267     }
 268 
 269     /**
 270      * Constructs a name from an array of relative distinguished names
 271      *
 272      * @param rdnArray array of relative distinguished names
 273      * @throws IOException on error
 274      */
 275     public X500Name(RDN[] rdnArray) throws IOException {
 276         if (rdnArray == null) {
 277             names = new RDN[0];
 278         } else {
 279             names = rdnArray.clone();
 280             for (int i = 0; i &lt; names.length; i++) {
 281                 if (names[i] == null) {
 282                     throw new IOException(&quot;Cannot create an X500Name&quot;);
 283                 }
 284             }
 285         }
 286     }
 287 
 288     /**
 289      * Constructs a name from an ASN.1 encoded value.  The encoding
 290      * of the name in the stream uses DER (a BER/1 subset).
 291      *
 292      * @param value a DER-encoded value holding an X.500 name.
 293      */
 294     public X500Name(DerValue value) throws IOException {
 295         //Note that toDerInputStream uses only the buffer (data) and not
 296         //the tag, so an empty SEQUENCE (OF) will yield an empty DerInputStream
 297         this(value.toDerInputStream());
 298     }
 299 
 300     /**
 301      * Constructs a name from an ASN.1 encoded input stream.  The encoding
 302      * of the name in the stream uses DER (a BER/1 subset).
 303      *
 304      * @param in DER-encoded data holding an X.500 name.
 305      */
 306     public X500Name(DerInputStream in) throws IOException {
 307         parseDER(in);
 308     }
 309 
 310     /**
 311      *  Constructs a name from an ASN.1 encoded byte array.
 312      *
 313      * @param name DER-encoded byte array holding an X.500 name.
 314      */
 315     public X500Name(byte[] name) throws IOException {
 316         DerInputStream in = new DerInputStream(name);
 317         parseDER(in);
 318     }
 319 
 320     /**
 321      * Return an immutable List of all RDNs in this X500Name.
 322      */
 323     public List&lt;RDN&gt; rdns() {
 324         List&lt;RDN&gt; list = rdnList;
 325         if (list == null) {
 326             list = Collections.unmodifiableList(Arrays.asList(names));
 327             rdnList = list;
 328         }
 329         return list;
 330     }
 331 
 332     /**
 333      * Return the number of RDNs in this X500Name.
 334      */
 335     public int size() {
 336         return names.length;
 337     }
 338 
 339     /**
 340      * Return an immutable List of the AVAs contained in all the
 341      * RDNs of this X500Name.
 342      */
 343     public List&lt;AVA&gt; allAvas() {
 344         List&lt;AVA&gt; list = allAvaList;
 345         if (list == null) {
 346             list = new ArrayList&lt;&gt;();
 347             for (int i = 0; i &lt; names.length; i++) {
 348                 list.addAll(names[i].avas());
 349             }
 350             list = Collections.unmodifiableList(list);
 351             allAvaList = list;
 352         }
 353         return list;
 354     }
 355 
 356     /**
 357      * Return the total number of AVAs contained in all the RDNs of
 358      * this X500Name.
 359      */
 360     public int avaSize() {
 361         return allAvas().size();
 362     }
 363 
 364     /**
 365      * Return whether this X500Name is empty. An X500Name is not empty
 366      * if it has at least one RDN containing at least one AVA.
 367      */
 368     public boolean isEmpty() {
 369         int n = names.length;
 370         for (int i = 0; i &lt; n; i++) {
 371             if (names[i].assertion.length != 0) {
 372                 return false;
 373             }
 374         }
 375         return true;
 376     }
 377 
 378     /**
 379      * Calculates a hash code value for the object.  Objects
 380      * which are equal will also have the same hashcode.
 381      */
 382     public int hashCode() {
 383         return getRFC2253CanonicalName().hashCode();
 384     }
 385 
 386     /**
 387      * Compares this name with another, for equality.
 388      *
 389      * @return true iff the names are identical.
 390      */
 391     public boolean equals(Object obj) {
 392         if (this == obj) {
 393             return true;
 394         }
 395         if (obj instanceof X500Name == false) {
 396             return false;
 397         }
 398         X500Name other = (X500Name)obj;
 399         // if we already have the canonical forms, compare now
 400         if ((this.canonicalDn != null) &amp;&amp; (other.canonicalDn != null)) {
 401             return this.canonicalDn.equals(other.canonicalDn);
 402         }
 403         // quick check that number of RDNs and AVAs match before canonicalizing
 404         int n = this.names.length;
 405         if (n != other.names.length) {
 406             return false;
 407         }
 408         for (int i = 0; i &lt; n; i++) {
 409             RDN r1 = this.names[i];
 410             RDN r2 = other.names[i];
 411             if (r1.assertion.length != r2.assertion.length) {
 412                 return false;
 413             }
 414         }
 415         // definite check via canonical form
 416         String thisCanonical = this.getRFC2253CanonicalName();
 417         String otherCanonical = other.getRFC2253CanonicalName();
 418         return thisCanonical.equals(otherCanonical);
 419     }
 420 
 421     /*
 422      * Returns the name component as a Java string, regardless of its
 423      * encoding restrictions.
 424      */
 425     private String getString(DerValue attribute) throws IOException {
 426         if (attribute == null)
 427             return null;
 428         String  value = attribute.getAsString();
 429 
 430         if (value == null)
 431             throw new IOException(&quot;not a DER string encoding, &quot;
 432                     + attribute.tag);
 433         else
 434             return value;
 435     }
 436 
 437     /**
 438      * Return type of GeneralName.
 439      */
 440     public int getType() {
 441         return (GeneralNameInterface.NAME_DIRECTORY);
 442     }
 443 
 444     /**
 445      * Returns a &quot;Country&quot; name component.  If more than one
 446      * such attribute exists, the topmost one is returned.
 447      *
 448      * @return &quot;C=&quot; component of the name, if any.
 449      */
 450     public String getCountry() throws IOException {
 451         DerValue attr = findAttribute(countryName_oid);
 452 
 453         return getString(attr);
 454     }
 455 
 456 
 457     /**
 458      * Returns an &quot;Organization&quot; name component.  If more than
 459      * one such attribute exists, the topmost one is returned.
 460      *
 461      * @return &quot;O=&quot; component of the name, if any.
 462      */
 463     public String getOrganization() throws IOException {
 464         DerValue attr = findAttribute(orgName_oid);
 465 
 466         return getString(attr);
 467     }
 468 
 469 
 470     /**
 471      * Returns an &quot;Organizational Unit&quot; name component.  If more
 472      * than one such attribute exists, the topmost one is returned.
 473      *
 474      * @return &quot;OU=&quot; component of the name, if any.
 475      */
 476     public String getOrganizationalUnit() throws IOException {
 477         DerValue attr = findAttribute(orgUnitName_oid);
 478 
 479         return getString(attr);
 480     }
 481 
 482 
 483     /**
 484      * Returns a &quot;Common Name&quot; component.  If more than one such
 485      * attribute exists, the topmost one is returned.
 486      *
 487      * @return &quot;CN=&quot; component of the name, if any.
 488      */
 489     public String getCommonName() throws IOException {
 490         DerValue attr = findAttribute(commonName_oid);
 491 
 492         return getString(attr);
 493     }
 494 
 495 
 496     /**
 497      * Returns a &quot;Locality&quot; name component.  If more than one
 498      * such component exists, the topmost one is returned.
 499      *
 500      * @return &quot;L=&quot; component of the name, if any.
 501      */
 502     public String getLocality() throws IOException {
 503         DerValue attr = findAttribute(localityName_oid);
 504 
 505         return getString(attr);
 506     }
 507 
 508     /**
 509      * Returns a &quot;State&quot; name component.  If more than one
 510      * such component exists, the topmost one is returned.
 511      *
 512      * @return &quot;S=&quot; component of the name, if any.
 513      */
 514     public String getState() throws IOException {
 515       DerValue attr = findAttribute(stateName_oid);
 516 
 517         return getString(attr);
 518     }
 519 
 520     /**
 521      * Returns a &quot;Domain&quot; name component.  If more than one
 522      * such component exists, the topmost one is returned.
 523      *
 524      * @return &quot;DC=&quot; component of the name, if any.
 525      */
 526     public String getDomain() throws IOException {
 527         DerValue attr = findAttribute(DOMAIN_COMPONENT_OID);
 528 
 529         return getString(attr);
 530     }
 531 
 532     /**
 533      * Returns a &quot;DN Qualifier&quot; name component.  If more than one
 534      * such component exists, the topmost one is returned.
 535      *
 536      * @return &quot;DNQ=&quot; component of the name, if any.
 537      */
 538     public String getDNQualifier() throws IOException {
 539         DerValue attr = findAttribute(DNQUALIFIER_OID);
 540 
 541         return getString(attr);
 542     }
 543 
 544     /**
 545      * Returns a &quot;Surname&quot; name component.  If more than one
 546      * such component exists, the topmost one is returned.
 547      *
 548      * @return &quot;SURNAME=&quot; component of the name, if any.
 549      */
 550     public String getSurname() throws IOException {
 551         DerValue attr = findAttribute(SURNAME_OID);
 552 
 553         return getString(attr);
 554     }
 555 
 556     /**
 557      * Returns a &quot;Given Name&quot; name component.  If more than one
 558      * such component exists, the topmost one is returned.
 559      *
 560      * @return &quot;GIVENNAME=&quot; component of the name, if any.
 561      */
 562     public String getGivenName() throws IOException {
 563        DerValue attr = findAttribute(GIVENNAME_OID);
 564 
 565        return getString(attr);
 566     }
 567 
 568     /**
 569      * Returns an &quot;Initials&quot; name component.  If more than one
 570      * such component exists, the topmost one is returned.
 571      *
 572      * @return &quot;INITIALS=&quot; component of the name, if any.
 573      */
 574     public String getInitials() throws IOException {
 575         DerValue attr = findAttribute(INITIALS_OID);
 576 
 577         return getString(attr);
 578      }
 579 
 580      /**
 581       * Returns a &quot;Generation Qualifier&quot; name component.  If more than one
 582       * such component exists, the topmost one is returned.
 583       *
 584       * @return &quot;GENERATION=&quot; component of the name, if any.
 585       */
 586     public String getGeneration() throws IOException {
 587         DerValue attr = findAttribute(GENERATIONQUALIFIER_OID);
 588 
 589         return getString(attr);
 590     }
 591 
 592     /**
 593      * Returns an &quot;IP address&quot; name component.  If more than one
 594      * such component exists, the topmost one is returned.
 595      *
 596      * @return &quot;IP=&quot; component of the name, if any.
 597      */
 598     public String getIP() throws IOException {
 599         DerValue attr = findAttribute(ipAddress_oid);
 600 
 601         return getString(attr);
 602     }
 603 
 604     /**
 605      * Returns a string form of the X.500 distinguished name.
 606      * The format of the string is from RFC 1779. The returned string
 607      * may contain non-standardised keywords for more readability
 608      * (keywords from RFCs 1779, 2253, and 5280).
 609      */
 610     public String toString() {
 611         if (dn == null) {
 612             generateDN();
 613         }
 614         return dn;
 615     }
 616 
 617     /**
 618      * Returns a string form of the X.500 distinguished name
 619      * using the algorithm defined in RFC 1779. Only standard attribute type
 620      * keywords defined in RFC 1779 are emitted.
 621      */
 622     public String getRFC1779Name() {
 623         return getRFC1779Name(Collections.&lt;String, String&gt;emptyMap());
 624     }
 625 
 626     /**
 627      * Returns a string form of the X.500 distinguished name
 628      * using the algorithm defined in RFC 1779. Attribute type
 629      * keywords defined in RFC 1779 are emitted, as well as additional
 630      * keywords contained in the OID/keyword map.
 631      */
 632     public String getRFC1779Name(Map&lt;String, String&gt; oidMap)
 633         throws IllegalArgumentException {
 634         if (oidMap.isEmpty()) {
 635             // return cached result
 636             if (rfc1779Dn != null) {
 637                 return rfc1779Dn;
 638             } else {
 639                 rfc1779Dn = generateRFC1779DN(oidMap);
 640                 return rfc1779Dn;
 641             }
 642         }
 643         return generateRFC1779DN(oidMap);
 644     }
 645 
 646     /**
 647      * Returns a string form of the X.500 distinguished name
 648      * using the algorithm defined in RFC 2253. Only standard attribute type
 649      * keywords defined in RFC 2253 are emitted.
 650      */
 651     public String getRFC2253Name() {
 652         return getRFC2253Name(Collections.&lt;String, String&gt;emptyMap());
 653     }
 654 
 655     /**
 656      * Returns a string form of the X.500 distinguished name
 657      * using the algorithm defined in RFC 2253. Attribute type
 658      * keywords defined in RFC 2253 are emitted, as well as additional
 659      * keywords contained in the OID/keyword map.
 660      */
 661     public String getRFC2253Name(Map&lt;String, String&gt; oidMap) {
 662         /* check for and return cached name */
 663         if (oidMap.isEmpty()) {
 664             if (rfc2253Dn != null) {
 665                 return rfc2253Dn;
 666             } else {
 667                 rfc2253Dn = generateRFC2253DN(oidMap);
 668                 return rfc2253Dn;
 669             }
 670         }
 671         return generateRFC2253DN(oidMap);
 672     }
 673 
 674     private String generateRFC2253DN(Map&lt;String, String&gt; oidMap) {
 675         /*
 676          * Section 2.1 : if the RDNSequence is an empty sequence
 677          * the result is the empty or zero length string.
 678          */
 679         if (names.length == 0) {
 680             return &quot;&quot;;
 681         }
 682 
 683         /*
 684          * 2.1 (continued) : Otherwise, the output consists of the string
 685          * encodings of each RelativeDistinguishedName in the RDNSequence
 686          * (according to 2.2), starting with the last element of the sequence
 687          * and moving backwards toward the first.
 688          *
 689          * The encodings of adjoining RelativeDistinguishedNames are separated
 690          * by a comma character (&#39;,&#39; ASCII 44).
 691          */
 692         StringJoiner sj = new StringJoiner(&quot;,&quot;);
 693         for (int i = names.length - 1; i &gt;= 0; i--) {
 694             sj.add(names[i].toRFC2253String(oidMap));
 695         }
 696         return sj.toString();
 697     }
 698 
 699     public String getRFC2253CanonicalName() {
 700         /* check for and return cached name */
 701         if (canonicalDn != null) {
 702             return canonicalDn;
 703         }
 704         /*
 705          * Section 2.1 : if the RDNSequence is an empty sequence
 706          * the result is the empty or zero length string.
 707          */
 708         if (names.length == 0) {
 709             canonicalDn = &quot;&quot;;
 710             return canonicalDn;
 711         }
 712 
 713         /*
 714          * 2.1 (continued) : Otherwise, the output consists of the string
 715          * encodings of each RelativeDistinguishedName in the RDNSequence
 716          * (according to 2.2), starting with the last element of the sequence
 717          * and moving backwards toward the first.
 718          *
 719          * The encodings of adjoining RelativeDistinguishedNames are separated
 720          * by a comma character (&#39;,&#39; ASCII 44).
 721          */
 722         StringJoiner sj = new StringJoiner(&quot;,&quot;);
 723         for (int i = names.length - 1; i &gt;= 0; i--) {
 724             sj.add(names[i].toRFC2253String(true));
 725         }
 726         canonicalDn = sj.toString();
 727         return canonicalDn;
 728     }
 729 
 730     /**
 731      * Returns the value of toString().  This call is needed to
 732      * implement the java.security.Principal interface.
 733      */
 734     public String getName() { return toString(); }
 735 
 736     /**
 737      * Find the first instance of this attribute in a &quot;top down&quot;
 738      * search of all the attributes in the name.
 739      */
 740     private DerValue findAttribute(ObjectIdentifier attribute) {
 741         if (names != null) {
 742             for (int i = 0; i &lt; names.length; i++) {
 743                 DerValue value = names[i].findAttribute(attribute);
 744                 if (value != null) {
 745                     return value;
 746                 }
 747             }
 748         }
 749         return null;
 750     }
 751 
 752     /**
 753      * Find the most specific (&quot;last&quot;) attribute of the given
 754      * type.
 755      */
 756     public DerValue findMostSpecificAttribute(ObjectIdentifier attribute) {
 757         if (names != null) {
 758             for (int i = names.length - 1; i &gt;= 0; i--) {
 759                 DerValue value = names[i].findAttribute(attribute);
 760                 if (value != null) {
 761                     return value;
 762                 }
 763             }
 764         }
 765         return null;
 766     }
 767 
 768     /****************************************************************/
 769 
 770     private void parseDER(DerInputStream in) throws IOException {
 771         //
 772         // X.500 names are a &quot;SEQUENCE OF&quot; RDNs, which means zero or
 773         // more and order matters.  We scan them in order, which
 774         // conventionally is big-endian.
 775         //
 776         DerValue[] nameseq = null;
 777         byte[] derBytes = in.toByteArray();
 778 
 779         try {
 780             nameseq = in.getSequence(5);
 781         } catch (IOException ioe) {
 782             if (derBytes == null) {
 783                 nameseq = null;
 784             } else {
 785                 DerValue derVal = new DerValue(DerValue.tag_Sequence,
 786                                            derBytes);
 787                 derBytes = derVal.toByteArray();
 788                 nameseq = new DerInputStream(derBytes).getSequence(5);
 789             }
 790         }
 791 
 792         if (nameseq == null) {
 793             names = new RDN[0];
 794         } else {
 795             names = new RDN[nameseq.length];
 796             for (int i = 0; i &lt; nameseq.length; i++) {
 797                 names[i] = new RDN(nameseq[i]);
 798             }
 799         }
 800     }
 801 
 802     /**
 803      * Encodes the name in DER-encoded form.
 804      *
 805      * @deprecated Use encode() instead
 806      * @param out where to put the DER-encoded X.500 name
 807      */
 808     @Deprecated
 809     public void emit(DerOutputStream out) throws IOException {
<a name="1" id="anc1"></a><span class="line-modified"> 810         derEncode(out);</span>
 811     }
 812 
 813     /**
 814      * Encodes the name in DER-encoded form.
 815      *
 816      * @param out where to put the DER-encoded X.500 name
 817      */
<a name="2" id="anc2"></a><span class="line-modified"> 818     @Override</span>
<span class="line-added"> 819     public void derEncode(DerOutputStream out) {</span>
 820         DerOutputStream tmp = new DerOutputStream();
 821         for (int i = 0; i &lt; names.length; i++) {
<a name="3" id="anc3"></a><span class="line-modified"> 822             names[i].derEncode(tmp);</span>
 823         }
 824         out.write(DerValue.tag_Sequence, tmp);
 825     }
 826 
 827     /**
 828      * Returned the encoding as an uncloned byte array. Callers must
 829      * guarantee that they neither modify it not expose it to untrusted
 830      * code.
 831      */
 832     public byte[] getEncodedInternal() throws IOException {
 833         if (encoded == null) {
 834             DerOutputStream     out = new DerOutputStream();
 835             DerOutputStream     tmp = new DerOutputStream();
 836             for (int i = 0; i &lt; names.length; i++) {
<a name="4" id="anc4"></a><span class="line-modified"> 837                 names[i].derEncode(tmp);</span>
 838             }
 839             out.write(DerValue.tag_Sequence, tmp);
 840             encoded = out.toByteArray();
 841         }
 842         return encoded;
 843     }
 844 
 845     /**
 846      * Gets the name in DER-encoded form.
 847      *
 848      * @return the DER encoded byte array of this name.
 849      */
 850     public byte[] getEncoded() throws IOException {
 851         return getEncodedInternal().clone();
 852     }
 853 
 854     /*
 855      * Parses a Distinguished Name (DN) in printable representation.
 856      *
 857      * According to RFC 1779, RDNs in a DN are separated by comma.
 858      * The following examples show both methods of quoting a comma, so that it
 859      * is not considered a separator:
 860      *
 861      *     O=&quot;Sue, Grabbit and Runn&quot; or
 862      *     O=Sue\, Grabbit and Runn
 863      *
 864      * This method can parse RFC 1779, 2253 or 4514 DNs and non-standard 5280
 865      * keywords. Additional keywords can be specified in the keyword/OID map.
 866      */
 867     private void parseDN(String input, Map&lt;String, String&gt; keywordMap)
 868         throws IOException {
 869         if (input == null || input.isEmpty()) {
 870             names = new RDN[0];
 871             return;
 872         }
 873 
 874         List&lt;RDN&gt; dnVector = new ArrayList&lt;&gt;();
 875         int dnOffset = 0;
 876         int rdnEnd;
 877         String rdnString;
 878         int quoteCount = 0;
 879 
 880         String dnString = input;
 881 
 882         int searchOffset = 0;
 883         int nextComma = dnString.indexOf(&#39;,&#39;);
 884         int nextSemiColon = dnString.indexOf(&#39;;&#39;);
 885         while (nextComma &gt;=0 || nextSemiColon &gt;=0) {
 886 
 887             if (nextSemiColon &lt; 0) {
 888                 rdnEnd = nextComma;
 889             } else if (nextComma &lt; 0) {
 890                 rdnEnd = nextSemiColon;
 891             } else {
 892                 rdnEnd = Math.min(nextComma, nextSemiColon);
 893             }
 894             quoteCount += countQuotes(dnString, searchOffset, rdnEnd);
 895 
 896             /*
 897              * We have encountered an RDN delimiter (comma or a semicolon).
 898              * If the comma or semicolon in the RDN under consideration is
 899              * preceded by a backslash (escape), or by a double quote, it
 900              * is part of the RDN. Otherwise, it is used as a separator, to
 901              * delimit the RDN under consideration from any subsequent RDNs.
 902              */
 903             if (rdnEnd &gt;= 0 &amp;&amp; quoteCount != 1 &amp;&amp;
 904                 !escaped(rdnEnd, searchOffset, dnString)) {
 905 
 906                 /*
 907                  * Comma/semicolon is a separator
 908                  */
 909                 rdnString = dnString.substring(dnOffset, rdnEnd);
 910 
 911                 // Parse RDN, and store it in vector
 912                 RDN rdn = new RDN(rdnString, keywordMap);
 913                 dnVector.add(rdn);
 914 
 915                 // Increase the offset
 916                 dnOffset = rdnEnd + 1;
 917 
 918                 // Set quote counter back to zero
 919                 quoteCount = 0;
 920             }
 921 
 922             searchOffset = rdnEnd + 1;
 923             nextComma = dnString.indexOf(&#39;,&#39;, searchOffset);
 924             nextSemiColon = dnString.indexOf(&#39;;&#39;, searchOffset);
 925         }
 926 
 927         // Parse last or only RDN, and store it in vector
 928         rdnString = dnString.substring(dnOffset);
 929         RDN rdn = new RDN(rdnString, keywordMap);
 930         dnVector.add(rdn);
 931 
 932         /*
 933          * Store the vector elements as an array of RDNs
 934          * NOTE: It&#39;s only on output that little-endian ordering is used.
 935          */
 936         Collections.reverse(dnVector);
 937         names = dnVector.toArray(new RDN[dnVector.size()]);
 938     }
 939 
 940     private void parseRFC2253DN(String dnString) throws IOException {
 941         if (dnString.isEmpty()) {
 942             names = new RDN[0];
 943             return;
 944          }
 945 
 946          List&lt;RDN&gt; dnVector = new ArrayList&lt;&gt;();
 947          int dnOffset = 0;
 948          String rdnString;
 949          int searchOffset = 0;
 950          int rdnEnd = dnString.indexOf(&#39;,&#39;);
 951          while (rdnEnd &gt;=0) {
 952              /*
 953               * We have encountered an RDN delimiter (comma).
 954               * If the comma in the RDN under consideration is
 955               * preceded by a backslash (escape), it
 956               * is part of the RDN. Otherwise, it is used as a separator, to
 957               * delimit the RDN under consideration from any subsequent RDNs.
 958               */
 959              if (rdnEnd &gt; 0 &amp;&amp; !escaped(rdnEnd, searchOffset, dnString)) {
 960 
 961                  /*
 962                   * Comma is a separator
 963                   */
 964                  rdnString = dnString.substring(dnOffset, rdnEnd);
 965 
 966                  // Parse RDN, and store it in vector
 967                  RDN rdn = new RDN(rdnString, &quot;RFC2253&quot;);
 968                  dnVector.add(rdn);
 969 
 970                  // Increase the offset
 971                  dnOffset = rdnEnd + 1;
 972              }
 973 
 974              searchOffset = rdnEnd + 1;
 975              rdnEnd = dnString.indexOf(&#39;,&#39;, searchOffset);
 976          }
 977 
 978          // Parse last or only RDN, and store it in vector
 979          rdnString = dnString.substring(dnOffset);
 980          RDN rdn = new RDN(rdnString, &quot;RFC2253&quot;);
 981          dnVector.add(rdn);
 982 
 983          /*
 984           * Store the vector elements as an array of RDNs
 985           * NOTE: It&#39;s only on output that little-endian ordering is used.
 986           */
 987          Collections.reverse(dnVector);
 988          names = dnVector.toArray(new RDN[dnVector.size()]);
 989     }
 990 
 991     /*
 992      * Counts double quotes in string.
 993      * Escaped quotes are ignored.
 994      */
 995     static int countQuotes(String string, int from, int to) {
 996         int count = 0;
 997 
 998         for (int i = from; i &lt; to; i++) {
 999             if ((string.charAt(i) == &#39;&quot;&#39; &amp;&amp; i == from) ||
1000                 (string.charAt(i) == &#39;&quot;&#39; &amp;&amp; string.charAt(i-1) != &#39;\\&#39;)) {
1001                 count++;
1002             }
1003         }
1004 
1005         return count;
1006     }
1007 
1008     private static boolean escaped
1009                 (int rdnEnd, int searchOffset, String dnString) {
1010 
1011         if (rdnEnd == 1 &amp;&amp; dnString.charAt(rdnEnd - 1) == &#39;\\&#39;) {
1012 
1013             //  case 1:
1014             //  \,
1015 
1016             return true;
1017 
1018         } else if (rdnEnd &gt; 1 &amp;&amp; dnString.charAt(rdnEnd - 1) == &#39;\\&#39; &amp;&amp;
1019                 dnString.charAt(rdnEnd - 2) != &#39;\\&#39;) {
1020 
1021             //  case 2:
1022             //  foo\,
1023 
1024             return true;
1025 
1026         } else if (rdnEnd &gt; 1 &amp;&amp; dnString.charAt(rdnEnd - 1) == &#39;\\&#39; &amp;&amp;
1027                 dnString.charAt(rdnEnd - 2) == &#39;\\&#39;) {
1028 
1029             //  case 3:
1030             //  foo\\\\\,
1031 
1032             int count = 0;
1033             rdnEnd--;   // back up to last backSlash
1034             while (rdnEnd &gt;= searchOffset) {
1035                 if (dnString.charAt(rdnEnd) == &#39;\\&#39;) {
1036                     count++;    // count consecutive backslashes
1037                 }
1038                 rdnEnd--;
1039             }
1040 
1041             // if count is odd, then rdnEnd is escaped
1042             return (count % 2) != 0 ? true : false;
1043 
1044         } else {
1045             return false;
1046         }
1047     }
1048 
1049     /*
1050      * Dump the printable form of a distinguished name.  Each relative
1051      * name is separated from the next by a &quot;,&quot;, and assertions in the
1052      * relative names have &quot;label=value&quot; syntax.
1053      *
1054      * Uses RFC 1779 syntax (i.e. little-endian, comma separators)
1055      */
1056     private void generateDN() {
1057         if (names.length == 1) {
1058             dn = names[0].toString();
1059             return;
1060         }
1061 
1062         if (names == null) {
1063             dn = &quot;&quot;;
1064             return;
1065         }
1066 
1067         StringJoiner sj = new StringJoiner(&quot;, &quot;);
1068         for (int i = names.length - 1; i &gt;= 0; i--) {
1069             sj.add(names[i].toString());
1070         }
1071         dn = sj.toString();
1072     }
1073 
1074     /*
1075      * Dump the printable form of a distinguished name.  Each relative
1076      * name is separated from the next by a &quot;,&quot;, and assertions in the
1077      * relative names have &quot;label=value&quot; syntax.
1078      *
1079      * Uses RFC 1779 syntax (i.e. little-endian, comma separators)
1080      * Valid keywords from RFC 1779 are used. Additional keywords can be
1081      * specified in the OID/keyword map.
1082      */
1083     private String generateRFC1779DN(Map&lt;String, String&gt; oidMap) {
1084         if (names.length == 1) {
1085             return names[0].toRFC1779String(oidMap);
1086         }
1087 
1088         if (names == null) {
1089             return &quot;&quot;;
1090         }
1091 
1092         StringJoiner sj = new StringJoiner(&quot;, &quot;);
1093         for (int i = names.length - 1; i &gt;= 0; i--) {
1094             sj.add(names[i].toRFC1779String(oidMap));
1095         }
1096         return sj.toString();
1097     }
1098 
1099     /****************************************************************/
1100 
1101     /*
1102      * Selected OIDs from X.520
1103      * Includes all those specified in RFC 5280 as MUST or SHOULD
1104      * be recognized
1105      */
1106 
1107     // OID for the &quot;CN=&quot; attribute, denoting a person&#39;s common name.
1108     public static final ObjectIdentifier commonName_oid =
1109             ObjectIdentifier.of(KnownOIDs.CommonName);
1110 
1111     // OID for the &quot;SURNAME=&quot; attribute, denoting a person&#39;s surname.
1112     public static final ObjectIdentifier SURNAME_OID =
1113             ObjectIdentifier.of(KnownOIDs.Surname);
1114 
1115     // OID for the &quot;SERIALNUMBER=&quot; attribute, denoting a serial number for.
1116     // a name. Do not confuse with PKCS#9 issuerAndSerialNumber or the
1117     // certificate serial number.
1118     public static final ObjectIdentifier SERIALNUMBER_OID =
1119             ObjectIdentifier.of(KnownOIDs.SerialNumber);
1120 
1121     // OID for the &quot;C=&quot; attribute, denoting a country.
1122     public static final ObjectIdentifier countryName_oid =
1123             ObjectIdentifier.of(KnownOIDs.CountryName);
1124 
1125     // OID for the &quot;L=&quot; attribute, denoting a locality (such as a city).
1126     public static final ObjectIdentifier localityName_oid =
1127             ObjectIdentifier.of(KnownOIDs.LocalityName);
1128 
1129     // OID for the &quot;S=&quot; attribute, denoting a state (such as Delaware).
1130     public static final ObjectIdentifier stateName_oid =
1131             ObjectIdentifier.of(KnownOIDs.StateName);
1132 
1133     // OID for the &quot;STREET=&quot; attribute, denoting a street address.
1134     public static final ObjectIdentifier streetAddress_oid =
1135             ObjectIdentifier.of(KnownOIDs.StreetAddress);
1136 
1137     // OID for the &quot;O=&quot; attribute, denoting an organization name.
1138     public static final ObjectIdentifier orgName_oid =
1139             ObjectIdentifier.of(KnownOIDs.OrgName);
1140 
1141     // OID for the &quot;OU=&quot; attribute, denoting an organizational unit name.
1142     public static final ObjectIdentifier orgUnitName_oid =
1143             ObjectIdentifier.of(KnownOIDs.OrgUnitName);
1144 
1145     // OID for the &quot;T=&quot; attribute, denoting a person&#39;s title.
1146     public static final ObjectIdentifier title_oid =
1147             ObjectIdentifier.of(KnownOIDs.Title);
1148 
1149     // OID for the &quot;GIVENNAME=&quot; attribute, denoting a person&#39;s given name.
1150     public static final ObjectIdentifier GIVENNAME_OID =
1151             ObjectIdentifier.of(KnownOIDs.GivenName);
1152 
1153     // OID for the &quot;INITIALS=&quot; attribute, denoting a person&#39;s initials.
1154     public static final ObjectIdentifier INITIALS_OID =
1155             ObjectIdentifier.of(KnownOIDs.Initials);
1156 
1157     // OID for the &quot;GENERATION=&quot; attribute, denoting Jr., II, etc.
1158     public static final ObjectIdentifier GENERATIONQUALIFIER_OID =
1159             ObjectIdentifier.of(KnownOIDs.GenerationQualifier);
1160 
1161     // OID for the &quot;DNQUALIFIER=&quot; or &quot;DNQ=&quot; attribute, denoting DN
1162     // disambiguating information.
1163     public static final ObjectIdentifier DNQUALIFIER_OID =
1164             ObjectIdentifier.of(KnownOIDs.DNQualifier);
1165 
1166     // OIDs from other sources which show up in X.500 names we
1167     // expect to deal with often.
1168     //
1169     // OID for &quot;IP=&quot; IP address attributes, used with SKIP.
1170     public static final ObjectIdentifier ipAddress_oid =
1171             ObjectIdentifier.of(KnownOIDs.SkipIPAddress);
1172 
1173     // Domain component OID from RFC 1274, RFC 2247, RFC 5280.
1174     //
1175     // OID for &quot;DC=&quot; domain component attributes.used with DNSNames in DN
1176     // format.
1177     public static final ObjectIdentifier DOMAIN_COMPONENT_OID =
1178             ObjectIdentifier.of(KnownOIDs.UCL_DomainComponent);
1179 
1180     // OID for &quot;UID=&quot; denoting a user id, defined in RFCs 1274 &amp; 2798.
1181     public static final ObjectIdentifier userid_oid =
1182             ObjectIdentifier.of(KnownOIDs.UCL_UserID);
1183 
1184     /**
1185      * Return constraint type:&lt;ul&gt;
1186      *   &lt;li&gt;NAME_DIFF_TYPE = -1: input name is different type from this name
1187      *       (i.e. does not constrain)
1188      *   &lt;li&gt;NAME_MATCH = 0: input name matches this name
1189      *   &lt;li&gt;NAME_NARROWS = 1: input name narrows this name
1190      *   &lt;li&gt;NAME_WIDENS = 2: input name widens this name
1191      *   &lt;li&gt;NAME_SAME_TYPE = 3: input name does not match or narrow this name,
1192      *       but is same type.
1193      * &lt;/ul&gt;
1194      * These results are used in checking NameConstraints during
1195      * certification path verification.
1196      *
1197      * @param inputName to be checked for being constrained
1198      * @return constraint type above
1199      * @throws UnsupportedOperationException if name is not exact match, but
1200      *         narrowing and widening are not supported for this name type.
1201      */
1202     public int constrains(GeneralNameInterface inputName)
1203             throws UnsupportedOperationException {
1204         int constraintType;
1205         if (inputName == null) {
1206             constraintType = NAME_DIFF_TYPE;
1207         } else if (inputName.getType() != NAME_DIRECTORY) {
1208             constraintType = NAME_DIFF_TYPE;
1209         } else { // type == NAME_DIRECTORY
1210             X500Name inputX500 = (X500Name)inputName;
1211             if (inputX500.equals(this)) {
1212                 constraintType = NAME_MATCH;
1213             } else if (inputX500.names.length == 0) {
1214                 constraintType = NAME_WIDENS;
1215             } else if (this.names.length == 0) {
1216                 constraintType = NAME_NARROWS;
1217             } else if (inputX500.isWithinSubtree(this)) {
1218                 constraintType = NAME_NARROWS;
1219             } else if (isWithinSubtree(inputX500)) {
1220                 constraintType = NAME_WIDENS;
1221             } else {
1222                 constraintType = NAME_SAME_TYPE;
1223             }
1224         }
1225         return constraintType;
1226     }
1227 
1228     /**
1229      * Compares this name with another and determines if
1230      * it is within the subtree of the other. Useful for
1231      * checking against the name constraints extension.
1232      *
1233      * @return true iff this name is within the subtree of other.
1234      */
1235     private boolean isWithinSubtree(X500Name other) {
1236         if (this == other) {
1237             return true;
1238         }
1239         if (other == null) {
1240             return false;
1241         }
1242         if (other.names.length == 0) {
1243             return true;
1244         }
1245         if (this.names.length == 0) {
1246             return false;
1247         }
1248         if (names.length &lt; other.names.length) {
1249             return false;
1250         }
1251         for (int i = 0; i &lt; other.names.length; i++) {
1252             if (!names[i].equals(other.names[i])) {
1253                 return false;
1254             }
1255         }
1256         return true;
1257     }
1258 
1259     /**
1260      * Return subtree depth of this name for purposes of determining
1261      * NameConstraints minimum and maximum bounds and for calculating
1262      * path lengths in name subtrees.
1263      *
1264      * @return distance of name from root
1265      * @throws UnsupportedOperationException if not supported for this name type
1266      */
1267     public int subtreeDepth() throws UnsupportedOperationException {
1268         return names.length;
1269     }
1270 
1271     /**
1272      * Return lowest common ancestor of this name and other name
1273      *
1274      * @param other another X500Name
1275      * @return X500Name of lowest common ancestor; null if none
1276      */
1277     public X500Name commonAncestor(X500Name other) {
1278 
1279         if (other == null) {
1280             return null;
1281         }
1282         int otherLen = other.names.length;
1283         int thisLen = this.names.length;
1284         if (thisLen == 0 || otherLen == 0) {
1285             return null;
1286         }
1287         int minLen = (thisLen &lt; otherLen) ? thisLen: otherLen;
1288 
1289         //Compare names from highest RDN down the naming tree
1290         //Note that these are stored in RDN[0]...
1291         int i=0;
1292         for (; i &lt; minLen; i++) {
1293             if (!names[i].equals(other.names[i])) {
1294                 if (i == 0) {
1295                     return null;
1296                 } else {
1297                     break;
1298                 }
1299             }
1300         }
1301 
1302         //Copy matching RDNs into new RDN array
1303         RDN[] ancestor = new RDN[i];
1304         for (int j=0; j &lt; i; j++) {
1305             ancestor[j] = names[j];
1306         }
1307 
1308         X500Name commonAncestor = null;
1309         try {
1310             commonAncestor = new X500Name(ancestor);
1311         } catch (IOException ioe) {
1312             return null;
1313         }
1314         return commonAncestor;
1315     }
1316 
1317     /**
1318      * Constructor object for use by asX500Principal().
1319      */
1320     private static final Constructor&lt;X500Principal&gt; principalConstructor;
1321 
1322     /**
1323      * Field object for use by asX500Name().
1324      */
1325     private static final Field principalField;
1326 
1327     /**
1328      * Retrieve the Constructor and Field we need for reflective access
1329      * and make them accessible.
1330      */
1331     static {
1332         PrivilegedExceptionAction&lt;Object[]&gt; pa =
1333                 new PrivilegedExceptionAction&lt;&gt;() {
1334             public Object[] run() throws Exception {
1335                 Class&lt;X500Principal&gt; pClass = X500Principal.class;
1336                 Class&lt;?&gt;[] args = new Class&lt;?&gt;[] { X500Name.class };
1337                 Constructor&lt;X500Principal&gt; cons = pClass.getDeclaredConstructor(args);
1338                 cons.setAccessible(true);
1339                 Field field = pClass.getDeclaredField(&quot;thisX500Name&quot;);
1340                 field.setAccessible(true);
1341                 return new Object[] {cons, field};
1342             }
1343         };
1344         try {
1345             Object[] result = AccessController.doPrivileged(pa);
1346             @SuppressWarnings(&quot;unchecked&quot;)
1347             Constructor&lt;X500Principal&gt; constr =
1348                     (Constructor&lt;X500Principal&gt;)result[0];
1349             principalConstructor = constr;
1350             principalField = (Field)result[1];
1351         } catch (Exception e) {
1352             throw new InternalError(&quot;Could not obtain X500Principal access&quot;, e);
1353         }
1354     }
1355 
1356     /**
1357      * Get an X500Principal backed by this X500Name.
1358      *
1359      * Note that we are using privileged reflection to access the hidden
1360      * package private constructor in X500Principal.
1361      */
1362     public X500Principal asX500Principal() {
1363         if (x500Principal == null) {
1364             try {
1365                 Object[] args = new Object[] {this};
1366                 x500Principal = principalConstructor.newInstance(args);
1367             } catch (Exception e) {
1368                 throw new RuntimeException(&quot;Unexpected exception&quot;, e);
1369             }
1370         }
1371         return x500Principal;
1372     }
1373 
1374     /**
1375      * Get the X500Name contained in the given X500Principal.
1376      *
1377      * Note that the X500Name is retrieved using reflection.
1378      */
1379     public static X500Name asX500Name(X500Principal p) {
1380         try {
1381             X500Name name = (X500Name)principalField.get(p);
1382             name.x500Principal = p;
1383             return name;
1384         } catch (Exception e) {
1385             throw new RuntimeException(&quot;Unexpected exception&quot;, e);
1386         }
1387     }
1388 
1389 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
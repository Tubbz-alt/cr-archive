<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/x509/RDN.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PrivateKeyUsageExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RFC822Name.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/x509/RDN.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45  * when we parse this data we don&#39;t have to worry about canonicalizing
 46  * it, but we&#39;ll need to sort them when we expose the RDN class more.
 47  * &lt;p&gt;
 48  * The ASN.1 for RDNs is:
 49  * &lt;pre&gt;
 50  * RelativeDistinguishedName ::=
 51  *   SET OF AttributeTypeAndValue
 52  *
 53  * AttributeTypeAndValue ::= SEQUENCE {
 54  *   type     AttributeType,
 55  *   value    AttributeValue }
 56  *
 57  * AttributeType ::= OBJECT IDENTIFIER
 58  *
 59  * AttributeValue ::= ANY DEFINED BY AttributeType
 60  * &lt;/pre&gt;
 61  *
 62  * Note that instances of this class are immutable.
 63  *
 64  */
<span class="line-modified"> 65 public class RDN {</span>
 66 
 67     // currently not private, accessed directly from X500Name
 68     final AVA[] assertion;
 69 
 70     // cached immutable List of the AVAs
 71     private volatile List&lt;AVA&gt; avaList;
 72 
 73     // cache canonical String form
 74     private volatile String canonicalString;
 75 
 76     /**
 77      * Constructs an RDN from its printable representation.
 78      *
 79      * An RDN may consist of one or multiple Attribute Value Assertions (AVAs),
 80      * using &#39;+&#39; as a separator.
 81      * If the &#39;+&#39; should be considered part of an AVA value, it must be
 82      * preceded by &#39;\&#39;.
 83      *
 84      * @param name String form of RDN
 85      * @throws IOException on parsing error
</pre>
<hr />
<pre>
319      * return specified attribute value from RDN
320      *
321      * @param oid ObjectIdentifier of attribute to be found
322      * @return DerValue of attribute value; null if attribute does not exist
323      */
324     DerValue findAttribute(ObjectIdentifier oid) {
325         for (int i = 0; i &lt; assertion.length; i++) {
326             if (assertion[i].oid.equals(oid)) {
327                 return assertion[i].value;
328             }
329         }
330         return null;
331     }
332 
333     /*
334      * Encode the RDN in DER-encoded form.
335      *
336      * @param out DerOutputStream to which RDN is to be written
337      * @throws IOException on error
338      */
<span class="line-modified">339     void encode(DerOutputStream out) throws IOException {</span>

340         out.putOrderedSetOf(DerValue.tag_Set, assertion);
341     }
342 
343     /*
344      * Returns a printable form of this RDN, using RFC 1779 style catenation
345      * of attribute/value assertions, and emitting attribute type keywords
346      * from RFCs 1779, 2253, and 5280.
347      */
348     public String toString() {
349         if (assertion.length == 1) {
350             return assertion[0].toString();
351         }
352 
353         StringJoiner sj = new StringJoiner(&quot; + &quot;);
354         for (int i = 0; i &lt; assertion.length; i++) {
355             sj.add(assertion[i].toString());
356         }
357         return sj.toString();
358     }
359 
</pre>
</td>
<td>
<hr />
<pre>
 45  * when we parse this data we don&#39;t have to worry about canonicalizing
 46  * it, but we&#39;ll need to sort them when we expose the RDN class more.
 47  * &lt;p&gt;
 48  * The ASN.1 for RDNs is:
 49  * &lt;pre&gt;
 50  * RelativeDistinguishedName ::=
 51  *   SET OF AttributeTypeAndValue
 52  *
 53  * AttributeTypeAndValue ::= SEQUENCE {
 54  *   type     AttributeType,
 55  *   value    AttributeValue }
 56  *
 57  * AttributeType ::= OBJECT IDENTIFIER
 58  *
 59  * AttributeValue ::= ANY DEFINED BY AttributeType
 60  * &lt;/pre&gt;
 61  *
 62  * Note that instances of this class are immutable.
 63  *
 64  */
<span class="line-modified"> 65 public class RDN implements DerEncoder {</span>
 66 
 67     // currently not private, accessed directly from X500Name
 68     final AVA[] assertion;
 69 
 70     // cached immutable List of the AVAs
 71     private volatile List&lt;AVA&gt; avaList;
 72 
 73     // cache canonical String form
 74     private volatile String canonicalString;
 75 
 76     /**
 77      * Constructs an RDN from its printable representation.
 78      *
 79      * An RDN may consist of one or multiple Attribute Value Assertions (AVAs),
 80      * using &#39;+&#39; as a separator.
 81      * If the &#39;+&#39; should be considered part of an AVA value, it must be
 82      * preceded by &#39;\&#39;.
 83      *
 84      * @param name String form of RDN
 85      * @throws IOException on parsing error
</pre>
<hr />
<pre>
319      * return specified attribute value from RDN
320      *
321      * @param oid ObjectIdentifier of attribute to be found
322      * @return DerValue of attribute value; null if attribute does not exist
323      */
324     DerValue findAttribute(ObjectIdentifier oid) {
325         for (int i = 0; i &lt; assertion.length; i++) {
326             if (assertion[i].oid.equals(oid)) {
327                 return assertion[i].value;
328             }
329         }
330         return null;
331     }
332 
333     /*
334      * Encode the RDN in DER-encoded form.
335      *
336      * @param out DerOutputStream to which RDN is to be written
337      * @throws IOException on error
338      */
<span class="line-modified">339     @Override</span>
<span class="line-added">340     public void derEncode(DerOutputStream out) {</span>
341         out.putOrderedSetOf(DerValue.tag_Set, assertion);
342     }
343 
344     /*
345      * Returns a printable form of this RDN, using RFC 1779 style catenation
346      * of attribute/value assertions, and emitting attribute type keywords
347      * from RFCs 1779, 2253, and 5280.
348      */
349     public String toString() {
350         if (assertion.length == 1) {
351             return assertion[0].toString();
352         }
353 
354         StringJoiner sj = new StringJoiner(&quot; + &quot;);
355         for (int i = 0; i &lt; assertion.length; i++) {
356             sj.add(assertion[i].toString());
357         }
358         return sj.toString();
359     }
360 
</pre>
</td>
</tr>
</table>
<center><a href="PrivateKeyUsageExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RFC822Name.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
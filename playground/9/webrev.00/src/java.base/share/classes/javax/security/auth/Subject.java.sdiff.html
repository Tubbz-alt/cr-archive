<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/javax/security/auth/Subject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.base/share/classes/javax/security/auth/Subject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 188      *          and false otherwise.
 189      *
 190      * @param principals the {@code Set} of Principals
 191      *          to be associated with this {@code Subject}.
 192      *
 193      * @param pubCredentials the {@code Set} of public credentials
 194      *          to be associated with this {@code Subject}.
 195      *
 196      * @param privCredentials the {@code Set} of private credentials
 197      *          to be associated with this {@code Subject}.
 198      *
 199      * @throws NullPointerException if the specified
 200      *          {@code principals}, {@code pubCredentials},
 201      *          or {@code privCredentials} are {@code null},
 202      *          or a null value exists within any of these three
 203      *          Sets.
 204      */
 205     public Subject(boolean readOnly, Set&lt;? extends Principal&gt; principals,
 206                    Set&lt;?&gt; pubCredentials, Set&lt;?&gt; privCredentials)
 207     {
<span class="line-modified"> 208         collectionNullClean(principals);</span>
<span class="line-modified"> 209         collectionNullClean(pubCredentials);</span>
<span class="line-modified"> 210         collectionNullClean(privCredentials);</span>



 211 
 212         this.principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 213                                 (this, PRINCIPAL_SET, principals));</span>
 214         this.pubCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 215                                 (this, PUB_CREDENTIAL_SET, pubCredentials));</span>
 216         this.privCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 217                                 (this, PRIV_CREDENTIAL_SET, privCredentials));</span>
 218         this.readOnly = readOnly;
 219     }
 220 
 221     /**
 222      * Set this {@code Subject} to be read-only.
 223      *
 224      * &lt;p&gt; Modifications (additions and removals) to this Subject&#39;s
 225      * {@code Principal} {@code Set} and
 226      * credential Sets will be disallowed.
 227      * The {@code destroy} operation on this Subject&#39;s credentials will
 228      * still be permitted.
 229      *
 230      * &lt;p&gt; Subsequent attempts to modify the Subject&#39;s {@code Principal}
 231      * and credential Sets will result in an
 232      * {@code IllegalStateException} being thrown.
 233      * Also, once a {@code Subject} is read-only,
 234      * it can not be reset to being writable again.
 235      *
 236      * @throws SecurityException if a security manager is installed and the
 237      *         caller does not have an
</pre>
<hr />
<pre>
 958 
 959     /**
 960      * Reads this object from a stream (i.e., deserializes it)
 961      */
 962     @SuppressWarnings(&quot;unchecked&quot;)
 963     @java.io.Serial
 964     private void readObject(java.io.ObjectInputStream s)
 965                 throws java.io.IOException, ClassNotFoundException {
 966 
 967         ObjectInputStream.GetField gf = s.readFields();
 968 
 969         readOnly = gf.get(&quot;readOnly&quot;, false);
 970 
 971         Set&lt;Principal&gt; inputPrincs = (Set&lt;Principal&gt;)gf.get(&quot;principals&quot;, null);
 972 
 973         Objects.requireNonNull(inputPrincs,
 974                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
 975 
 976         // Rewrap the principals into a SecureSet
 977         try {

 978             principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 979                                 (this, PRINCIPAL_SET, inputPrincs));</span>
 980         } catch (NullPointerException npe) {
 981             // Sometimes people deserialize the principals set only.
 982             // Subject is not accessible, so just don&#39;t fail.
 983             principals = Collections.synchronizedSet
 984                         (new SecureSet&lt;&gt;(this, PRINCIPAL_SET));
 985         }
 986 
 987         // The Credential {@code Set} is not serialized, but we do not
 988         // want the default deserialization routine to set it to null.
 989         this.pubCredentials = Collections.synchronizedSet
 990                         (new SecureSet&lt;&gt;(this, PUB_CREDENTIAL_SET));
 991         this.privCredentials = Collections.synchronizedSet
 992                         (new SecureSet&lt;&gt;(this, PRIV_CREDENTIAL_SET));
 993     }
 994 
 995     /**
 996      * Tests for null-clean collections (both non-null reference and
 997      * no null elements)
 998      *
 999      * @param coll A {@code Collection} to be tested for null references
1000      *
1001      * @throws NullPointerException if the specified collection is either
1002      *            {@code null} or contains a {@code null} element
1003      */
<span class="line-modified">1004     private static void collectionNullClean(Collection&lt;?&gt; coll) {</span>
<span class="line-modified">1005         boolean hasNullElements = false;</span>
1006 
1007         Objects.requireNonNull(coll,
1008                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1009 
<span class="line-modified">1010         try {</span>
<span class="line-modified">1011             hasNullElements = coll.contains(null);</span>
<span class="line-modified">1012         } catch (NullPointerException npe) {</span>
<span class="line-modified">1013             // A null-hostile collection may choose to throw</span>
<span class="line-removed">1014             // NullPointerException if contains(null) is called on it</span>
<span class="line-removed">1015             // rather than returning false.</span>
<span class="line-removed">1016             // If this happens we know the collection is null-clean.</span>
<span class="line-removed">1017             hasNullElements = false;</span>
<span class="line-removed">1018         } finally {</span>
<span class="line-removed">1019             if (hasNullElements) {</span>
<span class="line-removed">1020                 throw new NullPointerException</span>
<span class="line-removed">1021                     (ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));</span>
<span class="line-removed">1022             }</span>
1023         }

1024     }
1025 
1026     /**
1027      * Prevent modifications unless caller has permission.
1028      *
1029      * @serial include
1030      */
1031     private static class SecureSet&lt;E&gt;
1032         implements Set&lt;E&gt;, java.io.Serializable {
1033 
1034         @java.io.Serial
1035         private static final long serialVersionUID = 7911754171111800359L;
1036 
1037         /**
1038          * @serialField this$0 Subject The outer Subject instance.
1039          * @serialField elements LinkedList The elements in this set.
1040          */
1041         @java.io.Serial
1042         private static final ObjectStreamField[] serialPersistentFields = {
1043             new ObjectStreamField(&quot;this$0&quot;, Subject.class),
</pre>
<hr />
<pre>
1049         LinkedList&lt;E&gt; elements;
1050 
1051         /**
1052          * @serial An integer identifying the type of objects contained
1053          *      in this set.  If {@code which == 1},
1054          *      this is a Principal set and all the elements are
1055          *      of type {@code java.security.Principal}.
1056          *      If {@code which == 2}, this is a public credential
1057          *      set and all the elements are of type {@code Object}.
1058          *      If {@code which == 3}, this is a private credential
1059          *      set and all the elements are of type {@code Object}.
1060          */
1061         private int which;
1062 
1063         SecureSet(Subject subject, int which) {
1064             this.subject = subject;
1065             this.which = which;
1066             this.elements = new LinkedList&lt;E&gt;();
1067         }
1068 
<span class="line-modified">1069         SecureSet(Subject subject, int which, Set&lt;? extends E&gt; set) {</span>
1070             this.subject = subject;
1071             this.which = which;
<span class="line-modified">1072             this.elements = new LinkedList&lt;E&gt;(set);</span>
1073         }
1074 
1075         public int size() {
1076             return elements.size();
1077         }
1078 
1079         public Iterator&lt;E&gt; iterator() {
1080             final LinkedList&lt;E&gt; list = elements;
1081             return new Iterator&lt;E&gt;() {
1082                 ListIterator&lt;E&gt; i = list.listIterator(0);
1083 
1084                 public boolean hasNext() {return i.hasNext();}
1085 
1086                 public E next() {
1087                     if (which != Subject.PRIV_CREDENTIAL_SET) {
1088                         return i.next();
1089                     }
1090 
1091                     SecurityManager sm = System.getSecurityManager();
1092                     if (sm != null) {
</pre>
<hr />
<pre>
1225                                                 subject.getPrincipals()));
1226                     }
1227                     next = java.security.AccessController.doPrivileged
1228                         (new java.security.PrivilegedAction&lt;E&gt;() {
1229                         public E run() {
1230                             return e.next();
1231                         }
1232                     });
1233                 }
1234 
1235                 if (next.equals(o)) {
1236                     return true;
1237                 }
1238             }
1239             return false;
1240         }
1241 
1242         public boolean addAll(Collection&lt;? extends E&gt; c) {
1243             boolean result = false;
1244 
<span class="line-modified">1245             collectionNullClean(c);</span>
1246 
1247             for (E item : c) {
1248                 result |= this.add(item);
1249             }
1250 
1251             return result;
1252         }
1253 
1254         public boolean removeAll(Collection&lt;?&gt; c) {
<span class="line-modified">1255             collectionNullClean(c);</span>
1256 
1257             boolean modified = false;
1258             final Iterator&lt;E&gt; e = iterator();
1259             while (e.hasNext()) {
1260                 E next;
1261                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1262                     next = e.next();
1263                 } else {
1264                     next = java.security.AccessController.doPrivileged
1265                         (new java.security.PrivilegedAction&lt;E&gt;() {
1266                         public E run() {
1267                             return e.next();
1268                         }
1269                     });
1270                 }
1271 
1272                 Iterator&lt;?&gt; ce = c.iterator();
1273                 while (ce.hasNext()) {
1274                     if (next.equals(ce.next())) {
1275                             e.remove();
1276                             modified = true;
1277                             break;
1278                         }
1279                 }
1280             }
1281             return modified;
1282         }
1283 
1284         public boolean containsAll(Collection&lt;?&gt; c) {
<span class="line-modified">1285             collectionNullClean(c);</span>
1286 
1287             for (Object item : c) {
1288                 if (this.contains(item) == false) {
1289                     return false;
1290                 }
1291             }
1292 
1293             return true;
1294         }
1295 
1296         public boolean retainAll(Collection&lt;?&gt; c) {
<span class="line-modified">1297             collectionNullClean(c);</span>
1298 
1299             boolean modified = false;
1300             final Iterator&lt;E&gt; e = iterator();
1301             while (e.hasNext()) {
1302                 E next;
1303                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1304                     next = e.next();
1305                 } else {
1306                     next = java.security.AccessController.doPrivileged
1307                         (new java.security.PrivilegedAction&lt;E&gt;() {
1308                         public E run() {
1309                             return e.next();
1310                         }
1311                     });
1312                 }
1313 
1314                 if (c.contains(next) == false) {
1315                     e.remove();
1316                     modified = true;
<span class="line-removed">1317                     }</span>
1318                 }

1319 
1320             return modified;
1321         }
1322 
1323         public void clear() {
1324             final Iterator&lt;E&gt; e = iterator();
1325             while (e.hasNext()) {
1326                 E next;
1327                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1328                     next = e.next();
1329                 } else {
1330                     next = java.security.AccessController.doPrivileged
1331                         (new java.security.PrivilegedAction&lt;E&gt;() {
1332                         public E run() {
1333                             return e.next();
1334                         }
1335                     });
1336                 }
1337                 e.remove();
1338             }
</pre>
<hr />
<pre>
1426                 }
1427             }
1428             ObjectOutputStream.PutField fields = oos.putFields();
1429             fields.put(&quot;this$0&quot;, subject);
1430             fields.put(&quot;elements&quot;, elements);
1431             fields.put(&quot;which&quot;, which);
1432             oos.writeFields();
1433         }
1434 
1435         @SuppressWarnings(&quot;unchecked&quot;)
1436         @java.io.Serial
1437         private void readObject(ObjectInputStream ois)
1438             throws IOException, ClassNotFoundException
1439         {
1440             ObjectInputStream.GetField fields = ois.readFields();
1441             subject = (Subject) fields.get(&quot;this$0&quot;, null);
1442             which = fields.get(&quot;which&quot;, 0);
1443 
1444             LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);
1445 
<span class="line-modified">1446             Subject.collectionNullClean(tmp);</span>
<span class="line-removed">1447 </span>
<span class="line-removed">1448             if (tmp.getClass() != LinkedList.class) {</span>
<span class="line-removed">1449                 elements = new LinkedList&lt;E&gt;(tmp);</span>
<span class="line-removed">1450             } else {</span>
<span class="line-removed">1451                 elements = tmp;</span>
<span class="line-removed">1452             }</span>
1453         }
1454 
1455     }
1456 
1457     /**
1458      * This class implements a {@code Set} which returns only
1459      * members that are an instance of a specified Class.
1460      */
1461     private class ClassSet&lt;T&gt; extends AbstractSet&lt;T&gt; {
1462 
1463         private int which;
1464         private Class&lt;T&gt; c;
1465         private Set&lt;T&gt; set;
1466 
1467         ClassSet(int which, Class&lt;T&gt; c) {
1468             this.which = which;
1469             this.c = c;
1470             set = new HashSet&lt;T&gt;();
1471 
1472             switch (which) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 188      *          and false otherwise.
 189      *
 190      * @param principals the {@code Set} of Principals
 191      *          to be associated with this {@code Subject}.
 192      *
 193      * @param pubCredentials the {@code Set} of public credentials
 194      *          to be associated with this {@code Subject}.
 195      *
 196      * @param privCredentials the {@code Set} of private credentials
 197      *          to be associated with this {@code Subject}.
 198      *
 199      * @throws NullPointerException if the specified
 200      *          {@code principals}, {@code pubCredentials},
 201      *          or {@code privCredentials} are {@code null},
 202      *          or a null value exists within any of these three
 203      *          Sets.
 204      */
 205     public Subject(boolean readOnly, Set&lt;? extends Principal&gt; principals,
 206                    Set&lt;?&gt; pubCredentials, Set&lt;?&gt; privCredentials)
 207     {
<span class="line-modified"> 208         LinkedList&lt;Principal&gt; princList</span>
<span class="line-modified"> 209                 = collectionNullClean(principals);</span>
<span class="line-modified"> 210         LinkedList&lt;Object&gt; pubCredsList</span>
<span class="line-added"> 211                 = collectionNullClean(pubCredentials);</span>
<span class="line-added"> 212         LinkedList&lt;Object&gt; privCredsList</span>
<span class="line-added"> 213                 = collectionNullClean(privCredentials);</span>
 214 
 215         this.principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 216                                 (this, PRINCIPAL_SET, princList));</span>
 217         this.pubCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 218                                 (this, PUB_CREDENTIAL_SET, pubCredsList));</span>
 219         this.privCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 220                                 (this, PRIV_CREDENTIAL_SET, privCredsList));</span>
 221         this.readOnly = readOnly;
 222     }
 223 
 224     /**
 225      * Set this {@code Subject} to be read-only.
 226      *
 227      * &lt;p&gt; Modifications (additions and removals) to this Subject&#39;s
 228      * {@code Principal} {@code Set} and
 229      * credential Sets will be disallowed.
 230      * The {@code destroy} operation on this Subject&#39;s credentials will
 231      * still be permitted.
 232      *
 233      * &lt;p&gt; Subsequent attempts to modify the Subject&#39;s {@code Principal}
 234      * and credential Sets will result in an
 235      * {@code IllegalStateException} being thrown.
 236      * Also, once a {@code Subject} is read-only,
 237      * it can not be reset to being writable again.
 238      *
 239      * @throws SecurityException if a security manager is installed and the
 240      *         caller does not have an
</pre>
<hr />
<pre>
 961 
 962     /**
 963      * Reads this object from a stream (i.e., deserializes it)
 964      */
 965     @SuppressWarnings(&quot;unchecked&quot;)
 966     @java.io.Serial
 967     private void readObject(java.io.ObjectInputStream s)
 968                 throws java.io.IOException, ClassNotFoundException {
 969 
 970         ObjectInputStream.GetField gf = s.readFields();
 971 
 972         readOnly = gf.get(&quot;readOnly&quot;, false);
 973 
 974         Set&lt;Principal&gt; inputPrincs = (Set&lt;Principal&gt;)gf.get(&quot;principals&quot;, null);
 975 
 976         Objects.requireNonNull(inputPrincs,
 977                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
 978 
 979         // Rewrap the principals into a SecureSet
 980         try {
<span class="line-added"> 981             LinkedList&lt;Principal&gt; princList = collectionNullClean(inputPrincs);</span>
 982             principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
<span class="line-modified"> 983                                 (this, PRINCIPAL_SET, princList));</span>
 984         } catch (NullPointerException npe) {
 985             // Sometimes people deserialize the principals set only.
 986             // Subject is not accessible, so just don&#39;t fail.
 987             principals = Collections.synchronizedSet
 988                         (new SecureSet&lt;&gt;(this, PRINCIPAL_SET));
 989         }
 990 
 991         // The Credential {@code Set} is not serialized, but we do not
 992         // want the default deserialization routine to set it to null.
 993         this.pubCredentials = Collections.synchronizedSet
 994                         (new SecureSet&lt;&gt;(this, PUB_CREDENTIAL_SET));
 995         this.privCredentials = Collections.synchronizedSet
 996                         (new SecureSet&lt;&gt;(this, PRIV_CREDENTIAL_SET));
 997     }
 998 
 999     /**
1000      * Tests for null-clean collections (both non-null reference and
1001      * no null elements)
1002      *
1003      * @param coll A {@code Collection} to be tested for null references
1004      *
1005      * @throws NullPointerException if the specified collection is either
1006      *            {@code null} or contains a {@code null} element
1007      */
<span class="line-modified">1008     private static &lt;E&gt; LinkedList&lt;E&gt; collectionNullClean(</span>
<span class="line-modified">1009             Collection&lt;? extends E&gt; coll) {</span>
1010 
1011         Objects.requireNonNull(coll,
1012                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1013 
<span class="line-modified">1014         LinkedList&lt;E&gt; output = new LinkedList&lt;&gt;();</span>
<span class="line-modified">1015         for (E e : coll) {</span>
<span class="line-modified">1016             output.add(Objects.requireNonNull(e,</span>
<span class="line-modified">1017                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;)));</span>









1018         }
<span class="line-added">1019         return output;</span>
1020     }
1021 
1022     /**
1023      * Prevent modifications unless caller has permission.
1024      *
1025      * @serial include
1026      */
1027     private static class SecureSet&lt;E&gt;
1028         implements Set&lt;E&gt;, java.io.Serializable {
1029 
1030         @java.io.Serial
1031         private static final long serialVersionUID = 7911754171111800359L;
1032 
1033         /**
1034          * @serialField this$0 Subject The outer Subject instance.
1035          * @serialField elements LinkedList The elements in this set.
1036          */
1037         @java.io.Serial
1038         private static final ObjectStreamField[] serialPersistentFields = {
1039             new ObjectStreamField(&quot;this$0&quot;, Subject.class),
</pre>
<hr />
<pre>
1045         LinkedList&lt;E&gt; elements;
1046 
1047         /**
1048          * @serial An integer identifying the type of objects contained
1049          *      in this set.  If {@code which == 1},
1050          *      this is a Principal set and all the elements are
1051          *      of type {@code java.security.Principal}.
1052          *      If {@code which == 2}, this is a public credential
1053          *      set and all the elements are of type {@code Object}.
1054          *      If {@code which == 3}, this is a private credential
1055          *      set and all the elements are of type {@code Object}.
1056          */
1057         private int which;
1058 
1059         SecureSet(Subject subject, int which) {
1060             this.subject = subject;
1061             this.which = which;
1062             this.elements = new LinkedList&lt;E&gt;();
1063         }
1064 
<span class="line-modified">1065         SecureSet(Subject subject, int which, LinkedList&lt;E&gt; list) {</span>
1066             this.subject = subject;
1067             this.which = which;
<span class="line-modified">1068             this.elements = list;</span>
1069         }
1070 
1071         public int size() {
1072             return elements.size();
1073         }
1074 
1075         public Iterator&lt;E&gt; iterator() {
1076             final LinkedList&lt;E&gt; list = elements;
1077             return new Iterator&lt;E&gt;() {
1078                 ListIterator&lt;E&gt; i = list.listIterator(0);
1079 
1080                 public boolean hasNext() {return i.hasNext();}
1081 
1082                 public E next() {
1083                     if (which != Subject.PRIV_CREDENTIAL_SET) {
1084                         return i.next();
1085                     }
1086 
1087                     SecurityManager sm = System.getSecurityManager();
1088                     if (sm != null) {
</pre>
<hr />
<pre>
1221                                                 subject.getPrincipals()));
1222                     }
1223                     next = java.security.AccessController.doPrivileged
1224                         (new java.security.PrivilegedAction&lt;E&gt;() {
1225                         public E run() {
1226                             return e.next();
1227                         }
1228                     });
1229                 }
1230 
1231                 if (next.equals(o)) {
1232                     return true;
1233                 }
1234             }
1235             return false;
1236         }
1237 
1238         public boolean addAll(Collection&lt;? extends E&gt; c) {
1239             boolean result = false;
1240 
<span class="line-modified">1241             c = collectionNullClean(c);</span>
1242 
1243             for (E item : c) {
1244                 result |= this.add(item);
1245             }
1246 
1247             return result;
1248         }
1249 
1250         public boolean removeAll(Collection&lt;?&gt; c) {
<span class="line-modified">1251             c = collectionNullClean(c);</span>
1252 
1253             boolean modified = false;
1254             final Iterator&lt;E&gt; e = iterator();
1255             while (e.hasNext()) {
1256                 E next;
1257                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1258                     next = e.next();
1259                 } else {
1260                     next = java.security.AccessController.doPrivileged
1261                         (new java.security.PrivilegedAction&lt;E&gt;() {
1262                         public E run() {
1263                             return e.next();
1264                         }
1265                     });
1266                 }
1267 
1268                 Iterator&lt;?&gt; ce = c.iterator();
1269                 while (ce.hasNext()) {
1270                     if (next.equals(ce.next())) {
1271                             e.remove();
1272                             modified = true;
1273                             break;
1274                         }
1275                 }
1276             }
1277             return modified;
1278         }
1279 
1280         public boolean containsAll(Collection&lt;?&gt; c) {
<span class="line-modified">1281             c = collectionNullClean(c);</span>
1282 
1283             for (Object item : c) {
1284                 if (this.contains(item) == false) {
1285                     return false;
1286                 }
1287             }
1288 
1289             return true;
1290         }
1291 
1292         public boolean retainAll(Collection&lt;?&gt; c) {
<span class="line-modified">1293             c = collectionNullClean(c);</span>
1294 
1295             boolean modified = false;
1296             final Iterator&lt;E&gt; e = iterator();
1297             while (e.hasNext()) {
1298                 E next;
1299                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1300                     next = e.next();
1301                 } else {
1302                     next = java.security.AccessController.doPrivileged
1303                         (new java.security.PrivilegedAction&lt;E&gt;() {
1304                         public E run() {
1305                             return e.next();
1306                         }
1307                     });
1308                 }
1309 
1310                 if (c.contains(next) == false) {
1311                     e.remove();
1312                     modified = true;

1313                 }
<span class="line-added">1314             }</span>
1315 
1316             return modified;
1317         }
1318 
1319         public void clear() {
1320             final Iterator&lt;E&gt; e = iterator();
1321             while (e.hasNext()) {
1322                 E next;
1323                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1324                     next = e.next();
1325                 } else {
1326                     next = java.security.AccessController.doPrivileged
1327                         (new java.security.PrivilegedAction&lt;E&gt;() {
1328                         public E run() {
1329                             return e.next();
1330                         }
1331                     });
1332                 }
1333                 e.remove();
1334             }
</pre>
<hr />
<pre>
1422                 }
1423             }
1424             ObjectOutputStream.PutField fields = oos.putFields();
1425             fields.put(&quot;this$0&quot;, subject);
1426             fields.put(&quot;elements&quot;, elements);
1427             fields.put(&quot;which&quot;, which);
1428             oos.writeFields();
1429         }
1430 
1431         @SuppressWarnings(&quot;unchecked&quot;)
1432         @java.io.Serial
1433         private void readObject(ObjectInputStream ois)
1434             throws IOException, ClassNotFoundException
1435         {
1436             ObjectInputStream.GetField fields = ois.readFields();
1437             subject = (Subject) fields.get(&quot;this$0&quot;, null);
1438             which = fields.get(&quot;which&quot;, 0);
1439 
1440             LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);
1441 
<span class="line-modified">1442             elements = Subject.collectionNullClean(tmp);</span>






1443         }
1444 
1445     }
1446 
1447     /**
1448      * This class implements a {@code Set} which returns only
1449      * members that are an instance of a specified Class.
1450      */
1451     private class ClassSet&lt;T&gt; extends AbstractSet&lt;T&gt; {
1452 
1453         private int which;
1454         private Class&lt;T&gt; c;
1455         private Set&lt;T&gt; set;
1456 
1457         ClassSet(int which, Class&lt;T&gt; c) {
1458             this.which = which;
1459             this.c = c;
1460             set = new HashSet&lt;T&gt;();
1461 
1462             switch (which) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/javax/security/auth/Subject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.security.auth;
  27 
  28 import java.util.*;
  29 import java.io.*;
  30 import java.lang.reflect.*;
  31 import java.text.MessageFormat;
  32 import java.security.AccessController;
  33 import java.security.AccessControlContext;
  34 import java.security.DomainCombiner;
  35 import java.security.Permission;
  36 import java.security.PermissionCollection;
  37 import java.security.Principal;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedExceptionAction;
  40 import java.security.PrivilegedActionException;
  41 import java.security.ProtectionDomain;
  42 import sun.security.util.ResourcesMgr;
  43 
  44 /**
  45  * &lt;p&gt; A {@code Subject} represents a grouping of related information
  46  * for a single entity, such as a person.
  47  * Such information includes the Subject&#39;s identities as well as
  48  * its security-related attributes
  49  * (passwords and cryptographic keys, for example).
  50  *
  51  * &lt;p&gt; Subjects may potentially have multiple identities.
  52  * Each identity is represented as a {@code Principal}
  53  * within the {@code Subject}.  Principals simply bind names to a
  54  * {@code Subject}.  For example, a {@code Subject} that happens
  55  * to be a person, Alice, might have two Principals:
  56  * one which binds &quot;Alice Bar&quot;, the name on her driver license,
  57  * to the {@code Subject}, and another which binds,
  58  * &quot;999-99-9999&quot;, the number on her student identification card,
  59  * to the {@code Subject}.  Both Principals refer to the same
  60  * {@code Subject} even though each has a different name.
  61  *
  62  * &lt;p&gt; A {@code Subject} may also own security-related attributes,
  63  * which are referred to as credentials.
  64  * Sensitive credentials that require special protection, such as
  65  * private cryptographic keys, are stored within a private credential
  66  * {@code Set}.  Credentials intended to be shared, such as
  67  * public key certificates or Kerberos server tickets are stored
  68  * within a public credential {@code Set}.  Different permissions
  69  * are required to access and modify the different credential Sets.
  70  *
  71  * &lt;p&gt; To retrieve all the Principals associated with a {@code Subject},
  72  * invoke the {@code getPrincipals} method.  To retrieve
  73  * all the public or private credentials belonging to a {@code Subject},
  74  * invoke the {@code getPublicCredentials} method or
  75  * {@code getPrivateCredentials} method, respectively.
  76  * To modify the returned {@code Set} of Principals and credentials,
  77  * use the methods defined in the {@code Set} class.
  78  * For example:
  79  * &lt;pre&gt;
  80  *      Subject subject;
  81  *      Principal principal;
  82  *      Object credential;
  83  *
  84  *      // add a Principal and credential to the Subject
  85  *      subject.getPrincipals().add(principal);
  86  *      subject.getPublicCredentials().add(credential);
  87  * &lt;/pre&gt;
  88  *
  89  * &lt;p&gt; This {@code Subject} class implements {@code Serializable}.
  90  * While the Principals associated with the {@code Subject} are serialized,
  91  * the credentials associated with the {@code Subject} are not.
  92  * Note that the {@code java.security.Principal} class
  93  * does not implement {@code Serializable}.  Therefore all concrete
  94  * {@code Principal} implementations associated with Subjects
  95  * must implement {@code Serializable}.
  96  *
  97  * @since 1.4
  98  * @see java.security.Principal
  99  * @see java.security.DomainCombiner
 100  */
 101 public final class Subject implements java.io.Serializable {
 102 
 103     @java.io.Serial
 104     private static final long serialVersionUID = -8308522755600156056L;
 105 
 106     /**
 107      * A {@code Set} that provides a view of all of this
 108      * Subject&#39;s Principals
 109      *
 110      * @serial Each element in this set is a
 111      *          {@code java.security.Principal}.
 112      *          The set is a {@code Subject.SecureSet}.
 113      */
 114     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 115     Set&lt;Principal&gt; principals;
 116 
 117     /**
 118      * Sets that provide a view of all of this
 119      * Subject&#39;s Credentials
 120      */
 121     transient Set&lt;Object&gt; pubCredentials;
 122     transient Set&lt;Object&gt; privCredentials;
 123 
 124     /**
 125      * Whether this Subject is read-only
 126      *
 127      * @serial
 128      */
 129     private volatile boolean readOnly = false;
 130 
 131     private static final int PRINCIPAL_SET = 1;
 132     private static final int PUB_CREDENTIAL_SET = 2;
 133     private static final int PRIV_CREDENTIAL_SET = 3;
 134 
 135     private static final ProtectionDomain[] NULL_PD_ARRAY
 136         = new ProtectionDomain[0];
 137 
 138     /**
 139      * Create an instance of a {@code Subject}
 140      * with an empty {@code Set} of Principals and empty
 141      * Sets of public and private credentials.
 142      *
 143      * &lt;p&gt; The newly constructed Sets check whether this {@code Subject}
 144      * has been set read-only before permitting subsequent modifications.
 145      * The newly created Sets also prevent illegal modifications
 146      * by ensuring that callers have sufficient permissions.  These Sets
 147      * also prohibit null elements, and attempts to add or query a null
 148      * element will result in a {@code NullPointerException}.
 149      *
 150      * &lt;p&gt; To modify the Principals Set, the caller must have
 151      * {@code AuthPermission(&quot;modifyPrincipals&quot;)}.
 152      * To modify the public credential Set, the caller must have
 153      * {@code AuthPermission(&quot;modifyPublicCredentials&quot;)}.
 154      * To modify the private credential Set, the caller must have
 155      * {@code AuthPermission(&quot;modifyPrivateCredentials&quot;)}.
 156      */
 157     public Subject() {
 158 
 159         this.principals = Collections.synchronizedSet
 160                         (new SecureSet&lt;&gt;(this, PRINCIPAL_SET));
 161         this.pubCredentials = Collections.synchronizedSet
 162                         (new SecureSet&lt;&gt;(this, PUB_CREDENTIAL_SET));
 163         this.privCredentials = Collections.synchronizedSet
 164                         (new SecureSet&lt;&gt;(this, PRIV_CREDENTIAL_SET));
 165     }
 166 
 167     /**
 168      * Create an instance of a {@code Subject} with
 169      * Principals and credentials.
 170      *
 171      * &lt;p&gt; The Principals and credentials from the specified Sets
 172      * are copied into newly constructed Sets.
 173      * These newly created Sets check whether this {@code Subject}
 174      * has been set read-only before permitting subsequent modifications.
 175      * The newly created Sets also prevent illegal modifications
 176      * by ensuring that callers have sufficient permissions.  These Sets
 177      * also prohibit null elements, and attempts to add or query a null
 178      * element will result in a {@code NullPointerException}.
 179      *
 180      * &lt;p&gt; To modify the Principals Set, the caller must have
 181      * {@code AuthPermission(&quot;modifyPrincipals&quot;)}.
 182      * To modify the public credential Set, the caller must have
 183      * {@code AuthPermission(&quot;modifyPublicCredentials&quot;)}.
 184      * To modify the private credential Set, the caller must have
 185      * {@code AuthPermission(&quot;modifyPrivateCredentials&quot;)}.
 186      *
 187      * @param readOnly true if the {@code Subject} is to be read-only,
 188      *          and false otherwise.
 189      *
 190      * @param principals the {@code Set} of Principals
 191      *          to be associated with this {@code Subject}.
 192      *
 193      * @param pubCredentials the {@code Set} of public credentials
 194      *          to be associated with this {@code Subject}.
 195      *
 196      * @param privCredentials the {@code Set} of private credentials
 197      *          to be associated with this {@code Subject}.
 198      *
 199      * @throws NullPointerException if the specified
 200      *          {@code principals}, {@code pubCredentials},
 201      *          or {@code privCredentials} are {@code null},
 202      *          or a null value exists within any of these three
 203      *          Sets.
 204      */
 205     public Subject(boolean readOnly, Set&lt;? extends Principal&gt; principals,
 206                    Set&lt;?&gt; pubCredentials, Set&lt;?&gt; privCredentials)
 207     {
 208         LinkedList&lt;Principal&gt; princList
 209                 = collectionNullClean(principals);
 210         LinkedList&lt;Object&gt; pubCredsList
 211                 = collectionNullClean(pubCredentials);
 212         LinkedList&lt;Object&gt; privCredsList
 213                 = collectionNullClean(privCredentials);
 214 
 215         this.principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
 216                                 (this, PRINCIPAL_SET, princList));
 217         this.pubCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
 218                                 (this, PUB_CREDENTIAL_SET, pubCredsList));
 219         this.privCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
 220                                 (this, PRIV_CREDENTIAL_SET, privCredsList));
 221         this.readOnly = readOnly;
 222     }
 223 
 224     /**
 225      * Set this {@code Subject} to be read-only.
 226      *
 227      * &lt;p&gt; Modifications (additions and removals) to this Subject&#39;s
 228      * {@code Principal} {@code Set} and
 229      * credential Sets will be disallowed.
 230      * The {@code destroy} operation on this Subject&#39;s credentials will
 231      * still be permitted.
 232      *
 233      * &lt;p&gt; Subsequent attempts to modify the Subject&#39;s {@code Principal}
 234      * and credential Sets will result in an
 235      * {@code IllegalStateException} being thrown.
 236      * Also, once a {@code Subject} is read-only,
 237      * it can not be reset to being writable again.
 238      *
 239      * @throws SecurityException if a security manager is installed and the
 240      *         caller does not have an
 241      *         {@link AuthPermission#AuthPermission(String)
 242      *         AuthPermission(&quot;setReadOnly&quot;)} permission to set this
 243      *         {@code Subject} to be read-only.
 244      */
 245     public void setReadOnly() {
 246         java.lang.SecurityManager sm = System.getSecurityManager();
 247         if (sm != null) {
 248             sm.checkPermission(AuthPermissionHolder.SET_READ_ONLY_PERMISSION);
 249         }
 250 
 251         this.readOnly = true;
 252     }
 253 
 254     /**
 255      * Query whether this {@code Subject} is read-only.
 256      *
 257      * @return true if this {@code Subject} is read-only, false otherwise.
 258      */
 259     public boolean isReadOnly() {
 260         return this.readOnly;
 261     }
 262 
 263     /**
 264      * Get the {@code Subject} associated with the provided
 265      * {@code AccessControlContext}.
 266      *
 267      * &lt;p&gt; The {@code AccessControlContext} may contain many
 268      * Subjects (from nested {@code doAs} calls).
 269      * In this situation, the most recent {@code Subject} associated
 270      * with the {@code AccessControlContext} is returned.
 271      *
 272      * @param  acc the {@code AccessControlContext} from which to retrieve
 273      *          the {@code Subject}.
 274      *
 275      * @return  the {@code Subject} associated with the provided
 276      *          {@code AccessControlContext}, or {@code null}
 277      *          if no {@code Subject} is associated
 278      *          with the provided {@code AccessControlContext}.
 279      *
 280      * @throws SecurityException if a security manager is installed and the
 281      *          caller does not have an
 282      *          {@link AuthPermission#AuthPermission(String)
 283      *          AuthPermission(&quot;getSubject&quot;)} permission to get the
 284      *          {@code Subject}.
 285      *
 286      * @throws NullPointerException if the provided
 287      *          {@code AccessControlContext} is {@code null}.
 288      */
 289     public static Subject getSubject(final AccessControlContext acc) {
 290 
 291         java.lang.SecurityManager sm = System.getSecurityManager();
 292         if (sm != null) {
 293             sm.checkPermission(AuthPermissionHolder.GET_SUBJECT_PERMISSION);
 294         }
 295 
 296         Objects.requireNonNull(acc, ResourcesMgr.getString
 297                 (&quot;invalid.null.AccessControlContext.provided&quot;));
 298 
 299         // return the Subject from the DomainCombiner of the provided context
 300         return AccessController.doPrivileged
 301             (new java.security.PrivilegedAction&lt;&gt;() {
 302             public Subject run() {
 303                 DomainCombiner dc = acc.getDomainCombiner();
 304                 if (!(dc instanceof SubjectDomainCombiner)) {
 305                     return null;
 306                 }
 307                 SubjectDomainCombiner sdc = (SubjectDomainCombiner)dc;
 308                 return sdc.getSubject();
 309             }
 310         });
 311     }
 312 
 313     /**
 314      * Perform work as a particular {@code Subject}.
 315      *
 316      * &lt;p&gt; This method first retrieves the current Thread&#39;s
 317      * {@code AccessControlContext} via
 318      * {@code AccessController.getContext},
 319      * and then instantiates a new {@code AccessControlContext}
 320      * using the retrieved context along with a new
 321      * {@code SubjectDomainCombiner} (constructed using
 322      * the provided {@code Subject}).
 323      * Finally, this method invokes {@code AccessController.doPrivileged},
 324      * passing it the provided {@code PrivilegedAction},
 325      * as well as the newly constructed {@code AccessControlContext}.
 326      *
 327      * @param subject the {@code Subject} that the specified
 328      *                  {@code action} will run as.  This parameter
 329      *                  may be {@code null}.
 330      *
 331      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 332      *                  {@code run} method.
 333      *
 334      * @param action the code to be run as the specified
 335      *                  {@code Subject}.
 336      *
 337      * @return the value returned by the PrivilegedAction&#39;s
 338      *                  {@code run} method.
 339      *
 340      * @throws NullPointerException if the {@code PrivilegedAction}
 341      *                  is {@code null}.
 342      *
 343      * @throws SecurityException if a security manager is installed and the
 344      *                  caller does not have an
 345      *                  {@link AuthPermission#AuthPermission(String)
 346      *                  AuthPermission(&quot;doAs&quot;)} permission to invoke this
 347      *                  method.
 348      */
 349     public static &lt;T&gt; T doAs(final Subject subject,
 350                         final java.security.PrivilegedAction&lt;T&gt; action) {
 351 
 352         java.lang.SecurityManager sm = System.getSecurityManager();
 353         if (sm != null) {
 354             sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);
 355         }
 356 
 357         Objects.requireNonNull(action,
 358                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 359 
 360         // set up the new Subject-based AccessControlContext
 361         // for doPrivileged
 362         final AccessControlContext currentAcc = AccessController.getContext();
 363 
 364         // call doPrivileged and push this new context on the stack
 365         return java.security.AccessController.doPrivileged
 366                                         (action,
 367                                         createContext(subject, currentAcc));
 368     }
 369 
 370     /**
 371      * Perform work as a particular {@code Subject}.
 372      *
 373      * &lt;p&gt; This method first retrieves the current Thread&#39;s
 374      * {@code AccessControlContext} via
 375      * {@code AccessController.getContext},
 376      * and then instantiates a new {@code AccessControlContext}
 377      * using the retrieved context along with a new
 378      * {@code SubjectDomainCombiner} (constructed using
 379      * the provided {@code Subject}).
 380      * Finally, this method invokes {@code AccessController.doPrivileged},
 381      * passing it the provided {@code PrivilegedExceptionAction},
 382      * as well as the newly constructed {@code AccessControlContext}.
 383      *
 384      * @param subject the {@code Subject} that the specified
 385      *                  {@code action} will run as.  This parameter
 386      *                  may be {@code null}.
 387      *
 388      * @param &lt;T&gt; the type of the value returned by the
 389      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 390      *
 391      * @param action the code to be run as the specified
 392      *                  {@code Subject}.
 393      *
 394      * @return the value returned by the
 395      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 396      *
 397      * @throws PrivilegedActionException if the
 398      *                  {@code PrivilegedExceptionAction.run}
 399      *                  method throws a checked exception.
 400      *
 401      * @throws NullPointerException if the specified
 402      *                  {@code PrivilegedExceptionAction} is
 403      *                  {@code null}.
 404      *
 405      * @throws SecurityException if a security manager is installed and the
 406      *                  caller does not have an
 407      *                  {@link AuthPermission#AuthPermission(String)
 408      *                  AuthPermission(&quot;doAs&quot;)} permission to invoke this
 409      *                  method.
 410      */
 411     public static &lt;T&gt; T doAs(final Subject subject,
 412                         final java.security.PrivilegedExceptionAction&lt;T&gt; action)
 413                         throws java.security.PrivilegedActionException {
 414 
 415         java.lang.SecurityManager sm = System.getSecurityManager();
 416         if (sm != null) {
 417             sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);
 418         }
 419 
 420         Objects.requireNonNull(action,
 421                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 422 
 423         // set up the new Subject-based AccessControlContext for doPrivileged
 424         final AccessControlContext currentAcc = AccessController.getContext();
 425 
 426         // call doPrivileged and push this new context on the stack
 427         return java.security.AccessController.doPrivileged
 428                                         (action,
 429                                         createContext(subject, currentAcc));
 430     }
 431 
 432     /**
 433      * Perform privileged work as a particular {@code Subject}.
 434      *
 435      * &lt;p&gt; This method behaves exactly as {@code Subject.doAs},
 436      * except that instead of retrieving the current Thread&#39;s
 437      * {@code AccessControlContext}, it uses the provided
 438      * {@code AccessControlContext}.  If the provided
 439      * {@code AccessControlContext} is {@code null},
 440      * this method instantiates a new {@code AccessControlContext}
 441      * with an empty collection of ProtectionDomains.
 442      *
 443      * @param subject the {@code Subject} that the specified
 444      *                  {@code action} will run as.  This parameter
 445      *                  may be {@code null}.
 446      *
 447      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 448      *                  {@code run} method.
 449      *
 450      * @param action the code to be run as the specified
 451      *                  {@code Subject}.
 452      *
 453      * @param acc the {@code AccessControlContext} to be tied to the
 454      *                  specified &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;action&lt;/i&gt;.
 455      *
 456      * @return the value returned by the PrivilegedAction&#39;s
 457      *                  {@code run} method.
 458      *
 459      * @throws NullPointerException if the {@code PrivilegedAction}
 460      *                  is {@code null}.
 461      *
 462      * @throws SecurityException if a security manager is installed and the
 463      *                  caller does not have a
 464      *                  {@link AuthPermission#AuthPermission(String)
 465      *                  AuthPermission(&quot;doAsPrivileged&quot;)} permission to invoke
 466      *                  this method.
 467      */
 468     public static &lt;T&gt; T doAsPrivileged(final Subject subject,
 469                         final java.security.PrivilegedAction&lt;T&gt; action,
 470                         final java.security.AccessControlContext acc) {
 471 
 472         java.lang.SecurityManager sm = System.getSecurityManager();
 473         if (sm != null) {
 474             sm.checkPermission(AuthPermissionHolder.DO_AS_PRIVILEGED_PERMISSION);
 475         }
 476 
 477         Objects.requireNonNull(action,
 478                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 479 
 480         // set up the new Subject-based AccessControlContext
 481         // for doPrivileged
 482         final AccessControlContext callerAcc =
 483                 (acc == null ?
 484                 new AccessControlContext(NULL_PD_ARRAY) :
 485                 acc);
 486 
 487         // call doPrivileged and push this new context on the stack
 488         return java.security.AccessController.doPrivileged
 489                                         (action,
 490                                         createContext(subject, callerAcc));
 491     }
 492 
 493     /**
 494      * Perform privileged work as a particular {@code Subject}.
 495      *
 496      * &lt;p&gt; This method behaves exactly as {@code Subject.doAs},
 497      * except that instead of retrieving the current Thread&#39;s
 498      * {@code AccessControlContext}, it uses the provided
 499      * {@code AccessControlContext}.  If the provided
 500      * {@code AccessControlContext} is {@code null},
 501      * this method instantiates a new {@code AccessControlContext}
 502      * with an empty collection of ProtectionDomains.
 503      *
 504      * @param subject the {@code Subject} that the specified
 505      *                  {@code action} will run as.  This parameter
 506      *                  may be {@code null}.
 507      *
 508      * @param &lt;T&gt; the type of the value returned by the
 509      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 510      *
 511      * @param action the code to be run as the specified
 512      *                  {@code Subject}.
 513      *
 514      * @param acc the {@code AccessControlContext} to be tied to the
 515      *                  specified &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;action&lt;/i&gt;.
 516      *
 517      * @return the value returned by the
 518      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 519      *
 520      * @throws PrivilegedActionException if the
 521      *                  {@code PrivilegedExceptionAction.run}
 522      *                  method throws a checked exception.
 523      *
 524      * @throws NullPointerException if the specified
 525      *                  {@code PrivilegedExceptionAction} is
 526      *                  {@code null}.
 527      *
 528      * @throws SecurityException if a security manager is installed and the
 529      *                  caller does not have a
 530      *                  {@link AuthPermission#AuthPermission(String)
 531      *                  AuthPermission(&quot;doAsPrivileged&quot;)} permission to invoke
 532      *                  this method.
 533      */
 534     public static &lt;T&gt; T doAsPrivileged(final Subject subject,
 535                         final java.security.PrivilegedExceptionAction&lt;T&gt; action,
 536                         final java.security.AccessControlContext acc)
 537                         throws java.security.PrivilegedActionException {
 538 
 539         java.lang.SecurityManager sm = System.getSecurityManager();
 540         if (sm != null) {
 541             sm.checkPermission(AuthPermissionHolder.DO_AS_PRIVILEGED_PERMISSION);
 542         }
 543 
 544         Objects.requireNonNull(action,
 545                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 546 
 547         // set up the new Subject-based AccessControlContext for doPrivileged
 548         final AccessControlContext callerAcc =
 549                 (acc == null ?
 550                 new AccessControlContext(NULL_PD_ARRAY) :
 551                 acc);
 552 
 553         // call doPrivileged and push this new context on the stack
 554         return java.security.AccessController.doPrivileged
 555                                         (action,
 556                                         createContext(subject, callerAcc));
 557     }
 558 
 559     private static AccessControlContext createContext(final Subject subject,
 560                                         final AccessControlContext acc) {
 561 
 562 
 563         return java.security.AccessController.doPrivileged
 564             (new java.security.PrivilegedAction&lt;&gt;() {
 565             public AccessControlContext run() {
 566                 if (subject == null) {
 567                     return new AccessControlContext(acc, null);
 568                 } else {
 569                     return new AccessControlContext
 570                                         (acc,
 571                                         new SubjectDomainCombiner(subject));
 572             }
 573             }
 574         });
 575     }
 576 
 577     /**
 578      * Return the {@code Set} of Principals associated with this
 579      * {@code Subject}.  Each {@code Principal} represents
 580      * an identity for this {@code Subject}.
 581      *
 582      * &lt;p&gt; The returned {@code Set} is backed by this Subject&#39;s
 583      * internal {@code Principal} {@code Set}.  Any modification
 584      * to the returned {@code Set} affects the internal
 585      * {@code Principal} {@code Set} as well.
 586      *
 587      * &lt;p&gt; If a security manager is installed, the caller must have a
 588      * {@link AuthPermission#AuthPermission(String)
 589      * AuthPermission(&quot;modifyPrincipals&quot;)} permission to modify
 590      * the returned set, or a {@code SecurityException} will be thrown.
 591      *
 592      * @return  the {@code Set} of Principals associated with this
 593      *          {@code Subject}.
 594      */
 595     public Set&lt;Principal&gt; getPrincipals() {
 596 
 597         // always return an empty Set instead of null
 598         // so LoginModules can add to the Set if necessary
 599         return principals;
 600     }
 601 
 602     /**
 603      * Return a {@code Set} of Principals associated with this
 604      * {@code Subject} that are instances or subclasses of the specified
 605      * {@code Class}.
 606      *
 607      * &lt;p&gt; The returned {@code Set} is not backed by this Subject&#39;s
 608      * internal {@code Principal} {@code Set}.  A new
 609      * {@code Set} is created and returned for each method invocation.
 610      * Modifications to the returned {@code Set}
 611      * will not affect the internal {@code Principal} {@code Set}.
 612      *
 613      * @param &lt;T&gt; the type of the class modeled by {@code c}
 614      *
 615      * @param c the returned {@code Set} of Principals will all be
 616      *          instances of this class.
 617      *
 618      * @return a {@code Set} of Principals that are instances of the
 619      *          specified {@code Class}.
 620      *
 621      * @throws NullPointerException if the specified {@code Class}
 622      *          is {@code null}.
 623      */
 624     public &lt;T extends Principal&gt; Set&lt;T&gt; getPrincipals(Class&lt;T&gt; c) {
 625 
 626         Objects.requireNonNull(c,
 627                 ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));
 628 
 629         // always return an empty Set instead of null
 630         // so LoginModules can add to the Set if necessary
 631         return new ClassSet&lt;T&gt;(PRINCIPAL_SET, c);
 632     }
 633 
 634     /**
 635      * Return the {@code Set} of public credentials held by this
 636      * {@code Subject}.
 637      *
 638      * &lt;p&gt; The returned {@code Set} is backed by this Subject&#39;s
 639      * internal public Credential {@code Set}.  Any modification
 640      * to the returned {@code Set} affects the internal public
 641      * Credential {@code Set} as well.
 642      *
 643      * &lt;p&gt; If a security manager is installed, the caller must have a
 644      * {@link AuthPermission#AuthPermission(String)
 645      * AuthPermission(&quot;modifyPublicCredentials&quot;)} permission to modify
 646      * the returned set, or a {@code SecurityException} will be thrown.
 647      *
 648      * @return  a {@code Set} of public credentials held by this
 649      *          {@code Subject}.
 650      */
 651     public Set&lt;Object&gt; getPublicCredentials() {
 652 
 653         // always return an empty Set instead of null
 654         // so LoginModules can add to the Set if necessary
 655         return pubCredentials;
 656     }
 657 
 658     /**
 659      * Return the {@code Set} of private credentials held by this
 660      * {@code Subject}.
 661      *
 662      * &lt;p&gt; The returned {@code Set} is backed by this Subject&#39;s
 663      * internal private Credential {@code Set}.  Any modification
 664      * to the returned {@code Set} affects the internal private
 665      * Credential {@code Set} as well.
 666      *
 667      * &lt;p&gt; If a security manager is installed, the caller must have a
 668      * {@link AuthPermission#AuthPermission(String)
 669      * AuthPermission(&quot;modifyPrivateCredentials&quot;)} permission to modify
 670      * the returned set, or a {@code SecurityException} will be thrown.
 671      *
 672      * &lt;p&gt; While iterating through the {@code Set},
 673      * a {@code SecurityException} is thrown if a security manager is installed
 674      * and the caller does not have a {@link PrivateCredentialPermission}
 675      * to access a particular Credential.  The {@code Iterator}
 676      * is nevertheless advanced to the next element in the {@code Set}.
 677      *
 678      * @return  a {@code Set} of private credentials held by this
 679      *          {@code Subject}.
 680      */
 681     public Set&lt;Object&gt; getPrivateCredentials() {
 682 
 683         // XXX
 684         // we do not need a security check for
 685         // AuthPermission(getPrivateCredentials)
 686         // because we already restrict access to private credentials
 687         // via the PrivateCredentialPermission.  all the extra AuthPermission
 688         // would do is protect the set operations themselves
 689         // (like size()), which don&#39;t seem security-sensitive.
 690 
 691         // always return an empty Set instead of null
 692         // so LoginModules can add to the Set if necessary
 693         return privCredentials;
 694     }
 695 
 696     /**
 697      * Return a {@code Set} of public credentials associated with this
 698      * {@code Subject} that are instances or subclasses of the specified
 699      * {@code Class}.
 700      *
 701      * &lt;p&gt; The returned {@code Set} is not backed by this Subject&#39;s
 702      * internal public Credential {@code Set}.  A new
 703      * {@code Set} is created and returned for each method invocation.
 704      * Modifications to the returned {@code Set}
 705      * will not affect the internal public Credential {@code Set}.
 706      *
 707      * @param &lt;T&gt; the type of the class modeled by {@code c}
 708      *
 709      * @param c the returned {@code Set} of public credentials will all be
 710      *          instances of this class.
 711      *
 712      * @return a {@code Set} of public credentials that are instances
 713      *          of the  specified {@code Class}.
 714      *
 715      * @throws NullPointerException if the specified {@code Class}
 716      *          is {@code null}.
 717      */
 718     public &lt;T&gt; Set&lt;T&gt; getPublicCredentials(Class&lt;T&gt; c) {
 719 
 720         Objects.requireNonNull(c,
 721                 ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));
 722 
 723         // always return an empty Set instead of null
 724         // so LoginModules can add to the Set if necessary
 725         return new ClassSet&lt;T&gt;(PUB_CREDENTIAL_SET, c);
 726     }
 727 
 728     /**
 729      * Return a {@code Set} of private credentials associated with this
 730      * {@code Subject} that are instances or subclasses of the specified
 731      * {@code Class}.
 732      *
 733      * &lt;p&gt; If a security manager is installed, the caller must have a
 734      * {@link PrivateCredentialPermission} to access all of the requested
 735      * Credentials, or a {@code SecurityException} will be thrown.
 736      *
 737      * &lt;p&gt; The returned {@code Set} is not backed by this Subject&#39;s
 738      * internal private Credential {@code Set}.  A new
 739      * {@code Set} is created and returned for each method invocation.
 740      * Modifications to the returned {@code Set}
 741      * will not affect the internal private Credential {@code Set}.
 742      *
 743      * @param &lt;T&gt; the type of the class modeled by {@code c}
 744      *
 745      * @param c the returned {@code Set} of private credentials will all be
 746      *          instances of this class.
 747      *
 748      * @return a {@code Set} of private credentials that are instances
 749      *          of the  specified {@code Class}.
 750      *
 751      * @throws NullPointerException if the specified {@code Class}
 752      *          is {@code null}.
 753      */
 754     public &lt;T&gt; Set&lt;T&gt; getPrivateCredentials(Class&lt;T&gt; c) {
 755 
 756         // XXX
 757         // we do not need a security check for
 758         // AuthPermission(getPrivateCredentials)
 759         // because we already restrict access to private credentials
 760         // via the PrivateCredentialPermission.  all the extra AuthPermission
 761         // would do is protect the set operations themselves
 762         // (like size()), which don&#39;t seem security-sensitive.
 763 
 764         Objects.requireNonNull(c,
 765                 ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));
 766 
 767         // always return an empty Set instead of null
 768         // so LoginModules can add to the Set if necessary
 769         return new ClassSet&lt;T&gt;(PRIV_CREDENTIAL_SET, c);
 770     }
 771 
 772     /**
 773      * Compares the specified Object with this {@code Subject}
 774      * for equality.  Returns true if the given object is also a Subject
 775      * and the two {@code Subject} instances are equivalent.
 776      * More formally, two {@code Subject} instances are
 777      * equal if their {@code Principal} and {@code Credential}
 778      * Sets are equal.
 779      *
 780      * @param o Object to be compared for equality with this
 781      *          {@code Subject}.
 782      *
 783      * @return true if the specified Object is equal to this
 784      *          {@code Subject}.
 785      *
 786      * @throws SecurityException if a security manager is installed and the
 787      *         caller does not have a {@link PrivateCredentialPermission}
 788      *         permission to access the private credentials for this
 789      *         {@code Subject} or the provided {@code Subject}.
 790      */
 791     @Override
 792     public boolean equals(Object o) {
 793 
 794         if (o == null) {
 795             return false;
 796         }
 797 
 798         if (this == o) {
 799             return true;
 800         }
 801 
 802         if (o instanceof Subject) {
 803 
 804             final Subject that = (Subject)o;
 805 
 806             // check the principal and credential sets
 807             Set&lt;Principal&gt; thatPrincipals;
 808             synchronized(that.principals) {
 809                 // avoid deadlock from dual locks
 810                 thatPrincipals = new HashSet&lt;&gt;(that.principals);
 811             }
 812             if (!principals.equals(thatPrincipals)) {
 813                 return false;
 814             }
 815 
 816             Set&lt;Object&gt; thatPubCredentials;
 817             synchronized(that.pubCredentials) {
 818                 // avoid deadlock from dual locks
 819                 thatPubCredentials = new HashSet&lt;&gt;(that.pubCredentials);
 820             }
 821             if (!pubCredentials.equals(thatPubCredentials)) {
 822                 return false;
 823             }
 824 
 825             Set&lt;Object&gt; thatPrivCredentials;
 826             synchronized(that.privCredentials) {
 827                 // avoid deadlock from dual locks
 828                 thatPrivCredentials = new HashSet&lt;&gt;(that.privCredentials);
 829             }
 830             if (!privCredentials.equals(thatPrivCredentials)) {
 831                 return false;
 832             }
 833             return true;
 834         }
 835         return false;
 836     }
 837 
 838     /**
 839      * Return the String representation of this {@code Subject}.
 840      *
 841      * @return the String representation of this {@code Subject}.
 842      */
 843     @Override
 844     public String toString() {
 845         return toString(true);
 846     }
 847 
 848     /**
 849      * package private convenience method to print out the Subject
 850      * without firing off a security check when trying to access
 851      * the Private Credentials
 852      */
 853     String toString(boolean includePrivateCredentials) {
 854 
 855         String s = ResourcesMgr.getString(&quot;Subject.&quot;);
 856         String suffix = &quot;&quot;;
 857 
 858         synchronized(principals) {
 859             Iterator&lt;Principal&gt; pI = principals.iterator();
 860             while (pI.hasNext()) {
 861                 Principal p = pI.next();
 862                 suffix = suffix + ResourcesMgr.getString(&quot;.Principal.&quot;) +
 863                         p.toString() + ResourcesMgr.getString(&quot;NEWLINE&quot;);
 864             }
 865         }
 866 
 867         synchronized(pubCredentials) {
 868             Iterator&lt;Object&gt; pI = pubCredentials.iterator();
 869             while (pI.hasNext()) {
 870                 Object o = pI.next();
 871                 suffix = suffix +
 872                         ResourcesMgr.getString(&quot;.Public.Credential.&quot;) +
 873                         o.toString() + ResourcesMgr.getString(&quot;NEWLINE&quot;);
 874             }
 875         }
 876 
 877         if (includePrivateCredentials) {
 878             synchronized(privCredentials) {
 879                 Iterator&lt;Object&gt; pI = privCredentials.iterator();
 880                 while (pI.hasNext()) {
 881                     try {
 882                         Object o = pI.next();
 883                         suffix += ResourcesMgr.getString
 884                                         (&quot;.Private.Credential.&quot;) +
 885                                         o.toString() +
 886                                         ResourcesMgr.getString(&quot;NEWLINE&quot;);
 887                     } catch (SecurityException se) {
 888                         suffix += ResourcesMgr.getString
 889                                 (&quot;.Private.Credential.inaccessible.&quot;);
 890                         break;
 891                     }
 892                 }
 893             }
 894         }
 895         return s + suffix;
 896     }
 897 
 898     /**
 899      * Returns a hashcode for this {@code Subject}.
 900      *
 901      * @return a hashcode for this {@code Subject}.
 902      *
 903      * @throws SecurityException if a security manager is installed and the
 904      *         caller does not have a {@link PrivateCredentialPermission}
 905      *         permission to access this Subject&#39;s private credentials.
 906      */
 907     @Override
 908     public int hashCode() {
 909 
 910         /**
 911          * The hashcode is derived exclusive or-ing the
 912          * hashcodes of this Subject&#39;s Principals and credentials.
 913          *
 914          * If a particular credential was destroyed
 915          * ({@code credential.hashCode()} throws an
 916          * {@code IllegalStateException}),
 917          * the hashcode for that credential is derived via:
 918          * {@code credential.getClass().toString().hashCode()}.
 919          */
 920 
 921         int hashCode = 0;
 922 
 923         synchronized(principals) {
 924             Iterator&lt;Principal&gt; pIterator = principals.iterator();
 925             while (pIterator.hasNext()) {
 926                 Principal p = pIterator.next();
 927                 hashCode ^= p.hashCode();
 928             }
 929         }
 930 
 931         synchronized(pubCredentials) {
 932             Iterator&lt;Object&gt; pubCIterator = pubCredentials.iterator();
 933             while (pubCIterator.hasNext()) {
 934                 hashCode ^= getCredHashCode(pubCIterator.next());
 935             }
 936         }
 937         return hashCode;
 938     }
 939 
 940     /**
 941      * get a credential&#39;s hashcode
 942      */
 943     private int getCredHashCode(Object o) {
 944         try {
 945             return o.hashCode();
 946         } catch (IllegalStateException ise) {
 947             return o.getClass().toString().hashCode();
 948         }
 949     }
 950 
 951     /**
 952      * Writes this object out to a stream (i.e., serializes it).
 953      */
 954     @java.io.Serial
 955     private void writeObject(java.io.ObjectOutputStream oos)
 956                 throws java.io.IOException {
 957         synchronized(principals) {
 958             oos.defaultWriteObject();
 959         }
 960     }
 961 
 962     /**
 963      * Reads this object from a stream (i.e., deserializes it)
 964      */
 965     @SuppressWarnings(&quot;unchecked&quot;)
 966     @java.io.Serial
 967     private void readObject(java.io.ObjectInputStream s)
 968                 throws java.io.IOException, ClassNotFoundException {
 969 
 970         ObjectInputStream.GetField gf = s.readFields();
 971 
 972         readOnly = gf.get(&quot;readOnly&quot;, false);
 973 
 974         Set&lt;Principal&gt; inputPrincs = (Set&lt;Principal&gt;)gf.get(&quot;principals&quot;, null);
 975 
 976         Objects.requireNonNull(inputPrincs,
 977                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
 978 
 979         // Rewrap the principals into a SecureSet
 980         try {
 981             LinkedList&lt;Principal&gt; princList = collectionNullClean(inputPrincs);
 982             principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
 983                                 (this, PRINCIPAL_SET, princList));
 984         } catch (NullPointerException npe) {
 985             // Sometimes people deserialize the principals set only.
 986             // Subject is not accessible, so just don&#39;t fail.
 987             principals = Collections.synchronizedSet
 988                         (new SecureSet&lt;&gt;(this, PRINCIPAL_SET));
 989         }
 990 
 991         // The Credential {@code Set} is not serialized, but we do not
 992         // want the default deserialization routine to set it to null.
 993         this.pubCredentials = Collections.synchronizedSet
 994                         (new SecureSet&lt;&gt;(this, PUB_CREDENTIAL_SET));
 995         this.privCredentials = Collections.synchronizedSet
 996                         (new SecureSet&lt;&gt;(this, PRIV_CREDENTIAL_SET));
 997     }
 998 
 999     /**
1000      * Tests for null-clean collections (both non-null reference and
1001      * no null elements)
1002      *
1003      * @param coll A {@code Collection} to be tested for null references
1004      *
1005      * @throws NullPointerException if the specified collection is either
1006      *            {@code null} or contains a {@code null} element
1007      */
1008     private static &lt;E&gt; LinkedList&lt;E&gt; collectionNullClean(
1009             Collection&lt;? extends E&gt; coll) {
1010 
1011         Objects.requireNonNull(coll,
1012                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1013 
1014         LinkedList&lt;E&gt; output = new LinkedList&lt;&gt;();
1015         for (E e : coll) {
1016             output.add(Objects.requireNonNull(e,
1017                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;)));
1018         }
1019         return output;
1020     }
1021 
1022     /**
1023      * Prevent modifications unless caller has permission.
1024      *
1025      * @serial include
1026      */
1027     private static class SecureSet&lt;E&gt;
1028         implements Set&lt;E&gt;, java.io.Serializable {
1029 
1030         @java.io.Serial
1031         private static final long serialVersionUID = 7911754171111800359L;
1032 
1033         /**
1034          * @serialField this$0 Subject The outer Subject instance.
1035          * @serialField elements LinkedList The elements in this set.
1036          */
1037         @java.io.Serial
1038         private static final ObjectStreamField[] serialPersistentFields = {
1039             new ObjectStreamField(&quot;this$0&quot;, Subject.class),
1040             new ObjectStreamField(&quot;elements&quot;, LinkedList.class),
1041             new ObjectStreamField(&quot;which&quot;, int.class)
1042         };
1043 
1044         Subject subject;
1045         LinkedList&lt;E&gt; elements;
1046 
1047         /**
1048          * @serial An integer identifying the type of objects contained
1049          *      in this set.  If {@code which == 1},
1050          *      this is a Principal set and all the elements are
1051          *      of type {@code java.security.Principal}.
1052          *      If {@code which == 2}, this is a public credential
1053          *      set and all the elements are of type {@code Object}.
1054          *      If {@code which == 3}, this is a private credential
1055          *      set and all the elements are of type {@code Object}.
1056          */
1057         private int which;
1058 
1059         SecureSet(Subject subject, int which) {
1060             this.subject = subject;
1061             this.which = which;
1062             this.elements = new LinkedList&lt;E&gt;();
1063         }
1064 
1065         SecureSet(Subject subject, int which, LinkedList&lt;E&gt; list) {
1066             this.subject = subject;
1067             this.which = which;
1068             this.elements = list;
1069         }
1070 
1071         public int size() {
1072             return elements.size();
1073         }
1074 
1075         public Iterator&lt;E&gt; iterator() {
1076             final LinkedList&lt;E&gt; list = elements;
1077             return new Iterator&lt;E&gt;() {
1078                 ListIterator&lt;E&gt; i = list.listIterator(0);
1079 
1080                 public boolean hasNext() {return i.hasNext();}
1081 
1082                 public E next() {
1083                     if (which != Subject.PRIV_CREDENTIAL_SET) {
1084                         return i.next();
1085                     }
1086 
1087                     SecurityManager sm = System.getSecurityManager();
1088                     if (sm != null) {
1089                         try {
1090                             sm.checkPermission(new PrivateCredentialPermission
1091                                 (list.get(i.nextIndex()).getClass().getName(),
1092                                 subject.getPrincipals()));
1093                         } catch (SecurityException se) {
1094                             i.next();
1095                             throw (se);
1096                         }
1097                     }
1098                     return i.next();
1099                 }
1100 
1101                 public void remove() {
1102 
1103                     if (subject.isReadOnly()) {
1104                         throw new IllegalStateException(ResourcesMgr.getString
1105                                 (&quot;Subject.is.read.only&quot;));
1106                     }
1107 
1108                     java.lang.SecurityManager sm = System.getSecurityManager();
1109                     if (sm != null) {
1110                         switch (which) {
1111                         case Subject.PRINCIPAL_SET:
1112                             sm.checkPermission(AuthPermissionHolder.MODIFY_PRINCIPALS_PERMISSION);
1113                             break;
1114                         case Subject.PUB_CREDENTIAL_SET:
1115                             sm.checkPermission(AuthPermissionHolder.MODIFY_PUBLIC_CREDENTIALS_PERMISSION);
1116                             break;
1117                         default:
1118                             sm.checkPermission(AuthPermissionHolder.MODIFY_PRIVATE_CREDENTIALS_PERMISSION);
1119                             break;
1120                         }
1121                     }
1122                     i.remove();
1123                 }
1124             };
1125         }
1126 
1127         public boolean add(E o) {
1128 
1129             Objects.requireNonNull(o,
1130                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1131 
1132             if (subject.isReadOnly()) {
1133                 throw new IllegalStateException
1134                         (ResourcesMgr.getString(&quot;Subject.is.read.only&quot;));
1135             }
1136 
1137             java.lang.SecurityManager sm = System.getSecurityManager();
1138             if (sm != null) {
1139                 switch (which) {
1140                 case Subject.PRINCIPAL_SET:
1141                     sm.checkPermission(AuthPermissionHolder.MODIFY_PRINCIPALS_PERMISSION);
1142                     break;
1143                 case Subject.PUB_CREDENTIAL_SET:
1144                     sm.checkPermission(AuthPermissionHolder.MODIFY_PUBLIC_CREDENTIALS_PERMISSION);
1145                     break;
1146                 default:
1147                     sm.checkPermission(AuthPermissionHolder.MODIFY_PRIVATE_CREDENTIALS_PERMISSION);
1148                     break;
1149                 }
1150             }
1151 
1152             switch (which) {
1153             case Subject.PRINCIPAL_SET:
1154                 if (!(o instanceof Principal)) {
1155                     throw new SecurityException(ResourcesMgr.getString
1156                         (&quot;attempting.to.add.an.object.which.is.not.an.instance.of.java.security.Principal.to.a.Subject.s.Principal.Set&quot;));
1157                 }
1158                 break;
1159             default:
1160                 // ok to add Objects of any kind to credential sets
1161                 break;
1162             }
1163 
1164             // check for duplicates
1165             if (!elements.contains(o))
1166                 return elements.add(o);
1167             else {
1168                 return false;
1169         }
1170         }
1171 
1172         public boolean remove(Object o) {
1173 
1174             Objects.requireNonNull(o,
1175                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1176 
1177             final Iterator&lt;E&gt; e = iterator();
1178             while (e.hasNext()) {
1179                 E next;
1180                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1181                     next = e.next();
1182                 } else {
1183                     next = java.security.AccessController.doPrivileged
1184                         (new java.security.PrivilegedAction&lt;E&gt;() {
1185                         public E run() {
1186                             return e.next();
1187                         }
1188                     });
1189                 }
1190 
1191                 if (next.equals(o)) {
1192                     e.remove();
1193                     return true;
1194                 }
1195             }
1196             return false;
1197         }
1198 
1199         public boolean contains(Object o) {
1200 
1201             Objects.requireNonNull(o,
1202                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1203 
1204             final Iterator&lt;E&gt; e = iterator();
1205             while (e.hasNext()) {
1206                 E next;
1207                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1208                     next = e.next();
1209                 } else {
1210 
1211                     // For private credentials:
1212                     // If the caller does not have read permission for
1213                     // for o.getClass(), we throw a SecurityException.
1214                     // Otherwise we check the private cred set to see whether
1215                     // it contains the Object
1216 
1217                     SecurityManager sm = System.getSecurityManager();
1218                     if (sm != null) {
1219                         sm.checkPermission(new PrivateCredentialPermission
1220                                                 (o.getClass().getName(),
1221                                                 subject.getPrincipals()));
1222                     }
1223                     next = java.security.AccessController.doPrivileged
1224                         (new java.security.PrivilegedAction&lt;E&gt;() {
1225                         public E run() {
1226                             return e.next();
1227                         }
1228                     });
1229                 }
1230 
1231                 if (next.equals(o)) {
1232                     return true;
1233                 }
1234             }
1235             return false;
1236         }
1237 
1238         public boolean addAll(Collection&lt;? extends E&gt; c) {
1239             boolean result = false;
1240 
1241             c = collectionNullClean(c);
1242 
1243             for (E item : c) {
1244                 result |= this.add(item);
1245             }
1246 
1247             return result;
1248         }
1249 
1250         public boolean removeAll(Collection&lt;?&gt; c) {
1251             c = collectionNullClean(c);
1252 
1253             boolean modified = false;
1254             final Iterator&lt;E&gt; e = iterator();
1255             while (e.hasNext()) {
1256                 E next;
1257                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1258                     next = e.next();
1259                 } else {
1260                     next = java.security.AccessController.doPrivileged
1261                         (new java.security.PrivilegedAction&lt;E&gt;() {
1262                         public E run() {
1263                             return e.next();
1264                         }
1265                     });
1266                 }
1267 
1268                 Iterator&lt;?&gt; ce = c.iterator();
1269                 while (ce.hasNext()) {
1270                     if (next.equals(ce.next())) {
1271                             e.remove();
1272                             modified = true;
1273                             break;
1274                         }
1275                 }
1276             }
1277             return modified;
1278         }
1279 
1280         public boolean containsAll(Collection&lt;?&gt; c) {
1281             c = collectionNullClean(c);
1282 
1283             for (Object item : c) {
1284                 if (this.contains(item) == false) {
1285                     return false;
1286                 }
1287             }
1288 
1289             return true;
1290         }
1291 
1292         public boolean retainAll(Collection&lt;?&gt; c) {
1293             c = collectionNullClean(c);
1294 
1295             boolean modified = false;
1296             final Iterator&lt;E&gt; e = iterator();
1297             while (e.hasNext()) {
1298                 E next;
1299                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1300                     next = e.next();
1301                 } else {
1302                     next = java.security.AccessController.doPrivileged
1303                         (new java.security.PrivilegedAction&lt;E&gt;() {
1304                         public E run() {
1305                             return e.next();
1306                         }
1307                     });
1308                 }
1309 
1310                 if (c.contains(next) == false) {
1311                     e.remove();
1312                     modified = true;
1313                 }
1314             }
1315 
1316             return modified;
1317         }
1318 
1319         public void clear() {
1320             final Iterator&lt;E&gt; e = iterator();
1321             while (e.hasNext()) {
1322                 E next;
1323                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1324                     next = e.next();
1325                 } else {
1326                     next = java.security.AccessController.doPrivileged
1327                         (new java.security.PrivilegedAction&lt;E&gt;() {
1328                         public E run() {
1329                             return e.next();
1330                         }
1331                     });
1332                 }
1333                 e.remove();
1334             }
1335         }
1336 
1337         public boolean isEmpty() {
1338             return elements.isEmpty();
1339         }
1340 
1341         public Object[] toArray() {
1342             final Iterator&lt;E&gt; e = iterator();
1343             while (e.hasNext()) {
1344                 // The next() method performs a security manager check
1345                 // on each element in the SecureSet.  If we make it all
1346                 // the way through we should be able to simply return
1347                 // element&#39;s toArray results.  Otherwise we&#39;ll let
1348                 // the SecurityException pass up the call stack.
1349                 e.next();
1350             }
1351 
1352             return elements.toArray();
1353         }
1354 
1355         public &lt;T&gt; T[] toArray(T[] a) {
1356             final Iterator&lt;E&gt; e = iterator();
1357             while (e.hasNext()) {
1358                 // The next() method performs a security manager check
1359                 // on each element in the SecureSet.  If we make it all
1360                 // the way through we should be able to simply return
1361                 // element&#39;s toArray results.  Otherwise we&#39;ll let
1362                 // the SecurityException pass up the call stack.
1363                 e.next();
1364             }
1365 
1366             return elements.toArray(a);
1367         }
1368 
1369         public boolean equals(Object o) {
1370             if (o == this) {
1371                 return true;
1372             }
1373 
1374             if (!(o instanceof Set)) {
1375                 return false;
1376             }
1377 
1378             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
1379             if (c.size() != size()) {
1380                 return false;
1381             }
1382 
1383             try {
1384                 return containsAll(c);
1385             } catch (ClassCastException unused)   {
1386                 return false;
1387             } catch (NullPointerException unused) {
1388                 return false;
1389             }
1390         }
1391 
1392         public int hashCode() {
1393             int h = 0;
1394             Iterator&lt;E&gt; i = iterator();
1395             while (i.hasNext()) {
1396                 E obj = i.next();
1397                 if (obj != null) {
1398                     h += obj.hashCode();
1399                 }
1400             }
1401             return h;
1402         }
1403 
1404         /**
1405          * Writes this object out to a stream (i.e., serializes it).
1406          *
1407          * @serialData If this is a private credential set,
1408          *      a security check is performed to ensure that
1409          *      the caller has permission to access each credential
1410          *      in the set.  If the security check passes,
1411          *      the set is serialized.
1412          */
1413         @java.io.Serial
1414         private void writeObject(java.io.ObjectOutputStream oos)
1415                 throws java.io.IOException {
1416 
1417             if (which == Subject.PRIV_CREDENTIAL_SET) {
1418                 // check permissions before serializing
1419                 Iterator&lt;E&gt; i = iterator();
1420                 while (i.hasNext()) {
1421                     i.next();
1422                 }
1423             }
1424             ObjectOutputStream.PutField fields = oos.putFields();
1425             fields.put(&quot;this$0&quot;, subject);
1426             fields.put(&quot;elements&quot;, elements);
1427             fields.put(&quot;which&quot;, which);
1428             oos.writeFields();
1429         }
1430 
1431         @SuppressWarnings(&quot;unchecked&quot;)
1432         @java.io.Serial
1433         private void readObject(ObjectInputStream ois)
1434             throws IOException, ClassNotFoundException
1435         {
1436             ObjectInputStream.GetField fields = ois.readFields();
1437             subject = (Subject) fields.get(&quot;this$0&quot;, null);
1438             which = fields.get(&quot;which&quot;, 0);
1439 
1440             LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);
1441 
1442             elements = Subject.collectionNullClean(tmp);
1443         }
1444 
1445     }
1446 
1447     /**
1448      * This class implements a {@code Set} which returns only
1449      * members that are an instance of a specified Class.
1450      */
1451     private class ClassSet&lt;T&gt; extends AbstractSet&lt;T&gt; {
1452 
1453         private int which;
1454         private Class&lt;T&gt; c;
1455         private Set&lt;T&gt; set;
1456 
1457         ClassSet(int which, Class&lt;T&gt; c) {
1458             this.which = which;
1459             this.c = c;
1460             set = new HashSet&lt;T&gt;();
1461 
1462             switch (which) {
1463             case Subject.PRINCIPAL_SET:
1464                 synchronized(principals) { populateSet(); }
1465                 break;
1466             case Subject.PUB_CREDENTIAL_SET:
1467                 synchronized(pubCredentials) { populateSet(); }
1468                 break;
1469             default:
1470                 synchronized(privCredentials) { populateSet(); }
1471                 break;
1472             }
1473         }
1474 
1475         @SuppressWarnings(&quot;unchecked&quot;)     /*To suppress warning from line 1374*/
1476         private void populateSet() {
1477             final Iterator&lt;?&gt; iterator;
1478             switch(which) {
1479             case Subject.PRINCIPAL_SET:
1480                 iterator = Subject.this.principals.iterator();
1481                 break;
1482             case Subject.PUB_CREDENTIAL_SET:
1483                 iterator = Subject.this.pubCredentials.iterator();
1484                 break;
1485             default:
1486                 iterator = Subject.this.privCredentials.iterator();
1487                 break;
1488             }
1489 
1490             // Check whether the caller has permisson to get
1491             // credentials of Class c
1492 
1493             while (iterator.hasNext()) {
1494                 Object next;
1495                 if (which == Subject.PRIV_CREDENTIAL_SET) {
1496                     next = java.security.AccessController.doPrivileged
1497                         (new java.security.PrivilegedAction&lt;&gt;() {
1498                         public Object run() {
1499                             return iterator.next();
1500                         }
1501                     });
1502                 } else {
1503                     next = iterator.next();
1504                 }
1505                 if (c.isAssignableFrom(next.getClass())) {
1506                     if (which != Subject.PRIV_CREDENTIAL_SET) {
1507                         set.add((T)next);
1508                     } else {
1509                         // Check permission for private creds
1510                         SecurityManager sm = System.getSecurityManager();
1511                         if (sm != null) {
1512                             sm.checkPermission(new PrivateCredentialPermission
1513                                                 (next.getClass().getName(),
1514                                                 Subject.this.getPrincipals()));
1515                         }
1516                         set.add((T)next);
1517                     }
1518                 }
1519             }
1520         }
1521 
1522         @Override
1523         public int size() {
1524             return set.size();
1525         }
1526 
1527         @Override
1528         public Iterator&lt;T&gt; iterator() {
1529             return set.iterator();
1530         }
1531 
1532         @Override
1533         public boolean add(T o) {
1534 
1535             if (!c.isAssignableFrom(o.getClass())) {
1536                 MessageFormat form = new MessageFormat(ResourcesMgr.getString
1537                         (&quot;attempting.to.add.an.object.which.is.not.an.instance.of.class&quot;));
1538                 Object[] source = {c.toString()};
1539                 throw new SecurityException(form.format(source));
1540             }
1541 
1542             return set.add(o);
1543         }
1544     }
1545 
1546     static final class AuthPermissionHolder {
1547         static final AuthPermission DO_AS_PERMISSION =
1548             new AuthPermission(&quot;doAs&quot;);
1549 
1550         static final AuthPermission DO_AS_PRIVILEGED_PERMISSION =
1551             new AuthPermission(&quot;doAsPrivileged&quot;);
1552 
1553         static final AuthPermission SET_READ_ONLY_PERMISSION =
1554             new AuthPermission(&quot;setReadOnly&quot;);
1555 
1556         static final AuthPermission GET_SUBJECT_PERMISSION =
1557             new AuthPermission(&quot;getSubject&quot;);
1558 
1559         static final AuthPermission MODIFY_PRINCIPALS_PERMISSION =
1560             new AuthPermission(&quot;modifyPrincipals&quot;);
1561 
1562         static final AuthPermission MODIFY_PUBLIC_CREDENTIALS_PERMISSION =
1563             new AuthPermission(&quot;modifyPublicCredentials&quot;);
1564 
1565         static final AuthPermission MODIFY_PRIVATE_CREDENTIALS_PERMISSION =
1566             new AuthPermission(&quot;modifyPrivateCredentials&quot;);
1567     }
1568 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/javax/security/auth/Subject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.security.auth;
  27 
  28 import java.util.*;
  29 import java.io.*;
  30 import java.lang.reflect.*;
  31 import java.text.MessageFormat;
  32 import java.security.AccessController;
  33 import java.security.AccessControlContext;
  34 import java.security.DomainCombiner;
  35 import java.security.Permission;
  36 import java.security.PermissionCollection;
  37 import java.security.Principal;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedExceptionAction;
  40 import java.security.PrivilegedActionException;
  41 import java.security.ProtectionDomain;
  42 import sun.security.util.ResourcesMgr;
  43 
  44 /**
  45  * &lt;p&gt; A {@code Subject} represents a grouping of related information
  46  * for a single entity, such as a person.
  47  * Such information includes the Subject&#39;s identities as well as
  48  * its security-related attributes
  49  * (passwords and cryptographic keys, for example).
  50  *
  51  * &lt;p&gt; Subjects may potentially have multiple identities.
  52  * Each identity is represented as a {@code Principal}
  53  * within the {@code Subject}.  Principals simply bind names to a
  54  * {@code Subject}.  For example, a {@code Subject} that happens
  55  * to be a person, Alice, might have two Principals:
  56  * one which binds &quot;Alice Bar&quot;, the name on her driver license,
  57  * to the {@code Subject}, and another which binds,
  58  * &quot;999-99-9999&quot;, the number on her student identification card,
  59  * to the {@code Subject}.  Both Principals refer to the same
  60  * {@code Subject} even though each has a different name.
  61  *
  62  * &lt;p&gt; A {@code Subject} may also own security-related attributes,
  63  * which are referred to as credentials.
  64  * Sensitive credentials that require special protection, such as
  65  * private cryptographic keys, are stored within a private credential
  66  * {@code Set}.  Credentials intended to be shared, such as
  67  * public key certificates or Kerberos server tickets are stored
  68  * within a public credential {@code Set}.  Different permissions
  69  * are required to access and modify the different credential Sets.
  70  *
  71  * &lt;p&gt; To retrieve all the Principals associated with a {@code Subject},
  72  * invoke the {@code getPrincipals} method.  To retrieve
  73  * all the public or private credentials belonging to a {@code Subject},
  74  * invoke the {@code getPublicCredentials} method or
  75  * {@code getPrivateCredentials} method, respectively.
  76  * To modify the returned {@code Set} of Principals and credentials,
  77  * use the methods defined in the {@code Set} class.
  78  * For example:
  79  * &lt;pre&gt;
  80  *      Subject subject;
  81  *      Principal principal;
  82  *      Object credential;
  83  *
  84  *      // add a Principal and credential to the Subject
  85  *      subject.getPrincipals().add(principal);
  86  *      subject.getPublicCredentials().add(credential);
  87  * &lt;/pre&gt;
  88  *
  89  * &lt;p&gt; This {@code Subject} class implements {@code Serializable}.
  90  * While the Principals associated with the {@code Subject} are serialized,
  91  * the credentials associated with the {@code Subject} are not.
  92  * Note that the {@code java.security.Principal} class
  93  * does not implement {@code Serializable}.  Therefore all concrete
  94  * {@code Principal} implementations associated with Subjects
  95  * must implement {@code Serializable}.
  96  *
  97  * @since 1.4
  98  * @see java.security.Principal
  99  * @see java.security.DomainCombiner
 100  */
 101 public final class Subject implements java.io.Serializable {
 102 
 103     @java.io.Serial
 104     private static final long serialVersionUID = -8308522755600156056L;
 105 
 106     /**
 107      * A {@code Set} that provides a view of all of this
 108      * Subject&#39;s Principals
 109      *
 110      * @serial Each element in this set is a
 111      *          {@code java.security.Principal}.
 112      *          The set is a {@code Subject.SecureSet}.
 113      */
 114     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 115     Set&lt;Principal&gt; principals;
 116 
 117     /**
 118      * Sets that provide a view of all of this
 119      * Subject&#39;s Credentials
 120      */
 121     transient Set&lt;Object&gt; pubCredentials;
 122     transient Set&lt;Object&gt; privCredentials;
 123 
 124     /**
 125      * Whether this Subject is read-only
 126      *
 127      * @serial
 128      */
 129     private volatile boolean readOnly = false;
 130 
 131     private static final int PRINCIPAL_SET = 1;
 132     private static final int PUB_CREDENTIAL_SET = 2;
 133     private static final int PRIV_CREDENTIAL_SET = 3;
 134 
 135     private static final ProtectionDomain[] NULL_PD_ARRAY
 136         = new ProtectionDomain[0];
 137 
 138     /**
 139      * Create an instance of a {@code Subject}
 140      * with an empty {@code Set} of Principals and empty
 141      * Sets of public and private credentials.
 142      *
 143      * &lt;p&gt; The newly constructed Sets check whether this {@code Subject}
 144      * has been set read-only before permitting subsequent modifications.
 145      * The newly created Sets also prevent illegal modifications
 146      * by ensuring that callers have sufficient permissions.  These Sets
 147      * also prohibit null elements, and attempts to add or query a null
 148      * element will result in a {@code NullPointerException}.
 149      *
 150      * &lt;p&gt; To modify the Principals Set, the caller must have
 151      * {@code AuthPermission(&quot;modifyPrincipals&quot;)}.
 152      * To modify the public credential Set, the caller must have
 153      * {@code AuthPermission(&quot;modifyPublicCredentials&quot;)}.
 154      * To modify the private credential Set, the caller must have
 155      * {@code AuthPermission(&quot;modifyPrivateCredentials&quot;)}.
 156      */
 157     public Subject() {
 158 
 159         this.principals = Collections.synchronizedSet
 160                         (new SecureSet&lt;&gt;(this, PRINCIPAL_SET));
 161         this.pubCredentials = Collections.synchronizedSet
 162                         (new SecureSet&lt;&gt;(this, PUB_CREDENTIAL_SET));
 163         this.privCredentials = Collections.synchronizedSet
 164                         (new SecureSet&lt;&gt;(this, PRIV_CREDENTIAL_SET));
 165     }
 166 
 167     /**
 168      * Create an instance of a {@code Subject} with
 169      * Principals and credentials.
 170      *
 171      * &lt;p&gt; The Principals and credentials from the specified Sets
 172      * are copied into newly constructed Sets.
 173      * These newly created Sets check whether this {@code Subject}
 174      * has been set read-only before permitting subsequent modifications.
 175      * The newly created Sets also prevent illegal modifications
 176      * by ensuring that callers have sufficient permissions.  These Sets
 177      * also prohibit null elements, and attempts to add or query a null
 178      * element will result in a {@code NullPointerException}.
 179      *
 180      * &lt;p&gt; To modify the Principals Set, the caller must have
 181      * {@code AuthPermission(&quot;modifyPrincipals&quot;)}.
 182      * To modify the public credential Set, the caller must have
 183      * {@code AuthPermission(&quot;modifyPublicCredentials&quot;)}.
 184      * To modify the private credential Set, the caller must have
 185      * {@code AuthPermission(&quot;modifyPrivateCredentials&quot;)}.
 186      *
 187      * @param readOnly true if the {@code Subject} is to be read-only,
 188      *          and false otherwise.
 189      *
 190      * @param principals the {@code Set} of Principals
 191      *          to be associated with this {@code Subject}.
 192      *
 193      * @param pubCredentials the {@code Set} of public credentials
 194      *          to be associated with this {@code Subject}.
 195      *
 196      * @param privCredentials the {@code Set} of private credentials
 197      *          to be associated with this {@code Subject}.
 198      *
 199      * @throws NullPointerException if the specified
 200      *          {@code principals}, {@code pubCredentials},
 201      *          or {@code privCredentials} are {@code null},
 202      *          or a null value exists within any of these three
 203      *          Sets.
 204      */
 205     public Subject(boolean readOnly, Set&lt;? extends Principal&gt; principals,
 206                    Set&lt;?&gt; pubCredentials, Set&lt;?&gt; privCredentials)
 207     {
<a name="2" id="anc2"></a><span class="line-modified"> 208         collectionNullClean(principals);</span>
<span class="line-modified"> 209         collectionNullClean(pubCredentials);</span>
<span class="line-modified"> 210         collectionNullClean(privCredentials);</span>



 211 
 212         this.principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 213                                 (this, PRINCIPAL_SET, principals));</span>
 214         this.pubCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 215                                 (this, PUB_CREDENTIAL_SET, pubCredentials));</span>
 216         this.privCredentials = Collections.synchronizedSet(new SecureSet&lt;&gt;
<a name="5" id="anc5"></a><span class="line-modified"> 217                                 (this, PRIV_CREDENTIAL_SET, privCredentials));</span>
 218         this.readOnly = readOnly;
 219     }
 220 
 221     /**
 222      * Set this {@code Subject} to be read-only.
 223      *
 224      * &lt;p&gt; Modifications (additions and removals) to this Subject&#39;s
 225      * {@code Principal} {@code Set} and
 226      * credential Sets will be disallowed.
 227      * The {@code destroy} operation on this Subject&#39;s credentials will
 228      * still be permitted.
 229      *
 230      * &lt;p&gt; Subsequent attempts to modify the Subject&#39;s {@code Principal}
 231      * and credential Sets will result in an
 232      * {@code IllegalStateException} being thrown.
 233      * Also, once a {@code Subject} is read-only,
 234      * it can not be reset to being writable again.
 235      *
 236      * @throws SecurityException if a security manager is installed and the
 237      *         caller does not have an
 238      *         {@link AuthPermission#AuthPermission(String)
 239      *         AuthPermission(&quot;setReadOnly&quot;)} permission to set this
 240      *         {@code Subject} to be read-only.
 241      */
 242     public void setReadOnly() {
 243         java.lang.SecurityManager sm = System.getSecurityManager();
 244         if (sm != null) {
 245             sm.checkPermission(AuthPermissionHolder.SET_READ_ONLY_PERMISSION);
 246         }
 247 
 248         this.readOnly = true;
 249     }
 250 
 251     /**
 252      * Query whether this {@code Subject} is read-only.
 253      *
 254      * @return true if this {@code Subject} is read-only, false otherwise.
 255      */
 256     public boolean isReadOnly() {
 257         return this.readOnly;
 258     }
 259 
 260     /**
 261      * Get the {@code Subject} associated with the provided
 262      * {@code AccessControlContext}.
 263      *
 264      * &lt;p&gt; The {@code AccessControlContext} may contain many
 265      * Subjects (from nested {@code doAs} calls).
 266      * In this situation, the most recent {@code Subject} associated
 267      * with the {@code AccessControlContext} is returned.
 268      *
 269      * @param  acc the {@code AccessControlContext} from which to retrieve
 270      *          the {@code Subject}.
 271      *
 272      * @return  the {@code Subject} associated with the provided
 273      *          {@code AccessControlContext}, or {@code null}
 274      *          if no {@code Subject} is associated
 275      *          with the provided {@code AccessControlContext}.
 276      *
 277      * @throws SecurityException if a security manager is installed and the
 278      *          caller does not have an
 279      *          {@link AuthPermission#AuthPermission(String)
 280      *          AuthPermission(&quot;getSubject&quot;)} permission to get the
 281      *          {@code Subject}.
 282      *
 283      * @throws NullPointerException if the provided
 284      *          {@code AccessControlContext} is {@code null}.
 285      */
 286     public static Subject getSubject(final AccessControlContext acc) {
 287 
 288         java.lang.SecurityManager sm = System.getSecurityManager();
 289         if (sm != null) {
 290             sm.checkPermission(AuthPermissionHolder.GET_SUBJECT_PERMISSION);
 291         }
 292 
 293         Objects.requireNonNull(acc, ResourcesMgr.getString
 294                 (&quot;invalid.null.AccessControlContext.provided&quot;));
 295 
 296         // return the Subject from the DomainCombiner of the provided context
 297         return AccessController.doPrivileged
 298             (new java.security.PrivilegedAction&lt;&gt;() {
 299             public Subject run() {
 300                 DomainCombiner dc = acc.getDomainCombiner();
 301                 if (!(dc instanceof SubjectDomainCombiner)) {
 302                     return null;
 303                 }
 304                 SubjectDomainCombiner sdc = (SubjectDomainCombiner)dc;
 305                 return sdc.getSubject();
 306             }
 307         });
 308     }
 309 
 310     /**
 311      * Perform work as a particular {@code Subject}.
 312      *
 313      * &lt;p&gt; This method first retrieves the current Thread&#39;s
 314      * {@code AccessControlContext} via
 315      * {@code AccessController.getContext},
 316      * and then instantiates a new {@code AccessControlContext}
 317      * using the retrieved context along with a new
 318      * {@code SubjectDomainCombiner} (constructed using
 319      * the provided {@code Subject}).
 320      * Finally, this method invokes {@code AccessController.doPrivileged},
 321      * passing it the provided {@code PrivilegedAction},
 322      * as well as the newly constructed {@code AccessControlContext}.
 323      *
 324      * @param subject the {@code Subject} that the specified
 325      *                  {@code action} will run as.  This parameter
 326      *                  may be {@code null}.
 327      *
 328      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 329      *                  {@code run} method.
 330      *
 331      * @param action the code to be run as the specified
 332      *                  {@code Subject}.
 333      *
 334      * @return the value returned by the PrivilegedAction&#39;s
 335      *                  {@code run} method.
 336      *
 337      * @throws NullPointerException if the {@code PrivilegedAction}
 338      *                  is {@code null}.
 339      *
 340      * @throws SecurityException if a security manager is installed and the
 341      *                  caller does not have an
 342      *                  {@link AuthPermission#AuthPermission(String)
 343      *                  AuthPermission(&quot;doAs&quot;)} permission to invoke this
 344      *                  method.
 345      */
 346     public static &lt;T&gt; T doAs(final Subject subject,
 347                         final java.security.PrivilegedAction&lt;T&gt; action) {
 348 
 349         java.lang.SecurityManager sm = System.getSecurityManager();
 350         if (sm != null) {
 351             sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);
 352         }
 353 
 354         Objects.requireNonNull(action,
 355                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 356 
 357         // set up the new Subject-based AccessControlContext
 358         // for doPrivileged
 359         final AccessControlContext currentAcc = AccessController.getContext();
 360 
 361         // call doPrivileged and push this new context on the stack
 362         return java.security.AccessController.doPrivileged
 363                                         (action,
 364                                         createContext(subject, currentAcc));
 365     }
 366 
 367     /**
 368      * Perform work as a particular {@code Subject}.
 369      *
 370      * &lt;p&gt; This method first retrieves the current Thread&#39;s
 371      * {@code AccessControlContext} via
 372      * {@code AccessController.getContext},
 373      * and then instantiates a new {@code AccessControlContext}
 374      * using the retrieved context along with a new
 375      * {@code SubjectDomainCombiner} (constructed using
 376      * the provided {@code Subject}).
 377      * Finally, this method invokes {@code AccessController.doPrivileged},
 378      * passing it the provided {@code PrivilegedExceptionAction},
 379      * as well as the newly constructed {@code AccessControlContext}.
 380      *
 381      * @param subject the {@code Subject} that the specified
 382      *                  {@code action} will run as.  This parameter
 383      *                  may be {@code null}.
 384      *
 385      * @param &lt;T&gt; the type of the value returned by the
 386      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 387      *
 388      * @param action the code to be run as the specified
 389      *                  {@code Subject}.
 390      *
 391      * @return the value returned by the
 392      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 393      *
 394      * @throws PrivilegedActionException if the
 395      *                  {@code PrivilegedExceptionAction.run}
 396      *                  method throws a checked exception.
 397      *
 398      * @throws NullPointerException if the specified
 399      *                  {@code PrivilegedExceptionAction} is
 400      *                  {@code null}.
 401      *
 402      * @throws SecurityException if a security manager is installed and the
 403      *                  caller does not have an
 404      *                  {@link AuthPermission#AuthPermission(String)
 405      *                  AuthPermission(&quot;doAs&quot;)} permission to invoke this
 406      *                  method.
 407      */
 408     public static &lt;T&gt; T doAs(final Subject subject,
 409                         final java.security.PrivilegedExceptionAction&lt;T&gt; action)
 410                         throws java.security.PrivilegedActionException {
 411 
 412         java.lang.SecurityManager sm = System.getSecurityManager();
 413         if (sm != null) {
 414             sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);
 415         }
 416 
 417         Objects.requireNonNull(action,
 418                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 419 
 420         // set up the new Subject-based AccessControlContext for doPrivileged
 421         final AccessControlContext currentAcc = AccessController.getContext();
 422 
 423         // call doPrivileged and push this new context on the stack
 424         return java.security.AccessController.doPrivileged
 425                                         (action,
 426                                         createContext(subject, currentAcc));
 427     }
 428 
 429     /**
 430      * Perform privileged work as a particular {@code Subject}.
 431      *
 432      * &lt;p&gt; This method behaves exactly as {@code Subject.doAs},
 433      * except that instead of retrieving the current Thread&#39;s
 434      * {@code AccessControlContext}, it uses the provided
 435      * {@code AccessControlContext}.  If the provided
 436      * {@code AccessControlContext} is {@code null},
 437      * this method instantiates a new {@code AccessControlContext}
 438      * with an empty collection of ProtectionDomains.
 439      *
 440      * @param subject the {@code Subject} that the specified
 441      *                  {@code action} will run as.  This parameter
 442      *                  may be {@code null}.
 443      *
 444      * @param &lt;T&gt; the type of the value returned by the PrivilegedAction&#39;s
 445      *                  {@code run} method.
 446      *
 447      * @param action the code to be run as the specified
 448      *                  {@code Subject}.
 449      *
 450      * @param acc the {@code AccessControlContext} to be tied to the
 451      *                  specified &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;action&lt;/i&gt;.
 452      *
 453      * @return the value returned by the PrivilegedAction&#39;s
 454      *                  {@code run} method.
 455      *
 456      * @throws NullPointerException if the {@code PrivilegedAction}
 457      *                  is {@code null}.
 458      *
 459      * @throws SecurityException if a security manager is installed and the
 460      *                  caller does not have a
 461      *                  {@link AuthPermission#AuthPermission(String)
 462      *                  AuthPermission(&quot;doAsPrivileged&quot;)} permission to invoke
 463      *                  this method.
 464      */
 465     public static &lt;T&gt; T doAsPrivileged(final Subject subject,
 466                         final java.security.PrivilegedAction&lt;T&gt; action,
 467                         final java.security.AccessControlContext acc) {
 468 
 469         java.lang.SecurityManager sm = System.getSecurityManager();
 470         if (sm != null) {
 471             sm.checkPermission(AuthPermissionHolder.DO_AS_PRIVILEGED_PERMISSION);
 472         }
 473 
 474         Objects.requireNonNull(action,
 475                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 476 
 477         // set up the new Subject-based AccessControlContext
 478         // for doPrivileged
 479         final AccessControlContext callerAcc =
 480                 (acc == null ?
 481                 new AccessControlContext(NULL_PD_ARRAY) :
 482                 acc);
 483 
 484         // call doPrivileged and push this new context on the stack
 485         return java.security.AccessController.doPrivileged
 486                                         (action,
 487                                         createContext(subject, callerAcc));
 488     }
 489 
 490     /**
 491      * Perform privileged work as a particular {@code Subject}.
 492      *
 493      * &lt;p&gt; This method behaves exactly as {@code Subject.doAs},
 494      * except that instead of retrieving the current Thread&#39;s
 495      * {@code AccessControlContext}, it uses the provided
 496      * {@code AccessControlContext}.  If the provided
 497      * {@code AccessControlContext} is {@code null},
 498      * this method instantiates a new {@code AccessControlContext}
 499      * with an empty collection of ProtectionDomains.
 500      *
 501      * @param subject the {@code Subject} that the specified
 502      *                  {@code action} will run as.  This parameter
 503      *                  may be {@code null}.
 504      *
 505      * @param &lt;T&gt; the type of the value returned by the
 506      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 507      *
 508      * @param action the code to be run as the specified
 509      *                  {@code Subject}.
 510      *
 511      * @param acc the {@code AccessControlContext} to be tied to the
 512      *                  specified &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;action&lt;/i&gt;.
 513      *
 514      * @return the value returned by the
 515      *                  PrivilegedExceptionAction&#39;s {@code run} method.
 516      *
 517      * @throws PrivilegedActionException if the
 518      *                  {@code PrivilegedExceptionAction.run}
 519      *                  method throws a checked exception.
 520      *
 521      * @throws NullPointerException if the specified
 522      *                  {@code PrivilegedExceptionAction} is
 523      *                  {@code null}.
 524      *
 525      * @throws SecurityException if a security manager is installed and the
 526      *                  caller does not have a
 527      *                  {@link AuthPermission#AuthPermission(String)
 528      *                  AuthPermission(&quot;doAsPrivileged&quot;)} permission to invoke
 529      *                  this method.
 530      */
 531     public static &lt;T&gt; T doAsPrivileged(final Subject subject,
 532                         final java.security.PrivilegedExceptionAction&lt;T&gt; action,
 533                         final java.security.AccessControlContext acc)
 534                         throws java.security.PrivilegedActionException {
 535 
 536         java.lang.SecurityManager sm = System.getSecurityManager();
 537         if (sm != null) {
 538             sm.checkPermission(AuthPermissionHolder.DO_AS_PRIVILEGED_PERMISSION);
 539         }
 540 
 541         Objects.requireNonNull(action,
 542                 ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));
 543 
 544         // set up the new Subject-based AccessControlContext for doPrivileged
 545         final AccessControlContext callerAcc =
 546                 (acc == null ?
 547                 new AccessControlContext(NULL_PD_ARRAY) :
 548                 acc);
 549 
 550         // call doPrivileged and push this new context on the stack
 551         return java.security.AccessController.doPrivileged
 552                                         (action,
 553                                         createContext(subject, callerAcc));
 554     }
 555 
 556     private static AccessControlContext createContext(final Subject subject,
 557                                         final AccessControlContext acc) {
 558 
 559 
 560         return java.security.AccessController.doPrivileged
 561             (new java.security.PrivilegedAction&lt;&gt;() {
 562             public AccessControlContext run() {
 563                 if (subject == null) {
 564                     return new AccessControlContext(acc, null);
 565                 } else {
 566                     return new AccessControlContext
 567                                         (acc,
 568                                         new SubjectDomainCombiner(subject));
 569             }
 570             }
 571         });
 572     }
 573 
 574     /**
 575      * Return the {@code Set} of Principals associated with this
 576      * {@code Subject}.  Each {@code Principal} represents
 577      * an identity for this {@code Subject}.
 578      *
 579      * &lt;p&gt; The returned {@code Set} is backed by this Subject&#39;s
 580      * internal {@code Principal} {@code Set}.  Any modification
 581      * to the returned {@code Set} affects the internal
 582      * {@code Principal} {@code Set} as well.
 583      *
 584      * &lt;p&gt; If a security manager is installed, the caller must have a
 585      * {@link AuthPermission#AuthPermission(String)
 586      * AuthPermission(&quot;modifyPrincipals&quot;)} permission to modify
 587      * the returned set, or a {@code SecurityException} will be thrown.
 588      *
 589      * @return  the {@code Set} of Principals associated with this
 590      *          {@code Subject}.
 591      */
 592     public Set&lt;Principal&gt; getPrincipals() {
 593 
 594         // always return an empty Set instead of null
 595         // so LoginModules can add to the Set if necessary
 596         return principals;
 597     }
 598 
 599     /**
 600      * Return a {@code Set} of Principals associated with this
 601      * {@code Subject} that are instances or subclasses of the specified
 602      * {@code Class}.
 603      *
 604      * &lt;p&gt; The returned {@code Set} is not backed by this Subject&#39;s
 605      * internal {@code Principal} {@code Set}.  A new
 606      * {@code Set} is created and returned for each method invocation.
 607      * Modifications to the returned {@code Set}
 608      * will not affect the internal {@code Principal} {@code Set}.
 609      *
 610      * @param &lt;T&gt; the type of the class modeled by {@code c}
 611      *
 612      * @param c the returned {@code Set} of Principals will all be
 613      *          instances of this class.
 614      *
 615      * @return a {@code Set} of Principals that are instances of the
 616      *          specified {@code Class}.
 617      *
 618      * @throws NullPointerException if the specified {@code Class}
 619      *          is {@code null}.
 620      */
 621     public &lt;T extends Principal&gt; Set&lt;T&gt; getPrincipals(Class&lt;T&gt; c) {
 622 
 623         Objects.requireNonNull(c,
 624                 ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));
 625 
 626         // always return an empty Set instead of null
 627         // so LoginModules can add to the Set if necessary
 628         return new ClassSet&lt;T&gt;(PRINCIPAL_SET, c);
 629     }
 630 
 631     /**
 632      * Return the {@code Set} of public credentials held by this
 633      * {@code Subject}.
 634      *
 635      * &lt;p&gt; The returned {@code Set} is backed by this Subject&#39;s
 636      * internal public Credential {@code Set}.  Any modification
 637      * to the returned {@code Set} affects the internal public
 638      * Credential {@code Set} as well.
 639      *
 640      * &lt;p&gt; If a security manager is installed, the caller must have a
 641      * {@link AuthPermission#AuthPermission(String)
 642      * AuthPermission(&quot;modifyPublicCredentials&quot;)} permission to modify
 643      * the returned set, or a {@code SecurityException} will be thrown.
 644      *
 645      * @return  a {@code Set} of public credentials held by this
 646      *          {@code Subject}.
 647      */
 648     public Set&lt;Object&gt; getPublicCredentials() {
 649 
 650         // always return an empty Set instead of null
 651         // so LoginModules can add to the Set if necessary
 652         return pubCredentials;
 653     }
 654 
 655     /**
 656      * Return the {@code Set} of private credentials held by this
 657      * {@code Subject}.
 658      *
 659      * &lt;p&gt; The returned {@code Set} is backed by this Subject&#39;s
 660      * internal private Credential {@code Set}.  Any modification
 661      * to the returned {@code Set} affects the internal private
 662      * Credential {@code Set} as well.
 663      *
 664      * &lt;p&gt; If a security manager is installed, the caller must have a
 665      * {@link AuthPermission#AuthPermission(String)
 666      * AuthPermission(&quot;modifyPrivateCredentials&quot;)} permission to modify
 667      * the returned set, or a {@code SecurityException} will be thrown.
 668      *
 669      * &lt;p&gt; While iterating through the {@code Set},
 670      * a {@code SecurityException} is thrown if a security manager is installed
 671      * and the caller does not have a {@link PrivateCredentialPermission}
 672      * to access a particular Credential.  The {@code Iterator}
 673      * is nevertheless advanced to the next element in the {@code Set}.
 674      *
 675      * @return  a {@code Set} of private credentials held by this
 676      *          {@code Subject}.
 677      */
 678     public Set&lt;Object&gt; getPrivateCredentials() {
 679 
 680         // XXX
 681         // we do not need a security check for
 682         // AuthPermission(getPrivateCredentials)
 683         // because we already restrict access to private credentials
 684         // via the PrivateCredentialPermission.  all the extra AuthPermission
 685         // would do is protect the set operations themselves
 686         // (like size()), which don&#39;t seem security-sensitive.
 687 
 688         // always return an empty Set instead of null
 689         // so LoginModules can add to the Set if necessary
 690         return privCredentials;
 691     }
 692 
 693     /**
 694      * Return a {@code Set} of public credentials associated with this
 695      * {@code Subject} that are instances or subclasses of the specified
 696      * {@code Class}.
 697      *
 698      * &lt;p&gt; The returned {@code Set} is not backed by this Subject&#39;s
 699      * internal public Credential {@code Set}.  A new
 700      * {@code Set} is created and returned for each method invocation.
 701      * Modifications to the returned {@code Set}
 702      * will not affect the internal public Credential {@code Set}.
 703      *
 704      * @param &lt;T&gt; the type of the class modeled by {@code c}
 705      *
 706      * @param c the returned {@code Set} of public credentials will all be
 707      *          instances of this class.
 708      *
 709      * @return a {@code Set} of public credentials that are instances
 710      *          of the  specified {@code Class}.
 711      *
 712      * @throws NullPointerException if the specified {@code Class}
 713      *          is {@code null}.
 714      */
 715     public &lt;T&gt; Set&lt;T&gt; getPublicCredentials(Class&lt;T&gt; c) {
 716 
 717         Objects.requireNonNull(c,
 718                 ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));
 719 
 720         // always return an empty Set instead of null
 721         // so LoginModules can add to the Set if necessary
 722         return new ClassSet&lt;T&gt;(PUB_CREDENTIAL_SET, c);
 723     }
 724 
 725     /**
 726      * Return a {@code Set} of private credentials associated with this
 727      * {@code Subject} that are instances or subclasses of the specified
 728      * {@code Class}.
 729      *
 730      * &lt;p&gt; If a security manager is installed, the caller must have a
 731      * {@link PrivateCredentialPermission} to access all of the requested
 732      * Credentials, or a {@code SecurityException} will be thrown.
 733      *
 734      * &lt;p&gt; The returned {@code Set} is not backed by this Subject&#39;s
 735      * internal private Credential {@code Set}.  A new
 736      * {@code Set} is created and returned for each method invocation.
 737      * Modifications to the returned {@code Set}
 738      * will not affect the internal private Credential {@code Set}.
 739      *
 740      * @param &lt;T&gt; the type of the class modeled by {@code c}
 741      *
 742      * @param c the returned {@code Set} of private credentials will all be
 743      *          instances of this class.
 744      *
 745      * @return a {@code Set} of private credentials that are instances
 746      *          of the  specified {@code Class}.
 747      *
 748      * @throws NullPointerException if the specified {@code Class}
 749      *          is {@code null}.
 750      */
 751     public &lt;T&gt; Set&lt;T&gt; getPrivateCredentials(Class&lt;T&gt; c) {
 752 
 753         // XXX
 754         // we do not need a security check for
 755         // AuthPermission(getPrivateCredentials)
 756         // because we already restrict access to private credentials
 757         // via the PrivateCredentialPermission.  all the extra AuthPermission
 758         // would do is protect the set operations themselves
 759         // (like size()), which don&#39;t seem security-sensitive.
 760 
 761         Objects.requireNonNull(c,
 762                 ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));
 763 
 764         // always return an empty Set instead of null
 765         // so LoginModules can add to the Set if necessary
 766         return new ClassSet&lt;T&gt;(PRIV_CREDENTIAL_SET, c);
 767     }
 768 
 769     /**
 770      * Compares the specified Object with this {@code Subject}
 771      * for equality.  Returns true if the given object is also a Subject
 772      * and the two {@code Subject} instances are equivalent.
 773      * More formally, two {@code Subject} instances are
 774      * equal if their {@code Principal} and {@code Credential}
 775      * Sets are equal.
 776      *
 777      * @param o Object to be compared for equality with this
 778      *          {@code Subject}.
 779      *
 780      * @return true if the specified Object is equal to this
 781      *          {@code Subject}.
 782      *
 783      * @throws SecurityException if a security manager is installed and the
 784      *         caller does not have a {@link PrivateCredentialPermission}
 785      *         permission to access the private credentials for this
 786      *         {@code Subject} or the provided {@code Subject}.
 787      */
 788     @Override
 789     public boolean equals(Object o) {
 790 
 791         if (o == null) {
 792             return false;
 793         }
 794 
 795         if (this == o) {
 796             return true;
 797         }
 798 
 799         if (o instanceof Subject) {
 800 
 801             final Subject that = (Subject)o;
 802 
 803             // check the principal and credential sets
 804             Set&lt;Principal&gt; thatPrincipals;
 805             synchronized(that.principals) {
 806                 // avoid deadlock from dual locks
 807                 thatPrincipals = new HashSet&lt;&gt;(that.principals);
 808             }
 809             if (!principals.equals(thatPrincipals)) {
 810                 return false;
 811             }
 812 
 813             Set&lt;Object&gt; thatPubCredentials;
 814             synchronized(that.pubCredentials) {
 815                 // avoid deadlock from dual locks
 816                 thatPubCredentials = new HashSet&lt;&gt;(that.pubCredentials);
 817             }
 818             if (!pubCredentials.equals(thatPubCredentials)) {
 819                 return false;
 820             }
 821 
 822             Set&lt;Object&gt; thatPrivCredentials;
 823             synchronized(that.privCredentials) {
 824                 // avoid deadlock from dual locks
 825                 thatPrivCredentials = new HashSet&lt;&gt;(that.privCredentials);
 826             }
 827             if (!privCredentials.equals(thatPrivCredentials)) {
 828                 return false;
 829             }
 830             return true;
 831         }
 832         return false;
 833     }
 834 
 835     /**
 836      * Return the String representation of this {@code Subject}.
 837      *
 838      * @return the String representation of this {@code Subject}.
 839      */
 840     @Override
 841     public String toString() {
 842         return toString(true);
 843     }
 844 
 845     /**
 846      * package private convenience method to print out the Subject
 847      * without firing off a security check when trying to access
 848      * the Private Credentials
 849      */
 850     String toString(boolean includePrivateCredentials) {
 851 
 852         String s = ResourcesMgr.getString(&quot;Subject.&quot;);
 853         String suffix = &quot;&quot;;
 854 
 855         synchronized(principals) {
 856             Iterator&lt;Principal&gt; pI = principals.iterator();
 857             while (pI.hasNext()) {
 858                 Principal p = pI.next();
 859                 suffix = suffix + ResourcesMgr.getString(&quot;.Principal.&quot;) +
 860                         p.toString() + ResourcesMgr.getString(&quot;NEWLINE&quot;);
 861             }
 862         }
 863 
 864         synchronized(pubCredentials) {
 865             Iterator&lt;Object&gt; pI = pubCredentials.iterator();
 866             while (pI.hasNext()) {
 867                 Object o = pI.next();
 868                 suffix = suffix +
 869                         ResourcesMgr.getString(&quot;.Public.Credential.&quot;) +
 870                         o.toString() + ResourcesMgr.getString(&quot;NEWLINE&quot;);
 871             }
 872         }
 873 
 874         if (includePrivateCredentials) {
 875             synchronized(privCredentials) {
 876                 Iterator&lt;Object&gt; pI = privCredentials.iterator();
 877                 while (pI.hasNext()) {
 878                     try {
 879                         Object o = pI.next();
 880                         suffix += ResourcesMgr.getString
 881                                         (&quot;.Private.Credential.&quot;) +
 882                                         o.toString() +
 883                                         ResourcesMgr.getString(&quot;NEWLINE&quot;);
 884                     } catch (SecurityException se) {
 885                         suffix += ResourcesMgr.getString
 886                                 (&quot;.Private.Credential.inaccessible.&quot;);
 887                         break;
 888                     }
 889                 }
 890             }
 891         }
 892         return s + suffix;
 893     }
 894 
 895     /**
 896      * Returns a hashcode for this {@code Subject}.
 897      *
 898      * @return a hashcode for this {@code Subject}.
 899      *
 900      * @throws SecurityException if a security manager is installed and the
 901      *         caller does not have a {@link PrivateCredentialPermission}
 902      *         permission to access this Subject&#39;s private credentials.
 903      */
 904     @Override
 905     public int hashCode() {
 906 
 907         /**
 908          * The hashcode is derived exclusive or-ing the
 909          * hashcodes of this Subject&#39;s Principals and credentials.
 910          *
 911          * If a particular credential was destroyed
 912          * ({@code credential.hashCode()} throws an
 913          * {@code IllegalStateException}),
 914          * the hashcode for that credential is derived via:
 915          * {@code credential.getClass().toString().hashCode()}.
 916          */
 917 
 918         int hashCode = 0;
 919 
 920         synchronized(principals) {
 921             Iterator&lt;Principal&gt; pIterator = principals.iterator();
 922             while (pIterator.hasNext()) {
 923                 Principal p = pIterator.next();
 924                 hashCode ^= p.hashCode();
 925             }
 926         }
 927 
 928         synchronized(pubCredentials) {
 929             Iterator&lt;Object&gt; pubCIterator = pubCredentials.iterator();
 930             while (pubCIterator.hasNext()) {
 931                 hashCode ^= getCredHashCode(pubCIterator.next());
 932             }
 933         }
 934         return hashCode;
 935     }
 936 
 937     /**
 938      * get a credential&#39;s hashcode
 939      */
 940     private int getCredHashCode(Object o) {
 941         try {
 942             return o.hashCode();
 943         } catch (IllegalStateException ise) {
 944             return o.getClass().toString().hashCode();
 945         }
 946     }
 947 
 948     /**
 949      * Writes this object out to a stream (i.e., serializes it).
 950      */
 951     @java.io.Serial
 952     private void writeObject(java.io.ObjectOutputStream oos)
 953                 throws java.io.IOException {
 954         synchronized(principals) {
 955             oos.defaultWriteObject();
 956         }
 957     }
 958 
 959     /**
 960      * Reads this object from a stream (i.e., deserializes it)
 961      */
 962     @SuppressWarnings(&quot;unchecked&quot;)
 963     @java.io.Serial
 964     private void readObject(java.io.ObjectInputStream s)
 965                 throws java.io.IOException, ClassNotFoundException {
 966 
 967         ObjectInputStream.GetField gf = s.readFields();
 968 
 969         readOnly = gf.get(&quot;readOnly&quot;, false);
 970 
 971         Set&lt;Principal&gt; inputPrincs = (Set&lt;Principal&gt;)gf.get(&quot;principals&quot;, null);
 972 
 973         Objects.requireNonNull(inputPrincs,
 974                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
 975 
 976         // Rewrap the principals into a SecureSet
 977         try {
<a name="6" id="anc6"></a>
 978             principals = Collections.synchronizedSet(new SecureSet&lt;&gt;
<a name="7" id="anc7"></a><span class="line-modified"> 979                                 (this, PRINCIPAL_SET, inputPrincs));</span>
 980         } catch (NullPointerException npe) {
 981             // Sometimes people deserialize the principals set only.
 982             // Subject is not accessible, so just don&#39;t fail.
 983             principals = Collections.synchronizedSet
 984                         (new SecureSet&lt;&gt;(this, PRINCIPAL_SET));
 985         }
 986 
 987         // The Credential {@code Set} is not serialized, but we do not
 988         // want the default deserialization routine to set it to null.
 989         this.pubCredentials = Collections.synchronizedSet
 990                         (new SecureSet&lt;&gt;(this, PUB_CREDENTIAL_SET));
 991         this.privCredentials = Collections.synchronizedSet
 992                         (new SecureSet&lt;&gt;(this, PRIV_CREDENTIAL_SET));
 993     }
 994 
 995     /**
 996      * Tests for null-clean collections (both non-null reference and
 997      * no null elements)
 998      *
 999      * @param coll A {@code Collection} to be tested for null references
1000      *
1001      * @throws NullPointerException if the specified collection is either
1002      *            {@code null} or contains a {@code null} element
1003      */
<a name="8" id="anc8"></a><span class="line-modified">1004     private static void collectionNullClean(Collection&lt;?&gt; coll) {</span>
<span class="line-modified">1005         boolean hasNullElements = false;</span>
1006 
1007         Objects.requireNonNull(coll,
1008                 ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1009 
<a name="9" id="anc9"></a><span class="line-modified">1010         try {</span>
<span class="line-modified">1011             hasNullElements = coll.contains(null);</span>
<span class="line-modified">1012         } catch (NullPointerException npe) {</span>
<span class="line-modified">1013             // A null-hostile collection may choose to throw</span>
<span class="line-removed">1014             // NullPointerException if contains(null) is called on it</span>
<span class="line-removed">1015             // rather than returning false.</span>
<span class="line-removed">1016             // If this happens we know the collection is null-clean.</span>
<span class="line-removed">1017             hasNullElements = false;</span>
<span class="line-removed">1018         } finally {</span>
<span class="line-removed">1019             if (hasNullElements) {</span>
<span class="line-removed">1020                 throw new NullPointerException</span>
<span class="line-removed">1021                     (ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));</span>
<span class="line-removed">1022             }</span>
1023         }
<a name="10" id="anc10"></a>
1024     }
1025 
1026     /**
1027      * Prevent modifications unless caller has permission.
1028      *
1029      * @serial include
1030      */
1031     private static class SecureSet&lt;E&gt;
1032         implements Set&lt;E&gt;, java.io.Serializable {
1033 
1034         @java.io.Serial
1035         private static final long serialVersionUID = 7911754171111800359L;
1036 
1037         /**
1038          * @serialField this$0 Subject The outer Subject instance.
1039          * @serialField elements LinkedList The elements in this set.
1040          */
1041         @java.io.Serial
1042         private static final ObjectStreamField[] serialPersistentFields = {
1043             new ObjectStreamField(&quot;this$0&quot;, Subject.class),
1044             new ObjectStreamField(&quot;elements&quot;, LinkedList.class),
1045             new ObjectStreamField(&quot;which&quot;, int.class)
1046         };
1047 
1048         Subject subject;
1049         LinkedList&lt;E&gt; elements;
1050 
1051         /**
1052          * @serial An integer identifying the type of objects contained
1053          *      in this set.  If {@code which == 1},
1054          *      this is a Principal set and all the elements are
1055          *      of type {@code java.security.Principal}.
1056          *      If {@code which == 2}, this is a public credential
1057          *      set and all the elements are of type {@code Object}.
1058          *      If {@code which == 3}, this is a private credential
1059          *      set and all the elements are of type {@code Object}.
1060          */
1061         private int which;
1062 
1063         SecureSet(Subject subject, int which) {
1064             this.subject = subject;
1065             this.which = which;
1066             this.elements = new LinkedList&lt;E&gt;();
1067         }
1068 
<a name="11" id="anc11"></a><span class="line-modified">1069         SecureSet(Subject subject, int which, Set&lt;? extends E&gt; set) {</span>
1070             this.subject = subject;
1071             this.which = which;
<a name="12" id="anc12"></a><span class="line-modified">1072             this.elements = new LinkedList&lt;E&gt;(set);</span>
1073         }
1074 
1075         public int size() {
1076             return elements.size();
1077         }
1078 
1079         public Iterator&lt;E&gt; iterator() {
1080             final LinkedList&lt;E&gt; list = elements;
1081             return new Iterator&lt;E&gt;() {
1082                 ListIterator&lt;E&gt; i = list.listIterator(0);
1083 
1084                 public boolean hasNext() {return i.hasNext();}
1085 
1086                 public E next() {
1087                     if (which != Subject.PRIV_CREDENTIAL_SET) {
1088                         return i.next();
1089                     }
1090 
1091                     SecurityManager sm = System.getSecurityManager();
1092                     if (sm != null) {
1093                         try {
1094                             sm.checkPermission(new PrivateCredentialPermission
1095                                 (list.get(i.nextIndex()).getClass().getName(),
1096                                 subject.getPrincipals()));
1097                         } catch (SecurityException se) {
1098                             i.next();
1099                             throw (se);
1100                         }
1101                     }
1102                     return i.next();
1103                 }
1104 
1105                 public void remove() {
1106 
1107                     if (subject.isReadOnly()) {
1108                         throw new IllegalStateException(ResourcesMgr.getString
1109                                 (&quot;Subject.is.read.only&quot;));
1110                     }
1111 
1112                     java.lang.SecurityManager sm = System.getSecurityManager();
1113                     if (sm != null) {
1114                         switch (which) {
1115                         case Subject.PRINCIPAL_SET:
1116                             sm.checkPermission(AuthPermissionHolder.MODIFY_PRINCIPALS_PERMISSION);
1117                             break;
1118                         case Subject.PUB_CREDENTIAL_SET:
1119                             sm.checkPermission(AuthPermissionHolder.MODIFY_PUBLIC_CREDENTIALS_PERMISSION);
1120                             break;
1121                         default:
1122                             sm.checkPermission(AuthPermissionHolder.MODIFY_PRIVATE_CREDENTIALS_PERMISSION);
1123                             break;
1124                         }
1125                     }
1126                     i.remove();
1127                 }
1128             };
1129         }
1130 
1131         public boolean add(E o) {
1132 
1133             Objects.requireNonNull(o,
1134                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1135 
1136             if (subject.isReadOnly()) {
1137                 throw new IllegalStateException
1138                         (ResourcesMgr.getString(&quot;Subject.is.read.only&quot;));
1139             }
1140 
1141             java.lang.SecurityManager sm = System.getSecurityManager();
1142             if (sm != null) {
1143                 switch (which) {
1144                 case Subject.PRINCIPAL_SET:
1145                     sm.checkPermission(AuthPermissionHolder.MODIFY_PRINCIPALS_PERMISSION);
1146                     break;
1147                 case Subject.PUB_CREDENTIAL_SET:
1148                     sm.checkPermission(AuthPermissionHolder.MODIFY_PUBLIC_CREDENTIALS_PERMISSION);
1149                     break;
1150                 default:
1151                     sm.checkPermission(AuthPermissionHolder.MODIFY_PRIVATE_CREDENTIALS_PERMISSION);
1152                     break;
1153                 }
1154             }
1155 
1156             switch (which) {
1157             case Subject.PRINCIPAL_SET:
1158                 if (!(o instanceof Principal)) {
1159                     throw new SecurityException(ResourcesMgr.getString
1160                         (&quot;attempting.to.add.an.object.which.is.not.an.instance.of.java.security.Principal.to.a.Subject.s.Principal.Set&quot;));
1161                 }
1162                 break;
1163             default:
1164                 // ok to add Objects of any kind to credential sets
1165                 break;
1166             }
1167 
1168             // check for duplicates
1169             if (!elements.contains(o))
1170                 return elements.add(o);
1171             else {
1172                 return false;
1173         }
1174         }
1175 
1176         public boolean remove(Object o) {
1177 
1178             Objects.requireNonNull(o,
1179                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1180 
1181             final Iterator&lt;E&gt; e = iterator();
1182             while (e.hasNext()) {
1183                 E next;
1184                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1185                     next = e.next();
1186                 } else {
1187                     next = java.security.AccessController.doPrivileged
1188                         (new java.security.PrivilegedAction&lt;E&gt;() {
1189                         public E run() {
1190                             return e.next();
1191                         }
1192                     });
1193                 }
1194 
1195                 if (next.equals(o)) {
1196                     e.remove();
1197                     return true;
1198                 }
1199             }
1200             return false;
1201         }
1202 
1203         public boolean contains(Object o) {
1204 
1205             Objects.requireNonNull(o,
1206                     ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));
1207 
1208             final Iterator&lt;E&gt; e = iterator();
1209             while (e.hasNext()) {
1210                 E next;
1211                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1212                     next = e.next();
1213                 } else {
1214 
1215                     // For private credentials:
1216                     // If the caller does not have read permission for
1217                     // for o.getClass(), we throw a SecurityException.
1218                     // Otherwise we check the private cred set to see whether
1219                     // it contains the Object
1220 
1221                     SecurityManager sm = System.getSecurityManager();
1222                     if (sm != null) {
1223                         sm.checkPermission(new PrivateCredentialPermission
1224                                                 (o.getClass().getName(),
1225                                                 subject.getPrincipals()));
1226                     }
1227                     next = java.security.AccessController.doPrivileged
1228                         (new java.security.PrivilegedAction&lt;E&gt;() {
1229                         public E run() {
1230                             return e.next();
1231                         }
1232                     });
1233                 }
1234 
1235                 if (next.equals(o)) {
1236                     return true;
1237                 }
1238             }
1239             return false;
1240         }
1241 
1242         public boolean addAll(Collection&lt;? extends E&gt; c) {
1243             boolean result = false;
1244 
<a name="13" id="anc13"></a><span class="line-modified">1245             collectionNullClean(c);</span>
1246 
1247             for (E item : c) {
1248                 result |= this.add(item);
1249             }
1250 
1251             return result;
1252         }
1253 
1254         public boolean removeAll(Collection&lt;?&gt; c) {
<a name="14" id="anc14"></a><span class="line-modified">1255             collectionNullClean(c);</span>
1256 
1257             boolean modified = false;
1258             final Iterator&lt;E&gt; e = iterator();
1259             while (e.hasNext()) {
1260                 E next;
1261                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1262                     next = e.next();
1263                 } else {
1264                     next = java.security.AccessController.doPrivileged
1265                         (new java.security.PrivilegedAction&lt;E&gt;() {
1266                         public E run() {
1267                             return e.next();
1268                         }
1269                     });
1270                 }
1271 
1272                 Iterator&lt;?&gt; ce = c.iterator();
1273                 while (ce.hasNext()) {
1274                     if (next.equals(ce.next())) {
1275                             e.remove();
1276                             modified = true;
1277                             break;
1278                         }
1279                 }
1280             }
1281             return modified;
1282         }
1283 
1284         public boolean containsAll(Collection&lt;?&gt; c) {
<a name="15" id="anc15"></a><span class="line-modified">1285             collectionNullClean(c);</span>
1286 
1287             for (Object item : c) {
1288                 if (this.contains(item) == false) {
1289                     return false;
1290                 }
1291             }
1292 
1293             return true;
1294         }
1295 
1296         public boolean retainAll(Collection&lt;?&gt; c) {
<a name="16" id="anc16"></a><span class="line-modified">1297             collectionNullClean(c);</span>
1298 
1299             boolean modified = false;
1300             final Iterator&lt;E&gt; e = iterator();
1301             while (e.hasNext()) {
1302                 E next;
1303                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1304                     next = e.next();
1305                 } else {
1306                     next = java.security.AccessController.doPrivileged
1307                         (new java.security.PrivilegedAction&lt;E&gt;() {
1308                         public E run() {
1309                             return e.next();
1310                         }
1311                     });
1312                 }
1313 
1314                 if (c.contains(next) == false) {
1315                     e.remove();
1316                     modified = true;
<a name="17" id="anc17"></a><span class="line-removed">1317                     }</span>
1318                 }
<a name="18" id="anc18"></a>
1319 
1320             return modified;
1321         }
1322 
1323         public void clear() {
1324             final Iterator&lt;E&gt; e = iterator();
1325             while (e.hasNext()) {
1326                 E next;
1327                 if (which != Subject.PRIV_CREDENTIAL_SET) {
1328                     next = e.next();
1329                 } else {
1330                     next = java.security.AccessController.doPrivileged
1331                         (new java.security.PrivilegedAction&lt;E&gt;() {
1332                         public E run() {
1333                             return e.next();
1334                         }
1335                     });
1336                 }
1337                 e.remove();
1338             }
1339         }
1340 
1341         public boolean isEmpty() {
1342             return elements.isEmpty();
1343         }
1344 
1345         public Object[] toArray() {
1346             final Iterator&lt;E&gt; e = iterator();
1347             while (e.hasNext()) {
1348                 // The next() method performs a security manager check
1349                 // on each element in the SecureSet.  If we make it all
1350                 // the way through we should be able to simply return
1351                 // element&#39;s toArray results.  Otherwise we&#39;ll let
1352                 // the SecurityException pass up the call stack.
1353                 e.next();
1354             }
1355 
1356             return elements.toArray();
1357         }
1358 
1359         public &lt;T&gt; T[] toArray(T[] a) {
1360             final Iterator&lt;E&gt; e = iterator();
1361             while (e.hasNext()) {
1362                 // The next() method performs a security manager check
1363                 // on each element in the SecureSet.  If we make it all
1364                 // the way through we should be able to simply return
1365                 // element&#39;s toArray results.  Otherwise we&#39;ll let
1366                 // the SecurityException pass up the call stack.
1367                 e.next();
1368             }
1369 
1370             return elements.toArray(a);
1371         }
1372 
1373         public boolean equals(Object o) {
1374             if (o == this) {
1375                 return true;
1376             }
1377 
1378             if (!(o instanceof Set)) {
1379                 return false;
1380             }
1381 
1382             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
1383             if (c.size() != size()) {
1384                 return false;
1385             }
1386 
1387             try {
1388                 return containsAll(c);
1389             } catch (ClassCastException unused)   {
1390                 return false;
1391             } catch (NullPointerException unused) {
1392                 return false;
1393             }
1394         }
1395 
1396         public int hashCode() {
1397             int h = 0;
1398             Iterator&lt;E&gt; i = iterator();
1399             while (i.hasNext()) {
1400                 E obj = i.next();
1401                 if (obj != null) {
1402                     h += obj.hashCode();
1403                 }
1404             }
1405             return h;
1406         }
1407 
1408         /**
1409          * Writes this object out to a stream (i.e., serializes it).
1410          *
1411          * @serialData If this is a private credential set,
1412          *      a security check is performed to ensure that
1413          *      the caller has permission to access each credential
1414          *      in the set.  If the security check passes,
1415          *      the set is serialized.
1416          */
1417         @java.io.Serial
1418         private void writeObject(java.io.ObjectOutputStream oos)
1419                 throws java.io.IOException {
1420 
1421             if (which == Subject.PRIV_CREDENTIAL_SET) {
1422                 // check permissions before serializing
1423                 Iterator&lt;E&gt; i = iterator();
1424                 while (i.hasNext()) {
1425                     i.next();
1426                 }
1427             }
1428             ObjectOutputStream.PutField fields = oos.putFields();
1429             fields.put(&quot;this$0&quot;, subject);
1430             fields.put(&quot;elements&quot;, elements);
1431             fields.put(&quot;which&quot;, which);
1432             oos.writeFields();
1433         }
1434 
1435         @SuppressWarnings(&quot;unchecked&quot;)
1436         @java.io.Serial
1437         private void readObject(ObjectInputStream ois)
1438             throws IOException, ClassNotFoundException
1439         {
1440             ObjectInputStream.GetField fields = ois.readFields();
1441             subject = (Subject) fields.get(&quot;this$0&quot;, null);
1442             which = fields.get(&quot;which&quot;, 0);
1443 
1444             LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);
1445 
<a name="19" id="anc19"></a><span class="line-modified">1446             Subject.collectionNullClean(tmp);</span>
<span class="line-removed">1447 </span>
<span class="line-removed">1448             if (tmp.getClass() != LinkedList.class) {</span>
<span class="line-removed">1449                 elements = new LinkedList&lt;E&gt;(tmp);</span>
<span class="line-removed">1450             } else {</span>
<span class="line-removed">1451                 elements = tmp;</span>
<span class="line-removed">1452             }</span>
1453         }
1454 
1455     }
1456 
1457     /**
1458      * This class implements a {@code Set} which returns only
1459      * members that are an instance of a specified Class.
1460      */
1461     private class ClassSet&lt;T&gt; extends AbstractSet&lt;T&gt; {
1462 
1463         private int which;
1464         private Class&lt;T&gt; c;
1465         private Set&lt;T&gt; set;
1466 
1467         ClassSet(int which, Class&lt;T&gt; c) {
1468             this.which = which;
1469             this.c = c;
1470             set = new HashSet&lt;T&gt;();
1471 
1472             switch (which) {
1473             case Subject.PRINCIPAL_SET:
1474                 synchronized(principals) { populateSet(); }
1475                 break;
1476             case Subject.PUB_CREDENTIAL_SET:
1477                 synchronized(pubCredentials) { populateSet(); }
1478                 break;
1479             default:
1480                 synchronized(privCredentials) { populateSet(); }
1481                 break;
1482             }
1483         }
1484 
1485         @SuppressWarnings(&quot;unchecked&quot;)     /*To suppress warning from line 1374*/
1486         private void populateSet() {
1487             final Iterator&lt;?&gt; iterator;
1488             switch(which) {
1489             case Subject.PRINCIPAL_SET:
1490                 iterator = Subject.this.principals.iterator();
1491                 break;
1492             case Subject.PUB_CREDENTIAL_SET:
1493                 iterator = Subject.this.pubCredentials.iterator();
1494                 break;
1495             default:
1496                 iterator = Subject.this.privCredentials.iterator();
1497                 break;
1498             }
1499 
1500             // Check whether the caller has permisson to get
1501             // credentials of Class c
1502 
1503             while (iterator.hasNext()) {
1504                 Object next;
1505                 if (which == Subject.PRIV_CREDENTIAL_SET) {
1506                     next = java.security.AccessController.doPrivileged
1507                         (new java.security.PrivilegedAction&lt;&gt;() {
1508                         public Object run() {
1509                             return iterator.next();
1510                         }
1511                     });
1512                 } else {
1513                     next = iterator.next();
1514                 }
1515                 if (c.isAssignableFrom(next.getClass())) {
1516                     if (which != Subject.PRIV_CREDENTIAL_SET) {
1517                         set.add((T)next);
1518                     } else {
1519                         // Check permission for private creds
1520                         SecurityManager sm = System.getSecurityManager();
1521                         if (sm != null) {
1522                             sm.checkPermission(new PrivateCredentialPermission
1523                                                 (next.getClass().getName(),
1524                                                 Subject.this.getPrincipals()));
1525                         }
1526                         set.add((T)next);
1527                     }
1528                 }
1529             }
1530         }
1531 
1532         @Override
1533         public int size() {
1534             return set.size();
1535         }
1536 
1537         @Override
1538         public Iterator&lt;T&gt; iterator() {
1539             return set.iterator();
1540         }
1541 
1542         @Override
1543         public boolean add(T o) {
1544 
1545             if (!c.isAssignableFrom(o.getClass())) {
1546                 MessageFormat form = new MessageFormat(ResourcesMgr.getString
1547                         (&quot;attempting.to.add.an.object.which.is.not.an.instance.of.class&quot;));
1548                 Object[] source = {c.toString()};
1549                 throw new SecurityException(form.format(source));
1550             }
1551 
1552             return set.add(o);
1553         }
1554     }
1555 
1556     static final class AuthPermissionHolder {
1557         static final AuthPermission DO_AS_PERMISSION =
1558             new AuthPermission(&quot;doAs&quot;);
1559 
1560         static final AuthPermission DO_AS_PRIVILEGED_PERMISSION =
1561             new AuthPermission(&quot;doAsPrivileged&quot;);
1562 
1563         static final AuthPermission SET_READ_ONLY_PERMISSION =
1564             new AuthPermission(&quot;setReadOnly&quot;);
1565 
1566         static final AuthPermission GET_SUBJECT_PERMISSION =
1567             new AuthPermission(&quot;getSubject&quot;);
1568 
1569         static final AuthPermission MODIFY_PRINCIPALS_PERMISSION =
1570             new AuthPermission(&quot;modifyPrincipals&quot;);
1571 
1572         static final AuthPermission MODIFY_PUBLIC_CREDENTIALS_PERMISSION =
1573             new AuthPermission(&quot;modifyPublicCredentials&quot;);
1574 
1575         static final AuthPermission MODIFY_PRIVATE_CREDENTIALS_PERMISSION =
1576             new AuthPermission(&quot;modifyPrivateCredentials&quot;);
1577     }
1578 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
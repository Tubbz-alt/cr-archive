diff a/src/java.base/share/classes/java/util/zip/ZipEntry.java b/src/java.base/share/classes/java/util/zip/ZipEntry.java
--- a/src/java.base/share/classes/java/util/zip/ZipEntry.java
+++ b/src/java.base/share/classes/java/util/zip/ZipEntry.java
@@ -55,11 +55,11 @@
     long csize = -1;    // compressed size of entry data
     int method = -1;    // compression method
     int flag = 0;       // general purpose flag
     byte[] extra;       // optional extra field data for entry
     String comment;     // optional comment string for entry
-
+    int posixPerms = -1;// posix permissions
     /**
      * Compression method for uncompressed entries.
      */
     public static final int STORED = 0;
 
@@ -129,10 +129,11 @@
         csize = e.csize;
         method = e.method;
         flag = e.flag;
         extra = e.extra;
         comment = e.comment;
+        posixPerms = e.posixPerms;
     }
 
     /**
      * Returns the name of the entry.
      * @return the name of the entry
diff a/src/java.base/share/classes/java/util/zip/ZipFile.java b/src/java.base/share/classes/java/util/zip/ZipFile.java
--- a/src/java.base/share/classes/java/util/zip/ZipFile.java
+++ b/src/java.base/share/classes/java/util/zip/ZipFile.java
@@ -655,10 +655,15 @@
         e.xdostime = CENTIM(cen, pos);
         e.crc = CENCRC(cen, pos);
         e.size = CENLEN(cen, pos);
         e.csize = CENSIZ(cen, pos);
         e.method = CENHOW(cen, pos);
+        if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {
+            // 12 bits for setuid, setgid, sticky + perms
+            e.posixPerms = CENATX_PERMS(cen, pos) & 0xFFF;
+        }
+
         if (elen != 0) {
             int start = pos + CENHDR + nlen;
             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
         }
         if (clen != 0) {
@@ -1090,10 +1095,20 @@
                 }
                 @Override
                 public Stream<String> entryNameStream(ZipFile zip) {
                     return zip.entryNameStream();
                 }
+                // only set posix perms value via ZipEntry contructor for now
+                @Override
+                public int getPosixPerms(ZipEntry ze) {
+                    return ze.posixPerms;
+                }
+                @Override
+                public void setPosixPerms(ZipEntry ze, int perms) {
+                    ze.posixPerms = perms;
+                }
+
              }
         );
         isWindows = VM.getSavedProperty("os.name").contains("Windows");
     }
 
diff a/src/java.base/share/classes/java/util/zip/ZipOutputStream.java b/src/java.base/share/classes/java/util/zip/ZipOutputStream.java
--- a/src/java.base/share/classes/java/util/zip/ZipOutputStream.java
+++ b/src/java.base/share/classes/java/util/zip/ZipOutputStream.java
@@ -504,10 +504,19 @@
             writeInt(e.csize);          // compressed size
             writeInt(e.size);           // uncompressed size
         }
     }
 
+    /**
+     * Adds information about compatibility of file attribute information
+     * to a version value.
+     */
+    private int versionMadeBy(ZipEntry e, int version) {
+        return (e.posixPerms < 0) ? version :
+                VERSION_MADE_BY_BASE_UNIX | (version & 0xff);
+    }
+
     /*
      * Write central directory (CEN) header for specified entry.
      * REMIND: add support for file attributes
      */
     private void writeCEN(XEntry xentry) throws IOException {
@@ -535,14 +544,14 @@
             elenZIP64 += 8;              // offset(8)
             hasZip64 = true;
         }
         writeInt(CENSIG);           // CEN header signature
         if (hasZip64) {
-            writeShort(45);         // ver 4.5 for zip64
+            writeShort(versionMadeBy(e,45));         // ver 4.5 for zip64
             writeShort(45);
         } else {
-            writeShort(version);    // version made by
+            writeShort(versionMadeBy(e, version));    // version made by
             writeShort(version);    // version needed to extract
         }
         writeShort(flag);           // general purpose bit flag
         writeShort(e.method);       // compression method
         writeInt(e.xdostime);       // last modification time
@@ -595,11 +604,12 @@
             commentBytes = null;
             writeShort(0);
         }
         writeShort(0);              // starting disk number
         writeShort(0);              // internal file attributes (unused)
-        writeInt(0);                // external file attributes (unused)
+        // external file attributes, used for storing posix permissions
+        writeInt(e.posixPerms > 0 ? e.posixPerms << 16 : 0);
         writeInt(offset);           // relative offset of local header
         writeBytes(nameBytes, 0, nameBytes.length);
 
         // take care of EXTID_ZIP64 and EXTID_EXTT
         if (hasZip64) {
diff a/src/java.base/share/classes/java/util/zip/ZipUtils.java b/src/java.base/share/classes/java/util/zip/ZipUtils.java
--- a/src/java.base/share/classes/java/util/zip/ZipUtils.java
+++ b/src/java.base/share/classes/java/util/zip/ZipUtils.java
@@ -213,10 +213,21 @@
 
     static final long GETSIG(byte[] b) {
         return LG(b, 0);
     }
 
+    /*
+     * File attribute compatibility types of CEN field "version made by"
+     */
+    static final int FILE_ATTRIBUTES_UNIX = 3; // Unix
+
+    /*
+     * Base values for CEN field "version made by"
+     */
+    static final int VERSION_MADE_BY_BASE_UNIX = FILE_ATTRIBUTES_UNIX << 8; // Unix
+
+
     // local file (LOC) header fields
     static final long LOCSIG(byte[] b) { return LG(b, 0); } // signature
     static final int  LOCVER(byte[] b) { return SH(b, 4); } // version needed to extract
     static final int  LOCFLG(byte[] b) { return SH(b, 6); } // general purpose bit flags
     static final int  LOCHOW(byte[] b) { return SH(b, 8); } // compression method
@@ -248,10 +259,11 @@
     static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   // zip64 end offset
 
     // central directory header (CEN) fields
     static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }
     static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }
+    static final int  CENVEM_FA(byte[] b, int pos) { return CH(b, pos + 5); } // file attribute compatibility
     static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }
     static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }
     static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}
     static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}
     static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}
@@ -261,10 +273,11 @@
     static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}
     static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}
     static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}
     static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}
     static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}
+    static final int  CENATX_PERMS(byte[] b, int pos) { return SH(b, pos + 40);} // posix permission data
     static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}
 
     // The END header is followed by a variable length comment of size < 64k.
     static final long END_MAXLEN = 0xFFFF + ENDHDR;
     static final int READBLOCKSZ = 128;
diff a/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
@@ -28,17 +28,20 @@
 import java.util.Enumeration;
 import java.util.List;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
 public interface JavaUtilZipFileAccess {
     public boolean startsWithLocHeader(ZipFile zip);
     public List<String> getManifestAndSignatureRelatedFiles(JarFile zip);
     public String getManifestName(JarFile zip, boolean onlyIfSignatureRelatedFiles);
     public int[] getMetaInfVersions(JarFile zip);
     public Enumeration<JarEntry> entries(ZipFile zip);
     public Stream<JarEntry> stream(ZipFile zip);
     public Stream<String> entryNameStream(ZipFile zip);
+    public void setPosixPerms(ZipEntry ze, int posixPerms);
+    public int getPosixPerms(ZipEntry ze);
 }
 
diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -147,10 +147,11 @@
         java.desktop,
         java.logging,
         java.management,
         java.naming,
         java.rmi,
+        jdk.jartool,
         jdk.jlink,
         jdk.net,
         jdk.incubator.foreign;
     exports jdk.internal.access.foreign to
         jdk.incubator.foreign;
diff a/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java b/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
--- a/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
+++ b/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
@@ -246,11 +246,11 @@
         URI uri = name.getURI();
         if (debug != null) {
             debug.println("Trying to fetch CRL from DP " + uri);
         }
 
-        Event.report("event.crl.check", uri.toString());
+        Event.report(Event.ReporterCategory.CRLCHECK,"event.crl.check", uri.toString());
         CertStore ucs = null;
         try {
             ucs = URICertStore.getInstance(new URICertStoreParameters(uri));
         } catch (InvalidAlgorithmParameterException |
                  NoSuchAlgorithmException e) {
diff a/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java b/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java
--- a/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java
+++ b/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java
@@ -232,11 +232,11 @@
             URL url = responderURI.toURL();
             if (debug != null) {
                 debug.println("connecting to OCSP service at: " + url);
             }
 
-            Event.report("event.ocsp.check", url.toString());
+            Event.report(Event.ReporterCategory.CRLCHECK,"event.ocsp.check", url.toString());
             HttpURLConnection con = (HttpURLConnection)url.openConnection();
             con.setConnectTimeout(CONNECT_TIMEOUT);
             con.setReadTimeout(CONNECT_TIMEOUT);
             con.setDoOutput(true);
             con.setDoInput(true);
diff a/src/java.base/share/classes/sun/security/util/Event.java b/src/java.base/share/classes/sun/security/util/Event.java
--- a/src/java.base/share/classes/sun/security/util/Event.java
+++ b/src/java.base/share/classes/sun/security/util/Event.java
@@ -33,25 +33,31 @@
  * Listener should implement the event handling of the Reporter interface.
  */
 public final class Event {
     private Event() {}
 
+    public enum ReporterCategory {
+        CRLCHECK(),
+        POSIXPERMS();
+
+        private Reporter reporter;
+    }
+
     public interface Reporter {
         public void handle(String type, Object... args);
     }
 
-    private static Reporter reporter;
-    public static void setReportListener(Reporter re) {
-        reporter = re;
+    public static void setReportListener(ReporterCategory cat, Reporter re) {
+        cat.reporter = re;
     }
 
-    public static void clearReportListener() {
-        reporter = null;
+    public static void clearReportListener(ReporterCategory cat) {
+        cat.reporter = null;
     }
 
-    public static void report(String type, Object... args) {
-        Reporter currentReporter = reporter;
+    public static void report(ReporterCategory cat, String type, Object... args) {
+        Reporter currentReporter = cat.reporter;
 
         if (currentReporter != null) {
             currentReporter.handle(type, args);
         }
     }
diff a/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java b/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java
--- a/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java
+++ b/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java
@@ -25,12 +25,15 @@
 
 package jdk.security.jarsigner;
 
 import com.sun.jarsigner.ContentSigner;
 import com.sun.jarsigner.ContentSignerParameters;
+import jdk.internal.access.JavaUtilZipFileAccess;
+import jdk.internal.access.SharedSecrets;
 import sun.security.tools.PathList;
 import sun.security.tools.jarsigner.TimestampedSigner;
+import sun.security.util.Event;
 import sun.security.util.ManifestDigester;
 import sun.security.util.SignatureFileVerifier;
 import sun.security.x509.AlgorithmId;
 
 import java.io.*;
@@ -80,10 +83,12 @@
  *
  * @since 9
  */
 public final class JarSigner {
 
+    static final JavaUtilZipFileAccess JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
+
     /**
      * A mutable builder class that can create an immutable {@code JarSigner}
      * from various signing-related parameters.
      *
      * @since 9
@@ -498,10 +503,11 @@
     private final String tSADigestAlg;
     private final boolean signManifest; // "sign" the whole manifest
     private final boolean externalSF; // leave the .SF out of the PKCS7 block
     private final String altSignerPath;
     private final String altSigner;
+    private boolean posixPermsDetected;
 
     private JarSigner(JarSigner.Builder builder) {
 
         this.privateKey = builder.privateKey;
         this.certChain = builder.certChain;
@@ -941,10 +947,16 @@
         ZipEntry ze2 = new ZipEntry(ze.getName());
         ze2.setMethod(ze.getMethod());
         ze2.setTime(ze.getTime());
         ze2.setComment(ze.getComment());
         ze2.setExtra(ze.getExtra());
+        int perms = JUZFA.getPosixPerms(ze);
+        if (!posixPermsDetected && perms != -1) {
+            posixPermsDetected = true;
+            Event.report(Event.ReporterCategory.POSIXPERMS, "true");
+        }
+        JUZFA.setPosixPerms(ze2, perms);
         if (ze.getMethod() == ZipEntry.STORED) {
             ze2.setSize(ze.getSize());
             ze2.setCrc(ze.getCrc());
         }
         os.putNextEntry(ze2);
diff a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
--- a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
+++ b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
@@ -48,10 +48,12 @@
 import java.security.cert.CertificateFactory;
 import java.security.cert.CertificateNotYetValidException;
 import java.security.cert.TrustAnchor;
 import java.util.Map.Entry;
 
+import jdk.internal.access.JavaUtilZipFileAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.security.jarsigner.JarSigner;
 import jdk.security.jarsigner.JarSignerException;
 import sun.security.pkcs.PKCS7;
 import sun.security.pkcs.SignerInfo;
 import sun.security.timestamp.TimestampToken;
@@ -106,17 +108,21 @@
     private static final Set<CryptoPrimitive> DIGEST_PRIMITIVE_SET = Collections
             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
     private static final Set<CryptoPrimitive> SIG_PRIMITIVE_SET = Collections
             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 
+    private static boolean permsDetected;
+
     static final String VERSION = "1.0";
 
     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
     // signer is not in alias list
     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 
+    static final JavaUtilZipFileAccess JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
+
     // Attention:
     // This is the entry that get launched by the security tool jarsigner.
     public static void main(String args[]) throws Exception {
         Main js = new Main();
         js.run(args);
@@ -292,11 +298,11 @@
             // zero-out keystore password
             if (storepass != null) {
                 Arrays.fill(storepass, ' ');
                 storepass = null;
             }
-            Event.clearReportListener();
+            Event.clearReportListener(Event.ReporterCategory.CRLCHECK);
         }
 
         if (strict) {
             int exitCode = 0;
             if (disabledAlg != 0 || chainNotValidated || hasExpiredCert
@@ -774,10 +780,13 @@
 
                 while (e.hasMoreElements()) {
                     JarEntry je = e.nextElement();
                     String name = je.getName();
 
+                    if (!permsDetected && JUZFA.getPosixPerms(je) != -1) {
+                        permsDetected = true;
+                    }
                     hasSignature = hasSignature
                             || SignatureFileVerifier.isBlockOrSF(name);
 
                     CodeSigner[] signers = je.getCodeSigners();
                     boolean isSigned = (signers != null);
@@ -1052,11 +1061,11 @@
 
         if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
                 notYetValidCert || chainNotValidated || hasExpiredCert ||
                 hasUnsignedEntry || signerSelfSigned || (legacyAlg != 0) ||
                 (disabledAlg != 0) || aliasNotInStore || notSignedByAlias ||
-                tsaChainNotValidated ||
+                tsaChainNotValidated || permsDetected ||
                 (hasExpiredTsaCert && !signerNotExpired)) {
 
             if (strict) {
                 result = isSigning
                         ? rb.getString("jar.signed.with.signer.errors.")
@@ -1133,10 +1142,14 @@
                 errors.add(isSigning
                         ? rb.getString("The.signer.s.certificate.is.self.signed.")
                         : rb.getString("This.jar.contains.entries.whose.signer.certificate.is.self.signed."));
             }
 
+            if (permsDetected) {
+                warnings.add(rb.getString("posix.attributes.detected"));
+            }
+
             if (isSigning) {
                 if ((legacyAlg & 1) == 1) {
                     warnings.add(String.format(
                             rb.getString("The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update."),
                             digestalg, "-digestalg"));
@@ -1769,10 +1782,12 @@
 
         Throwable failedCause = null;
         String failedMessage = null;
 
         try {
+            Event.setReportListener(Event.ReporterCategory.POSIXPERMS,
+                    (t, o) -> permsDetected = true);
             builder.build().sign(zipFile, fos);
         } catch (JarSignerException e) {
             failedCause = e.getCause();
             if (failedCause instanceof SocketTimeoutException
                     || failedCause instanceof UnknownHostException) {
@@ -1803,10 +1818,11 @@
 
             if (fos != null) {
                 fos.close();
             }
 
+            Event.clearReportListener(Event.ReporterCategory.POSIXPERMS);
         }
 
         if (failedCause != null) {
             signedJarFile.delete();
             error(failedMessage, failedCause);
@@ -2062,11 +2078,12 @@
                             null);
 
                     if (revocationCheck) {
                         Security.setProperty("ocsp.enable", "true");
                         System.setProperty("com.sun.security.enableCRLDP", "true");
-                        Event.setReportListener((t, o) -> System.out.println(String.format(rb.getString(t), o)));
+                        Event.setReportListener(Event.ReporterCategory.CRLCHECK,
+                                (t, o) -> System.out.println(String.format(rb.getString(t), o)));
                     }
                     pkixParameters.setRevocationEnabled(revocationCheck);
                 } catch (InvalidAlgorithmParameterException ex) {
                     // Only if tas is empty
                 }
diff a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java
--- a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java
+++ b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java
@@ -168,10 +168,11 @@
         {"with.disabled", "%s (disabled)"},
         {"key.bit", "%d-bit key"},
         {"key.bit.weak", "%d-bit key (weak)"},
         {"key.bit.disabled", "%d-bit key (disabled)"},
         {"unknown.size", "unknown size"},
+        {"posix.attributes.detected", "POSIX file permission attributes detected. Note that these attributes are unsigned and not protected by the signature."},
 
         {"jarsigner.", "jarsigner: "},
         {"signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.",
                 "signature filename must consist of the following characters: A-Z, 0-9, _ or -"},
         {"unable.to.open.jar.file.", "unable to open jar file: "},
diff a/test/jdk/sun/security/tools/jarsigner/PosixPermissionsTest.java b/test/jdk/sun/security/tools/jarsigner/PosixPermissionsTest.java
--- /dev/null
+++ b/test/jdk/sun/security/tools/jarsigner/PosixPermissionsTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8218021
+ * @summary Have jarsigner preserve posix permission attributes
+ * @modules jdk.jartool/sun.security.tools.jarsigner
+ *          java.base/sun.security.tools.keytool
+ * @library /test/lib
+ * @run main/othervm PosixPermissionsTest
+ */
+
+import java.net.URI;
+import java.nio.file.*;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.*;
+
+import jdk.test.lib.SecurityTools;
+
+public class PosixPermissionsTest {
+
+    private static List<String> perms = List.of(
+            "---------",
+            "r--------",
+            "-w-------",
+            "--x------",
+            "rwx------",
+            "---r-----",
+            "----w----",
+            "-----x---",
+            "---rwx---",
+            "------r--",
+            "-------w-",
+            "--------x",
+            "------rwx",
+            "r--r-----",
+            "r--r--r--",
+            "rw-rw----",
+            "rwxrwx---",
+            "rw-rw-r--",
+            "r-xr-x---",
+            "r-xr-xr-x",
+            "rwxrwxrwx");
+
+    private final static String ZIPFILENAME = "8218021-test.zip";
+    private final static String JARFILENAME = "8218021-test.jar";
+    private final static URI JARURI = URI.create("jar:" + Path.of(JARFILENAME).toUri());
+    private final static URI ZIPURI = URI.create("jar:" + Path.of(ZIPFILENAME).toUri());
+    private static Path file;
+    private static int count;
+    private static Set<PosixFilePermission> permsSet;
+    private static String expectedJarPerms;
+    private static final String POSIXWARNING = "POSIX file permission attributes detected. " +
+        "Note that these attributes are unsigned and not protected by the signature.";
+
+    public static void main(String[] args) throws Exception {
+        if (!FileSystems.getDefault().supportedFileAttributeViews().contains("posix")) {
+            System.out.println("No posix support. Skipping");
+            return;
+        }
+
+        createFiles();
+        // check permissions before signing
+        verifyFilePermissions(ZIPURI, true);
+        verifyFilePermissions(JARURI, false);
+
+        SecurityTools.keytool(
+                "-genkey",
+                "-keyalg", "RSA",
+                "-dname", "CN=Coffey, OU=JPG, O=Oracle, L=Santa Clara, ST=California, C=US",
+                "-alias", "examplekey",
+                "-storepass", "password",
+                "-keypass", "password",
+                "-keystore", "examplekeystore",
+                "-validity", "365")
+                .shouldHaveExitValue(0);
+
+        SecurityTools.jarsigner(
+                "-keystore", "examplekeystore",
+                "-verbose", ZIPFILENAME,
+                "-storepass", "password",
+                "-keypass", "password",
+                "examplekey")
+                .shouldHaveExitValue(0)
+                .shouldContain(POSIXWARNING);
+
+        // zip file now signed. Recheck file permissions
+        verifyFilePermissions(ZIPURI, true);
+
+        // sign jar file - no posix warning message expected
+        SecurityTools.jarsigner("-keystore", "examplekeystore",
+                "-verbose", JARFILENAME,
+                "-storepass", "password",
+                "-keypass", "password",
+                "examplekey")
+                .shouldHaveExitValue(0)
+                .shouldNotContain(POSIXWARNING);
+
+        // default attributes expected
+        verifyFilePermissions(JARURI, false);
+
+        SecurityTools.jarsigner("-keystore", "examplekeystore",
+                "-storepass", "password",
+                "-keypass", "password",
+                "-verbose",
+                "-verify", ZIPFILENAME)
+                .shouldHaveExitValue(0)
+                .shouldContain(POSIXWARNING);
+
+        // no warning expected for regular jar file
+        SecurityTools.jarsigner("-keystore", "examplekeystore",
+                "-storepass", "password",
+                "-keypass", "password",
+                "-verbose",
+                "-verify", JARFILENAME)
+                .shouldHaveExitValue(0)
+                .shouldNotContain(POSIXWARNING);
+    }
+
+    private static void createFiles() throws Exception {
+
+        String fileList = " ";
+        Map<String, String> env = new HashMap<>();
+        env.put("create", "true");
+        env.put("enablePosixFileAttributes", "true");
+
+        try (FileSystem zipfs = FileSystems.newFileSystem(ZIPURI, env)) {
+            for (String s : perms) {
+                file = Path.of("test_" + count++);
+                fileList += file + " ";
+                permsSet = PosixFilePermissions.fromString(s);
+                Files.createFile(file);
+
+                Files.copy(file,
+                        zipfs.getPath(file.toString()),
+                        StandardCopyOption.COPY_ATTRIBUTES);
+                Files.setPosixFilePermissions(zipfs.getPath(file.toString()), permsSet);
+            }
+        }
+
+        // create jar file for testing also
+        SecurityTools.jar("cf " + JARFILENAME + fileList);
+        try (FileSystem jarfs = FileSystems.newFileSystem(JARURI, env)) {
+            expectedJarPerms = PosixFilePermissions.toString(
+                    Files.getPosixFilePermissions(jarfs.getPath("test_1")));
+        }
+    }
+
+    private static void verifyFilePermissions(URI u, boolean containAttributes) throws Exception {
+        count = 0;
+        for (String s : perms) {
+            file = Path.of("test_" + count++);
+            checkEntryAttributes(u, file, s, containAttributes);
+        }
+    }
+
+    private static void checkEntryAttributes(URI uri, Path file,
+                                             String expectedPerms, boolean containAttributes) throws Exception {
+        try (FileSystem zipfs = FileSystems.newFileSystem(uri, Map.of("enablePosixFileAttributes", "true"))) {
+            Path p = zipfs.getPath(file.getFileName().toString());
+            Set<PosixFilePermission> permsSet = Files.getPosixFilePermissions(p);
+            String actualPerms = PosixFilePermissions.toString(permsSet);
+            if (containAttributes) {
+                if (!expectedPerms.equals(actualPerms)) {
+                    throw new RuntimeException("Unexpected permissions for: " + file + ". Received: " + actualPerms);
+                }
+            } else {
+                if (!actualPerms.equals(expectedJarPerms)) {
+                    throw new RuntimeException("Expected default permissions for " + file);
+                }
+            }
+        }
+    }
+}
diff a/test/jdk/sun/security/util/Resources/Usages.java b/test/jdk/sun/security/util/Resources/Usages.java
--- a/test/jdk/sun/security/util/Resources/Usages.java
+++ b/test/jdk/sun/security/util/Resources/Usages.java
@@ -73,11 +73,11 @@
     // rb.getString(). Used by keytool, jarsigner, and KeyStoreUtil.
     static Pattern RB_GETSTRING = Pattern.compile(
             "(?m)rb[ \\n]*\\.getString[ \\n]*\\([ \\n]*\"(.*?)\"\\)");
 
     static Pattern EVENT_OCSP_CRL = Pattern.compile(
-            "Event\\.report\\(\"(.*?)\",");
+            "Event\\.report\\(.*,\"(.*?)\",");
 
     // Command and Option enums in keytool
     static Pattern KT_ENUM = Pattern.compile("\\n +[A-Z]+\\(.*\"(.*)\"");
 
     // ResourceMgr.getAuthResourceString

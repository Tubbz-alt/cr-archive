<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.jarsigner;
  27 
  28 import java.io.*;
  29 import java.net.UnknownHostException;
  30 import java.security.cert.CertPathValidatorException;
  31 import java.security.cert.PKIXBuilderParameters;
  32 import java.util.*;
  33 import java.util.stream.Collectors;
  34 import java.util.zip.*;
  35 import java.util.jar.*;
  36 import java.net.URI;
  37 import java.text.Collator;
  38 import java.text.MessageFormat;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.X509Certificate;
  41 import java.security.cert.CertificateException;
  42 import java.security.*;
  43 
  44 import java.net.SocketTimeoutException;
  45 import java.net.URL;
  46 import java.security.cert.CertPath;
  47 import java.security.cert.CertificateExpiredException;
  48 import java.security.cert.CertificateFactory;
  49 import java.security.cert.CertificateNotYetValidException;
  50 import java.security.cert.TrustAnchor;
  51 import java.util.Map.Entry;
  52 
<a name="1" id="anc1"></a>

  53 import jdk.security.jarsigner.JarSigner;
  54 import jdk.security.jarsigner.JarSignerException;
  55 import sun.security.pkcs.PKCS7;
  56 import sun.security.pkcs.SignerInfo;
  57 import sun.security.timestamp.TimestampToken;
  58 import sun.security.tools.KeyStoreUtil;
  59 import sun.security.validator.Validator;
  60 import sun.security.validator.ValidatorException;
  61 import sun.security.x509.*;
  62 import sun.security.util.*;
  63 
  64 
  65 /**
  66  * &lt;p&gt;The jarsigner utility.
  67  *
  68  * The exit codes for the main method are:
  69  *
  70  * 0: success
  71  * 1: any error that the jar cannot be signed or verified, including:
  72  *      keystore loading error
  73  *      TSP communication error
  74  *      jarsigner command line error...
  75  * otherwise: error codes from -strict
  76  *
  77  * @author Roland Schemers
  78  * @author Jan Luehe
  79  */
  80 public class Main {
  81 
  82     // for i18n
  83     private static final java.util.ResourceBundle rb =
  84         java.util.ResourceBundle.getBundle
  85         (&quot;sun.security.tools.jarsigner.Resources&quot;);
  86     private static final Collator collator = Collator.getInstance();
  87     static {
  88         // this is for case insensitive string comparisions
  89         collator.setStrength(Collator.PRIMARY);
  90     }
  91 
  92     private static final String NONE = &quot;NONE&quot;;
  93     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  94 
  95     private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds
  96     private static final long ONE_YEAR = 366*24*60*60*1000L;
  97 
  98     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
  99             new DisabledAlgorithmConstraints(
 100                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 101 
 102     private static final DisabledAlgorithmConstraints LEGACY_CHECK =
 103             new DisabledAlgorithmConstraints(
 104                     DisabledAlgorithmConstraints.PROPERTY_SECURITY_LEGACY_ALGS);
 105 
 106     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET = Collections
 107             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 108     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 109             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 110 
<a name="2" id="anc2"></a>

 111     static final String VERSION = &quot;1.0&quot;;
 112 
 113     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
 114     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
 115     // signer is not in alias list
 116     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 117 
<a name="3" id="anc3"></a>

 118     // Attention:
 119     // This is the entry that get launched by the security tool jarsigner.
 120     public static void main(String args[]) throws Exception {
 121         Main js = new Main();
 122         js.run(args);
 123     }
 124 
 125     X509Certificate[] certChain;    // signer&#39;s cert chain (when composing)
 126     PrivateKey privateKey;          // private key
 127     KeyStore store;                 // the keystore specified by -keystore
 128                                     // or the default keystore, never null
 129 
 130     String keystore; // key store file
 131     boolean nullStream = false; // null keystore input stream (NONE)
 132     boolean token = false; // token-based keystore
 133     String jarfile;  // jar files to sign or verify
 134     String alias;    // alias to sign jar with
 135     List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
 136     char[] storepass; // keystore password
 137     boolean protectedPath; // protected authentication path
 138     String storetype; // keystore type
 139     String providerName; // provider name
 140     List&lt;String&gt; providers = null; // list of provider names
 141     List&lt;String&gt; providerClasses = null; // list of provider classes
 142     // arguments for provider constructors
 143     HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
 144     char[] keypass; // private key password
 145     String sigfile; // name of .SF file
 146     String sigalg; // name of signature algorithm
 147     String digestalg; // name of digest algorithm
 148     String signedjar; // output filename
 149     String tsaUrl; // location of the Timestamping Authority
 150     String tsaAlias; // alias for the Timestamping Authority&#39;s certificate
 151     String altCertChain; // file to read alternative cert chain from
 152     String tSAPolicyID;
 153     String tSADigestAlg;
 154     boolean verify = false; // verify the jar
 155     String verbose = null; // verbose output when signing/verifying
 156     boolean showcerts = false; // show certs when verifying
 157     boolean debug = false; // debug
 158     boolean signManifest = true; // &quot;sign&quot; the whole manifest
 159     boolean externalSF = true; // leave the .SF out of the PKCS7 block
 160     boolean strict = false;  // treat warnings as error
 161     boolean revocationCheck = false; // Revocation check flag
 162 
 163     // read zip entry raw bytes
 164     private String altSignerClass = null;
 165     private String altSignerClasspath = null;
 166     private ZipFile zipFile = null;
 167 
 168     // Informational warnings
 169     private boolean hasExpiringCert = false;
 170     private boolean hasExpiringTsaCert = false;
 171     private boolean noTimestamp = true;
 172 
 173     // Expiration date. The value could be null if signed by a trusted cert.
 174     private Date expireDate = null;
 175     private Date tsaExpireDate = null;
 176 
 177     // If there is a time stamp block inside the PKCS7 block file
 178     boolean hasTimestampBlock = false;
 179 
 180     private PublicKey weakPublicKey = null;
 181     private boolean disabledAlgFound = false;
 182     private String legacyDigestAlg = null;
 183     private String legacyTsaDigestAlg = null;
 184     private String legacySigAlg = null;
 185 
 186     // Severe warnings.
 187 
 188     // jarsigner used to check signer cert chain validity and key usages
 189     // itself and set various warnings. Later CertPath validation is
 190     // added but chainNotValidated is only flagged when no other existing
 191     // warnings are set. TSA cert chain check is added separately and
 192     // only tsaChainNotValidated is set, i.e. has no affect on hasExpiredCert,
 193     // notYetValidCert, or any badXyzUsage.
 194 
 195     private int legacyAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg, 8. key
 196     private int disabledAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg, 8. key
 197     private boolean hasExpiredCert = false;
 198     private boolean hasExpiredTsaCert = false;
 199     private boolean notYetValidCert = false;
 200     private boolean chainNotValidated = false;
 201     private boolean tsaChainNotValidated = false;
 202     private boolean notSignedByAlias = false;
 203     private boolean aliasNotInStore = false;
 204     private boolean hasUnsignedEntry = false;
 205     private boolean badKeyUsage = false;
 206     private boolean badExtendedKeyUsage = false;
 207     private boolean badNetscapeCertType = false;
 208     private boolean signerSelfSigned = false;
 209 
 210     private Throwable chainNotValidatedReason = null;
 211     private Throwable tsaChainNotValidatedReason = null;
 212 
 213     PKIXBuilderParameters pkixParameters;
 214     Set&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
 215 
 216     public void run(String args[]) {
 217         try {
 218             args = parseArgs(args);
 219 
 220             // Try to load and install the specified providers
 221             if (providers != null) {
 222                 for (String provName: providers) {
 223                     try {
 224                         KeyStoreUtil.loadProviderByName(provName,
 225                                 providerArgs.get(provName));
 226                         if (debug) {
 227                             System.out.println(&quot;loadProviderByName: &quot; + provName);
 228                         }
 229                     } catch (IllegalArgumentException e) {
 230                         throw new Exception(String.format(rb.getString(
 231                                 &quot;provider.name.not.found&quot;), provName));
 232                     }
 233                 }
 234             }
 235 
 236             if (providerClasses != null) {
 237                 ClassLoader cl = ClassLoader.getSystemClassLoader();
 238                 for (String provClass: providerClasses) {
 239                     try {
 240                         KeyStoreUtil.loadProviderByClass(provClass,
 241                                 providerArgs.get(provClass), cl);
 242                         if (debug) {
 243                             System.out.println(&quot;loadProviderByClass: &quot; + provClass);
 244                         }
 245                     } catch (ClassCastException cce) {
 246                         throw new Exception(String.format(rb.getString(
 247                                 &quot;provclass.not.a.provider&quot;), provClass));
 248                     } catch (IllegalArgumentException e) {
 249                         throw new Exception(String.format(rb.getString(
 250                                 &quot;provider.class.not.found&quot;), provClass), e.getCause());
 251                     }
 252                 }
 253             }
 254 
 255             if (verify) {
 256                 try {
 257                     loadKeyStore(keystore, false);
 258                 } catch (Exception e) {
 259                     if ((keystore != null) || (storepass != null)) {
 260                         System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
 261                                         e.getMessage());
 262                         if (debug) {
 263                             e.printStackTrace();
 264                         }
 265                         System.exit(1);
 266                     }
 267                 }
 268                 /*              if (debug) {
 269                     SignatureFileVerifier.setDebug(true);
 270                     ManifestEntryVerifier.setDebug(true);
 271                 }
 272                 */
 273                 verifyJar(jarfile);
 274             } else {
 275                 loadKeyStore(keystore, true);
 276                 getAliasInfo(alias);
 277 
 278                 signJar(jarfile, alias);
 279             }
 280         } catch (Exception e) {
 281             System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
 282             if (debug) {
 283                 e.printStackTrace();
 284             }
 285             System.exit(1);
 286         } finally {
 287             // zero-out private key password
 288             if (keypass != null) {
 289                 Arrays.fill(keypass, &#39; &#39;);
 290                 keypass = null;
 291             }
 292             // zero-out keystore password
 293             if (storepass != null) {
 294                 Arrays.fill(storepass, &#39; &#39;);
 295                 storepass = null;
 296             }
<a name="4" id="anc4"></a><span class="line-modified"> 297             Event.clearReportListener();</span>
 298         }
 299 
 300         if (strict) {
 301             int exitCode = 0;
 302             if (disabledAlg != 0 || chainNotValidated || hasExpiredCert
 303                     || hasExpiredTsaCert || notYetValidCert || signerSelfSigned) {
 304                 exitCode |= 4;
 305             }
 306             if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
 307                 exitCode |= 8;
 308             }
 309             if (hasUnsignedEntry) {
 310                 exitCode |= 16;
 311             }
 312             if (notSignedByAlias || aliasNotInStore) {
 313                 exitCode |= 32;
 314             }
 315             if (tsaChainNotValidated) {
 316                 exitCode |= 64;
 317             }
 318             if (exitCode != 0) {
 319                 System.exit(exitCode);
 320             }
 321         }
 322     }
 323 
 324     /*
 325      * Parse command line arguments.
 326      */
 327     String[] parseArgs(String args[]) throws Exception {
 328         /* parse flags */
 329         int n = 0;
 330 
 331         if (args.length == 0) fullusage();
 332 
 333         String confFile = null;
 334         String command = &quot;-sign&quot;;
 335         for (n=0; n &lt; args.length; n++) {
 336             if (collator.compare(args[n], &quot;-verify&quot;) == 0) {
 337                 command = &quot;-verify&quot;;
 338             } else if (collator.compare(args[n], &quot;-conf&quot;) == 0) {
 339                 if (n == args.length - 1) {
 340                     usageNoArg();
 341                 }
 342                 confFile = args[++n];
 343             }
 344         }
 345 
 346         if (confFile != null) {
 347             args = KeyStoreUtil.expandArgs(
 348                     &quot;jarsigner&quot;, confFile, command, null, args);
 349         }
 350 
 351         debug = Arrays.stream(args).anyMatch(
 352                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 353 
 354         if (debug) {
 355             // No need to localize debug output
 356             System.out.println(&quot;Command line args: &quot; +
 357                     Arrays.toString(args));
 358         }
 359 
 360         for (n=0; n &lt; args.length; n++) {
 361 
 362             String flags = args[n];
 363             String modifier = null;
 364 
 365             if (flags.startsWith(&quot;-&quot;)) {
 366                 int pos = flags.indexOf(&#39;:&#39;);
 367                 if (pos &gt; 0) {
 368                     modifier = flags.substring(pos+1);
 369                     flags = flags.substring(0, pos);
 370                 }
 371             }
 372 
 373             if (!flags.startsWith(&quot;-&quot;)) {
 374                 if (jarfile == null) {
 375                     jarfile = flags;
 376                 } else {
 377                     alias = flags;
 378                     ckaliases.add(alias);
 379                 }
 380             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 381                 if (++n == args.length) usageNoArg();
 382             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 383                 if (++n == args.length) usageNoArg();
 384                 keystore = args[n];
 385             } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
 386                 if (++n == args.length) usageNoArg();
 387                 storepass = getPass(modifier, args[n]);
 388             } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
 389                 if (++n == args.length) usageNoArg();
 390                 storetype = args[n];
 391             } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
 392                 if (++n == args.length) usageNoArg();
 393                 providerName = args[n];
 394             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 395                         collator.compare(flags, &quot;-providerClass&quot;) == 0) {
 396                 if (++n == args.length) usageNoArg();
 397                 if (providerClasses == null) {
 398                     providerClasses = new ArrayList&lt;&gt;(3);
 399                 }
 400                 providerClasses.add(args[n]);
 401 
 402                 if (args.length &gt; (n+1)) {
 403                     flags = args[n+1];
 404                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 405                         if (args.length == (n+2)) usageNoArg();
 406                         providerArgs.put(args[n], args[n+2]);
 407                         n += 2;
 408                     }
 409                 }
 410             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 411                 if (++n == args.length) usageNoArg();
 412                 if (providers == null) {
 413                     providers = new ArrayList&lt;&gt;(3);
 414                 }
 415                 providers.add(args[n]);
 416 
 417                 if (args.length &gt; (n+1)) {
 418                     flags = args[n+1];
 419                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 420                         if (args.length == (n+2)) usageNoArg();
 421                         providerArgs.put(args[n], args[n+2]);
 422                         n += 2;
 423                     }
 424                 }
 425             } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
 426                 protectedPath = true;
 427             } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
 428                 if (++n == args.length) usageNoArg();
 429                 altCertChain = args[n];
 430             } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
 431                 if (++n == args.length) usageNoArg();
 432                 tSAPolicyID = args[n];
 433             } else if (collator.compare(flags, &quot;-tsadigestalg&quot;) ==0) {
 434                 if (++n == args.length) usageNoArg();
 435                 tSADigestAlg = args[n];
 436             } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
 437                 // Already processed
 438             } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
 439                 if (++n == args.length) usageNoArg();
 440                 keypass = getPass(modifier, args[n]);
 441             } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
 442                 if (++n == args.length) usageNoArg();
 443                 sigfile = args[n];
 444             } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
 445                 if (++n == args.length) usageNoArg();
 446                 signedjar = args[n];
 447             } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
 448                 if (++n == args.length) usageNoArg();
 449                 tsaUrl = args[n];
 450             } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
 451                 if (++n == args.length) usageNoArg();
 452                 tsaAlias = args[n];
 453             } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
 454                 if (++n == args.length) usageNoArg();
 455                 altSignerClass = args[n];
 456                 System.err.println(
 457                         rb.getString(&quot;This.option.is.forremoval&quot;) +
 458                                 &quot;-altsigner&quot;);
 459             } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
 460                 if (++n == args.length) usageNoArg();
 461                 altSignerClasspath = args[n];
 462                 System.err.println(
 463                         rb.getString(&quot;This.option.is.forremoval&quot;) +
 464                                 &quot;-altsignerpath&quot;);
 465             } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
 466                 signManifest = false;
 467             } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
 468                 externalSF = false;
 469             } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
 470                 verify = true;
 471             } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
 472                 verbose = (modifier != null) ? modifier : &quot;all&quot;;
 473             } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
 474                 if (++n == args.length) usageNoArg();
 475                 sigalg = args[n];
 476             } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
 477                 if (++n == args.length) usageNoArg();
 478                 digestalg = args[n];
 479             } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
 480                 showcerts = true;
 481             } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
 482                 strict = true;
 483             } else if (collator.compare(flags, &quot;-?&quot;) == 0 ||
 484                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 485                        collator.compare(flags, &quot;--help&quot;) == 0 ||
 486                        // -help: legacy.
 487                        collator.compare(flags, &quot;-help&quot;) == 0) {
 488                 fullusage();
 489             } else if (collator.compare(flags, &quot;-revCheck&quot;) == 0) {
 490                 revocationCheck = true;
 491             } else {
 492                 System.err.println(
 493                         rb.getString(&quot;Illegal.option.&quot;) + flags);
 494                 usage();
 495             }
 496         }
 497 
 498         // -certs must always be specified with -verbose
 499         if (verbose == null) showcerts = false;
 500 
 501         if (jarfile == null) {
 502             System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
 503             usage();
 504         }
 505         if (!verify &amp;&amp; alias == null) {
 506             System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
 507             usage();
 508         }
 509         if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
 510             System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
 511             usage();
 512         }
 513 
 514         if (storetype == null) {
 515             storetype = KeyStore.getDefaultType();
 516         }
 517         storetype = KeyStoreUtil.niceStoreTypeName(storetype);
 518 
 519         try {
 520             if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
 521                     new File(jarfile).getCanonicalPath())) {
 522                 signedjar = null;
 523             }
 524         } catch (IOException ioe) {
 525             // File system error?
 526             // Just ignore it.
 527         }
 528 
 529         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 530                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 531             token = true;
 532             if (keystore == null) {
 533                 keystore = NONE;
 534             }
 535         }
 536 
 537         if (NONE.equals(keystore)) {
 538             nullStream = true;
 539         }
 540 
 541         if (token &amp;&amp; !nullStream) {
 542             System.err.println(MessageFormat.format(rb.getString
 543                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 544             usage();
 545         }
 546 
 547         if (token &amp;&amp; keypass != null) {
 548             System.err.println(MessageFormat.format(rb.getString
 549                 (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 550             usage();
 551         }
 552 
 553         if (protectedPath) {
 554             if (storepass != null || keypass != null) {
 555                 System.err.println(rb.getString
 556                         (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
 557                 usage();
 558             }
 559         }
 560         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 561             if (storepass != null || keypass != null) {
 562                 System.err.println(rb.getString
 563                         (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
 564                 usage();
 565             }
 566         }
 567         return args;
 568     }
 569 
 570     static char[] getPass(String modifier, String arg) {
 571         char[] output =
 572             KeyStoreUtil.getPassWithModifier(modifier, arg, rb, collator);
 573         if (output != null) return output;
 574         usage();
 575         return null;    // Useless, usage() already exit
 576     }
 577 
 578     static void usageNoArg() {
 579         System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
 580         usage();
 581     }
 582 
 583     static void usage() {
 584         System.out.println();
 585         System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
 586         System.exit(1);
 587     }
 588 
 589     static void fullusage() {
 590         System.out.println(rb.getString
 591                 (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
 592         System.out.println(rb.getString
 593                 (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
 594         System.out.println();
 595         System.out.println(rb.getString
 596                 (&quot;.keystore.url.keystore.location&quot;));
 597         System.out.println();
 598         System.out.println(rb.getString
 599                 (&quot;.storepass.password.password.for.keystore.integrity&quot;));
 600         System.out.println();
 601         System.out.println(rb.getString
 602                 (&quot;.storetype.type.keystore.type&quot;));
 603         System.out.println();
 604         System.out.println(rb.getString
 605                 (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
 606         System.out.println();
 607         System.out.println(rb.getString
 608                 (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
 609         System.out.println();
 610         System.out.println(rb.getString
 611                 (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
 612         System.out.println();
 613         System.out.println(rb.getString
 614                 (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
 615         System.out.println();
 616         System.out.println(rb.getString
 617                 (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
 618         System.out.println();
 619         System.out.println(rb.getString
 620                 (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
 621         System.out.println();
 622         System.out.println(rb.getString
 623                 (&quot;.verify.verify.a.signed.JAR.file&quot;));
 624         System.out.println();
 625         System.out.println(rb.getString
 626                 (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
 627         System.out.println(rb.getString
 628                 (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
 629         System.out.println();
 630         System.out.println(rb.getString
 631                 (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
 632         System.out.println();
 633         System.out.println(rb.getString
 634                 (&quot;.certs.revocation.check&quot;));
 635         System.out.println();
 636         System.out.println(rb.getString
 637                 (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
 638         System.out.println();
 639         System.out.println(rb.getString
 640                 (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
 641         System.out.println();
 642         System.out.println(rb.getString
 643                 (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
 644         System.out.println();
 645         System.out.println(rb.getString
 646                 (&quot;.tsadigestalg.algorithm.of.digest.data.in.timestamping.request&quot;));
 647         System.out.println();
 648         System.out.println(rb.getString
 649                 (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
 650         System.out.println();
 651         System.out.println(rb.getString
 652                 (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
 653         System.out.println();
 654         System.out.println(rb.getString
 655                 (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
 656         System.out.println();
 657         System.out.println(rb.getString
 658                 (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
 659         System.out.println();
 660         System.out.println(rb.getString
 661                 (&quot;.protected.keystore.has.protected.authentication.path&quot;));
 662         System.out.println();
 663         System.out.println(rb.getString
 664                 (&quot;.providerName.name.provider.name&quot;));
 665         System.out.println();
 666         System.out.println(rb.getString
 667                 (&quot;.add.provider.option&quot;));
 668         System.out.println(rb.getString
 669                 (&quot;.providerArg.option.1&quot;));
 670         System.out.println();
 671         System.out.println(rb.getString
 672                 (&quot;.providerClass.option&quot;));
 673         System.out.println(rb.getString
 674                 (&quot;.providerArg.option.2&quot;));
 675         System.out.println();
 676         System.out.println(rb.getString
 677                 (&quot;.strict.treat.warnings.as.errors&quot;));
 678         System.out.println();
 679         System.out.println(rb.getString
 680                 (&quot;.conf.url.specify.a.pre.configured.options.file&quot;));
 681         System.out.println();
 682         System.out.println(rb.getString
 683                 (&quot;.print.this.help.message&quot;));
 684         System.out.println();
 685 
 686         System.exit(0);
 687     }
 688 
 689     void verifyJar(String jarName)
 690         throws Exception
 691     {
 692         boolean anySigned = false;  // if there exists entry inside jar signed
 693         JarFile jf = null;
 694         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 695         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 696         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 697         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 698 
 699         try {
 700             jf = new JarFile(jarName, true);
 701             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 702             byte[] buffer = new byte[8192];
 703 
 704             String suffix1 = &quot;-Digest-Manifest&quot;;
 705             String suffix2 = &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS;
 706 
 707             int suffixLength1 = suffix1.length();
 708             int suffixLength2 = suffix2.length();
 709 
 710             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 711             while (entries.hasMoreElements()) {
 712                 JarEntry je = entries.nextElement();
 713                 entriesVec.addElement(je);
 714                 try (InputStream is = jf.getInputStream(je)) {
 715                     String name = je.getName();
 716                     if (signatureRelated(name)
 717                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 718                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 719                                 name.lastIndexOf(&#39;.&#39;));
 720                         try {
 721                             if (name.endsWith(&quot;.SF&quot;)) {
 722                                 Manifest sf = new Manifest(is);
 723                                 boolean found = false;
 724                                 for (Object obj : sf.getMainAttributes().keySet()) {
 725                                     String key = obj.toString();
 726                                     if (key.endsWith(suffix1)) {
 727                                         digestMap.put(alias, key.substring(
 728                                                 0, key.length() - suffixLength1));
 729                                         found = true;
 730                                         break;
 731                                     } else if (key.endsWith(suffix2)) {
 732                                         digestMap.put(alias, key.substring(
 733                                                 0, key.length() - suffixLength2));
 734                                         found = true;
 735                                         break;
 736                                     }
 737                                 }
 738                                 if (!found) {
 739                                     unparsableSignatures.putIfAbsent(alias,
 740                                         String.format(
 741                                             rb.getString(&quot;history.unparsable&quot;),
 742                                             name));
 743                                 }
 744                             } else {
 745                                 sigNameMap.put(alias, name);
 746                                 sigMap.put(alias, new PKCS7(is));
 747                             }
 748                         } catch (IOException ioe) {
 749                             unparsableSignatures.putIfAbsent(alias, String.format(
 750                                     rb.getString(&quot;history.unparsable&quot;), name));
 751                         }
 752                     } else {
 753                         while (is.read(buffer, 0, buffer.length) != -1) {
 754                             // we just read. this will throw a SecurityException
 755                             // if  a signature/digest check fails.
 756                         }
 757                     }
 758                 }
 759             }
 760 
 761             Manifest man = jf.getManifest();
 762             boolean hasSignature = false;
 763 
 764             // The map to record display info, only used when -verbose provided
 765             //      key: signer info string
 766             //      value: the list of files with common key
 767             Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();
 768 
 769             if (man != null) {
 770                 if (verbose != null) System.out.println();
 771                 Enumeration&lt;JarEntry&gt; e = entriesVec.elements();
 772 
 773                 String tab = rb.getString(&quot;6SPACE&quot;);
 774 
 775                 while (e.hasMoreElements()) {
 776                     JarEntry je = e.nextElement();
 777                     String name = je.getName();
 778 
<a name="5" id="anc5"></a>


 779                     hasSignature = hasSignature
 780                             || SignatureFileVerifier.isBlockOrSF(name);
 781 
 782                     CodeSigner[] signers = je.getCodeSigners();
 783                     boolean isSigned = (signers != null);
 784                     anySigned |= isSigned;
 785                     hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
 786                                         &amp;&amp; !signatureRelated(name);
 787 
 788                     int inStoreWithAlias = inKeyStore(signers);
 789 
 790                     boolean inStore = (inStoreWithAlias &amp; IN_KEYSTORE) != 0;
 791 
 792                     notSignedByAlias |= (inStoreWithAlias &amp; NOT_ALIAS) != 0;
 793                     if (keystore != null) {
 794                         aliasNotInStore |= isSigned &amp;&amp; !inStore;
 795                     }
 796 
 797                     // Only used when -verbose provided
 798                     StringBuffer sb = null;
 799                     if (verbose != null) {
 800                         sb = new StringBuffer();
 801                         boolean inManifest =
 802                             ((man.getAttributes(name) != null) ||
 803                              (man.getAttributes(&quot;./&quot;+name) != null) ||
 804                              (man.getAttributes(&quot;/&quot;+name) != null));
 805                         sb.append(isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;))
 806                                 .append(inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;))
 807                                 .append(inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;))
 808                                 .append((inStoreWithAlias &amp; NOT_ALIAS) != 0 ? &#39;X&#39; : &#39; &#39;)
 809                                 .append(rb.getString(&quot;SPACE&quot;));
 810                         sb.append(&#39;|&#39;);
 811                     }
 812 
 813                     // When -certs provided, display info has extra empty
 814                     // lines at the beginning and end.
 815                     if (isSigned) {
 816                         if (showcerts) sb.append(&#39;\n&#39;);
 817                         for (CodeSigner signer: signers) {
 818                             // signerInfo() must be called even if -verbose
 819                             // not provided. The method updates various
 820                             // warning flags.
 821                             String si = signerInfo(signer, tab);
 822                             if (showcerts) {
 823                                 sb.append(si);
 824                                 sb.append(&#39;\n&#39;);
 825                             }
 826                         }
 827                     } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
 828                         // Print no info for unsigned entries when -verbose:all,
 829                         // to be consistent with old behavior.
 830                         if (signatureRelated(name)) {
 831                             sb.append(&#39;\n&#39;)
 832                                     .append(tab)
 833                                     .append(rb
 834                                             .getString(&quot;.Signature.related.entries.&quot;))
 835                                     .append(&quot;\n\n&quot;);
 836                         } else {
 837                             sb.append(&#39;\n&#39;).append(tab)
 838                                     .append(rb.getString(&quot;.Unsigned.entries.&quot;))
 839                                     .append(&quot;\n\n&quot;);
 840                         }
 841                     }
 842 
 843                     if (verbose != null) {
 844                         String label = sb.toString();
 845                         if (signatureRelated(name)) {
 846                             // Entries inside META-INF and other unsigned
 847                             // entries are grouped separately.
 848                             label = &quot;-&quot; + label;
 849                         }
 850 
 851                         // The label finally contains 2 parts separated by &#39;|&#39;:
 852                         // The legend displayed before the entry names, and
 853                         // the cert info (if -certs specified).
 854 
 855                         if (!output.containsKey(label)) {
 856                             output.put(label, new ArrayList&lt;String&gt;());
 857                         }
 858 
 859                         StringBuilder fb = new StringBuilder();
 860                         String s = Long.toString(je.getSize());
 861                         for (int i = 6 - s.length(); i &gt; 0; --i) {
 862                             fb.append(&#39; &#39;);
 863                         }
 864                         fb.append(s).append(&#39; &#39;).
 865                                 append(new Date(je.getTime()).toString());
 866                         fb.append(&#39; &#39;).append(name);
 867 
 868                         output.get(label).add(fb.toString());
 869                     }
 870                 }
 871             }
 872             if (verbose != null) {
 873                 for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
 874                     List&lt;String&gt; files = s.getValue();
 875                     String key = s.getKey();
 876                     if (key.charAt(0) == &#39;-&#39;) { // the signature-related group
 877                         key = key.substring(1);
 878                     }
 879                     int pipe = key.indexOf(&#39;|&#39;);
 880                     if (verbose.equals(&quot;all&quot;)) {
 881                         for (String f: files) {
 882                             System.out.println(key.substring(0, pipe) + f);
 883                             System.out.printf(key.substring(pipe+1));
 884                         }
 885                     } else {
 886                         if (verbose.equals(&quot;grouped&quot;)) {
 887                             for (String f: files) {
 888                                 System.out.println(key.substring(0, pipe) + f);
 889                             }
 890                         } else if (verbose.equals(&quot;summary&quot;)) {
 891                             System.out.print(key.substring(0, pipe));
 892                             if (files.size() &gt; 1) {
 893                                 System.out.println(files.get(0) + &quot; &quot; +
 894                                         String.format(rb.getString(
 895                                         &quot;.and.d.more.&quot;), files.size()-1));
 896                             } else {
 897                                 System.out.println(files.get(0));
 898                             }
 899                         }
 900                         System.out.printf(key.substring(pipe+1));
 901                     }
 902                 }
 903                 System.out.println();
 904                 System.out.println(rb.getString(
 905                     &quot;.s.signature.was.verified.&quot;));
 906                 System.out.println(rb.getString(
 907                     &quot;.m.entry.is.listed.in.manifest&quot;));
 908                 System.out.println(rb.getString(
 909                     &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
 910                 if (ckaliases.size() &gt; 0) {
 911                     System.out.println(rb.getString(
 912                         &quot;.X.not.signed.by.specified.alias.es.&quot;));
 913                 }
 914             }
 915             if (man == null) {
 916                 System.out.println();
 917                 System.out.println(rb.getString(&quot;no.manifest.&quot;));
 918             }
 919 
 920             // If signer is a trusted cert or private entry in user&#39;s own
 921             // keystore, it can be self-signed. Please note aliasNotInStore
 922             // is always false when ~/.keystore is used.
 923             if (!aliasNotInStore &amp;&amp; keystore != null) {
 924                 signerSelfSigned = false;
 925             }
 926 
 927             // Even if the verbose option is not specified, all out strings
 928             // must be generated so disabledAlgFound can be updated.
 929             if (!digestMap.isEmpty()
 930                     || !sigMap.isEmpty()
 931                     || !unparsableSignatures.isEmpty()) {
 932                 if (verbose != null) {
 933                     System.out.println();
 934                 }
 935                 for (String s : sigMap.keySet()) {
 936                     if (!digestMap.containsKey(s)) {
 937                         unparsableSignatures.putIfAbsent(s, String.format(
 938                                 rb.getString(&quot;history.nosf&quot;), s));
 939                     }
 940                 }
 941                 for (String s : digestMap.keySet()) {
 942                     PKCS7 p7 = sigMap.get(s);
 943                     if (p7 != null) {
 944                         String history;
 945                         try {
 946                             SignerInfo si = p7.getSignerInfos()[0];
 947                             X509Certificate signer = si.getCertificate(p7);
 948                             String digestAlg = digestMap.get(s);
 949                             String sigAlg = AlgorithmId.makeSigAlg(
 950                                     si.getDigestAlgorithmId().getName(),
 951                                     si.getDigestEncryptionAlgorithmId().getName());
 952                             PublicKey key = signer.getPublicKey();
 953                             PKCS7 tsToken = si.getTsToken();
 954                             if (tsToken != null) {
 955                                 hasTimestampBlock = true;
 956                                 SignerInfo tsSi = tsToken.getSignerInfos()[0];
 957                                 X509Certificate tsSigner = tsSi.getCertificate(tsToken);
 958                                 byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
 959                                 TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
 960                                 PublicKey tsKey = tsSigner.getPublicKey();
 961                                 String tsDigestAlg = tsTokenInfo.getHashAlgorithm().getName();
 962                                 String tsSigAlg = AlgorithmId.makeSigAlg(
 963                                         tsSi.getDigestAlgorithmId().getName(),
 964                                         tsSi.getDigestEncryptionAlgorithmId().getName());
 965                                 Calendar c = Calendar.getInstance(
 966                                         TimeZone.getTimeZone(&quot;UTC&quot;),
 967                                         Locale.getDefault(Locale.Category.FORMAT));
 968                                 c.setTime(tsTokenInfo.getDate());
 969                                 history = String.format(
 970                                         rb.getString(&quot;history.with.ts&quot;),
 971                                         signer.getSubjectX500Principal(),
 972                                         verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),
 973                                         verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),
 974                                         verifyWithWeak(key),
 975                                         c,
 976                                         tsSigner.getSubjectX500Principal(),
 977                                         verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true),
 978                                         verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true),
 979                                         verifyWithWeak(tsKey));
 980                             } else {
 981                                 history = String.format(
 982                                         rb.getString(&quot;history.without.ts&quot;),
 983                                         signer.getSubjectX500Principal(),
 984                                         verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),
 985                                         verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),
 986                                         verifyWithWeak(key));
 987                             }
 988                         } catch (Exception e) {
 989                             // The only usage of sigNameMap, remember the name
 990                             // of the block file if it&#39;s invalid.
 991                             history = String.format(
 992                                     rb.getString(&quot;history.unparsable&quot;),
 993                                     sigNameMap.get(s));
 994                         }
 995                         if (verbose != null) {
 996                             System.out.println(history);
 997                         }
 998                     } else {
 999                         unparsableSignatures.putIfAbsent(s, String.format(
1000                                 rb.getString(&quot;history.nobk&quot;), s));
1001                     }
1002                 }
1003                 if (verbose != null) {
1004                     for (String s : unparsableSignatures.keySet()) {
1005                         System.out.println(unparsableSignatures.get(s));
1006                     }
1007                 }
1008             }
1009             System.out.println();
1010 
1011             if (!anySigned) {
1012                 if (disabledAlgFound) {
1013                     if (verbose != null) {
1014                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak.verbose&quot;));
1015                         System.out.println(&quot;\n  &quot; +
1016                                 DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS +
1017                                 &quot;=&quot; + Security.getProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS));
1018                     } else {
1019                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak&quot;));
1020                     }
1021                 } else if (hasSignature) {
1022                     System.out.println(rb.getString(&quot;jar.treated.unsigned&quot;));
1023                 } else {
1024                     System.out.println(rb.getString(&quot;jar.is.unsigned&quot;));
1025                 }
1026             } else {
1027                 displayMessagesAndResult(false);
1028             }
1029             return;
1030         } catch (Exception e) {
1031             System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
1032             if (debug) {
1033                 e.printStackTrace();
1034             }
1035         } finally { // close the resource
1036             if (jf != null) {
1037                 jf.close();
1038             }
1039         }
1040 
1041         System.exit(1);
1042     }
1043 
1044     private void displayMessagesAndResult(boolean isSigning) {
1045         String result;
1046         List&lt;String&gt; errors = new ArrayList&lt;&gt;();
1047         List&lt;String&gt; warnings = new ArrayList&lt;&gt;();
1048         List&lt;String&gt; info = new ArrayList&lt;&gt;();
1049 
1050         boolean signerNotExpired = expireDate == null
1051                 || expireDate.after(new Date());
1052 
1053         if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
1054                 notYetValidCert || chainNotValidated || hasExpiredCert ||
1055                 hasUnsignedEntry || signerSelfSigned || (legacyAlg != 0) ||
1056                 (disabledAlg != 0) || aliasNotInStore || notSignedByAlias ||
<a name="6" id="anc6"></a><span class="line-modified">1057                 tsaChainNotValidated ||</span>
1058                 (hasExpiredTsaCert &amp;&amp; !signerNotExpired)) {
1059 
1060             if (strict) {
1061                 result = isSigning
1062                         ? rb.getString(&quot;jar.signed.with.signer.errors.&quot;)
1063                         : rb.getString(&quot;jar.verified.with.signer.errors.&quot;);
1064             } else {
1065                 result = isSigning
1066                         ? rb.getString(&quot;jar.signed.&quot;)
1067                         : rb.getString(&quot;jar.verified.&quot;);
1068             }
1069 
1070             if (badKeyUsage) {
1071                 errors.add(isSigning
1072                         ? rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1073                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1074             }
1075 
1076             if (badExtendedKeyUsage) {
1077                 errors.add(isSigning
1078                         ? rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1079                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1080             }
1081 
1082             if (badNetscapeCertType) {
1083                 errors.add(isSigning
1084                         ? rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;)
1085                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
1086             }
1087 
1088             // only in verifying
1089             if (hasUnsignedEntry) {
1090                 errors.add(rb.getString(
1091                         &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));
1092             }
1093             if (hasExpiredCert) {
1094                 errors.add(isSigning
1095                         ? rb.getString(&quot;The.signer.certificate.has.expired.&quot;)
1096                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));
1097             }
1098             if (notYetValidCert) {
1099                 errors.add(isSigning
1100                         ? rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;)
1101                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));
1102             }
1103 
1104             if (chainNotValidated) {
1105                 errors.add(String.format(isSigning
1106                                 ? rb.getString(&quot;The.signer.s.certificate.chain.is.invalid.reason.1&quot;)
1107                                 : rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1&quot;),
1108                         chainNotValidatedReason.getLocalizedMessage()));
1109             }
1110 
1111             if (hasExpiredTsaCert) {
1112                 errors.add(rb.getString(&quot;The.timestamp.has.expired.&quot;));
1113             }
1114             if (tsaChainNotValidated) {
1115                 errors.add(String.format(isSigning
1116                                 ? rb.getString(&quot;The.tsa.certificate.chain.is.invalid.reason.1&quot;)
1117                                 : rb.getString(&quot;This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1&quot;),
1118                         tsaChainNotValidatedReason.getLocalizedMessage()));
1119             }
1120 
1121             // only in verifying
1122             if (notSignedByAlias) {
1123                 errors.add(
1124                         rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));
1125             }
1126 
1127             // only in verifying
1128             if (aliasNotInStore) {
1129                 errors.add(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));
1130             }
1131 
1132             if (signerSelfSigned) {
1133                 errors.add(isSigning
1134                         ? rb.getString(&quot;The.signer.s.certificate.is.self.signed.&quot;)
1135                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.self.signed.&quot;));
1136             }
1137 
<a name="7" id="anc7"></a>



1138             if (isSigning) {
1139                 if ((legacyAlg &amp; 1) == 1) {
1140                     warnings.add(String.format(
1141                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1142                             digestalg, &quot;-digestalg&quot;));
1143                 }
1144 
1145                 if ((disabledAlg &amp; 1) == 1) {
1146                     errors.add(String.format(
1147                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),
1148                             digestalg, &quot;-digestalg&quot;));
1149                 }
1150 
1151                 if ((legacyAlg &amp; 2) == 2) {
1152                     warnings.add(String.format(
1153                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1154                             sigalg, &quot;-sigalg&quot;));
1155                 }
1156                 if ((disabledAlg &amp; 2) == 2) {
1157                     errors.add(String.format(
1158                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),
1159                             sigalg, &quot;-sigalg&quot;));
1160                 }
1161 
1162                 if ((legacyAlg &amp; 4) == 4) {
1163                     warnings.add(String.format(
1164                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1165                             tSADigestAlg, &quot;-tsadigestalg&quot;));
1166                 }
1167                 if ((disabledAlg &amp; 4) == 4) {
1168                     errors.add(String.format(
1169                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),
1170                             tSADigestAlg, &quot;-tsadigestalg&quot;));
1171                 }
1172 
1173                 if ((legacyAlg &amp; 8) == 8) {
1174                     warnings.add(String.format(
1175                             rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update.&quot;),
1176                             privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1177                 }
1178                 if ((disabledAlg &amp; 8) == 8) {
1179                     errors.add(String.format(
1180                             rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.and.is.disabled.&quot;),
1181                             privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1182                 }
1183             } else {
1184                 if ((legacyAlg &amp; 1) != 0) {
1185                     warnings.add(String.format(
1186                             rb.getString(&quot;The.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1187                             legacyDigestAlg));
1188                 }
1189 
1190                 if ((legacyAlg &amp; 2) == 2) {
1191                      warnings.add(String.format(
1192                              rb.getString(&quot;The.signature.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1193                              legacySigAlg));
1194                 }
1195 
1196                 if ((legacyAlg &amp; 4) != 0) {
1197                     warnings.add(String.format(
1198                             rb.getString(&quot;The.timestamp.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1199                             legacyTsaDigestAlg));
1200                 }
1201 
1202                 if ((legacyAlg &amp; 8) == 8) {
1203                     warnings.add(String.format(
1204                             rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update.&quot;),
1205                             weakPublicKey.getAlgorithm(), KeyUtil.getKeySize(weakPublicKey)));
1206                 }
1207             }
1208         } else {
1209             result = isSigning ? rb.getString(&quot;jar.signed.&quot;) : rb.getString(&quot;jar.verified.&quot;);
1210         }
1211 
1212         if (hasExpiredTsaCert) {
1213             // No need to warn about expiring if already expired
1214             hasExpiringTsaCert = false;
1215         }
1216 
1217         if (hasExpiringCert ||
1218                 (hasExpiringTsaCert  &amp;&amp; expireDate != null) ||
1219                 (noTimestamp &amp;&amp; expireDate != null) ||
1220                 (hasExpiredTsaCert &amp;&amp; signerNotExpired)) {
1221 
1222             if (hasExpiredTsaCert &amp;&amp; signerNotExpired) {
1223                 if (expireDate != null) {
1224                     warnings.add(String.format(
1225                             rb.getString(&quot;The.timestamp.expired.1.but.usable.2&quot;),
1226                             tsaExpireDate,
1227                             expireDate));
1228                 }
1229                 // Reset the flag so exit code is 0
1230                 hasExpiredTsaCert = false;
1231             }
1232             if (hasExpiringCert) {
1233                 warnings.add(isSigning
1234                         ? rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;)
1235                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));
1236             }
1237             if (hasExpiringTsaCert &amp;&amp; expireDate != null) {
1238                 if (expireDate.after(tsaExpireDate)) {
1239                     warnings.add(String.format(rb.getString(
1240                             &quot;The.timestamp.will.expire.within.one.year.on.1.but.2&quot;), tsaExpireDate, expireDate));
1241                 } else {
1242                     warnings.add(String.format(rb.getString(
1243                             &quot;The.timestamp.will.expire.within.one.year.on.1&quot;), tsaExpireDate));
1244                 }
1245             }
1246             if (noTimestamp &amp;&amp; expireDate != null) {
1247                 if (hasTimestampBlock) {
1248                     warnings.add(String.format(isSigning
1249                             ? rb.getString(&quot;invalid.timestamp.signing&quot;)
1250                             : rb.getString(&quot;bad.timestamp.verifying&quot;), expireDate));
1251                 } else {
1252                     warnings.add(String.format(isSigning
1253                             ? rb.getString(&quot;no.timestamp.signing&quot;)
1254                             : rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));
1255                 }
1256             }
1257         }
1258 
1259         System.out.println(result);
1260         if (strict) {
1261             if (!errors.isEmpty()) {
1262                 System.out.println();
1263                 System.out.println(rb.getString(&quot;Error.&quot;));
1264                 errors.forEach(System.out::println);
1265             }
1266             if (!warnings.isEmpty()) {
1267                 System.out.println();
1268                 System.out.println(rb.getString(&quot;Warning.&quot;));
1269                 warnings.forEach(System.out::println);
1270             }
1271         } else {
1272             if (!errors.isEmpty() || !warnings.isEmpty()) {
1273                 System.out.println();
1274                 System.out.println(rb.getString(&quot;Warning.&quot;));
1275                 errors.forEach(System.out::println);
1276                 warnings.forEach(System.out::println);
1277             }
1278         }
1279         if (!isSigning &amp;&amp; (!errors.isEmpty() || !warnings.isEmpty())) {
1280             if (! (verbose != null &amp;&amp; showcerts)) {
1281                 System.out.println();
1282                 System.out.println(rb.getString(
1283                         &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
1284             }
1285         }
1286 
1287         if (isSigning || verbose != null) {
1288             // Always print out expireDate, unless expired or expiring.
1289             if (!hasExpiringCert &amp;&amp; !hasExpiredCert
1290                     &amp;&amp; expireDate != null &amp;&amp; signerNotExpired) {
1291                 info.add(String.format(rb.getString(
1292                         &quot;The.signer.certificate.will.expire.on.1.&quot;), expireDate));
1293             }
1294             if (!noTimestamp) {
1295                 if (!hasExpiringTsaCert &amp;&amp; !hasExpiredTsaCert &amp;&amp; tsaExpireDate != null) {
1296                     if (signerNotExpired) {
1297                         info.add(String.format(rb.getString(
1298                                 &quot;The.timestamp.will.expire.on.1.&quot;), tsaExpireDate));
1299                     } else {
1300                         info.add(String.format(rb.getString(
1301                                 &quot;signer.cert.expired.1.but.timestamp.good.2.&quot;),
1302                                 expireDate,
1303                                 tsaExpireDate));
1304                     }
1305                 }
1306             }
1307         }
1308 
1309         if (!info.isEmpty()) {
1310             System.out.println();
1311             info.forEach(System.out::println);
1312         }
1313     }
1314 
1315     private String verifyWithWeak(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet, boolean tsa) {
1316         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1317             if (LEGACY_CHECK.permits(primitiveSet, alg, null)) {
1318                 return alg;
1319             } else {
1320                 if (primitiveSet == SIG_PRIMITIVE_SET) {
1321                    legacyAlg |= 2;
1322                    legacySigAlg = alg;
1323                 } else {
1324                     if (tsa) {
1325                         legacyAlg |= 4;
1326                         legacyTsaDigestAlg = alg;
1327                     } else {
1328                         legacyAlg |= 1;
1329                         legacyDigestAlg = alg;
1330                     }
1331                 }
1332                 return String.format(rb.getString(&quot;with.weak&quot;), alg);
1333             }
1334         } else {
1335             disabledAlgFound = true;
1336             return String.format(rb.getString(&quot;with.disabled&quot;), alg);
1337         }
1338     }
1339 
1340     private String verifyWithWeak(PublicKey key) {
1341         int kLen = KeyUtil.getKeySize(key);
1342         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1343             if (LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1344                 if (kLen &gt;= 0) {
1345                     return String.format(rb.getString(&quot;key.bit&quot;), kLen);
1346                 } else {
1347                     return rb.getString(&quot;unknown.size&quot;);
1348                 }
1349             } else {
1350                 weakPublicKey = key;
1351                 legacyAlg |= 8;
1352                 return String.format(rb.getString(&quot;key.bit.weak&quot;), kLen);
1353             }
1354         } else {
1355            disabledAlgFound = true;
1356            return String.format(rb.getString(&quot;key.bit.disabled&quot;), kLen);
1357         }
1358     }
1359 
1360     private void checkWeakSign(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet, boolean tsa) {
1361         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1362             if (!LEGACY_CHECK.permits(primitiveSet, alg, null)) {
1363                 if (primitiveSet == SIG_PRIMITIVE_SET) {
1364                    legacyAlg |= 2;
1365                 } else {
1366                     if (tsa) {
1367                         legacyAlg |= 4;
1368                     } else {
1369                         legacyAlg |= 1;
1370                     }
1371                 }
1372             }
1373         } else {
1374            if (primitiveSet == SIG_PRIMITIVE_SET) {
1375                disabledAlg |= 2;
1376            } else {
1377                if (tsa) {
1378                    disabledAlg |= 4;
1379                } else {
1380                    disabledAlg |= 1;
1381                }
1382            }
1383         }
1384     }
1385 
1386     private void checkWeakSign(PrivateKey key) {
1387         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1388             if (!LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1389                 legacyAlg |= 8;
1390             }
1391         } else {
1392             disabledAlg |= 8;
1393         }
1394     }
1395 
1396     private static MessageFormat validityTimeForm = null;
1397     private static MessageFormat notYetTimeForm = null;
1398     private static MessageFormat expiredTimeForm = null;
1399     private static MessageFormat expiringTimeForm = null;
1400 
1401     /**
1402      * Returns a string about a certificate:
1403      *
1404      * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
1405      * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
1406      * [&lt;key-usage-warning&gt;]
1407      *
1408      * Note: no newline character at the end.
1409      *
1410      * This method sets global flags like hasExpiringCert, hasExpiredCert,
1411      * notYetValidCert, badKeyUsage, badExtendedKeyUsage, badNetscapeCertType,
1412      * hasExpiringTsaCert, hasExpiredTsaCert.
1413      *
1414      * @param isTsCert true if c is in the TSA cert chain, false otherwise.
1415      * @param checkUsage true to check code signer keyUsage
1416      */
1417     String printCert(boolean isTsCert, String tab, Certificate c,
1418         Date timestamp, boolean checkUsage) throws Exception {
1419 
1420         StringBuilder certStr = new StringBuilder();
1421         String space = rb.getString(&quot;SPACE&quot;);
1422         X509Certificate x509Cert = null;
1423 
1424         if (c instanceof X509Certificate) {
1425             x509Cert = (X509Certificate) c;
1426             certStr.append(tab).append(x509Cert.getType())
1427                 .append(rb.getString(&quot;COMMA&quot;))
1428                 .append(x509Cert.getSubjectDN().getName());
1429         } else {
1430             certStr.append(tab).append(c.getType());
1431         }
1432 
1433         String alias = storeHash.get(c);
1434         if (alias != null) {
1435             certStr.append(space).append(&quot;(&quot;).append(alias).append(&quot;)&quot;);
1436         }
1437 
1438         if (x509Cert != null) {
1439 
1440             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1441 
1442             if (trustedCerts.contains(x509Cert)) {
1443                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1444             } else {
1445                 Date notAfter = x509Cert.getNotAfter();
1446                 try {
1447                     boolean printValidity = true;
1448                     if (isTsCert) {
1449                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1450                             tsaExpireDate = notAfter;
1451                         }
1452                     } else {
1453                         if (expireDate == null || expireDate.after(notAfter)) {
1454                             expireDate = notAfter;
1455                         }
1456                     }
1457                     if (timestamp == null) {
1458                         x509Cert.checkValidity();
1459                         // test if cert will expire within six months (or one year for tsa)
1460                         long age = isTsCert ? ONE_YEAR : SIX_MONTHS;
1461                         if (notAfter.getTime() &lt; System.currentTimeMillis() + age) {
1462                             if (isTsCert) {
1463                                 hasExpiringTsaCert = true;
1464                             } else {
1465                                 hasExpiringCert = true;
1466                             }
1467                             if (expiringTimeForm == null) {
1468                                 expiringTimeForm = new MessageFormat(
1469                                         rb.getString(&quot;certificate.will.expire.on&quot;));
1470                             }
1471                             Object[] source = {notAfter};
1472                             certStr.append(expiringTimeForm.format(source));
1473                             printValidity = false;
1474                         }
1475                     } else {
1476                         x509Cert.checkValidity(timestamp);
1477                     }
1478                     if (printValidity) {
1479                         if (validityTimeForm == null) {
1480                             validityTimeForm = new MessageFormat(
1481                                     rb.getString(&quot;certificate.is.valid.from&quot;));
1482                         }
1483                         Object[] source = {x509Cert.getNotBefore(), notAfter};
1484                         certStr.append(validityTimeForm.format(source));
1485                     }
1486                 } catch (CertificateExpiredException cee) {
1487                     if (isTsCert) {
1488                         hasExpiredTsaCert = true;
1489                     } else {
1490                         hasExpiredCert = true;
1491                     }
1492 
1493                     if (expiredTimeForm == null) {
1494                         expiredTimeForm = new MessageFormat(
1495                                 rb.getString(&quot;certificate.expired.on&quot;));
1496                     }
1497                     Object[] source = {notAfter};
1498                     certStr.append(expiredTimeForm.format(source));
1499 
1500                 } catch (CertificateNotYetValidException cnyve) {
1501                     if (!isTsCert) notYetValidCert = true;
1502 
1503                     if (notYetTimeForm == null) {
1504                         notYetTimeForm = new MessageFormat(
1505                                 rb.getString(&quot;certificate.is.not.valid.until&quot;));
1506                     }
1507                     Object[] source = {x509Cert.getNotBefore()};
1508                     certStr.append(notYetTimeForm.format(source));
1509                 }
1510             }
1511             certStr.append(&quot;]&quot;);
1512 
1513             if (checkUsage) {
1514                 boolean[] bad = new boolean[3];
1515                 checkCertUsage(x509Cert, bad);
1516                 if (bad[0] || bad[1] || bad[2]) {
1517                     String x = &quot;&quot;;
1518                     if (bad[0]) {
1519                         x =&quot;KeyUsage&quot;;
1520                     }
1521                     if (bad[1]) {
1522                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1523                         x = x + &quot;ExtendedKeyUsage&quot;;
1524                     }
1525                     if (bad[2]) {
1526                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1527                         x = x + &quot;NetscapeCertType&quot;;
1528                     }
1529                     certStr.append(&quot;\n&quot;).append(tab)
1530                         .append(MessageFormat.format(rb.getString(
1531                         &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
1532                 }
1533             }
1534         }
1535         return certStr.toString();
1536     }
1537 
1538     private static MessageFormat signTimeForm = null;
1539 
1540     private String printTimestamp(String tab, Timestamp timestamp) {
1541 
1542         if (signTimeForm == null) {
1543             signTimeForm =
1544                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1545         }
1546         Object[] source = { timestamp.getTimestamp() };
1547 
1548         return new StringBuilder().append(tab).append(&quot;[&quot;)
1549             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1550     }
1551 
1552     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1553 
1554     private int inKeyStoreForOneSigner(CodeSigner signer) {
1555         if (cacheForInKS.containsKey(signer)) {
1556             return cacheForInKS.get(signer);
1557         }
1558 
1559         int result = 0;
1560         if (store != null) {
1561             try {
1562                 List&lt;? extends Certificate&gt; certs =
1563                         signer.getSignerCertPath().getCertificates();
1564                 for (Certificate c : certs) {
1565                     String alias = storeHash.get(c);
1566                     if (alias == null) {
1567                         alias = store.getCertificateAlias(c);
1568                         if (alias != null) {
1569                             storeHash.put(c, alias);
1570                         }
1571                     }
1572                     if (alias != null) {
1573                         result |= IN_KEYSTORE;
1574                     }
1575                     for (String ckalias : ckaliases) {
1576                         if (c.equals(store.getCertificate(ckalias))) {
1577                             result |= SIGNED_BY_ALIAS;
1578                             // must continue with next certificate c and cannot
1579                             // return or break outer loop because has to fill
1580                             // storeHash for printCert
1581                             break;
1582                         }
1583                     }
1584                 }
1585             } catch (KeyStoreException kse) {
1586                 // never happens, because keystore has been loaded
1587             }
1588         }
1589         cacheForInKS.put(signer, result);
1590         return result;
1591     }
1592 
1593     /**
1594      * Maps certificates (as keys) to alias names associated in the keystore
1595      * {@link #store} (as values).
1596      */
1597     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1598 
1599     int inKeyStore(CodeSigner[] signers) {
1600 
1601         if (signers == null)
1602             return 0;
1603 
1604         int output = 0;
1605 
1606         for (CodeSigner signer: signers) {
1607             int result = inKeyStoreForOneSigner(signer);
1608             output |= result;
1609         }
1610         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1611             output |= NOT_ALIAS;
1612         }
1613         return output;
1614     }
1615 
1616     void signJar(String jarName, String alias)
1617             throws Exception {
1618 
1619         if (digestalg == null) {
1620             digestalg = JarSigner.Builder.getDefaultDigestAlgorithm();
1621         }
1622         checkWeakSign(digestalg, DIGEST_PRIMITIVE_SET, false);
1623 
1624         if (tSADigestAlg == null) {
1625             tSADigestAlg = JarSigner.Builder.getDefaultDigestAlgorithm();
1626         }
1627         checkWeakSign(tSADigestAlg, DIGEST_PRIMITIVE_SET, true);
1628 
1629         if (sigalg == null) {
1630             sigalg = JarSigner.Builder.getDefaultSignatureAlgorithm(privateKey);
1631         }
1632         checkWeakSign(sigalg, SIG_PRIMITIVE_SET, false);
1633 
1634         checkWeakSign(privateKey);
1635 
1636         boolean aliasUsed = false;
1637         X509Certificate tsaCert = null;
1638 
1639         if (sigfile == null) {
1640             sigfile = alias;
1641             aliasUsed = true;
1642         }
1643 
1644         if (sigfile.length() &gt; 8) {
1645             sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
1646         } else {
1647             sigfile = sigfile.toUpperCase(Locale.ENGLISH);
1648         }
1649 
1650         StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
1651         for (int j = 0; j &lt; sigfile.length(); j++) {
1652             char c = sigfile.charAt(j);
1653             if (!
1654                     ((c&gt;= &#39;A&#39; &amp;&amp; c&lt;= &#39;Z&#39;) ||
1655                             (c&gt;= &#39;0&#39; &amp;&amp; c&lt;= &#39;9&#39;) ||
1656                             (c == &#39;-&#39;) ||
1657                             (c == &#39;_&#39;))) {
1658                 if (aliasUsed) {
1659                     // convert illegal characters from the alias to be _&#39;s
1660                     c = &#39;_&#39;;
1661                 } else {
1662                     throw new
1663                             RuntimeException(rb.getString
1664                             (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
1665                 }
1666             }
1667             tmpSigFile.append(c);
1668         }
1669 
1670         sigfile = tmpSigFile.toString();
1671 
1672         String tmpJarName;
1673         if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
1674         else tmpJarName = signedjar;
1675 
1676         File jarFile = new File(jarName);
1677         File signedJarFile = new File(tmpJarName);
1678 
1679         // Open the jar (zip) file
1680         try {
1681             zipFile = new ZipFile(jarName);
1682         } catch (IOException ioe) {
1683             error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
1684         }
1685 
1686         CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;)
1687                 .generateCertPath(Arrays.asList(certChain));
1688         JarSigner.Builder builder = new JarSigner.Builder(privateKey, cp);
1689 
1690         if (verbose != null) {
1691             builder.eventHandler((action, file) -&gt; {
1692                 switch (action) {
1693                     case &quot;signing&quot;:
1694                         System.out.println(rb.getString(&quot;.signing.&quot;) + file);
1695                         break;
1696                     case &quot;adding&quot;:
1697                         System.out.println(rb.getString(&quot;.adding.&quot;) + file);
1698                         break;
1699                     case &quot;updating&quot;:
1700                         System.out.println(rb.getString(&quot;.updating.&quot;) + file);
1701                         break;
1702                     default:
1703                         throw new IllegalArgumentException(&quot;unknown action: &quot;
1704                                 + action);
1705                 }
1706             });
1707         }
1708 
1709         if (digestalg != null) {
1710             builder.digestAlgorithm(digestalg);
1711         }
1712         if (sigalg != null) {
1713             builder.signatureAlgorithm(sigalg);
1714         }
1715 
1716         URI tsaURI = null;
1717 
1718         if (tsaUrl != null) {
1719             tsaURI = new URI(tsaUrl);
1720         } else if (tsaAlias != null) {
1721             tsaCert = getTsaCert(tsaAlias);
1722             tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
1723         }
1724 
1725         if (tsaURI != null) {
1726             if (verbose != null) {
1727                 System.out.println(
1728                         rb.getString(&quot;requesting.a.signature.timestamp&quot;));
1729                 if (tsaUrl != null) {
1730                     System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
1731                 } else if (tsaCert != null) {
1732                     System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
1733                             printCert(true, &quot;&quot;, tsaCert, null, false));
1734                 }
1735             }
1736             builder.tsa(tsaURI);
1737             if (tSADigestAlg != null) {
1738                 builder.setProperty(&quot;tsaDigestAlg&quot;, tSADigestAlg);
1739             }
1740 
1741             if (tSAPolicyID != null) {
1742                 builder.setProperty(&quot;tsaPolicyId&quot;, tSAPolicyID);
1743             }
1744         }
1745 
1746         if (altSignerClass != null) {
1747             builder.setProperty(&quot;altSigner&quot;, altSignerClass);
1748             if (verbose != null) {
1749                 System.out.println(
1750                         rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
1751             }
1752         }
1753 
1754         if (altSignerClasspath != null) {
1755             builder.setProperty(&quot;altSignerPath&quot;, altSignerClasspath);
1756         }
1757 
1758         builder.signerName(sigfile);
1759 
1760         builder.setProperty(&quot;sectionsOnly&quot;, Boolean.toString(!signManifest));
1761         builder.setProperty(&quot;internalSF&quot;, Boolean.toString(!externalSF));
1762 
1763         FileOutputStream fos = null;
1764         try {
1765             fos = new FileOutputStream(signedJarFile);
1766         } catch (IOException ioe) {
1767             error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
1768         }
1769 
1770         Throwable failedCause = null;
1771         String failedMessage = null;
1772 
1773         try {
<a name="8" id="anc8"></a>

1774             builder.build().sign(zipFile, fos);
1775         } catch (JarSignerException e) {
1776             failedCause = e.getCause();
1777             if (failedCause instanceof SocketTimeoutException
1778                     || failedCause instanceof UnknownHostException) {
1779                 // Provide a helpful message when TSA is beyond a firewall
1780                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) +
1781                         rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
1782                         &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
1783                         &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
1784                         rb.getString(&quot;or&quot;) +
1785                         &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
1786                         &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;;
1787             } else {
1788                 // JarSignerException might have a null cause
1789                 if (failedCause == null) {
1790                     failedCause = e;
1791                 }
1792                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1793             }
1794         } catch (Exception e) {
1795             failedCause = e;
1796             failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1797         } finally {
1798             // close the resources
1799             if (zipFile != null) {
1800                 zipFile.close();
1801                 zipFile = null;
1802             }
1803 
1804             if (fos != null) {
1805                 fos.close();
1806             }
1807 
<a name="9" id="anc9"></a>
1808         }
1809 
1810         if (failedCause != null) {
1811             signedJarFile.delete();
1812             error(failedMessage, failedCause);
1813         }
1814 
1815         if (verbose != null) {
1816             System.out.println();
1817         }
1818 
1819         // The JarSigner API always accepts the timestamp received.
1820         // We need to extract the certs from the signed jar to
1821         // validate it.
1822         try (JarFile check = new JarFile(signedJarFile)) {
1823             PKCS7 p7 = new PKCS7(check.getInputStream(check.getEntry(
1824                     &quot;META-INF/&quot; + sigfile + &quot;.&quot; + privateKey.getAlgorithm())));
1825             Timestamp ts = null;
1826             try {
1827                 SignerInfo si = p7.getSignerInfos()[0];
1828                 if (si.getTsToken() != null) {
1829                     hasTimestampBlock = true;
1830                 }
1831                 ts = si.getTimestamp();
1832             } catch (Exception e) {
1833                 tsaChainNotValidated = true;
1834                 tsaChainNotValidatedReason = e;
1835             }
1836             // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are different
1837             String result = certsAndTSInfo(&quot;&quot;, &quot;    &quot;, Arrays.asList(certChain), ts);
1838             if (verbose != null) {
1839                 System.out.println(result);
1840             }
1841         } catch (Exception e) {
1842             if (debug) {
1843                 e.printStackTrace();
1844             }
1845         }
1846 
1847         if (signedjar == null) {
1848             // attempt an atomic rename. If that fails,
1849             // rename the original jar file, then the signed
1850             // one, then delete the original.
1851             if (!signedJarFile.renameTo(jarFile)) {
1852                 File origJar = new File(jarName+&quot;.orig&quot;);
1853 
1854                 if (jarFile.renameTo(origJar)) {
1855                     if (signedJarFile.renameTo(jarFile)) {
1856                         origJar.delete();
1857                     } else {
1858                         MessageFormat form = new MessageFormat(rb.getString
1859                     (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
1860                         Object[] source = {signedJarFile, jarFile};
1861                         error(form.format(source));
1862                     }
1863                 } else {
1864                     MessageFormat form = new MessageFormat(rb.getString
1865                         (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
1866                     Object[] source = {jarFile, origJar};
1867                     error(form.format(source));
1868                 }
1869             }
1870         }
1871         displayMessagesAndResult(true);
1872     }
1873 
1874     /**
1875      * signature-related files include:
1876      * . META-INF/MANIFEST.MF
1877      * . META-INF/SIG-*
1878      * . META-INF/*.SF
1879      * . META-INF/*.DSA
1880      * . META-INF/*.RSA
1881      * . META-INF/*.EC
1882      */
1883     private boolean signatureRelated(String name) {
1884         return SignatureFileVerifier.isSigningRelated(name);
1885     }
1886 
1887     Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();
1888 
1889     /**
1890      * Returns a string of signer info, with a newline at the end.
1891      * Called by verifyJar().
1892      */
1893     private String signerInfo(CodeSigner signer, String tab) throws Exception {
1894         if (cacheForSignerInfo.containsKey(signer)) {
1895             return cacheForSignerInfo.get(signer);
1896         }
1897         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1898         // signing time is only displayed on verification
1899         Timestamp ts = signer.getTimestamp();
1900         String tsLine = &quot;&quot;;
1901         if (ts != null) {
1902             tsLine = printTimestamp(tab, ts) + &quot;\n&quot;;
1903         }
1904         // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are the same.
1905 
1906         String result = certsAndTSInfo(tab, tab, certs, ts);
1907         cacheForSignerInfo.put(signer, tsLine + result);
1908         return result;
1909     }
1910 
1911     /**
1912      * Fills info on certs and timestamp into a StringBuilder, sets
1913      * warning flags (through printCert) and validates cert chains.
1914      *
1915      * @param tab1 spaces before the &quot;&gt;&gt;&gt; Signer&quot; line
1916      * @param tab2 spaces before the other lines
1917      * @param certs the signer cert
1918      * @param ts the timestamp, can be null
1919      * @return the info as a string
1920      */
1921     private String certsAndTSInfo(
1922             String tab1,
1923             String tab2,
1924             List&lt;? extends Certificate&gt; certs, Timestamp ts)
1925             throws Exception {
1926 
1927         Date timestamp;
1928         if (ts != null) {
1929             timestamp = ts.getTimestamp();
1930             noTimestamp = false;
1931         } else {
1932             timestamp = null;
1933         }
1934         // display the certificate(sb). The first one is end-entity cert and
1935         // its KeyUsage should be checked.
1936         boolean first = true;
1937         StringBuilder sb = new StringBuilder();
1938         sb.append(tab1).append(rb.getString(&quot;...Signer&quot;)).append(&#39;\n&#39;);
1939         for (Certificate c : certs) {
1940             sb.append(printCert(false, tab2, c, timestamp, first));
1941             sb.append(&#39;\n&#39;);
1942             first = false;
1943         }
1944         try {
1945             validateCertChain(Validator.VAR_CODE_SIGNING, certs, ts);
1946         } catch (Exception e) {
1947             chainNotValidated = true;
1948             chainNotValidatedReason = e;
1949             sb.append(tab2).append(rb.getString(&quot;.Invalid.certificate.chain.&quot;))
1950                     .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1951         }
1952         if (ts != null) {
1953             sb.append(tab1).append(rb.getString(&quot;...TSA&quot;)).append(&#39;\n&#39;);
1954             for (Certificate c : ts.getSignerCertPath().getCertificates()) {
1955                 sb.append(printCert(true, tab2, c, null, false));
1956                 sb.append(&#39;\n&#39;);
1957             }
1958             try {
1959                 validateCertChain(Validator.VAR_TSA_SERVER,
1960                         ts.getSignerCertPath().getCertificates(), null);
1961             } catch (Exception e) {
1962                 tsaChainNotValidated = true;
1963                 tsaChainNotValidatedReason = e;
1964                 sb.append(tab2).append(rb.getString(&quot;.Invalid.TSA.certificate.chain.&quot;))
1965                         .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1966             }
1967         }
1968         if (certs.size() == 1
1969                 &amp;&amp; KeyStoreUtil.isSelfSigned((X509Certificate)certs.get(0))) {
1970             signerSelfSigned = true;
1971         }
1972 
1973         return sb.toString();
1974     }
1975 
1976     void loadKeyStore(String keyStoreName, boolean prompt) {
1977 
1978         if (!nullStream &amp;&amp; keyStoreName == null) {
1979             keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
1980                 + &quot;.keystore&quot;;
1981         }
1982 
1983         try {
1984             try {
1985                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
1986                 if (caks != null) {
1987                     Enumeration&lt;String&gt; aliases = caks.aliases();
1988                     while (aliases.hasMoreElements()) {
1989                         String a = aliases.nextElement();
1990                         try {
1991                             trustedCerts.add((X509Certificate)caks.getCertificate(a));
1992                         } catch (Exception e2) {
1993                             // ignore, when a SecretkeyEntry does not include a cert
1994                         }
1995                     }
1996                 }
1997             } catch (Exception e) {
1998                 // Ignore, if cacerts cannot be loaded
1999             }
2000 
2001             if (providerName == null) {
2002                 store = KeyStore.getInstance(storetype);
2003             } else {
2004                 store = KeyStore.getInstance(storetype, providerName);
2005             }
2006 
2007             // Get pass phrase
2008             // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
2009             // and on NT call ??
2010             if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
2011                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
2012                 storepass = getPass
2013                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
2014             } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
2015                 storepass = getPass
2016                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
2017             }
2018 
2019             try {
2020                 if (nullStream) {
2021                     store.load(null, storepass);
2022                 } else {
2023                     keyStoreName = keyStoreName.replace(File.separatorChar, &#39;/&#39;);
2024                     URL url = null;
2025                     try {
2026                         url = new URL(keyStoreName);
2027                     } catch (java.net.MalformedURLException e) {
2028                         // try as file
2029                         url = new File(keyStoreName).toURI().toURL();
2030                     }
2031                     InputStream is = null;
2032                     try {
2033                         is = url.openStream();
2034                         store.load(is, storepass);
2035                     } finally {
2036                         if (is != null) {
2037                             is.close();
2038                         }
2039                     }
2040                 }
2041                 Enumeration&lt;String&gt; aliases = store.aliases();
2042                 while (aliases.hasMoreElements()) {
2043                     String a = aliases.nextElement();
2044                     try {
2045                         X509Certificate c = (X509Certificate)store.getCertificate(a);
2046                         // Only add TrustedCertificateEntry and self-signed
2047                         // PrivateKeyEntry
2048                         if (store.isCertificateEntry(a) ||
2049                                 c.getSubjectDN().equals(c.getIssuerDN())) {
2050                             trustedCerts.add(c);
2051                         }
2052                     } catch (Exception e2) {
2053                         // ignore, when a SecretkeyEntry does not include a cert
2054                     }
2055                 }
2056             } finally {
2057                 try {
2058                     pkixParameters = new PKIXBuilderParameters(
2059                             trustedCerts.stream()
2060                                     .map(c -&gt; new TrustAnchor(c, null))
2061                                     .collect(Collectors.toSet()),
2062                             null);
2063 
2064                     if (revocationCheck) {
2065                         Security.setProperty(&quot;ocsp.enable&quot;, &quot;true&quot;);
2066                         System.setProperty(&quot;com.sun.security.enableCRLDP&quot;, &quot;true&quot;);
<a name="10" id="anc10"></a><span class="line-modified">2067                         Event.setReportListener((t, o) -&gt; System.out.println(String.format(rb.getString(t), o)));</span>

2068                     }
2069                     pkixParameters.setRevocationEnabled(revocationCheck);
2070                 } catch (InvalidAlgorithmParameterException ex) {
2071                     // Only if tas is empty
2072                 }
2073             }
2074         } catch (IOException ioe) {
2075             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2076                                         ioe.getMessage());
2077         } catch (java.security.cert.CertificateException ce) {
2078             throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
2079                                         ce.getMessage());
2080         } catch (NoSuchProviderException pe) {
2081             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2082                                         pe.getMessage());
2083         } catch (NoSuchAlgorithmException nsae) {
2084             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2085                                         nsae.getMessage());
2086         } catch (KeyStoreException kse) {
2087             throw new RuntimeException
2088                 (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
2089                 kse.getMessage());
2090         }
2091     }
2092 
2093     X509Certificate getTsaCert(String alias) {
2094 
2095         java.security.cert.Certificate cs = null;
2096 
2097         try {
2098             cs = store.getCertificate(alias);
2099         } catch (KeyStoreException kse) {
2100             // this never happens, because keystore has been loaded
2101         }
2102         if (cs == null || (!(cs instanceof X509Certificate))) {
2103             MessageFormat form = new MessageFormat(rb.getString
2104                 (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
2105             Object[] source = {alias, alias};
2106             error(form.format(source));
2107         }
2108         return (X509Certificate) cs;
2109     }
2110 
2111     /**
2112      * Check if userCert is designed to be a code signer
2113      * @param userCert the certificate to be examined
2114      * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
2115      *            NetscapeCertType has codeSigning flag turned on.
2116      *            If null, the class field badKeyUsage, badExtendedKeyUsage,
2117      *            badNetscapeCertType will be set.
2118      */
2119     void checkCertUsage(X509Certificate userCert, boolean[] bad) {
2120 
2121         // Can act as a signer?
2122         // 1. if KeyUsage, then [0:digitalSignature] or
2123         //    [1:nonRepudiation] should be true
2124         // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
2125         // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
2126         // 1,2,3 must be true
2127 
2128         if (bad != null) {
2129             bad[0] = bad[1] = bad[2] = false;
2130         }
2131 
2132         boolean[] keyUsage = userCert.getKeyUsage();
2133         if (keyUsage != null) {
2134             keyUsage = Arrays.copyOf(keyUsage, 9);
2135             if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
2136                 if (bad != null) {
2137                     bad[0] = true;
2138                     badKeyUsage = true;
2139                 }
2140             }
2141         }
2142 
2143         try {
2144             List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
2145             if (xKeyUsage != null) {
2146                 if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
2147                         &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
2148                     if (bad != null) {
2149                         bad[1] = true;
2150                         badExtendedKeyUsage = true;
2151                     }
2152                 }
2153             }
2154         } catch (java.security.cert.CertificateParsingException e) {
2155             // shouldn&#39;t happen
2156         }
2157 
2158         try {
2159             // OID_NETSCAPE_CERT_TYPE
2160             byte[] netscapeEx = userCert.getExtensionValue
2161                     (&quot;2.16.840.1.113730.1.1&quot;);
2162             if (netscapeEx != null) {
2163                 DerInputStream in = new DerInputStream(netscapeEx);
2164                 byte[] encoded = in.getOctetString();
2165                 encoded = new DerValue(encoded).getUnalignedBitString()
2166                         .toByteArray();
2167 
2168                 NetscapeCertTypeExtension extn =
2169                         new NetscapeCertTypeExtension(encoded);
2170 
2171                 Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
2172                 if (!val) {
2173                     if (bad != null) {
2174                         bad[2] = true;
2175                         badNetscapeCertType = true;
2176                     }
2177                 }
2178             }
2179         } catch (IOException e) {
2180             //
2181         }
2182     }
2183 
2184     // Called by signJar().
2185     void getAliasInfo(String alias) throws Exception {
2186 
2187         Key key = null;
2188 
2189         try {
2190             java.security.cert.Certificate[] cs = null;
2191             if (altCertChain != null) {
2192                 try (FileInputStream fis = new FileInputStream(altCertChain)) {
2193                     cs = CertificateFactory.getInstance(&quot;X.509&quot;).
2194                             generateCertificates(fis).
2195                             toArray(new Certificate[0]);
2196                 } catch (FileNotFoundException ex) {
2197                     error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
2198                 } catch (CertificateException | IOException ex) {
2199                     error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
2200                 }
2201             } else {
2202                 try {
2203                     cs = store.getCertificateChain(alias);
2204                 } catch (KeyStoreException kse) {
2205                     // this never happens, because keystore has been loaded
2206                 }
2207             }
2208             if (cs == null || cs.length == 0) {
2209                 if (altCertChain != null) {
2210                     error(rb.getString
2211                             (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
2212                 } else {
2213                     MessageFormat form = new MessageFormat(rb.getString
2214                         (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
2215                     Object[] source = {alias, alias};
2216                     error(form.format(source));
2217                 }
2218             }
2219 
2220             certChain = new X509Certificate[cs.length];
2221             for (int i=0; i&lt;cs.length; i++) {
2222                 if (!(cs[i] instanceof X509Certificate)) {
2223                     error(rb.getString
2224                         (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
2225                 }
2226                 certChain[i] = (X509Certificate)cs[i];
2227             }
2228 
2229             try {
2230                 if (!token &amp;&amp; keypass == null)
2231                     key = store.getKey(alias, storepass);
2232                 else
2233                     key = store.getKey(alias, keypass);
2234             } catch (UnrecoverableKeyException e) {
2235                 if (token) {
2236                     throw e;
2237                 } else if (keypass == null) {
2238                     // Did not work out, so prompt user for key password
2239                     MessageFormat form = new MessageFormat(rb.getString
2240                         (&quot;Enter.key.password.for.alias.&quot;));
2241                     Object[] source = {alias};
2242                     keypass = getPass(form.format(source));
2243                     key = store.getKey(alias, keypass);
2244                 }
2245             }
2246         } catch (NoSuchAlgorithmException e) {
2247             error(e.getMessage());
2248         } catch (UnrecoverableKeyException e) {
2249             error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
2250         } catch (KeyStoreException kse) {
2251             // this never happens, because keystore has been loaded
2252         }
2253 
2254         if (!(key instanceof PrivateKey)) {
2255             MessageFormat form = new MessageFormat(rb.getString
2256                 (&quot;key.associated.with.alias.not.a.private.key&quot;));
2257             Object[] source = {alias};
2258             error(form.format(source));
2259         } else {
2260             privateKey = (PrivateKey)key;
2261         }
2262     }
2263 
2264     void error(String message) {
2265         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2266         System.exit(1);
2267     }
2268 
2269 
2270     void error(String message, Throwable e) {
2271         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2272         if (debug) {
2273             e.printStackTrace();
2274         }
2275         System.exit(1);
2276     }
2277 
2278     /**
2279      * Validates a cert chain.
2280      *
2281      * @param parameter this might be a timestamp
2282      */
2283     void validateCertChain(String variant, List&lt;? extends Certificate&gt; certs,
2284                            Timestamp parameter)
2285             throws Exception {
2286         try {
2287             Validator.getInstance(Validator.TYPE_PKIX,
2288                     variant,
2289                     pkixParameters)
2290                     .validate(certs.toArray(new X509Certificate[certs.size()]),
2291                             null, parameter);
2292         } catch (Exception e) {
2293             if (debug) {
2294                 e.printStackTrace();
2295             }
2296 
2297             // Exception might be dismissed if another warning flag
2298             // is already set by printCert.
2299 
2300             if (variant.equals(Validator.VAR_TSA_SERVER) &amp;&amp;
2301                     e instanceof ValidatorException) {
2302                 // Throw cause if it&#39;s CertPathValidatorException,
2303                 if (e.getCause() != null &amp;&amp;
2304                         e.getCause() instanceof CertPathValidatorException) {
2305                     e = (Exception) e.getCause();
2306                     Throwable t = e.getCause();
2307                     if ((t instanceof CertificateExpiredException &amp;&amp;
2308                             hasExpiredTsaCert)) {
2309                         // we already have hasExpiredTsaCert
2310                         return;
2311                     }
2312                 }
2313             }
2314 
2315             if (variant.equals(Validator.VAR_CODE_SIGNING) &amp;&amp;
2316                     e instanceof ValidatorException) {
2317                 // Throw cause if it&#39;s CertPathValidatorException,
2318                 if (e.getCause() != null &amp;&amp;
2319                         e.getCause() instanceof CertPathValidatorException) {
2320                     e = (Exception) e.getCause();
2321                     Throwable t = e.getCause();
2322                     if ((t instanceof CertificateExpiredException &amp;&amp;
2323                                 hasExpiredCert) ||
2324                             (t instanceof CertificateNotYetValidException &amp;&amp;
2325                                     notYetValidCert)) {
2326                         // we already have hasExpiredCert and notYetValidCert
2327                         return;
2328                     }
2329                 }
2330                 if (e instanceof ValidatorException) {
2331                     ValidatorException ve = (ValidatorException)e;
2332                     if (ve.getErrorType() == ValidatorException.T_EE_EXTENSIONS &amp;&amp;
2333                             (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType)) {
2334                         // We already have badKeyUsage, badExtendedKeyUsage
2335                         // and badNetscapeCertType
2336                         return;
2337                     }
2338                 }
2339             }
2340             throw e;
2341         }
2342     }
2343 
2344     char[] getPass(String prompt) {
2345         System.err.print(prompt);
2346         System.err.flush();
2347         try {
2348             char[] pass = Password.readPassword(System.in);
2349 
2350             if (pass == null) {
2351                 error(rb.getString(&quot;you.must.enter.key.password&quot;));
2352             } else {
2353                 return pass;
2354             }
2355         } catch (IOException ioe) {
2356             error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
2357         }
2358         // this shouldn&#39;t happen
2359         return null;
2360     }
2361 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
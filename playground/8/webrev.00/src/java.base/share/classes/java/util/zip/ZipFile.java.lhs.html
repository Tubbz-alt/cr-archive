<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Objects;
  51 import java.util.NoSuchElementException;
  52 import java.util.Set;
  53 import java.util.Spliterator;
  54 import java.util.Spliterators;
  55 import java.util.TreeSet;
  56 import java.util.WeakHashMap;
  57 import java.util.function.Consumer;
  58 import java.util.function.IntFunction;
  59 import java.util.jar.JarEntry;
  60 import java.util.jar.JarFile;
  61 import java.util.stream.Stream;
  62 import java.util.stream.StreamSupport;
  63 import jdk.internal.access.JavaUtilZipFileAccess;
  64 import jdk.internal.access.JavaUtilJarAccess;
  65 import jdk.internal.access.SharedSecrets;
  66 import jdk.internal.misc.VM;
  67 import jdk.internal.perf.PerfCounter;
  68 import jdk.internal.ref.CleanerFactory;
  69 import jdk.internal.vm.annotation.Stable;
  70 import sun.nio.cs.UTF_8;
  71 import sun.security.util.SignatureFileVerifier;
  72 
  73 import static java.util.zip.ZipConstants64.*;
  74 import static java.util.zip.ZipUtils.*;
  75 
  76 /**
  77  * This class is used to read entries from a zip file.
  78  *
  79  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  80  * or method in this class will cause a {@link NullPointerException} to be
  81  * thrown.
  82  *
  83  * @apiNote
  84  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  85  * should be called explicitly or by try-with-resources. Subclasses are responsible
  86  * for the cleanup of resources acquired by the subclass. Subclasses that override
  87  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  88  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  89  * {@code finalize} method.
  90  *
  91  * @author      David Connelly
  92  * @since 1.1
  93  */
  94 public class ZipFile implements ZipConstants, Closeable {
  95 
  96     private final String name;     // zip file name
  97     private volatile boolean closeRequested;
  98 
  99     // The &quot;resource&quot; used by this zip file that needs to be
 100     // cleaned after use.
 101     // a) the input streams that need to be closed
 102     // b) the list of cached Inflater objects
 103     // c) the &quot;native&quot; source of this zip file.
 104     private final @Stable CleanableResource res;
 105 
 106     private static final int STORED = ZipEntry.STORED;
 107     private static final int DEFLATED = ZipEntry.DEFLATED;
 108 
 109     /**
 110      * Mode flag to open a zip file for reading.
 111      */
 112     public static final int OPEN_READ = 0x1;
 113 
 114     /**
 115      * Mode flag to open a zip file and mark it for deletion.  The file will be
 116      * deleted some time between the moment that it is opened and the moment
 117      * that it is closed, but its contents will remain accessible via the
 118      * {@code ZipFile} object until either the close method is invoked or the
 119      * virtual machine exits.
 120      */
 121     public static final int OPEN_DELETE = 0x4;
 122 
 123     /**
 124      * Opens a zip file for reading.
 125      *
 126      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 127      * method is called with the {@code name} argument as its argument
 128      * to ensure the read is allowed.
 129      *
 130      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 131      * decode the entry names and comments.
 132      *
 133      * @param name the name of the zip file
 134      * @throws ZipException if a ZIP format error has occurred
 135      * @throws IOException if an I/O error has occurred
 136      * @throws SecurityException if a security manager exists and its
 137      *         {@code checkRead} method doesn&#39;t allow read access to the file.
 138      *
 139      * @see SecurityManager#checkRead(java.lang.String)
 140      */
 141     public ZipFile(String name) throws IOException {
 142         this(new File(name), OPEN_READ);
 143     }
 144 
 145     /**
 146      * Opens a new {@code ZipFile} to read from the specified
 147      * {@code File} object in the specified mode.  The mode argument
 148      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 149      *
 150      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 151      * method is called with the {@code name} argument as its argument to
 152      * ensure the read is allowed.
 153      *
 154      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 155      * decode the entry names and comments
 156      *
 157      * @param file the ZIP file to be opened for reading
 158      * @param mode the mode in which the file is to be opened
 159      * @throws ZipException if a ZIP format error has occurred
 160      * @throws IOException if an I/O error has occurred
 161      * @throws SecurityException if a security manager exists and
 162      *         its {@code checkRead} method
 163      *         doesn&#39;t allow read access to the file,
 164      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 165      *         the file when the {@code OPEN_DELETE} flag is set.
 166      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 167      * @see SecurityManager#checkRead(java.lang.String)
 168      * @since 1.3
 169      */
 170     public ZipFile(File file, int mode) throws IOException {
 171         this(file, mode, UTF_8.INSTANCE);
 172     }
 173 
 174     /**
 175      * Opens a ZIP file for reading given the specified File object.
 176      *
 177      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 178      * decode the entry names and comments.
 179      *
 180      * @param file the ZIP file to be opened for reading
 181      * @throws ZipException if a ZIP format error has occurred
 182      * @throws IOException if an I/O error has occurred
 183      */
 184     public ZipFile(File file) throws ZipException, IOException {
 185         this(file, OPEN_READ);
 186     }
 187 
 188     /**
 189      * Opens a new {@code ZipFile} to read from the specified
 190      * {@code File} object in the specified mode.  The mode argument
 191      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 192      *
 193      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 194      * method is called with the {@code name} argument as its argument to
 195      * ensure the read is allowed.
 196      *
 197      * @param file the ZIP file to be opened for reading
 198      * @param mode the mode in which the file is to be opened
 199      * @param charset
 200      *        the {@linkplain java.nio.charset.Charset charset} to
 201      *        be used to decode the ZIP entry name and comment that are not
 202      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 203      *        purpose flag).
 204      *
 205      * @throws ZipException if a ZIP format error has occurred
 206      * @throws IOException if an I/O error has occurred
 207      *
 208      * @throws SecurityException
 209      *         if a security manager exists and its {@code checkRead}
 210      *         method doesn&#39;t allow read access to the file,or its
 211      *         {@code checkDelete} method doesn&#39;t allow deleting the
 212      *         file when the {@code OPEN_DELETE} flag is set
 213      *
 214      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 215      *
 216      * @see SecurityManager#checkRead(java.lang.String)
 217      *
 218      * @since 1.7
 219      */
 220     public ZipFile(File file, int mode, Charset charset) throws IOException
 221     {
 222         if (((mode &amp; OPEN_READ) == 0) ||
 223             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 224             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 225                                                Integer.toHexString(mode));
 226         }
 227         String name = file.getPath();
 228         SecurityManager sm = System.getSecurityManager();
 229         if (sm != null) {
 230             sm.checkRead(name);
 231             if ((mode &amp; OPEN_DELETE) != 0) {
 232                 sm.checkDelete(name);
 233             }
 234         }
 235         Objects.requireNonNull(charset, &quot;charset&quot;);
 236 
 237         this.name = name;
 238         long t0 = System.nanoTime();
 239 
 240         this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);
 241 
 242         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 243         PerfCounter.getZipFileCount().increment();
 244     }
 245 
 246     /**
 247      * Opens a zip file for reading.
 248      *
 249      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 250      * method is called with the {@code name} argument as its argument
 251      * to ensure the read is allowed.
 252      *
 253      * @param name the name of the zip file
 254      * @param charset
 255      *        the {@linkplain java.nio.charset.Charset charset} to
 256      *        be used to decode the ZIP entry name and comment that are not
 257      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 258      *        purpose flag).
 259      *
 260      * @throws ZipException if a ZIP format error has occurred
 261      * @throws IOException if an I/O error has occurred
 262      * @throws SecurityException
 263      *         if a security manager exists and its {@code checkRead}
 264      *         method doesn&#39;t allow read access to the file
 265      *
 266      * @see SecurityManager#checkRead(java.lang.String)
 267      *
 268      * @since 1.7
 269      */
 270     public ZipFile(String name, Charset charset) throws IOException
 271     {
 272         this(new File(name), OPEN_READ, charset);
 273     }
 274 
 275     /**
 276      * Opens a ZIP file for reading given the specified File object.
 277      *
 278      * @param file the ZIP file to be opened for reading
 279      * @param charset
 280      *        The {@linkplain java.nio.charset.Charset charset} to be
 281      *        used to decode the ZIP entry name and comment (ignored if
 282      *        the &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 283      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 284      *        flag is set).
 285      *
 286      * @throws ZipException if a ZIP format error has occurred
 287      * @throws IOException if an I/O error has occurred
 288      *
 289      * @since 1.7
 290      */
 291     public ZipFile(File file, Charset charset) throws IOException
 292     {
 293         this(file, OPEN_READ, charset);
 294     }
 295 
 296     /**
 297      * Returns the zip file comment, or null if none.
 298      *
 299      * @return the comment string for the zip file, or null if none
 300      *
 301      * @throws IllegalStateException if the zip file has been closed
 302      *
 303      * @since 1.7
 304      */
 305     public String getComment() {
 306         synchronized (this) {
 307             ensureOpen();
 308             if (res.zsrc.comment == null) {
 309                 return null;
 310             }
 311             return res.zsrc.zc.toString(res.zsrc.comment);
 312         }
 313     }
 314 
 315     /**
 316      * Returns the zip file entry for the specified name, or null
 317      * if not found.
 318      *
 319      * @param name the name of the entry
 320      * @return the zip file entry, or null if not found
 321      * @throws IllegalStateException if the zip file has been closed
 322      */
 323     public ZipEntry getEntry(String name) {
 324         Objects.requireNonNull(name, &quot;name&quot;);
 325         ZipEntry entry = null;
 326         synchronized (this) {
 327             ensureOpen();
 328             int pos = res.zsrc.getEntryPos(name, true);
 329             if (pos != -1) {
 330                 entry = getZipEntry(name, pos);
 331             }
 332         }
 333         return entry;
 334     }
 335 
 336     /**
 337      * Returns an input stream for reading the contents of the specified
 338      * zip file entry.
 339      * &lt;p&gt;
 340      * Closing this ZIP file will, in turn, close all input streams that
 341      * have been returned by invocations of this method.
 342      *
 343      * @param entry the zip file entry
 344      * @return the input stream for reading the contents of the specified
 345      * zip file entry.
 346      * @throws ZipException if a ZIP format error has occurred
 347      * @throws IOException if an I/O error has occurred
 348      * @throws IllegalStateException if the zip file has been closed
 349      */
 350     public InputStream getInputStream(ZipEntry entry) throws IOException {
 351         Objects.requireNonNull(entry, &quot;entry&quot;);
 352         int pos;
 353         ZipFileInputStream in;
 354         Source zsrc = res.zsrc;
 355         Set&lt;InputStream&gt; istreams = res.istreams;
 356         synchronized (this) {
 357             ensureOpen();
 358             if (Objects.equals(lastEntryName, entry.name)) {
 359                 pos = lastEntryPos;
 360             } else {
 361                 pos = zsrc.getEntryPos(entry.name, false);
 362             }
 363             if (pos == -1) {
 364                 return null;
 365             }
 366             in = new ZipFileInputStream(zsrc.cen, pos);
 367             switch (CENHOW(zsrc.cen, pos)) {
 368             case STORED:
 369                 synchronized (istreams) {
 370                     istreams.add(in);
 371                 }
 372                 return in;
 373             case DEFLATED:
 374                 // Inflater likes a bit of slack
 375                 // MORE: Compute good size for inflater stream:
 376                 long size = CENLEN(zsrc.cen, pos) + 2;
 377                 if (size &gt; 65536) {
 378                     size = 8192;
 379                 }
 380                 if (size &lt;= 0) {
 381                     size = 4096;
 382                 }
 383                 InputStream is = new ZipFileInflaterInputStream(in, res, (int)size);
 384                 synchronized (istreams) {
 385                     istreams.add(is);
 386                 }
 387                 return is;
 388             default:
 389                 throw new ZipException(&quot;invalid compression method&quot;);
 390             }
 391         }
 392     }
 393 
 394     private static class InflaterCleanupAction implements Runnable {
 395         private final Inflater inf;
 396         private final CleanableResource res;
 397 
 398         InflaterCleanupAction(Inflater inf, CleanableResource res) {
 399             this.inf = inf;
 400             this.res = res;
 401         }
 402 
 403         @Override
 404         public void run() {
 405             res.releaseInflater(inf);
 406         }
 407     }
 408 
 409     private class ZipFileInflaterInputStream extends InflaterInputStream {
 410         private volatile boolean closeRequested;
 411         private boolean eof = false;
 412         private final Cleanable cleanable;
 413 
 414         ZipFileInflaterInputStream(ZipFileInputStream zfin,
 415                                    CleanableResource res, int size) {
 416             this(zfin, res, res.getInflater(), size);
 417         }
 418 
 419         private ZipFileInflaterInputStream(ZipFileInputStream zfin,
 420                                            CleanableResource res,
 421                                            Inflater inf, int size) {
 422             super(zfin, inf, size);
 423             this.cleanable = CleanerFactory.cleaner().register(this,
 424                     new InflaterCleanupAction(inf, res));
 425         }
 426 
 427         public void close() throws IOException {
 428             if (closeRequested)
 429                 return;
 430             closeRequested = true;
 431             super.close();
 432             synchronized (res.istreams) {
 433                 res.istreams.remove(this);
 434             }
 435             cleanable.clean();
 436         }
 437 
 438         // Override fill() method to provide an extra &quot;dummy&quot; byte
 439         // at the end of the input stream. This is required when
 440         // using the &quot;nowrap&quot; Inflater option.
 441         protected void fill() throws IOException {
 442             if (eof) {
 443                 throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
 444             }
 445             len = in.read(buf, 0, buf.length);
 446             if (len == -1) {
 447                 buf[0] = 0;
 448                 len = 1;
 449                 eof = true;
 450             }
 451             inf.setInput(buf, 0, len);
 452         }
 453 
 454         public int available() throws IOException {
 455             if (closeRequested)
 456                 return 0;
 457             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 458             return (avail &gt; (long) Integer.MAX_VALUE ?
 459                     Integer.MAX_VALUE : (int) avail);
 460         }
 461     }
 462 
 463     /**
 464      * Returns the path name of the ZIP file.
 465      * @return the path name of the ZIP file
 466      */
 467     public String getName() {
 468         return name;
 469     }
 470 
 471     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 472             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 473 
 474         private int i = 0;
 475         private final int entryCount;
 476 
 477         public ZipEntryIterator(int entryCount) {
 478             this.entryCount = entryCount;
 479         }
 480 
 481         @Override
 482         public boolean hasMoreElements() {
 483             return hasNext();
 484         }
 485 
 486         @Override
 487         public boolean hasNext() {
 488             return i &lt; entryCount;
 489         }
 490 
 491         @Override
 492         public T nextElement() {
 493             return next();
 494         }
 495 
 496         @Override
 497         @SuppressWarnings(&quot;unchecked&quot;)
 498         public T next() {
 499             synchronized (ZipFile.this) {
 500                 ensureOpen();
 501                 if (!hasNext()) {
 502                     throw new NoSuchElementException();
 503                 }
 504                 // each &quot;entry&quot; has 3 ints in table entries
 505                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3));
 506             }
 507         }
 508 
 509         @Override
 510         public Iterator&lt;T&gt; asIterator() {
 511             return this;
 512         }
 513     }
 514 
 515     /**
 516      * Returns an enumeration of the ZIP file entries.
 517      * @return an enumeration of the ZIP file entries
 518      * @throws IllegalStateException if the zip file has been closed
 519      */
 520     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 521         synchronized (this) {
 522             ensureOpen();
 523             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total);
 524         }
 525     }
 526 
 527     private Enumeration&lt;JarEntry&gt; jarEntries() {
 528         synchronized (this) {
 529             ensureOpen();
 530             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total);
 531         }
 532     }
 533 
 534     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 535         private int index;
 536         private final int fence;
 537         private final IntFunction&lt;T&gt; gen;
 538 
 539         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 540             super((long)fence,
 541                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 542                   Spliterator.NONNULL);
 543             this.index = index;
 544             this.fence = fence;
 545             this.gen = gen;
 546         }
 547 
 548         @Override
 549         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 550             if (action == null)
 551                 throw new NullPointerException();
 552             if (index &gt;= 0 &amp;&amp; index &lt; fence) {
 553                 synchronized (ZipFile.this) {
 554                     ensureOpen();
 555                     action.accept(gen.apply(res.zsrc.getEntryPos(index++ * 3)));
 556                 }
 557                 return true;
 558             }
 559             return false;
 560         }
 561     }
 562 
 563     /**
 564      * Returns an ordered {@code Stream} over the ZIP file entries.
 565      *
 566      * Entries appear in the {@code Stream} in the order they appear in
 567      * the central directory of the ZIP file.
 568      *
 569      * @return an ordered {@code Stream} of entries in this ZIP file
 570      * @throws IllegalStateException if the zip file has been closed
 571      * @since 1.8
 572      */
 573     public Stream&lt;? extends ZipEntry&gt; stream() {
 574         synchronized (this) {
 575             ensureOpen();
 576             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 577                 pos -&gt; getZipEntry(null, pos)), false);
 578        }
 579     }
 580 
 581     private String getEntryName(int pos) {
 582         byte[] cen = res.zsrc.cen;
 583         int nlen = CENNAM(cen, pos);
 584         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 585         return zc.toString(cen, pos + CENHDR, nlen);
 586     }
 587 
 588     /*
 589      * Returns an ordered {@code Stream} over the zip file entry names.
 590      *
 591      * Entry names appear in the {@code Stream} in the order they appear in
 592      * the central directory of the ZIP file.
 593      *
 594      * @return an ordered {@code Stream} of entry names in this zip file
 595      * @throws IllegalStateException if the zip file has been closed
 596      * @since 10
 597      */
 598     private Stream&lt;String&gt; entryNameStream() {
 599         synchronized (this) {
 600             ensureOpen();
 601             return StreamSupport.stream(
 602                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 603         }
 604     }
 605 
 606     /*
 607      * Returns an ordered {@code Stream} over the zip file entries.
 608      *
 609      * Entries appear in the {@code Stream} in the order they appear in
 610      * the central directory of the jar file.
 611      *
 612      * @return an ordered {@code Stream} of entries in this zip file
 613      * @throws IllegalStateException if the zip file has been closed
 614      * @since 10
 615      */
 616     private Stream&lt;JarEntry&gt; jarStream() {
 617         synchronized (this) {
 618             ensureOpen();
 619             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 620                 pos -&gt; (JarEntry)getZipEntry(null, pos)), false);
 621         }
 622     }
 623 
 624     private String lastEntryName;
 625     private int lastEntryPos;
 626 
 627     /* Check ensureOpen() before invoking this method */
 628     private ZipEntry getZipEntry(String name, int pos) {
 629         byte[] cen = res.zsrc.cen;
 630         int nlen = CENNAM(cen, pos);
 631         int elen = CENEXT(cen, pos);
 632         int clen = CENCOM(cen, pos);
 633 
 634         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 635         if (name != null) {
 636             // only need to check for mismatch of trailing slash
 637             if (nlen &gt; 0 &amp;&amp;
 638                 !name.isEmpty() &amp;&amp;
 639                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;
 640                 !name.endsWith(&quot;/&quot;))
 641             {
 642                 name += &#39;/&#39;;
 643             }
 644         } else {
 645             // invoked from iterator, use the entry name stored in cen
 646             name = zc.toString(cen, pos + CENHDR, nlen);
 647         }
 648         ZipEntry e;
 649         if (this instanceof JarFile) {
 650             e = Source.JUJA.entryFor((JarFile)this, name);
 651         } else {
 652             e = new ZipEntry(name);
 653         }
 654         e.flag = CENFLG(cen, pos);
 655         e.xdostime = CENTIM(cen, pos);
 656         e.crc = CENCRC(cen, pos);
 657         e.size = CENLEN(cen, pos);
 658         e.csize = CENSIZ(cen, pos);
 659         e.method = CENHOW(cen, pos);
<a name="1" id="anc1"></a>




 660         if (elen != 0) {
 661             int start = pos + CENHDR + nlen;
 662             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 663         }
 664         if (clen != 0) {
 665             int start = pos + CENHDR + nlen + elen;
 666             e.comment = zc.toString(cen, start, clen);
 667         }
 668         lastEntryName = e.name;
 669         lastEntryPos = pos;
 670         return e;
 671     }
 672 
 673     /**
 674      * Returns the number of entries in the ZIP file.
 675      *
 676      * @return the number of entries in the ZIP file
 677      * @throws IllegalStateException if the zip file has been closed
 678      */
 679     public int size() {
 680         synchronized (this) {
 681             ensureOpen();
 682             return res.zsrc.total;
 683         }
 684     }
 685 
 686     private static class CleanableResource implements Runnable {
 687         // The outstanding inputstreams that need to be closed
 688         final Set&lt;InputStream&gt; istreams;
 689 
 690         // List of cached Inflater objects for decompression
 691         Deque&lt;Inflater&gt; inflaterCache;
 692 
 693         final Cleanable cleanable;
 694 
 695         Source zsrc;
 696 
 697         CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {
 698             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 699             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 700             this.inflaterCache = new ArrayDeque&lt;&gt;();
 701             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zc);
 702         }
 703 
 704         void clean() {
 705             cleanable.clean();
 706         }
 707 
 708         /*
 709          * Gets an inflater from the list of available inflaters or allocates
 710          * a new one.
 711          */
 712         Inflater getInflater() {
 713             Inflater inf;
 714             synchronized (inflaterCache) {
 715                 if ((inf = inflaterCache.poll()) != null) {
 716                     return inf;
 717                 }
 718             }
 719             return new Inflater(true);
 720         }
 721 
 722         /*
 723          * Releases the specified inflater to the list of available inflaters.
 724          */
 725         void releaseInflater(Inflater inf) {
 726             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 727             if (inflaters != null) {
 728                 synchronized (inflaters) {
 729                     // double checked!
 730                     if (inflaters == this.inflaterCache) {
 731                         inf.reset();
 732                         inflaters.add(inf);
 733                         return;
 734                     }
 735                 }
 736             }
 737             // inflaters cache already closed - just end it.
 738             inf.end();
 739         }
 740 
 741         public void run() {
 742             IOException ioe = null;
 743 
 744             // Release cached inflaters and close the cache first
 745             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 746             if (inflaters != null) {
 747                 synchronized (inflaters) {
 748                     // no need to double-check as only one thread gets a
 749                     // chance to execute run() (Cleaner guarantee)...
 750                     Inflater inf;
 751                     while ((inf = inflaters.poll()) != null) {
 752                         inf.end();
 753                     }
 754                     // close inflaters cache
 755                     this.inflaterCache = null;
 756                 }
 757             }
 758 
 759             // Close streams, release their inflaters
 760             if (istreams != null) {
 761                 synchronized (istreams) {
 762                     if (!istreams.isEmpty()) {
 763                         InputStream[] copy = istreams.toArray(new InputStream[0]);
 764                         istreams.clear();
 765                         for (InputStream is : copy) {
 766                             try {
 767                                 is.close();
 768                             } catch (IOException e) {
 769                                 if (ioe == null) ioe = e;
 770                                 else ioe.addSuppressed(e);
 771                             }
 772                         }
 773                     }
 774                 }
 775             }
 776 
 777             // Release zip src
 778             if (zsrc != null) {
 779                 synchronized (zsrc) {
 780                     try {
 781                         Source.release(zsrc);
 782                         zsrc = null;
 783                     } catch (IOException e) {
 784                         if (ioe == null) ioe = e;
 785                         else ioe.addSuppressed(e);
 786                     }
 787                 }
 788             }
 789             if (ioe != null) {
 790                 throw new UncheckedIOException(ioe);
 791             }
 792         }
 793 
 794     }
 795 
 796     /**
 797      * Closes the ZIP file.
 798      *
 799      * &lt;p&gt; Closing this ZIP file will close all of the input streams
 800      * previously returned by invocations of the {@link #getInputStream
 801      * getInputStream} method.
 802      *
 803      * @throws IOException if an I/O error has occurred
 804      */
 805     public void close() throws IOException {
 806         if (closeRequested) {
 807             return;
 808         }
 809         closeRequested = true;
 810 
 811         synchronized (this) {
 812             // Close streams, release their inflaters, release cached inflaters
 813             // and release zip source
 814             try {
 815                 res.clean();
 816             } catch (UncheckedIOException ioe) {
 817                 throw ioe.getCause();
 818             }
 819         }
 820     }
 821 
 822     private void ensureOpen() {
 823         if (closeRequested) {
 824             throw new IllegalStateException(&quot;zip file closed&quot;);
 825         }
 826         if (res.zsrc == null) {
 827             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 828         }
 829     }
 830 
 831     private void ensureOpenOrZipException() throws IOException {
 832         if (closeRequested) {
 833             throw new ZipException(&quot;ZipFile closed&quot;);
 834         }
 835     }
 836 
 837     /*
 838      * Inner class implementing the input stream used to read a
 839      * (possibly compressed) zip file entry.
 840      */
 841     private class ZipFileInputStream extends InputStream {
 842         private volatile boolean closeRequested;
 843         private   long pos;     // current position within entry data
 844         private   long startingPos; // Start position for the entry data
 845         protected long rem;     // number of remaining bytes within entry
 846         protected long size;    // uncompressed size of this entry
 847 
 848         ZipFileInputStream(byte[] cen, int cenpos) {
 849             rem = CENSIZ(cen, cenpos);
 850             size = CENLEN(cen, cenpos);
 851             pos = CENOFF(cen, cenpos);
 852             // zip64
 853             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 854                 pos == ZIP64_MAGICVAL) {
 855                 checkZIP64(cen, cenpos);
 856             }
 857             // negative for lazy initialization, see getDataOffset();
 858             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 859         }
 860 
 861         private void checkZIP64(byte[] cen, int cenpos) {
 862             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 863             int end = off + CENEXT(cen, cenpos);
 864             while (off + 4 &lt; end) {
 865                 int tag = get16(cen, off);
 866                 int sz = get16(cen, off + 2);
 867                 off += 4;
 868                 if (off + sz &gt; end)         // invalid data
 869                     break;
 870                 if (tag == EXTID_ZIP64) {
 871                     if (size == ZIP64_MAGICVAL) {
 872                         if (sz &lt; 8 || (off + 8) &gt; end)
 873                             break;
 874                         size = get64(cen, off);
 875                         sz -= 8;
 876                         off += 8;
 877                     }
 878                     if (rem == ZIP64_MAGICVAL) {
 879                         if (sz &lt; 8 || (off + 8) &gt; end)
 880                             break;
 881                         rem = get64(cen, off);
 882                         sz -= 8;
 883                         off += 8;
 884                     }
 885                     if (pos == ZIP64_MAGICVAL) {
 886                         if (sz &lt; 8 || (off + 8) &gt; end)
 887                             break;
 888                         pos = get64(cen, off);
 889                         sz -= 8;
 890                         off += 8;
 891                     }
 892                     break;
 893                 }
 894                 off += sz;
 895             }
 896         }
 897 
 898         /*
 899          * The Zip file spec explicitly allows the LOC extra data size to
 900          * be different from the CEN extra data size. Since we cannot trust
 901          * the CEN extra data size, we need to read the LOC to determine
 902          * the entry data offset.
 903          */
 904         private long initDataOffset() throws IOException {
 905             if (pos &lt;= 0) {
 906                 byte[] loc = new byte[LOCHDR];
 907                 pos = -pos;
 908                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 909                 if (len != LOCHDR) {
 910                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 911                 }
 912                 if (LOCSIG(loc) != LOCSIG) {
 913                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 914                 }
 915                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);
 916                 startingPos = pos; // Save starting position for the entry
 917             }
 918             return pos;
 919         }
 920 
 921         public int read(byte b[], int off, int len) throws IOException {
 922             synchronized (ZipFile.this) {
 923                 ensureOpenOrZipException();
 924                 initDataOffset();
 925                 if (rem == 0) {
 926                     return -1;
 927                 }
 928                 if (len &gt; rem) {
 929                     len = (int) rem;
 930                 }
 931                 if (len &lt;= 0) {
 932                     return 0;
 933                 }
 934                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 935                 if (len &gt; 0) {
 936                     pos += len;
 937                     rem -= len;
 938                 }
 939             }
 940             if (rem == 0) {
 941                 close();
 942             }
 943             return len;
 944         }
 945 
 946         public int read() throws IOException {
 947             byte[] b = new byte[1];
 948             if (read(b, 0, 1) == 1) {
 949                 return b[0] &amp; 0xff;
 950             } else {
 951                 return -1;
 952             }
 953         }
 954 
 955         public long skip(long n) throws IOException {
 956             synchronized (ZipFile.this) {
 957                 initDataOffset();
 958                 long newPos = pos + n;
 959                 if (n &gt; 0) {
 960                     // If we overflowed adding the skip value or are moving
 961                     // past EOF, set the skip value to number of bytes remaining
 962                     // to reach EOF
 963                     if (newPos &lt; 0 || n &gt; rem) {
 964                         n = rem;
 965                     }
 966                 } else if (newPos &lt; startingPos) {
 967                     // Tried to position before BOF so set position to the
 968                     // BOF and return the number of bytes we moved backwards
 969                     // to reach BOF
 970                     n = startingPos - pos;
 971                 }
 972                 pos += n;
 973                 rem -= n;
 974             }
 975             if (rem == 0) {
 976                 close();
 977             }
 978             return n;
 979         }
 980 
 981         public int available() {
 982             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
 983         }
 984 
 985         public long size() {
 986             return size;
 987         }
 988 
 989         public void close() {
 990             if (closeRequested) {
 991                 return;
 992             }
 993             closeRequested = true;
 994             rem = 0;
 995             synchronized (res.istreams) {
 996                 res.istreams.remove(this);
 997             }
 998         }
 999 
1000     }
1001 
1002     /**
1003      * Returns the names of the META-INF/MANIFEST.MF entry - if exists -
1004      * and any signature-related files under META-INF. This method is used in
1005      * JarFile, via SharedSecrets, as an optimization.
1006      */
1007     private List&lt;String&gt; getManifestAndSignatureRelatedFiles() {
1008         synchronized (this) {
1009             ensureOpen();
1010             Source zsrc = res.zsrc;
1011             int[] metanames = zsrc.signatureMetaNames;
1012             List&lt;String&gt; files = null;
1013             if (zsrc.manifestPos &gt;= 0) {
1014                 files = new ArrayList&lt;&gt;();
1015                 files.add(getEntryName(zsrc.manifestPos));
1016             }
1017             if (metanames != null) {
1018                 if (files == null) {
1019                     files = new ArrayList&lt;&gt;();
1020                 }
1021                 for (int i = 0; i &lt; metanames.length; i++) {
1022                     files.add(getEntryName(metanames[i]));
1023                 }
1024             }
1025             return files == null ? List.of() : files;
1026         }
1027     }
1028 
1029     /**
1030      * Returns the name of the META-INF/MANIFEST.MF entry, ignoring
1031      * case. If {@code onlyIfSignatureRelatedFiles} is true, we only return the
1032      * manifest if there is also at least one signature-related file.
1033      * This method is used in JarFile, via SharedSecrets, as an optimization
1034      * when looking up the manifest file.
1035      */
1036     private String getManifestName(boolean onlyIfSignatureRelatedFiles) {
1037         synchronized (this) {
1038             ensureOpen();
1039             Source zsrc = res.zsrc;
1040             int pos = zsrc.manifestPos;
1041             if (pos &gt;= 0 &amp;&amp; (!onlyIfSignatureRelatedFiles || zsrc.signatureMetaNames != null)) {
1042                 return getEntryName(pos);
1043             }
1044         }
1045         return null;
1046     }
1047 
1048     /**
1049      * Returns the versions for which there exists a non-directory
1050      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
1051      * This method is used in JarFile, via SharedSecrets, as an
1052      * optimization when looking up potentially versioned entries.
1053      * Returns an empty array if no versioned entries exist.
1054      */
1055     private int[] getMetaInfVersions() {
1056         synchronized (this) {
1057             ensureOpen();
1058             return res.zsrc.metaVersions;
1059         }
1060     }
1061 
1062     private static boolean isWindows;
1063 
1064     static {
1065         SharedSecrets.setJavaUtilZipFileAccess(
1066             new JavaUtilZipFileAccess() {
1067                 @Override
1068                 public boolean startsWithLocHeader(ZipFile zip) {
1069                     return zip.res.zsrc.startsWithLoc;
1070                 }
1071                 @Override
1072                 public List&lt;String&gt; getManifestAndSignatureRelatedFiles(JarFile jar) {
1073                     return ((ZipFile)jar).getManifestAndSignatureRelatedFiles();
1074                 }
1075                 @Override
1076                 public String getManifestName(JarFile jar, boolean onlyIfHasSignatureRelatedFiles) {
1077                     return ((ZipFile)jar).getManifestName(onlyIfHasSignatureRelatedFiles);
1078                 }
1079                 @Override
1080                 public int[] getMetaInfVersions(JarFile jar) {
1081                     return ((ZipFile)jar).getMetaInfVersions();
1082                 }
1083                 @Override
1084                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip) {
1085                     return zip.jarEntries();
1086                 }
1087                 @Override
1088                 public Stream&lt;JarEntry&gt; stream(ZipFile zip) {
1089                     return zip.jarStream();
1090                 }
1091                 @Override
1092                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1093                     return zip.entryNameStream();
1094                 }
<a name="2" id="anc2"></a>









1095              }
1096         );
1097         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1098     }
1099 
1100     private static class Source {
1101         // While this is only used from ZipFile, defining it there would cause
1102         // a bootstrap cycle that would leave this initialized as null
1103         private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();
1104         // &quot;META-INF/&quot;.length()
1105         private static final int META_INF_LENGTH = 9;
1106         private static final int[] EMPTY_META_VERSIONS = new int[0];
1107 
1108         private final Key key;               // the key in files
1109         private final @Stable ZipCoder zc;   // zip coder used to decode/encode
1110 
1111         private int refs = 1;
1112 
1113         private RandomAccessFile zfile;      // zfile of the underlying zip file
1114         private byte[] cen;                  // CEN &amp; ENDHDR
1115         private long locpos;                 // position of first LOC header (usually 0)
1116         private byte[] comment;              // zip file comment
1117                                              // list of meta entries in META-INF dir
1118         private int   manifestPos = -1;      // position of the META-INF/MANIFEST.MF, if exists
1119         private int[] signatureMetaNames;    // positions of signature related entries, if such exist
1120         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1121         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1122 
1123         // A Hashmap for all entries.
1124         //
1125         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1126         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1127         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1128         // entry name and its offset {@code pos} in the central directory hdeader.
1129         //
1130         // private static class Entry {
1131         //     int hash;       // 32 bit hashcode on name
1132         //     int next;       // hash chain: index into entries
1133         //     int pos;        // Offset of central directory file header
1134         // }
1135         // private Entry[] entries;             // array of hashed cen entry
1136         //
1137         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1138         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1139         // referred by their index of their positions in the {@code entries}.
1140         //
1141         private int[] entries;                  // array of hashed cen entry
1142         private int addEntry(int index, int hash, int next, int pos) {
1143             entries[index++] = hash;
1144             entries[index++] = next;
1145             entries[index++] = pos;
1146             return index;
1147         }
1148         private int getEntryHash(int index) { return entries[index]; }
1149         private int getEntryNext(int index) { return entries[index + 1]; }
1150         private int getEntryPos(int index)  { return entries[index + 2]; }
1151         private static final int ZIP_ENDCHAIN  = -1;
1152         private int total;                   // total number of entries
1153         private int[] table;                 // Hash chain heads: indexes into entries
1154         private int tablelen;                // number of hash heads
1155 
1156         private static class Key {
1157             final BasicFileAttributes attrs;
1158             File file;
1159             final boolean utf8;
1160 
1161             public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {
1162                 this.attrs = attrs;
1163                 this.file = file;
1164                 this.utf8 = zc.isUTF8();
1165             }
1166 
1167             public int hashCode() {
1168                 long t = utf8 ? 0 : Long.MAX_VALUE;
1169                 t += attrs.lastModifiedTime().toMillis();
1170                 return ((int)(t ^ (t &gt;&gt;&gt; 32))) + file.hashCode();
1171             }
1172 
1173             public boolean equals(Object obj) {
1174                 if (obj instanceof Key) {
1175                     Key key = (Key)obj;
1176                     if (key.utf8 != utf8) {
1177                         return false;
1178                     }
1179                     if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {
1180                         return false;
1181                     }
1182                     Object fk = attrs.fileKey();
1183                     if (fk != null) {
1184                         return fk.equals(key.attrs.fileKey());
1185                     } else {
1186                         return file.equals(key.file);
1187                     }
1188                 }
1189                 return false;
1190             }
1191         }
1192         private static final HashMap&lt;Key, Source&gt; files = new HashMap&lt;&gt;();
1193 
1194 
1195         static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {
1196             final Key key;
1197             try {
1198                 key = new Key(file,
1199                         Files.readAttributes(file.toPath(), BasicFileAttributes.class),
1200                         zc);
1201             } catch (InvalidPathException ipe) {
1202                 throw new IOException(ipe);
1203             }
1204             Source src;
1205             synchronized (files) {
1206                 src = files.get(key);
1207                 if (src != null) {
1208                     src.refs++;
1209                     return src;
1210                 }
1211             }
1212             src = new Source(key, toDelete, zc);
1213 
1214             synchronized (files) {
1215                 if (files.containsKey(key)) {    // someone else put in first
1216                     src.close();                 // close the newly created one
1217                     src = files.get(key);
1218                     src.refs++;
1219                     return src;
1220                 }
1221                 files.put(key, src);
1222                 return src;
1223             }
1224         }
1225 
1226         static void release(Source src) throws IOException {
1227             synchronized (files) {
1228                 if (src != null &amp;&amp; --src.refs == 0) {
1229                     files.remove(src.key);
1230                     src.close();
1231                 }
1232             }
1233         }
1234 
1235         private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {
1236             this.zc = zc;
1237             this.key = key;
1238             if (toDelete) {
1239                 if (isWindows) {
1240                     this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()
1241                                               .openAndDelete(key.file, &quot;r&quot;);
1242                 } else {
1243                     this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1244                     key.file.delete();
1245                 }
1246             } else {
1247                 this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1248             }
1249             try {
1250                 initCEN(-1);
1251                 byte[] buf = new byte[4];
1252                 readFullyAt(buf, 0, 4, 0);
1253                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1254             } catch (IOException x) {
1255                 try {
1256                     this.zfile.close();
1257                 } catch (IOException xx) {}
1258                 throw x;
1259             }
1260         }
1261 
1262         private void close() throws IOException {
1263             zfile.close();
1264             zfile = null;
1265             cen = null;
1266             entries = null;
1267             table = null;
1268             manifestPos = -1;
1269             signatureMetaNames = null;
1270             metaVersions = EMPTY_META_VERSIONS;
1271         }
1272 
1273         private static final int BUF_SIZE = 8192;
1274         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1275             throws IOException
1276         {
1277             synchronized (zfile) {
1278                 zfile.seek(pos);
1279                 int N = len;
1280                 while (N &gt; 0) {
1281                     int n = Math.min(BUF_SIZE, N);
1282                     zfile.readFully(buf, off, n);
1283                     off += n;
1284                     N -= n;
1285                 }
1286                 return len;
1287             }
1288         }
1289 
1290         private final int readAt(byte[] buf, int off, int len, long pos)
1291             throws IOException
1292         {
1293             synchronized (zfile) {
1294                 zfile.seek(pos);
1295                 return zfile.read(buf, off, len);
1296             }
1297         }
1298 
1299         private static class End {
1300             int  centot;     // 4 bytes
1301             long cenlen;     // 4 bytes
1302             long cenoff;     // 4 bytes
1303             long endpos;     // 4 bytes
1304         }
1305 
1306         /*
1307          * Searches for end of central directory (END) header. The contents of
1308          * the END header will be read and placed in endbuf. Returns the file
1309          * position of the END header, otherwise returns -1 if the END header
1310          * was not found or an error occurred.
1311          */
1312         private End findEND() throws IOException {
1313             long ziplen = zfile.length();
1314             if (ziplen &lt;= 0)
1315                 zerror(&quot;zip file is empty&quot;);
1316             End end = new End();
1317             byte[] buf = new byte[READBLOCKSZ];
1318             long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1319             long minPos = minHDR - (buf.length - ENDHDR);
1320             for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1321                 int off = 0;
1322                 if (pos &lt; 0) {
1323                     // Pretend there are some NUL bytes before start of file
1324                     off = (int)-pos;
1325                     Arrays.fill(buf, 0, off, (byte)0);
1326                 }
1327                 int len = buf.length - off;
1328                 if (readFullyAt(buf, off, len, pos + off) != len ) {
1329                     zerror(&quot;zip END header not found&quot;);
1330                 }
1331                 // Now scan the block backwards for END header signature
1332                 for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1333                     if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;
1334                         buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1335                         buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1336                         buf[i+3] == (byte)&#39;\006&#39;) {
1337                         // Found ENDSIG header
1338                         byte[] endbuf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1339                         end.centot = ENDTOT(endbuf);
1340                         end.cenlen = ENDSIZ(endbuf);
1341                         end.cenoff = ENDOFF(endbuf);
1342                         end.endpos = pos + i;
1343                         int comlen = ENDCOM(endbuf);
1344                         if (end.endpos + ENDHDR + comlen != ziplen) {
1345                             // ENDSIG matched, however the size of file comment in it does
1346                             // not match the real size. One &quot;common&quot; cause for this problem
1347                             // is some &quot;extra&quot; bytes are padded at the end of the zipfile.
1348                             // Let&#39;s do some extra verification, we don&#39;t care about the
1349                             // performance in this situation.
1350                             byte[] sbuf = new byte[4];
1351                             long cenpos = end.endpos - end.cenlen;
1352                             long locpos = cenpos - end.cenoff;
1353                             if  (cenpos &lt; 0 ||
1354                                  locpos &lt; 0 ||
1355                                  readFullyAt(sbuf, 0, sbuf.length, cenpos) != 4 ||
1356                                  GETSIG(sbuf) != CENSIG ||
1357                                  readFullyAt(sbuf, 0, sbuf.length, locpos) != 4 ||
1358                                  GETSIG(sbuf) != LOCSIG) {
1359                                 continue;
1360                             }
1361                         }
1362                         if (comlen &gt; 0) {    // this zip file has comlen
1363                             comment = new byte[comlen];
1364                             if (readFullyAt(comment, 0, comlen, end.endpos + ENDHDR) != comlen) {
1365                                 zerror(&quot;zip comment read failed&quot;);
1366                             }
1367                         }
1368                         // must check for a zip64 end record; it is always permitted to be present
1369                         try {
1370                             byte[] loc64 = new byte[ZIP64_LOCHDR];
1371                             if (end.endpos &lt; ZIP64_LOCHDR ||
1372                                 readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1373                                 != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {
1374                                 return end;
1375                             }
1376                             long end64pos = ZIP64_LOCOFF(loc64);
1377                             byte[] end64buf = new byte[ZIP64_ENDHDR];
1378                             if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1379                                 != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {
1380                                 return end;
1381                             }
1382                             // end64 candidate found,
1383                             long cenlen64 = ZIP64_ENDSIZ(end64buf);
1384                             long cenoff64 = ZIP64_ENDOFF(end64buf);
1385                             long centot64 = ZIP64_ENDTOT(end64buf);
1386                             // double-check
1387                             if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MAGICVAL ||
1388                                 cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MAGICVAL ||
1389                                 centot64 != end.centot &amp;&amp; end.centot != ZIP64_MAGICCOUNT) {
1390                                 return end;
1391                             }
1392                             // to use the end64 values
1393                             end.cenlen = cenlen64;
1394                             end.cenoff = cenoff64;
1395                             end.centot = (int)centot64; // assume total &lt; 2g
1396                             end.endpos = end64pos;
1397                         } catch (IOException x) {}    // no zip64 loc/end
1398                         return end;
1399                     }
1400                 }
1401             }
1402             zerror(&quot;zip END header not found&quot;);
1403             return null; //make compiler happy
1404         }
1405 
1406         // Reads zip file central directory.
1407         private void initCEN(int knownTotal) throws IOException {
1408             // Prefer locals for better performance during startup
1409             byte[] cen;
1410             if (knownTotal == -1) {
1411                 End end = findEND();
1412                 if (end.endpos == 0) {
1413                     locpos = 0;
1414                     total = 0;
1415                     entries = new int[0];
1416                     this.cen = null;
1417                     return;         // only END header present
1418                 }
1419                 if (end.cenlen &gt; end.endpos)
1420                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1421                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1422                 // Get position of first local file (LOC) header, taking into
1423                 // account that there may be a stub prefixed to the zip file.
1424                 locpos = cenpos - end.cenoff;
1425                 if (locpos &lt; 0) {
1426                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1427                 }
1428                 // read in the CEN and END
1429                 cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];
1430                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1431                     zerror(&quot;read CEN tables failed&quot;);
1432                 }
1433                 total = end.centot;
1434             } else {
1435                 cen = this.cen;
1436                 total = knownTotal;
1437             }
1438             // hash table for entries
1439             entries  = new int[total * 3];
1440 
1441             this.tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1442             int tablelen = this.tablelen;
1443 
1444             this.table = new int[tablelen];
1445             int[] table = this.table;
1446 
1447             Arrays.fill(table, ZIP_ENDCHAIN);
1448             int idx = 0;
1449             int hash;
1450             int next;
1451 
1452             // list for all meta entries
1453             ArrayList&lt;Integer&gt; signatureNames = null;
1454             // Set of all version numbers seen in META-INF/versions/
1455             Set&lt;Integer&gt; metaVersionsSet = null;
1456 
1457             // Iterate through the entries in the central directory
1458             int i = 0;
1459             int hsh;
1460             int pos = 0;
1461             int entryPos = CENHDR;
1462             int limit = cen.length - ENDHDR;
1463             while (entryPos &lt;= limit) {
1464                 if (i &gt;= total) {
1465                     // This will only happen if the zip file has an incorrect
1466                     // ENDTOT field, which usually means it contains more than
1467                     // 65535 entries.
1468                     initCEN(countCENHeaders(cen, limit));
1469                     return;
1470                 }
1471                 if (CENSIG(cen, pos) != CENSIG)
1472                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1473                 int method = CENHOW(cen, pos);
1474                 int nlen   = CENNAM(cen, pos);
1475                 int elen   = CENEXT(cen, pos);
1476                 int clen   = CENCOM(cen, pos);
1477                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1478                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1479                 if (method != STORED &amp;&amp; method != DEFLATED)
1480                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1481                 if (entryPos + nlen &gt; limit)
1482                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1483                 // Record the CEN offset and the name hash in our hash cell.
1484                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);
1485                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1486                 next = table[hsh];
1487                 table[hsh] = idx;
1488                 idx = addEntry(idx, hash, next, pos);
1489                 // Adds name to metanames.
1490                 if (isMetaName(cen, entryPos, nlen)) {
1491                     // nlen is at least META_INF_LENGTH
1492                     if (isManifestName(cen, entryPos + META_INF_LENGTH,
1493                             nlen - META_INF_LENGTH)) {
1494                         manifestPos = pos;
1495                     } else {
1496                         if (isSignatureRelated(cen, entryPos, nlen)) {
1497                             if (signatureNames == null)
1498                                 signatureNames = new ArrayList&lt;&gt;(4);
1499                             signatureNames.add(pos);
1500                         }
1501 
1502                         // If this is a versioned entry, parse the version
1503                         // and store it for later. This optimizes lookup
1504                         // performance in multi-release jar files
1505                         int version = getMetaVersion(cen,
1506                             entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);
1507                         if (version &gt; 0) {
1508                             if (metaVersionsSet == null)
1509                                 metaVersionsSet = new TreeSet&lt;&gt;();
1510                             metaVersionsSet.add(version);
1511                         }
1512                     }
1513                 }
1514                 // skip ext and comment
1515                 pos = entryPos + nlen + elen + clen;
1516                 entryPos = pos + CENHDR;
1517                 i++;
1518             }
1519             total = i;
1520             if (signatureNames != null) {
1521                 int len = signatureNames.size();
1522                 signatureMetaNames = new int[len];
1523                 for (int j = 0; j &lt; len; j++) {
1524                     signatureMetaNames[j] = signatureNames.get(j);
1525                 }
1526             }
1527             if (metaVersionsSet != null) {
1528                 metaVersions = new int[metaVersionsSet.size()];
1529                 int c = 0;
1530                 for (Integer version : metaVersionsSet) {
1531                     metaVersions[c++] = version;
1532                 }
1533             } else {
1534                 metaVersions = EMPTY_META_VERSIONS;
1535             }
1536             if (pos + ENDHDR != cen.length) {
1537                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1538             }
1539         }
1540 
1541         private static void zerror(String msg) throws ZipException {
1542             throw new ZipException(msg);
1543         }
1544 
1545         /*
1546          * Returns the {@code pos} of the zip cen entry corresponding to the
1547          * specified entry name, or -1 if not found.
1548          */
1549         private int getEntryPos(String name, boolean addSlash) {
1550             if (total == 0) {
1551                 return -1;
1552             }
1553 
1554             int hsh = ZipCoder.normalizedHash(name);
1555             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1556 
1557             // Search down the target hash chain for a entry whose
1558             // 32 bit hash matches the hashed name.
1559             while (idx != ZIP_ENDCHAIN) {
1560                 if (getEntryHash(idx) == hsh) {
1561                     // The CEN name must match the specfied one
1562                     int pos = getEntryPos(idx);
1563 
1564                     try {
1565                         ZipCoder zc = zipCoderForPos(pos);
1566                         String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));
1567 
1568                         // If addSlash is true we&#39;ll test for name+/ in addition to
1569                         // name, unless name is the empty string or already ends with a
1570                         // slash
1571                         int entryLen = entry.length();
1572                         int nameLen = name.length();
1573                         if ((entryLen == nameLen &amp;&amp; entry.equals(name)) ||
1574                                 (addSlash &amp;&amp;
1575                                 nameLen + 1 == entryLen &amp;&amp;
1576                                 entry.startsWith(name) &amp;&amp;
1577                                 entry.charAt(entryLen - 1) == &#39;/&#39;)) {
1578                             return pos;
1579                         }
1580                     } catch (IllegalArgumentException iae) {
1581                         // Ignore
1582                     }
1583                 }
1584                 idx = getEntryNext(idx);
1585             }
1586             return -1;
1587         }
1588 
1589         private ZipCoder zipCoderForPos(int pos) {
1590             if (zc.isUTF8()) {
1591                 return zc;
1592             }
1593             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {
1594                 return ZipCoder.UTF8;
1595             }
1596             return zc;
1597         }
1598 
1599         /**
1600          * Returns true if the bytes represent a non-directory name
1601          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1602          */
1603         private static boolean isMetaName(byte[] name, int off, int len) {
1604             // Use the &quot;oldest ASCII trick in the book&quot;:
1605             // ch | 0x20 == Character.toLowerCase(ch)
1606             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1607                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1608                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1609                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1610                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1611                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1612                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1613                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1614                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1615                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1616                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1617         }
1618 
1619         /*
1620          * Check if the bytes represents a name equals to MANIFEST.MF
1621          */
1622         private static boolean isManifestName(byte[] name, int off, int len) {
1623             return (len == 11 // &quot;MANIFEST.MF&quot;.length()
1624                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1625                     &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1626                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1627                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1628                     &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1629                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1630                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1631                     &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1632                     &amp;&amp; (name[off++]       ) == &#39;.&#39;
1633                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1634                     &amp;&amp; (name[off]   | 0x20) == &#39;f&#39;);
1635         }
1636 
1637         private static boolean isSignatureRelated(byte[] name, int off, int len) {
1638             // Only called when isMetaName(name, off, len) is true, which means
1639             // len is at least META_INF_LENGTH
1640             // assert isMetaName(name, off, len)
1641             boolean signatureRelated = false;
1642             if (name[off + len - 3] == &#39;.&#39;) {
1643                 // Check if entry ends with .EC and .SF
1644                 int b1 = name[off + len - 2] | 0x20;
1645                 int b2 = name[off + len - 1] | 0x20;
1646                 if ((b1 == &#39;e&#39; &amp;&amp; b2 == &#39;c&#39;) || (b1 == &#39;s&#39; &amp;&amp; b2 == &#39;f&#39;)) {
1647                     signatureRelated = true;
1648                 }
1649             } else if (name[off + len - 4] == &#39;.&#39;) {
1650                 // Check if entry ends with .DSA and .RSA
1651                 int b1 = name[off + len - 3] | 0x20;
1652                 int b2 = name[off + len - 2] | 0x20;
1653                 int b3 = name[off + len - 1] | 0x20;
1654                 if ((b1 == &#39;r&#39; || b1 == &#39;d&#39;) &amp;&amp; b2 == &#39;s&#39; &amp;&amp; b3 == &#39;a&#39;) {
1655                     signatureRelated = true;
1656                 }
1657             }
1658             // Above logic must match SignatureFileVerifier.isBlockOrSF
1659             assert(signatureRelated == SignatureFileVerifier
1660                 .isBlockOrSF(new String(name, off, len, UTF_8.INSTANCE)
1661                     .toUpperCase(Locale.ENGLISH)));
1662             return signatureRelated;
1663         }
1664 
1665         /*
1666          * If the bytes represents a non-directory name beginning
1667          * with &quot;versions/&quot;, continuing with a positive integer,
1668          * followed by a &#39;/&#39;, then return that integer value.
1669          * Otherwise, return 0
1670          */
1671         private static int getMetaVersion(byte[] name, int off, int len) {
1672             int nend = off + len;
1673             if (!(len &gt; 10                         // &quot;versions//&quot;.length()
1674                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1675                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;
1676                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1677                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;
1678                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1679                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1680                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;
1681                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1682                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1683                     &amp;&amp; (name[off++]       ) == &#39;/&#39;)) {
1684                 return 0;
1685             }
1686             int version = 0;
1687             while (off &lt; nend) {
1688                 final byte c = name[off++];
1689                 if (c == &#39;/&#39;) {
1690                     return version;
1691                 }
1692                 if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
1693                     return 0;
1694                 }
1695                 version = version * 10 + c - &#39;0&#39;;
1696                 // Check for overflow and leading zeros
1697                 if (version &lt;= 0) {
1698                     return 0;
1699                 }
1700             }
1701             return 0;
1702         }
1703 
1704         /**
1705          * Returns the number of CEN headers in a central directory.
1706          * Will not throw, even if the zip file is corrupt.
1707          *
1708          * @param cen copy of the bytes in a zip file&#39;s central directory
1709          * @param size number of bytes in central directory
1710          */
1711         private static int countCENHeaders(byte[] cen, int size) {
1712             int count = 0;
1713             for (int p = 0;
1714                  p + CENHDR &lt;= size;
1715                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1716                 count++;
1717             return count;
1718         }
1719     }
1720 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
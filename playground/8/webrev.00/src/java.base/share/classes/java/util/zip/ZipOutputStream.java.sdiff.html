<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
489         }
490         writeExtra(e.extra);
491         locoff = written;
492     }
493 
494     /*
495      * Writes extra data descriptor (EXT) for specified entry.
496      */
497     private void writeEXT(ZipEntry e) throws IOException {
498         writeInt(EXTSIG);           // EXT header signature
499         writeInt(e.crc);            // crc-32
500         if (e.csize &gt;= ZIP64_MAGICVAL || e.size &gt;= ZIP64_MAGICVAL) {
501             writeLong(e.csize);
502             writeLong(e.size);
503         } else {
504             writeInt(e.csize);          // compressed size
505             writeInt(e.size);           // uncompressed size
506         }
507     }
508 









509     /*
510      * Write central directory (CEN) header for specified entry.
511      * REMIND: add support for file attributes
512      */
513     private void writeCEN(XEntry xentry) throws IOException {
514         ZipEntry e  = xentry.entry;
515         int flag = e.flag;
516         int version = version(e);
517         long csize = e.csize;
518         long size = e.size;
519         long offset = xentry.offset;
520         int elenZIP64 = 0;
521         boolean hasZip64 = false;
522 
523         if (e.csize &gt;= ZIP64_MAGICVAL) {
524             csize = ZIP64_MAGICVAL;
525             elenZIP64 += 8;              // csize(8)
526             hasZip64 = true;
527         }
528         if (e.size &gt;= ZIP64_MAGICVAL) {
529             size = ZIP64_MAGICVAL;    // size(8)
530             elenZIP64 += 8;
531             hasZip64 = true;
532         }
533         if (xentry.offset &gt;= ZIP64_MAGICVAL) {
534             offset = ZIP64_MAGICVAL;
535             elenZIP64 += 8;              // offset(8)
536             hasZip64 = true;
537         }
538         writeInt(CENSIG);           // CEN header signature
539         if (hasZip64) {
<span class="line-modified">540             writeShort(45);         // ver 4.5 for zip64</span>
541             writeShort(45);
542         } else {
<span class="line-modified">543             writeShort(version);    // version made by</span>
544             writeShort(version);    // version needed to extract
545         }
546         writeShort(flag);           // general purpose bit flag
547         writeShort(e.method);       // compression method
548         writeInt(e.xdostime);       // last modification time
549         writeInt(e.crc);            // crc-32
550         writeInt(csize);            // compressed size
551         writeInt(size);             // uncompressed size
552         byte[] nameBytes = zc.getBytes(e.name);
553         writeShort(nameBytes.length);
554 
555         int elen = getExtraLen(e.extra);
556         if (hasZip64) {
557             elen += (elenZIP64 + 4);// + headid(2) + datasize(2)
558         }
559         // cen info-zip extended timestamp only outputs mtime
560         // but set the flag for a/ctime, if present in loc
561         int flagEXTT = 0;
562         long umtime = -1;
563         long uatime = -1;
</pre>
<hr />
<pre>
580                 uatime &gt; UPPER_UNIXTIME_BOUND ||
581                 uctime &gt; UPPER_UNIXTIME_BOUND) {
582                 elen += 36;         // NTFS time total 36 bytes
583             } else {
584                 elen += 5;          // headid(2) + sz(2) + flag(1)
585                 if (e.mtime != null)
586                     elen += 4;      // + mtime (4)
587             }
588         }
589         writeShort(elen);
590         byte[] commentBytes;
591         if (e.comment != null) {
592             commentBytes = zc.getBytes(e.comment);
593             writeShort(Math.min(commentBytes.length, 0xffff));
594         } else {
595             commentBytes = null;
596             writeShort(0);
597         }
598         writeShort(0);              // starting disk number
599         writeShort(0);              // internal file attributes (unused)
<span class="line-modified">600         writeInt(0);                // external file attributes (unused)</span>

601         writeInt(offset);           // relative offset of local header
602         writeBytes(nameBytes, 0, nameBytes.length);
603 
604         // take care of EXTID_ZIP64 and EXTID_EXTT
605         if (hasZip64) {
606             writeShort(ZIP64_EXTID);// Zip64 extra
607             writeShort(elenZIP64);
608             if (size == ZIP64_MAGICVAL)
609                 writeLong(e.size);
610             if (csize == ZIP64_MAGICVAL)
611                 writeLong(e.csize);
612             if (offset == ZIP64_MAGICVAL)
613                 writeLong(xentry.offset);
614         }
615         if (flagEXTT != 0) {
616             if (umtime &gt; UPPER_UNIXTIME_BOUND ||
617                 uatime &gt; UPPER_UNIXTIME_BOUND ||
618                 uctime &gt; UPPER_UNIXTIME_BOUND) {
619                 writeShort(EXTID_NTFS);    // id
620                 writeShort(32);            // data size
</pre>
</td>
<td>
<hr />
<pre>
489         }
490         writeExtra(e.extra);
491         locoff = written;
492     }
493 
494     /*
495      * Writes extra data descriptor (EXT) for specified entry.
496      */
497     private void writeEXT(ZipEntry e) throws IOException {
498         writeInt(EXTSIG);           // EXT header signature
499         writeInt(e.crc);            // crc-32
500         if (e.csize &gt;= ZIP64_MAGICVAL || e.size &gt;= ZIP64_MAGICVAL) {
501             writeLong(e.csize);
502             writeLong(e.size);
503         } else {
504             writeInt(e.csize);          // compressed size
505             writeInt(e.size);           // uncompressed size
506         }
507     }
508 
<span class="line-added">509     /**</span>
<span class="line-added">510      * Adds information about compatibility of file attribute information</span>
<span class="line-added">511      * to a version value.</span>
<span class="line-added">512      */</span>
<span class="line-added">513     private int versionMadeBy(ZipEntry e, int version) {</span>
<span class="line-added">514         return (e.posixPerms &lt; 0) ? version :</span>
<span class="line-added">515                 VERSION_MADE_BY_BASE_UNIX | (version &amp; 0xff);</span>
<span class="line-added">516     }</span>
<span class="line-added">517 </span>
518     /*
519      * Write central directory (CEN) header for specified entry.
520      * REMIND: add support for file attributes
521      */
522     private void writeCEN(XEntry xentry) throws IOException {
523         ZipEntry e  = xentry.entry;
524         int flag = e.flag;
525         int version = version(e);
526         long csize = e.csize;
527         long size = e.size;
528         long offset = xentry.offset;
529         int elenZIP64 = 0;
530         boolean hasZip64 = false;
531 
532         if (e.csize &gt;= ZIP64_MAGICVAL) {
533             csize = ZIP64_MAGICVAL;
534             elenZIP64 += 8;              // csize(8)
535             hasZip64 = true;
536         }
537         if (e.size &gt;= ZIP64_MAGICVAL) {
538             size = ZIP64_MAGICVAL;    // size(8)
539             elenZIP64 += 8;
540             hasZip64 = true;
541         }
542         if (xentry.offset &gt;= ZIP64_MAGICVAL) {
543             offset = ZIP64_MAGICVAL;
544             elenZIP64 += 8;              // offset(8)
545             hasZip64 = true;
546         }
547         writeInt(CENSIG);           // CEN header signature
548         if (hasZip64) {
<span class="line-modified">549             writeShort(versionMadeBy(e,45));         // ver 4.5 for zip64</span>
550             writeShort(45);
551         } else {
<span class="line-modified">552             writeShort(versionMadeBy(e, version));    // version made by</span>
553             writeShort(version);    // version needed to extract
554         }
555         writeShort(flag);           // general purpose bit flag
556         writeShort(e.method);       // compression method
557         writeInt(e.xdostime);       // last modification time
558         writeInt(e.crc);            // crc-32
559         writeInt(csize);            // compressed size
560         writeInt(size);             // uncompressed size
561         byte[] nameBytes = zc.getBytes(e.name);
562         writeShort(nameBytes.length);
563 
564         int elen = getExtraLen(e.extra);
565         if (hasZip64) {
566             elen += (elenZIP64 + 4);// + headid(2) + datasize(2)
567         }
568         // cen info-zip extended timestamp only outputs mtime
569         // but set the flag for a/ctime, if present in loc
570         int flagEXTT = 0;
571         long umtime = -1;
572         long uatime = -1;
</pre>
<hr />
<pre>
589                 uatime &gt; UPPER_UNIXTIME_BOUND ||
590                 uctime &gt; UPPER_UNIXTIME_BOUND) {
591                 elen += 36;         // NTFS time total 36 bytes
592             } else {
593                 elen += 5;          // headid(2) + sz(2) + flag(1)
594                 if (e.mtime != null)
595                     elen += 4;      // + mtime (4)
596             }
597         }
598         writeShort(elen);
599         byte[] commentBytes;
600         if (e.comment != null) {
601             commentBytes = zc.getBytes(e.comment);
602             writeShort(Math.min(commentBytes.length, 0xffff));
603         } else {
604             commentBytes = null;
605             writeShort(0);
606         }
607         writeShort(0);              // starting disk number
608         writeShort(0);              // internal file attributes (unused)
<span class="line-modified">609         // external file attributes, used for storing posix permissions</span>
<span class="line-added">610         writeInt(e.posixPerms &gt; 0 ? e.posixPerms &lt;&lt; 16 : 0);</span>
611         writeInt(offset);           // relative offset of local header
612         writeBytes(nameBytes, 0, nameBytes.length);
613 
614         // take care of EXTID_ZIP64 and EXTID_EXTT
615         if (hasZip64) {
616             writeShort(ZIP64_EXTID);// Zip64 extra
617             writeShort(elenZIP64);
618             if (size == ZIP64_MAGICVAL)
619                 writeLong(e.size);
620             if (csize == ZIP64_MAGICVAL)
621                 writeLong(e.csize);
622             if (offset == ZIP64_MAGICVAL)
623                 writeLong(xentry.offset);
624         }
625         if (flagEXTT != 0) {
626             if (umtime &gt; UPPER_UNIXTIME_BOUND ||
627                 uatime &gt; UPPER_UNIXTIME_BOUND ||
628                 uctime &gt; UPPER_UNIXTIME_BOUND) {
629                 writeShort(EXTID_NTFS);    // id
630                 writeShort(32);            // data size
</pre>
</td>
</tr>
</table>
<center><a href="ZipFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
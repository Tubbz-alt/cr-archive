<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaUtilZipFileAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
198     static final int CH(byte[] b, int n) {
199         return b[n] &amp; 0xff ;
200     }
201 
202     static final int SH(byte[] b, int n) {
203         return (b[n] &amp; 0xff) | ((b[n + 1] &amp; 0xff) &lt;&lt; 8);
204     }
205 
206     static final long LG(byte[] b, int n) {
207         return ((SH(b, n)) | (SH(b, n + 2) &lt;&lt; 16)) &amp; 0xffffffffL;
208     }
209 
210     static final long LL(byte[] b, int n) {
211         return (LG(b, n)) | (LG(b, n + 4) &lt;&lt; 32);
212     }
213 
214     static final long GETSIG(byte[] b) {
215         return LG(b, 0);
216     }
217 











218     // local file (LOC) header fields
219     static final long LOCSIG(byte[] b) { return LG(b, 0); } // signature
220     static final int  LOCVER(byte[] b) { return SH(b, 4); } // version needed to extract
221     static final int  LOCFLG(byte[] b) { return SH(b, 6); } // general purpose bit flags
222     static final int  LOCHOW(byte[] b) { return SH(b, 8); } // compression method
223     static final long LOCTIM(byte[] b) { return LG(b, 10);} // modification time
224     static final long LOCCRC(byte[] b) { return LG(b, 14);} // crc of uncompressed data
225     static final long LOCSIZ(byte[] b) { return LG(b, 18);} // compressed data size
226     static final long LOCLEN(byte[] b) { return LG(b, 22);} // uncompressed data size
227     static final int  LOCNAM(byte[] b) { return SH(b, 26);} // filename length
228     static final int  LOCEXT(byte[] b) { return SH(b, 28);} // extra field length
229 
230     // extra local (EXT) header fields
231     static final long EXTCRC(byte[] b) { return LG(b, 4);}  // crc of uncompressed data
232     static final long EXTSIZ(byte[] b) { return LG(b, 8);}  // compressed size
233     static final long EXTLEN(byte[] b) { return LG(b, 12);} // uncompressed size
234 
235     // end of central directory header (END) fields
236     static final int  ENDSUB(byte[] b) { return SH(b, 8); }  // number of entries on this disk
237     static final int  ENDTOT(byte[] b) { return SH(b, 10);}  // total number of entries
238     static final long ENDSIZ(byte[] b) { return LG(b, 12);}  // central directory size
239     static final long ENDOFF(byte[] b) { return LG(b, 16);}  // central directory offset
240     static final int  ENDCOM(byte[] b) { return SH(b, 20);}  // size of zip file comment
241     static final int  ENDCOM(byte[] b, int off) { return SH(b, off + 20);}
242 
243     // zip64 end of central directory recoder fields
244     static final long ZIP64_ENDTOD(byte[] b) { return LL(b, 24);}  // total number of entries on disk
245     static final long ZIP64_ENDTOT(byte[] b) { return LL(b, 32);}  // total number of entries
246     static final long ZIP64_ENDSIZ(byte[] b) { return LL(b, 40);}  // central directory size
247     static final long ZIP64_ENDOFF(byte[] b) { return LL(b, 48);}  // central directory offset
248     static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   // zip64 end offset
249 
250     // central directory header (CEN) fields
251     static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }
252     static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }

253     static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }
254     static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }
255     static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}
256     static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}
257     static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}
258     static final long CENSIZ(byte[] b, int pos) { return LG(b, pos + 20);}
259     static final long CENLEN(byte[] b, int pos) { return LG(b, pos + 24);}
260     static final int  CENNAM(byte[] b, int pos) { return SH(b, pos + 28);}
261     static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}
262     static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}
263     static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}
264     static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}
265     static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}

266     static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}
267 
268     // The END header is followed by a variable length comment of size &lt; 64k.
269     static final long END_MAXLEN = 0xFFFF + ENDHDR;
270     static final int READBLOCKSZ = 128;
271 
272     /**
273      * Loads zip native library, if not already laoded
274      */
275     static void loadLibrary() {
276         jdk.internal.loader.BootLoader.loadLibrary(&quot;zip&quot;);
277     }
278 
279     private static final Unsafe unsafe = Unsafe.getUnsafe();
280 
281     private static final long byteBufferArrayOffset = unsafe.objectFieldOffset(ByteBuffer.class, &quot;hb&quot;);
282     private static final long byteBufferOffsetOffset = unsafe.objectFieldOffset(ByteBuffer.class, &quot;offset&quot;);
283 
284     static byte[] getBufferArray(ByteBuffer byteBuffer) {
285         return (byte[]) unsafe.getReference(byteBuffer, byteBufferArrayOffset);
</pre>
</td>
<td>
<hr />
<pre>
198     static final int CH(byte[] b, int n) {
199         return b[n] &amp; 0xff ;
200     }
201 
202     static final int SH(byte[] b, int n) {
203         return (b[n] &amp; 0xff) | ((b[n + 1] &amp; 0xff) &lt;&lt; 8);
204     }
205 
206     static final long LG(byte[] b, int n) {
207         return ((SH(b, n)) | (SH(b, n + 2) &lt;&lt; 16)) &amp; 0xffffffffL;
208     }
209 
210     static final long LL(byte[] b, int n) {
211         return (LG(b, n)) | (LG(b, n + 4) &lt;&lt; 32);
212     }
213 
214     static final long GETSIG(byte[] b) {
215         return LG(b, 0);
216     }
217 
<span class="line-added">218     /*</span>
<span class="line-added">219      * File attribute compatibility types of CEN field &quot;version made by&quot;</span>
<span class="line-added">220      */</span>
<span class="line-added">221     static final int FILE_ATTRIBUTES_UNIX = 3; // Unix</span>
<span class="line-added">222 </span>
<span class="line-added">223     /*</span>
<span class="line-added">224      * Base values for CEN field &quot;version made by&quot;</span>
<span class="line-added">225      */</span>
<span class="line-added">226     static final int VERSION_MADE_BY_BASE_UNIX = FILE_ATTRIBUTES_UNIX &lt;&lt; 8; // Unix</span>
<span class="line-added">227 </span>
<span class="line-added">228 </span>
229     // local file (LOC) header fields
230     static final long LOCSIG(byte[] b) { return LG(b, 0); } // signature
231     static final int  LOCVER(byte[] b) { return SH(b, 4); } // version needed to extract
232     static final int  LOCFLG(byte[] b) { return SH(b, 6); } // general purpose bit flags
233     static final int  LOCHOW(byte[] b) { return SH(b, 8); } // compression method
234     static final long LOCTIM(byte[] b) { return LG(b, 10);} // modification time
235     static final long LOCCRC(byte[] b) { return LG(b, 14);} // crc of uncompressed data
236     static final long LOCSIZ(byte[] b) { return LG(b, 18);} // compressed data size
237     static final long LOCLEN(byte[] b) { return LG(b, 22);} // uncompressed data size
238     static final int  LOCNAM(byte[] b) { return SH(b, 26);} // filename length
239     static final int  LOCEXT(byte[] b) { return SH(b, 28);} // extra field length
240 
241     // extra local (EXT) header fields
242     static final long EXTCRC(byte[] b) { return LG(b, 4);}  // crc of uncompressed data
243     static final long EXTSIZ(byte[] b) { return LG(b, 8);}  // compressed size
244     static final long EXTLEN(byte[] b) { return LG(b, 12);} // uncompressed size
245 
246     // end of central directory header (END) fields
247     static final int  ENDSUB(byte[] b) { return SH(b, 8); }  // number of entries on this disk
248     static final int  ENDTOT(byte[] b) { return SH(b, 10);}  // total number of entries
249     static final long ENDSIZ(byte[] b) { return LG(b, 12);}  // central directory size
250     static final long ENDOFF(byte[] b) { return LG(b, 16);}  // central directory offset
251     static final int  ENDCOM(byte[] b) { return SH(b, 20);}  // size of zip file comment
252     static final int  ENDCOM(byte[] b, int off) { return SH(b, off + 20);}
253 
254     // zip64 end of central directory recoder fields
255     static final long ZIP64_ENDTOD(byte[] b) { return LL(b, 24);}  // total number of entries on disk
256     static final long ZIP64_ENDTOT(byte[] b) { return LL(b, 32);}  // total number of entries
257     static final long ZIP64_ENDSIZ(byte[] b) { return LL(b, 40);}  // central directory size
258     static final long ZIP64_ENDOFF(byte[] b) { return LL(b, 48);}  // central directory offset
259     static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   // zip64 end offset
260 
261     // central directory header (CEN) fields
262     static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }
263     static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }
<span class="line-added">264     static final int  CENVEM_FA(byte[] b, int pos) { return CH(b, pos + 5); } // file attribute compatibility</span>
265     static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }
266     static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }
267     static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}
268     static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}
269     static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}
270     static final long CENSIZ(byte[] b, int pos) { return LG(b, pos + 20);}
271     static final long CENLEN(byte[] b, int pos) { return LG(b, pos + 24);}
272     static final int  CENNAM(byte[] b, int pos) { return SH(b, pos + 28);}
273     static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}
274     static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}
275     static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}
276     static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}
277     static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}
<span class="line-added">278     static final int  CENATX_PERMS(byte[] b, int pos) { return SH(b, pos + 40);} // posix permission data</span>
279     static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}
280 
281     // The END header is followed by a variable length comment of size &lt; 64k.
282     static final long END_MAXLEN = 0xFFFF + ENDHDR;
283     static final int READBLOCKSZ = 128;
284 
285     /**
286      * Loads zip native library, if not already laoded
287      */
288     static void loadLibrary() {
289         jdk.internal.loader.BootLoader.loadLibrary(&quot;zip&quot;);
290     }
291 
292     private static final Unsafe unsafe = Unsafe.getUnsafe();
293 
294     private static final long byteBufferArrayOffset = unsafe.objectFieldOffset(ByteBuffer.class, &quot;hb&quot;);
295     private static final long byteBufferOffsetOffset = unsafe.objectFieldOffset(ByteBuffer.class, &quot;offset&quot;);
296 
297     static byte[] getBufferArray(ByteBuffer byteBuffer) {
298         return (byte[]) unsafe.getReference(byteBuffer, byteBufferArrayOffset);
</pre>
</td>
</tr>
</table>
<center><a href="ZipOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaUtilZipFileAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
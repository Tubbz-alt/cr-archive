diff a/src/java.base/share/classes/sun/security/util/DerInputBuffer.java b/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
--- a/src/java.base/share/classes/sun/security/util/DerInputBuffer.java
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
- * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.util;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.math.BigInteger;
-import java.util.Date;
-import sun.util.calendar.CalendarDate;
-import sun.util.calendar.CalendarSystem;
-
-/**
- * DER input buffer ... this is the main abstraction in the DER library
- * which actively works with the "untyped byte stream" abstraction.  It
- * does so with impunity, since it's not intended to be exposed to
- * anyone who could violate the "typed value stream" DER model and hence
- * corrupt the input stream of DER values.
- *
- * @author David Brownell
- */
-class DerInputBuffer extends ByteArrayInputStream implements Cloneable {
-
-    boolean allowBER = true;
-
-    // used by sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
-    DerInputBuffer(byte[] buf) {
-        this(buf, true);
-    }
-
-    DerInputBuffer(byte[] buf, boolean allowBER) {
-        super(buf);
-        this.allowBER = allowBER;
-    }
-
-    DerInputBuffer(byte[] buf, int offset, int len, boolean allowBER) {
-        super(buf, offset, len);
-        this.allowBER = allowBER;
-    }
-
-    DerInputBuffer dup() {
-        try {
-            DerInputBuffer retval = (DerInputBuffer)clone();
-            retval.mark(Integer.MAX_VALUE);
-            return retval;
-        } catch (CloneNotSupportedException e) {
-            throw new IllegalArgumentException(e.toString());
-        }
-    }
-
-    byte[] toByteArray() {
-        int     len = available();
-        if (len <= 0)
-            return null;
-        byte[]  retval = new byte[len];
-
-        System.arraycopy(buf, pos, retval, 0, len);
-        return retval;
-    }
-
-    int peek() throws IOException {
-        if (pos >= count)
-            throw new IOException("out of data");
-        else
-            return buf[pos];
-    }
-
-    /**
-     * Compares this DerInputBuffer for equality with the specified
-     * object.
-     */
-    public boolean equals(Object other) {
-        if (other instanceof DerInputBuffer)
-            return equals((DerInputBuffer)other);
-        else
-            return false;
-    }
-
-    boolean equals(DerInputBuffer other) {
-        if (this == other)
-            return true;
-
-        int max = this.available();
-        if (other.available() != max)
-            return false;
-        for (int i = 0; i < max; i++) {
-            if (this.buf[this.pos + i] != other.buf[other.pos + i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns a hashcode for this DerInputBuffer.
-     *
-     * @return a hashcode for this DerInputBuffer.
-     */
-    public int hashCode() {
-        int retval = 0;
-
-        int len = available();
-        int p = pos;
-
-        for (int i = 0; i < len; i++)
-            retval += buf[p + i] * i;
-        return retval;
-    }
-
-    void truncate(int len) throws IOException {
-        if (len > available())
-            throw new IOException("insufficient data");
-        count = pos + len;
-    }
-
-    /**
-     * Returns the integer which takes up the specified number
-     * of bytes in this buffer as a BigInteger.
-     * @param len the number of bytes to use.
-     * @param makePositive whether to always return a positive value,
-     *   irrespective of actual encoding
-     * @return the integer as a BigInteger.
-     */
-    BigInteger getBigInteger(int len, boolean makePositive) throws IOException {
-        if (len > available())
-            throw new IOException("short read of integer");
-
-        if (len == 0) {
-            throw new IOException("Invalid encoding: zero length Int value");
-        }
-
-        byte[] bytes = new byte[len];
-
-        System.arraycopy(buf, pos, bytes, 0, len);
-        skip(len);
-
-        // BER allows leading 0s but DER does not
-        if (!allowBER && (len >= 2 && (bytes[0] == 0) && (bytes[1] >= 0))) {
-            throw new IOException("Invalid encoding: redundant leading 0s");
-        }
-
-        if (makePositive) {
-            return new BigInteger(1, bytes);
-        } else {
-            return new BigInteger(bytes);
-        }
-    }
-
-    /**
-     * Returns the integer which takes up the specified number
-     * of bytes in this buffer.
-     * @throws IOException if the result is not within the valid
-     * range for integer, i.e. between Integer.MIN_VALUE and
-     * Integer.MAX_VALUE.
-     * @param len the number of bytes to use.
-     * @return the integer.
-     */
-    public int getInteger(int len) throws IOException {
-
-        BigInteger result = getBigInteger(len, false);
-        if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0) {
-            throw new IOException("Integer below minimum valid value");
-        }
-        if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {
-            throw new IOException("Integer exceeds maximum valid value");
-        }
-        return result.intValue();
-    }
-
-    /**
-     * Returns the bit string which takes up the specified
-     * number of bytes in this buffer.
-     */
-    public byte[] getBitString(int len) throws IOException {
-        if (len > available())
-            throw new IOException("short read of bit string");
-
-        if (len == 0) {
-            throw new IOException("Invalid encoding: zero length bit string");
-        }
-
-        int numOfPadBits = buf[pos];
-        if ((numOfPadBits < 0) || (numOfPadBits > 7)) {
-            throw new IOException("Invalid number of padding bits");
-        }
-        // minus the first byte which indicates the number of padding bits
-        byte[] retval = new byte[len - 1];
-        System.arraycopy(buf, pos + 1, retval, 0, len - 1);
-        if (numOfPadBits != 0) {
-            // get rid of the padding bits
-            retval[len - 2] &= (0xff << numOfPadBits);
-        }
-        skip(len);
-        return retval;
-    }
-
-    /**
-     * Returns the bit string which takes up the rest of this buffer.
-     */
-    byte[] getBitString() throws IOException {
-        return getBitString(available());
-    }
-
-    /**
-     * Returns the bit string which takes up the rest of this buffer.
-     * The bit string need not be byte-aligned.
-     */
-    BitArray getUnalignedBitString() throws IOException {
-        if (pos >= count)
-            return null;
-        /*
-         * Just copy the data into an aligned, padded octet buffer,
-         * and consume the rest of the buffer.
-         */
-        int len = available();
-        int unusedBits = buf[pos] & 0xff;
-        if (unusedBits > 7 ) {
-            throw new IOException("Invalid value for unused bits: " + unusedBits);
-        }
-        byte[] bits = new byte[len - 1];
-        // number of valid bits
-        int length = (bits.length == 0) ? 0 : bits.length * 8 - unusedBits;
-
-        System.arraycopy(buf, pos + 1, bits, 0, len - 1);
-
-        BitArray bitArray = new BitArray(length, bits);
-        pos = count;
-        return bitArray;
-    }
-
-    /**
-     * Returns the UTC Time value that takes up the specified number
-     * of bytes in this buffer.
-     * @param len the number of bytes to use
-     */
-    public Date getUTCTime(int len) throws IOException {
-        if (len > available())
-            throw new IOException("short read of DER UTC Time");
-
-        if (len < 11 || len > 17)
-            throw new IOException("DER UTC Time length error");
-
-        return getTime(len, false);
-    }
-
-    /**
-     * Returns the Generalized Time value that takes up the specified
-     * number of bytes in this buffer.
-     * @param len the number of bytes to use
-     */
-    public Date getGeneralizedTime(int len) throws IOException {
-        if (len > available())
-            throw new IOException("short read of DER Generalized Time");
-
-        if (len < 13)
-            throw new IOException("DER Generalized Time length error");
-
-        return getTime(len, true);
-
-    }
-
-    /**
-     * Private helper routine to extract time from the der value.
-     * @param len the number of bytes to use
-     * @param generalized true if Generalized Time is to be read, false
-     * if UTC Time is to be read.
-     */
-    private Date getTime(int len, boolean generalized) throws IOException {
-
-        /*
-         * UTC time encoded as ASCII chars:
-         *       YYMMDDhhmmZ
-         *       YYMMDDhhmmssZ
-         *       YYMMDDhhmm+hhmm
-         *       YYMMDDhhmm-hhmm
-         *       YYMMDDhhmmss+hhmm
-         *       YYMMDDhhmmss-hhmm
-         * UTC Time is broken in storing only two digits of year.
-         * If YY < 50, we assume 20YY;
-         * if YY >= 50, we assume 19YY, as per RFC 5280.
-         *
-         * Generalized time has a four-digit year and allows any
-         * precision specified in ISO 8601. However, for our purposes,
-         * we will only allow the same format as UTC time, except that
-         * fractional seconds (millisecond precision) are supported.
-         */
-
-        int year, month, day, hour, minute, second, millis;
-        String type = null;
-
-        if (generalized) {
-            type = "Generalized";
-            year = 1000 * Character.digit((char)buf[pos++], 10);
-            year += 100 * Character.digit((char)buf[pos++], 10);
-            year += 10 * Character.digit((char)buf[pos++], 10);
-            year += Character.digit((char)buf[pos++], 10);
-            len -= 2; // For the two extra YY
-        } else {
-            type = "UTC";
-            year = 10 * Character.digit((char)buf[pos++], 10);
-            year += Character.digit((char)buf[pos++], 10);
-
-            if (year < 50)              // origin 2000
-                year += 2000;
-            else
-                year += 1900;   // origin 1900
-        }
-
-        month = 10 * Character.digit((char)buf[pos++], 10);
-        month += Character.digit((char)buf[pos++], 10);
-
-        day = 10 * Character.digit((char)buf[pos++], 10);
-        day += Character.digit((char)buf[pos++], 10);
-
-        hour = 10 * Character.digit((char)buf[pos++], 10);
-        hour += Character.digit((char)buf[pos++], 10);
-
-        minute = 10 * Character.digit((char)buf[pos++], 10);
-        minute += Character.digit((char)buf[pos++], 10);
-
-        len -= 10; // YYMMDDhhmm
-
-        /*
-         * We allow for non-encoded seconds, even though the
-         * IETF-PKIX specification says that the seconds should
-         * always be encoded even if it is zero.
-         */
-
-        millis = 0;
-        if (len > 2) {
-            second = 10 * Character.digit((char)buf[pos++], 10);
-            second += Character.digit((char)buf[pos++], 10);
-            len -= 2;
-            // handle fractional seconds (if present)
-            if (buf[pos] == '.' || buf[pos] == ',') {
-                len --;
-                pos++;
-                int precision = 0;
-                while (buf[pos] != 'Z' &&
-                       buf[pos] != '+' &&
-                       buf[pos] != '-') {
-                    // Validate all digits in the fractional part but
-                    // store millisecond precision only
-                    int thisDigit = Character.digit((char)buf[pos], 10);
-                    precision++;
-                    pos++;
-                    switch (precision) {
-                        case 1:
-                            millis += 100 * thisDigit;
-                            break;
-                        case 2:
-                            millis += 10 * thisDigit;
-                            break;
-                        case 3:
-                            millis += thisDigit;
-                            break;
-                    }
-                }
-                if (precision == 0) {
-                    throw new IOException("Parse " + type +
-                            " time, empty fractional part");
-                }
-                len -= precision;
-            }
-        } else
-            second = 0;
-
-        if (month == 0 || day == 0
-            || month > 12 || day > 31
-            || hour >= 24 || minute >= 60 || second >= 60)
-            throw new IOException("Parse " + type + " time, invalid format");
-
-        /*
-         * Generalized time can theoretically allow any precision,
-         * but we're not supporting that.
-         */
-        CalendarSystem gcal = CalendarSystem.getGregorianCalendar();
-        CalendarDate date = gcal.newCalendarDate(null); // no time zone
-        date.setDate(year, month, day);
-        date.setTimeOfDay(hour, minute, second, millis);
-        long time = gcal.getTime(date);
-
-        /*
-         * Finally, "Z" or "+hhmm" or "-hhmm" ... offsets change hhmm
-         */
-        if (! (len == 1 || len == 5))
-            throw new IOException("Parse " + type + " time, invalid offset");
-
-        int hr, min;
-
-        switch (buf[pos++]) {
-        case '+':
-            hr = 10 * Character.digit((char)buf[pos++], 10);
-            hr += Character.digit((char)buf[pos++], 10);
-            min = 10 * Character.digit((char)buf[pos++], 10);
-            min += Character.digit((char)buf[pos++], 10);
-
-            if (hr >= 24 || min >= 60)
-                throw new IOException("Parse " + type + " time, +hhmm");
-
-            time -= ((hr * 60) + min) * 60 * 1000;
-            break;
-
-        case '-':
-            hr = 10 * Character.digit((char)buf[pos++], 10);
-            hr += Character.digit((char)buf[pos++], 10);
-            min = 10 * Character.digit((char)buf[pos++], 10);
-            min += Character.digit((char)buf[pos++], 10);
-
-            if (hr >= 24 || min >= 60)
-                throw new IOException("Parse " + type + " time, -hhmm");
-
-            time += ((hr * 60) + min) * 60 * 1000;
-            break;
-
-        case 'Z':
-            break;
-
-        default:
-            throw new IOException("Parse " + type + " time, garbage offset");
-        }
-        return new Date(time);
-    }
-}
diff a/src/java.base/share/classes/sun/security/util/DerInputStream.java b/src/java.base/share/classes/sun/security/util/DerInputStream.java
--- a/src/java.base/share/classes/sun/security/util/DerInputStream.java
+++ b/src/java.base/share/classes/sun/security/util/DerInputStream.java
@@ -25,13 +25,16 @@
 
 package sun.security.util;
 
 import java.io.InputStream;
 import java.io.IOException;
+import java.io.UncheckedIOException;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
+import java.util.Arrays;
 import java.util.Date;
+import java.util.Iterator;
 import java.util.Vector;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
@@ -55,522 +58,157 @@
  * @author David Brownell
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
 
-public class DerInputStream {
+public class DerInputStream implements Iterable<DerValue> {
 
-    /*
-     * This version only supports fully buffered DER.  This is easy to
-     * work with, though if large objects are manipulated DER becomes
-     * awkward to deal with.  That's where BER is useful, since BER
-     * handles streaming data relatively well.
-     */
-    DerInputBuffer      buffer;
+    final byte[] data;
+    final int start;
+    final int end;
+    final boolean allowBER;
+    int pos;
 
-    /** The DER tag of the value; one of the tag_ constants. */
-    public byte         tag;
+    @Override
+    public Iterator<DerValue> iterator() {
+        return new Iterator<DerValue>() {
+            @Override
+            public boolean hasNext() {
+                return pos < end;
+            }
 
-    /**
-     * Create a DER input stream from a data buffer.  The buffer is not
-     * copied, it is shared.  Accordingly, the buffer should be treated
-     * as read-only.
-     *
-     * @param data the buffer from which to create the string (CONSUMED)
-     */
-    public DerInputStream(byte[] data) throws IOException {
-        init(data, 0, data.length, true);
+            @Override
+            public DerValue next() {
+                try {
+                    DerValue n = new DerValue(data, pos, end, allowBER, false);
+                    pos = n.end;
+                    return n;
+                } catch (IOException ioe) {
+                    throw new UncheckedIOException(ioe);
+                }
+            }
+        };
     }
 
-    /**
-     * Create a DER input stream from part of a data buffer with
-     * additional arg to control whether DER checks are enforced.
-     * The buffer is not copied, it is shared.  Accordingly, the
-     * buffer should be treated as read-only.
-     *
-     * @param data the buffer from which to create the string (CONSUMED)
-     * @param offset the first index of <em>data</em> which will
-     *          be read as DER input in the new stream
-     * @param len how long a chunk of the buffer to use,
-     *          starting at "offset"
-     * @param allowBER whether to allow constructed indefinite-length
-     *          encoding as well as tolerate leading 0s
-     */
-    public DerInputStream(byte[] data, int offset, int len,
-        boolean allowBER) throws IOException {
-        init(data, offset, len, allowBER);
+    public DerInputStream(byte[] data, int start, int length, boolean allowBER) {
+        this.data = data;
+        this.start = start;
+        this.end = start + length;
+        this.allowBER = allowBER;
+        this.pos = start;
     }
 
-    /**
-     * Create a DER input stream from part of a data buffer.
-     * The buffer is not copied, it is shared.  Accordingly, the
-     * buffer should be treated as read-only.
-     *
-     * @param data the buffer from which to create the string (CONSUMED)
-     * @param offset the first index of <em>data</em> which will
-     *          be read as DER input in the new stream
-     * @param len how long a chunk of the buffer to use,
-     *          starting at "offset"
-     */
-    public DerInputStream(byte[] data, int offset, int len) throws IOException {
-        init(data, offset, len, true);
+    public DerInputStream(DerValue v) {
+        this(v.buffer, v.start, v.end - v.start, v.allowBER);
     }
 
-    /*
-     * private helper routine
-     */
-    private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {
-        if ((offset+2 > data.length) || (offset+len > data.length)) {
-            throw new IOException("Encoding bytes too short");
-        }
-        // check for indefinite length encoding
-        if (DerIndefLenConverter.isIndefinite(data[offset+1])) {
-            if (!allowBER) {
-                throw new IOException("Indefinite length BER encoding found");
-            } else {
-                byte[] inData = new byte[len];
-                System.arraycopy(data, offset, inData, 0, len);
-
-                DerIndefLenConverter derIn = new DerIndefLenConverter();
-                byte[] result = derIn.convertBytes(inData);
-                if (result == null) {
-                    throw new IOException("not all indef len BER resolved");
-                } else {
-                    buffer = new DerInputBuffer(result, allowBER);
-                }
-            }
-        } else {
-            buffer = new DerInputBuffer(data, offset, len, allowBER);
-        }
-        buffer.mark(Integer.MAX_VALUE);
-    }
-
-    DerInputStream(DerInputBuffer buf) {
-        buffer = buf;
-        buffer.mark(Integer.MAX_VALUE);
+    public DerInputStream(byte[] data) throws IOException {
+        this(data, 0, data.length, true);
     }
 
-    /**
-     * Creates a new DER input stream from part of this input stream.
-     *
-     * @param len how long a chunk of the current input stream to use,
-     *          starting at the current position.
-     * @param do_skip true if the existing data in the input stream should
-     *          be skipped.  If this value is false, the next data read
-     *          on this stream and the newly created stream will be the
-     *          same.
-     */
-    public DerInputStream subStream(int len, boolean do_skip)
-    throws IOException {
-        DerInputBuffer newbuf = buffer.dup();
-
-        newbuf.truncate(len);
-        if (do_skip) {
-            buffer.skip(len);
-        }
-        return new DerInputStream(newbuf);
+    public DerInputStream(byte[] data, int offset, int len) throws IOException {
+        this(data, offset, len, true);
     }
 
-    /**
-     * Return what has been written to this DerInputStream
-     * as a byte array. Useful for debugging.
-     */
     public byte[] toByteArray() {
-        return buffer.toByteArray();
+        return Arrays.copyOfRange(data, start, end);
     }
 
-    /*
-     * PRIMITIVES -- these are "universal" ASN.1 simple types.
-     *
-     *  INTEGER, ENUMERATED, BIT STRING, OCTET STRING, NULL
-     *  OBJECT IDENTIFIER, SEQUENCE (OF), SET (OF)
-     *  UTF8String, PrintableString, T61String, IA5String, UTCTime,
-     *  GeneralizedTime, BMPString.
-     * Note: UniversalString not supported till encoder is available.
-     */
-
-    /**
-     * Get an integer from the input stream as an integer.
-     *
-     * @return the integer held in this DER input stream.
-     */
     public int getInteger() throws IOException {
-        if (buffer.read() != DerValue.tag_Integer) {
-            throw new IOException("DER input, Integer tag error");
-        }
-        return buffer.getInteger(getDefiniteLength(buffer));
+        return getDerValue().getInteger();
     }
 
-    /**
-     * Get a integer from the input stream as a BigInteger object.
-     *
-     * @return the integer held in this DER input stream.
-     */
     public BigInteger getBigInteger() throws IOException {
-        if (buffer.read() != DerValue.tag_Integer) {
-            throw new IOException("DER input, Integer tag error");
-        }
-        return buffer.getBigInteger(getDefiniteLength(buffer), false);
+        return getDerValue().getBigInteger();
     }
 
-    /**
-     * Returns an ASN.1 INTEGER value as a positive BigInteger.
-     * This is just to deal with implementations that incorrectly encode
-     * some values as negative.
-     *
-     * @return the integer held in this DER value as a BigInteger.
-     */
     public BigInteger getPositiveBigInteger() throws IOException {
-        if (buffer.read() != DerValue.tag_Integer) {
-            throw new IOException("DER input, Integer tag error");
-        }
-        return buffer.getBigInteger(getDefiniteLength(buffer), true);
+        return getDerValue().getPositiveBigInteger();
     }
 
-    /**
-     * Get an enumerated from the input stream.
-     *
-     * @return the integer held in this DER input stream.
-     */
     public int getEnumerated() throws IOException {
-        if (buffer.read() != DerValue.tag_Enumerated) {
-            throw new IOException("DER input, Enumerated tag error");
-        }
-        return buffer.getInteger(getDefiniteLength(buffer));
+        return getDerValue().getEnumerated();
     }
 
-    /**
-     * Get a bit string from the input stream. Padded bits (if any)
-     * will be stripped off before the bit string is returned.
-     */
     public byte[] getBitString() throws IOException {
-        if (buffer.read() != DerValue.tag_BitString)
-            throw new IOException("DER input not an bit string");
-
-        return buffer.getBitString(getDefiniteLength(buffer));
+        return getDerValue().getBitString();
     }
 
-    /**
-     * Get a bit string from the input stream.  The bit string need
-     * not be byte-aligned.
-     */
     public BitArray getUnalignedBitString() throws IOException {
-        if (buffer.read() != DerValue.tag_BitString) {
-            throw new IOException("DER input not a bit string");
-        }
-
-        int length = getDefiniteLength(buffer);
-
-        if (length == 0) {
-            return new BitArray(0);
-        }
-
-        /*
-         * First byte = number of excess bits in the last octet of the
-         * representation.
-         */
-        length--;
-        int excessBits = buffer.read();
-        if (excessBits < 0) {
-            throw new IOException("Unused bits of bit string invalid");
-        }
-        int validBits = length*8 - excessBits;
-        if (validBits < 0) {
-            throw new IOException("Valid bits of bit string invalid");
-        }
-
-        byte[] repn = new byte[length];
-
-        if ((length != 0) && (buffer.read(repn) != length)) {
-            throw new IOException("Short read of DER bit string");
-        }
-
-        return new BitArray(validBits, repn);
+        return getDerValue().getUnalignedBitString();
     }
 
-    /**
-     * Returns an ASN.1 OCTET STRING from the input stream.
-     */
     public byte[] getOctetString() throws IOException {
-        if (buffer.read() != DerValue.tag_OctetString)
-            throw new IOException("DER input not an octet string");
-
-        int length = getDefiniteLength(buffer);
-        byte[] retval = new byte[length];
-        if ((length != 0) && (buffer.read(retval) != length))
-            throw new IOException("Short read of DER octet string");
-
-        return retval;
-    }
-
-    /**
-     * Returns the asked number of bytes from the input stream.
-     */
-    public void getBytes(byte[] val) throws IOException {
-        if ((val.length != 0) && (buffer.read(val) != val.length)) {
-            throw new IOException("Short read of DER octet string");
-        }
+        return getDerValue().getOctetString();
     }
 
-    /**
-     * Reads an encoded null value from the input stream.
-     */
     public void getNull() throws IOException {
-        if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)
-            throw new IOException("getNull, bad data");
+        getDerValue().getNull();
     }
 
-    /**
-     * Reads an X.200 style Object Identifier from the stream.
-     */
     public ObjectIdentifier getOID() throws IOException {
-        return new ObjectIdentifier(this);
+        return getDerValue().getOID();
     }
 
-    /**
-     * Return a sequence of encoded entities.  ASN.1 sequences are
-     * ordered, and they are often used, like a "struct" in C or C++,
-     * to group data values.  They may have optional or context
-     * specific values.
-     *
-     * @param startLen guess about how long the sequence will be
-     *          (used to initialize an auto-growing data structure)
-     * @return array of the values in the sequence
-     */
     public DerValue[] getSequence(int startLen) throws IOException {
-        tag = (byte)buffer.read();
-        if (tag != DerValue.tag_Sequence)
-            throw new IOException("Sequence tag error");
-        return readVector(startLen);
+        return getDerValue().subs(DerValue.tag_Sequence);
     }
 
-    /**
-     * Return a set of encoded entities.  ASN.1 sets are unordered,
-     * though DER may specify an order for some kinds of sets (such
-     * as the attributes in an X.500 relative distinguished name)
-     * to facilitate binary comparisons of encoded values.
-     *
-     * @param startLen guess about how large the set will be
-     *          (used to initialize an auto-growing data structure)
-     * @return array of the values in the sequence
-     */
     public DerValue[] getSet(int startLen) throws IOException {
-        tag = (byte)buffer.read();
-        if (tag != DerValue.tag_Set)
-            throw new IOException("Set tag error");
-        return readVector(startLen);
+        return getDerValue().subs(DerValue.tag_Set);
     }
 
-    /**
-     * Return a set of encoded entities.  ASN.1 sets are unordered,
-     * though DER may specify an order for some kinds of sets (such
-     * as the attributes in an X.500 relative distinguished name)
-     * to facilitate binary comparisons of encoded values.
-     *
-     * @param startLen guess about how large the set will be
-     *          (used to initialize an auto-growing data structure)
-     * @param implicit if true tag is assumed implicit.
-     * @return array of the values in the sequence
-     */
-    public DerValue[] getSet(int startLen, boolean implicit)
-        throws IOException {
-        tag = (byte)buffer.read();
-        if (!implicit) {
-            if (tag != DerValue.tag_Set) {
-                throw new IOException("Set tag error");
-            }
-        }
-        return (readVector(startLen));
+    public DerValue[] getSet(int startLen, boolean implicit) throws IOException {
+        return getDerValue().subs((byte)0);
     }
 
-    /*
-     * Read a "vector" of values ... set or sequence have the
-     * same encoding, except for the initial tag, so both use
-     * this same helper routine.
-     */
-    protected DerValue[] readVector(int startLen) throws IOException {
-        DerInputStream  newstr;
-
-        byte lenByte = (byte)buffer.read();
-        int len = getLength(lenByte, buffer);
-
-        if (len == -1) {
-           // indefinite length encoding found
-           buffer = new DerInputBuffer(
-                   DerIndefLenConverter.convertStream(buffer, lenByte, tag),
-                   buffer.allowBER);
-
-           if (tag != buffer.read())
-                throw new IOException("Indefinite length encoding" +
-                        " not supported");
-           len = DerInputStream.getDefiniteLength(buffer);
-        }
-
-        if (len == 0)
-            // return empty array instead of null, which should be
-            // used only for missing optionals
-            return new DerValue[0];
-
-        /*
-         * Create a temporary stream from which to read the data,
-         * unless it's not really needed.
-         */
-        if (buffer.available() == len)
-            newstr = this;
-        else
-            newstr = subStream(len, true);
-
-        /*
-         * Pull values out of the stream.
-         */
-        Vector<DerValue> vec = new Vector<>(startLen);
-        DerValue value;
-
-        do {
-            value = new DerValue(newstr.buffer, buffer.allowBER);
-            vec.addElement(value);
-        } while (newstr.available() > 0);
-
-        if (newstr.available() != 0)
-            throw new IOException("Extra data at end of vector");
-
-        /*
-         * Now stick them into the array we're returning.
-         */
-        int             i, max = vec.size();
-        DerValue[]      retval = new DerValue[max];
-
-        for (i = 0; i < max; i++)
-            retval[i] = vec.elementAt(i);
-
-        return retval;
-    }
-
-    /**
-     * Get a single DER-encoded value from the input stream.
-     * It can often be useful to pull a value from the stream
-     * and defer parsing it.  For example, you can pull a nested
-     * sequence out with one call, and only examine its elements
-     * later when you really need to.
-     */
     public DerValue getDerValue() throws IOException {
-        return new DerValue(buffer);
+        DerValue result = new DerValue(
+                this.data, this.pos, this.end - this.pos, this.allowBER, false);
+        this.pos = result.end;
+        return result;
     }
 
-    /**
-     * Read a string that was encoded as a UTF8String DER value.
-     */
     public String getUTF8String() throws IOException {
-        return readString(DerValue.tag_UTF8String, "UTF-8", UTF_8);
+        return getDerValue().getUTF8String();
     }
 
-    /**
-     * Read a string that was encoded as a PrintableString DER value.
-     */
     public String getPrintableString() throws IOException {
-        return readString(DerValue.tag_PrintableString, "Printable",
-                          US_ASCII);
+        return getDerValue().getPrintableString();
     }
 
-    /**
-     * Read a string that was encoded as a T61String DER value.
-     */
     public String getT61String() throws IOException {
-        /*
-         * Works for common characters between T61 and ASCII.
-         */
-        return readString(DerValue.tag_T61String, "T61", ISO_8859_1);
-    }
-
-    /**
-     * Read a string that was encoded as a IA5String DER value.
-     */
-    public String getIA5String() throws IOException {
-        return readString(DerValue.tag_IA5String, "IA5", US_ASCII);
+        return getDerValue().getT61String();
     }
 
-    /**
-     * Read a string that was encoded as a BMPString DER value.
-     */
     public String getBMPString() throws IOException {
-        return readString(DerValue.tag_BMPString, "BMP", UTF_16BE);
+        return getDerValue().getBMPString();
     }
 
-    /**
-     * Read a string that was encoded as a GeneralString DER value.
-     */
-    public String getGeneralString() throws IOException {
-        return readString(DerValue.tag_GeneralString, "General",
-                          US_ASCII);
+    public String getIA5String() throws IOException {
+        return getDerValue().getIA5String();
     }
 
-    /**
-     * Private helper routine to read an encoded string from the input
-     * stream.
-     * @param stringTag the tag for the type of string to read
-     * @param stringName a name to display in error messages
-     * @param enc the encoder to use to interpret the data. Should
-     * correspond to the stringTag above.
-     */
-    private String readString(byte stringTag, String stringName,
-                              Charset charset) throws IOException {
-
-        if (buffer.read() != stringTag)
-            throw new IOException("DER input not a " +
-                                  stringName + " string");
-
-        int length = getDefiniteLength(buffer);
-        byte[] retval = new byte[length];
-        if ((length != 0) && (buffer.read(retval) != length))
-            throw new IOException("Short read of DER " +
-                                  stringName + " string");
-
-        return new String(retval, charset);
+    public String getGeneralString() throws IOException {
+        return getDerValue().getGeneralString();
     }
 
-    /**
-     * Get a UTC encoded time value from the input stream.
-     */
     public Date getUTCTime() throws IOException {
-        if (buffer.read() != DerValue.tag_UtcTime)
-            throw new IOException("DER input, UTCtime tag invalid ");
-        return buffer.getUTCTime(getDefiniteLength(buffer));
+        return getDerValue().getUTCTime();
     }
 
-    /**
-     * Get a Generalized encoded time value from the input stream.
-     */
     public Date getGeneralizedTime() throws IOException {
-        if (buffer.read() != DerValue.tag_GeneralizedTime)
-            throw new IOException("DER input, GeneralizedTime tag invalid ");
-        return buffer.getGeneralizedTime(getDefiniteLength(buffer));
-    }
-
-    /*
-     * Get a byte from the input stream.
-     */
-    // package private
-    int getByte() throws IOException {
-        return (0x00ff & buffer.read());
+        return getDerValue().getGeneralizedTime();
     }
 
     public int peekByte() throws IOException {
-        return buffer.peek();
-    }
-
-    // package private
-    int getLength() throws IOException {
-        return getLength(buffer);
+        if (pos == end) {
+            throw new IOException("At end");
+        }
+        return data[pos];
     }
 
-    /*
-     * Get a length from the input stream, allowing for at most 32 bits of
-     * encoding to be used.  (Not the same as getting a tagged integer!)
-     *
-     * @return the length or -1 if indefinite length found.
-     * @exception IOException on parsing error or unsupported lengths.
-     */
     static int getLength(InputStream in) throws IOException {
         return getLength(in.read(), in);
     }
 
     /*
@@ -620,14 +258,10 @@
             }
         }
         return value;
     }
 
-    int getDefiniteLength() throws IOException {
-        return getDefiniteLength(buffer);
-    }
-
     /*
      * Get a length from the input stream.
      *
      * @return the length
      * @exception IOException on parsing error or if indefinite length found.
@@ -638,27 +272,21 @@
             throw new IOException("Indefinite length encoding not supported");
         }
         return len;
     }
 
-    /**
-     * Mark the current position in the buffer, so that
-     * a later call to <code>reset</code> will return here.
-     */
-    public void mark(int value) { buffer.mark(value); }
-
-
     /**
      * Return to the position of the last <code>mark</code>
      * call.  A mark is implicitly set at the beginning of
      * the stream when it is created.
      */
-    public void reset() { buffer.reset(); }
+    public void reset() { pos = start; }
+    public void mark(int dummy) { }
 
 
     /**
      * Returns the number of bytes available for reading.
      * This is most useful for testing whether the stream is
      * empty.
      */
-    public int available() { return buffer.available(); }
+    public int available() { return end - pos; }
 }
diff a/src/java.base/share/classes/sun/security/util/DerValue.java b/src/java.base/share/classes/sun/security/util/DerValue.java
--- a/src/java.base/share/classes/sun/security/util/DerValue.java
+++ b/src/java.base/share/classes/sun/security/util/DerValue.java
@@ -1,7 +1,7 @@
 /**
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,14 +23,19 @@
  * questions.
  */
 
 package sun.security.util;
 
+import sun.util.calendar.CalendarDate;
+import sun.util.calendar.CalendarSystem;
+
 import java.io.*;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
-import java.util.Date;
+import java.nio.charset.IllegalCharsetNameException;
+import java.nio.charset.UnsupportedCharsetException;
+import java.util.*;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
  * Represents a single DER-encoded value.  DER encoding rules are a subset
@@ -54,28 +59,17 @@
  * @author David Brownell
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
 public class DerValue {
+
     /** The tag class types */
     public static final byte TAG_UNIVERSAL = (byte)0x000;
     public static final byte TAG_APPLICATION = (byte)0x040;
     public static final byte TAG_CONTEXT = (byte)0x080;
     public static final byte TAG_PRIVATE = (byte)0x0c0;
 
-    /** The DER tag of the value; one of the tag_ constants. */
-    public byte                 tag;
-
-    protected DerInputBuffer    buffer;
-
-    /**
-     * The DER-encoded data of the value, never null
-     */
-    public final DerInputStream data;
-
-    private int                 length;
-
     /*
      * The type starts at the first byte of the encoding, and
      * is one of these tag_* values.  That may be all the type
      * data that is needed.
      */
@@ -157,10 +151,19 @@
      * Tag value indicating an ASN.1
      * "SET OF" (one to N members, order does not matter).
      */
     public static final byte    tag_SetOf = 0x31;
 
+    // Instance fields start here:
+    public /*final*/ byte tag;
+    final byte[] buffer;
+    final int start;
+    final int end;
+    public final boolean allowBER;
+
+    final public DerInputStream data;
+
     /*
      * These values are the high order bits for the other kinds of tags.
      */
 
     /**
@@ -206,127 +209,201 @@
 
     /**
      * Creates a PrintableString or UTF8string DER value from a string
      */
     public DerValue(String value) {
-        boolean isPrintableString = true;
+        this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,
+                value);
+    }
+
+    public static boolean isPrintableString(String value) {
         for (int i = 0; i < value.length(); i++) {
             if (!isPrintableStringChar(value.charAt(i))) {
-                isPrintableString = false;
-                break;
+                return false;
             }
         }
-
-        data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
+        return true;
     }
 
     /**
      * Creates a string type DER value from a String object
      * @param stringTag the tag for the DER value to create
      * @param value the String object to use for the DER value
      */
     public DerValue(byte stringTag, String value) {
-        data = init(stringTag, value);
+        final Charset charset;
+
+        tag = stringTag;
+
+        switch (stringTag) {
+            case tag_PrintableString:
+            case tag_IA5String:
+            case tag_GeneralString:
+                charset = US_ASCII;
+                break;
+            case tag_T61String:
+                charset = ISO_8859_1;
+                break;
+            case tag_BMPString:
+                charset = UTF_16BE;
+                break;
+            case tag_UTF8String:
+                charset = UTF_8;
+                break;
+            case tag_UniversalString:
+                charset = Charset.forName("UTF_32BE");
+                break;
+            default:
+                throw new IllegalArgumentException("Unsupported DER string type");
+        }
+
+        buffer = value.getBytes(charset);
+        start = 0;
+        end = buffer.length;
+        allowBER = false;
+        this.data = new DerInputStream(this);
     }
 
     // Creates a DerValue from a tag and some DER-encoded data w/ additional
     // arg to control whether DER checks are enforced.
-    DerValue(byte tag, byte[] data, boolean allowBER) {
+    DerValue(byte tag, byte[] buffer, boolean allowBER) {
+        this(tag, buffer, 0, buffer.length, allowBER);
+    }
+
+    DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {
         this.tag = tag;
-        buffer = new DerInputBuffer(data.clone(), allowBER);
-        length = data.length;
-        this.data = new DerInputStream(buffer);
-        this.data.mark(Integer.MAX_VALUE);
+        this.buffer = buffer;
+        this.start = start;
+        this.end = end;
+        this.allowBER = allowBER;
+        this.data = new DerInputStream(this);
     }
 
     /**
      * Creates a DerValue from a tag and some DER-encoded data.
      *
      * @param tag the DER type tag
-     * @param data the DER-encoded data
+     * @param buffer the DER-encoded data
      */
-    public DerValue(byte tag, byte[] data) {
-        this(tag, data, true);
-    }
-
-    /*
-     * package private
-     */
-    DerValue(DerInputBuffer in) throws IOException {
-
-        // XXX must also parse BER-encoded constructed
-        // values such as sequences, sets...
-        tag = (byte)in.read();
-        byte lenByte = (byte)in.read();
-        length = DerInputStream.getLength(lenByte, in);
-        if (length == -1) {  // indefinite length encoding found
-            DerInputBuffer inbuf = in.dup();
-            inbuf = new DerInputBuffer(
-                    DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
-                    in.allowBER);
-            if (tag != inbuf.read())
-                throw new IOException
-                        ("Indefinite length encoding not supported");
-            length = DerInputStream.getDefiniteLength(inbuf);
-            buffer = inbuf.dup();
-            buffer.truncate(length);
-            data = new DerInputStream(buffer);
-            // indefinite form is encoded by sending a length field with a
-            // length of 0. - i.e. [1000|0000].
-            // the object is ended by sending two zero bytes.
-            in.skip(length + 2);
-        } else {
-
-            buffer = in.dup();
-            buffer.truncate(length);
-            data = new DerInputStream(buffer);
-
-            in.skip(length);
-        }
+    public DerValue(byte tag, byte[] buffer) {
+        this(tag, buffer.clone(), true);
     }
 
     // Get an ASN.1/DER encoded datum from a buffer w/ additional
     // arg to control whether DER checks are enforced.
     DerValue(byte[] buf, boolean allowBER) throws IOException {
-        data = init(true, new ByteArrayInputStream(buf), allowBER);
+        this(buf, 0, buf.length, allowBER);
     }
 
     /**
      * Get an ASN.1/DER encoded datum from a buffer.  The
      * entire buffer must hold exactly one datum, including
      * its tag and length.
      *
      * @param buf buffer holding a single DER-encoded datum.
      */
     public DerValue(byte[] buf) throws IOException {
-        this(buf, true);
+        this(buf.clone(), true);
     }
 
     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
     // arg to control whether DER checks are enforced.
-    DerValue(byte[] buf, int offset, int len, boolean allowBER)
-        throws IOException {
-        data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
+    DerValue(byte[] buf, int offset, int len, boolean allowBER) throws IOException {
+        this(buf, offset, len, allowBER, true);
     }
 
-    /**
-     * Get an ASN.1/DER encoded datum from part of a buffer.
-     * That part of the buffer must hold exactly one datum, including
-     * its tag and length.
-     *
-     * @param buf the buffer
-     * @param offset start point of the single DER-encoded dataum
-     * @param len how many bytes are in the encoded datum
-     */
-    public DerValue(byte[] buf, int offset, int len) throws IOException {
-        this(buf, offset, len, true);
+    DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean noMore) throws IOException {
+        if (len < 2) {
+            throw new IOException("Too short " + len);
+        }
+        int pos = offset;
+        tag = buf[pos++];
+        int length;
+        int lenByte = buf[pos++];
+
+        if (lenByte == (byte)0x80) {
+            length = -1;
+        } else if ((lenByte & 0x080) == 0x00) { // short form, 1 byte datum
+            length = lenByte;
+        } else {                     // long form or indefinite
+            lenByte &= 0x07f;
+            if (lenByte == 0) {
+                length = -1;
+            } else if (lenByte < 0 || lenByte > 4) {
+                throw new IOException("incorrect DER encoding");
+            } else {
+                if (len < 2 + lenByte) {
+                    throw new IOException("incorrect DER encoding");
+                }
+                length = 0x0ff & buf[pos++];
+                lenByte--;
+                if (length == 0 && !allowBER) {
+                    // DER requires length value be encoded in minimum number of bytes
+                    throw new IOException("Redundant length bytes found");
+                }
+                while (lenByte-- > 0) {
+                    length <<= 8;
+                    length += 0x0ff & buf[pos++];
+                }
+                if (length < 0) {
+                    throw new IOException("Invalid length bytes");
+                } else if (length <= 127 && !allowBER) {
+                    throw new IOException("Should use short form for length");
+                }
+            }
+        }
+        if (length == -1) { // indefinite length encoding found
+            if (!allowBER) {
+                throw new IOException
+                        ("Indefinite length encoding not supported");
+            }
+            InputStream in = new ByteArrayInputStream(
+                    DerIndefLenConverter.convertStream(
+                            new ByteArrayInputStream(buf, pos, len - (pos - offset)), (byte)lenByte, tag));
+            if (tag != in.read())
+                throw new IOException
+                        ("Indefinite length encoding not supported");
+            length = DerInputStream.getDefiniteLength(in);
+            this.buffer = IOUtils.readExactlyNBytes(in, length);
+            this.start = 0;
+            this.end = length;
+            this.allowBER = true;
+        } else {
+            if (len - length < pos - offset) {
+                throw new EOFException("Too little");
+            }
+            if (len - length > pos - offset && noMore) {
+                throw new IOException("Too much");
+            }
+            this.buffer = buf;
+            this.start = pos;
+            this.end = pos + length;
+            this.allowBER = allowBER;
+        }
+        this.data = new DerInputStream(this);
     }
 
     // Get an ASN1/DER encoded datum from an input stream w/ additional
     // arg to control whether DER checks are enforced.
     DerValue(InputStream in, boolean allowBER) throws IOException {
-        data = init(false, in, allowBER);
+        this.tag = (byte)in.read();
+        byte lenByte = (byte)in.read();
+        int length = DerInputStream.getLength(lenByte, in);
+        if (length == -1) { // indefinite length encoding found
+            in = new ByteArrayInputStream(
+                    DerIndefLenConverter.convertStream(in, lenByte, tag));
+            if (tag != in.read())
+                throw new IOException
+                        ("Indefinite length encoding not supported");
+            length = DerInputStream.getDefiniteLength(in);
+        }
+        this.buffer = IOUtils.readExactlyNBytes(in, length);
+        this.start = 0;
+        this.end = length;
+        this.allowBER = allowBER;
+        this.data = new DerInputStream(this);
+        System.out.println(this);
     }
 
     /**
      * Get an ASN1/DER encoded datum from an input stream.  The
      * stream may have additional data following the encoded datum.
@@ -338,90 +415,18 @@
      */
     public DerValue(InputStream in) throws IOException {
         this(in, true);
     }
 
-    private DerInputStream init(byte stringTag, String value) {
-        final Charset charset;
-
-        tag = stringTag;
-
-        switch (stringTag) {
-        case tag_PrintableString:
-        case tag_IA5String:
-        case tag_GeneralString:
-            charset = US_ASCII;
-            break;
-        case tag_T61String:
-            charset = ISO_8859_1;
-            break;
-        case tag_BMPString:
-            charset = UTF_16BE;
-            break;
-        case tag_UTF8String:
-            charset = UTF_8;
-            break;
-            // TBD: Need encoder for UniversalString before it can
-            // be handled.
-        default:
-            throw new IllegalArgumentException("Unsupported DER string type");
-        }
-
-        byte[] buf = value.getBytes(charset);
-        length = buf.length;
-        buffer = new DerInputBuffer(buf, true);
-        DerInputStream result = new DerInputStream(buffer);
-        result.mark(Integer.MAX_VALUE);
-        return result;
-    }
-
-    /*
-     * helper routine
-     */
-    private DerInputStream init(boolean fullyBuffered, InputStream in,
-        boolean allowBER) throws IOException {
-
-        tag = (byte)in.read();
-        byte lenByte = (byte)in.read();
-        length = DerInputStream.getLength(lenByte, in);
-        if (length == -1) { // indefinite length encoding found
-            in = new ByteArrayInputStream(
-                    DerIndefLenConverter.convertStream(in, lenByte, tag));
-            if (tag != in.read())
-                throw new IOException
-                        ("Indefinite length encoding not supported");
-            length = DerInputStream.getDefiniteLength(in);
-        }
-
-        if (fullyBuffered && in.available() != length)
-            throw new IOException("extra data given to DerValue constructor");
-
-        byte[] bytes = IOUtils.readExactlyNBytes(in, length);
-
-        buffer = new DerInputBuffer(bytes, allowBER);
-        return new DerInputStream(buffer);
-    }
-
     /**
      * Encode an ASN1/DER encoded datum onto a DER output stream.
      */
-    public void encode(DerOutputStream out)
-    throws IOException {
+    public void encode(DerOutputStream out) throws IOException {
         out.write(tag);
-        out.putLength(length);
-        // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
-        if (length > 0) {
-            byte[] value = new byte[length];
-            // always synchronized on data
-            synchronized (data) {
-                buffer.reset();
-                if (buffer.read(value) != length) {
-                    throw new IOException("short DER value read (encode)");
-                }
-                out.write(value);
-            }
-        }
+        out.putLength(end - start);
+        out.write(buffer, start, end - start);
+        data.pos = data.end; // Compatibility. Reach end.
     }
 
     public final DerInputStream getData() {
         return data;
     }
@@ -437,40 +442,28 @@
      */
     public boolean getBoolean() throws IOException {
         if (tag != tag_Boolean) {
             throw new IOException("DerValue.getBoolean, not a BOOLEAN " + tag);
         }
-        if (length != 1) {
+        if (end - start != 1) {
             throw new IOException("DerValue.getBoolean, invalid length "
-                                        + length);
-        }
-        if (buffer.read() != 0) {
-            return true;
+                                        + (end - start));
         }
-        return false;
+        data.pos = data.end; // Compatibility. Reach end.
+        return buffer[start] != 0;
     }
 
     /**
      * Returns an ASN.1 OBJECT IDENTIFIER.
      *
      * @return the OID held in this DER value
      */
     public ObjectIdentifier getOID() throws IOException {
         if (tag != tag_ObjectId)
             throw new IOException("DerValue.getOID, not an OID " + tag);
-        return new ObjectIdentifier(buffer);
-    }
-
-    private byte[] append(byte[] a, byte[] b) {
-        if (a == null)
-            return b;
-
-        byte[] ret = new byte[a.length + b.length];
-        System.arraycopy(a, 0, ret, 0, a.length);
-        System.arraycopy(b, 0, ret, a.length, b.length);
-
-        return ret;
+        data.pos = data.end; // Compatibility. Reach end.
+        return new ObjectIdentifier(buffer, start, end);
     }
 
     /**
      * Returns an ASN.1 OCTET STRING
      *
@@ -482,69 +475,75 @@
             throw new IOException(
                 "DerValue.getOctetString, not an Octet String: " + tag);
         }
         // Note: do not attempt to call buffer.read(bytes) at all. There's a
         // known bug that it returns -1 instead of 0.
-        if (length == 0) {
+        if (end - start == 0) {
             return new byte[0];
         }
 
-        // Only allocate the array if there are enough bytes available.
-        // This only works for ByteArrayInputStream.
-        // The assignment below ensures that buffer has the required type.
-        ByteArrayInputStream arrayInput = buffer;
-        if (arrayInput.available() < length) {
-            throw new IOException("short read on DerValue buffer");
-        }
-        byte[] bytes = new byte[length];
-        arrayInput.read(bytes);
-
-        if (isConstructed()) {
-            DerInputStream in = new DerInputStream(bytes, 0, bytes.length,
-                buffer.allowBER);
-            bytes = null;
-            while (in.available() != 0) {
-                bytes = append(bytes, in.getOctetString());
+        data.pos = data.end; // Compatibility. Reach end.
+        if (!isConstructed()) {
+            return Arrays.copyOfRange(buffer, start, end);
+        } else {
+            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            for (DerValue dv : new DerInputStream(this)) {
+                bout.write(dv.getOctetString());
             }
+            return bout.toByteArray();
         }
-        return bytes;
     }
 
     /**
      * Returns an ASN.1 INTEGER value as an integer.
      *
      * @return the integer held in this DER value.
      */
     public int getInteger() throws IOException {
-        if (tag != tag_Integer) {
-            throw new IOException("DerValue.getInteger, not an int " + tag);
+        BigInteger result = getBigInteger();
+        if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0) {
+            throw new IOException("Integer below minimum valid value");
+        }
+        if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {
+            throw new IOException("Integer exceeds maximum valid value");
         }
-        return buffer.getInteger(data.available());
+        return result.intValue();
     }
 
     /**
      * Returns an ASN.1 INTEGER value as a BigInteger.
      *
      * @return the integer held in this DER value as a BigInteger.
      */
     public BigInteger getBigInteger() throws IOException {
-        if (tag != tag_Integer)
-            throw new IOException("DerValue.getBigInteger, not an int " + tag);
-        return buffer.getBigInteger(data.available(), false);
+        return getBigInteger0(false);
     }
 
     /**
      * Returns an ASN.1 INTEGER value as a positive BigInteger.
      * This is just to deal with implementations that incorrectly encode
      * some values as negative.
      *
      * @return the integer held in this DER value as a BigInteger.
      */
     public BigInteger getPositiveBigInteger() throws IOException {
+        return getBigInteger0(true);
+    }
+
+    private BigInteger getBigInteger0(boolean mustBePositive) throws IOException {
         if (tag != tag_Integer)
             throw new IOException("DerValue.getBigInteger, not an int " + tag);
-        return buffer.getBigInteger(data.available(), true);
+        if (end == start) {
+            throw new IOException("Invalid encoding: zero length Int value");
+        }
+        data.pos = data.end; // Compatibility. Reach end.
+        if (!allowBER && (end - start >= 2 && (buffer[start] == 0) && (buffer[start + 1] >= 0))) {
+            throw new IOException("Invalid encoding: redundant leading 0s");
+        }
+        return mustBePositive
+                ? new BigInteger(1, buffer, start, end - start)
+                : new BigInteger(buffer, start, end - start);
     }
 
     /**
      * Returns an ASN.1 ENUMERATED value.
      *
@@ -553,37 +552,30 @@
     public int getEnumerated() throws IOException {
         if (tag != tag_Enumerated) {
             throw new IOException("DerValue.getEnumerated, incorrect tag: "
                                   + tag);
         }
-        return buffer.getInteger(data.available());
+        // TODO
+        return new BigInteger(1, buffer, start, end - start).intValue();
     }
 
     /**
      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
      *
      * @return the bit string held in this value
      */
     public byte[] getBitString() throws IOException {
-        if (tag != tag_BitString)
-            throw new IOException(
-                "DerValue.getBitString, not a bit string " + tag);
-
-        return buffer.getBitString();
+        return getBitString(false);
     }
 
     /**
      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
      *
      * @return a BitArray representing the bit string held in this value
      */
     public BitArray getUnalignedBitString() throws IOException {
-        if (tag != tag_BitString)
-            throw new IOException(
-                "DerValue.getBitString, not a bit string " + tag);
-
-        return buffer.getUnalignedBitString();
+        return getUnalignedBitString(false);
     }
 
     /**
      * Returns the name component as a Java string, regardless of its
      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
@@ -596,14 +588,12 @@
             return getPrintableString();
         else if (tag == tag_T61String)
             return getT61String();
         else if (tag == tag_IA5String)
             return getIA5String();
-        /*
-          else if (tag == tag_UniversalString)
+        else if (tag == tag_UniversalString)
           return getUniversalString();
-        */
         else if (tag == tag_BMPString)
             return getBMPString();
         else if (tag == tag_GeneralString)
             return getGeneralString();
         else
@@ -617,47 +607,76 @@
      * @param tagImplicit if true, the tag is assumed implicit.
      * @return the bit string held in this value
      */
     public byte[] getBitString(boolean tagImplicit) throws IOException {
         if (!tagImplicit) {
-            if (tag != tag_BitString)
+            if (tag != tag_BitString) {
                 throw new IOException("DerValue.getBitString, not a bit string "
-                                       + tag);
+                        + tag);
             }
-        return buffer.getBitString();
+        }
+        if (end == start) {
+            throw new IOException("No padding");
+        }
+        int numOfPadBits = buffer[start];
+        if ((numOfPadBits < 0) || (numOfPadBits > 7)) {
+            throw new IOException("Invalid number of padding bits");
+        }
+        // minus the first byte which indicates the number of padding bits
+        byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);
+        if (numOfPadBits != 0) {
+            // get rid of the padding bits
+            retval[end - start - 2] &= (0xff << numOfPadBits);
+        }
+        data.pos = data.end; // Compatibility. Reach end.
+        return retval;
     }
 
     /**
      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
      * based on the parameter.  The bit string need not be byte-aligned.
      *
      * @param tagImplicit if true, the tag is assumed implicit.
      * @return the bit string held in this value
      */
     public BitArray getUnalignedBitString(boolean tagImplicit)
-    throws IOException {
+            throws IOException {
         if (!tagImplicit) {
-            if (tag != tag_BitString)
+            if (tag != tag_BitString) {
                 throw new IOException("DerValue.getBitString, not a bit string "
-                                       + tag);
+                        + tag);
             }
-        return buffer.getUnalignedBitString();
+        }
+        if (end == start) {
+            throw new IOException("No padding");
+        }
+        data.pos = data.end; // Compatibility. Reach end.
+        if (end == start + 1) {
+            return new BitArray(0);
+        } else {
+            int numOfPadBits = buffer[start];
+            if ((numOfPadBits < 0) || (numOfPadBits > 7)) {
+                throw new IOException("Invalid number of padding bits");
+            }
+            return new BitArray((end - start - 1) * 8 - numOfPadBits,
+                    Arrays.copyOfRange(buffer, start + 1, end));
+        }
     }
 
     /**
      * Helper routine to return all the bytes contained in the
      * DerInputStream associated with this object.
      */
     public byte[] getDataBytes() throws IOException {
-        byte[] retVal = new byte[length];
-        synchronized (data) {
-            data.reset();
-            data.getBytes(retVal);
-        }
-        return retVal;
+        data.pos = data.end; // Compatibility. Reach end.
+        return Arrays.copyOfRange(buffer, start, end);
     }
 
+    private String readString0(Charset cs) {
+        data.pos = data.end; // Compatibility. Reach end.
+        return new String(buffer, start, end - start, cs);
+    }
     /**
      * Returns an ASN.1 STRING value
      *
      * @return the printable string held in this value
      */
@@ -665,11 +684,11 @@
     throws IOException {
         if (tag != tag_PrintableString)
             throw new IOException(
                 "DerValue.getPrintableString, not a string " + tag);
 
-        return new String(getDataBytes(), US_ASCII);
+        return readString0(US_ASCII);
     }
 
     /**
      * Returns an ASN.1 T61 (Teletype) STRING value
      *
@@ -678,11 +697,11 @@
     public String getT61String() throws IOException {
         if (tag != tag_T61String)
             throw new IOException(
                 "DerValue.getT61String, not T61 " + tag);
 
-        return new String(getDataBytes(), ISO_8859_1);
+        return readString0(ISO_8859_1);
     }
 
     /**
      * Returns an ASN.1 IA5 (ASCII) STRING value
      *
@@ -691,11 +710,11 @@
     public String getIA5String() throws IOException {
         if (tag != tag_IA5String)
             throw new IOException(
                 "DerValue.getIA5String, not IA5 " + tag);
 
-        return new String(getDataBytes(), US_ASCII);
+        return readString0(US_ASCII);
     }
 
     /**
      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
      *
@@ -707,11 +726,11 @@
             throw new IOException(
                 "DerValue.getBMPString, not BMP " + tag);
 
         // BMPString is the same as Unicode in big endian, unmarked
         // format.
-        return new String(getDataBytes(), UTF_16BE);
+        return readString0(UTF_16BE);
     }
 
     /**
      * Returns the ASN.1 UTF-8 STRING value as a Java String.
      *
@@ -721,11 +740,11 @@
     public String getUTF8String() throws IOException {
         if (tag != tag_UTF8String)
             throw new IOException(
                 "DerValue.getUTF8String, not UTF-8 " + tag);
 
-        return new String(getDataBytes(), UTF_8);
+        return readString0(UTF_8);
     }
 
     /**
      * Returns the ASN.1 GENERAL STRING value as a Java String.
      *
@@ -735,11 +754,197 @@
     public String getGeneralString() throws IOException {
         if (tag != tag_GeneralString)
             throw new IOException(
                 "DerValue.getGeneralString, not GeneralString " + tag);
 
-        return new String(getDataBytes(), US_ASCII);
+        return readString0(US_ASCII);
+    }
+
+    /**
+     * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.
+     *
+     * @return a string corresponding to the encoded UniversalString held in
+     * this value or an empty string if UTF_32BE is not a supported character
+     * set.
+     */
+    public String getUniversalString() throws IOException {
+        if (tag != tag_UniversalString)
+            throw new IOException(
+                "DerValue.getUniversalString, not UniversalString " + tag);
+        try {
+            Charset cset = Charset.forName("UTF_32BE");
+            return readString0(cset);
+        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {
+            return "";
+        }
+    }
+
+    private Date getTime(int len, boolean generalized) throws IOException {
+
+        /*
+         * UTC time encoded as ASCII chars:
+         *       YYMMDDhhmmZ
+         *       YYMMDDhhmmssZ
+         *       YYMMDDhhmm+hhmm
+         *       YYMMDDhhmm-hhmm
+         *       YYMMDDhhmmss+hhmm
+         *       YYMMDDhhmmss-hhmm
+         * UTC Time is broken in storing only two digits of year.
+         * If YY < 50, we assume 20YY;
+         * if YY >= 50, we assume 19YY, as per RFC 5280.
+         *
+         * Generalized time has a four-digit year and allows any
+         * precision specified in ISO 8601. However, for our purposes,
+         * we will only allow the same format as UTC time, except that
+         * fractional seconds (millisecond precision) are supported.
+         */
+
+        int year, month, day, hour, minute, second, millis;
+        String type = null;
+
+        int pos = start;
+        if (generalized) {
+            type = "Generalized";
+            year = 1000 * Character.digit((char)buffer[pos++], 10);
+            year += 100 * Character.digit((char)buffer[pos++], 10);
+            year += 10 * Character.digit((char)buffer[pos++], 10);
+            year += Character.digit((char)buffer[pos++], 10);
+            len -= 2; // For the two extra YY
+        } else {
+            type = "UTC";
+            year = 10 * Character.digit((char)buffer[pos++], 10);
+            year += Character.digit((char)buffer[pos++], 10);
+
+            if (year < 50)              // origin 2000
+                year += 2000;
+            else
+                year += 1900;   // origin 1900
+        }
+
+        month = 10 * Character.digit((char)buffer[pos++], 10);
+        month += Character.digit((char)buffer[pos++], 10);
+
+        day = 10 * Character.digit((char)buffer[pos++], 10);
+        day += Character.digit((char)buffer[pos++], 10);
+
+        hour = 10 * Character.digit((char)buffer[pos++], 10);
+        hour += Character.digit((char)buffer[pos++], 10);
+
+        minute = 10 * Character.digit((char)buffer[pos++], 10);
+        minute += Character.digit((char)buffer[pos++], 10);
+
+        len -= 10; // YYMMDDhhmm
+
+        /*
+         * We allow for non-encoded seconds, even though the
+         * IETF-PKIX specification says that the seconds should
+         * always be encoded even if it is zero.
+         */
+
+        millis = 0;
+        if (len > 2) {
+            second = 10 * Character.digit((char)buffer[pos++], 10);
+            second += Character.digit((char)buffer[pos++], 10);
+            len -= 2;
+            // handle fractional seconds (if present)
+            if (buffer[pos] == '.' || buffer[pos] == ',') {
+                len --;
+                pos++;
+                int precision = 0;
+                while (buffer[pos] != 'Z' &&
+                        buffer[pos] != '+' &&
+                        buffer[pos] != '-') {
+                    // Validate all digits in the fractional part but
+                    // store millisecond precision only
+                    int thisDigit = Character.digit((char)buffer[pos], 10);
+                    precision++;
+                    pos++;
+                    switch (precision) {
+                        case 1:
+                            millis += 100 * thisDigit;
+                            break;
+                        case 2:
+                            millis += 10 * thisDigit;
+                            break;
+                        case 3:
+                            millis += thisDigit;
+                            break;
+                    }
+                }
+                if (precision == 0) {
+                    throw new IOException("Parse " + type +
+                            " time, empty fractional part");
+                }
+                len -= precision;
+            }
+        } else
+            second = 0;
+
+        if (month == 0 || day == 0
+                || month > 12 || day > 31
+                || hour >= 24 || minute >= 60 || second >= 60)
+            throw new IOException("Parse " + type + " time, invalid format");
+
+        /*
+         * Generalized time can theoretically allow any precision,
+         * but we're not supporting that.
+         */
+        CalendarSystem gcal = CalendarSystem.getGregorianCalendar();
+        CalendarDate date = gcal.newCalendarDate(null); // no time zone
+        date.setDate(year, month, day);
+        date.setTimeOfDay(hour, minute, second, millis);
+        long time = gcal.getTime(date);
+
+        /*
+         * Finally, "Z" or "+hhmm" or "-hhmm" ... offsets change hhmm
+         */
+        if (! (len == 1 || len == 5))
+            throw new IOException("Parse " + type + " time, invalid offset");
+
+        int hr, min;
+
+        switch (buffer[pos++]) {
+            case '+':
+                hr = 10 * Character.digit((char)buffer[pos++], 10);
+                hr += Character.digit((char)buffer[pos++], 10);
+                min = 10 * Character.digit((char)buffer[pos++], 10);
+                min += Character.digit((char)buffer[pos++], 10);
+
+                if (hr >= 24 || min >= 60)
+                    throw new IOException("Parse " + type + " time, +hhmm");
+
+                time -= ((hr * 60) + min) * 60 * 1000;
+                break;
+
+            case '-':
+                hr = 10 * Character.digit((char)buffer[pos++], 10);
+                hr += Character.digit((char)buffer[pos++], 10);
+                min = 10 * Character.digit((char)buffer[pos++], 10);
+                min += Character.digit((char)buffer[pos++], 10);
+
+                if (hr >= 24 || min >= 60)
+                    throw new IOException("Parse " + type + " time, -hhmm");
+
+                time += ((hr * 60) + min) * 60 * 1000;
+                break;
+
+            case 'Z':
+                break;
+
+            default:
+                throw new IOException("Parse " + type + " time, garbage offset");
+        }
+        return new Date(time);
+    }
+
+    public void getNull() throws IOException {
+        if (tag != tag_Null) {
+            throw new IOException("DerValue.getUTCTime, not a UtcTime: " + tag);
+        }
+        if (end != start) {
+            throw new IOException("DER UTC Time length error");
+        }
     }
 
     /**
      * Returns a Date if the DerValue is UtcTime.
      *
@@ -747,11 +952,15 @@
      */
     public Date getUTCTime() throws IOException {
         if (tag != tag_UtcTime) {
             throw new IOException("DerValue.getUTCTime, not a UtcTime: " + tag);
         }
-        return buffer.getUTCTime(data.available());
+        if (end - start < 11 || end - start > 17)
+            throw new IOException("DER UTC Time length error");
+
+        data.pos = data.end; // Compatibility. Reach end.
+        return getTime(end - start, false);
     }
 
     /**
      * Returns a Date if the DerValue is GeneralizedTime.
      *
@@ -760,11 +969,15 @@
     public Date getGeneralizedTime() throws IOException {
         if (tag != tag_GeneralizedTime) {
             throw new IOException(
                 "DerValue.getGeneralizedTime, not a GeneralizedTime: " + tag);
         }
-        return buffer.getGeneralizedTime(data.available());
+        if (end - start < 13)
+            throw new IOException("DER Generalized Time length error");
+
+        data.pos = data.end; // Compatibility. Reach end.
+        return getTime(end - start, true);
     }
 
     /**
      * Bitwise equality comparison.  DER encoded values have a single
      * encoding, so that bitwise equality of the encoded values is an
@@ -782,71 +995,37 @@
         }
         DerValue other = (DerValue) o;
         if (tag != other.tag) {
             return false;
         }
-        if (data == other.data) {
+        if (buffer == other.buffer && start == other.start && end == other.end) {
             return true;
         }
-
-        // make sure the order of lock is always consistent to avoid a deadlock
-        return (System.identityHashCode(this.data)
-                > System.identityHashCode(other.data)) ?
-                doEquals(this, other):
-                doEquals(other, this);
-    }
-
-    /**
-     * Helper for public method equals()
-     */
-    private static boolean doEquals(DerValue d1, DerValue d2) {
-        synchronized (d1.data) {
-            synchronized (d2.data) {
-                d1.data.reset();
-                d2.data.reset();
-                return d1.buffer.equals(d2.buffer);
-            }
-        }
+        return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);
     }
 
     /**
      * Returns a printable representation of the value.
      *
      * @return printable representation of the value
      */
     @Override
     public String toString() {
-        try {
-
-            String str = getAsString();
-            if (str != null)
-                return "\"" + str + "\"";
-            if (tag == tag_Null)
-                return "[DerValue, null]";
-            if (tag == tag_ObjectId)
-                return "OID." + getOID();
-
-            // integers
-            else
-                return "[DerValue, tag = " + tag
-                        + ", length = " + length + "]";
-        } catch (IOException e) {
-            throw new IllegalArgumentException("misformatted DER value");
-        }
+        return String.format("DerValue(%02x, %s, %d, 5d)",
+                0xff & tag, buffer, start, end);
     }
 
     /**
      * Returns a DER-encoded value, such that if it's passed to the
      * DerValue constructor, a value equivalent to "this" is returned.
      *
      * @return DER-encoded value, including tag and length.
      */
     public byte[] toByteArray() throws IOException {
         DerOutputStream out = new DerOutputStream();
-
         encode(out);
-        data.reset();
+        data.pos = data.start; // encode go last, should go back
         return out.toByteArray();
     }
 
     /**
      * For "set" and "sequence" types, this function may be used
@@ -854,19 +1033,19 @@
      * This operation is not supported for primitive types such as
      * integers or bit strings.
      */
     public DerInputStream toDerInputStream() throws IOException {
         if (tag == tag_Sequence || tag == tag_Set)
-            return new DerInputStream(buffer);
+            return data;
         throw new IOException("toDerInputStream rejects tag type " + tag);
     }
 
     /**
      * Get the length of the encoded value.
      */
     public int length() {
-        return length;
+        return end - start;
     }
 
     /**
      * Determine if a character is one of the permissible characters for
      * PrintableString:
@@ -943,6 +1122,18 @@
      */
     @Override
     public int hashCode() {
         return toString().hashCode();
     }
+
+    public DerValue[] subs(byte expectedTag) throws IOException {
+        if (expectedTag != 0 && expectedTag != tag) {
+            throw new IOException("Not constructed");
+        }
+        List<DerValue> result = new ArrayList<>();
+        DerInputStream dis = new DerInputStream(this);
+        while (dis.available() > 0) {
+            result.add(dis.getDerValue());
+        }
+        return result.toArray(new DerValue[result.size()]);
+    }
 }
diff a/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java b/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
--- a/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
+++ b/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
@@ -215,10 +215,20 @@
             throw new IOException("ObjectIdentifier() -- Invalid format: "
                     + e.toString(), e);
         }
     }
 
+    public ObjectIdentifier(byte[] data, int start, int end) throws IOException {
+        encoding = Arrays.copyOfRange(data, start, end);
+        check(encoding);
+    }
+
+    ObjectIdentifier(ByteArrayInputStream in) throws IOException {
+        encoding = in.readAllBytes();
+        check(encoding);
+    }
+
     /**
      * Constructor, from an ASN.1 encoded input stream.
      * Validity check NOT included.
      * The encoding of the ID in the stream uses "DER", a BER/1 subset.
      * In this case, that means a triple { typeId, length, data }.
@@ -228,50 +238,11 @@
      *
      * @param in DER-encoded data holding an object ID
      * @exception IOException indicates a decoding error
      */
     public ObjectIdentifier(DerInputStream in) throws IOException {
-        byte    type_id;
-        int     bufferEnd;
-
-        /*
-         * Object IDs are a "universal" type, and their tag needs only
-         * one byte of encoding.  Verify that the tag of this datum
-         * is that of an object ID.
-         *
-         * Then get and check the length of the ID's encoding.  We set
-         * up so that we can use in.available() to check for the end of
-         * this value in the data stream.
-         */
-        type_id = (byte)in.getByte();
-        if (type_id != DerValue.tag_ObjectId)
-            throw new IOException (
-                "ObjectIdentifier() -- data isn't an object ID"
-                + " (tag = " +  type_id + ")"
-                );
-
-        int len = in.getDefiniteLength();
-        if (len > in.available()) {
-            throw new IOException("ObjectIdentifier() -- length exceeds" +
-                    "data available.  Length: " + len + ", Available: " +
-                    in.available());
-        }
-        encoding = new byte[len];
-        in.getBytes(encoding);
-        check(encoding);
-    }
-
-    /*
-     * Constructor, from the rest of a DER input buffer;
-     * the tag and length have been removed/verified
-     * Validity check NOT included.
-     */
-    ObjectIdentifier(DerInputBuffer buf) throws IOException {
-        DerInputStream in = new DerInputStream(buf);
-        encoding = new byte[in.available()];
-        in.getBytes(encoding);
-        check(encoding);
+        encoding = in.getDerValue().getOID().encoding;
     }
 
     private void init(int[] components, int length) {
         int pos = 0;
         byte[] tmp = new byte[length*5+1];  // +1 for empty input
diff a/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java b/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
--- a/test/jdk/sun/security/util/DerInputBuffer/DerInputBufferEqualsHashCode.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @author Gary Ellison
- * @bug 4170635
- * @summary Verify equals()/hashCode() contract honored
- * @modules java.base/sun.security.util:+open
- *          java.base/sun.security.x509
- * @run main/othervm/policy=Allow.policy DerInputBufferEqualsHashCode
- */
-
-import java.io.*;
-import sun.security.util.*;
-import sun.security.x509.*;
-import java.lang.reflect.*;
-
-
-public class DerInputBufferEqualsHashCode {
-
-    public static void main(String[] args) throws Exception {
-
-        String name1 = "CN=eve s. dropper";
-        DerOutputStream deros;
-        byte[] ba;
-        // encode
-        X500Name dn1 = new X500Name(name1);
-
-        deros = new DerOutputStream();
-        dn1.encode(deros);
-        ba = deros.toByteArray();
-
-        GetDIBConstructor a = new GetDIBConstructor();
-        java.security.AccessController.doPrivileged(a);
-        Constructor c = a.getCons();
-
-        Object[] objs = new Object[1];
-        objs[0] = ba;
-
-        Object db1 = null, db2 = null;
-        try {
-            db1 = c.newInstance(objs);
-            db2 = c.newInstance(objs);
-        } catch (Exception e) {
-            System.out.println("Caught unexpected exception " + e);
-            throw e;
-        }
-
-        if ( (db1.equals(db2)) == (db1.hashCode()==db2.hashCode()) )
-            System.out.println("PASSED");
-        else
-            throw new Exception("FAILED equals()/hashCode() contract");
-
-    }
-}
-
-
-class GetDIBConstructor implements java.security.PrivilegedExceptionAction {
-
-    private Class dibClass = null;
-    private Constructor dibCons = null;
-
-    public Object run() throws Exception {
-        try {
-            dibClass = Class.forName("sun.security.util.DerInputBuffer");
-            Constructor[] cons = dibClass.getDeclaredConstructors();
-
-            int i;
-            for (i = 0; i < cons.length; i++) {
-                Class [] parms = cons[i].getParameterTypes();
-                if (parms.length == 1) {
-                    if (parms[0].getName().equalsIgnoreCase("[B")) {
-                        cons[i].setAccessible(true);
-                        break;
-                    }
-                }
-            }
-            dibCons = cons[i];
-        } catch (Exception e) {
-            System.out.println("Caught unexpected exception " + e);
-            throw e;
-        }
-        return dibCons;
-    }
-
-    public Constructor getCons(){
-        return dibCons;
-    }
-
-}

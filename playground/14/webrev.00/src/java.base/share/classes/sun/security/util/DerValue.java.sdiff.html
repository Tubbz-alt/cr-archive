<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerValue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /**
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.util;
  27 



  28 import java.io.*;
  29 import java.math.BigInteger;
  30 import java.nio.charset.Charset;
<span class="line-modified">  31 import java.util.Date;</span>


  32 
  33 import static java.nio.charset.StandardCharsets.*;
  34 
  35 /**
  36  * Represents a single DER-encoded value.  DER encoding rules are a subset
  37  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
  38  * (&quot;Definite&quot; encoding) to encode any given value.
  39  *
  40  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
  41  * class represents such tagged values as they have been read (or constructed),
  42  * and provides structured access to the encoded data.
  43  *
  44  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
  45  * data encodings which are defined.  That subset is sufficient for parsing
  46  * most X.509 certificates, and working with selected additional formats
  47  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
  48  *
  49  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
  50  * and RFC 5280, section 8, we assume that this kind of string will contain
  51  * ISO-8859-1 characters only.
  52  *
  53  *
  54  * @author David Brownell
  55  * @author Amit Kapoor
  56  * @author Hemma Prafullchandra
  57  */
  58 public class DerValue {

  59     /** The tag class types */
  60     public static final byte TAG_UNIVERSAL = (byte)0x000;
  61     public static final byte TAG_APPLICATION = (byte)0x040;
  62     public static final byte TAG_CONTEXT = (byte)0x080;
  63     public static final byte TAG_PRIVATE = (byte)0x0c0;
  64 
<span class="line-removed">  65     /** The DER tag of the value; one of the tag_ constants. */</span>
<span class="line-removed">  66     public byte                 tag;</span>
<span class="line-removed">  67 </span>
<span class="line-removed">  68     protected DerInputBuffer    buffer;</span>
<span class="line-removed">  69 </span>
<span class="line-removed">  70     /**</span>
<span class="line-removed">  71      * The DER-encoded data of the value, never null</span>
<span class="line-removed">  72      */</span>
<span class="line-removed">  73     public final DerInputStream data;</span>
<span class="line-removed">  74 </span>
<span class="line-removed">  75     private int                 length;</span>
<span class="line-removed">  76 </span>
  77     /*
  78      * The type starts at the first byte of the encoding, and
  79      * is one of these tag_* values.  That may be all the type
  80      * data that is needed.
  81      */
  82 
  83     /*
  84      * These tags are the &quot;universal&quot; tags ... they mean the same
  85      * in all contexts.  (Mask with 0x1f -- five bits.)
  86      */
  87 
  88     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
  89     public static final byte    tag_Boolean = 0x01;
  90 
  91     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
  92     public static final byte    tag_Integer = 0x02;
  93 
  94     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
  95     public static final byte    tag_BitString = 0x03;
  96 
</pre>
<hr />
<pre>
 142     public static final byte    tag_Sequence = 0x30;
 143 
 144     /**
 145      * Tag value indicating an ASN.1
 146      * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
 147      */
 148     public static final byte    tag_SequenceOf = 0x30;
 149 
 150     /**
 151      * Tag value indicating an ASN.1
 152      * &quot;SET&quot; (zero to N members, order does not matter).
 153      */
 154     public static final byte    tag_Set = 0x31;
 155 
 156     /**
 157      * Tag value indicating an ASN.1
 158      * &quot;SET OF&quot; (one to N members, order does not matter).
 159      */
 160     public static final byte    tag_SetOf = 0x31;
 161 









 162     /*
 163      * These values are the high order bits for the other kinds of tags.
 164      */
 165 
 166     /**
 167      * Returns true if the tag class is UNIVERSAL.
 168      */
 169     public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }
 170 
 171     /**
 172      * Returns true if the tag class is APPLICATION.
 173      */
 174     public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }
 175 
 176     /**
 177      * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
 178      * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
 179      */
 180     public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }
 181 
</pre>
<hr />
<pre>
 191 
 192     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
 193 
 194     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
 195     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
 196 
 197     /**
 198      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
 199      */
 200     public boolean isConstructed(byte constructedTag) {
 201         if (!isConstructed()) {
 202             return false;
 203         }
 204         return ((tag &amp; 0x01f) == constructedTag);
 205     }
 206 
 207     /**
 208      * Creates a PrintableString or UTF8string DER value from a string
 209      */
 210     public DerValue(String value) {
<span class="line-modified"> 211         boolean isPrintableString = true;</span>




 212         for (int i = 0; i &lt; value.length(); i++) {
 213             if (!isPrintableStringChar(value.charAt(i))) {
<span class="line-modified"> 214                 isPrintableString = false;</span>
<span class="line-removed"> 215                 break;</span>
 216             }
 217         }
<span class="line-modified"> 218 </span>
<span class="line-removed"> 219         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);</span>
 220     }
 221 
 222     /**
 223      * Creates a string type DER value from a String object
 224      * @param stringTag the tag for the DER value to create
 225      * @param value the String object to use for the DER value
 226      */
 227     public DerValue(byte stringTag, String value) {
<span class="line-modified"> 228         data = init(stringTag, value);</span>






























 229     }
 230 
 231     // Creates a DerValue from a tag and some DER-encoded data w/ additional
 232     // arg to control whether DER checks are enforced.
<span class="line-modified"> 233     DerValue(byte tag, byte[] data, boolean allowBER) {</span>




 234         this.tag = tag;
<span class="line-modified"> 235         buffer = new DerInputBuffer(data.clone(), allowBER);</span>
<span class="line-modified"> 236         length = data.length;</span>
<span class="line-modified"> 237         this.data = new DerInputStream(buffer);</span>
<span class="line-modified"> 238         this.data.mark(Integer.MAX_VALUE);</span>

 239     }
 240 
 241     /**
 242      * Creates a DerValue from a tag and some DER-encoded data.
 243      *
 244      * @param tag the DER type tag
<span class="line-modified"> 245      * @param data the DER-encoded data</span>
 246      */
<span class="line-modified"> 247     public DerValue(byte tag, byte[] data) {</span>
<span class="line-modified"> 248         this(tag, data, true);</span>
<span class="line-removed"> 249     }</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251     /*</span>
<span class="line-removed"> 252      * package private</span>
<span class="line-removed"> 253      */</span>
<span class="line-removed"> 254     DerValue(DerInputBuffer in) throws IOException {</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256         // XXX must also parse BER-encoded constructed</span>
<span class="line-removed"> 257         // values such as sequences, sets...</span>
<span class="line-removed"> 258         tag = (byte)in.read();</span>
<span class="line-removed"> 259         byte lenByte = (byte)in.read();</span>
<span class="line-removed"> 260         length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-removed"> 261         if (length == -1) {  // indefinite length encoding found</span>
<span class="line-removed"> 262             DerInputBuffer inbuf = in.dup();</span>
<span class="line-removed"> 263             inbuf = new DerInputBuffer(</span>
<span class="line-removed"> 264                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),</span>
<span class="line-removed"> 265                     in.allowBER);</span>
<span class="line-removed"> 266             if (tag != inbuf.read())</span>
<span class="line-removed"> 267                 throw new IOException</span>
<span class="line-removed"> 268                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-removed"> 269             length = DerInputStream.getDefiniteLength(inbuf);</span>
<span class="line-removed"> 270             buffer = inbuf.dup();</span>
<span class="line-removed"> 271             buffer.truncate(length);</span>
<span class="line-removed"> 272             data = new DerInputStream(buffer);</span>
<span class="line-removed"> 273             // indefinite form is encoded by sending a length field with a</span>
<span class="line-removed"> 274             // length of 0. - i.e. [1000|0000].</span>
<span class="line-removed"> 275             // the object is ended by sending two zero bytes.</span>
<span class="line-removed"> 276             in.skip(length + 2);</span>
<span class="line-removed"> 277         } else {</span>
<span class="line-removed"> 278 </span>
<span class="line-removed"> 279             buffer = in.dup();</span>
<span class="line-removed"> 280             buffer.truncate(length);</span>
<span class="line-removed"> 281             data = new DerInputStream(buffer);</span>
<span class="line-removed"> 282 </span>
<span class="line-removed"> 283             in.skip(length);</span>
<span class="line-removed"> 284         }</span>
 285     }
 286 
 287     // Get an ASN.1/DER encoded datum from a buffer w/ additional
 288     // arg to control whether DER checks are enforced.
 289     DerValue(byte[] buf, boolean allowBER) throws IOException {
<span class="line-modified"> 290         data = init(true, new ByteArrayInputStream(buf), allowBER);</span>
 291     }
 292 
 293     /**
 294      * Get an ASN.1/DER encoded datum from a buffer.  The
 295      * entire buffer must hold exactly one datum, including
 296      * its tag and length.
 297      *
 298      * @param buf buffer holding a single DER-encoded datum.
 299      */
 300     public DerValue(byte[] buf) throws IOException {
<span class="line-modified"> 301         this(buf, true);</span>
 302     }
 303 
 304     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
 305     // arg to control whether DER checks are enforced.
<span class="line-modified"> 306     DerValue(byte[] buf, int offset, int len, boolean allowBER)</span>
<span class="line-modified"> 307         throws IOException {</span>
<span class="line-removed"> 308         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);</span>
 309     }
 310 
<span class="line-modified"> 311     /**</span>
<span class="line-modified"> 312      * Get an ASN.1/DER encoded datum from part of a buffer.</span>
<span class="line-modified"> 313      * That part of the buffer must hold exactly one datum, including</span>
<span class="line-modified"> 314      * its tag and length.</span>
<span class="line-modified"> 315      *</span>
<span class="line-modified"> 316      * @param buf the buffer</span>
<span class="line-modified"> 317      * @param offset start point of the single DER-encoded dataum</span>
<span class="line-modified"> 318      * @param len how many bytes are in the encoded datum</span>
<span class="line-modified"> 319      */</span>
<span class="line-modified"> 320     public DerValue(byte[] buf, int offset, int len) throws IOException {</span>
<span class="line-modified"> 321         this(buf, offset, len, true);</span>


























































 322     }
 323 
 324     // Get an ASN1/DER encoded datum from an input stream w/ additional
 325     // arg to control whether DER checks are enforced.
 326     DerValue(InputStream in, boolean allowBER) throws IOException {
<span class="line-modified"> 327         data = init(false, in, allowBER);</span>
















 328     }
 329 
 330     /**
 331      * Get an ASN1/DER encoded datum from an input stream.  The
 332      * stream may have additional data following the encoded datum.
 333      * In case of indefinite length encoded datum, the input stream
 334      * must hold only one datum.
 335      *
 336      * @param in the input stream holding a single DER datum,
 337      *  which may be followed by additional data
 338      */
 339     public DerValue(InputStream in) throws IOException {
 340         this(in, true);
 341     }
 342 
<span class="line-removed"> 343     private DerInputStream init(byte stringTag, String value) {</span>
<span class="line-removed"> 344         final Charset charset;</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346         tag = stringTag;</span>
<span class="line-removed"> 347 </span>
<span class="line-removed"> 348         switch (stringTag) {</span>
<span class="line-removed"> 349         case tag_PrintableString:</span>
<span class="line-removed"> 350         case tag_IA5String:</span>
<span class="line-removed"> 351         case tag_GeneralString:</span>
<span class="line-removed"> 352             charset = US_ASCII;</span>
<span class="line-removed"> 353             break;</span>
<span class="line-removed"> 354         case tag_T61String:</span>
<span class="line-removed"> 355             charset = ISO_8859_1;</span>
<span class="line-removed"> 356             break;</span>
<span class="line-removed"> 357         case tag_BMPString:</span>
<span class="line-removed"> 358             charset = UTF_16BE;</span>
<span class="line-removed"> 359             break;</span>
<span class="line-removed"> 360         case tag_UTF8String:</span>
<span class="line-removed"> 361             charset = UTF_8;</span>
<span class="line-removed"> 362             break;</span>
<span class="line-removed"> 363             // TBD: Need encoder for UniversalString before it can</span>
<span class="line-removed"> 364             // be handled.</span>
<span class="line-removed"> 365         default:</span>
<span class="line-removed"> 366             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);</span>
<span class="line-removed"> 367         }</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369         byte[] buf = value.getBytes(charset);</span>
<span class="line-removed"> 370         length = buf.length;</span>
<span class="line-removed"> 371         buffer = new DerInputBuffer(buf, true);</span>
<span class="line-removed"> 372         DerInputStream result = new DerInputStream(buffer);</span>
<span class="line-removed"> 373         result.mark(Integer.MAX_VALUE);</span>
<span class="line-removed"> 374         return result;</span>
<span class="line-removed"> 375     }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377     /*</span>
<span class="line-removed"> 378      * helper routine</span>
<span class="line-removed"> 379      */</span>
<span class="line-removed"> 380     private DerInputStream init(boolean fullyBuffered, InputStream in,</span>
<span class="line-removed"> 381         boolean allowBER) throws IOException {</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383         tag = (byte)in.read();</span>
<span class="line-removed"> 384         byte lenByte = (byte)in.read();</span>
<span class="line-removed"> 385         length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-removed"> 386         if (length == -1) { // indefinite length encoding found</span>
<span class="line-removed"> 387             in = new ByteArrayInputStream(</span>
<span class="line-removed"> 388                     DerIndefLenConverter.convertStream(in, lenByte, tag));</span>
<span class="line-removed"> 389             if (tag != in.read())</span>
<span class="line-removed"> 390                 throw new IOException</span>
<span class="line-removed"> 391                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-removed"> 392             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-removed"> 393         }</span>
<span class="line-removed"> 394 </span>
<span class="line-removed"> 395         if (fullyBuffered &amp;&amp; in.available() != length)</span>
<span class="line-removed"> 396             throw new IOException(&quot;extra data given to DerValue constructor&quot;);</span>
<span class="line-removed"> 397 </span>
<span class="line-removed"> 398         byte[] bytes = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-removed"> 399 </span>
<span class="line-removed"> 400         buffer = new DerInputBuffer(bytes, allowBER);</span>
<span class="line-removed"> 401         return new DerInputStream(buffer);</span>
<span class="line-removed"> 402     }</span>
<span class="line-removed"> 403 </span>
 404     /**
 405      * Encode an ASN1/DER encoded datum onto a DER output stream.
 406      */
<span class="line-modified"> 407     public void encode(DerOutputStream out)</span>
<span class="line-removed"> 408     throws IOException {</span>
 409         out.write(tag);
<span class="line-modified"> 410         out.putLength(length);</span>
<span class="line-modified"> 411         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)</span>
<span class="line-modified"> 412         if (length &gt; 0) {</span>
<span class="line-removed"> 413             byte[] value = new byte[length];</span>
<span class="line-removed"> 414             // always synchronized on data</span>
<span class="line-removed"> 415             synchronized (data) {</span>
<span class="line-removed"> 416                 buffer.reset();</span>
<span class="line-removed"> 417                 if (buffer.read(value) != length) {</span>
<span class="line-removed"> 418                     throw new IOException(&quot;short DER value read (encode)&quot;);</span>
<span class="line-removed"> 419                 }</span>
<span class="line-removed"> 420                 out.write(value);</span>
<span class="line-removed"> 421             }</span>
<span class="line-removed"> 422         }</span>
 423     }
 424 
 425     public final DerInputStream getData() {
 426         return data;
 427     }
 428 
 429     public final byte getTag() {
 430         return tag;
 431     }
 432 
 433     /**
 434      * Returns an ASN.1 BOOLEAN
 435      *
 436      * @return the boolean held in this DER value
 437      */
 438     public boolean getBoolean() throws IOException {
 439         if (tag != tag_Boolean) {
 440             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
 441         }
<span class="line-modified"> 442         if (length != 1) {</span>
 443             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
<span class="line-modified"> 444                                         + length);</span>
<span class="line-removed"> 445         }</span>
<span class="line-removed"> 446         if (buffer.read() != 0) {</span>
<span class="line-removed"> 447             return true;</span>
 448         }
<span class="line-modified"> 449         return false;</span>

 450     }
 451 
 452     /**
 453      * Returns an ASN.1 OBJECT IDENTIFIER.
 454      *
 455      * @return the OID held in this DER value
 456      */
 457     public ObjectIdentifier getOID() throws IOException {
 458         if (tag != tag_ObjectId)
 459             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
<span class="line-modified"> 460         return new ObjectIdentifier(buffer);</span>
<span class="line-modified"> 461     }</span>
<span class="line-removed"> 462 </span>
<span class="line-removed"> 463     private byte[] append(byte[] a, byte[] b) {</span>
<span class="line-removed"> 464         if (a == null)</span>
<span class="line-removed"> 465             return b;</span>
<span class="line-removed"> 466 </span>
<span class="line-removed"> 467         byte[] ret = new byte[a.length + b.length];</span>
<span class="line-removed"> 468         System.arraycopy(a, 0, ret, 0, a.length);</span>
<span class="line-removed"> 469         System.arraycopy(b, 0, ret, a.length, b.length);</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471         return ret;</span>
 472     }
 473 
 474     /**
 475      * Returns an ASN.1 OCTET STRING
 476      *
 477      * @return the octet string held in this DER value
 478      */
 479     public byte[] getOctetString() throws IOException {
 480 
 481         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
 482             throw new IOException(
 483                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
 484         }
 485         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
 486         // known bug that it returns -1 instead of 0.
<span class="line-modified"> 487         if (length == 0) {</span>
 488             return new byte[0];
 489         }
 490 
<span class="line-modified"> 491         // Only allocate the array if there are enough bytes available.</span>
<span class="line-modified"> 492         // This only works for ByteArrayInputStream.</span>
<span class="line-modified"> 493         // The assignment below ensures that buffer has the required type.</span>
<span class="line-modified"> 494         ByteArrayInputStream arrayInput = buffer;</span>
<span class="line-modified"> 495         if (arrayInput.available() &lt; length) {</span>
<span class="line-modified"> 496             throw new IOException(&quot;short read on DerValue buffer&quot;);</span>
<span class="line-modified"> 497         }</span>
<span class="line-removed"> 498         byte[] bytes = new byte[length];</span>
<span class="line-removed"> 499         arrayInput.read(bytes);</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501         if (isConstructed()) {</span>
<span class="line-removed"> 502             DerInputStream in = new DerInputStream(bytes, 0, bytes.length,</span>
<span class="line-removed"> 503                 buffer.allowBER);</span>
<span class="line-removed"> 504             bytes = null;</span>
<span class="line-removed"> 505             while (in.available() != 0) {</span>
<span class="line-removed"> 506                 bytes = append(bytes, in.getOctetString());</span>
 507             }

 508         }
<span class="line-removed"> 509         return bytes;</span>
 510     }
 511 
 512     /**
 513      * Returns an ASN.1 INTEGER value as an integer.
 514      *
 515      * @return the integer held in this DER value.
 516      */
 517     public int getInteger() throws IOException {
<span class="line-modified"> 518         if (tag != tag_Integer) {</span>
<span class="line-modified"> 519             throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);</span>




 520         }
<span class="line-modified"> 521         return buffer.getInteger(data.available());</span>
 522     }
 523 
 524     /**
 525      * Returns an ASN.1 INTEGER value as a BigInteger.
 526      *
 527      * @return the integer held in this DER value as a BigInteger.
 528      */
 529     public BigInteger getBigInteger() throws IOException {
<span class="line-modified"> 530         if (tag != tag_Integer)</span>
<span class="line-removed"> 531             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);</span>
<span class="line-removed"> 532         return buffer.getBigInteger(data.available(), false);</span>
 533     }
 534 
 535     /**
 536      * Returns an ASN.1 INTEGER value as a positive BigInteger.
 537      * This is just to deal with implementations that incorrectly encode
 538      * some values as negative.
 539      *
 540      * @return the integer held in this DER value as a BigInteger.
 541      */
 542     public BigInteger getPositiveBigInteger() throws IOException {




 543         if (tag != tag_Integer)
 544             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<span class="line-modified"> 545         return buffer.getBigInteger(data.available(), true);</span>









 546     }
 547 
 548     /**
 549      * Returns an ASN.1 ENUMERATED value.
 550      *
 551      * @return the integer held in this DER value.
 552      */
 553     public int getEnumerated() throws IOException {
 554         if (tag != tag_Enumerated) {
 555             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
 556                                   + tag);
 557         }
<span class="line-modified"> 558         return buffer.getInteger(data.available());</span>

 559     }
 560 
 561     /**
 562      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
 563      *
 564      * @return the bit string held in this value
 565      */
 566     public byte[] getBitString() throws IOException {
<span class="line-modified"> 567         if (tag != tag_BitString)</span>
<span class="line-removed"> 568             throw new IOException(</span>
<span class="line-removed"> 569                 &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-removed"> 570 </span>
<span class="line-removed"> 571         return buffer.getBitString();</span>
 572     }
 573 
 574     /**
 575      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
 576      *
 577      * @return a BitArray representing the bit string held in this value
 578      */
 579     public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified"> 580         if (tag != tag_BitString)</span>
<span class="line-removed"> 581             throw new IOException(</span>
<span class="line-removed"> 582                 &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-removed"> 583 </span>
<span class="line-removed"> 584         return buffer.getUnalignedBitString();</span>
 585     }
 586 
 587     /**
 588      * Returns the name component as a Java string, regardless of its
 589      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
 590      */
 591     // TBD: Need encoder for UniversalString before it can be handled.
 592     public String getAsString() throws IOException {
 593         if (tag == tag_UTF8String)
 594             return getUTF8String();
 595         else if (tag == tag_PrintableString)
 596             return getPrintableString();
 597         else if (tag == tag_T61String)
 598             return getT61String();
 599         else if (tag == tag_IA5String)
 600             return getIA5String();
<span class="line-modified"> 601         /*</span>
<span class="line-removed"> 602           else if (tag == tag_UniversalString)</span>
 603           return getUniversalString();
<span class="line-removed"> 604         */</span>
 605         else if (tag == tag_BMPString)
 606             return getBMPString();
 607         else if (tag == tag_GeneralString)
 608             return getGeneralString();
 609         else
 610             return null;
 611     }
 612 
 613     /**
 614      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 615      * based on the parameter.  The bit string must be byte-aligned.
 616      *
 617      * @param tagImplicit if true, the tag is assumed implicit.
 618      * @return the bit string held in this value
 619      */
 620     public byte[] getBitString(boolean tagImplicit) throws IOException {
 621         if (!tagImplicit) {
<span class="line-modified"> 622             if (tag != tag_BitString)</span>
 623                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified"> 624                                        + tag);</span>
 625             }
<span class="line-modified"> 626         return buffer.getBitString();</span>















 627     }
 628 
 629     /**
 630      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 631      * based on the parameter.  The bit string need not be byte-aligned.
 632      *
 633      * @param tagImplicit if true, the tag is assumed implicit.
 634      * @return the bit string held in this value
 635      */
 636     public BitArray getUnalignedBitString(boolean tagImplicit)
<span class="line-modified"> 637     throws IOException {</span>
 638         if (!tagImplicit) {
<span class="line-modified"> 639             if (tag != tag_BitString)</span>
 640                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified"> 641                                        + tag);</span>
 642             }
<span class="line-modified"> 643         return buffer.getUnalignedBitString();</span>














 644     }
 645 
 646     /**
 647      * Helper routine to return all the bytes contained in the
 648      * DerInputStream associated with this object.
 649      */
 650     public byte[] getDataBytes() throws IOException {
<span class="line-modified"> 651         byte[] retVal = new byte[length];</span>
<span class="line-modified"> 652         synchronized (data) {</span>
<span class="line-removed"> 653             data.reset();</span>
<span class="line-removed"> 654             data.getBytes(retVal);</span>
<span class="line-removed"> 655         }</span>
<span class="line-removed"> 656         return retVal;</span>
 657     }
 658 




 659     /**
 660      * Returns an ASN.1 STRING value
 661      *
 662      * @return the printable string held in this value
 663      */
 664     public String getPrintableString()
 665     throws IOException {
 666         if (tag != tag_PrintableString)
 667             throw new IOException(
 668                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
 669 
<span class="line-modified"> 670         return new String(getDataBytes(), US_ASCII);</span>
 671     }
 672 
 673     /**
 674      * Returns an ASN.1 T61 (Teletype) STRING value
 675      *
 676      * @return the teletype string held in this value
 677      */
 678     public String getT61String() throws IOException {
 679         if (tag != tag_T61String)
 680             throw new IOException(
 681                 &quot;DerValue.getT61String, not T61 &quot; + tag);
 682 
<span class="line-modified"> 683         return new String(getDataBytes(), ISO_8859_1);</span>
 684     }
 685 
 686     /**
 687      * Returns an ASN.1 IA5 (ASCII) STRING value
 688      *
 689      * @return the ASCII string held in this value
 690      */
 691     public String getIA5String() throws IOException {
 692         if (tag != tag_IA5String)
 693             throw new IOException(
 694                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
 695 
<span class="line-modified"> 696         return new String(getDataBytes(), US_ASCII);</span>
 697     }
 698 
 699     /**
 700      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
 701      *
 702      * @return a string corresponding to the encoded BMPString held in
 703      * this value
 704      */
 705     public String getBMPString() throws IOException {
 706         if (tag != tag_BMPString)
 707             throw new IOException(
 708                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
 709 
 710         // BMPString is the same as Unicode in big endian, unmarked
 711         // format.
<span class="line-modified"> 712         return new String(getDataBytes(), UTF_16BE);</span>
 713     }
 714 
 715     /**
 716      * Returns the ASN.1 UTF-8 STRING value as a Java String.
 717      *
 718      * @return a string corresponding to the encoded UTF8String held in
 719      * this value
 720      */
 721     public String getUTF8String() throws IOException {
 722         if (tag != tag_UTF8String)
 723             throw new IOException(
 724                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
 725 
<span class="line-modified"> 726         return new String(getDataBytes(), UTF_8);</span>
 727     }
 728 
 729     /**
 730      * Returns the ASN.1 GENERAL STRING value as a Java String.
 731      *
 732      * @return a string corresponding to the encoded GeneralString held in
 733      * this value
 734      */
 735     public String getGeneralString() throws IOException {
 736         if (tag != tag_GeneralString)
 737             throw new IOException(
 738                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
 739 
<span class="line-modified"> 740         return new String(getDataBytes(), US_ASCII);</span>


























































































































































































 741     }
 742 
 743     /**
 744      * Returns a Date if the DerValue is UtcTime.
 745      *
 746      * @return the Date held in this DER value
 747      */
 748     public Date getUTCTime() throws IOException {
 749         if (tag != tag_UtcTime) {
 750             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
 751         }
<span class="line-modified"> 752         return buffer.getUTCTime(data.available());</span>




 753     }
 754 
 755     /**
 756      * Returns a Date if the DerValue is GeneralizedTime.
 757      *
 758      * @return the Date held in this DER value
 759      */
 760     public Date getGeneralizedTime() throws IOException {
 761         if (tag != tag_GeneralizedTime) {
 762             throw new IOException(
 763                 &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
 764         }
<span class="line-modified"> 765         return buffer.getGeneralizedTime(data.available());</span>




 766     }
 767 
 768     /**
 769      * Bitwise equality comparison.  DER encoded values have a single
 770      * encoding, so that bitwise equality of the encoded values is an
 771      * efficient way to establish equivalence of the unencoded values.
 772      *
 773      * @param o the object being compared with this one
 774      */
 775     @Override
 776     public boolean equals(Object o) {
 777         if (this == o) {
 778             return true;
 779         }
 780         if (!(o instanceof DerValue)) {
 781             return false;
 782         }
 783         DerValue other = (DerValue) o;
 784         if (tag != other.tag) {
 785             return false;
 786         }
<span class="line-modified"> 787         if (data == other.data) {</span>
 788             return true;
 789         }
<span class="line-modified"> 790 </span>
<span class="line-removed"> 791         // make sure the order of lock is always consistent to avoid a deadlock</span>
<span class="line-removed"> 792         return (System.identityHashCode(this.data)</span>
<span class="line-removed"> 793                 &gt; System.identityHashCode(other.data)) ?</span>
<span class="line-removed"> 794                 doEquals(this, other):</span>
<span class="line-removed"> 795                 doEquals(other, this);</span>
<span class="line-removed"> 796     }</span>
<span class="line-removed"> 797 </span>
<span class="line-removed"> 798     /**</span>
<span class="line-removed"> 799      * Helper for public method equals()</span>
<span class="line-removed"> 800      */</span>
<span class="line-removed"> 801     private static boolean doEquals(DerValue d1, DerValue d2) {</span>
<span class="line-removed"> 802         synchronized (d1.data) {</span>
<span class="line-removed"> 803             synchronized (d2.data) {</span>
<span class="line-removed"> 804                 d1.data.reset();</span>
<span class="line-removed"> 805                 d2.data.reset();</span>
<span class="line-removed"> 806                 return d1.buffer.equals(d2.buffer);</span>
<span class="line-removed"> 807             }</span>
<span class="line-removed"> 808         }</span>
 809     }
 810 
 811     /**
 812      * Returns a printable representation of the value.
 813      *
 814      * @return printable representation of the value
 815      */
 816     @Override
 817     public String toString() {
<span class="line-modified"> 818         try {</span>
<span class="line-modified"> 819 </span>
<span class="line-removed"> 820             String str = getAsString();</span>
<span class="line-removed"> 821             if (str != null)</span>
<span class="line-removed"> 822                 return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;</span>
<span class="line-removed"> 823             if (tag == tag_Null)</span>
<span class="line-removed"> 824                 return &quot;[DerValue, null]&quot;;</span>
<span class="line-removed"> 825             if (tag == tag_ObjectId)</span>
<span class="line-removed"> 826                 return &quot;OID.&quot; + getOID();</span>
<span class="line-removed"> 827 </span>
<span class="line-removed"> 828             // integers</span>
<span class="line-removed"> 829             else</span>
<span class="line-removed"> 830                 return &quot;[DerValue, tag = &quot; + tag</span>
<span class="line-removed"> 831                         + &quot;, length = &quot; + length + &quot;]&quot;;</span>
<span class="line-removed"> 832         } catch (IOException e) {</span>
<span class="line-removed"> 833             throw new IllegalArgumentException(&quot;misformatted DER value&quot;);</span>
<span class="line-removed"> 834         }</span>
 835     }
 836 
 837     /**
 838      * Returns a DER-encoded value, such that if it&#39;s passed to the
 839      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
 840      *
 841      * @return DER-encoded value, including tag and length.
 842      */
 843     public byte[] toByteArray() throws IOException {
 844         DerOutputStream out = new DerOutputStream();
<span class="line-removed"> 845 </span>
 846         encode(out);
<span class="line-modified"> 847         data.reset();</span>
 848         return out.toByteArray();
 849     }
 850 
 851     /**
 852      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
 853      * to return a DER stream of the members of the set or sequence.
 854      * This operation is not supported for primitive types such as
 855      * integers or bit strings.
 856      */
 857     public DerInputStream toDerInputStream() throws IOException {
 858         if (tag == tag_Sequence || tag == tag_Set)
<span class="line-modified"> 859             return new DerInputStream(buffer);</span>
 860         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
 861     }
 862 
 863     /**
 864      * Get the length of the encoded value.
 865      */
 866     public int length() {
<span class="line-modified"> 867         return length;</span>
 868     }
 869 
 870     /**
 871      * Determine if a character is one of the permissible characters for
 872      * PrintableString:
 873      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
 874      * plus sign, comma, hyphen, period, slash, colon, equals sign,
 875      * and question mark.
 876      *
 877      * Characters that are *not* allowed in PrintableString include
 878      * exclamation point, quotation mark, number sign, dollar sign,
 879      * percent sign, ampersand, asterisk, semicolon, less than sign,
 880      * greater than sign, at sign, left and right square brackets,
 881      * backslash, circumflex (94), underscore, back quote (96),
 882      * left and right curly brackets, vertical line, tilde,
 883      * and the control codes (0-31 and 127).
 884      *
 885      * This list is based on X.680 (the ASN.1 spec).
 886      */
 887     public static boolean isPrintableStringChar(char ch) {
</pre>
<hr />
<pre>
 928 
 929     /**
 930      * Set the tag of the attribute. Commonly used to reset the
 931      * tag value used for IMPLICIT encodings.
 932      *
 933      * @param tag the tag value
 934      */
 935     public void resetTag(byte tag) {
 936         this.tag = tag;
 937     }
 938 
 939     /**
 940      * Returns a hashcode for this DerValue.
 941      *
 942      * @return a hashcode for this DerValue.
 943      */
 944     @Override
 945     public int hashCode() {
 946         return toString().hashCode();
 947     }












 948 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /**
<span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.util;
  27 
<span class="line-added">  28 import sun.util.calendar.CalendarDate;</span>
<span class="line-added">  29 import sun.util.calendar.CalendarSystem;</span>
<span class="line-added">  30 </span>
  31 import java.io.*;
  32 import java.math.BigInteger;
  33 import java.nio.charset.Charset;
<span class="line-modified">  34 import java.nio.charset.IllegalCharsetNameException;</span>
<span class="line-added">  35 import java.nio.charset.UnsupportedCharsetException;</span>
<span class="line-added">  36 import java.util.*;</span>
  37 
  38 import static java.nio.charset.StandardCharsets.*;
  39 
  40 /**
  41  * Represents a single DER-encoded value.  DER encoding rules are a subset
  42  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
  43  * (&quot;Definite&quot; encoding) to encode any given value.
  44  *
  45  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
  46  * class represents such tagged values as they have been read (or constructed),
  47  * and provides structured access to the encoded data.
  48  *
  49  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
  50  * data encodings which are defined.  That subset is sufficient for parsing
  51  * most X.509 certificates, and working with selected additional formats
  52  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
  53  *
  54  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
  55  * and RFC 5280, section 8, we assume that this kind of string will contain
  56  * ISO-8859-1 characters only.
  57  *
  58  *
  59  * @author David Brownell
  60  * @author Amit Kapoor
  61  * @author Hemma Prafullchandra
  62  */
  63 public class DerValue {
<span class="line-added">  64 </span>
  65     /** The tag class types */
  66     public static final byte TAG_UNIVERSAL = (byte)0x000;
  67     public static final byte TAG_APPLICATION = (byte)0x040;
  68     public static final byte TAG_CONTEXT = (byte)0x080;
  69     public static final byte TAG_PRIVATE = (byte)0x0c0;
  70 












  71     /*
  72      * The type starts at the first byte of the encoding, and
  73      * is one of these tag_* values.  That may be all the type
  74      * data that is needed.
  75      */
  76 
  77     /*
  78      * These tags are the &quot;universal&quot; tags ... they mean the same
  79      * in all contexts.  (Mask with 0x1f -- five bits.)
  80      */
  81 
  82     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
  83     public static final byte    tag_Boolean = 0x01;
  84 
  85     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
  86     public static final byte    tag_Integer = 0x02;
  87 
  88     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
  89     public static final byte    tag_BitString = 0x03;
  90 
</pre>
<hr />
<pre>
 136     public static final byte    tag_Sequence = 0x30;
 137 
 138     /**
 139      * Tag value indicating an ASN.1
 140      * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
 141      */
 142     public static final byte    tag_SequenceOf = 0x30;
 143 
 144     /**
 145      * Tag value indicating an ASN.1
 146      * &quot;SET&quot; (zero to N members, order does not matter).
 147      */
 148     public static final byte    tag_Set = 0x31;
 149 
 150     /**
 151      * Tag value indicating an ASN.1
 152      * &quot;SET OF&quot; (one to N members, order does not matter).
 153      */
 154     public static final byte    tag_SetOf = 0x31;
 155 
<span class="line-added"> 156     // Instance fields start here:</span>
<span class="line-added"> 157     public /*final*/ byte tag;</span>
<span class="line-added"> 158     final byte[] buffer;</span>
<span class="line-added"> 159     final int start;</span>
<span class="line-added"> 160     final int end;</span>
<span class="line-added"> 161     public final boolean allowBER;</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163     final public DerInputStream data;</span>
<span class="line-added"> 164 </span>
 165     /*
 166      * These values are the high order bits for the other kinds of tags.
 167      */
 168 
 169     /**
 170      * Returns true if the tag class is UNIVERSAL.
 171      */
 172     public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }
 173 
 174     /**
 175      * Returns true if the tag class is APPLICATION.
 176      */
 177     public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }
 178 
 179     /**
 180      * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
 181      * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
 182      */
 183     public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }
 184 
</pre>
<hr />
<pre>
 194 
 195     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
 196 
 197     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
 198     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
 199 
 200     /**
 201      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
 202      */
 203     public boolean isConstructed(byte constructedTag) {
 204         if (!isConstructed()) {
 205             return false;
 206         }
 207         return ((tag &amp; 0x01f) == constructedTag);
 208     }
 209 
 210     /**
 211      * Creates a PrintableString or UTF8string DER value from a string
 212      */
 213     public DerValue(String value) {
<span class="line-modified"> 214         this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,</span>
<span class="line-added"> 215                 value);</span>
<span class="line-added"> 216     }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218     public static boolean isPrintableString(String value) {</span>
 219         for (int i = 0; i &lt; value.length(); i++) {
 220             if (!isPrintableStringChar(value.charAt(i))) {
<span class="line-modified"> 221                 return false;</span>

 222             }
 223         }
<span class="line-modified"> 224         return true;</span>

 225     }
 226 
 227     /**
 228      * Creates a string type DER value from a String object
 229      * @param stringTag the tag for the DER value to create
 230      * @param value the String object to use for the DER value
 231      */
 232     public DerValue(byte stringTag, String value) {
<span class="line-modified"> 233         final Charset charset;</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235         tag = stringTag;</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237         switch (stringTag) {</span>
<span class="line-added"> 238             case tag_PrintableString:</span>
<span class="line-added"> 239             case tag_IA5String:</span>
<span class="line-added"> 240             case tag_GeneralString:</span>
<span class="line-added"> 241                 charset = US_ASCII;</span>
<span class="line-added"> 242                 break;</span>
<span class="line-added"> 243             case tag_T61String:</span>
<span class="line-added"> 244                 charset = ISO_8859_1;</span>
<span class="line-added"> 245                 break;</span>
<span class="line-added"> 246             case tag_BMPString:</span>
<span class="line-added"> 247                 charset = UTF_16BE;</span>
<span class="line-added"> 248                 break;</span>
<span class="line-added"> 249             case tag_UTF8String:</span>
<span class="line-added"> 250                 charset = UTF_8;</span>
<span class="line-added"> 251                 break;</span>
<span class="line-added"> 252             case tag_UniversalString:</span>
<span class="line-added"> 253                 charset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added"> 254                 break;</span>
<span class="line-added"> 255             default:</span>
<span class="line-added"> 256                 throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);</span>
<span class="line-added"> 257         }</span>
<span class="line-added"> 258 </span>
<span class="line-added"> 259         buffer = value.getBytes(charset);</span>
<span class="line-added"> 260         start = 0;</span>
<span class="line-added"> 261         end = buffer.length;</span>
<span class="line-added"> 262         allowBER = false;</span>
<span class="line-added"> 263         this.data = new DerInputStream(this);</span>
 264     }
 265 
 266     // Creates a DerValue from a tag and some DER-encoded data w/ additional
 267     // arg to control whether DER checks are enforced.
<span class="line-modified"> 268     DerValue(byte tag, byte[] buffer, boolean allowBER) {</span>
<span class="line-added"> 269         this(tag, buffer, 0, buffer.length, allowBER);</span>
<span class="line-added"> 270     }</span>
<span class="line-added"> 271 </span>
<span class="line-added"> 272     DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {</span>
 273         this.tag = tag;
<span class="line-modified"> 274         this.buffer = buffer;</span>
<span class="line-modified"> 275         this.start = start;</span>
<span class="line-modified"> 276         this.end = end;</span>
<span class="line-modified"> 277         this.allowBER = allowBER;</span>
<span class="line-added"> 278         this.data = new DerInputStream(this);</span>
 279     }
 280 
 281     /**
 282      * Creates a DerValue from a tag and some DER-encoded data.
 283      *
 284      * @param tag the DER type tag
<span class="line-modified"> 285      * @param buffer the DER-encoded data</span>
 286      */
<span class="line-modified"> 287     public DerValue(byte tag, byte[] buffer) {</span>
<span class="line-modified"> 288         this(tag, buffer.clone(), true);</span>




































 289     }
 290 
 291     // Get an ASN.1/DER encoded datum from a buffer w/ additional
 292     // arg to control whether DER checks are enforced.
 293     DerValue(byte[] buf, boolean allowBER) throws IOException {
<span class="line-modified"> 294         this(buf, 0, buf.length, allowBER);</span>
 295     }
 296 
 297     /**
 298      * Get an ASN.1/DER encoded datum from a buffer.  The
 299      * entire buffer must hold exactly one datum, including
 300      * its tag and length.
 301      *
 302      * @param buf buffer holding a single DER-encoded datum.
 303      */
 304     public DerValue(byte[] buf) throws IOException {
<span class="line-modified"> 305         this(buf.clone(), true);</span>
 306     }
 307 
 308     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
 309     // arg to control whether DER checks are enforced.
<span class="line-modified"> 310     DerValue(byte[] buf, int offset, int len, boolean allowBER) throws IOException {</span>
<span class="line-modified"> 311         this(buf, offset, len, allowBER, true);</span>

 312     }
 313 
<span class="line-modified"> 314     DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean noMore) throws IOException {</span>
<span class="line-modified"> 315         if (len &lt; 2) {</span>
<span class="line-modified"> 316             throw new IOException(&quot;Too short &quot; + len);</span>
<span class="line-modified"> 317         }</span>
<span class="line-modified"> 318         int pos = offset;</span>
<span class="line-modified"> 319         tag = buf[pos++];</span>
<span class="line-modified"> 320         int length;</span>
<span class="line-modified"> 321         int lenByte = buf[pos++];</span>
<span class="line-modified"> 322 </span>
<span class="line-modified"> 323         if (lenByte == (byte)0x80) {</span>
<span class="line-modified"> 324             length = -1;</span>
<span class="line-added"> 325         } else if ((lenByte &amp; 0x080) == 0x00) { // short form, 1 byte datum</span>
<span class="line-added"> 326             length = lenByte;</span>
<span class="line-added"> 327         } else {                     // long form or indefinite</span>
<span class="line-added"> 328             lenByte &amp;= 0x07f;</span>
<span class="line-added"> 329             if (lenByte == 0) {</span>
<span class="line-added"> 330                 length = -1;</span>
<span class="line-added"> 331             } else if (lenByte &lt; 0 || lenByte &gt; 4) {</span>
<span class="line-added"> 332                 throw new IOException(&quot;incorrect DER encoding&quot;);</span>
<span class="line-added"> 333             } else {</span>
<span class="line-added"> 334                 if (len &lt; 2 + lenByte) {</span>
<span class="line-added"> 335                     throw new IOException(&quot;incorrect DER encoding&quot;);</span>
<span class="line-added"> 336                 }</span>
<span class="line-added"> 337                 length = 0x0ff &amp; buf[pos++];</span>
<span class="line-added"> 338                 lenByte--;</span>
<span class="line-added"> 339                 if (length == 0 &amp;&amp; !allowBER) {</span>
<span class="line-added"> 340                     // DER requires length value be encoded in minimum number of bytes</span>
<span class="line-added"> 341                     throw new IOException(&quot;Redundant length bytes found&quot;);</span>
<span class="line-added"> 342                 }</span>
<span class="line-added"> 343                 while (lenByte-- &gt; 0) {</span>
<span class="line-added"> 344                     length &lt;&lt;= 8;</span>
<span class="line-added"> 345                     length += 0x0ff &amp; buf[pos++];</span>
<span class="line-added"> 346                 }</span>
<span class="line-added"> 347                 if (length &lt; 0) {</span>
<span class="line-added"> 348                     throw new IOException(&quot;Invalid length bytes&quot;);</span>
<span class="line-added"> 349                 } else if (length &lt;= 127 &amp;&amp; !allowBER) {</span>
<span class="line-added"> 350                     throw new IOException(&quot;Should use short form for length&quot;);</span>
<span class="line-added"> 351                 }</span>
<span class="line-added"> 352             }</span>
<span class="line-added"> 353         }</span>
<span class="line-added"> 354         if (length == -1) { // indefinite length encoding found</span>
<span class="line-added"> 355             if (!allowBER) {</span>
<span class="line-added"> 356                 throw new IOException</span>
<span class="line-added"> 357                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added"> 358             }</span>
<span class="line-added"> 359             InputStream in = new ByteArrayInputStream(</span>
<span class="line-added"> 360                     DerIndefLenConverter.convertStream(</span>
<span class="line-added"> 361                             new ByteArrayInputStream(buf, pos, len - (pos - offset)), (byte)lenByte, tag));</span>
<span class="line-added"> 362             if (tag != in.read())</span>
<span class="line-added"> 363                 throw new IOException</span>
<span class="line-added"> 364                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added"> 365             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-added"> 366             this.buffer = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-added"> 367             this.start = 0;</span>
<span class="line-added"> 368             this.end = length;</span>
<span class="line-added"> 369             this.allowBER = true;</span>
<span class="line-added"> 370         } else {</span>
<span class="line-added"> 371             if (len - length &lt; pos - offset) {</span>
<span class="line-added"> 372                 throw new EOFException(&quot;Too little&quot;);</span>
<span class="line-added"> 373             }</span>
<span class="line-added"> 374             if (len - length &gt; pos - offset &amp;&amp; noMore) {</span>
<span class="line-added"> 375                 throw new IOException(&quot;Too much&quot;);</span>
<span class="line-added"> 376             }</span>
<span class="line-added"> 377             this.buffer = buf;</span>
<span class="line-added"> 378             this.start = pos;</span>
<span class="line-added"> 379             this.end = pos + length;</span>
<span class="line-added"> 380             this.allowBER = allowBER;</span>
<span class="line-added"> 381         }</span>
<span class="line-added"> 382         this.data = new DerInputStream(this);</span>
 383     }
 384 
 385     // Get an ASN1/DER encoded datum from an input stream w/ additional
 386     // arg to control whether DER checks are enforced.
 387     DerValue(InputStream in, boolean allowBER) throws IOException {
<span class="line-modified"> 388         this.tag = (byte)in.read();</span>
<span class="line-added"> 389         byte lenByte = (byte)in.read();</span>
<span class="line-added"> 390         int length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-added"> 391         if (length == -1) { // indefinite length encoding found</span>
<span class="line-added"> 392             in = new ByteArrayInputStream(</span>
<span class="line-added"> 393                     DerIndefLenConverter.convertStream(in, lenByte, tag));</span>
<span class="line-added"> 394             if (tag != in.read())</span>
<span class="line-added"> 395                 throw new IOException</span>
<span class="line-added"> 396                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added"> 397             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-added"> 398         }</span>
<span class="line-added"> 399         this.buffer = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-added"> 400         this.start = 0;</span>
<span class="line-added"> 401         this.end = length;</span>
<span class="line-added"> 402         this.allowBER = allowBER;</span>
<span class="line-added"> 403         this.data = new DerInputStream(this);</span>
<span class="line-added"> 404         System.out.println(this);</span>
 405     }
 406 
 407     /**
 408      * Get an ASN1/DER encoded datum from an input stream.  The
 409      * stream may have additional data following the encoded datum.
 410      * In case of indefinite length encoded datum, the input stream
 411      * must hold only one datum.
 412      *
 413      * @param in the input stream holding a single DER datum,
 414      *  which may be followed by additional data
 415      */
 416     public DerValue(InputStream in) throws IOException {
 417         this(in, true);
 418     }
 419 





























































 420     /**
 421      * Encode an ASN1/DER encoded datum onto a DER output stream.
 422      */
<span class="line-modified"> 423     public void encode(DerOutputStream out) throws IOException {</span>

 424         out.write(tag);
<span class="line-modified"> 425         out.putLength(end - start);</span>
<span class="line-modified"> 426         out.write(buffer, start, end - start);</span>
<span class="line-modified"> 427         data.pos = data.end; // Compatibility. Reach end.</span>










 428     }
 429 
 430     public final DerInputStream getData() {
 431         return data;
 432     }
 433 
 434     public final byte getTag() {
 435         return tag;
 436     }
 437 
 438     /**
 439      * Returns an ASN.1 BOOLEAN
 440      *
 441      * @return the boolean held in this DER value
 442      */
 443     public boolean getBoolean() throws IOException {
 444         if (tag != tag_Boolean) {
 445             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
 446         }
<span class="line-modified"> 447         if (end - start != 1) {</span>
 448             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
<span class="line-modified"> 449                                         + (end - start));</span>



 450         }
<span class="line-modified"> 451         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 452         return buffer[start] != 0;</span>
 453     }
 454 
 455     /**
 456      * Returns an ASN.1 OBJECT IDENTIFIER.
 457      *
 458      * @return the OID held in this DER value
 459      */
 460     public ObjectIdentifier getOID() throws IOException {
 461         if (tag != tag_ObjectId)
 462             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
<span class="line-modified"> 463         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified"> 464         return new ObjectIdentifier(buffer, start, end);</span>










 465     }
 466 
 467     /**
 468      * Returns an ASN.1 OCTET STRING
 469      *
 470      * @return the octet string held in this DER value
 471      */
 472     public byte[] getOctetString() throws IOException {
 473 
 474         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
 475             throw new IOException(
 476                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
 477         }
 478         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
 479         // known bug that it returns -1 instead of 0.
<span class="line-modified"> 480         if (end - start == 0) {</span>
 481             return new byte[0];
 482         }
 483 
<span class="line-modified"> 484         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified"> 485         if (!isConstructed()) {</span>
<span class="line-modified"> 486             return Arrays.copyOfRange(buffer, start, end);</span>
<span class="line-modified"> 487         } else {</span>
<span class="line-modified"> 488             ByteArrayOutputStream bout = new ByteArrayOutputStream();</span>
<span class="line-modified"> 489             for (DerValue dv : new DerInputStream(this)) {</span>
<span class="line-modified"> 490                 bout.write(dv.getOctetString());</span>









 491             }
<span class="line-added"> 492             return bout.toByteArray();</span>
 493         }

 494     }
 495 
 496     /**
 497      * Returns an ASN.1 INTEGER value as an integer.
 498      *
 499      * @return the integer held in this DER value.
 500      */
 501     public int getInteger() throws IOException {
<span class="line-modified"> 502         BigInteger result = getBigInteger();</span>
<span class="line-modified"> 503         if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0) {</span>
<span class="line-added"> 504             throw new IOException(&quot;Integer below minimum valid value&quot;);</span>
<span class="line-added"> 505         }</span>
<span class="line-added"> 506         if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
<span class="line-added"> 507             throw new IOException(&quot;Integer exceeds maximum valid value&quot;);</span>
 508         }
<span class="line-modified"> 509         return result.intValue();</span>
 510     }
 511 
 512     /**
 513      * Returns an ASN.1 INTEGER value as a BigInteger.
 514      *
 515      * @return the integer held in this DER value as a BigInteger.
 516      */
 517     public BigInteger getBigInteger() throws IOException {
<span class="line-modified"> 518         return getBigInteger0(false);</span>


 519     }
 520 
 521     /**
 522      * Returns an ASN.1 INTEGER value as a positive BigInteger.
 523      * This is just to deal with implementations that incorrectly encode
 524      * some values as negative.
 525      *
 526      * @return the integer held in this DER value as a BigInteger.
 527      */
 528     public BigInteger getPositiveBigInteger() throws IOException {
<span class="line-added"> 529         return getBigInteger0(true);</span>
<span class="line-added"> 530     }</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532     private BigInteger getBigInteger0(boolean mustBePositive) throws IOException {</span>
 533         if (tag != tag_Integer)
 534             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<span class="line-modified"> 535         if (end == start) {</span>
<span class="line-added"> 536             throw new IOException(&quot;Invalid encoding: zero length Int value&quot;);</span>
<span class="line-added"> 537         }</span>
<span class="line-added"> 538         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 539         if (!allowBER &amp;&amp; (end - start &gt;= 2 &amp;&amp; (buffer[start] == 0) &amp;&amp; (buffer[start + 1] &gt;= 0))) {</span>
<span class="line-added"> 540             throw new IOException(&quot;Invalid encoding: redundant leading 0s&quot;);</span>
<span class="line-added"> 541         }</span>
<span class="line-added"> 542         return mustBePositive</span>
<span class="line-added"> 543                 ? new BigInteger(1, buffer, start, end - start)</span>
<span class="line-added"> 544                 : new BigInteger(buffer, start, end - start);</span>
 545     }
 546 
 547     /**
 548      * Returns an ASN.1 ENUMERATED value.
 549      *
 550      * @return the integer held in this DER value.
 551      */
 552     public int getEnumerated() throws IOException {
 553         if (tag != tag_Enumerated) {
 554             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
 555                                   + tag);
 556         }
<span class="line-modified"> 557         // TODO</span>
<span class="line-added"> 558         return new BigInteger(1, buffer, start, end - start).intValue();</span>
 559     }
 560 
 561     /**
 562      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
 563      *
 564      * @return the bit string held in this value
 565      */
 566     public byte[] getBitString() throws IOException {
<span class="line-modified"> 567         return getBitString(false);</span>




 568     }
 569 
 570     /**
 571      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
 572      *
 573      * @return a BitArray representing the bit string held in this value
 574      */
 575     public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified"> 576         return getUnalignedBitString(false);</span>




 577     }
 578 
 579     /**
 580      * Returns the name component as a Java string, regardless of its
 581      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
 582      */
 583     // TBD: Need encoder for UniversalString before it can be handled.
 584     public String getAsString() throws IOException {
 585         if (tag == tag_UTF8String)
 586             return getUTF8String();
 587         else if (tag == tag_PrintableString)
 588             return getPrintableString();
 589         else if (tag == tag_T61String)
 590             return getT61String();
 591         else if (tag == tag_IA5String)
 592             return getIA5String();
<span class="line-modified"> 593         else if (tag == tag_UniversalString)</span>

 594           return getUniversalString();

 595         else if (tag == tag_BMPString)
 596             return getBMPString();
 597         else if (tag == tag_GeneralString)
 598             return getGeneralString();
 599         else
 600             return null;
 601     }
 602 
 603     /**
 604      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 605      * based on the parameter.  The bit string must be byte-aligned.
 606      *
 607      * @param tagImplicit if true, the tag is assumed implicit.
 608      * @return the bit string held in this value
 609      */
 610     public byte[] getBitString(boolean tagImplicit) throws IOException {
 611         if (!tagImplicit) {
<span class="line-modified"> 612             if (tag != tag_BitString) {</span>
 613                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified"> 614                         + tag);</span>
 615             }
<span class="line-modified"> 616         }</span>
<span class="line-added"> 617         if (end == start) {</span>
<span class="line-added"> 618             throw new IOException(&quot;No padding&quot;);</span>
<span class="line-added"> 619         }</span>
<span class="line-added"> 620         int numOfPadBits = buffer[start];</span>
<span class="line-added"> 621         if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {</span>
<span class="line-added"> 622             throw new IOException(&quot;Invalid number of padding bits&quot;);</span>
<span class="line-added"> 623         }</span>
<span class="line-added"> 624         // minus the first byte which indicates the number of padding bits</span>
<span class="line-added"> 625         byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);</span>
<span class="line-added"> 626         if (numOfPadBits != 0) {</span>
<span class="line-added"> 627             // get rid of the padding bits</span>
<span class="line-added"> 628             retval[end - start - 2] &amp;= (0xff &lt;&lt; numOfPadBits);</span>
<span class="line-added"> 629         }</span>
<span class="line-added"> 630         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 631         return retval;</span>
 632     }
 633 
 634     /**
 635      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 636      * based on the parameter.  The bit string need not be byte-aligned.
 637      *
 638      * @param tagImplicit if true, the tag is assumed implicit.
 639      * @return the bit string held in this value
 640      */
 641     public BitArray getUnalignedBitString(boolean tagImplicit)
<span class="line-modified"> 642             throws IOException {</span>
 643         if (!tagImplicit) {
<span class="line-modified"> 644             if (tag != tag_BitString) {</span>
 645                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified"> 646                         + tag);</span>
 647             }
<span class="line-modified"> 648         }</span>
<span class="line-added"> 649         if (end == start) {</span>
<span class="line-added"> 650             throw new IOException(&quot;No padding&quot;);</span>
<span class="line-added"> 651         }</span>
<span class="line-added"> 652         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 653         if (end == start + 1) {</span>
<span class="line-added"> 654             return new BitArray(0);</span>
<span class="line-added"> 655         } else {</span>
<span class="line-added"> 656             int numOfPadBits = buffer[start];</span>
<span class="line-added"> 657             if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {</span>
<span class="line-added"> 658                 throw new IOException(&quot;Invalid number of padding bits&quot;);</span>
<span class="line-added"> 659             }</span>
<span class="line-added"> 660             return new BitArray((end - start - 1) * 8 - numOfPadBits,</span>
<span class="line-added"> 661                     Arrays.copyOfRange(buffer, start + 1, end));</span>
<span class="line-added"> 662         }</span>
 663     }
 664 
 665     /**
 666      * Helper routine to return all the bytes contained in the
 667      * DerInputStream associated with this object.
 668      */
 669     public byte[] getDataBytes() throws IOException {
<span class="line-modified"> 670         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified"> 671         return Arrays.copyOfRange(buffer, start, end);</span>




 672     }
 673 
<span class="line-added"> 674     private String readString0(Charset cs) {</span>
<span class="line-added"> 675         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 676         return new String(buffer, start, end - start, cs);</span>
<span class="line-added"> 677     }</span>
 678     /**
 679      * Returns an ASN.1 STRING value
 680      *
 681      * @return the printable string held in this value
 682      */
 683     public String getPrintableString()
 684     throws IOException {
 685         if (tag != tag_PrintableString)
 686             throw new IOException(
 687                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
 688 
<span class="line-modified"> 689         return readString0(US_ASCII);</span>
 690     }
 691 
 692     /**
 693      * Returns an ASN.1 T61 (Teletype) STRING value
 694      *
 695      * @return the teletype string held in this value
 696      */
 697     public String getT61String() throws IOException {
 698         if (tag != tag_T61String)
 699             throw new IOException(
 700                 &quot;DerValue.getT61String, not T61 &quot; + tag);
 701 
<span class="line-modified"> 702         return readString0(ISO_8859_1);</span>
 703     }
 704 
 705     /**
 706      * Returns an ASN.1 IA5 (ASCII) STRING value
 707      *
 708      * @return the ASCII string held in this value
 709      */
 710     public String getIA5String() throws IOException {
 711         if (tag != tag_IA5String)
 712             throw new IOException(
 713                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
 714 
<span class="line-modified"> 715         return readString0(US_ASCII);</span>
 716     }
 717 
 718     /**
 719      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
 720      *
 721      * @return a string corresponding to the encoded BMPString held in
 722      * this value
 723      */
 724     public String getBMPString() throws IOException {
 725         if (tag != tag_BMPString)
 726             throw new IOException(
 727                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
 728 
 729         // BMPString is the same as Unicode in big endian, unmarked
 730         // format.
<span class="line-modified"> 731         return readString0(UTF_16BE);</span>
 732     }
 733 
 734     /**
 735      * Returns the ASN.1 UTF-8 STRING value as a Java String.
 736      *
 737      * @return a string corresponding to the encoded UTF8String held in
 738      * this value
 739      */
 740     public String getUTF8String() throws IOException {
 741         if (tag != tag_UTF8String)
 742             throw new IOException(
 743                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
 744 
<span class="line-modified"> 745         return readString0(UTF_8);</span>
 746     }
 747 
 748     /**
 749      * Returns the ASN.1 GENERAL STRING value as a Java String.
 750      *
 751      * @return a string corresponding to the encoded GeneralString held in
 752      * this value
 753      */
 754     public String getGeneralString() throws IOException {
 755         if (tag != tag_GeneralString)
 756             throw new IOException(
 757                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
 758 
<span class="line-modified"> 759         return readString0(US_ASCII);</span>
<span class="line-added"> 760     }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762     /**</span>
<span class="line-added"> 763      * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.</span>
<span class="line-added"> 764      *</span>
<span class="line-added"> 765      * @return a string corresponding to the encoded UniversalString held in</span>
<span class="line-added"> 766      * this value or an empty string if UTF_32BE is not a supported character</span>
<span class="line-added"> 767      * set.</span>
<span class="line-added"> 768      */</span>
<span class="line-added"> 769     public String getUniversalString() throws IOException {</span>
<span class="line-added"> 770         if (tag != tag_UniversalString)</span>
<span class="line-added"> 771             throw new IOException(</span>
<span class="line-added"> 772                 &quot;DerValue.getUniversalString, not UniversalString &quot; + tag);</span>
<span class="line-added"> 773         try {</span>
<span class="line-added"> 774             Charset cset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added"> 775             return readString0(cset);</span>
<span class="line-added"> 776         } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {</span>
<span class="line-added"> 777             return &quot;&quot;;</span>
<span class="line-added"> 778         }</span>
<span class="line-added"> 779     }</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781     private Date getTime(int len, boolean generalized) throws IOException {</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783         /*</span>
<span class="line-added"> 784          * UTC time encoded as ASCII chars:</span>
<span class="line-added"> 785          *       YYMMDDhhmmZ</span>
<span class="line-added"> 786          *       YYMMDDhhmmssZ</span>
<span class="line-added"> 787          *       YYMMDDhhmm+hhmm</span>
<span class="line-added"> 788          *       YYMMDDhhmm-hhmm</span>
<span class="line-added"> 789          *       YYMMDDhhmmss+hhmm</span>
<span class="line-added"> 790          *       YYMMDDhhmmss-hhmm</span>
<span class="line-added"> 791          * UTC Time is broken in storing only two digits of year.</span>
<span class="line-added"> 792          * If YY &lt; 50, we assume 20YY;</span>
<span class="line-added"> 793          * if YY &gt;= 50, we assume 19YY, as per RFC 5280.</span>
<span class="line-added"> 794          *</span>
<span class="line-added"> 795          * Generalized time has a four-digit year and allows any</span>
<span class="line-added"> 796          * precision specified in ISO 8601. However, for our purposes,</span>
<span class="line-added"> 797          * we will only allow the same format as UTC time, except that</span>
<span class="line-added"> 798          * fractional seconds (millisecond precision) are supported.</span>
<span class="line-added"> 799          */</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801         int year, month, day, hour, minute, second, millis;</span>
<span class="line-added"> 802         String type = null;</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804         int pos = start;</span>
<span class="line-added"> 805         if (generalized) {</span>
<span class="line-added"> 806             type = &quot;Generalized&quot;;</span>
<span class="line-added"> 807             year = 1000 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 808             year += 100 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 809             year += 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 810             year += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 811             len -= 2; // For the two extra YY</span>
<span class="line-added"> 812         } else {</span>
<span class="line-added"> 813             type = &quot;UTC&quot;;</span>
<span class="line-added"> 814             year = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 815             year += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817             if (year &lt; 50)              // origin 2000</span>
<span class="line-added"> 818                 year += 2000;</span>
<span class="line-added"> 819             else</span>
<span class="line-added"> 820                 year += 1900;   // origin 1900</span>
<span class="line-added"> 821         }</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823         month = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 824         month += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826         day = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 827         day += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 828 </span>
<span class="line-added"> 829         hour = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 830         hour += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832         minute = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 833         minute += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 834 </span>
<span class="line-added"> 835         len -= 10; // YYMMDDhhmm</span>
<span class="line-added"> 836 </span>
<span class="line-added"> 837         /*</span>
<span class="line-added"> 838          * We allow for non-encoded seconds, even though the</span>
<span class="line-added"> 839          * IETF-PKIX specification says that the seconds should</span>
<span class="line-added"> 840          * always be encoded even if it is zero.</span>
<span class="line-added"> 841          */</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843         millis = 0;</span>
<span class="line-added"> 844         if (len &gt; 2) {</span>
<span class="line-added"> 845             second = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 846             second += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 847             len -= 2;</span>
<span class="line-added"> 848             // handle fractional seconds (if present)</span>
<span class="line-added"> 849             if (buffer[pos] == &#39;.&#39; || buffer[pos] == &#39;,&#39;) {</span>
<span class="line-added"> 850                 len --;</span>
<span class="line-added"> 851                 pos++;</span>
<span class="line-added"> 852                 int precision = 0;</span>
<span class="line-added"> 853                 while (buffer[pos] != &#39;Z&#39; &amp;&amp;</span>
<span class="line-added"> 854                         buffer[pos] != &#39;+&#39; &amp;&amp;</span>
<span class="line-added"> 855                         buffer[pos] != &#39;-&#39;) {</span>
<span class="line-added"> 856                     // Validate all digits in the fractional part but</span>
<span class="line-added"> 857                     // store millisecond precision only</span>
<span class="line-added"> 858                     int thisDigit = Character.digit((char)buffer[pos], 10);</span>
<span class="line-added"> 859                     precision++;</span>
<span class="line-added"> 860                     pos++;</span>
<span class="line-added"> 861                     switch (precision) {</span>
<span class="line-added"> 862                         case 1:</span>
<span class="line-added"> 863                             millis += 100 * thisDigit;</span>
<span class="line-added"> 864                             break;</span>
<span class="line-added"> 865                         case 2:</span>
<span class="line-added"> 866                             millis += 10 * thisDigit;</span>
<span class="line-added"> 867                             break;</span>
<span class="line-added"> 868                         case 3:</span>
<span class="line-added"> 869                             millis += thisDigit;</span>
<span class="line-added"> 870                             break;</span>
<span class="line-added"> 871                     }</span>
<span class="line-added"> 872                 }</span>
<span class="line-added"> 873                 if (precision == 0) {</span>
<span class="line-added"> 874                     throw new IOException(&quot;Parse &quot; + type +</span>
<span class="line-added"> 875                             &quot; time, empty fractional part&quot;);</span>
<span class="line-added"> 876                 }</span>
<span class="line-added"> 877                 len -= precision;</span>
<span class="line-added"> 878             }</span>
<span class="line-added"> 879         } else</span>
<span class="line-added"> 880             second = 0;</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882         if (month == 0 || day == 0</span>
<span class="line-added"> 883                 || month &gt; 12 || day &gt; 31</span>
<span class="line-added"> 884                 || hour &gt;= 24 || minute &gt;= 60 || second &gt;= 60)</span>
<span class="line-added"> 885             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid format&quot;);</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887         /*</span>
<span class="line-added"> 888          * Generalized time can theoretically allow any precision,</span>
<span class="line-added"> 889          * but we&#39;re not supporting that.</span>
<span class="line-added"> 890          */</span>
<span class="line-added"> 891         CalendarSystem gcal = CalendarSystem.getGregorianCalendar();</span>
<span class="line-added"> 892         CalendarDate date = gcal.newCalendarDate(null); // no time zone</span>
<span class="line-added"> 893         date.setDate(year, month, day);</span>
<span class="line-added"> 894         date.setTimeOfDay(hour, minute, second, millis);</span>
<span class="line-added"> 895         long time = gcal.getTime(date);</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897         /*</span>
<span class="line-added"> 898          * Finally, &quot;Z&quot; or &quot;+hhmm&quot; or &quot;-hhmm&quot; ... offsets change hhmm</span>
<span class="line-added"> 899          */</span>
<span class="line-added"> 900         if (! (len == 1 || len == 5))</span>
<span class="line-added"> 901             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid offset&quot;);</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903         int hr, min;</span>
<span class="line-added"> 904 </span>
<span class="line-added"> 905         switch (buffer[pos++]) {</span>
<span class="line-added"> 906             case &#39;+&#39;:</span>
<span class="line-added"> 907                 hr = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 908                 hr += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 909                 min = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 910                 min += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 911 </span>
<span class="line-added"> 912                 if (hr &gt;= 24 || min &gt;= 60)</span>
<span class="line-added"> 913                     throw new IOException(&quot;Parse &quot; + type + &quot; time, +hhmm&quot;);</span>
<span class="line-added"> 914 </span>
<span class="line-added"> 915                 time -= ((hr * 60) + min) * 60 * 1000;</span>
<span class="line-added"> 916                 break;</span>
<span class="line-added"> 917 </span>
<span class="line-added"> 918             case &#39;-&#39;:</span>
<span class="line-added"> 919                 hr = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 920                 hr += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 921                 min = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 922                 min += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924                 if (hr &gt;= 24 || min &gt;= 60)</span>
<span class="line-added"> 925                     throw new IOException(&quot;Parse &quot; + type + &quot; time, -hhmm&quot;);</span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927                 time += ((hr * 60) + min) * 60 * 1000;</span>
<span class="line-added"> 928                 break;</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930             case &#39;Z&#39;:</span>
<span class="line-added"> 931                 break;</span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933             default:</span>
<span class="line-added"> 934                 throw new IOException(&quot;Parse &quot; + type + &quot; time, garbage offset&quot;);</span>
<span class="line-added"> 935         }</span>
<span class="line-added"> 936         return new Date(time);</span>
<span class="line-added"> 937     }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939     public void getNull() throws IOException {</span>
<span class="line-added"> 940         if (tag != tag_Null) {</span>
<span class="line-added"> 941             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943         if (end != start) {</span>
<span class="line-added"> 944             throw new IOException(&quot;DER UTC Time length error&quot;);</span>
<span class="line-added"> 945         }</span>
 946     }
 947 
 948     /**
 949      * Returns a Date if the DerValue is UtcTime.
 950      *
 951      * @return the Date held in this DER value
 952      */
 953     public Date getUTCTime() throws IOException {
 954         if (tag != tag_UtcTime) {
 955             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
 956         }
<span class="line-modified"> 957         if (end - start &lt; 11 || end - start &gt; 17)</span>
<span class="line-added"> 958             throw new IOException(&quot;DER UTC Time length error&quot;);</span>
<span class="line-added"> 959 </span>
<span class="line-added"> 960         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 961         return getTime(end - start, false);</span>
 962     }
 963 
 964     /**
 965      * Returns a Date if the DerValue is GeneralizedTime.
 966      *
 967      * @return the Date held in this DER value
 968      */
 969     public Date getGeneralizedTime() throws IOException {
 970         if (tag != tag_GeneralizedTime) {
 971             throw new IOException(
 972                 &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
 973         }
<span class="line-modified"> 974         if (end - start &lt; 13)</span>
<span class="line-added"> 975             throw new IOException(&quot;DER Generalized Time length error&quot;);</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 978         return getTime(end - start, true);</span>
 979     }
 980 
 981     /**
 982      * Bitwise equality comparison.  DER encoded values have a single
 983      * encoding, so that bitwise equality of the encoded values is an
 984      * efficient way to establish equivalence of the unencoded values.
 985      *
 986      * @param o the object being compared with this one
 987      */
 988     @Override
 989     public boolean equals(Object o) {
 990         if (this == o) {
 991             return true;
 992         }
 993         if (!(o instanceof DerValue)) {
 994             return false;
 995         }
 996         DerValue other = (DerValue) o;
 997         if (tag != other.tag) {
 998             return false;
 999         }
<span class="line-modified">1000         if (buffer == other.buffer &amp;&amp; start == other.start &amp;&amp; end == other.end) {</span>
1001             return true;
1002         }
<span class="line-modified">1003         return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);</span>


















1004     }
1005 
1006     /**
1007      * Returns a printable representation of the value.
1008      *
1009      * @return printable representation of the value
1010      */
1011     @Override
1012     public String toString() {
<span class="line-modified">1013         return String.format(&quot;DerValue(%02x, %s, %d, 5d)&quot;,</span>
<span class="line-modified">1014                 0xff &amp; tag, buffer, start, end);</span>















1015     }
1016 
1017     /**
1018      * Returns a DER-encoded value, such that if it&#39;s passed to the
1019      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
1020      *
1021      * @return DER-encoded value, including tag and length.
1022      */
1023     public byte[] toByteArray() throws IOException {
1024         DerOutputStream out = new DerOutputStream();

1025         encode(out);
<span class="line-modified">1026         data.pos = data.start; // encode go last, should go back</span>
1027         return out.toByteArray();
1028     }
1029 
1030     /**
1031      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
1032      * to return a DER stream of the members of the set or sequence.
1033      * This operation is not supported for primitive types such as
1034      * integers or bit strings.
1035      */
1036     public DerInputStream toDerInputStream() throws IOException {
1037         if (tag == tag_Sequence || tag == tag_Set)
<span class="line-modified">1038             return data;</span>
1039         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
1040     }
1041 
1042     /**
1043      * Get the length of the encoded value.
1044      */
1045     public int length() {
<span class="line-modified">1046         return end - start;</span>
1047     }
1048 
1049     /**
1050      * Determine if a character is one of the permissible characters for
1051      * PrintableString:
1052      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
1053      * plus sign, comma, hyphen, period, slash, colon, equals sign,
1054      * and question mark.
1055      *
1056      * Characters that are *not* allowed in PrintableString include
1057      * exclamation point, quotation mark, number sign, dollar sign,
1058      * percent sign, ampersand, asterisk, semicolon, less than sign,
1059      * greater than sign, at sign, left and right square brackets,
1060      * backslash, circumflex (94), underscore, back quote (96),
1061      * left and right curly brackets, vertical line, tilde,
1062      * and the control codes (0-31 and 127).
1063      *
1064      * This list is based on X.680 (the ASN.1 spec).
1065      */
1066     public static boolean isPrintableStringChar(char ch) {
</pre>
<hr />
<pre>
1107 
1108     /**
1109      * Set the tag of the attribute. Commonly used to reset the
1110      * tag value used for IMPLICIT encodings.
1111      *
1112      * @param tag the tag value
1113      */
1114     public void resetTag(byte tag) {
1115         this.tag = tag;
1116     }
1117 
1118     /**
1119      * Returns a hashcode for this DerValue.
1120      *
1121      * @return a hashcode for this DerValue.
1122      */
1123     @Override
1124     public int hashCode() {
1125         return toString().hashCode();
1126     }
<span class="line-added">1127 </span>
<span class="line-added">1128     public DerValue[] subs(byte expectedTag) throws IOException {</span>
<span class="line-added">1129         if (expectedTag != 0 &amp;&amp; expectedTag != tag) {</span>
<span class="line-added">1130             throw new IOException(&quot;Not constructed&quot;);</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         List&lt;DerValue&gt; result = new ArrayList&lt;&gt;();</span>
<span class="line-added">1133         DerInputStream dis = new DerInputStream(this);</span>
<span class="line-added">1134         while (dis.available() &gt; 0) {</span>
<span class="line-added">1135             result.add(dis.getDerValue());</span>
<span class="line-added">1136         }</span>
<span class="line-added">1137         return result.toArray(new DerValue[result.size()]);</span>
<span class="line-added">1138     }</span>
1139 }
</pre>
</td>
</tr>
</table>
<center><a href="DerInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /**
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.util;
  27 
  28 import sun.util.calendar.CalendarDate;
  29 import sun.util.calendar.CalendarSystem;
  30 
  31 import java.io.*;
  32 import java.math.BigInteger;
  33 import java.nio.charset.Charset;
  34 import java.nio.charset.IllegalCharsetNameException;
  35 import java.nio.charset.UnsupportedCharsetException;
  36 import java.util.*;
  37 
  38 import static java.nio.charset.StandardCharsets.*;
  39 
  40 /**
  41  * Represents a single DER-encoded value.  DER encoding rules are a subset
  42  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
  43  * (&quot;Definite&quot; encoding) to encode any given value.
  44  *
  45  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
  46  * class represents such tagged values as they have been read (or constructed),
  47  * and provides structured access to the encoded data.
  48  *
  49  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
  50  * data encodings which are defined.  That subset is sufficient for parsing
  51  * most X.509 certificates, and working with selected additional formats
  52  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
  53  *
  54  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
  55  * and RFC 5280, section 8, we assume that this kind of string will contain
  56  * ISO-8859-1 characters only.
  57  *
  58  *
  59  * @author David Brownell
  60  * @author Amit Kapoor
  61  * @author Hemma Prafullchandra
  62  */
  63 public class DerValue {
  64 
  65     /** The tag class types */
  66     public static final byte TAG_UNIVERSAL = (byte)0x000;
  67     public static final byte TAG_APPLICATION = (byte)0x040;
  68     public static final byte TAG_CONTEXT = (byte)0x080;
  69     public static final byte TAG_PRIVATE = (byte)0x0c0;
  70 
  71     /*
  72      * The type starts at the first byte of the encoding, and
  73      * is one of these tag_* values.  That may be all the type
  74      * data that is needed.
  75      */
  76 
  77     /*
  78      * These tags are the &quot;universal&quot; tags ... they mean the same
  79      * in all contexts.  (Mask with 0x1f -- five bits.)
  80      */
  81 
  82     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
  83     public static final byte    tag_Boolean = 0x01;
  84 
  85     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
  86     public static final byte    tag_Integer = 0x02;
  87 
  88     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
  89     public static final byte    tag_BitString = 0x03;
  90 
  91     /** Tag value indicating an ASN.1 &quot;OCTET STRING&quot; value. */
  92     public static final byte    tag_OctetString = 0x04;
  93 
  94     /** Tag value indicating an ASN.1 &quot;NULL&quot; value. */
  95     public static final byte    tag_Null = 0x05;
  96 
  97     /** Tag value indicating an ASN.1 &quot;OBJECT IDENTIFIER&quot; value. */
  98     public static final byte    tag_ObjectId = 0x06;
  99 
 100     /** Tag value including an ASN.1 &quot;ENUMERATED&quot; value */
 101     public static final byte    tag_Enumerated = 0x0A;
 102 
 103     /** Tag value indicating an ASN.1 &quot;UTF8String&quot; value. */
 104     public static final byte    tag_UTF8String = 0x0C;
 105 
 106     /** Tag value including a &quot;printable&quot; string */
 107     public static final byte    tag_PrintableString = 0x13;
 108 
 109     /** Tag value including a &quot;teletype&quot; string */
 110     public static final byte    tag_T61String = 0x14;
 111 
 112     /** Tag value including an ASCII string */
 113     public static final byte    tag_IA5String = 0x16;
 114 
 115     /** Tag value indicating an ASN.1 &quot;UTCTime&quot; value. */
 116     public static final byte    tag_UtcTime = 0x17;
 117 
 118     /** Tag value indicating an ASN.1 &quot;GeneralizedTime&quot; value. */
 119     public static final byte    tag_GeneralizedTime = 0x18;
 120 
 121     /** Tag value indicating an ASN.1 &quot;GenerallString&quot; value. */
 122     public static final byte    tag_GeneralString = 0x1B;
 123 
 124     /** Tag value indicating an ASN.1 &quot;UniversalString&quot; value. */
 125     public static final byte    tag_UniversalString = 0x1C;
 126 
 127     /** Tag value indicating an ASN.1 &quot;BMPString&quot; value. */
 128     public static final byte    tag_BMPString = 0x1E;
 129 
 130     // CONSTRUCTED seq/set
 131 
 132     /**
 133      * Tag value indicating an ASN.1
 134      * &quot;SEQUENCE&quot; (zero to N elements, order is significant).
 135      */
 136     public static final byte    tag_Sequence = 0x30;
 137 
 138     /**
 139      * Tag value indicating an ASN.1
 140      * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
 141      */
 142     public static final byte    tag_SequenceOf = 0x30;
 143 
 144     /**
 145      * Tag value indicating an ASN.1
 146      * &quot;SET&quot; (zero to N members, order does not matter).
 147      */
 148     public static final byte    tag_Set = 0x31;
 149 
 150     /**
 151      * Tag value indicating an ASN.1
 152      * &quot;SET OF&quot; (one to N members, order does not matter).
 153      */
 154     public static final byte    tag_SetOf = 0x31;
 155 
 156     // Instance fields start here:
 157     public /*final*/ byte tag;
 158     final byte[] buffer;
 159     final int start;
 160     final int end;
 161     public final boolean allowBER;
 162 
 163     final public DerInputStream data;
 164 
 165     /*
 166      * These values are the high order bits for the other kinds of tags.
 167      */
 168 
 169     /**
 170      * Returns true if the tag class is UNIVERSAL.
 171      */
 172     public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }
 173 
 174     /**
 175      * Returns true if the tag class is APPLICATION.
 176      */
 177     public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }
 178 
 179     /**
 180      * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
 181      * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
 182      */
 183     public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }
 184 
 185     /**
 186      * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.
 187      */
 188     public boolean isContextSpecific(byte cntxtTag) {
 189         if (!isContextSpecific()) {
 190             return false;
 191         }
 192         return ((tag &amp; 0x01f) == cntxtTag);
 193     }
 194 
 195     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
 196 
 197     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
 198     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
 199 
 200     /**
 201      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
 202      */
 203     public boolean isConstructed(byte constructedTag) {
 204         if (!isConstructed()) {
 205             return false;
 206         }
 207         return ((tag &amp; 0x01f) == constructedTag);
 208     }
 209 
 210     /**
 211      * Creates a PrintableString or UTF8string DER value from a string
 212      */
 213     public DerValue(String value) {
 214         this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,
 215                 value);
 216     }
 217 
 218     public static boolean isPrintableString(String value) {
 219         for (int i = 0; i &lt; value.length(); i++) {
 220             if (!isPrintableStringChar(value.charAt(i))) {
 221                 return false;
 222             }
 223         }
 224         return true;
 225     }
 226 
 227     /**
 228      * Creates a string type DER value from a String object
 229      * @param stringTag the tag for the DER value to create
 230      * @param value the String object to use for the DER value
 231      */
 232     public DerValue(byte stringTag, String value) {
 233         final Charset charset;
 234 
 235         tag = stringTag;
 236 
 237         switch (stringTag) {
 238             case tag_PrintableString:
 239             case tag_IA5String:
 240             case tag_GeneralString:
 241                 charset = US_ASCII;
 242                 break;
 243             case tag_T61String:
 244                 charset = ISO_8859_1;
 245                 break;
 246             case tag_BMPString:
 247                 charset = UTF_16BE;
 248                 break;
 249             case tag_UTF8String:
 250                 charset = UTF_8;
 251                 break;
 252             case tag_UniversalString:
 253                 charset = Charset.forName(&quot;UTF_32BE&quot;);
 254                 break;
 255             default:
 256                 throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
 257         }
 258 
 259         buffer = value.getBytes(charset);
 260         start = 0;
 261         end = buffer.length;
 262         allowBER = false;
 263         this.data = new DerInputStream(this);
 264     }
 265 
 266     // Creates a DerValue from a tag and some DER-encoded data w/ additional
 267     // arg to control whether DER checks are enforced.
 268     DerValue(byte tag, byte[] buffer, boolean allowBER) {
 269         this(tag, buffer, 0, buffer.length, allowBER);
 270     }
 271 
 272     DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {
 273         this.tag = tag;
 274         this.buffer = buffer;
 275         this.start = start;
 276         this.end = end;
 277         this.allowBER = allowBER;
 278         this.data = new DerInputStream(this);
 279     }
 280 
 281     /**
 282      * Creates a DerValue from a tag and some DER-encoded data.
 283      *
 284      * @param tag the DER type tag
 285      * @param buffer the DER-encoded data
 286      */
 287     public DerValue(byte tag, byte[] buffer) {
 288         this(tag, buffer.clone(), true);
 289     }
 290 
 291     // Get an ASN.1/DER encoded datum from a buffer w/ additional
 292     // arg to control whether DER checks are enforced.
 293     DerValue(byte[] buf, boolean allowBER) throws IOException {
 294         this(buf, 0, buf.length, allowBER);
 295     }
 296 
 297     /**
 298      * Get an ASN.1/DER encoded datum from a buffer.  The
 299      * entire buffer must hold exactly one datum, including
 300      * its tag and length.
 301      *
 302      * @param buf buffer holding a single DER-encoded datum.
 303      */
 304     public DerValue(byte[] buf) throws IOException {
 305         this(buf.clone(), true);
 306     }
 307 
 308     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
 309     // arg to control whether DER checks are enforced.
 310     DerValue(byte[] buf, int offset, int len, boolean allowBER) throws IOException {
 311         this(buf, offset, len, allowBER, true);
 312     }
 313 
 314     DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean noMore) throws IOException {
 315         if (len &lt; 2) {
 316             throw new IOException(&quot;Too short &quot; + len);
 317         }
 318         int pos = offset;
 319         tag = buf[pos++];
 320         int length;
 321         int lenByte = buf[pos++];
 322 
 323         if (lenByte == (byte)0x80) {
 324             length = -1;
 325         } else if ((lenByte &amp; 0x080) == 0x00) { // short form, 1 byte datum
 326             length = lenByte;
 327         } else {                     // long form or indefinite
 328             lenByte &amp;= 0x07f;
 329             if (lenByte == 0) {
 330                 length = -1;
 331             } else if (lenByte &lt; 0 || lenByte &gt; 4) {
 332                 throw new IOException(&quot;incorrect DER encoding&quot;);
 333             } else {
 334                 if (len &lt; 2 + lenByte) {
 335                     throw new IOException(&quot;incorrect DER encoding&quot;);
 336                 }
 337                 length = 0x0ff &amp; buf[pos++];
 338                 lenByte--;
 339                 if (length == 0 &amp;&amp; !allowBER) {
 340                     // DER requires length value be encoded in minimum number of bytes
 341                     throw new IOException(&quot;Redundant length bytes found&quot;);
 342                 }
 343                 while (lenByte-- &gt; 0) {
 344                     length &lt;&lt;= 8;
 345                     length += 0x0ff &amp; buf[pos++];
 346                 }
 347                 if (length &lt; 0) {
 348                     throw new IOException(&quot;Invalid length bytes&quot;);
 349                 } else if (length &lt;= 127 &amp;&amp; !allowBER) {
 350                     throw new IOException(&quot;Should use short form for length&quot;);
 351                 }
 352             }
 353         }
 354         if (length == -1) { // indefinite length encoding found
 355             if (!allowBER) {
 356                 throw new IOException
 357                         (&quot;Indefinite length encoding not supported&quot;);
 358             }
 359             InputStream in = new ByteArrayInputStream(
 360                     DerIndefLenConverter.convertStream(
 361                             new ByteArrayInputStream(buf, pos, len - (pos - offset)), (byte)lenByte, tag));
 362             if (tag != in.read())
 363                 throw new IOException
 364                         (&quot;Indefinite length encoding not supported&quot;);
 365             length = DerInputStream.getDefiniteLength(in);
 366             this.buffer = IOUtils.readExactlyNBytes(in, length);
 367             this.start = 0;
 368             this.end = length;
 369             this.allowBER = true;
 370         } else {
 371             if (len - length &lt; pos - offset) {
 372                 throw new EOFException(&quot;Too little&quot;);
 373             }
 374             if (len - length &gt; pos - offset &amp;&amp; noMore) {
 375                 throw new IOException(&quot;Too much&quot;);
 376             }
 377             this.buffer = buf;
 378             this.start = pos;
 379             this.end = pos + length;
 380             this.allowBER = allowBER;
 381         }
 382         this.data = new DerInputStream(this);
 383     }
 384 
 385     // Get an ASN1/DER encoded datum from an input stream w/ additional
 386     // arg to control whether DER checks are enforced.
 387     DerValue(InputStream in, boolean allowBER) throws IOException {
 388         this.tag = (byte)in.read();
 389         byte lenByte = (byte)in.read();
 390         int length = DerInputStream.getLength(lenByte, in);
 391         if (length == -1) { // indefinite length encoding found
 392             in = new ByteArrayInputStream(
 393                     DerIndefLenConverter.convertStream(in, lenByte, tag));
 394             if (tag != in.read())
 395                 throw new IOException
 396                         (&quot;Indefinite length encoding not supported&quot;);
 397             length = DerInputStream.getDefiniteLength(in);
 398         }
 399         this.buffer = IOUtils.readExactlyNBytes(in, length);
 400         this.start = 0;
 401         this.end = length;
 402         this.allowBER = allowBER;
 403         this.data = new DerInputStream(this);
 404         System.out.println(this);
 405     }
 406 
 407     /**
 408      * Get an ASN1/DER encoded datum from an input stream.  The
 409      * stream may have additional data following the encoded datum.
 410      * In case of indefinite length encoded datum, the input stream
 411      * must hold only one datum.
 412      *
 413      * @param in the input stream holding a single DER datum,
 414      *  which may be followed by additional data
 415      */
 416     public DerValue(InputStream in) throws IOException {
 417         this(in, true);
 418     }
 419 
 420     /**
 421      * Encode an ASN1/DER encoded datum onto a DER output stream.
 422      */
 423     public void encode(DerOutputStream out) throws IOException {
 424         out.write(tag);
 425         out.putLength(end - start);
 426         out.write(buffer, start, end - start);
 427         data.pos = data.end; // Compatibility. Reach end.
 428     }
 429 
 430     public final DerInputStream getData() {
 431         return data;
 432     }
 433 
 434     public final byte getTag() {
 435         return tag;
 436     }
 437 
 438     /**
 439      * Returns an ASN.1 BOOLEAN
 440      *
 441      * @return the boolean held in this DER value
 442      */
 443     public boolean getBoolean() throws IOException {
 444         if (tag != tag_Boolean) {
 445             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
 446         }
 447         if (end - start != 1) {
 448             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
 449                                         + (end - start));
 450         }
 451         data.pos = data.end; // Compatibility. Reach end.
 452         return buffer[start] != 0;
 453     }
 454 
 455     /**
 456      * Returns an ASN.1 OBJECT IDENTIFIER.
 457      *
 458      * @return the OID held in this DER value
 459      */
 460     public ObjectIdentifier getOID() throws IOException {
 461         if (tag != tag_ObjectId)
 462             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
 463         data.pos = data.end; // Compatibility. Reach end.
 464         return new ObjectIdentifier(buffer, start, end);
 465     }
 466 
 467     /**
 468      * Returns an ASN.1 OCTET STRING
 469      *
 470      * @return the octet string held in this DER value
 471      */
 472     public byte[] getOctetString() throws IOException {
 473 
 474         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
 475             throw new IOException(
 476                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
 477         }
 478         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
 479         // known bug that it returns -1 instead of 0.
 480         if (end - start == 0) {
 481             return new byte[0];
 482         }
 483 
 484         data.pos = data.end; // Compatibility. Reach end.
 485         if (!isConstructed()) {
 486             return Arrays.copyOfRange(buffer, start, end);
 487         } else {
 488             ByteArrayOutputStream bout = new ByteArrayOutputStream();
 489             for (DerValue dv : new DerInputStream(this)) {
 490                 bout.write(dv.getOctetString());
 491             }
 492             return bout.toByteArray();
 493         }
 494     }
 495 
 496     /**
 497      * Returns an ASN.1 INTEGER value as an integer.
 498      *
 499      * @return the integer held in this DER value.
 500      */
 501     public int getInteger() throws IOException {
 502         BigInteger result = getBigInteger();
 503         if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0) {
 504             throw new IOException(&quot;Integer below minimum valid value&quot;);
 505         }
 506         if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {
 507             throw new IOException(&quot;Integer exceeds maximum valid value&quot;);
 508         }
 509         return result.intValue();
 510     }
 511 
 512     /**
 513      * Returns an ASN.1 INTEGER value as a BigInteger.
 514      *
 515      * @return the integer held in this DER value as a BigInteger.
 516      */
 517     public BigInteger getBigInteger() throws IOException {
 518         return getBigInteger0(false);
 519     }
 520 
 521     /**
 522      * Returns an ASN.1 INTEGER value as a positive BigInteger.
 523      * This is just to deal with implementations that incorrectly encode
 524      * some values as negative.
 525      *
 526      * @return the integer held in this DER value as a BigInteger.
 527      */
 528     public BigInteger getPositiveBigInteger() throws IOException {
 529         return getBigInteger0(true);
 530     }
 531 
 532     private BigInteger getBigInteger0(boolean mustBePositive) throws IOException {
 533         if (tag != tag_Integer)
 534             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
 535         if (end == start) {
 536             throw new IOException(&quot;Invalid encoding: zero length Int value&quot;);
 537         }
 538         data.pos = data.end; // Compatibility. Reach end.
 539         if (!allowBER &amp;&amp; (end - start &gt;= 2 &amp;&amp; (buffer[start] == 0) &amp;&amp; (buffer[start + 1] &gt;= 0))) {
 540             throw new IOException(&quot;Invalid encoding: redundant leading 0s&quot;);
 541         }
 542         return mustBePositive
 543                 ? new BigInteger(1, buffer, start, end - start)
 544                 : new BigInteger(buffer, start, end - start);
 545     }
 546 
 547     /**
 548      * Returns an ASN.1 ENUMERATED value.
 549      *
 550      * @return the integer held in this DER value.
 551      */
 552     public int getEnumerated() throws IOException {
 553         if (tag != tag_Enumerated) {
 554             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
 555                                   + tag);
 556         }
 557         // TODO
 558         return new BigInteger(1, buffer, start, end - start).intValue();
 559     }
 560 
 561     /**
 562      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
 563      *
 564      * @return the bit string held in this value
 565      */
 566     public byte[] getBitString() throws IOException {
 567         return getBitString(false);
 568     }
 569 
 570     /**
 571      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
 572      *
 573      * @return a BitArray representing the bit string held in this value
 574      */
 575     public BitArray getUnalignedBitString() throws IOException {
 576         return getUnalignedBitString(false);
 577     }
 578 
 579     /**
 580      * Returns the name component as a Java string, regardless of its
 581      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
 582      */
 583     // TBD: Need encoder for UniversalString before it can be handled.
 584     public String getAsString() throws IOException {
 585         if (tag == tag_UTF8String)
 586             return getUTF8String();
 587         else if (tag == tag_PrintableString)
 588             return getPrintableString();
 589         else if (tag == tag_T61String)
 590             return getT61String();
 591         else if (tag == tag_IA5String)
 592             return getIA5String();
 593         else if (tag == tag_UniversalString)
 594           return getUniversalString();
 595         else if (tag == tag_BMPString)
 596             return getBMPString();
 597         else if (tag == tag_GeneralString)
 598             return getGeneralString();
 599         else
 600             return null;
 601     }
 602 
 603     /**
 604      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 605      * based on the parameter.  The bit string must be byte-aligned.
 606      *
 607      * @param tagImplicit if true, the tag is assumed implicit.
 608      * @return the bit string held in this value
 609      */
 610     public byte[] getBitString(boolean tagImplicit) throws IOException {
 611         if (!tagImplicit) {
 612             if (tag != tag_BitString) {
 613                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
 614                         + tag);
 615             }
 616         }
 617         if (end == start) {
 618             throw new IOException(&quot;No padding&quot;);
 619         }
 620         int numOfPadBits = buffer[start];
 621         if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {
 622             throw new IOException(&quot;Invalid number of padding bits&quot;);
 623         }
 624         // minus the first byte which indicates the number of padding bits
 625         byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);
 626         if (numOfPadBits != 0) {
 627             // get rid of the padding bits
 628             retval[end - start - 2] &amp;= (0xff &lt;&lt; numOfPadBits);
 629         }
 630         data.pos = data.end; // Compatibility. Reach end.
 631         return retval;
 632     }
 633 
 634     /**
 635      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 636      * based on the parameter.  The bit string need not be byte-aligned.
 637      *
 638      * @param tagImplicit if true, the tag is assumed implicit.
 639      * @return the bit string held in this value
 640      */
 641     public BitArray getUnalignedBitString(boolean tagImplicit)
 642             throws IOException {
 643         if (!tagImplicit) {
 644             if (tag != tag_BitString) {
 645                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
 646                         + tag);
 647             }
 648         }
 649         if (end == start) {
 650             throw new IOException(&quot;No padding&quot;);
 651         }
 652         data.pos = data.end; // Compatibility. Reach end.
 653         if (end == start + 1) {
 654             return new BitArray(0);
 655         } else {
 656             int numOfPadBits = buffer[start];
 657             if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {
 658                 throw new IOException(&quot;Invalid number of padding bits&quot;);
 659             }
 660             return new BitArray((end - start - 1) * 8 - numOfPadBits,
 661                     Arrays.copyOfRange(buffer, start + 1, end));
 662         }
 663     }
 664 
 665     /**
 666      * Helper routine to return all the bytes contained in the
 667      * DerInputStream associated with this object.
 668      */
 669     public byte[] getDataBytes() throws IOException {
 670         data.pos = data.end; // Compatibility. Reach end.
 671         return Arrays.copyOfRange(buffer, start, end);
 672     }
 673 
 674     private String readString0(Charset cs) {
 675         data.pos = data.end; // Compatibility. Reach end.
 676         return new String(buffer, start, end - start, cs);
 677     }
 678     /**
 679      * Returns an ASN.1 STRING value
 680      *
 681      * @return the printable string held in this value
 682      */
 683     public String getPrintableString()
 684     throws IOException {
 685         if (tag != tag_PrintableString)
 686             throw new IOException(
 687                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
 688 
 689         return readString0(US_ASCII);
 690     }
 691 
 692     /**
 693      * Returns an ASN.1 T61 (Teletype) STRING value
 694      *
 695      * @return the teletype string held in this value
 696      */
 697     public String getT61String() throws IOException {
 698         if (tag != tag_T61String)
 699             throw new IOException(
 700                 &quot;DerValue.getT61String, not T61 &quot; + tag);
 701 
 702         return readString0(ISO_8859_1);
 703     }
 704 
 705     /**
 706      * Returns an ASN.1 IA5 (ASCII) STRING value
 707      *
 708      * @return the ASCII string held in this value
 709      */
 710     public String getIA5String() throws IOException {
 711         if (tag != tag_IA5String)
 712             throw new IOException(
 713                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
 714 
 715         return readString0(US_ASCII);
 716     }
 717 
 718     /**
 719      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
 720      *
 721      * @return a string corresponding to the encoded BMPString held in
 722      * this value
 723      */
 724     public String getBMPString() throws IOException {
 725         if (tag != tag_BMPString)
 726             throw new IOException(
 727                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
 728 
 729         // BMPString is the same as Unicode in big endian, unmarked
 730         // format.
 731         return readString0(UTF_16BE);
 732     }
 733 
 734     /**
 735      * Returns the ASN.1 UTF-8 STRING value as a Java String.
 736      *
 737      * @return a string corresponding to the encoded UTF8String held in
 738      * this value
 739      */
 740     public String getUTF8String() throws IOException {
 741         if (tag != tag_UTF8String)
 742             throw new IOException(
 743                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
 744 
 745         return readString0(UTF_8);
 746     }
 747 
 748     /**
 749      * Returns the ASN.1 GENERAL STRING value as a Java String.
 750      *
 751      * @return a string corresponding to the encoded GeneralString held in
 752      * this value
 753      */
 754     public String getGeneralString() throws IOException {
 755         if (tag != tag_GeneralString)
 756             throw new IOException(
 757                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
 758 
 759         return readString0(US_ASCII);
 760     }
 761 
 762     /**
 763      * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.
 764      *
 765      * @return a string corresponding to the encoded UniversalString held in
 766      * this value or an empty string if UTF_32BE is not a supported character
 767      * set.
 768      */
 769     public String getUniversalString() throws IOException {
 770         if (tag != tag_UniversalString)
 771             throw new IOException(
 772                 &quot;DerValue.getUniversalString, not UniversalString &quot; + tag);
 773         try {
 774             Charset cset = Charset.forName(&quot;UTF_32BE&quot;);
 775             return readString0(cset);
 776         } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {
 777             return &quot;&quot;;
 778         }
 779     }
 780 
 781     private Date getTime(int len, boolean generalized) throws IOException {
 782 
 783         /*
 784          * UTC time encoded as ASCII chars:
 785          *       YYMMDDhhmmZ
 786          *       YYMMDDhhmmssZ
 787          *       YYMMDDhhmm+hhmm
 788          *       YYMMDDhhmm-hhmm
 789          *       YYMMDDhhmmss+hhmm
 790          *       YYMMDDhhmmss-hhmm
 791          * UTC Time is broken in storing only two digits of year.
 792          * If YY &lt; 50, we assume 20YY;
 793          * if YY &gt;= 50, we assume 19YY, as per RFC 5280.
 794          *
 795          * Generalized time has a four-digit year and allows any
 796          * precision specified in ISO 8601. However, for our purposes,
 797          * we will only allow the same format as UTC time, except that
 798          * fractional seconds (millisecond precision) are supported.
 799          */
 800 
 801         int year, month, day, hour, minute, second, millis;
 802         String type = null;
 803 
 804         int pos = start;
 805         if (generalized) {
 806             type = &quot;Generalized&quot;;
 807             year = 1000 * Character.digit((char)buffer[pos++], 10);
 808             year += 100 * Character.digit((char)buffer[pos++], 10);
 809             year += 10 * Character.digit((char)buffer[pos++], 10);
 810             year += Character.digit((char)buffer[pos++], 10);
 811             len -= 2; // For the two extra YY
 812         } else {
 813             type = &quot;UTC&quot;;
 814             year = 10 * Character.digit((char)buffer[pos++], 10);
 815             year += Character.digit((char)buffer[pos++], 10);
 816 
 817             if (year &lt; 50)              // origin 2000
 818                 year += 2000;
 819             else
 820                 year += 1900;   // origin 1900
 821         }
 822 
 823         month = 10 * Character.digit((char)buffer[pos++], 10);
 824         month += Character.digit((char)buffer[pos++], 10);
 825 
 826         day = 10 * Character.digit((char)buffer[pos++], 10);
 827         day += Character.digit((char)buffer[pos++], 10);
 828 
 829         hour = 10 * Character.digit((char)buffer[pos++], 10);
 830         hour += Character.digit((char)buffer[pos++], 10);
 831 
 832         minute = 10 * Character.digit((char)buffer[pos++], 10);
 833         minute += Character.digit((char)buffer[pos++], 10);
 834 
 835         len -= 10; // YYMMDDhhmm
 836 
 837         /*
 838          * We allow for non-encoded seconds, even though the
 839          * IETF-PKIX specification says that the seconds should
 840          * always be encoded even if it is zero.
 841          */
 842 
 843         millis = 0;
 844         if (len &gt; 2) {
 845             second = 10 * Character.digit((char)buffer[pos++], 10);
 846             second += Character.digit((char)buffer[pos++], 10);
 847             len -= 2;
 848             // handle fractional seconds (if present)
 849             if (buffer[pos] == &#39;.&#39; || buffer[pos] == &#39;,&#39;) {
 850                 len --;
 851                 pos++;
 852                 int precision = 0;
 853                 while (buffer[pos] != &#39;Z&#39; &amp;&amp;
 854                         buffer[pos] != &#39;+&#39; &amp;&amp;
 855                         buffer[pos] != &#39;-&#39;) {
 856                     // Validate all digits in the fractional part but
 857                     // store millisecond precision only
 858                     int thisDigit = Character.digit((char)buffer[pos], 10);
 859                     precision++;
 860                     pos++;
 861                     switch (precision) {
 862                         case 1:
 863                             millis += 100 * thisDigit;
 864                             break;
 865                         case 2:
 866                             millis += 10 * thisDigit;
 867                             break;
 868                         case 3:
 869                             millis += thisDigit;
 870                             break;
 871                     }
 872                 }
 873                 if (precision == 0) {
 874                     throw new IOException(&quot;Parse &quot; + type +
 875                             &quot; time, empty fractional part&quot;);
 876                 }
 877                 len -= precision;
 878             }
 879         } else
 880             second = 0;
 881 
 882         if (month == 0 || day == 0
 883                 || month &gt; 12 || day &gt; 31
 884                 || hour &gt;= 24 || minute &gt;= 60 || second &gt;= 60)
 885             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid format&quot;);
 886 
 887         /*
 888          * Generalized time can theoretically allow any precision,
 889          * but we&#39;re not supporting that.
 890          */
 891         CalendarSystem gcal = CalendarSystem.getGregorianCalendar();
 892         CalendarDate date = gcal.newCalendarDate(null); // no time zone
 893         date.setDate(year, month, day);
 894         date.setTimeOfDay(hour, minute, second, millis);
 895         long time = gcal.getTime(date);
 896 
 897         /*
 898          * Finally, &quot;Z&quot; or &quot;+hhmm&quot; or &quot;-hhmm&quot; ... offsets change hhmm
 899          */
 900         if (! (len == 1 || len == 5))
 901             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid offset&quot;);
 902 
 903         int hr, min;
 904 
 905         switch (buffer[pos++]) {
 906             case &#39;+&#39;:
 907                 hr = 10 * Character.digit((char)buffer[pos++], 10);
 908                 hr += Character.digit((char)buffer[pos++], 10);
 909                 min = 10 * Character.digit((char)buffer[pos++], 10);
 910                 min += Character.digit((char)buffer[pos++], 10);
 911 
 912                 if (hr &gt;= 24 || min &gt;= 60)
 913                     throw new IOException(&quot;Parse &quot; + type + &quot; time, +hhmm&quot;);
 914 
 915                 time -= ((hr * 60) + min) * 60 * 1000;
 916                 break;
 917 
 918             case &#39;-&#39;:
 919                 hr = 10 * Character.digit((char)buffer[pos++], 10);
 920                 hr += Character.digit((char)buffer[pos++], 10);
 921                 min = 10 * Character.digit((char)buffer[pos++], 10);
 922                 min += Character.digit((char)buffer[pos++], 10);
 923 
 924                 if (hr &gt;= 24 || min &gt;= 60)
 925                     throw new IOException(&quot;Parse &quot; + type + &quot; time, -hhmm&quot;);
 926 
 927                 time += ((hr * 60) + min) * 60 * 1000;
 928                 break;
 929 
 930             case &#39;Z&#39;:
 931                 break;
 932 
 933             default:
 934                 throw new IOException(&quot;Parse &quot; + type + &quot; time, garbage offset&quot;);
 935         }
 936         return new Date(time);
 937     }
 938 
 939     public void getNull() throws IOException {
 940         if (tag != tag_Null) {
 941             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
 942         }
 943         if (end != start) {
 944             throw new IOException(&quot;DER UTC Time length error&quot;);
 945         }
 946     }
 947 
 948     /**
 949      * Returns a Date if the DerValue is UtcTime.
 950      *
 951      * @return the Date held in this DER value
 952      */
 953     public Date getUTCTime() throws IOException {
 954         if (tag != tag_UtcTime) {
 955             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
 956         }
 957         if (end - start &lt; 11 || end - start &gt; 17)
 958             throw new IOException(&quot;DER UTC Time length error&quot;);
 959 
 960         data.pos = data.end; // Compatibility. Reach end.
 961         return getTime(end - start, false);
 962     }
 963 
 964     /**
 965      * Returns a Date if the DerValue is GeneralizedTime.
 966      *
 967      * @return the Date held in this DER value
 968      */
 969     public Date getGeneralizedTime() throws IOException {
 970         if (tag != tag_GeneralizedTime) {
 971             throw new IOException(
 972                 &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
 973         }
 974         if (end - start &lt; 13)
 975             throw new IOException(&quot;DER Generalized Time length error&quot;);
 976 
 977         data.pos = data.end; // Compatibility. Reach end.
 978         return getTime(end - start, true);
 979     }
 980 
 981     /**
 982      * Bitwise equality comparison.  DER encoded values have a single
 983      * encoding, so that bitwise equality of the encoded values is an
 984      * efficient way to establish equivalence of the unencoded values.
 985      *
 986      * @param o the object being compared with this one
 987      */
 988     @Override
 989     public boolean equals(Object o) {
 990         if (this == o) {
 991             return true;
 992         }
 993         if (!(o instanceof DerValue)) {
 994             return false;
 995         }
 996         DerValue other = (DerValue) o;
 997         if (tag != other.tag) {
 998             return false;
 999         }
1000         if (buffer == other.buffer &amp;&amp; start == other.start &amp;&amp; end == other.end) {
1001             return true;
1002         }
1003         return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);
1004     }
1005 
1006     /**
1007      * Returns a printable representation of the value.
1008      *
1009      * @return printable representation of the value
1010      */
1011     @Override
1012     public String toString() {
1013         return String.format(&quot;DerValue(%02x, %s, %d, 5d)&quot;,
1014                 0xff &amp; tag, buffer, start, end);
1015     }
1016 
1017     /**
1018      * Returns a DER-encoded value, such that if it&#39;s passed to the
1019      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
1020      *
1021      * @return DER-encoded value, including tag and length.
1022      */
1023     public byte[] toByteArray() throws IOException {
1024         DerOutputStream out = new DerOutputStream();
1025         encode(out);
1026         data.pos = data.start; // encode go last, should go back
1027         return out.toByteArray();
1028     }
1029 
1030     /**
1031      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
1032      * to return a DER stream of the members of the set or sequence.
1033      * This operation is not supported for primitive types such as
1034      * integers or bit strings.
1035      */
1036     public DerInputStream toDerInputStream() throws IOException {
1037         if (tag == tag_Sequence || tag == tag_Set)
1038             return data;
1039         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
1040     }
1041 
1042     /**
1043      * Get the length of the encoded value.
1044      */
1045     public int length() {
1046         return end - start;
1047     }
1048 
1049     /**
1050      * Determine if a character is one of the permissible characters for
1051      * PrintableString:
1052      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
1053      * plus sign, comma, hyphen, period, slash, colon, equals sign,
1054      * and question mark.
1055      *
1056      * Characters that are *not* allowed in PrintableString include
1057      * exclamation point, quotation mark, number sign, dollar sign,
1058      * percent sign, ampersand, asterisk, semicolon, less than sign,
1059      * greater than sign, at sign, left and right square brackets,
1060      * backslash, circumflex (94), underscore, back quote (96),
1061      * left and right curly brackets, vertical line, tilde,
1062      * and the control codes (0-31 and 127).
1063      *
1064      * This list is based on X.680 (the ASN.1 spec).
1065      */
1066     public static boolean isPrintableStringChar(char ch) {
1067         if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
1068             (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
1069             return true;
1070         } else {
1071             switch (ch) {
1072                 case &#39; &#39;:       /* space */
1073                 case &#39;\&#39;&#39;:      /* apostrophe */
1074                 case &#39;(&#39;:       /* left paren */
1075                 case &#39;)&#39;:       /* right paren */
1076                 case &#39;+&#39;:       /* plus */
1077                 case &#39;,&#39;:       /* comma */
1078                 case &#39;-&#39;:       /* hyphen */
1079                 case &#39;.&#39;:       /* period */
1080                 case &#39;/&#39;:       /* slash */
1081                 case &#39;:&#39;:       /* colon */
1082                 case &#39;=&#39;:       /* equals */
1083                 case &#39;?&#39;:       /* question mark */
1084                     return true;
1085                 default:
1086                     return false;
1087             }
1088         }
1089     }
1090 
1091     /**
1092      * Create the tag of the attribute.
1093      *
1094      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
1095      *               APPLICATION or PRIVATE
1096      * @param form if true, the value is constructed, otherwise it
1097      * is primitive.
1098      * @param val the tag value
1099      */
1100     public static byte createTag(byte tagClass, boolean form, byte val) {
1101         byte tag = (byte)(tagClass | val);
1102         if (form) {
1103             tag |= (byte)0x20;
1104         }
1105         return (tag);
1106     }
1107 
1108     /**
1109      * Set the tag of the attribute. Commonly used to reset the
1110      * tag value used for IMPLICIT encodings.
1111      *
1112      * @param tag the tag value
1113      */
1114     public void resetTag(byte tag) {
1115         this.tag = tag;
1116     }
1117 
1118     /**
1119      * Returns a hashcode for this DerValue.
1120      *
1121      * @return a hashcode for this DerValue.
1122      */
1123     @Override
1124     public int hashCode() {
1125         return toString().hashCode();
1126     }
1127 
1128     public DerValue[] subs(byte expectedTag) throws IOException {
1129         if (expectedTag != 0 &amp;&amp; expectedTag != tag) {
1130             throw new IOException(&quot;Not constructed&quot;);
1131         }
1132         List&lt;DerValue&gt; result = new ArrayList&lt;&gt;();
1133         DerInputStream dis = new DerInputStream(this);
1134         while (dis.available() &gt; 0) {
1135             result.add(dis.getDerValue());
1136         }
1137         return result.toArray(new DerValue[result.size()]);
1138     }
1139 }
    </pre>
  </body>
</html>
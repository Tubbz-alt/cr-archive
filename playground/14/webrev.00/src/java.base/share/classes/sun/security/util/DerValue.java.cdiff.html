<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerInputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerValue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /**
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /**
<span class="line-modified">!  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,14 ***</span>
   * questions.
   */
  
  package sun.security.util;
  
  import java.io.*;
  import java.math.BigInteger;
  import java.nio.charset.Charset;
<span class="line-modified">! import java.util.Date;</span>
  
  import static java.nio.charset.StandardCharsets.*;
  
  /**
   * Represents a single DER-encoded value.  DER encoding rules are a subset
<span class="line-new-header">--- 23,19 ---</span>
   * questions.
   */
  
  package sun.security.util;
  
<span class="line-added">+ import sun.util.calendar.CalendarDate;</span>
<span class="line-added">+ import sun.util.calendar.CalendarSystem;</span>
<span class="line-added">+ </span>
  import java.io.*;
  import java.math.BigInteger;
  import java.nio.charset.Charset;
<span class="line-modified">! import java.nio.charset.IllegalCharsetNameException;</span>
<span class="line-added">+ import java.nio.charset.UnsupportedCharsetException;</span>
<span class="line-added">+ import java.util.*;</span>
  
  import static java.nio.charset.StandardCharsets.*;
  
  /**
   * Represents a single DER-encoded value.  DER encoding rules are a subset
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,28 ***</span>
   * @author David Brownell
   * @author Amit Kapoor
   * @author Hemma Prafullchandra
   */
  public class DerValue {
      /** The tag class types */
      public static final byte TAG_UNIVERSAL = (byte)0x000;
      public static final byte TAG_APPLICATION = (byte)0x040;
      public static final byte TAG_CONTEXT = (byte)0x080;
      public static final byte TAG_PRIVATE = (byte)0x0c0;
  
<span class="line-removed">-     /** The DER tag of the value; one of the tag_ constants. */</span>
<span class="line-removed">-     public byte                 tag;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     protected DerInputBuffer    buffer;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The DER-encoded data of the value, never null</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public final DerInputStream data;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private int                 length;</span>
<span class="line-removed">- </span>
      /*
       * The type starts at the first byte of the encoding, and
       * is one of these tag_* values.  That may be all the type
       * data that is needed.
       */
<span class="line-new-header">--- 59,17 ---</span>
   * @author David Brownell
   * @author Amit Kapoor
   * @author Hemma Prafullchandra
   */
  public class DerValue {
<span class="line-added">+ </span>
      /** The tag class types */
      public static final byte TAG_UNIVERSAL = (byte)0x000;
      public static final byte TAG_APPLICATION = (byte)0x040;
      public static final byte TAG_CONTEXT = (byte)0x080;
      public static final byte TAG_PRIVATE = (byte)0x0c0;
  
      /*
       * The type starts at the first byte of the encoding, and
       * is one of these tag_* values.  That may be all the type
       * data that is needed.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,10 ***</span>
<span class="line-new-header">--- 151,19 ---</span>
       * Tag value indicating an ASN.1
       * &quot;SET OF&quot; (one to N members, order does not matter).
       */
      public static final byte    tag_SetOf = 0x31;
  
<span class="line-added">+     // Instance fields start here:</span>
<span class="line-added">+     public /*final*/ byte tag;</span>
<span class="line-added">+     final byte[] buffer;</span>
<span class="line-added">+     final int start;</span>
<span class="line-added">+     final int end;</span>
<span class="line-added">+     public final boolean allowBER;</span>
<span class="line-added">+ </span>
<span class="line-added">+     final public DerInputStream data;</span>
<span class="line-added">+ </span>
      /*
       * These values are the high order bits for the other kinds of tags.
       */
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,127 ***</span>
  
      /**
       * Creates a PrintableString or UTF8string DER value from a string
       */
      public DerValue(String value) {
<span class="line-modified">!         boolean isPrintableString = true;</span>
          for (int i = 0; i &lt; value.length(); i++) {
              if (!isPrintableStringChar(value.charAt(i))) {
<span class="line-modified">!                 isPrintableString = false;</span>
<span class="line-removed">-                 break;</span>
              }
          }
<span class="line-modified">! </span>
<span class="line-removed">-         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);</span>
      }
  
      /**
       * Creates a string type DER value from a String object
       * @param stringTag the tag for the DER value to create
       * @param value the String object to use for the DER value
       */
      public DerValue(byte stringTag, String value) {
<span class="line-modified">!         data = init(stringTag, value);</span>
      }
  
      // Creates a DerValue from a tag and some DER-encoded data w/ additional
      // arg to control whether DER checks are enforced.
<span class="line-modified">!     DerValue(byte tag, byte[] data, boolean allowBER) {</span>
          this.tag = tag;
<span class="line-modified">!         buffer = new DerInputBuffer(data.clone(), allowBER);</span>
<span class="line-modified">!         length = data.length;</span>
<span class="line-modified">!         this.data = new DerInputStream(buffer);</span>
<span class="line-modified">!         this.data.mark(Integer.MAX_VALUE);</span>
      }
  
      /**
       * Creates a DerValue from a tag and some DER-encoded data.
       *
       * @param tag the DER type tag
<span class="line-modified">!      * @param data the DER-encoded data</span>
       */
<span class="line-modified">!     public DerValue(byte tag, byte[] data) {</span>
<span class="line-modified">!         this(tag, data, true);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * package private</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     DerValue(DerInputBuffer in) throws IOException {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // XXX must also parse BER-encoded constructed</span>
<span class="line-removed">-         // values such as sequences, sets...</span>
<span class="line-removed">-         tag = (byte)in.read();</span>
<span class="line-removed">-         byte lenByte = (byte)in.read();</span>
<span class="line-removed">-         length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-removed">-         if (length == -1) {  // indefinite length encoding found</span>
<span class="line-removed">-             DerInputBuffer inbuf = in.dup();</span>
<span class="line-removed">-             inbuf = new DerInputBuffer(</span>
<span class="line-removed">-                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),</span>
<span class="line-removed">-                     in.allowBER);</span>
<span class="line-removed">-             if (tag != inbuf.read())</span>
<span class="line-removed">-                 throw new IOException</span>
<span class="line-removed">-                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-removed">-             length = DerInputStream.getDefiniteLength(inbuf);</span>
<span class="line-removed">-             buffer = inbuf.dup();</span>
<span class="line-removed">-             buffer.truncate(length);</span>
<span class="line-removed">-             data = new DerInputStream(buffer);</span>
<span class="line-removed">-             // indefinite form is encoded by sending a length field with a</span>
<span class="line-removed">-             // length of 0. - i.e. [1000|0000].</span>
<span class="line-removed">-             // the object is ended by sending two zero bytes.</span>
<span class="line-removed">-             in.skip(length + 2);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">- </span>
<span class="line-removed">-             buffer = in.dup();</span>
<span class="line-removed">-             buffer.truncate(length);</span>
<span class="line-removed">-             data = new DerInputStream(buffer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             in.skip(length);</span>
<span class="line-removed">-         }</span>
      }
  
      // Get an ASN.1/DER encoded datum from a buffer w/ additional
      // arg to control whether DER checks are enforced.
      DerValue(byte[] buf, boolean allowBER) throws IOException {
<span class="line-modified">!         data = init(true, new ByteArrayInputStream(buf), allowBER);</span>
      }
  
      /**
       * Get an ASN.1/DER encoded datum from a buffer.  The
       * entire buffer must hold exactly one datum, including
       * its tag and length.
       *
       * @param buf buffer holding a single DER-encoded datum.
       */
      public DerValue(byte[] buf) throws IOException {
<span class="line-modified">!         this(buf, true);</span>
      }
  
      // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
      // arg to control whether DER checks are enforced.
<span class="line-modified">!     DerValue(byte[] buf, int offset, int len, boolean allowBER)</span>
<span class="line-modified">!         throws IOException {</span>
<span class="line-removed">-         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Get an ASN.1/DER encoded datum from part of a buffer.</span>
<span class="line-modified">!      * That part of the buffer must hold exactly one datum, including</span>
<span class="line-modified">!      * its tag and length.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param buf the buffer</span>
<span class="line-modified">!      * @param offset start point of the single DER-encoded dataum</span>
<span class="line-modified">!      * @param len how many bytes are in the encoded datum</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     public DerValue(byte[] buf, int offset, int len) throws IOException {</span>
<span class="line-modified">!         this(buf, offset, len, true);</span>
      }
  
      // Get an ASN1/DER encoded datum from an input stream w/ additional
      // arg to control whether DER checks are enforced.
      DerValue(InputStream in, boolean allowBER) throws IOException {
<span class="line-modified">!         data = init(false, in, allowBER);</span>
      }
  
      /**
       * Get an ASN1/DER encoded datum from an input stream.  The
       * stream may have additional data following the encoded datum.
<span class="line-new-header">--- 209,201 ---</span>
  
      /**
       * Creates a PrintableString or UTF8string DER value from a string
       */
      public DerValue(String value) {
<span class="line-modified">!         this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,</span>
<span class="line-added">+                 value);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static boolean isPrintableString(String value) {</span>
          for (int i = 0; i &lt; value.length(); i++) {
              if (!isPrintableStringChar(value.charAt(i))) {
<span class="line-modified">!                 return false;</span>
              }
          }
<span class="line-modified">!         return true;</span>
      }
  
      /**
       * Creates a string type DER value from a String object
       * @param stringTag the tag for the DER value to create
       * @param value the String object to use for the DER value
       */
      public DerValue(byte stringTag, String value) {
<span class="line-modified">!         final Charset charset;</span>
<span class="line-added">+ </span>
<span class="line-added">+         tag = stringTag;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (stringTag) {</span>
<span class="line-added">+             case tag_PrintableString:</span>
<span class="line-added">+             case tag_IA5String:</span>
<span class="line-added">+             case tag_GeneralString:</span>
<span class="line-added">+                 charset = US_ASCII;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case tag_T61String:</span>
<span class="line-added">+                 charset = ISO_8859_1;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case tag_BMPString:</span>
<span class="line-added">+                 charset = UTF_16BE;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case tag_UTF8String:</span>
<span class="line-added">+                 charset = UTF_8;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case tag_UniversalString:</span>
<span class="line-added">+                 charset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         buffer = value.getBytes(charset);</span>
<span class="line-added">+         start = 0;</span>
<span class="line-added">+         end = buffer.length;</span>
<span class="line-added">+         allowBER = false;</span>
<span class="line-added">+         this.data = new DerInputStream(this);</span>
      }
  
      // Creates a DerValue from a tag and some DER-encoded data w/ additional
      // arg to control whether DER checks are enforced.
<span class="line-modified">!     DerValue(byte tag, byte[] buffer, boolean allowBER) {</span>
<span class="line-added">+         this(tag, buffer, 0, buffer.length, allowBER);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {</span>
          this.tag = tag;
<span class="line-modified">!         this.buffer = buffer;</span>
<span class="line-modified">!         this.start = start;</span>
<span class="line-modified">!         this.end = end;</span>
<span class="line-modified">!         this.allowBER = allowBER;</span>
<span class="line-added">+         this.data = new DerInputStream(this);</span>
      }
  
      /**
       * Creates a DerValue from a tag and some DER-encoded data.
       *
       * @param tag the DER type tag
<span class="line-modified">!      * @param buffer the DER-encoded data</span>
       */
<span class="line-modified">!     public DerValue(byte tag, byte[] buffer) {</span>
<span class="line-modified">!         this(tag, buffer.clone(), true);</span>
      }
  
      // Get an ASN.1/DER encoded datum from a buffer w/ additional
      // arg to control whether DER checks are enforced.
      DerValue(byte[] buf, boolean allowBER) throws IOException {
<span class="line-modified">!         this(buf, 0, buf.length, allowBER);</span>
      }
  
      /**
       * Get an ASN.1/DER encoded datum from a buffer.  The
       * entire buffer must hold exactly one datum, including
       * its tag and length.
       *
       * @param buf buffer holding a single DER-encoded datum.
       */
      public DerValue(byte[] buf) throws IOException {
<span class="line-modified">!         this(buf.clone(), true);</span>
      }
  
      // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
      // arg to control whether DER checks are enforced.
<span class="line-modified">!     DerValue(byte[] buf, int offset, int len, boolean allowBER) throws IOException {</span>
<span class="line-modified">!         this(buf, offset, len, allowBER, true);</span>
      }
  
<span class="line-modified">!     DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean noMore) throws IOException {</span>
<span class="line-modified">!         if (len &lt; 2) {</span>
<span class="line-modified">!             throw new IOException(&quot;Too short &quot; + len);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         int pos = offset;</span>
<span class="line-modified">!         tag = buf[pos++];</span>
<span class="line-modified">!         int length;</span>
<span class="line-modified">!         int lenByte = buf[pos++];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (lenByte == (byte)0x80) {</span>
<span class="line-modified">!             length = -1;</span>
<span class="line-added">+         } else if ((lenByte &amp; 0x080) == 0x00) { // short form, 1 byte datum</span>
<span class="line-added">+             length = lenByte;</span>
<span class="line-added">+         } else {                     // long form or indefinite</span>
<span class="line-added">+             lenByte &amp;= 0x07f;</span>
<span class="line-added">+             if (lenByte == 0) {</span>
<span class="line-added">+                 length = -1;</span>
<span class="line-added">+             } else if (lenByte &lt; 0 || lenByte &gt; 4) {</span>
<span class="line-added">+                 throw new IOException(&quot;incorrect DER encoding&quot;);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (len &lt; 2 + lenByte) {</span>
<span class="line-added">+                     throw new IOException(&quot;incorrect DER encoding&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 length = 0x0ff &amp; buf[pos++];</span>
<span class="line-added">+                 lenByte--;</span>
<span class="line-added">+                 if (length == 0 &amp;&amp; !allowBER) {</span>
<span class="line-added">+                     // DER requires length value be encoded in minimum number of bytes</span>
<span class="line-added">+                     throw new IOException(&quot;Redundant length bytes found&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 while (lenByte-- &gt; 0) {</span>
<span class="line-added">+                     length &lt;&lt;= 8;</span>
<span class="line-added">+                     length += 0x0ff &amp; buf[pos++];</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (length &lt; 0) {</span>
<span class="line-added">+                     throw new IOException(&quot;Invalid length bytes&quot;);</span>
<span class="line-added">+                 } else if (length &lt;= 127 &amp;&amp; !allowBER) {</span>
<span class="line-added">+                     throw new IOException(&quot;Should use short form for length&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (length == -1) { // indefinite length encoding found</span>
<span class="line-added">+             if (!allowBER) {</span>
<span class="line-added">+                 throw new IOException</span>
<span class="line-added">+                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             InputStream in = new ByteArrayInputStream(</span>
<span class="line-added">+                     DerIndefLenConverter.convertStream(</span>
<span class="line-added">+                             new ByteArrayInputStream(buf, pos, len - (pos - offset)), (byte)lenByte, tag));</span>
<span class="line-added">+             if (tag != in.read())</span>
<span class="line-added">+                 throw new IOException</span>
<span class="line-added">+                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added">+             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-added">+             this.buffer = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-added">+             this.start = 0;</span>
<span class="line-added">+             this.end = length;</span>
<span class="line-added">+             this.allowBER = true;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             if (len - length &lt; pos - offset) {</span>
<span class="line-added">+                 throw new EOFException(&quot;Too little&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (len - length &gt; pos - offset &amp;&amp; noMore) {</span>
<span class="line-added">+                 throw new IOException(&quot;Too much&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             this.buffer = buf;</span>
<span class="line-added">+             this.start = pos;</span>
<span class="line-added">+             this.end = pos + length;</span>
<span class="line-added">+             this.allowBER = allowBER;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         this.data = new DerInputStream(this);</span>
      }
  
      // Get an ASN1/DER encoded datum from an input stream w/ additional
      // arg to control whether DER checks are enforced.
      DerValue(InputStream in, boolean allowBER) throws IOException {
<span class="line-modified">!         this.tag = (byte)in.read();</span>
<span class="line-added">+         byte lenByte = (byte)in.read();</span>
<span class="line-added">+         int length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-added">+         if (length == -1) { // indefinite length encoding found</span>
<span class="line-added">+             in = new ByteArrayInputStream(</span>
<span class="line-added">+                     DerIndefLenConverter.convertStream(in, lenByte, tag));</span>
<span class="line-added">+             if (tag != in.read())</span>
<span class="line-added">+                 throw new IOException</span>
<span class="line-added">+                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added">+             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         this.buffer = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-added">+         this.start = 0;</span>
<span class="line-added">+         this.end = length;</span>
<span class="line-added">+         this.allowBER = allowBER;</span>
<span class="line-added">+         this.data = new DerInputStream(this);</span>
<span class="line-added">+         System.out.println(this);</span>
      }
  
      /**
       * Get an ASN1/DER encoded datum from an input stream.  The
       * stream may have additional data following the encoded datum.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,90 ***</span>
       */
      public DerValue(InputStream in) throws IOException {
          this(in, true);
      }
  
<span class="line-removed">-     private DerInputStream init(byte stringTag, String value) {</span>
<span class="line-removed">-         final Charset charset;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         tag = stringTag;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (stringTag) {</span>
<span class="line-removed">-         case tag_PrintableString:</span>
<span class="line-removed">-         case tag_IA5String:</span>
<span class="line-removed">-         case tag_GeneralString:</span>
<span class="line-removed">-             charset = US_ASCII;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case tag_T61String:</span>
<span class="line-removed">-             charset = ISO_8859_1;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case tag_BMPString:</span>
<span class="line-removed">-             charset = UTF_16BE;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case tag_UTF8String:</span>
<span class="line-removed">-             charset = UTF_8;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-             // TBD: Need encoder for UniversalString before it can</span>
<span class="line-removed">-             // be handled.</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         byte[] buf = value.getBytes(charset);</span>
<span class="line-removed">-         length = buf.length;</span>
<span class="line-removed">-         buffer = new DerInputBuffer(buf, true);</span>
<span class="line-removed">-         DerInputStream result = new DerInputStream(buffer);</span>
<span class="line-removed">-         result.mark(Integer.MAX_VALUE);</span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * helper routine</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private DerInputStream init(boolean fullyBuffered, InputStream in,</span>
<span class="line-removed">-         boolean allowBER) throws IOException {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         tag = (byte)in.read();</span>
<span class="line-removed">-         byte lenByte = (byte)in.read();</span>
<span class="line-removed">-         length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-removed">-         if (length == -1) { // indefinite length encoding found</span>
<span class="line-removed">-             in = new ByteArrayInputStream(</span>
<span class="line-removed">-                     DerIndefLenConverter.convertStream(in, lenByte, tag));</span>
<span class="line-removed">-             if (tag != in.read())</span>
<span class="line-removed">-                 throw new IOException</span>
<span class="line-removed">-                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-removed">-             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (fullyBuffered &amp;&amp; in.available() != length)</span>
<span class="line-removed">-             throw new IOException(&quot;extra data given to DerValue constructor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         byte[] bytes = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         buffer = new DerInputBuffer(bytes, allowBER);</span>
<span class="line-removed">-         return new DerInputStream(buffer);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Encode an ASN1/DER encoded datum onto a DER output stream.
       */
<span class="line-modified">!     public void encode(DerOutputStream out)</span>
<span class="line-removed">-     throws IOException {</span>
          out.write(tag);
<span class="line-modified">!         out.putLength(length);</span>
<span class="line-modified">!         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)</span>
<span class="line-modified">!         if (length &gt; 0) {</span>
<span class="line-removed">-             byte[] value = new byte[length];</span>
<span class="line-removed">-             // always synchronized on data</span>
<span class="line-removed">-             synchronized (data) {</span>
<span class="line-removed">-                 buffer.reset();</span>
<span class="line-removed">-                 if (buffer.read(value) != length) {</span>
<span class="line-removed">-                     throw new IOException(&quot;short DER value read (encode)&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 out.write(value);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
  
      public final DerInputStream getData() {
          return data;
      }
<span class="line-new-header">--- 415,18 ---</span>
       */
      public DerValue(InputStream in) throws IOException {
          this(in, true);
      }
  
      /**
       * Encode an ASN1/DER encoded datum onto a DER output stream.
       */
<span class="line-modified">!     public void encode(DerOutputStream out) throws IOException {</span>
          out.write(tag);
<span class="line-modified">!         out.putLength(end - start);</span>
<span class="line-modified">!         out.write(buffer, start, end - start);</span>
<span class="line-modified">!         data.pos = data.end; // Compatibility. Reach end.</span>
      }
  
      public final DerInputStream getData() {
          return data;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,40 ***</span>
       */
      public boolean getBoolean() throws IOException {
          if (tag != tag_Boolean) {
              throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
          }
<span class="line-modified">!         if (length != 1) {</span>
              throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
<span class="line-modified">!                                         + length);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (buffer.read() != 0) {</span>
<span class="line-removed">-             return true;</span>
          }
<span class="line-modified">!         return false;</span>
      }
  
      /**
       * Returns an ASN.1 OBJECT IDENTIFIER.
       *
       * @return the OID held in this DER value
       */
      public ObjectIdentifier getOID() throws IOException {
          if (tag != tag_ObjectId)
              throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
<span class="line-modified">!         return new ObjectIdentifier(buffer);</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private byte[] append(byte[] a, byte[] b) {</span>
<span class="line-removed">-         if (a == null)</span>
<span class="line-removed">-             return b;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         byte[] ret = new byte[a.length + b.length];</span>
<span class="line-removed">-         System.arraycopy(a, 0, ret, 0, a.length);</span>
<span class="line-removed">-         System.arraycopy(b, 0, ret, a.length, b.length);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return ret;</span>
      }
  
      /**
       * Returns an ASN.1 OCTET STRING
       *
<span class="line-new-header">--- 442,28 ---</span>
       */
      public boolean getBoolean() throws IOException {
          if (tag != tag_Boolean) {
              throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
          }
<span class="line-modified">!         if (end - start != 1) {</span>
              throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
<span class="line-modified">!                                         + (end - start));</span>
          }
<span class="line-modified">!         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         return buffer[start] != 0;</span>
      }
  
      /**
       * Returns an ASN.1 OBJECT IDENTIFIER.
       *
       * @return the OID held in this DER value
       */
      public ObjectIdentifier getOID() throws IOException {
          if (tag != tag_ObjectId)
              throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
<span class="line-modified">!         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified">!         return new ObjectIdentifier(buffer, start, end);</span>
      }
  
      /**
       * Returns an ASN.1 OCTET STRING
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,69 ***</span>
              throw new IOException(
                  &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
          }
          // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
          // known bug that it returns -1 instead of 0.
<span class="line-modified">!         if (length == 0) {</span>
              return new byte[0];
          }
  
<span class="line-modified">!         // Only allocate the array if there are enough bytes available.</span>
<span class="line-modified">!         // This only works for ByteArrayInputStream.</span>
<span class="line-modified">!         // The assignment below ensures that buffer has the required type.</span>
<span class="line-modified">!         ByteArrayInputStream arrayInput = buffer;</span>
<span class="line-modified">!         if (arrayInput.available() &lt; length) {</span>
<span class="line-modified">!             throw new IOException(&quot;short read on DerValue buffer&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         byte[] bytes = new byte[length];</span>
<span class="line-removed">-         arrayInput.read(bytes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (isConstructed()) {</span>
<span class="line-removed">-             DerInputStream in = new DerInputStream(bytes, 0, bytes.length,</span>
<span class="line-removed">-                 buffer.allowBER);</span>
<span class="line-removed">-             bytes = null;</span>
<span class="line-removed">-             while (in.available() != 0) {</span>
<span class="line-removed">-                 bytes = append(bytes, in.getOctetString());</span>
              }
          }
<span class="line-removed">-         return bytes;</span>
      }
  
      /**
       * Returns an ASN.1 INTEGER value as an integer.
       *
       * @return the integer held in this DER value.
       */
      public int getInteger() throws IOException {
<span class="line-modified">!         if (tag != tag_Integer) {</span>
<span class="line-modified">!             throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);</span>
          }
<span class="line-modified">!         return buffer.getInteger(data.available());</span>
      }
  
      /**
       * Returns an ASN.1 INTEGER value as a BigInteger.
       *
       * @return the integer held in this DER value as a BigInteger.
       */
      public BigInteger getBigInteger() throws IOException {
<span class="line-modified">!         if (tag != tag_Integer)</span>
<span class="line-removed">-             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);</span>
<span class="line-removed">-         return buffer.getBigInteger(data.available(), false);</span>
      }
  
      /**
       * Returns an ASN.1 INTEGER value as a positive BigInteger.
       * This is just to deal with implementations that incorrectly encode
       * some values as negative.
       *
       * @return the integer held in this DER value as a BigInteger.
       */
      public BigInteger getPositiveBigInteger() throws IOException {
          if (tag != tag_Integer)
              throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<span class="line-modified">!         return buffer.getBigInteger(data.available(), true);</span>
      }
  
      /**
       * Returns an ASN.1 ENUMERATED value.
       *
<span class="line-new-header">--- 475,75 ---</span>
              throw new IOException(
                  &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
          }
          // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
          // known bug that it returns -1 instead of 0.
<span class="line-modified">!         if (end - start == 0) {</span>
              return new byte[0];
          }
  
<span class="line-modified">!         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified">!         if (!isConstructed()) {</span>
<span class="line-modified">!             return Arrays.copyOfRange(buffer, start, end);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             ByteArrayOutputStream bout = new ByteArrayOutputStream();</span>
<span class="line-modified">!             for (DerValue dv : new DerInputStream(this)) {</span>
<span class="line-modified">!                 bout.write(dv.getOctetString());</span>
              }
<span class="line-added">+             return bout.toByteArray();</span>
          }
      }
  
      /**
       * Returns an ASN.1 INTEGER value as an integer.
       *
       * @return the integer held in this DER value.
       */
      public int getInteger() throws IOException {
<span class="line-modified">!         BigInteger result = getBigInteger();</span>
<span class="line-modified">!         if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0) {</span>
<span class="line-added">+             throw new IOException(&quot;Integer below minimum valid value&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
<span class="line-added">+             throw new IOException(&quot;Integer exceeds maximum valid value&quot;);</span>
          }
<span class="line-modified">!         return result.intValue();</span>
      }
  
      /**
       * Returns an ASN.1 INTEGER value as a BigInteger.
       *
       * @return the integer held in this DER value as a BigInteger.
       */
      public BigInteger getBigInteger() throws IOException {
<span class="line-modified">!         return getBigInteger0(false);</span>
      }
  
      /**
       * Returns an ASN.1 INTEGER value as a positive BigInteger.
       * This is just to deal with implementations that incorrectly encode
       * some values as negative.
       *
       * @return the integer held in this DER value as a BigInteger.
       */
      public BigInteger getPositiveBigInteger() throws IOException {
<span class="line-added">+         return getBigInteger0(true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private BigInteger getBigInteger0(boolean mustBePositive) throws IOException {</span>
          if (tag != tag_Integer)
              throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<span class="line-modified">!         if (end == start) {</span>
<span class="line-added">+             throw new IOException(&quot;Invalid encoding: zero length Int value&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         if (!allowBER &amp;&amp; (end - start &gt;= 2 &amp;&amp; (buffer[start] == 0) &amp;&amp; (buffer[start + 1] &gt;= 0))) {</span>
<span class="line-added">+             throw new IOException(&quot;Invalid encoding: redundant leading 0s&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return mustBePositive</span>
<span class="line-added">+                 ? new BigInteger(1, buffer, start, end - start)</span>
<span class="line-added">+                 : new BigInteger(buffer, start, end - start);</span>
      }
  
      /**
       * Returns an ASN.1 ENUMERATED value.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 553,37 ***</span>
      public int getEnumerated() throws IOException {
          if (tag != tag_Enumerated) {
              throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
                                    + tag);
          }
<span class="line-modified">!         return buffer.getInteger(data.available());</span>
      }
  
      /**
       * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
       *
       * @return the bit string held in this value
       */
      public byte[] getBitString() throws IOException {
<span class="line-modified">!         if (tag != tag_BitString)</span>
<span class="line-removed">-             throw new IOException(</span>
<span class="line-removed">-                 &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return buffer.getBitString();</span>
      }
  
      /**
       * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
       *
       * @return a BitArray representing the bit string held in this value
       */
      public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified">!         if (tag != tag_BitString)</span>
<span class="line-removed">-             throw new IOException(</span>
<span class="line-removed">-                 &quot;DerValue.getBitString, not a bit string &quot; + tag);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return buffer.getUnalignedBitString();</span>
      }
  
      /**
       * Returns the name component as a Java string, regardless of its
       * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
<span class="line-new-header">--- 552,30 ---</span>
      public int getEnumerated() throws IOException {
          if (tag != tag_Enumerated) {
              throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
                                    + tag);
          }
<span class="line-modified">!         // TODO</span>
<span class="line-added">+         return new BigInteger(1, buffer, start, end - start).intValue();</span>
      }
  
      /**
       * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
       *
       * @return the bit string held in this value
       */
      public byte[] getBitString() throws IOException {
<span class="line-modified">!         return getBitString(false);</span>
      }
  
      /**
       * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
       *
       * @return a BitArray representing the bit string held in this value
       */
      public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified">!         return getUnalignedBitString(false);</span>
      }
  
      /**
       * Returns the name component as a Java string, regardless of its
       * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,14 ***</span>
              return getPrintableString();
          else if (tag == tag_T61String)
              return getT61String();
          else if (tag == tag_IA5String)
              return getIA5String();
<span class="line-modified">!         /*</span>
<span class="line-removed">-           else if (tag == tag_UniversalString)</span>
            return getUniversalString();
<span class="line-removed">-         */</span>
          else if (tag == tag_BMPString)
              return getBMPString();
          else if (tag == tag_GeneralString)
              return getGeneralString();
          else
<span class="line-new-header">--- 588,12 ---</span>
              return getPrintableString();
          else if (tag == tag_T61String)
              return getT61String();
          else if (tag == tag_IA5String)
              return getIA5String();
<span class="line-modified">!         else if (tag == tag_UniversalString)</span>
            return getUniversalString();
          else if (tag == tag_BMPString)
              return getBMPString();
          else if (tag == tag_GeneralString)
              return getGeneralString();
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 617,47 ***</span>
       * @param tagImplicit if true, the tag is assumed implicit.
       * @return the bit string held in this value
       */
      public byte[] getBitString(boolean tagImplicit) throws IOException {
          if (!tagImplicit) {
<span class="line-modified">!             if (tag != tag_BitString)</span>
                  throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">!                                        + tag);</span>
              }
<span class="line-modified">!         return buffer.getBitString();</span>
      }
  
      /**
       * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
       * based on the parameter.  The bit string need not be byte-aligned.
       *
       * @param tagImplicit if true, the tag is assumed implicit.
       * @return the bit string held in this value
       */
      public BitArray getUnalignedBitString(boolean tagImplicit)
<span class="line-modified">!     throws IOException {</span>
          if (!tagImplicit) {
<span class="line-modified">!             if (tag != tag_BitString)</span>
                  throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">!                                        + tag);</span>
              }
<span class="line-modified">!         return buffer.getUnalignedBitString();</span>
      }
  
      /**
       * Helper routine to return all the bytes contained in the
       * DerInputStream associated with this object.
       */
      public byte[] getDataBytes() throws IOException {
<span class="line-modified">!         byte[] retVal = new byte[length];</span>
<span class="line-modified">!         synchronized (data) {</span>
<span class="line-removed">-             data.reset();</span>
<span class="line-removed">-             data.getBytes(retVal);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return retVal;</span>
      }
  
      /**
       * Returns an ASN.1 STRING value
       *
       * @return the printable string held in this value
       */
<span class="line-new-header">--- 607,76 ---</span>
       * @param tagImplicit if true, the tag is assumed implicit.
       * @return the bit string held in this value
       */
      public byte[] getBitString(boolean tagImplicit) throws IOException {
          if (!tagImplicit) {
<span class="line-modified">!             if (tag != tag_BitString) {</span>
                  throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">!                         + tag);</span>
              }
<span class="line-modified">!         }</span>
<span class="line-added">+         if (end == start) {</span>
<span class="line-added">+             throw new IOException(&quot;No padding&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         int numOfPadBits = buffer[start];</span>
<span class="line-added">+         if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {</span>
<span class="line-added">+             throw new IOException(&quot;Invalid number of padding bits&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // minus the first byte which indicates the number of padding bits</span>
<span class="line-added">+         byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);</span>
<span class="line-added">+         if (numOfPadBits != 0) {</span>
<span class="line-added">+             // get rid of the padding bits</span>
<span class="line-added">+             retval[end - start - 2] &amp;= (0xff &lt;&lt; numOfPadBits);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         return retval;</span>
      }
  
      /**
       * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
       * based on the parameter.  The bit string need not be byte-aligned.
       *
       * @param tagImplicit if true, the tag is assumed implicit.
       * @return the bit string held in this value
       */
      public BitArray getUnalignedBitString(boolean tagImplicit)
<span class="line-modified">!             throws IOException {</span>
          if (!tagImplicit) {
<span class="line-modified">!             if (tag != tag_BitString) {</span>
                  throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<span class="line-modified">!                         + tag);</span>
              }
<span class="line-modified">!         }</span>
<span class="line-added">+         if (end == start) {</span>
<span class="line-added">+             throw new IOException(&quot;No padding&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         if (end == start + 1) {</span>
<span class="line-added">+             return new BitArray(0);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             int numOfPadBits = buffer[start];</span>
<span class="line-added">+             if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {</span>
<span class="line-added">+                 throw new IOException(&quot;Invalid number of padding bits&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return new BitArray((end - start - 1) * 8 - numOfPadBits,</span>
<span class="line-added">+                     Arrays.copyOfRange(buffer, start + 1, end));</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Helper routine to return all the bytes contained in the
       * DerInputStream associated with this object.
       */
      public byte[] getDataBytes() throws IOException {
<span class="line-modified">!         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified">!         return Arrays.copyOfRange(buffer, start, end);</span>
      }
  
<span class="line-added">+     private String readString0(Charset cs) {</span>
<span class="line-added">+         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         return new String(buffer, start, end - start, cs);</span>
<span class="line-added">+     }</span>
      /**
       * Returns an ASN.1 STRING value
       *
       * @return the printable string held in this value
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,11 ***</span>
      throws IOException {
          if (tag != tag_PrintableString)
              throw new IOException(
                  &quot;DerValue.getPrintableString, not a string &quot; + tag);
  
<span class="line-modified">!         return new String(getDataBytes(), US_ASCII);</span>
      }
  
      /**
       * Returns an ASN.1 T61 (Teletype) STRING value
       *
<span class="line-new-header">--- 684,11 ---</span>
      throws IOException {
          if (tag != tag_PrintableString)
              throw new IOException(
                  &quot;DerValue.getPrintableString, not a string &quot; + tag);
  
<span class="line-modified">!         return readString0(US_ASCII);</span>
      }
  
      /**
       * Returns an ASN.1 T61 (Teletype) STRING value
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 678,11 ***</span>
      public String getT61String() throws IOException {
          if (tag != tag_T61String)
              throw new IOException(
                  &quot;DerValue.getT61String, not T61 &quot; + tag);
  
<span class="line-modified">!         return new String(getDataBytes(), ISO_8859_1);</span>
      }
  
      /**
       * Returns an ASN.1 IA5 (ASCII) STRING value
       *
<span class="line-new-header">--- 697,11 ---</span>
      public String getT61String() throws IOException {
          if (tag != tag_T61String)
              throw new IOException(
                  &quot;DerValue.getT61String, not T61 &quot; + tag);
  
<span class="line-modified">!         return readString0(ISO_8859_1);</span>
      }
  
      /**
       * Returns an ASN.1 IA5 (ASCII) STRING value
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,11 ***</span>
      public String getIA5String() throws IOException {
          if (tag != tag_IA5String)
              throw new IOException(
                  &quot;DerValue.getIA5String, not IA5 &quot; + tag);
  
<span class="line-modified">!         return new String(getDataBytes(), US_ASCII);</span>
      }
  
      /**
       * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
       *
<span class="line-new-header">--- 710,11 ---</span>
      public String getIA5String() throws IOException {
          if (tag != tag_IA5String)
              throw new IOException(
                  &quot;DerValue.getIA5String, not IA5 &quot; + tag);
  
<span class="line-modified">!         return readString0(US_ASCII);</span>
      }
  
      /**
       * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,11 ***</span>
              throw new IOException(
                  &quot;DerValue.getBMPString, not BMP &quot; + tag);
  
          // BMPString is the same as Unicode in big endian, unmarked
          // format.
<span class="line-modified">!         return new String(getDataBytes(), UTF_16BE);</span>
      }
  
      /**
       * Returns the ASN.1 UTF-8 STRING value as a Java String.
       *
<span class="line-new-header">--- 726,11 ---</span>
              throw new IOException(
                  &quot;DerValue.getBMPString, not BMP &quot; + tag);
  
          // BMPString is the same as Unicode in big endian, unmarked
          // format.
<span class="line-modified">!         return readString0(UTF_16BE);</span>
      }
  
      /**
       * Returns the ASN.1 UTF-8 STRING value as a Java String.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,11 ***</span>
      public String getUTF8String() throws IOException {
          if (tag != tag_UTF8String)
              throw new IOException(
                  &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
  
<span class="line-modified">!         return new String(getDataBytes(), UTF_8);</span>
      }
  
      /**
       * Returns the ASN.1 GENERAL STRING value as a Java String.
       *
<span class="line-new-header">--- 740,11 ---</span>
      public String getUTF8String() throws IOException {
          if (tag != tag_UTF8String)
              throw new IOException(
                  &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
  
<span class="line-modified">!         return readString0(UTF_8);</span>
      }
  
      /**
       * Returns the ASN.1 GENERAL STRING value as a Java String.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,11 ***</span>
      public String getGeneralString() throws IOException {
          if (tag != tag_GeneralString)
              throw new IOException(
                  &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
  
<span class="line-modified">!         return new String(getDataBytes(), US_ASCII);</span>
      }
  
      /**
       * Returns a Date if the DerValue is UtcTime.
       *
<span class="line-new-header">--- 754,197 ---</span>
      public String getGeneralString() throws IOException {
          if (tag != tag_GeneralString)
              throw new IOException(
                  &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
  
<span class="line-modified">!         return readString0(US_ASCII);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return a string corresponding to the encoded UniversalString held in</span>
<span class="line-added">+      * this value or an empty string if UTF_32BE is not a supported character</span>
<span class="line-added">+      * set.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public String getUniversalString() throws IOException {</span>
<span class="line-added">+         if (tag != tag_UniversalString)</span>
<span class="line-added">+             throw new IOException(</span>
<span class="line-added">+                 &quot;DerValue.getUniversalString, not UniversalString &quot; + tag);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             Charset cset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added">+             return readString0(cset);</span>
<span class="line-added">+         } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {</span>
<span class="line-added">+             return &quot;&quot;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Date getTime(int len, boolean generalized) throws IOException {</span>
<span class="line-added">+ </span>
<span class="line-added">+         /*</span>
<span class="line-added">+          * UTC time encoded as ASCII chars:</span>
<span class="line-added">+          *       YYMMDDhhmmZ</span>
<span class="line-added">+          *       YYMMDDhhmmssZ</span>
<span class="line-added">+          *       YYMMDDhhmm+hhmm</span>
<span class="line-added">+          *       YYMMDDhhmm-hhmm</span>
<span class="line-added">+          *       YYMMDDhhmmss+hhmm</span>
<span class="line-added">+          *       YYMMDDhhmmss-hhmm</span>
<span class="line-added">+          * UTC Time is broken in storing only two digits of year.</span>
<span class="line-added">+          * If YY &lt; 50, we assume 20YY;</span>
<span class="line-added">+          * if YY &gt;= 50, we assume 19YY, as per RFC 5280.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * Generalized time has a four-digit year and allows any</span>
<span class="line-added">+          * precision specified in ISO 8601. However, for our purposes,</span>
<span class="line-added">+          * we will only allow the same format as UTC time, except that</span>
<span class="line-added">+          * fractional seconds (millisecond precision) are supported.</span>
<span class="line-added">+          */</span>
<span class="line-added">+ </span>
<span class="line-added">+         int year, month, day, hour, minute, second, millis;</span>
<span class="line-added">+         String type = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+         int pos = start;</span>
<span class="line-added">+         if (generalized) {</span>
<span class="line-added">+             type = &quot;Generalized&quot;;</span>
<span class="line-added">+             year = 1000 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             year += 100 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             year += 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             year += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             len -= 2; // For the two extra YY</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             type = &quot;UTC&quot;;</span>
<span class="line-added">+             year = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             year += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (year &lt; 50)              // origin 2000</span>
<span class="line-added">+                 year += 2000;</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 year += 1900;   // origin 1900</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         month = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+         month += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+         day = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+         day += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+         hour = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+         hour += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+         minute = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+         minute += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+         len -= 10; // YYMMDDhhmm</span>
<span class="line-added">+ </span>
<span class="line-added">+         /*</span>
<span class="line-added">+          * We allow for non-encoded seconds, even though the</span>
<span class="line-added">+          * IETF-PKIX specification says that the seconds should</span>
<span class="line-added">+          * always be encoded even if it is zero.</span>
<span class="line-added">+          */</span>
<span class="line-added">+ </span>
<span class="line-added">+         millis = 0;</span>
<span class="line-added">+         if (len &gt; 2) {</span>
<span class="line-added">+             second = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             second += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+             len -= 2;</span>
<span class="line-added">+             // handle fractional seconds (if present)</span>
<span class="line-added">+             if (buffer[pos] == &#39;.&#39; || buffer[pos] == &#39;,&#39;) {</span>
<span class="line-added">+                 len --;</span>
<span class="line-added">+                 pos++;</span>
<span class="line-added">+                 int precision = 0;</span>
<span class="line-added">+                 while (buffer[pos] != &#39;Z&#39; &amp;&amp;</span>
<span class="line-added">+                         buffer[pos] != &#39;+&#39; &amp;&amp;</span>
<span class="line-added">+                         buffer[pos] != &#39;-&#39;) {</span>
<span class="line-added">+                     // Validate all digits in the fractional part but</span>
<span class="line-added">+                     // store millisecond precision only</span>
<span class="line-added">+                     int thisDigit = Character.digit((char)buffer[pos], 10);</span>
<span class="line-added">+                     precision++;</span>
<span class="line-added">+                     pos++;</span>
<span class="line-added">+                     switch (precision) {</span>
<span class="line-added">+                         case 1:</span>
<span class="line-added">+                             millis += 100 * thisDigit;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         case 2:</span>
<span class="line-added">+                             millis += 10 * thisDigit;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         case 3:</span>
<span class="line-added">+                             millis += thisDigit;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (precision == 0) {</span>
<span class="line-added">+                     throw new IOException(&quot;Parse &quot; + type +</span>
<span class="line-added">+                             &quot; time, empty fractional part&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 len -= precision;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             second = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (month == 0 || day == 0</span>
<span class="line-added">+                 || month &gt; 12 || day &gt; 31</span>
<span class="line-added">+                 || hour &gt;= 24 || minute &gt;= 60 || second &gt;= 60)</span>
<span class="line-added">+             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid format&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         /*</span>
<span class="line-added">+          * Generalized time can theoretically allow any precision,</span>
<span class="line-added">+          * but we&#39;re not supporting that.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         CalendarSystem gcal = CalendarSystem.getGregorianCalendar();</span>
<span class="line-added">+         CalendarDate date = gcal.newCalendarDate(null); // no time zone</span>
<span class="line-added">+         date.setDate(year, month, day);</span>
<span class="line-added">+         date.setTimeOfDay(hour, minute, second, millis);</span>
<span class="line-added">+         long time = gcal.getTime(date);</span>
<span class="line-added">+ </span>
<span class="line-added">+         /*</span>
<span class="line-added">+          * Finally, &quot;Z&quot; or &quot;+hhmm&quot; or &quot;-hhmm&quot; ... offsets change hhmm</span>
<span class="line-added">+          */</span>
<span class="line-added">+         if (! (len == 1 || len == 5))</span>
<span class="line-added">+             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid offset&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         int hr, min;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (buffer[pos++]) {</span>
<span class="line-added">+             case &#39;+&#39;:</span>
<span class="line-added">+                 hr = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+                 hr += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+                 min = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+                 min += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (hr &gt;= 24 || min &gt;= 60)</span>
<span class="line-added">+                     throw new IOException(&quot;Parse &quot; + type + &quot; time, +hhmm&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 time -= ((hr * 60) + min) * 60 * 1000;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             case &#39;-&#39;:</span>
<span class="line-added">+                 hr = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+                 hr += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+                 min = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+                 min += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (hr &gt;= 24 || min &gt;= 60)</span>
<span class="line-added">+                     throw new IOException(&quot;Parse &quot; + type + &quot; time, -hhmm&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 time += ((hr * 60) + min) * 60 * 1000;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             case &#39;Z&#39;:</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 throw new IOException(&quot;Parse &quot; + type + &quot; time, garbage offset&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return new Date(time);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void getNull() throws IOException {</span>
<span class="line-added">+         if (tag != tag_Null) {</span>
<span class="line-added">+             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (end != start) {</span>
<span class="line-added">+             throw new IOException(&quot;DER UTC Time length error&quot;);</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Returns a Date if the DerValue is UtcTime.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 747,11 ***</span>
       */
      public Date getUTCTime() throws IOException {
          if (tag != tag_UtcTime) {
              throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
          }
<span class="line-modified">!         return buffer.getUTCTime(data.available());</span>
      }
  
      /**
       * Returns a Date if the DerValue is GeneralizedTime.
       *
<span class="line-new-header">--- 952,15 ---</span>
       */
      public Date getUTCTime() throws IOException {
          if (tag != tag_UtcTime) {
              throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
          }
<span class="line-modified">!         if (end - start &lt; 11 || end - start &gt; 17)</span>
<span class="line-added">+             throw new IOException(&quot;DER UTC Time length error&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         return getTime(end - start, false);</span>
      }
  
      /**
       * Returns a Date if the DerValue is GeneralizedTime.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 760,11 ***</span>
      public Date getGeneralizedTime() throws IOException {
          if (tag != tag_GeneralizedTime) {
              throw new IOException(
                  &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
          }
<span class="line-modified">!         return buffer.getGeneralizedTime(data.available());</span>
      }
  
      /**
       * Bitwise equality comparison.  DER encoded values have a single
       * encoding, so that bitwise equality of the encoded values is an
<span class="line-new-header">--- 969,15 ---</span>
      public Date getGeneralizedTime() throws IOException {
          if (tag != tag_GeneralizedTime) {
              throw new IOException(
                  &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
          }
<span class="line-modified">!         if (end - start &lt; 13)</span>
<span class="line-added">+             throw new IOException(&quot;DER Generalized Time length error&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added">+         return getTime(end - start, true);</span>
      }
  
      /**
       * Bitwise equality comparison.  DER encoded values have a single
       * encoding, so that bitwise equality of the encoded values is an
</pre>
<hr />
<pre>
<span class="line-old-header">*** 782,71 ***</span>
          }
          DerValue other = (DerValue) o;
          if (tag != other.tag) {
              return false;
          }
<span class="line-modified">!         if (data == other.data) {</span>
              return true;
          }
<span class="line-modified">! </span>
<span class="line-removed">-         // make sure the order of lock is always consistent to avoid a deadlock</span>
<span class="line-removed">-         return (System.identityHashCode(this.data)</span>
<span class="line-removed">-                 &gt; System.identityHashCode(other.data)) ?</span>
<span class="line-removed">-                 doEquals(this, other):</span>
<span class="line-removed">-                 doEquals(other, this);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Helper for public method equals()</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static boolean doEquals(DerValue d1, DerValue d2) {</span>
<span class="line-removed">-         synchronized (d1.data) {</span>
<span class="line-removed">-             synchronized (d2.data) {</span>
<span class="line-removed">-                 d1.data.reset();</span>
<span class="line-removed">-                 d2.data.reset();</span>
<span class="line-removed">-                 return d1.buffer.equals(d2.buffer);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Returns a printable representation of the value.
       *
       * @return printable representation of the value
       */
      @Override
      public String toString() {
<span class="line-modified">!         try {</span>
<span class="line-modified">! </span>
<span class="line-removed">-             String str = getAsString();</span>
<span class="line-removed">-             if (str != null)</span>
<span class="line-removed">-                 return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;</span>
<span class="line-removed">-             if (tag == tag_Null)</span>
<span class="line-removed">-                 return &quot;[DerValue, null]&quot;;</span>
<span class="line-removed">-             if (tag == tag_ObjectId)</span>
<span class="line-removed">-                 return &quot;OID.&quot; + getOID();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // integers</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 return &quot;[DerValue, tag = &quot; + tag</span>
<span class="line-removed">-                         + &quot;, length = &quot; + length + &quot;]&quot;;</span>
<span class="line-removed">-         } catch (IOException e) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;misformatted DER value&quot;);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Returns a DER-encoded value, such that if it&#39;s passed to the
       * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
       *
       * @return DER-encoded value, including tag and length.
       */
      public byte[] toByteArray() throws IOException {
          DerOutputStream out = new DerOutputStream();
<span class="line-removed">- </span>
          encode(out);
<span class="line-modified">!         data.reset();</span>
          return out.toByteArray();
      }
  
      /**
       * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
<span class="line-new-header">--- 995,37 ---</span>
          }
          DerValue other = (DerValue) o;
          if (tag != other.tag) {
              return false;
          }
<span class="line-modified">!         if (buffer == other.buffer &amp;&amp; start == other.start &amp;&amp; end == other.end) {</span>
              return true;
          }
<span class="line-modified">!         return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);</span>
      }
  
      /**
       * Returns a printable representation of the value.
       *
       * @return printable representation of the value
       */
      @Override
      public String toString() {
<span class="line-modified">!         return String.format(&quot;DerValue(%02x, %s, %d, 5d)&quot;,</span>
<span class="line-modified">!                 0xff &amp; tag, buffer, start, end);</span>
      }
  
      /**
       * Returns a DER-encoded value, such that if it&#39;s passed to the
       * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
       *
       * @return DER-encoded value, including tag and length.
       */
      public byte[] toByteArray() throws IOException {
          DerOutputStream out = new DerOutputStream();
          encode(out);
<span class="line-modified">!         data.pos = data.start; // encode go last, should go back</span>
          return out.toByteArray();
      }
  
      /**
       * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
</pre>
<hr />
<pre>
<span class="line-old-header">*** 854,19 ***</span>
       * This operation is not supported for primitive types such as
       * integers or bit strings.
       */
      public DerInputStream toDerInputStream() throws IOException {
          if (tag == tag_Sequence || tag == tag_Set)
<span class="line-modified">!             return new DerInputStream(buffer);</span>
          throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
      }
  
      /**
       * Get the length of the encoded value.
       */
      public int length() {
<span class="line-modified">!         return length;</span>
      }
  
      /**
       * Determine if a character is one of the permissible characters for
       * PrintableString:
<span class="line-new-header">--- 1033,19 ---</span>
       * This operation is not supported for primitive types such as
       * integers or bit strings.
       */
      public DerInputStream toDerInputStream() throws IOException {
          if (tag == tag_Sequence || tag == tag_Set)
<span class="line-modified">!             return data;</span>
          throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
      }
  
      /**
       * Get the length of the encoded value.
       */
      public int length() {
<span class="line-modified">!         return end - start;</span>
      }
  
      /**
       * Determine if a character is one of the permissible characters for
       * PrintableString:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 943,6 ***</span>
<span class="line-new-header">--- 1122,18 ---</span>
       */
      @Override
      public int hashCode() {
          return toString().hashCode();
      }
<span class="line-added">+ </span>
<span class="line-added">+     public DerValue[] subs(byte expectedTag) throws IOException {</span>
<span class="line-added">+         if (expectedTag != 0 &amp;&amp; expectedTag != tag) {</span>
<span class="line-added">+             throw new IOException(&quot;Not constructed&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         List&lt;DerValue&gt; result = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         DerInputStream dis = new DerInputStream(this);</span>
<span class="line-added">+         while (dis.available() &gt; 0) {</span>
<span class="line-added">+             result.add(dis.getDerValue());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return result.toArray(new DerValue[result.size()]);</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="DerInputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
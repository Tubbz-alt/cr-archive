<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DerInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
<a name="1" id="anc1"></a>
 30 import java.math.BigInteger;
 31 import java.nio.charset.Charset;
<a name="2" id="anc2"></a>
 32 import java.util.Date;
<a name="3" id="anc3"></a>
 33 import java.util.Vector;
 34 
 35 import static java.nio.charset.StandardCharsets.*;
 36 
 37 /**
 38  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 39  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 40  * the advantage that it allows only a single encoding of primitive data.
 41  * (High level data such as dates still support many encodings.)  That is,
 42  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 43  *
 44  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 45  * tagged data values.  Accordingly, this programming interface does
 46  * not expose any variant of the java.io.InputStream interface, since
 47  * that kind of input stream holds untagged data values and using that
 48  * I/O model could prevent correct parsing of the DER data.
 49  *
 50  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 51  * data encodings which are defined.  That subset is sufficient for parsing
 52  * most X.509 certificates.
 53  *
 54  *
 55  * @author David Brownell
 56  * @author Amit Kapoor
 57  * @author Hemma Prafullchandra
 58  */
 59 
<a name="4" id="anc4"></a><span class="line-modified"> 60 public class DerInputStream {</span>
 61 
<a name="5" id="anc5"></a><span class="line-modified"> 62     /*</span>
<span class="line-modified"> 63      * This version only supports fully buffered DER.  This is easy to</span>
<span class="line-modified"> 64      * work with, though if large objects are manipulated DER becomes</span>
<span class="line-modified"> 65      * awkward to deal with.  That&#39;s where BER is useful, since BER</span>
<span class="line-modified"> 66      * handles streaming data relatively well.</span>
<span class="line-removed"> 67      */</span>
<span class="line-removed"> 68     DerInputBuffer      buffer;</span>
 69 
<a name="6" id="anc6"></a><span class="line-modified"> 70     /** The DER tag of the value; one of the tag_ constants. */</span>
<span class="line-modified"> 71     public byte         tag;</span>





 72 
<a name="7" id="anc7"></a><span class="line-modified"> 73     /**</span>
<span class="line-modified"> 74      * Create a DER input stream from a data buffer.  The buffer is not</span>
<span class="line-modified"> 75      * copied, it is shared.  Accordingly, the buffer should be treated</span>
<span class="line-modified"> 76      * as read-only.</span>
<span class="line-modified"> 77      *</span>
<span class="line-modified"> 78      * @param data the buffer from which to create the string (CONSUMED)</span>
<span class="line-modified"> 79      */</span>
<span class="line-modified"> 80     public DerInputStream(byte[] data) throws IOException {</span>
<span class="line-modified"> 81         init(data, 0, data.length, true);</span>


 82     }
 83 
<a name="8" id="anc8"></a><span class="line-modified"> 84     /**</span>
<span class="line-modified"> 85      * Create a DER input stream from part of a data buffer with</span>
<span class="line-modified"> 86      * additional arg to control whether DER checks are enforced.</span>
<span class="line-modified"> 87      * The buffer is not copied, it is shared.  Accordingly, the</span>
<span class="line-modified"> 88      * buffer should be treated as read-only.</span>
<span class="line-modified"> 89      *</span>
<span class="line-removed"> 90      * @param data the buffer from which to create the string (CONSUMED)</span>
<span class="line-removed"> 91      * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will</span>
<span class="line-removed"> 92      *          be read as DER input in the new stream</span>
<span class="line-removed"> 93      * @param len how long a chunk of the buffer to use,</span>
<span class="line-removed"> 94      *          starting at &quot;offset&quot;</span>
<span class="line-removed"> 95      * @param allowBER whether to allow constructed indefinite-length</span>
<span class="line-removed"> 96      *          encoding as well as tolerate leading 0s</span>
<span class="line-removed"> 97      */</span>
<span class="line-removed"> 98     public DerInputStream(byte[] data, int offset, int len,</span>
<span class="line-removed"> 99         boolean allowBER) throws IOException {</span>
<span class="line-removed">100         init(data, offset, len, allowBER);</span>
101     }
102 
<a name="9" id="anc9"></a><span class="line-modified">103     /**</span>
<span class="line-modified">104      * Create a DER input stream from part of a data buffer.</span>
<span class="line-removed">105      * The buffer is not copied, it is shared.  Accordingly, the</span>
<span class="line-removed">106      * buffer should be treated as read-only.</span>
<span class="line-removed">107      *</span>
<span class="line-removed">108      * @param data the buffer from which to create the string (CONSUMED)</span>
<span class="line-removed">109      * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will</span>
<span class="line-removed">110      *          be read as DER input in the new stream</span>
<span class="line-removed">111      * @param len how long a chunk of the buffer to use,</span>
<span class="line-removed">112      *          starting at &quot;offset&quot;</span>
<span class="line-removed">113      */</span>
<span class="line-removed">114     public DerInputStream(byte[] data, int offset, int len) throws IOException {</span>
<span class="line-removed">115         init(data, offset, len, true);</span>
116     }
117 
<a name="10" id="anc10"></a><span class="line-modified">118     /*</span>
<span class="line-modified">119      * private helper routine</span>
<span class="line-removed">120      */</span>
<span class="line-removed">121     private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {</span>
<span class="line-removed">122         if ((offset+2 &gt; data.length) || (offset+len &gt; data.length)) {</span>
<span class="line-removed">123             throw new IOException(&quot;Encoding bytes too short&quot;);</span>
<span class="line-removed">124         }</span>
<span class="line-removed">125         // check for indefinite length encoding</span>
<span class="line-removed">126         if (DerIndefLenConverter.isIndefinite(data[offset+1])) {</span>
<span class="line-removed">127             if (!allowBER) {</span>
<span class="line-removed">128                 throw new IOException(&quot;Indefinite length BER encoding found&quot;);</span>
<span class="line-removed">129             } else {</span>
<span class="line-removed">130                 byte[] inData = new byte[len];</span>
<span class="line-removed">131                 System.arraycopy(data, offset, inData, 0, len);</span>
<span class="line-removed">132 </span>
<span class="line-removed">133                 DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-removed">134                 byte[] result = derIn.convertBytes(inData);</span>
<span class="line-removed">135                 if (result == null) {</span>
<span class="line-removed">136                     throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="line-removed">137                 } else {</span>
<span class="line-removed">138                     buffer = new DerInputBuffer(result, allowBER);</span>
<span class="line-removed">139                 }</span>
<span class="line-removed">140             }</span>
<span class="line-removed">141         } else {</span>
<span class="line-removed">142             buffer = new DerInputBuffer(data, offset, len, allowBER);</span>
<span class="line-removed">143         }</span>
<span class="line-removed">144         buffer.mark(Integer.MAX_VALUE);</span>
<span class="line-removed">145     }</span>
<span class="line-removed">146 </span>
<span class="line-removed">147     DerInputStream(DerInputBuffer buf) {</span>
<span class="line-removed">148         buffer = buf;</span>
<span class="line-removed">149         buffer.mark(Integer.MAX_VALUE);</span>
150     }
151 
<a name="11" id="anc11"></a><span class="line-modified">152     /**</span>
<span class="line-modified">153      * Creates a new DER input stream from part of this input stream.</span>
<span class="line-removed">154      *</span>
<span class="line-removed">155      * @param len how long a chunk of the current input stream to use,</span>
<span class="line-removed">156      *          starting at the current position.</span>
<span class="line-removed">157      * @param do_skip true if the existing data in the input stream should</span>
<span class="line-removed">158      *          be skipped.  If this value is false, the next data read</span>
<span class="line-removed">159      *          on this stream and the newly created stream will be the</span>
<span class="line-removed">160      *          same.</span>
<span class="line-removed">161      */</span>
<span class="line-removed">162     public DerInputStream subStream(int len, boolean do_skip)</span>
<span class="line-removed">163     throws IOException {</span>
<span class="line-removed">164         DerInputBuffer newbuf = buffer.dup();</span>
<span class="line-removed">165 </span>
<span class="line-removed">166         newbuf.truncate(len);</span>
<span class="line-removed">167         if (do_skip) {</span>
<span class="line-removed">168             buffer.skip(len);</span>
<span class="line-removed">169         }</span>
<span class="line-removed">170         return new DerInputStream(newbuf);</span>
171     }
172 
<a name="12" id="anc12"></a><span class="line-removed">173     /**</span>
<span class="line-removed">174      * Return what has been written to this DerInputStream</span>
<span class="line-removed">175      * as a byte array. Useful for debugging.</span>
<span class="line-removed">176      */</span>
177     public byte[] toByteArray() {
<a name="13" id="anc13"></a><span class="line-modified">178         return buffer.toByteArray();</span>
179     }
180 
<a name="14" id="anc14"></a><span class="line-removed">181     /*</span>
<span class="line-removed">182      * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.</span>
<span class="line-removed">183      *</span>
<span class="line-removed">184      *  INTEGER, ENUMERATED, BIT STRING, OCTET STRING, NULL</span>
<span class="line-removed">185      *  OBJECT IDENTIFIER, SEQUENCE (OF), SET (OF)</span>
<span class="line-removed">186      *  UTF8String, PrintableString, T61String, IA5String, UTCTime,</span>
<span class="line-removed">187      *  GeneralizedTime, BMPString.</span>
<span class="line-removed">188      * Note: UniversalString not supported till encoder is available.</span>
<span class="line-removed">189      */</span>
<span class="line-removed">190 </span>
<span class="line-removed">191     /**</span>
<span class="line-removed">192      * Get an integer from the input stream as an integer.</span>
<span class="line-removed">193      *</span>
<span class="line-removed">194      * @return the integer held in this DER input stream.</span>
<span class="line-removed">195      */</span>
196     public int getInteger() throws IOException {
<a name="15" id="anc15"></a><span class="line-modified">197         if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="line-removed">198             throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
<span class="line-removed">199         }</span>
<span class="line-removed">200         return buffer.getInteger(getDefiniteLength(buffer));</span>
201     }
202 
<a name="16" id="anc16"></a><span class="line-removed">203     /**</span>
<span class="line-removed">204      * Get a integer from the input stream as a BigInteger object.</span>
<span class="line-removed">205      *</span>
<span class="line-removed">206      * @return the integer held in this DER input stream.</span>
<span class="line-removed">207      */</span>
208     public BigInteger getBigInteger() throws IOException {
<a name="17" id="anc17"></a><span class="line-modified">209         if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="line-removed">210             throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
<span class="line-removed">211         }</span>
<span class="line-removed">212         return buffer.getBigInteger(getDefiniteLength(buffer), false);</span>
213     }
214 
<a name="18" id="anc18"></a><span class="line-removed">215     /**</span>
<span class="line-removed">216      * Returns an ASN.1 INTEGER value as a positive BigInteger.</span>
<span class="line-removed">217      * This is just to deal with implementations that incorrectly encode</span>
<span class="line-removed">218      * some values as negative.</span>
<span class="line-removed">219      *</span>
<span class="line-removed">220      * @return the integer held in this DER value as a BigInteger.</span>
<span class="line-removed">221      */</span>
222     public BigInteger getPositiveBigInteger() throws IOException {
<a name="19" id="anc19"></a><span class="line-modified">223         if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="line-removed">224             throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
<span class="line-removed">225         }</span>
<span class="line-removed">226         return buffer.getBigInteger(getDefiniteLength(buffer), true);</span>
227     }
228 
<a name="20" id="anc20"></a><span class="line-removed">229     /**</span>
<span class="line-removed">230      * Get an enumerated from the input stream.</span>
<span class="line-removed">231      *</span>
<span class="line-removed">232      * @return the integer held in this DER input stream.</span>
<span class="line-removed">233      */</span>
234     public int getEnumerated() throws IOException {
<a name="21" id="anc21"></a><span class="line-modified">235         if (buffer.read() != DerValue.tag_Enumerated) {</span>
<span class="line-removed">236             throw new IOException(&quot;DER input, Enumerated tag error&quot;);</span>
<span class="line-removed">237         }</span>
<span class="line-removed">238         return buffer.getInteger(getDefiniteLength(buffer));</span>
239     }
240 
<a name="22" id="anc22"></a><span class="line-removed">241     /**</span>
<span class="line-removed">242      * Get a bit string from the input stream. Padded bits (if any)</span>
<span class="line-removed">243      * will be stripped off before the bit string is returned.</span>
<span class="line-removed">244      */</span>
245     public byte[] getBitString() throws IOException {
<a name="23" id="anc23"></a><span class="line-modified">246         if (buffer.read() != DerValue.tag_BitString)</span>
<span class="line-removed">247             throw new IOException(&quot;DER input not an bit string&quot;);</span>
<span class="line-removed">248 </span>
<span class="line-removed">249         return buffer.getBitString(getDefiniteLength(buffer));</span>
250     }
251 
<a name="24" id="anc24"></a><span class="line-removed">252     /**</span>
<span class="line-removed">253      * Get a bit string from the input stream.  The bit string need</span>
<span class="line-removed">254      * not be byte-aligned.</span>
<span class="line-removed">255      */</span>
256     public BitArray getUnalignedBitString() throws IOException {
<a name="25" id="anc25"></a><span class="line-modified">257         if (buffer.read() != DerValue.tag_BitString) {</span>
<span class="line-removed">258             throw new IOException(&quot;DER input not a bit string&quot;);</span>
<span class="line-removed">259         }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261         int length = getDefiniteLength(buffer);</span>
<span class="line-removed">262 </span>
<span class="line-removed">263         if (length == 0) {</span>
<span class="line-removed">264             return new BitArray(0);</span>
<span class="line-removed">265         }</span>
<span class="line-removed">266 </span>
<span class="line-removed">267         /*</span>
<span class="line-removed">268          * First byte = number of excess bits in the last octet of the</span>
<span class="line-removed">269          * representation.</span>
<span class="line-removed">270          */</span>
<span class="line-removed">271         length--;</span>
<span class="line-removed">272         int excessBits = buffer.read();</span>
<span class="line-removed">273         if (excessBits &lt; 0) {</span>
<span class="line-removed">274             throw new IOException(&quot;Unused bits of bit string invalid&quot;);</span>
<span class="line-removed">275         }</span>
<span class="line-removed">276         int validBits = length*8 - excessBits;</span>
<span class="line-removed">277         if (validBits &lt; 0) {</span>
<span class="line-removed">278             throw new IOException(&quot;Valid bits of bit string invalid&quot;);</span>
<span class="line-removed">279         }</span>
<span class="line-removed">280 </span>
<span class="line-removed">281         byte[] repn = new byte[length];</span>
<span class="line-removed">282 </span>
<span class="line-removed">283         if ((length != 0) &amp;&amp; (buffer.read(repn) != length)) {</span>
<span class="line-removed">284             throw new IOException(&quot;Short read of DER bit string&quot;);</span>
<span class="line-removed">285         }</span>
<span class="line-removed">286 </span>
<span class="line-removed">287         return new BitArray(validBits, repn);</span>
288     }
289 
<a name="26" id="anc26"></a><span class="line-removed">290     /**</span>
<span class="line-removed">291      * Returns an ASN.1 OCTET STRING from the input stream.</span>
<span class="line-removed">292      */</span>
293     public byte[] getOctetString() throws IOException {
<a name="27" id="anc27"></a><span class="line-modified">294         if (buffer.read() != DerValue.tag_OctetString)</span>
<span class="line-removed">295             throw new IOException(&quot;DER input not an octet string&quot;);</span>
<span class="line-removed">296 </span>
<span class="line-removed">297         int length = getDefiniteLength(buffer);</span>
<span class="line-removed">298         byte[] retval = new byte[length];</span>
<span class="line-removed">299         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))</span>
<span class="line-removed">300             throw new IOException(&quot;Short read of DER octet string&quot;);</span>
<span class="line-removed">301 </span>
<span class="line-removed">302         return retval;</span>
<span class="line-removed">303     }</span>
<span class="line-removed">304 </span>
<span class="line-removed">305     /**</span>
<span class="line-removed">306      * Returns the asked number of bytes from the input stream.</span>
<span class="line-removed">307      */</span>
<span class="line-removed">308     public void getBytes(byte[] val) throws IOException {</span>
<span class="line-removed">309         if ((val.length != 0) &amp;&amp; (buffer.read(val) != val.length)) {</span>
<span class="line-removed">310             throw new IOException(&quot;Short read of DER octet string&quot;);</span>
<span class="line-removed">311         }</span>
312     }
313 
<a name="28" id="anc28"></a><span class="line-removed">314     /**</span>
<span class="line-removed">315      * Reads an encoded null value from the input stream.</span>
<span class="line-removed">316      */</span>
317     public void getNull() throws IOException {
<a name="29" id="anc29"></a><span class="line-modified">318         if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)</span>
<span class="line-removed">319             throw new IOException(&quot;getNull, bad data&quot;);</span>
320     }
321 
<a name="30" id="anc30"></a><span class="line-removed">322     /**</span>
<span class="line-removed">323      * Reads an X.200 style Object Identifier from the stream.</span>
<span class="line-removed">324      */</span>
325     public ObjectIdentifier getOID() throws IOException {
<a name="31" id="anc31"></a><span class="line-modified">326         return new ObjectIdentifier(this);</span>
327     }
328 
<a name="32" id="anc32"></a><span class="line-removed">329     /**</span>
<span class="line-removed">330      * Return a sequence of encoded entities.  ASN.1 sequences are</span>
<span class="line-removed">331      * ordered, and they are often used, like a &quot;struct&quot; in C or C++,</span>
<span class="line-removed">332      * to group data values.  They may have optional or context</span>
<span class="line-removed">333      * specific values.</span>
<span class="line-removed">334      *</span>
<span class="line-removed">335      * @param startLen guess about how long the sequence will be</span>
<span class="line-removed">336      *          (used to initialize an auto-growing data structure)</span>
<span class="line-removed">337      * @return array of the values in the sequence</span>
<span class="line-removed">338      */</span>
339     public DerValue[] getSequence(int startLen) throws IOException {
<a name="33" id="anc33"></a><span class="line-modified">340         tag = (byte)buffer.read();</span>
<span class="line-removed">341         if (tag != DerValue.tag_Sequence)</span>
<span class="line-removed">342             throw new IOException(&quot;Sequence tag error&quot;);</span>
<span class="line-removed">343         return readVector(startLen);</span>
344     }
345 
<a name="34" id="anc34"></a><span class="line-removed">346     /**</span>
<span class="line-removed">347      * Return a set of encoded entities.  ASN.1 sets are unordered,</span>
<span class="line-removed">348      * though DER may specify an order for some kinds of sets (such</span>
<span class="line-removed">349      * as the attributes in an X.500 relative distinguished name)</span>
<span class="line-removed">350      * to facilitate binary comparisons of encoded values.</span>
<span class="line-removed">351      *</span>
<span class="line-removed">352      * @param startLen guess about how large the set will be</span>
<span class="line-removed">353      *          (used to initialize an auto-growing data structure)</span>
<span class="line-removed">354      * @return array of the values in the sequence</span>
<span class="line-removed">355      */</span>
356     public DerValue[] getSet(int startLen) throws IOException {
<a name="35" id="anc35"></a><span class="line-modified">357         tag = (byte)buffer.read();</span>
<span class="line-removed">358         if (tag != DerValue.tag_Set)</span>
<span class="line-removed">359             throw new IOException(&quot;Set tag error&quot;);</span>
<span class="line-removed">360         return readVector(startLen);</span>
361     }
362 
<a name="36" id="anc36"></a><span class="line-modified">363     /**</span>
<span class="line-modified">364      * Return a set of encoded entities.  ASN.1 sets are unordered,</span>
<span class="line-removed">365      * though DER may specify an order for some kinds of sets (such</span>
<span class="line-removed">366      * as the attributes in an X.500 relative distinguished name)</span>
<span class="line-removed">367      * to facilitate binary comparisons of encoded values.</span>
<span class="line-removed">368      *</span>
<span class="line-removed">369      * @param startLen guess about how large the set will be</span>
<span class="line-removed">370      *          (used to initialize an auto-growing data structure)</span>
<span class="line-removed">371      * @param implicit if true tag is assumed implicit.</span>
<span class="line-removed">372      * @return array of the values in the sequence</span>
<span class="line-removed">373      */</span>
<span class="line-removed">374     public DerValue[] getSet(int startLen, boolean implicit)</span>
<span class="line-removed">375         throws IOException {</span>
<span class="line-removed">376         tag = (byte)buffer.read();</span>
<span class="line-removed">377         if (!implicit) {</span>
<span class="line-removed">378             if (tag != DerValue.tag_Set) {</span>
<span class="line-removed">379                 throw new IOException(&quot;Set tag error&quot;);</span>
<span class="line-removed">380             }</span>
<span class="line-removed">381         }</span>
<span class="line-removed">382         return (readVector(startLen));</span>
383     }
384 
<a name="37" id="anc37"></a><span class="line-removed">385     /*</span>
<span class="line-removed">386      * Read a &quot;vector&quot; of values ... set or sequence have the</span>
<span class="line-removed">387      * same encoding, except for the initial tag, so both use</span>
<span class="line-removed">388      * this same helper routine.</span>
<span class="line-removed">389      */</span>
<span class="line-removed">390     protected DerValue[] readVector(int startLen) throws IOException {</span>
<span class="line-removed">391         DerInputStream  newstr;</span>
<span class="line-removed">392 </span>
<span class="line-removed">393         byte lenByte = (byte)buffer.read();</span>
<span class="line-removed">394         int len = getLength(lenByte, buffer);</span>
<span class="line-removed">395 </span>
<span class="line-removed">396         if (len == -1) {</span>
<span class="line-removed">397            // indefinite length encoding found</span>
<span class="line-removed">398            buffer = new DerInputBuffer(</span>
<span class="line-removed">399                    DerIndefLenConverter.convertStream(buffer, lenByte, tag),</span>
<span class="line-removed">400                    buffer.allowBER);</span>
<span class="line-removed">401 </span>
<span class="line-removed">402            if (tag != buffer.read())</span>
<span class="line-removed">403                 throw new IOException(&quot;Indefinite length encoding&quot; +</span>
<span class="line-removed">404                         &quot; not supported&quot;);</span>
<span class="line-removed">405            len = DerInputStream.getDefiniteLength(buffer);</span>
<span class="line-removed">406         }</span>
<span class="line-removed">407 </span>
<span class="line-removed">408         if (len == 0)</span>
<span class="line-removed">409             // return empty array instead of null, which should be</span>
<span class="line-removed">410             // used only for missing optionals</span>
<span class="line-removed">411             return new DerValue[0];</span>
<span class="line-removed">412 </span>
<span class="line-removed">413         /*</span>
<span class="line-removed">414          * Create a temporary stream from which to read the data,</span>
<span class="line-removed">415          * unless it&#39;s not really needed.</span>
<span class="line-removed">416          */</span>
<span class="line-removed">417         if (buffer.available() == len)</span>
<span class="line-removed">418             newstr = this;</span>
<span class="line-removed">419         else</span>
<span class="line-removed">420             newstr = subStream(len, true);</span>
<span class="line-removed">421 </span>
<span class="line-removed">422         /*</span>
<span class="line-removed">423          * Pull values out of the stream.</span>
<span class="line-removed">424          */</span>
<span class="line-removed">425         Vector&lt;DerValue&gt; vec = new Vector&lt;&gt;(startLen);</span>
<span class="line-removed">426         DerValue value;</span>
<span class="line-removed">427 </span>
<span class="line-removed">428         do {</span>
<span class="line-removed">429             value = new DerValue(newstr.buffer, buffer.allowBER);</span>
<span class="line-removed">430             vec.addElement(value);</span>
<span class="line-removed">431         } while (newstr.available() &gt; 0);</span>
<span class="line-removed">432 </span>
<span class="line-removed">433         if (newstr.available() != 0)</span>
<span class="line-removed">434             throw new IOException(&quot;Extra data at end of vector&quot;);</span>
<span class="line-removed">435 </span>
<span class="line-removed">436         /*</span>
<span class="line-removed">437          * Now stick them into the array we&#39;re returning.</span>
<span class="line-removed">438          */</span>
<span class="line-removed">439         int             i, max = vec.size();</span>
<span class="line-removed">440         DerValue[]      retval = new DerValue[max];</span>
<span class="line-removed">441 </span>
<span class="line-removed">442         for (i = 0; i &lt; max; i++)</span>
<span class="line-removed">443             retval[i] = vec.elementAt(i);</span>
<span class="line-removed">444 </span>
<span class="line-removed">445         return retval;</span>
<span class="line-removed">446     }</span>
<span class="line-removed">447 </span>
<span class="line-removed">448     /**</span>
<span class="line-removed">449      * Get a single DER-encoded value from the input stream.</span>
<span class="line-removed">450      * It can often be useful to pull a value from the stream</span>
<span class="line-removed">451      * and defer parsing it.  For example, you can pull a nested</span>
<span class="line-removed">452      * sequence out with one call, and only examine its elements</span>
<span class="line-removed">453      * later when you really need to.</span>
<span class="line-removed">454      */</span>
455     public DerValue getDerValue() throws IOException {
<a name="38" id="anc38"></a><span class="line-modified">456         return new DerValue(buffer);</span>



457     }
458 
<a name="39" id="anc39"></a><span class="line-removed">459     /**</span>
<span class="line-removed">460      * Read a string that was encoded as a UTF8String DER value.</span>
<span class="line-removed">461      */</span>
462     public String getUTF8String() throws IOException {
<a name="40" id="anc40"></a><span class="line-modified">463         return readString(DerValue.tag_UTF8String, &quot;UTF-8&quot;, UTF_8);</span>
464     }
465 
<a name="41" id="anc41"></a><span class="line-removed">466     /**</span>
<span class="line-removed">467      * Read a string that was encoded as a PrintableString DER value.</span>
<span class="line-removed">468      */</span>
469     public String getPrintableString() throws IOException {
<a name="42" id="anc42"></a><span class="line-modified">470         return readString(DerValue.tag_PrintableString, &quot;Printable&quot;,</span>
<span class="line-removed">471                           US_ASCII);</span>
472     }
473 
<a name="43" id="anc43"></a><span class="line-removed">474     /**</span>
<span class="line-removed">475      * Read a string that was encoded as a T61String DER value.</span>
<span class="line-removed">476      */</span>
477     public String getT61String() throws IOException {
<a name="44" id="anc44"></a><span class="line-modified">478         /*</span>
<span class="line-removed">479          * Works for common characters between T61 and ASCII.</span>
<span class="line-removed">480          */</span>
<span class="line-removed">481         return readString(DerValue.tag_T61String, &quot;T61&quot;, ISO_8859_1);</span>
<span class="line-removed">482     }</span>
<span class="line-removed">483 </span>
<span class="line-removed">484     /**</span>
<span class="line-removed">485      * Read a string that was encoded as a IA5String DER value.</span>
<span class="line-removed">486      */</span>
<span class="line-removed">487     public String getIA5String() throws IOException {</span>
<span class="line-removed">488         return readString(DerValue.tag_IA5String, &quot;IA5&quot;, US_ASCII);</span>
489     }
490 
<a name="45" id="anc45"></a><span class="line-removed">491     /**</span>
<span class="line-removed">492      * Read a string that was encoded as a BMPString DER value.</span>
<span class="line-removed">493      */</span>
494     public String getBMPString() throws IOException {
<a name="46" id="anc46"></a><span class="line-modified">495         return readString(DerValue.tag_BMPString, &quot;BMP&quot;, UTF_16BE);</span>
496     }
497 
<a name="47" id="anc47"></a><span class="line-modified">498     /**</span>
<span class="line-modified">499      * Read a string that was encoded as a GeneralString DER value.</span>
<span class="line-removed">500      */</span>
<span class="line-removed">501     public String getGeneralString() throws IOException {</span>
<span class="line-removed">502         return readString(DerValue.tag_GeneralString, &quot;General&quot;,</span>
<span class="line-removed">503                           US_ASCII);</span>
504     }
505 
<a name="48" id="anc48"></a><span class="line-modified">506     /**</span>
<span class="line-modified">507      * Private helper routine to read an encoded string from the input</span>
<span class="line-removed">508      * stream.</span>
<span class="line-removed">509      * @param stringTag the tag for the type of string to read</span>
<span class="line-removed">510      * @param stringName a name to display in error messages</span>
<span class="line-removed">511      * @param enc the encoder to use to interpret the data. Should</span>
<span class="line-removed">512      * correspond to the stringTag above.</span>
<span class="line-removed">513      */</span>
<span class="line-removed">514     private String readString(byte stringTag, String stringName,</span>
<span class="line-removed">515                               Charset charset) throws IOException {</span>
<span class="line-removed">516 </span>
<span class="line-removed">517         if (buffer.read() != stringTag)</span>
<span class="line-removed">518             throw new IOException(&quot;DER input not a &quot; +</span>
<span class="line-removed">519                                   stringName + &quot; string&quot;);</span>
<span class="line-removed">520 </span>
<span class="line-removed">521         int length = getDefiniteLength(buffer);</span>
<span class="line-removed">522         byte[] retval = new byte[length];</span>
<span class="line-removed">523         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))</span>
<span class="line-removed">524             throw new IOException(&quot;Short read of DER &quot; +</span>
<span class="line-removed">525                                   stringName + &quot; string&quot;);</span>
<span class="line-removed">526 </span>
<span class="line-removed">527         return new String(retval, charset);</span>
528     }
529 
<a name="49" id="anc49"></a><span class="line-removed">530     /**</span>
<span class="line-removed">531      * Get a UTC encoded time value from the input stream.</span>
<span class="line-removed">532      */</span>
533     public Date getUTCTime() throws IOException {
<a name="50" id="anc50"></a><span class="line-modified">534         if (buffer.read() != DerValue.tag_UtcTime)</span>
<span class="line-removed">535             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);</span>
<span class="line-removed">536         return buffer.getUTCTime(getDefiniteLength(buffer));</span>
537     }
538 
<a name="51" id="anc51"></a><span class="line-removed">539     /**</span>
<span class="line-removed">540      * Get a Generalized encoded time value from the input stream.</span>
<span class="line-removed">541      */</span>
542     public Date getGeneralizedTime() throws IOException {
<a name="52" id="anc52"></a><span class="line-modified">543         if (buffer.read() != DerValue.tag_GeneralizedTime)</span>
<span class="line-removed">544             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);</span>
<span class="line-removed">545         return buffer.getGeneralizedTime(getDefiniteLength(buffer));</span>
<span class="line-removed">546     }</span>
<span class="line-removed">547 </span>
<span class="line-removed">548     /*</span>
<span class="line-removed">549      * Get a byte from the input stream.</span>
<span class="line-removed">550      */</span>
<span class="line-removed">551     // package private</span>
<span class="line-removed">552     int getByte() throws IOException {</span>
<span class="line-removed">553         return (0x00ff &amp; buffer.read());</span>
554     }
555 
556     public int peekByte() throws IOException {
<a name="53" id="anc53"></a><span class="line-modified">557         return buffer.peek();</span>
<span class="line-modified">558     }</span>
<span class="line-modified">559 </span>
<span class="line-modified">560     // package private</span>
<span class="line-removed">561     int getLength() throws IOException {</span>
<span class="line-removed">562         return getLength(buffer);</span>
563     }
564 
<a name="54" id="anc54"></a><span class="line-removed">565     /*</span>
<span class="line-removed">566      * Get a length from the input stream, allowing for at most 32 bits of</span>
<span class="line-removed">567      * encoding to be used.  (Not the same as getting a tagged integer!)</span>
<span class="line-removed">568      *</span>
<span class="line-removed">569      * @return the length or -1 if indefinite length found.</span>
<span class="line-removed">570      * @exception IOException on parsing error or unsupported lengths.</span>
<span class="line-removed">571      */</span>
572     static int getLength(InputStream in) throws IOException {
573         return getLength(in.read(), in);
574     }
575 
576     /*
577      * Get a length from the input stream, allowing for at most 32 bits of
578      * encoding to be used.  (Not the same as getting a tagged integer!)
579      *
580      * @return the length or -1 if indefinite length found.
581      * @exception IOException on parsing error or unsupported lengths.
582      */
583     static int getLength(int lenByte, InputStream in) throws IOException {
584         int value, tmp;
585         if (lenByte == -1) {
586             throw new IOException(&quot;Short read of DER length&quot;);
587         }
588 
589         String mdName = &quot;DerInputStream.getLength(): &quot;;
590         tmp = lenByte;
591         if ((tmp &amp; 0x080) == 0x00) { // short form, 1 byte datum
592             value = tmp;
593         } else {                     // long form or indefinite
594             tmp &amp;= 0x07f;
595 
596             /*
597              * NOTE:  tmp == 0 indicates indefinite length encoded data.
598              * tmp &gt; 4 indicates more than 4Gb of data.
599              */
600             if (tmp == 0)
601                 return -1;
602             if (tmp &lt; 0 || tmp &gt; 4)
603                 throw new IOException(mdName + &quot;lengthTag=&quot; + tmp + &quot;, &quot;
604                     + ((tmp &lt; 0) ? &quot;incorrect DER encoding.&quot; : &quot;too big.&quot;));
605 
606             value = 0x0ff &amp; in.read();
607             tmp--;
608             if (value == 0) {
609                 // DER requires length value be encoded in minimum number of bytes
610                 throw new IOException(mdName + &quot;Redundant length bytes found&quot;);
611             }
612             while (tmp-- &gt; 0) {
613                 value &lt;&lt;= 8;
614                 value += 0x0ff &amp; in.read();
615             }
616             if (value &lt; 0) {
617                 throw new IOException(mdName + &quot;Invalid length bytes&quot;);
618             } else if (value &lt;= 127) {
619                 throw new IOException(mdName + &quot;Should use short form for length&quot;);
620             }
621         }
622         return value;
623     }
624 
<a name="55" id="anc55"></a><span class="line-removed">625     int getDefiniteLength() throws IOException {</span>
<span class="line-removed">626         return getDefiniteLength(buffer);</span>
<span class="line-removed">627     }</span>
<span class="line-removed">628 </span>
629     /*
630      * Get a length from the input stream.
631      *
632      * @return the length
633      * @exception IOException on parsing error or if indefinite length found.
634      */
635     static int getDefiniteLength(InputStream in) throws IOException {
636         int len = getLength(in);
637         if (len &lt; 0) {
638             throw new IOException(&quot;Indefinite length encoding not supported&quot;);
639         }
640         return len;
641     }
642 
<a name="56" id="anc56"></a><span class="line-removed">643     /**</span>
<span class="line-removed">644      * Mark the current position in the buffer, so that</span>
<span class="line-removed">645      * a later call to &lt;code&gt;reset&lt;/code&gt; will return here.</span>
<span class="line-removed">646      */</span>
<span class="line-removed">647     public void mark(int value) { buffer.mark(value); }</span>
<span class="line-removed">648 </span>
<span class="line-removed">649 </span>
650     /**
651      * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
652      * call.  A mark is implicitly set at the beginning of
653      * the stream when it is created.
654      */
<a name="57" id="anc57"></a><span class="line-modified">655     public void reset() { buffer.reset(); }</span>

656 
657 
658     /**
659      * Returns the number of bytes available for reading.
660      * This is most useful for testing whether the stream is
661      * empty.
662      */
<a name="58" id="anc58"></a><span class="line-modified">663     public int available() { return buffer.available(); }</span>
664 }
<a name="59" id="anc59"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="59" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /**
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.util;
  27 
<a name="2" id="anc2"></a><span class="line-added">  28 import sun.util.calendar.CalendarDate;</span>
<span class="line-added">  29 import sun.util.calendar.CalendarSystem;</span>
<span class="line-added">  30 </span>
  31 import java.io.*;
  32 import java.math.BigInteger;
  33 import java.nio.charset.Charset;
<a name="3" id="anc3"></a><span class="line-modified">  34 import java.nio.charset.IllegalCharsetNameException;</span>
<span class="line-added">  35 import java.nio.charset.UnsupportedCharsetException;</span>
<span class="line-added">  36 import java.util.*;</span>
  37 
  38 import static java.nio.charset.StandardCharsets.*;
  39 
  40 /**
  41  * Represents a single DER-encoded value.  DER encoding rules are a subset
  42  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
  43  * (&quot;Definite&quot; encoding) to encode any given value.
  44  *
  45  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
  46  * class represents such tagged values as they have been read (or constructed),
  47  * and provides structured access to the encoded data.
  48  *
  49  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
  50  * data encodings which are defined.  That subset is sufficient for parsing
  51  * most X.509 certificates, and working with selected additional formats
  52  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
  53  *
  54  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
  55  * and RFC 5280, section 8, we assume that this kind of string will contain
  56  * ISO-8859-1 characters only.
  57  *
  58  *
  59  * @author David Brownell
  60  * @author Amit Kapoor
  61  * @author Hemma Prafullchandra
  62  */
  63 public class DerValue {
<a name="4" id="anc4"></a><span class="line-added">  64 </span>
  65     /** The tag class types */
  66     public static final byte TAG_UNIVERSAL = (byte)0x000;
  67     public static final byte TAG_APPLICATION = (byte)0x040;
  68     public static final byte TAG_CONTEXT = (byte)0x080;
  69     public static final byte TAG_PRIVATE = (byte)0x0c0;
  70 
<a name="5" id="anc5"></a>











  71     /*
  72      * The type starts at the first byte of the encoding, and
  73      * is one of these tag_* values.  That may be all the type
  74      * data that is needed.
  75      */
  76 
  77     /*
  78      * These tags are the &quot;universal&quot; tags ... they mean the same
  79      * in all contexts.  (Mask with 0x1f -- five bits.)
  80      */
  81 
  82     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
  83     public static final byte    tag_Boolean = 0x01;
  84 
  85     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
  86     public static final byte    tag_Integer = 0x02;
  87 
  88     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
  89     public static final byte    tag_BitString = 0x03;
  90 
  91     /** Tag value indicating an ASN.1 &quot;OCTET STRING&quot; value. */
  92     public static final byte    tag_OctetString = 0x04;
  93 
  94     /** Tag value indicating an ASN.1 &quot;NULL&quot; value. */
  95     public static final byte    tag_Null = 0x05;
  96 
  97     /** Tag value indicating an ASN.1 &quot;OBJECT IDENTIFIER&quot; value. */
  98     public static final byte    tag_ObjectId = 0x06;
  99 
 100     /** Tag value including an ASN.1 &quot;ENUMERATED&quot; value */
 101     public static final byte    tag_Enumerated = 0x0A;
 102 
 103     /** Tag value indicating an ASN.1 &quot;UTF8String&quot; value. */
 104     public static final byte    tag_UTF8String = 0x0C;
 105 
 106     /** Tag value including a &quot;printable&quot; string */
 107     public static final byte    tag_PrintableString = 0x13;
 108 
 109     /** Tag value including a &quot;teletype&quot; string */
 110     public static final byte    tag_T61String = 0x14;
 111 
 112     /** Tag value including an ASCII string */
 113     public static final byte    tag_IA5String = 0x16;
 114 
 115     /** Tag value indicating an ASN.1 &quot;UTCTime&quot; value. */
 116     public static final byte    tag_UtcTime = 0x17;
 117 
 118     /** Tag value indicating an ASN.1 &quot;GeneralizedTime&quot; value. */
 119     public static final byte    tag_GeneralizedTime = 0x18;
 120 
 121     /** Tag value indicating an ASN.1 &quot;GenerallString&quot; value. */
 122     public static final byte    tag_GeneralString = 0x1B;
 123 
 124     /** Tag value indicating an ASN.1 &quot;UniversalString&quot; value. */
 125     public static final byte    tag_UniversalString = 0x1C;
 126 
 127     /** Tag value indicating an ASN.1 &quot;BMPString&quot; value. */
 128     public static final byte    tag_BMPString = 0x1E;
 129 
 130     // CONSTRUCTED seq/set
 131 
 132     /**
 133      * Tag value indicating an ASN.1
 134      * &quot;SEQUENCE&quot; (zero to N elements, order is significant).
 135      */
 136     public static final byte    tag_Sequence = 0x30;
 137 
 138     /**
 139      * Tag value indicating an ASN.1
 140      * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
 141      */
 142     public static final byte    tag_SequenceOf = 0x30;
 143 
 144     /**
 145      * Tag value indicating an ASN.1
 146      * &quot;SET&quot; (zero to N members, order does not matter).
 147      */
 148     public static final byte    tag_Set = 0x31;
 149 
 150     /**
 151      * Tag value indicating an ASN.1
 152      * &quot;SET OF&quot; (one to N members, order does not matter).
 153      */
 154     public static final byte    tag_SetOf = 0x31;
 155 
<a name="6" id="anc6"></a><span class="line-added"> 156     // Instance fields start here:</span>
<span class="line-added"> 157     public /*final*/ byte tag;</span>
<span class="line-added"> 158     final byte[] buffer;</span>
<span class="line-added"> 159     final int start;</span>
<span class="line-added"> 160     final int end;</span>
<span class="line-added"> 161     public final boolean allowBER;</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163     final public DerInputStream data;</span>
<span class="line-added"> 164 </span>
 165     /*
 166      * These values are the high order bits for the other kinds of tags.
 167      */
 168 
 169     /**
 170      * Returns true if the tag class is UNIVERSAL.
 171      */
 172     public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }
 173 
 174     /**
 175      * Returns true if the tag class is APPLICATION.
 176      */
 177     public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }
 178 
 179     /**
 180      * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
 181      * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
 182      */
 183     public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }
 184 
 185     /**
 186      * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.
 187      */
 188     public boolean isContextSpecific(byte cntxtTag) {
 189         if (!isContextSpecific()) {
 190             return false;
 191         }
 192         return ((tag &amp; 0x01f) == cntxtTag);
 193     }
 194 
 195     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
 196 
 197     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
 198     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
 199 
 200     /**
 201      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
 202      */
 203     public boolean isConstructed(byte constructedTag) {
 204         if (!isConstructed()) {
 205             return false;
 206         }
 207         return ((tag &amp; 0x01f) == constructedTag);
 208     }
 209 
 210     /**
 211      * Creates a PrintableString or UTF8string DER value from a string
 212      */
 213     public DerValue(String value) {
<a name="7" id="anc7"></a><span class="line-modified"> 214         this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,</span>
<span class="line-added"> 215                 value);</span>
<span class="line-added"> 216     }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218     public static boolean isPrintableString(String value) {</span>
 219         for (int i = 0; i &lt; value.length(); i++) {
 220             if (!isPrintableStringChar(value.charAt(i))) {
<a name="8" id="anc8"></a><span class="line-modified"> 221                 return false;</span>

 222             }
 223         }
<a name="9" id="anc9"></a><span class="line-modified"> 224         return true;</span>

 225     }
 226 
 227     /**
 228      * Creates a string type DER value from a String object
 229      * @param stringTag the tag for the DER value to create
 230      * @param value the String object to use for the DER value
 231      */
 232     public DerValue(byte stringTag, String value) {
<a name="10" id="anc10"></a><span class="line-modified"> 233         final Charset charset;</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235         tag = stringTag;</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237         switch (stringTag) {</span>
<span class="line-added"> 238             case tag_PrintableString:</span>
<span class="line-added"> 239             case tag_IA5String:</span>
<span class="line-added"> 240             case tag_GeneralString:</span>
<span class="line-added"> 241                 charset = US_ASCII;</span>
<span class="line-added"> 242                 break;</span>
<span class="line-added"> 243             case tag_T61String:</span>
<span class="line-added"> 244                 charset = ISO_8859_1;</span>
<span class="line-added"> 245                 break;</span>
<span class="line-added"> 246             case tag_BMPString:</span>
<span class="line-added"> 247                 charset = UTF_16BE;</span>
<span class="line-added"> 248                 break;</span>
<span class="line-added"> 249             case tag_UTF8String:</span>
<span class="line-added"> 250                 charset = UTF_8;</span>
<span class="line-added"> 251                 break;</span>
<span class="line-added"> 252             case tag_UniversalString:</span>
<span class="line-added"> 253                 charset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added"> 254                 break;</span>
<span class="line-added"> 255             default:</span>
<span class="line-added"> 256                 throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);</span>
<span class="line-added"> 257         }</span>
<span class="line-added"> 258 </span>
<span class="line-added"> 259         buffer = value.getBytes(charset);</span>
<span class="line-added"> 260         start = 0;</span>
<span class="line-added"> 261         end = buffer.length;</span>
<span class="line-added"> 262         allowBER = false;</span>
<span class="line-added"> 263         this.data = new DerInputStream(this);</span>
 264     }
 265 
 266     // Creates a DerValue from a tag and some DER-encoded data w/ additional
 267     // arg to control whether DER checks are enforced.
<a name="11" id="anc11"></a><span class="line-modified"> 268     DerValue(byte tag, byte[] buffer, boolean allowBER) {</span>
<span class="line-added"> 269         this(tag, buffer, 0, buffer.length, allowBER);</span>
<span class="line-added"> 270     }</span>
<span class="line-added"> 271 </span>
<span class="line-added"> 272     DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {</span>
 273         this.tag = tag;
<a name="12" id="anc12"></a><span class="line-modified"> 274         this.buffer = buffer;</span>
<span class="line-modified"> 275         this.start = start;</span>
<span class="line-modified"> 276         this.end = end;</span>
<span class="line-modified"> 277         this.allowBER = allowBER;</span>
<span class="line-added"> 278         this.data = new DerInputStream(this);</span>
 279     }
 280 
 281     /**
 282      * Creates a DerValue from a tag and some DER-encoded data.
 283      *
 284      * @param tag the DER type tag
<a name="13" id="anc13"></a><span class="line-modified"> 285      * @param buffer the DER-encoded data</span>
 286      */
<a name="14" id="anc14"></a><span class="line-modified"> 287     public DerValue(byte tag, byte[] buffer) {</span>
<span class="line-modified"> 288         this(tag, buffer.clone(), true);</span>




































 289     }
 290 
 291     // Get an ASN.1/DER encoded datum from a buffer w/ additional
 292     // arg to control whether DER checks are enforced.
 293     DerValue(byte[] buf, boolean allowBER) throws IOException {
<a name="15" id="anc15"></a><span class="line-modified"> 294         this(buf, 0, buf.length, allowBER);</span>
 295     }
 296 
 297     /**
 298      * Get an ASN.1/DER encoded datum from a buffer.  The
 299      * entire buffer must hold exactly one datum, including
 300      * its tag and length.
 301      *
 302      * @param buf buffer holding a single DER-encoded datum.
 303      */
 304     public DerValue(byte[] buf) throws IOException {
<a name="16" id="anc16"></a><span class="line-modified"> 305         this(buf.clone(), true);</span>
 306     }
 307 
 308     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
 309     // arg to control whether DER checks are enforced.
<a name="17" id="anc17"></a><span class="line-modified"> 310     DerValue(byte[] buf, int offset, int len, boolean allowBER) throws IOException {</span>
<span class="line-modified"> 311         this(buf, offset, len, allowBER, true);</span>

 312     }
 313 
<a name="18" id="anc18"></a><span class="line-modified"> 314     DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean noMore) throws IOException {</span>
<span class="line-modified"> 315         if (len &lt; 2) {</span>
<span class="line-modified"> 316             throw new IOException(&quot;Too short &quot; + len);</span>
<span class="line-modified"> 317         }</span>
<span class="line-modified"> 318         int pos = offset;</span>
<span class="line-modified"> 319         tag = buf[pos++];</span>
<span class="line-modified"> 320         int length;</span>
<span class="line-modified"> 321         int lenByte = buf[pos++];</span>
<span class="line-modified"> 322 </span>
<span class="line-modified"> 323         if (lenByte == (byte)0x80) {</span>
<span class="line-modified"> 324             length = -1;</span>
<span class="line-added"> 325         } else if ((lenByte &amp; 0x080) == 0x00) { // short form, 1 byte datum</span>
<span class="line-added"> 326             length = lenByte;</span>
<span class="line-added"> 327         } else {                     // long form or indefinite</span>
<span class="line-added"> 328             lenByte &amp;= 0x07f;</span>
<span class="line-added"> 329             if (lenByte == 0) {</span>
<span class="line-added"> 330                 length = -1;</span>
<span class="line-added"> 331             } else if (lenByte &lt; 0 || lenByte &gt; 4) {</span>
<span class="line-added"> 332                 throw new IOException(&quot;incorrect DER encoding&quot;);</span>
<span class="line-added"> 333             } else {</span>
<span class="line-added"> 334                 if (len &lt; 2 + lenByte) {</span>
<span class="line-added"> 335                     throw new IOException(&quot;incorrect DER encoding&quot;);</span>
<span class="line-added"> 336                 }</span>
<span class="line-added"> 337                 length = 0x0ff &amp; buf[pos++];</span>
<span class="line-added"> 338                 lenByte--;</span>
<span class="line-added"> 339                 if (length == 0 &amp;&amp; !allowBER) {</span>
<span class="line-added"> 340                     // DER requires length value be encoded in minimum number of bytes</span>
<span class="line-added"> 341                     throw new IOException(&quot;Redundant length bytes found&quot;);</span>
<span class="line-added"> 342                 }</span>
<span class="line-added"> 343                 while (lenByte-- &gt; 0) {</span>
<span class="line-added"> 344                     length &lt;&lt;= 8;</span>
<span class="line-added"> 345                     length += 0x0ff &amp; buf[pos++];</span>
<span class="line-added"> 346                 }</span>
<span class="line-added"> 347                 if (length &lt; 0) {</span>
<span class="line-added"> 348                     throw new IOException(&quot;Invalid length bytes&quot;);</span>
<span class="line-added"> 349                 } else if (length &lt;= 127 &amp;&amp; !allowBER) {</span>
<span class="line-added"> 350                     throw new IOException(&quot;Should use short form for length&quot;);</span>
<span class="line-added"> 351                 }</span>
<span class="line-added"> 352             }</span>
<span class="line-added"> 353         }</span>
<span class="line-added"> 354         if (length == -1) { // indefinite length encoding found</span>
<span class="line-added"> 355             if (!allowBER) {</span>
<span class="line-added"> 356                 throw new IOException</span>
<span class="line-added"> 357                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added"> 358             }</span>
<span class="line-added"> 359             InputStream in = new ByteArrayInputStream(</span>
<span class="line-added"> 360                     DerIndefLenConverter.convertStream(</span>
<span class="line-added"> 361                             new ByteArrayInputStream(buf, pos, len - (pos - offset)), (byte)lenByte, tag));</span>
<span class="line-added"> 362             if (tag != in.read())</span>
<span class="line-added"> 363                 throw new IOException</span>
<span class="line-added"> 364                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added"> 365             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-added"> 366             this.buffer = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-added"> 367             this.start = 0;</span>
<span class="line-added"> 368             this.end = length;</span>
<span class="line-added"> 369             this.allowBER = true;</span>
<span class="line-added"> 370         } else {</span>
<span class="line-added"> 371             if (len - length &lt; pos - offset) {</span>
<span class="line-added"> 372                 throw new EOFException(&quot;Too little&quot;);</span>
<span class="line-added"> 373             }</span>
<span class="line-added"> 374             if (len - length &gt; pos - offset &amp;&amp; noMore) {</span>
<span class="line-added"> 375                 throw new IOException(&quot;Too much&quot;);</span>
<span class="line-added"> 376             }</span>
<span class="line-added"> 377             this.buffer = buf;</span>
<span class="line-added"> 378             this.start = pos;</span>
<span class="line-added"> 379             this.end = pos + length;</span>
<span class="line-added"> 380             this.allowBER = allowBER;</span>
<span class="line-added"> 381         }</span>
<span class="line-added"> 382         this.data = new DerInputStream(this);</span>
 383     }
 384 
 385     // Get an ASN1/DER encoded datum from an input stream w/ additional
 386     // arg to control whether DER checks are enforced.
 387     DerValue(InputStream in, boolean allowBER) throws IOException {
<a name="19" id="anc19"></a><span class="line-modified"> 388         this.tag = (byte)in.read();</span>
<span class="line-added"> 389         byte lenByte = (byte)in.read();</span>
<span class="line-added"> 390         int length = DerInputStream.getLength(lenByte, in);</span>
<span class="line-added"> 391         if (length == -1) { // indefinite length encoding found</span>
<span class="line-added"> 392             in = new ByteArrayInputStream(</span>
<span class="line-added"> 393                     DerIndefLenConverter.convertStream(in, lenByte, tag));</span>
<span class="line-added"> 394             if (tag != in.read())</span>
<span class="line-added"> 395                 throw new IOException</span>
<span class="line-added"> 396                         (&quot;Indefinite length encoding not supported&quot;);</span>
<span class="line-added"> 397             length = DerInputStream.getDefiniteLength(in);</span>
<span class="line-added"> 398         }</span>
<span class="line-added"> 399         this.buffer = IOUtils.readExactlyNBytes(in, length);</span>
<span class="line-added"> 400         this.start = 0;</span>
<span class="line-added"> 401         this.end = length;</span>
<span class="line-added"> 402         this.allowBER = allowBER;</span>
<span class="line-added"> 403         this.data = new DerInputStream(this);</span>
<span class="line-added"> 404         System.out.println(this);</span>
 405     }
 406 
 407     /**
 408      * Get an ASN1/DER encoded datum from an input stream.  The
 409      * stream may have additional data following the encoded datum.
 410      * In case of indefinite length encoded datum, the input stream
 411      * must hold only one datum.
 412      *
 413      * @param in the input stream holding a single DER datum,
 414      *  which may be followed by additional data
 415      */
 416     public DerValue(InputStream in) throws IOException {
 417         this(in, true);
 418     }
 419 
<a name="20" id="anc20"></a>




























































 420     /**
 421      * Encode an ASN1/DER encoded datum onto a DER output stream.
 422      */
<a name="21" id="anc21"></a><span class="line-modified"> 423     public void encode(DerOutputStream out) throws IOException {</span>

 424         out.write(tag);
<a name="22" id="anc22"></a><span class="line-modified"> 425         out.putLength(end - start);</span>
<span class="line-modified"> 426         out.write(buffer, start, end - start);</span>
<span class="line-modified"> 427         data.pos = data.end; // Compatibility. Reach end.</span>










 428     }
 429 
 430     public final DerInputStream getData() {
 431         return data;
 432     }
 433 
 434     public final byte getTag() {
 435         return tag;
 436     }
 437 
 438     /**
 439      * Returns an ASN.1 BOOLEAN
 440      *
 441      * @return the boolean held in this DER value
 442      */
 443     public boolean getBoolean() throws IOException {
 444         if (tag != tag_Boolean) {
 445             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
 446         }
<a name="23" id="anc23"></a><span class="line-modified"> 447         if (end - start != 1) {</span>
 448             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
<a name="24" id="anc24"></a><span class="line-modified"> 449                                         + (end - start));</span>



 450         }
<a name="25" id="anc25"></a><span class="line-modified"> 451         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 452         return buffer[start] != 0;</span>
 453     }
 454 
 455     /**
 456      * Returns an ASN.1 OBJECT IDENTIFIER.
 457      *
 458      * @return the OID held in this DER value
 459      */
 460     public ObjectIdentifier getOID() throws IOException {
 461         if (tag != tag_ObjectId)
 462             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
<a name="26" id="anc26"></a><span class="line-modified"> 463         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified"> 464         return new ObjectIdentifier(buffer, start, end);</span>










 465     }
 466 
 467     /**
 468      * Returns an ASN.1 OCTET STRING
 469      *
 470      * @return the octet string held in this DER value
 471      */
 472     public byte[] getOctetString() throws IOException {
 473 
 474         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
 475             throw new IOException(
 476                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
 477         }
 478         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
 479         // known bug that it returns -1 instead of 0.
<a name="27" id="anc27"></a><span class="line-modified"> 480         if (end - start == 0) {</span>
 481             return new byte[0];
 482         }
 483 
<a name="28" id="anc28"></a><span class="line-modified"> 484         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified"> 485         if (!isConstructed()) {</span>
<span class="line-modified"> 486             return Arrays.copyOfRange(buffer, start, end);</span>
<span class="line-modified"> 487         } else {</span>
<span class="line-modified"> 488             ByteArrayOutputStream bout = new ByteArrayOutputStream();</span>
<span class="line-modified"> 489             for (DerValue dv : new DerInputStream(this)) {</span>
<span class="line-modified"> 490                 bout.write(dv.getOctetString());</span>









 491             }
<a name="29" id="anc29"></a><span class="line-added"> 492             return bout.toByteArray();</span>
 493         }
<a name="30" id="anc30"></a>
 494     }
 495 
 496     /**
 497      * Returns an ASN.1 INTEGER value as an integer.
 498      *
 499      * @return the integer held in this DER value.
 500      */
 501     public int getInteger() throws IOException {
<a name="31" id="anc31"></a><span class="line-modified"> 502         BigInteger result = getBigInteger();</span>
<span class="line-modified"> 503         if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0) {</span>
<span class="line-added"> 504             throw new IOException(&quot;Integer below minimum valid value&quot;);</span>
<span class="line-added"> 505         }</span>
<span class="line-added"> 506         if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
<span class="line-added"> 507             throw new IOException(&quot;Integer exceeds maximum valid value&quot;);</span>
 508         }
<a name="32" id="anc32"></a><span class="line-modified"> 509         return result.intValue();</span>
 510     }
 511 
 512     /**
 513      * Returns an ASN.1 INTEGER value as a BigInteger.
 514      *
 515      * @return the integer held in this DER value as a BigInteger.
 516      */
 517     public BigInteger getBigInteger() throws IOException {
<a name="33" id="anc33"></a><span class="line-modified"> 518         return getBigInteger0(false);</span>


 519     }
 520 
 521     /**
 522      * Returns an ASN.1 INTEGER value as a positive BigInteger.
 523      * This is just to deal with implementations that incorrectly encode
 524      * some values as negative.
 525      *
 526      * @return the integer held in this DER value as a BigInteger.
 527      */
 528     public BigInteger getPositiveBigInteger() throws IOException {
<a name="34" id="anc34"></a><span class="line-added"> 529         return getBigInteger0(true);</span>
<span class="line-added"> 530     }</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532     private BigInteger getBigInteger0(boolean mustBePositive) throws IOException {</span>
 533         if (tag != tag_Integer)
 534             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
<a name="35" id="anc35"></a><span class="line-modified"> 535         if (end == start) {</span>
<span class="line-added"> 536             throw new IOException(&quot;Invalid encoding: zero length Int value&quot;);</span>
<span class="line-added"> 537         }</span>
<span class="line-added"> 538         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 539         if (!allowBER &amp;&amp; (end - start &gt;= 2 &amp;&amp; (buffer[start] == 0) &amp;&amp; (buffer[start + 1] &gt;= 0))) {</span>
<span class="line-added"> 540             throw new IOException(&quot;Invalid encoding: redundant leading 0s&quot;);</span>
<span class="line-added"> 541         }</span>
<span class="line-added"> 542         return mustBePositive</span>
<span class="line-added"> 543                 ? new BigInteger(1, buffer, start, end - start)</span>
<span class="line-added"> 544                 : new BigInteger(buffer, start, end - start);</span>
 545     }
 546 
 547     /**
 548      * Returns an ASN.1 ENUMERATED value.
 549      *
 550      * @return the integer held in this DER value.
 551      */
 552     public int getEnumerated() throws IOException {
 553         if (tag != tag_Enumerated) {
 554             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
 555                                   + tag);
 556         }
<a name="36" id="anc36"></a><span class="line-modified"> 557         // TODO</span>
<span class="line-added"> 558         return new BigInteger(1, buffer, start, end - start).intValue();</span>
 559     }
 560 
 561     /**
 562      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
 563      *
 564      * @return the bit string held in this value
 565      */
 566     public byte[] getBitString() throws IOException {
<a name="37" id="anc37"></a><span class="line-modified"> 567         return getBitString(false);</span>




 568     }
 569 
 570     /**
 571      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
 572      *
 573      * @return a BitArray representing the bit string held in this value
 574      */
 575     public BitArray getUnalignedBitString() throws IOException {
<a name="38" id="anc38"></a><span class="line-modified"> 576         return getUnalignedBitString(false);</span>




 577     }
 578 
 579     /**
 580      * Returns the name component as a Java string, regardless of its
 581      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
 582      */
 583     // TBD: Need encoder for UniversalString before it can be handled.
 584     public String getAsString() throws IOException {
 585         if (tag == tag_UTF8String)
 586             return getUTF8String();
 587         else if (tag == tag_PrintableString)
 588             return getPrintableString();
 589         else if (tag == tag_T61String)
 590             return getT61String();
 591         else if (tag == tag_IA5String)
 592             return getIA5String();
<a name="39" id="anc39"></a><span class="line-modified"> 593         else if (tag == tag_UniversalString)</span>

 594           return getUniversalString();
<a name="40" id="anc40"></a>
 595         else if (tag == tag_BMPString)
 596             return getBMPString();
 597         else if (tag == tag_GeneralString)
 598             return getGeneralString();
 599         else
 600             return null;
 601     }
 602 
 603     /**
 604      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 605      * based on the parameter.  The bit string must be byte-aligned.
 606      *
 607      * @param tagImplicit if true, the tag is assumed implicit.
 608      * @return the bit string held in this value
 609      */
 610     public byte[] getBitString(boolean tagImplicit) throws IOException {
 611         if (!tagImplicit) {
<a name="41" id="anc41"></a><span class="line-modified"> 612             if (tag != tag_BitString) {</span>
 613                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<a name="42" id="anc42"></a><span class="line-modified"> 614                         + tag);</span>
 615             }
<a name="43" id="anc43"></a><span class="line-modified"> 616         }</span>
<span class="line-added"> 617         if (end == start) {</span>
<span class="line-added"> 618             throw new IOException(&quot;No padding&quot;);</span>
<span class="line-added"> 619         }</span>
<span class="line-added"> 620         int numOfPadBits = buffer[start];</span>
<span class="line-added"> 621         if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {</span>
<span class="line-added"> 622             throw new IOException(&quot;Invalid number of padding bits&quot;);</span>
<span class="line-added"> 623         }</span>
<span class="line-added"> 624         // minus the first byte which indicates the number of padding bits</span>
<span class="line-added"> 625         byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);</span>
<span class="line-added"> 626         if (numOfPadBits != 0) {</span>
<span class="line-added"> 627             // get rid of the padding bits</span>
<span class="line-added"> 628             retval[end - start - 2] &amp;= (0xff &lt;&lt; numOfPadBits);</span>
<span class="line-added"> 629         }</span>
<span class="line-added"> 630         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 631         return retval;</span>
 632     }
 633 
 634     /**
 635      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
 636      * based on the parameter.  The bit string need not be byte-aligned.
 637      *
 638      * @param tagImplicit if true, the tag is assumed implicit.
 639      * @return the bit string held in this value
 640      */
 641     public BitArray getUnalignedBitString(boolean tagImplicit)
<a name="44" id="anc44"></a><span class="line-modified"> 642             throws IOException {</span>
 643         if (!tagImplicit) {
<a name="45" id="anc45"></a><span class="line-modified"> 644             if (tag != tag_BitString) {</span>
 645                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
<a name="46" id="anc46"></a><span class="line-modified"> 646                         + tag);</span>
 647             }
<a name="47" id="anc47"></a><span class="line-modified"> 648         }</span>
<span class="line-added"> 649         if (end == start) {</span>
<span class="line-added"> 650             throw new IOException(&quot;No padding&quot;);</span>
<span class="line-added"> 651         }</span>
<span class="line-added"> 652         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 653         if (end == start + 1) {</span>
<span class="line-added"> 654             return new BitArray(0);</span>
<span class="line-added"> 655         } else {</span>
<span class="line-added"> 656             int numOfPadBits = buffer[start];</span>
<span class="line-added"> 657             if ((numOfPadBits &lt; 0) || (numOfPadBits &gt; 7)) {</span>
<span class="line-added"> 658                 throw new IOException(&quot;Invalid number of padding bits&quot;);</span>
<span class="line-added"> 659             }</span>
<span class="line-added"> 660             return new BitArray((end - start - 1) * 8 - numOfPadBits,</span>
<span class="line-added"> 661                     Arrays.copyOfRange(buffer, start + 1, end));</span>
<span class="line-added"> 662         }</span>
 663     }
 664 
 665     /**
 666      * Helper routine to return all the bytes contained in the
 667      * DerInputStream associated with this object.
 668      */
 669     public byte[] getDataBytes() throws IOException {
<a name="48" id="anc48"></a><span class="line-modified"> 670         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-modified"> 671         return Arrays.copyOfRange(buffer, start, end);</span>




 672     }
 673 
<a name="49" id="anc49"></a><span class="line-added"> 674     private String readString0(Charset cs) {</span>
<span class="line-added"> 675         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 676         return new String(buffer, start, end - start, cs);</span>
<span class="line-added"> 677     }</span>
 678     /**
 679      * Returns an ASN.1 STRING value
 680      *
 681      * @return the printable string held in this value
 682      */
 683     public String getPrintableString()
 684     throws IOException {
 685         if (tag != tag_PrintableString)
 686             throw new IOException(
 687                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
 688 
<a name="50" id="anc50"></a><span class="line-modified"> 689         return readString0(US_ASCII);</span>
 690     }
 691 
 692     /**
 693      * Returns an ASN.1 T61 (Teletype) STRING value
 694      *
 695      * @return the teletype string held in this value
 696      */
 697     public String getT61String() throws IOException {
 698         if (tag != tag_T61String)
 699             throw new IOException(
 700                 &quot;DerValue.getT61String, not T61 &quot; + tag);
 701 
<a name="51" id="anc51"></a><span class="line-modified"> 702         return readString0(ISO_8859_1);</span>
 703     }
 704 
 705     /**
 706      * Returns an ASN.1 IA5 (ASCII) STRING value
 707      *
 708      * @return the ASCII string held in this value
 709      */
 710     public String getIA5String() throws IOException {
 711         if (tag != tag_IA5String)
 712             throw new IOException(
 713                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
 714 
<a name="52" id="anc52"></a><span class="line-modified"> 715         return readString0(US_ASCII);</span>
 716     }
 717 
 718     /**
 719      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
 720      *
 721      * @return a string corresponding to the encoded BMPString held in
 722      * this value
 723      */
 724     public String getBMPString() throws IOException {
 725         if (tag != tag_BMPString)
 726             throw new IOException(
 727                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
 728 
 729         // BMPString is the same as Unicode in big endian, unmarked
 730         // format.
<a name="53" id="anc53"></a><span class="line-modified"> 731         return readString0(UTF_16BE);</span>
 732     }
 733 
 734     /**
 735      * Returns the ASN.1 UTF-8 STRING value as a Java String.
 736      *
 737      * @return a string corresponding to the encoded UTF8String held in
 738      * this value
 739      */
 740     public String getUTF8String() throws IOException {
 741         if (tag != tag_UTF8String)
 742             throw new IOException(
 743                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
 744 
<a name="54" id="anc54"></a><span class="line-modified"> 745         return readString0(UTF_8);</span>
 746     }
 747 
 748     /**
 749      * Returns the ASN.1 GENERAL STRING value as a Java String.
 750      *
 751      * @return a string corresponding to the encoded GeneralString held in
 752      * this value
 753      */
 754     public String getGeneralString() throws IOException {
 755         if (tag != tag_GeneralString)
 756             throw new IOException(
 757                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
 758 
<a name="55" id="anc55"></a><span class="line-modified"> 759         return readString0(US_ASCII);</span>
<span class="line-added"> 760     }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762     /**</span>
<span class="line-added"> 763      * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.</span>
<span class="line-added"> 764      *</span>
<span class="line-added"> 765      * @return a string corresponding to the encoded UniversalString held in</span>
<span class="line-added"> 766      * this value or an empty string if UTF_32BE is not a supported character</span>
<span class="line-added"> 767      * set.</span>
<span class="line-added"> 768      */</span>
<span class="line-added"> 769     public String getUniversalString() throws IOException {</span>
<span class="line-added"> 770         if (tag != tag_UniversalString)</span>
<span class="line-added"> 771             throw new IOException(</span>
<span class="line-added"> 772                 &quot;DerValue.getUniversalString, not UniversalString &quot; + tag);</span>
<span class="line-added"> 773         try {</span>
<span class="line-added"> 774             Charset cset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added"> 775             return readString0(cset);</span>
<span class="line-added"> 776         } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {</span>
<span class="line-added"> 777             return &quot;&quot;;</span>
<span class="line-added"> 778         }</span>
<span class="line-added"> 779     }</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781     private Date getTime(int len, boolean generalized) throws IOException {</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783         /*</span>
<span class="line-added"> 784          * UTC time encoded as ASCII chars:</span>
<span class="line-added"> 785          *       YYMMDDhhmmZ</span>
<span class="line-added"> 786          *       YYMMDDhhmmssZ</span>
<span class="line-added"> 787          *       YYMMDDhhmm+hhmm</span>
<span class="line-added"> 788          *       YYMMDDhhmm-hhmm</span>
<span class="line-added"> 789          *       YYMMDDhhmmss+hhmm</span>
<span class="line-added"> 790          *       YYMMDDhhmmss-hhmm</span>
<span class="line-added"> 791          * UTC Time is broken in storing only two digits of year.</span>
<span class="line-added"> 792          * If YY &lt; 50, we assume 20YY;</span>
<span class="line-added"> 793          * if YY &gt;= 50, we assume 19YY, as per RFC 5280.</span>
<span class="line-added"> 794          *</span>
<span class="line-added"> 795          * Generalized time has a four-digit year and allows any</span>
<span class="line-added"> 796          * precision specified in ISO 8601. However, for our purposes,</span>
<span class="line-added"> 797          * we will only allow the same format as UTC time, except that</span>
<span class="line-added"> 798          * fractional seconds (millisecond precision) are supported.</span>
<span class="line-added"> 799          */</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801         int year, month, day, hour, minute, second, millis;</span>
<span class="line-added"> 802         String type = null;</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804         int pos = start;</span>
<span class="line-added"> 805         if (generalized) {</span>
<span class="line-added"> 806             type = &quot;Generalized&quot;;</span>
<span class="line-added"> 807             year = 1000 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 808             year += 100 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 809             year += 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 810             year += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 811             len -= 2; // For the two extra YY</span>
<span class="line-added"> 812         } else {</span>
<span class="line-added"> 813             type = &quot;UTC&quot;;</span>
<span class="line-added"> 814             year = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 815             year += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817             if (year &lt; 50)              // origin 2000</span>
<span class="line-added"> 818                 year += 2000;</span>
<span class="line-added"> 819             else</span>
<span class="line-added"> 820                 year += 1900;   // origin 1900</span>
<span class="line-added"> 821         }</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823         month = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 824         month += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826         day = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 827         day += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 828 </span>
<span class="line-added"> 829         hour = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 830         hour += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832         minute = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 833         minute += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 834 </span>
<span class="line-added"> 835         len -= 10; // YYMMDDhhmm</span>
<span class="line-added"> 836 </span>
<span class="line-added"> 837         /*</span>
<span class="line-added"> 838          * We allow for non-encoded seconds, even though the</span>
<span class="line-added"> 839          * IETF-PKIX specification says that the seconds should</span>
<span class="line-added"> 840          * always be encoded even if it is zero.</span>
<span class="line-added"> 841          */</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843         millis = 0;</span>
<span class="line-added"> 844         if (len &gt; 2) {</span>
<span class="line-added"> 845             second = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 846             second += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 847             len -= 2;</span>
<span class="line-added"> 848             // handle fractional seconds (if present)</span>
<span class="line-added"> 849             if (buffer[pos] == &#39;.&#39; || buffer[pos] == &#39;,&#39;) {</span>
<span class="line-added"> 850                 len --;</span>
<span class="line-added"> 851                 pos++;</span>
<span class="line-added"> 852                 int precision = 0;</span>
<span class="line-added"> 853                 while (buffer[pos] != &#39;Z&#39; &amp;&amp;</span>
<span class="line-added"> 854                         buffer[pos] != &#39;+&#39; &amp;&amp;</span>
<span class="line-added"> 855                         buffer[pos] != &#39;-&#39;) {</span>
<span class="line-added"> 856                     // Validate all digits in the fractional part but</span>
<span class="line-added"> 857                     // store millisecond precision only</span>
<span class="line-added"> 858                     int thisDigit = Character.digit((char)buffer[pos], 10);</span>
<span class="line-added"> 859                     precision++;</span>
<span class="line-added"> 860                     pos++;</span>
<span class="line-added"> 861                     switch (precision) {</span>
<span class="line-added"> 862                         case 1:</span>
<span class="line-added"> 863                             millis += 100 * thisDigit;</span>
<span class="line-added"> 864                             break;</span>
<span class="line-added"> 865                         case 2:</span>
<span class="line-added"> 866                             millis += 10 * thisDigit;</span>
<span class="line-added"> 867                             break;</span>
<span class="line-added"> 868                         case 3:</span>
<span class="line-added"> 869                             millis += thisDigit;</span>
<span class="line-added"> 870                             break;</span>
<span class="line-added"> 871                     }</span>
<span class="line-added"> 872                 }</span>
<span class="line-added"> 873                 if (precision == 0) {</span>
<span class="line-added"> 874                     throw new IOException(&quot;Parse &quot; + type +</span>
<span class="line-added"> 875                             &quot; time, empty fractional part&quot;);</span>
<span class="line-added"> 876                 }</span>
<span class="line-added"> 877                 len -= precision;</span>
<span class="line-added"> 878             }</span>
<span class="line-added"> 879         } else</span>
<span class="line-added"> 880             second = 0;</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882         if (month == 0 || day == 0</span>
<span class="line-added"> 883                 || month &gt; 12 || day &gt; 31</span>
<span class="line-added"> 884                 || hour &gt;= 24 || minute &gt;= 60 || second &gt;= 60)</span>
<span class="line-added"> 885             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid format&quot;);</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887         /*</span>
<span class="line-added"> 888          * Generalized time can theoretically allow any precision,</span>
<span class="line-added"> 889          * but we&#39;re not supporting that.</span>
<span class="line-added"> 890          */</span>
<span class="line-added"> 891         CalendarSystem gcal = CalendarSystem.getGregorianCalendar();</span>
<span class="line-added"> 892         CalendarDate date = gcal.newCalendarDate(null); // no time zone</span>
<span class="line-added"> 893         date.setDate(year, month, day);</span>
<span class="line-added"> 894         date.setTimeOfDay(hour, minute, second, millis);</span>
<span class="line-added"> 895         long time = gcal.getTime(date);</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897         /*</span>
<span class="line-added"> 898          * Finally, &quot;Z&quot; or &quot;+hhmm&quot; or &quot;-hhmm&quot; ... offsets change hhmm</span>
<span class="line-added"> 899          */</span>
<span class="line-added"> 900         if (! (len == 1 || len == 5))</span>
<span class="line-added"> 901             throw new IOException(&quot;Parse &quot; + type + &quot; time, invalid offset&quot;);</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903         int hr, min;</span>
<span class="line-added"> 904 </span>
<span class="line-added"> 905         switch (buffer[pos++]) {</span>
<span class="line-added"> 906             case &#39;+&#39;:</span>
<span class="line-added"> 907                 hr = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 908                 hr += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 909                 min = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 910                 min += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 911 </span>
<span class="line-added"> 912                 if (hr &gt;= 24 || min &gt;= 60)</span>
<span class="line-added"> 913                     throw new IOException(&quot;Parse &quot; + type + &quot; time, +hhmm&quot;);</span>
<span class="line-added"> 914 </span>
<span class="line-added"> 915                 time -= ((hr * 60) + min) * 60 * 1000;</span>
<span class="line-added"> 916                 break;</span>
<span class="line-added"> 917 </span>
<span class="line-added"> 918             case &#39;-&#39;:</span>
<span class="line-added"> 919                 hr = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 920                 hr += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 921                 min = 10 * Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 922                 min += Character.digit((char)buffer[pos++], 10);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924                 if (hr &gt;= 24 || min &gt;= 60)</span>
<span class="line-added"> 925                     throw new IOException(&quot;Parse &quot; + type + &quot; time, -hhmm&quot;);</span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927                 time += ((hr * 60) + min) * 60 * 1000;</span>
<span class="line-added"> 928                 break;</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930             case &#39;Z&#39;:</span>
<span class="line-added"> 931                 break;</span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933             default:</span>
<span class="line-added"> 934                 throw new IOException(&quot;Parse &quot; + type + &quot; time, garbage offset&quot;);</span>
<span class="line-added"> 935         }</span>
<span class="line-added"> 936         return new Date(time);</span>
<span class="line-added"> 937     }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939     public void getNull() throws IOException {</span>
<span class="line-added"> 940         if (tag != tag_Null) {</span>
<span class="line-added"> 941             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943         if (end != start) {</span>
<span class="line-added"> 944             throw new IOException(&quot;DER UTC Time length error&quot;);</span>
<span class="line-added"> 945         }</span>
 946     }
 947 
 948     /**
 949      * Returns a Date if the DerValue is UtcTime.
 950      *
 951      * @return the Date held in this DER value
 952      */
 953     public Date getUTCTime() throws IOException {
 954         if (tag != tag_UtcTime) {
 955             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
 956         }
<a name="56" id="anc56"></a><span class="line-modified"> 957         if (end - start &lt; 11 || end - start &gt; 17)</span>
<span class="line-added"> 958             throw new IOException(&quot;DER UTC Time length error&quot;);</span>
<span class="line-added"> 959 </span>
<span class="line-added"> 960         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 961         return getTime(end - start, false);</span>
 962     }
 963 
 964     /**
 965      * Returns a Date if the DerValue is GeneralizedTime.
 966      *
 967      * @return the Date held in this DER value
 968      */
 969     public Date getGeneralizedTime() throws IOException {
 970         if (tag != tag_GeneralizedTime) {
 971             throw new IOException(
 972                 &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
 973         }
<a name="57" id="anc57"></a><span class="line-modified"> 974         if (end - start &lt; 13)</span>
<span class="line-added"> 975             throw new IOException(&quot;DER Generalized Time length error&quot;);</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977         data.pos = data.end; // Compatibility. Reach end.</span>
<span class="line-added"> 978         return getTime(end - start, true);</span>
 979     }
 980 
 981     /**
 982      * Bitwise equality comparison.  DER encoded values have a single
 983      * encoding, so that bitwise equality of the encoded values is an
 984      * efficient way to establish equivalence of the unencoded values.
 985      *
 986      * @param o the object being compared with this one
 987      */
 988     @Override
 989     public boolean equals(Object o) {
 990         if (this == o) {
 991             return true;
 992         }
 993         if (!(o instanceof DerValue)) {
 994             return false;
 995         }
 996         DerValue other = (DerValue) o;
 997         if (tag != other.tag) {
 998             return false;
 999         }
<a name="58" id="anc58"></a><span class="line-modified">1000         if (buffer == other.buffer &amp;&amp; start == other.start &amp;&amp; end == other.end) {</span>
1001             return true;
1002         }
<a name="59" id="anc59"></a><span class="line-modified">1003         return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);</span>


















1004     }
1005 
1006     /**
1007      * Returns a printable representation of the value.
1008      *
1009      * @return printable representation of the value
1010      */
1011     @Override
1012     public String toString() {
<a name="60" id="anc60"></a><span class="line-modified">1013         return String.format(&quot;DerValue(%02x, %s, %d, 5d)&quot;,</span>
<span class="line-modified">1014                 0xff &amp; tag, buffer, start, end);</span>















1015     }
1016 
1017     /**
1018      * Returns a DER-encoded value, such that if it&#39;s passed to the
1019      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
1020      *
1021      * @return DER-encoded value, including tag and length.
1022      */
1023     public byte[] toByteArray() throws IOException {
1024         DerOutputStream out = new DerOutputStream();
<a name="61" id="anc61"></a>
1025         encode(out);
<a name="62" id="anc62"></a><span class="line-modified">1026         data.pos = data.start; // encode go last, should go back</span>
1027         return out.toByteArray();
1028     }
1029 
1030     /**
1031      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
1032      * to return a DER stream of the members of the set or sequence.
1033      * This operation is not supported for primitive types such as
1034      * integers or bit strings.
1035      */
1036     public DerInputStream toDerInputStream() throws IOException {
1037         if (tag == tag_Sequence || tag == tag_Set)
<a name="63" id="anc63"></a><span class="line-modified">1038             return data;</span>
1039         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
1040     }
1041 
1042     /**
1043      * Get the length of the encoded value.
1044      */
1045     public int length() {
<a name="64" id="anc64"></a><span class="line-modified">1046         return end - start;</span>
1047     }
1048 
1049     /**
1050      * Determine if a character is one of the permissible characters for
1051      * PrintableString:
1052      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
1053      * plus sign, comma, hyphen, period, slash, colon, equals sign,
1054      * and question mark.
1055      *
1056      * Characters that are *not* allowed in PrintableString include
1057      * exclamation point, quotation mark, number sign, dollar sign,
1058      * percent sign, ampersand, asterisk, semicolon, less than sign,
1059      * greater than sign, at sign, left and right square brackets,
1060      * backslash, circumflex (94), underscore, back quote (96),
1061      * left and right curly brackets, vertical line, tilde,
1062      * and the control codes (0-31 and 127).
1063      *
1064      * This list is based on X.680 (the ASN.1 spec).
1065      */
1066     public static boolean isPrintableStringChar(char ch) {
1067         if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
1068             (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
1069             return true;
1070         } else {
1071             switch (ch) {
1072                 case &#39; &#39;:       /* space */
1073                 case &#39;\&#39;&#39;:      /* apostrophe */
1074                 case &#39;(&#39;:       /* left paren */
1075                 case &#39;)&#39;:       /* right paren */
1076                 case &#39;+&#39;:       /* plus */
1077                 case &#39;,&#39;:       /* comma */
1078                 case &#39;-&#39;:       /* hyphen */
1079                 case &#39;.&#39;:       /* period */
1080                 case &#39;/&#39;:       /* slash */
1081                 case &#39;:&#39;:       /* colon */
1082                 case &#39;=&#39;:       /* equals */
1083                 case &#39;?&#39;:       /* question mark */
1084                     return true;
1085                 default:
1086                     return false;
1087             }
1088         }
1089     }
1090 
1091     /**
1092      * Create the tag of the attribute.
1093      *
1094      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
1095      *               APPLICATION or PRIVATE
1096      * @param form if true, the value is constructed, otherwise it
1097      * is primitive.
1098      * @param val the tag value
1099      */
1100     public static byte createTag(byte tagClass, boolean form, byte val) {
1101         byte tag = (byte)(tagClass | val);
1102         if (form) {
1103             tag |= (byte)0x20;
1104         }
1105         return (tag);
1106     }
1107 
1108     /**
1109      * Set the tag of the attribute. Commonly used to reset the
1110      * tag value used for IMPLICIT encodings.
1111      *
1112      * @param tag the tag value
1113      */
1114     public void resetTag(byte tag) {
1115         this.tag = tag;
1116     }
1117 
1118     /**
1119      * Returns a hashcode for this DerValue.
1120      *
1121      * @return a hashcode for this DerValue.
1122      */
1123     @Override
1124     public int hashCode() {
1125         return toString().hashCode();
1126     }
<a name="65" id="anc65"></a><span class="line-added">1127 </span>
<span class="line-added">1128     public DerValue[] subs(byte expectedTag) throws IOException {</span>
<span class="line-added">1129         if (expectedTag != 0 &amp;&amp; expectedTag != tag) {</span>
<span class="line-added">1130             throw new IOException(&quot;Not constructed&quot;);</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         List&lt;DerValue&gt; result = new ArrayList&lt;&gt;();</span>
<span class="line-added">1133         DerInputStream dis = new DerInputStream(this);</span>
<span class="line-added">1134         while (dis.available() &gt; 0) {</span>
<span class="line-added">1135             result.add(dis.getDerValue());</span>
<span class="line-added">1136         }</span>
<span class="line-added">1137         return result.toArray(new DerValue[result.size()]);</span>
<span class="line-added">1138     }</span>
1139 }
<a name="66" id="anc66"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="66" type="hidden" />
</body>
</html>
diff a/src/java.base/share/classes/sun/security/util/DerValue.java b/src/java.base/share/classes/sun/security/util/DerValue.java
--- a/src/java.base/share/classes/sun/security/util/DerValue.java
+++ b/src/java.base/share/classes/sun/security/util/DerValue.java
@@ -1,7 +1,7 @@
 /**
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,14 +23,19 @@
  * questions.
  */
 
 package sun.security.util;
 
+import sun.util.calendar.CalendarDate;
+import sun.util.calendar.CalendarSystem;
+
 import java.io.*;
 import java.math.BigInteger;
 import java.nio.charset.Charset;
-import java.util.Date;
+import java.nio.charset.IllegalCharsetNameException;
+import java.nio.charset.UnsupportedCharsetException;
+import java.util.*;
 
 import static java.nio.charset.StandardCharsets.*;
 
 /**
  * Represents a single DER-encoded value.  DER encoding rules are a subset
@@ -54,28 +59,17 @@
  * @author David Brownell
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
 public class DerValue {
+
     /** The tag class types */
     public static final byte TAG_UNIVERSAL = (byte)0x000;
     public static final byte TAG_APPLICATION = (byte)0x040;
     public static final byte TAG_CONTEXT = (byte)0x080;
     public static final byte TAG_PRIVATE = (byte)0x0c0;
 
-    /** The DER tag of the value; one of the tag_ constants. */
-    public byte                 tag;
-
-    protected DerInputBuffer    buffer;
-
-    /**
-     * The DER-encoded data of the value, never null
-     */
-    public final DerInputStream data;
-
-    private int                 length;
-
     /*
      * The type starts at the first byte of the encoding, and
      * is one of these tag_* values.  That may be all the type
      * data that is needed.
      */
@@ -157,10 +151,19 @@
      * Tag value indicating an ASN.1
      * "SET OF" (one to N members, order does not matter).
      */
     public static final byte    tag_SetOf = 0x31;
 
+    // Instance fields start here:
+    public /*final*/ byte tag;
+    final byte[] buffer;
+    final int start;
+    final int end;
+    public final boolean allowBER;
+
+    final public DerInputStream data;
+
     /*
      * These values are the high order bits for the other kinds of tags.
      */
 
     /**
@@ -206,127 +209,201 @@
 
     /**
      * Creates a PrintableString or UTF8string DER value from a string
      */
     public DerValue(String value) {
-        boolean isPrintableString = true;
+        this(isPrintableString(value) ? tag_PrintableString : tag_UTF8String,
+                value);
+    }
+
+    public static boolean isPrintableString(String value) {
         for (int i = 0; i < value.length(); i++) {
             if (!isPrintableStringChar(value.charAt(i))) {
-                isPrintableString = false;
-                break;
+                return false;
             }
         }
-
-        data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
+        return true;
     }
 
     /**
      * Creates a string type DER value from a String object
      * @param stringTag the tag for the DER value to create
      * @param value the String object to use for the DER value
      */
     public DerValue(byte stringTag, String value) {
-        data = init(stringTag, value);
+        final Charset charset;
+
+        tag = stringTag;
+
+        switch (stringTag) {
+            case tag_PrintableString:
+            case tag_IA5String:
+            case tag_GeneralString:
+                charset = US_ASCII;
+                break;
+            case tag_T61String:
+                charset = ISO_8859_1;
+                break;
+            case tag_BMPString:
+                charset = UTF_16BE;
+                break;
+            case tag_UTF8String:
+                charset = UTF_8;
+                break;
+            case tag_UniversalString:
+                charset = Charset.forName("UTF_32BE");
+                break;
+            default:
+                throw new IllegalArgumentException("Unsupported DER string type");
+        }
+
+        buffer = value.getBytes(charset);
+        start = 0;
+        end = buffer.length;
+        allowBER = false;
+        this.data = new DerInputStream(this);
     }
 
     // Creates a DerValue from a tag and some DER-encoded data w/ additional
     // arg to control whether DER checks are enforced.
-    DerValue(byte tag, byte[] data, boolean allowBER) {
+    DerValue(byte tag, byte[] buffer, boolean allowBER) {
+        this(tag, buffer, 0, buffer.length, allowBER);
+    }
+
+    DerValue(byte tag, byte[] buffer, int start, int end, boolean allowBER) {
         this.tag = tag;
-        buffer = new DerInputBuffer(data.clone(), allowBER);
-        length = data.length;
-        this.data = new DerInputStream(buffer);
-        this.data.mark(Integer.MAX_VALUE);
+        this.buffer = buffer;
+        this.start = start;
+        this.end = end;
+        this.allowBER = allowBER;
+        this.data = new DerInputStream(this);
     }
 
     /**
      * Creates a DerValue from a tag and some DER-encoded data.
      *
      * @param tag the DER type tag
-     * @param data the DER-encoded data
+     * @param buffer the DER-encoded data
      */
-    public DerValue(byte tag, byte[] data) {
-        this(tag, data, true);
-    }
-
-    /*
-     * package private
-     */
-    DerValue(DerInputBuffer in) throws IOException {
-
-        // XXX must also parse BER-encoded constructed
-        // values such as sequences, sets...
-        tag = (byte)in.read();
-        byte lenByte = (byte)in.read();
-        length = DerInputStream.getLength(lenByte, in);
-        if (length == -1) {  // indefinite length encoding found
-            DerInputBuffer inbuf = in.dup();
-            inbuf = new DerInputBuffer(
-                    DerIndefLenConverter.convertStream(inbuf, lenByte, tag),
-                    in.allowBER);
-            if (tag != inbuf.read())
-                throw new IOException
-                        ("Indefinite length encoding not supported");
-            length = DerInputStream.getDefiniteLength(inbuf);
-            buffer = inbuf.dup();
-            buffer.truncate(length);
-            data = new DerInputStream(buffer);
-            // indefinite form is encoded by sending a length field with a
-            // length of 0. - i.e. [1000|0000].
-            // the object is ended by sending two zero bytes.
-            in.skip(length + 2);
-        } else {
-
-            buffer = in.dup();
-            buffer.truncate(length);
-            data = new DerInputStream(buffer);
-
-            in.skip(length);
-        }
+    public DerValue(byte tag, byte[] buffer) {
+        this(tag, buffer.clone(), true);
     }
 
     // Get an ASN.1/DER encoded datum from a buffer w/ additional
     // arg to control whether DER checks are enforced.
     DerValue(byte[] buf, boolean allowBER) throws IOException {
-        data = init(true, new ByteArrayInputStream(buf), allowBER);
+        this(buf, 0, buf.length, allowBER);
     }
 
     /**
      * Get an ASN.1/DER encoded datum from a buffer.  The
      * entire buffer must hold exactly one datum, including
      * its tag and length.
      *
      * @param buf buffer holding a single DER-encoded datum.
      */
     public DerValue(byte[] buf) throws IOException {
-        this(buf, true);
+        this(buf.clone(), true);
     }
 
     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
     // arg to control whether DER checks are enforced.
-    DerValue(byte[] buf, int offset, int len, boolean allowBER)
-        throws IOException {
-        data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
+    DerValue(byte[] buf, int offset, int len, boolean allowBER) throws IOException {
+        this(buf, offset, len, allowBER, true);
     }
 
-    /**
-     * Get an ASN.1/DER encoded datum from part of a buffer.
-     * That part of the buffer must hold exactly one datum, including
-     * its tag and length.
-     *
-     * @param buf the buffer
-     * @param offset start point of the single DER-encoded dataum
-     * @param len how many bytes are in the encoded datum
-     */
-    public DerValue(byte[] buf, int offset, int len) throws IOException {
-        this(buf, offset, len, true);
+    DerValue(byte[] buf, int offset, int len, boolean allowBER, boolean noMore) throws IOException {
+        if (len < 2) {
+            throw new IOException("Too short " + len);
+        }
+        int pos = offset;
+        tag = buf[pos++];
+        int length;
+        int lenByte = buf[pos++];
+
+        if (lenByte == (byte)0x80) {
+            length = -1;
+        } else if ((lenByte & 0x080) == 0x00) { // short form, 1 byte datum
+            length = lenByte;
+        } else {                     // long form or indefinite
+            lenByte &= 0x07f;
+            if (lenByte == 0) {
+                length = -1;
+            } else if (lenByte < 0 || lenByte > 4) {
+                throw new IOException("incorrect DER encoding");
+            } else {
+                if (len < 2 + lenByte) {
+                    throw new IOException("incorrect DER encoding");
+                }
+                length = 0x0ff & buf[pos++];
+                lenByte--;
+                if (length == 0 && !allowBER) {
+                    // DER requires length value be encoded in minimum number of bytes
+                    throw new IOException("Redundant length bytes found");
+                }
+                while (lenByte-- > 0) {
+                    length <<= 8;
+                    length += 0x0ff & buf[pos++];
+                }
+                if (length < 0) {
+                    throw new IOException("Invalid length bytes");
+                } else if (length <= 127 && !allowBER) {
+                    throw new IOException("Should use short form for length");
+                }
+            }
+        }
+        if (length == -1) { // indefinite length encoding found
+            if (!allowBER) {
+                throw new IOException
+                        ("Indefinite length encoding not supported");
+            }
+            InputStream in = new ByteArrayInputStream(
+                    DerIndefLenConverter.convertStream(
+                            new ByteArrayInputStream(buf, pos, len - (pos - offset)), (byte)lenByte, tag));
+            if (tag != in.read())
+                throw new IOException
+                        ("Indefinite length encoding not supported");
+            length = DerInputStream.getDefiniteLength(in);
+            this.buffer = IOUtils.readExactlyNBytes(in, length);
+            this.start = 0;
+            this.end = length;
+            this.allowBER = true;
+        } else {
+            if (len - length < pos - offset) {
+                throw new EOFException("Too little");
+            }
+            if (len - length > pos - offset && noMore) {
+                throw new IOException("Too much");
+            }
+            this.buffer = buf;
+            this.start = pos;
+            this.end = pos + length;
+            this.allowBER = allowBER;
+        }
+        this.data = new DerInputStream(this);
     }
 
     // Get an ASN1/DER encoded datum from an input stream w/ additional
     // arg to control whether DER checks are enforced.
     DerValue(InputStream in, boolean allowBER) throws IOException {
-        data = init(false, in, allowBER);
+        this.tag = (byte)in.read();
+        byte lenByte = (byte)in.read();
+        int length = DerInputStream.getLength(lenByte, in);
+        if (length == -1) { // indefinite length encoding found
+            in = new ByteArrayInputStream(
+                    DerIndefLenConverter.convertStream(in, lenByte, tag));
+            if (tag != in.read())
+                throw new IOException
+                        ("Indefinite length encoding not supported");
+            length = DerInputStream.getDefiniteLength(in);
+        }
+        this.buffer = IOUtils.readExactlyNBytes(in, length);
+        this.start = 0;
+        this.end = length;
+        this.allowBER = allowBER;
+        this.data = new DerInputStream(this);
+        System.out.println(this);
     }
 
     /**
      * Get an ASN1/DER encoded datum from an input stream.  The
      * stream may have additional data following the encoded datum.
@@ -338,90 +415,18 @@
      */
     public DerValue(InputStream in) throws IOException {
         this(in, true);
     }
 
-    private DerInputStream init(byte stringTag, String value) {
-        final Charset charset;
-
-        tag = stringTag;
-
-        switch (stringTag) {
-        case tag_PrintableString:
-        case tag_IA5String:
-        case tag_GeneralString:
-            charset = US_ASCII;
-            break;
-        case tag_T61String:
-            charset = ISO_8859_1;
-            break;
-        case tag_BMPString:
-            charset = UTF_16BE;
-            break;
-        case tag_UTF8String:
-            charset = UTF_8;
-            break;
-            // TBD: Need encoder for UniversalString before it can
-            // be handled.
-        default:
-            throw new IllegalArgumentException("Unsupported DER string type");
-        }
-
-        byte[] buf = value.getBytes(charset);
-        length = buf.length;
-        buffer = new DerInputBuffer(buf, true);
-        DerInputStream result = new DerInputStream(buffer);
-        result.mark(Integer.MAX_VALUE);
-        return result;
-    }
-
-    /*
-     * helper routine
-     */
-    private DerInputStream init(boolean fullyBuffered, InputStream in,
-        boolean allowBER) throws IOException {
-
-        tag = (byte)in.read();
-        byte lenByte = (byte)in.read();
-        length = DerInputStream.getLength(lenByte, in);
-        if (length == -1) { // indefinite length encoding found
-            in = new ByteArrayInputStream(
-                    DerIndefLenConverter.convertStream(in, lenByte, tag));
-            if (tag != in.read())
-                throw new IOException
-                        ("Indefinite length encoding not supported");
-            length = DerInputStream.getDefiniteLength(in);
-        }
-
-        if (fullyBuffered && in.available() != length)
-            throw new IOException("extra data given to DerValue constructor");
-
-        byte[] bytes = IOUtils.readExactlyNBytes(in, length);
-
-        buffer = new DerInputBuffer(bytes, allowBER);
-        return new DerInputStream(buffer);
-    }
-
     /**
      * Encode an ASN1/DER encoded datum onto a DER output stream.
      */
-    public void encode(DerOutputStream out)
-    throws IOException {
+    public void encode(DerOutputStream out) throws IOException {
         out.write(tag);
-        out.putLength(length);
-        // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
-        if (length > 0) {
-            byte[] value = new byte[length];
-            // always synchronized on data
-            synchronized (data) {
-                buffer.reset();
-                if (buffer.read(value) != length) {
-                    throw new IOException("short DER value read (encode)");
-                }
-                out.write(value);
-            }
-        }
+        out.putLength(end - start);
+        out.write(buffer, start, end - start);
+        data.pos = data.end; // Compatibility. Reach end.
     }
 
     public final DerInputStream getData() {
         return data;
     }
@@ -437,40 +442,28 @@
      */
     public boolean getBoolean() throws IOException {
         if (tag != tag_Boolean) {
             throw new IOException("DerValue.getBoolean, not a BOOLEAN " + tag);
         }
-        if (length != 1) {
+        if (end - start != 1) {
             throw new IOException("DerValue.getBoolean, invalid length "
-                                        + length);
-        }
-        if (buffer.read() != 0) {
-            return true;
+                                        + (end - start));
         }
-        return false;
+        data.pos = data.end; // Compatibility. Reach end.
+        return buffer[start] != 0;
     }
 
     /**
      * Returns an ASN.1 OBJECT IDENTIFIER.
      *
      * @return the OID held in this DER value
      */
     public ObjectIdentifier getOID() throws IOException {
         if (tag != tag_ObjectId)
             throw new IOException("DerValue.getOID, not an OID " + tag);
-        return new ObjectIdentifier(buffer);
-    }
-
-    private byte[] append(byte[] a, byte[] b) {
-        if (a == null)
-            return b;
-
-        byte[] ret = new byte[a.length + b.length];
-        System.arraycopy(a, 0, ret, 0, a.length);
-        System.arraycopy(b, 0, ret, a.length, b.length);
-
-        return ret;
+        data.pos = data.end; // Compatibility. Reach end.
+        return new ObjectIdentifier(buffer, start, end);
     }
 
     /**
      * Returns an ASN.1 OCTET STRING
      *
@@ -482,69 +475,75 @@
             throw new IOException(
                 "DerValue.getOctetString, not an Octet String: " + tag);
         }
         // Note: do not attempt to call buffer.read(bytes) at all. There's a
         // known bug that it returns -1 instead of 0.
-        if (length == 0) {
+        if (end - start == 0) {
             return new byte[0];
         }
 
-        // Only allocate the array if there are enough bytes available.
-        // This only works for ByteArrayInputStream.
-        // The assignment below ensures that buffer has the required type.
-        ByteArrayInputStream arrayInput = buffer;
-        if (arrayInput.available() < length) {
-            throw new IOException("short read on DerValue buffer");
-        }
-        byte[] bytes = new byte[length];
-        arrayInput.read(bytes);
-
-        if (isConstructed()) {
-            DerInputStream in = new DerInputStream(bytes, 0, bytes.length,
-                buffer.allowBER);
-            bytes = null;
-            while (in.available() != 0) {
-                bytes = append(bytes, in.getOctetString());
+        data.pos = data.end; // Compatibility. Reach end.
+        if (!isConstructed()) {
+            return Arrays.copyOfRange(buffer, start, end);
+        } else {
+            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            for (DerValue dv : new DerInputStream(this)) {
+                bout.write(dv.getOctetString());
             }
+            return bout.toByteArray();
         }
-        return bytes;
     }
 
     /**
      * Returns an ASN.1 INTEGER value as an integer.
      *
      * @return the integer held in this DER value.
      */
     public int getInteger() throws IOException {
-        if (tag != tag_Integer) {
-            throw new IOException("DerValue.getInteger, not an int " + tag);
+        BigInteger result = getBigInteger();
+        if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0) {
+            throw new IOException("Integer below minimum valid value");
+        }
+        if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {
+            throw new IOException("Integer exceeds maximum valid value");
         }
-        return buffer.getInteger(data.available());
+        return result.intValue();
     }
 
     /**
      * Returns an ASN.1 INTEGER value as a BigInteger.
      *
      * @return the integer held in this DER value as a BigInteger.
      */
     public BigInteger getBigInteger() throws IOException {
-        if (tag != tag_Integer)
-            throw new IOException("DerValue.getBigInteger, not an int " + tag);
-        return buffer.getBigInteger(data.available(), false);
+        return getBigInteger0(false);
     }
 
     /**
      * Returns an ASN.1 INTEGER value as a positive BigInteger.
      * This is just to deal with implementations that incorrectly encode
      * some values as negative.
      *
      * @return the integer held in this DER value as a BigInteger.
      */
     public BigInteger getPositiveBigInteger() throws IOException {
+        return getBigInteger0(true);
+    }
+
+    private BigInteger getBigInteger0(boolean mustBePositive) throws IOException {
         if (tag != tag_Integer)
             throw new IOException("DerValue.getBigInteger, not an int " + tag);
-        return buffer.getBigInteger(data.available(), true);
+        if (end == start) {
+            throw new IOException("Invalid encoding: zero length Int value");
+        }
+        data.pos = data.end; // Compatibility. Reach end.
+        if (!allowBER && (end - start >= 2 && (buffer[start] == 0) && (buffer[start + 1] >= 0))) {
+            throw new IOException("Invalid encoding: redundant leading 0s");
+        }
+        return mustBePositive
+                ? new BigInteger(1, buffer, start, end - start)
+                : new BigInteger(buffer, start, end - start);
     }
 
     /**
      * Returns an ASN.1 ENUMERATED value.
      *
@@ -553,37 +552,30 @@
     public int getEnumerated() throws IOException {
         if (tag != tag_Enumerated) {
             throw new IOException("DerValue.getEnumerated, incorrect tag: "
                                   + tag);
         }
-        return buffer.getInteger(data.available());
+        // TODO
+        return new BigInteger(1, buffer, start, end - start).intValue();
     }
 
     /**
      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
      *
      * @return the bit string held in this value
      */
     public byte[] getBitString() throws IOException {
-        if (tag != tag_BitString)
-            throw new IOException(
-                "DerValue.getBitString, not a bit string " + tag);
-
-        return buffer.getBitString();
+        return getBitString(false);
     }
 
     /**
      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
      *
      * @return a BitArray representing the bit string held in this value
      */
     public BitArray getUnalignedBitString() throws IOException {
-        if (tag != tag_BitString)
-            throw new IOException(
-                "DerValue.getBitString, not a bit string " + tag);
-
-        return buffer.getUnalignedBitString();
+        return getUnalignedBitString(false);
     }
 
     /**
      * Returns the name component as a Java string, regardless of its
      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
@@ -596,14 +588,12 @@
             return getPrintableString();
         else if (tag == tag_T61String)
             return getT61String();
         else if (tag == tag_IA5String)
             return getIA5String();
-        /*
-          else if (tag == tag_UniversalString)
+        else if (tag == tag_UniversalString)
           return getUniversalString();
-        */
         else if (tag == tag_BMPString)
             return getBMPString();
         else if (tag == tag_GeneralString)
             return getGeneralString();
         else
@@ -617,47 +607,76 @@
      * @param tagImplicit if true, the tag is assumed implicit.
      * @return the bit string held in this value
      */
     public byte[] getBitString(boolean tagImplicit) throws IOException {
         if (!tagImplicit) {
-            if (tag != tag_BitString)
+            if (tag != tag_BitString) {
                 throw new IOException("DerValue.getBitString, not a bit string "
-                                       + tag);
+                        + tag);
             }
-        return buffer.getBitString();
+        }
+        if (end == start) {
+            throw new IOException("No padding");
+        }
+        int numOfPadBits = buffer[start];
+        if ((numOfPadBits < 0) || (numOfPadBits > 7)) {
+            throw new IOException("Invalid number of padding bits");
+        }
+        // minus the first byte which indicates the number of padding bits
+        byte[] retval = Arrays.copyOfRange(buffer, start + 1, end);
+        if (numOfPadBits != 0) {
+            // get rid of the padding bits
+            retval[end - start - 2] &= (0xff << numOfPadBits);
+        }
+        data.pos = data.end; // Compatibility. Reach end.
+        return retval;
     }
 
     /**
      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
      * based on the parameter.  The bit string need not be byte-aligned.
      *
      * @param tagImplicit if true, the tag is assumed implicit.
      * @return the bit string held in this value
      */
     public BitArray getUnalignedBitString(boolean tagImplicit)
-    throws IOException {
+            throws IOException {
         if (!tagImplicit) {
-            if (tag != tag_BitString)
+            if (tag != tag_BitString) {
                 throw new IOException("DerValue.getBitString, not a bit string "
-                                       + tag);
+                        + tag);
             }
-        return buffer.getUnalignedBitString();
+        }
+        if (end == start) {
+            throw new IOException("No padding");
+        }
+        data.pos = data.end; // Compatibility. Reach end.
+        if (end == start + 1) {
+            return new BitArray(0);
+        } else {
+            int numOfPadBits = buffer[start];
+            if ((numOfPadBits < 0) || (numOfPadBits > 7)) {
+                throw new IOException("Invalid number of padding bits");
+            }
+            return new BitArray((end - start - 1) * 8 - numOfPadBits,
+                    Arrays.copyOfRange(buffer, start + 1, end));
+        }
     }
 
     /**
      * Helper routine to return all the bytes contained in the
      * DerInputStream associated with this object.
      */
     public byte[] getDataBytes() throws IOException {
-        byte[] retVal = new byte[length];
-        synchronized (data) {
-            data.reset();
-            data.getBytes(retVal);
-        }
-        return retVal;
+        data.pos = data.end; // Compatibility. Reach end.
+        return Arrays.copyOfRange(buffer, start, end);
     }
 
+    private String readString0(Charset cs) {
+        data.pos = data.end; // Compatibility. Reach end.
+        return new String(buffer, start, end - start, cs);
+    }
     /**
      * Returns an ASN.1 STRING value
      *
      * @return the printable string held in this value
      */
@@ -665,11 +684,11 @@
     throws IOException {
         if (tag != tag_PrintableString)
             throw new IOException(
                 "DerValue.getPrintableString, not a string " + tag);
 
-        return new String(getDataBytes(), US_ASCII);
+        return readString0(US_ASCII);
     }
 
     /**
      * Returns an ASN.1 T61 (Teletype) STRING value
      *
@@ -678,11 +697,11 @@
     public String getT61String() throws IOException {
         if (tag != tag_T61String)
             throw new IOException(
                 "DerValue.getT61String, not T61 " + tag);
 
-        return new String(getDataBytes(), ISO_8859_1);
+        return readString0(ISO_8859_1);
     }
 
     /**
      * Returns an ASN.1 IA5 (ASCII) STRING value
      *
@@ -691,11 +710,11 @@
     public String getIA5String() throws IOException {
         if (tag != tag_IA5String)
             throw new IOException(
                 "DerValue.getIA5String, not IA5 " + tag);
 
-        return new String(getDataBytes(), US_ASCII);
+        return readString0(US_ASCII);
     }
 
     /**
      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
      *
@@ -707,11 +726,11 @@
             throw new IOException(
                 "DerValue.getBMPString, not BMP " + tag);
 
         // BMPString is the same as Unicode in big endian, unmarked
         // format.
-        return new String(getDataBytes(), UTF_16BE);
+        return readString0(UTF_16BE);
     }
 
     /**
      * Returns the ASN.1 UTF-8 STRING value as a Java String.
      *
@@ -721,11 +740,11 @@
     public String getUTF8String() throws IOException {
         if (tag != tag_UTF8String)
             throw new IOException(
                 "DerValue.getUTF8String, not UTF-8 " + tag);
 
-        return new String(getDataBytes(), UTF_8);
+        return readString0(UTF_8);
     }
 
     /**
      * Returns the ASN.1 GENERAL STRING value as a Java String.
      *
@@ -735,11 +754,197 @@
     public String getGeneralString() throws IOException {
         if (tag != tag_GeneralString)
             throw new IOException(
                 "DerValue.getGeneralString, not GeneralString " + tag);
 
-        return new String(getDataBytes(), US_ASCII);
+        return readString0(US_ASCII);
+    }
+
+    /**
+     * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.
+     *
+     * @return a string corresponding to the encoded UniversalString held in
+     * this value or an empty string if UTF_32BE is not a supported character
+     * set.
+     */
+    public String getUniversalString() throws IOException {
+        if (tag != tag_UniversalString)
+            throw new IOException(
+                "DerValue.getUniversalString, not UniversalString " + tag);
+        try {
+            Charset cset = Charset.forName("UTF_32BE");
+            return readString0(cset);
+        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {
+            return "";
+        }
+    }
+
+    private Date getTime(int len, boolean generalized) throws IOException {
+
+        /*
+         * UTC time encoded as ASCII chars:
+         *       YYMMDDhhmmZ
+         *       YYMMDDhhmmssZ
+         *       YYMMDDhhmm+hhmm
+         *       YYMMDDhhmm-hhmm
+         *       YYMMDDhhmmss+hhmm
+         *       YYMMDDhhmmss-hhmm
+         * UTC Time is broken in storing only two digits of year.
+         * If YY < 50, we assume 20YY;
+         * if YY >= 50, we assume 19YY, as per RFC 5280.
+         *
+         * Generalized time has a four-digit year and allows any
+         * precision specified in ISO 8601. However, for our purposes,
+         * we will only allow the same format as UTC time, except that
+         * fractional seconds (millisecond precision) are supported.
+         */
+
+        int year, month, day, hour, minute, second, millis;
+        String type = null;
+
+        int pos = start;
+        if (generalized) {
+            type = "Generalized";
+            year = 1000 * Character.digit((char)buffer[pos++], 10);
+            year += 100 * Character.digit((char)buffer[pos++], 10);
+            year += 10 * Character.digit((char)buffer[pos++], 10);
+            year += Character.digit((char)buffer[pos++], 10);
+            len -= 2; // For the two extra YY
+        } else {
+            type = "UTC";
+            year = 10 * Character.digit((char)buffer[pos++], 10);
+            year += Character.digit((char)buffer[pos++], 10);
+
+            if (year < 50)              // origin 2000
+                year += 2000;
+            else
+                year += 1900;   // origin 1900
+        }
+
+        month = 10 * Character.digit((char)buffer[pos++], 10);
+        month += Character.digit((char)buffer[pos++], 10);
+
+        day = 10 * Character.digit((char)buffer[pos++], 10);
+        day += Character.digit((char)buffer[pos++], 10);
+
+        hour = 10 * Character.digit((char)buffer[pos++], 10);
+        hour += Character.digit((char)buffer[pos++], 10);
+
+        minute = 10 * Character.digit((char)buffer[pos++], 10);
+        minute += Character.digit((char)buffer[pos++], 10);
+
+        len -= 10; // YYMMDDhhmm
+
+        /*
+         * We allow for non-encoded seconds, even though the
+         * IETF-PKIX specification says that the seconds should
+         * always be encoded even if it is zero.
+         */
+
+        millis = 0;
+        if (len > 2) {
+            second = 10 * Character.digit((char)buffer[pos++], 10);
+            second += Character.digit((char)buffer[pos++], 10);
+            len -= 2;
+            // handle fractional seconds (if present)
+            if (buffer[pos] == '.' || buffer[pos] == ',') {
+                len --;
+                pos++;
+                int precision = 0;
+                while (buffer[pos] != 'Z' &&
+                        buffer[pos] != '+' &&
+                        buffer[pos] != '-') {
+                    // Validate all digits in the fractional part but
+                    // store millisecond precision only
+                    int thisDigit = Character.digit((char)buffer[pos], 10);
+                    precision++;
+                    pos++;
+                    switch (precision) {
+                        case 1:
+                            millis += 100 * thisDigit;
+                            break;
+                        case 2:
+                            millis += 10 * thisDigit;
+                            break;
+                        case 3:
+                            millis += thisDigit;
+                            break;
+                    }
+                }
+                if (precision == 0) {
+                    throw new IOException("Parse " + type +
+                            " time, empty fractional part");
+                }
+                len -= precision;
+            }
+        } else
+            second = 0;
+
+        if (month == 0 || day == 0
+                || month > 12 || day > 31
+                || hour >= 24 || minute >= 60 || second >= 60)
+            throw new IOException("Parse " + type + " time, invalid format");
+
+        /*
+         * Generalized time can theoretically allow any precision,
+         * but we're not supporting that.
+         */
+        CalendarSystem gcal = CalendarSystem.getGregorianCalendar();
+        CalendarDate date = gcal.newCalendarDate(null); // no time zone
+        date.setDate(year, month, day);
+        date.setTimeOfDay(hour, minute, second, millis);
+        long time = gcal.getTime(date);
+
+        /*
+         * Finally, "Z" or "+hhmm" or "-hhmm" ... offsets change hhmm
+         */
+        if (! (len == 1 || len == 5))
+            throw new IOException("Parse " + type + " time, invalid offset");
+
+        int hr, min;
+
+        switch (buffer[pos++]) {
+            case '+':
+                hr = 10 * Character.digit((char)buffer[pos++], 10);
+                hr += Character.digit((char)buffer[pos++], 10);
+                min = 10 * Character.digit((char)buffer[pos++], 10);
+                min += Character.digit((char)buffer[pos++], 10);
+
+                if (hr >= 24 || min >= 60)
+                    throw new IOException("Parse " + type + " time, +hhmm");
+
+                time -= ((hr * 60) + min) * 60 * 1000;
+                break;
+
+            case '-':
+                hr = 10 * Character.digit((char)buffer[pos++], 10);
+                hr += Character.digit((char)buffer[pos++], 10);
+                min = 10 * Character.digit((char)buffer[pos++], 10);
+                min += Character.digit((char)buffer[pos++], 10);
+
+                if (hr >= 24 || min >= 60)
+                    throw new IOException("Parse " + type + " time, -hhmm");
+
+                time += ((hr * 60) + min) * 60 * 1000;
+                break;
+
+            case 'Z':
+                break;
+
+            default:
+                throw new IOException("Parse " + type + " time, garbage offset");
+        }
+        return new Date(time);
+    }
+
+    public void getNull() throws IOException {
+        if (tag != tag_Null) {
+            throw new IOException("DerValue.getUTCTime, not a UtcTime: " + tag);
+        }
+        if (end != start) {
+            throw new IOException("DER UTC Time length error");
+        }
     }
 
     /**
      * Returns a Date if the DerValue is UtcTime.
      *
@@ -747,11 +952,15 @@
      */
     public Date getUTCTime() throws IOException {
         if (tag != tag_UtcTime) {
             throw new IOException("DerValue.getUTCTime, not a UtcTime: " + tag);
         }
-        return buffer.getUTCTime(data.available());
+        if (end - start < 11 || end - start > 17)
+            throw new IOException("DER UTC Time length error");
+
+        data.pos = data.end; // Compatibility. Reach end.
+        return getTime(end - start, false);
     }
 
     /**
      * Returns a Date if the DerValue is GeneralizedTime.
      *
@@ -760,11 +969,15 @@
     public Date getGeneralizedTime() throws IOException {
         if (tag != tag_GeneralizedTime) {
             throw new IOException(
                 "DerValue.getGeneralizedTime, not a GeneralizedTime: " + tag);
         }
-        return buffer.getGeneralizedTime(data.available());
+        if (end - start < 13)
+            throw new IOException("DER Generalized Time length error");
+
+        data.pos = data.end; // Compatibility. Reach end.
+        return getTime(end - start, true);
     }
 
     /**
      * Bitwise equality comparison.  DER encoded values have a single
      * encoding, so that bitwise equality of the encoded values is an
@@ -782,71 +995,37 @@
         }
         DerValue other = (DerValue) o;
         if (tag != other.tag) {
             return false;
         }
-        if (data == other.data) {
+        if (buffer == other.buffer && start == other.start && end == other.end) {
             return true;
         }
-
-        // make sure the order of lock is always consistent to avoid a deadlock
-        return (System.identityHashCode(this.data)
-                > System.identityHashCode(other.data)) ?
-                doEquals(this, other):
-                doEquals(other, this);
-    }
-
-    /**
-     * Helper for public method equals()
-     */
-    private static boolean doEquals(DerValue d1, DerValue d2) {
-        synchronized (d1.data) {
-            synchronized (d2.data) {
-                d1.data.reset();
-                d2.data.reset();
-                return d1.buffer.equals(d2.buffer);
-            }
-        }
+        return Arrays.equals(buffer, start, end, other.buffer, other.start, other.end);
     }
 
     /**
      * Returns a printable representation of the value.
      *
      * @return printable representation of the value
      */
     @Override
     public String toString() {
-        try {
-
-            String str = getAsString();
-            if (str != null)
-                return "\"" + str + "\"";
-            if (tag == tag_Null)
-                return "[DerValue, null]";
-            if (tag == tag_ObjectId)
-                return "OID." + getOID();
-
-            // integers
-            else
-                return "[DerValue, tag = " + tag
-                        + ", length = " + length + "]";
-        } catch (IOException e) {
-            throw new IllegalArgumentException("misformatted DER value");
-        }
+        return String.format("DerValue(%02x, %s, %d, 5d)",
+                0xff & tag, buffer, start, end);
     }
 
     /**
      * Returns a DER-encoded value, such that if it's passed to the
      * DerValue constructor, a value equivalent to "this" is returned.
      *
      * @return DER-encoded value, including tag and length.
      */
     public byte[] toByteArray() throws IOException {
         DerOutputStream out = new DerOutputStream();
-
         encode(out);
-        data.reset();
+        data.pos = data.start; // encode go last, should go back
         return out.toByteArray();
     }
 
     /**
      * For "set" and "sequence" types, this function may be used
@@ -854,19 +1033,19 @@
      * This operation is not supported for primitive types such as
      * integers or bit strings.
      */
     public DerInputStream toDerInputStream() throws IOException {
         if (tag == tag_Sequence || tag == tag_Set)
-            return new DerInputStream(buffer);
+            return data;
         throw new IOException("toDerInputStream rejects tag type " + tag);
     }
 
     /**
      * Get the length of the encoded value.
      */
     public int length() {
-        return length;
+        return end - start;
     }
 
     /**
      * Determine if a character is one of the permissible characters for
      * PrintableString:
@@ -943,6 +1122,18 @@
      */
     @Override
     public int hashCode() {
         return toString().hashCode();
     }
+
+    public DerValue[] subs(byte expectedTag) throws IOException {
+        if (expectedTag != 0 && expectedTag != tag) {
+            throw new IOException("Not constructed");
+        }
+        List<DerValue> result = new ArrayList<>();
+        DerInputStream dis = new DerInputStream(this);
+        while (dis.available() > 0) {
+            result.add(dis.getDerValue());
+        }
+        return result.toArray(new DerValue[result.size()]);
+    }
 }

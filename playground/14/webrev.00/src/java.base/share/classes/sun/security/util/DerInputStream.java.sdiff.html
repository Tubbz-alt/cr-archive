<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerValue.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;

 30 import java.math.BigInteger;
 31 import java.nio.charset.Charset;

 32 import java.util.Date;

 33 import java.util.Vector;
 34 
 35 import static java.nio.charset.StandardCharsets.*;
 36 
 37 /**
 38  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 39  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 40  * the advantage that it allows only a single encoding of primitive data.
 41  * (High level data such as dates still support many encodings.)  That is,
 42  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 43  *
 44  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 45  * tagged data values.  Accordingly, this programming interface does
 46  * not expose any variant of the java.io.InputStream interface, since
 47  * that kind of input stream holds untagged data values and using that
 48  * I/O model could prevent correct parsing of the DER data.
 49  *
 50  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 51  * data encodings which are defined.  That subset is sufficient for parsing
 52  * most X.509 certificates.
 53  *
 54  *
 55  * @author David Brownell
 56  * @author Amit Kapoor
 57  * @author Hemma Prafullchandra
 58  */
 59 
<span class="line-modified"> 60 public class DerInputStream {</span>
 61 
<span class="line-modified"> 62     /*</span>
<span class="line-modified"> 63      * This version only supports fully buffered DER.  This is easy to</span>
<span class="line-modified"> 64      * work with, though if large objects are manipulated DER becomes</span>
<span class="line-modified"> 65      * awkward to deal with.  That&#39;s where BER is useful, since BER</span>
<span class="line-modified"> 66      * handles streaming data relatively well.</span>
<span class="line-removed"> 67      */</span>
<span class="line-removed"> 68     DerInputBuffer      buffer;</span>
 69 
<span class="line-modified"> 70     /** The DER tag of the value; one of the tag_ constants. */</span>
<span class="line-modified"> 71     public byte         tag;</span>





 72 
<span class="line-modified"> 73     /**</span>
<span class="line-modified"> 74      * Create a DER input stream from a data buffer.  The buffer is not</span>
<span class="line-modified"> 75      * copied, it is shared.  Accordingly, the buffer should be treated</span>
<span class="line-modified"> 76      * as read-only.</span>
<span class="line-modified"> 77      *</span>
<span class="line-modified"> 78      * @param data the buffer from which to create the string (CONSUMED)</span>
<span class="line-modified"> 79      */</span>
<span class="line-modified"> 80     public DerInputStream(byte[] data) throws IOException {</span>
<span class="line-modified"> 81         init(data, 0, data.length, true);</span>


 82     }
 83 
<span class="line-modified"> 84     /**</span>
<span class="line-modified"> 85      * Create a DER input stream from part of a data buffer with</span>
<span class="line-modified"> 86      * additional arg to control whether DER checks are enforced.</span>
<span class="line-modified"> 87      * The buffer is not copied, it is shared.  Accordingly, the</span>
<span class="line-modified"> 88      * buffer should be treated as read-only.</span>
<span class="line-modified"> 89      *</span>
<span class="line-removed"> 90      * @param data the buffer from which to create the string (CONSUMED)</span>
<span class="line-removed"> 91      * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will</span>
<span class="line-removed"> 92      *          be read as DER input in the new stream</span>
<span class="line-removed"> 93      * @param len how long a chunk of the buffer to use,</span>
<span class="line-removed"> 94      *          starting at &quot;offset&quot;</span>
<span class="line-removed"> 95      * @param allowBER whether to allow constructed indefinite-length</span>
<span class="line-removed"> 96      *          encoding as well as tolerate leading 0s</span>
<span class="line-removed"> 97      */</span>
<span class="line-removed"> 98     public DerInputStream(byte[] data, int offset, int len,</span>
<span class="line-removed"> 99         boolean allowBER) throws IOException {</span>
<span class="line-removed">100         init(data, offset, len, allowBER);</span>
101     }
102 
<span class="line-modified">103     /**</span>
<span class="line-modified">104      * Create a DER input stream from part of a data buffer.</span>
<span class="line-removed">105      * The buffer is not copied, it is shared.  Accordingly, the</span>
<span class="line-removed">106      * buffer should be treated as read-only.</span>
<span class="line-removed">107      *</span>
<span class="line-removed">108      * @param data the buffer from which to create the string (CONSUMED)</span>
<span class="line-removed">109      * @param offset the first index of &lt;em&gt;data&lt;/em&gt; which will</span>
<span class="line-removed">110      *          be read as DER input in the new stream</span>
<span class="line-removed">111      * @param len how long a chunk of the buffer to use,</span>
<span class="line-removed">112      *          starting at &quot;offset&quot;</span>
<span class="line-removed">113      */</span>
<span class="line-removed">114     public DerInputStream(byte[] data, int offset, int len) throws IOException {</span>
<span class="line-removed">115         init(data, offset, len, true);</span>
116     }
117 
<span class="line-modified">118     /*</span>
<span class="line-modified">119      * private helper routine</span>
<span class="line-removed">120      */</span>
<span class="line-removed">121     private void init(byte[] data, int offset, int len, boolean allowBER) throws IOException {</span>
<span class="line-removed">122         if ((offset+2 &gt; data.length) || (offset+len &gt; data.length)) {</span>
<span class="line-removed">123             throw new IOException(&quot;Encoding bytes too short&quot;);</span>
<span class="line-removed">124         }</span>
<span class="line-removed">125         // check for indefinite length encoding</span>
<span class="line-removed">126         if (DerIndefLenConverter.isIndefinite(data[offset+1])) {</span>
<span class="line-removed">127             if (!allowBER) {</span>
<span class="line-removed">128                 throw new IOException(&quot;Indefinite length BER encoding found&quot;);</span>
<span class="line-removed">129             } else {</span>
<span class="line-removed">130                 byte[] inData = new byte[len];</span>
<span class="line-removed">131                 System.arraycopy(data, offset, inData, 0, len);</span>
<span class="line-removed">132 </span>
<span class="line-removed">133                 DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-removed">134                 byte[] result = derIn.convertBytes(inData);</span>
<span class="line-removed">135                 if (result == null) {</span>
<span class="line-removed">136                     throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="line-removed">137                 } else {</span>
<span class="line-removed">138                     buffer = new DerInputBuffer(result, allowBER);</span>
<span class="line-removed">139                 }</span>
<span class="line-removed">140             }</span>
<span class="line-removed">141         } else {</span>
<span class="line-removed">142             buffer = new DerInputBuffer(data, offset, len, allowBER);</span>
<span class="line-removed">143         }</span>
<span class="line-removed">144         buffer.mark(Integer.MAX_VALUE);</span>
<span class="line-removed">145     }</span>
<span class="line-removed">146 </span>
<span class="line-removed">147     DerInputStream(DerInputBuffer buf) {</span>
<span class="line-removed">148         buffer = buf;</span>
<span class="line-removed">149         buffer.mark(Integer.MAX_VALUE);</span>
150     }
151 
<span class="line-modified">152     /**</span>
<span class="line-modified">153      * Creates a new DER input stream from part of this input stream.</span>
<span class="line-removed">154      *</span>
<span class="line-removed">155      * @param len how long a chunk of the current input stream to use,</span>
<span class="line-removed">156      *          starting at the current position.</span>
<span class="line-removed">157      * @param do_skip true if the existing data in the input stream should</span>
<span class="line-removed">158      *          be skipped.  If this value is false, the next data read</span>
<span class="line-removed">159      *          on this stream and the newly created stream will be the</span>
<span class="line-removed">160      *          same.</span>
<span class="line-removed">161      */</span>
<span class="line-removed">162     public DerInputStream subStream(int len, boolean do_skip)</span>
<span class="line-removed">163     throws IOException {</span>
<span class="line-removed">164         DerInputBuffer newbuf = buffer.dup();</span>
<span class="line-removed">165 </span>
<span class="line-removed">166         newbuf.truncate(len);</span>
<span class="line-removed">167         if (do_skip) {</span>
<span class="line-removed">168             buffer.skip(len);</span>
<span class="line-removed">169         }</span>
<span class="line-removed">170         return new DerInputStream(newbuf);</span>
171     }
172 
<span class="line-removed">173     /**</span>
<span class="line-removed">174      * Return what has been written to this DerInputStream</span>
<span class="line-removed">175      * as a byte array. Useful for debugging.</span>
<span class="line-removed">176      */</span>
177     public byte[] toByteArray() {
<span class="line-modified">178         return buffer.toByteArray();</span>
179     }
180 
<span class="line-removed">181     /*</span>
<span class="line-removed">182      * PRIMITIVES -- these are &quot;universal&quot; ASN.1 simple types.</span>
<span class="line-removed">183      *</span>
<span class="line-removed">184      *  INTEGER, ENUMERATED, BIT STRING, OCTET STRING, NULL</span>
<span class="line-removed">185      *  OBJECT IDENTIFIER, SEQUENCE (OF), SET (OF)</span>
<span class="line-removed">186      *  UTF8String, PrintableString, T61String, IA5String, UTCTime,</span>
<span class="line-removed">187      *  GeneralizedTime, BMPString.</span>
<span class="line-removed">188      * Note: UniversalString not supported till encoder is available.</span>
<span class="line-removed">189      */</span>
<span class="line-removed">190 </span>
<span class="line-removed">191     /**</span>
<span class="line-removed">192      * Get an integer from the input stream as an integer.</span>
<span class="line-removed">193      *</span>
<span class="line-removed">194      * @return the integer held in this DER input stream.</span>
<span class="line-removed">195      */</span>
196     public int getInteger() throws IOException {
<span class="line-modified">197         if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="line-removed">198             throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
<span class="line-removed">199         }</span>
<span class="line-removed">200         return buffer.getInteger(getDefiniteLength(buffer));</span>
201     }
202 
<span class="line-removed">203     /**</span>
<span class="line-removed">204      * Get a integer from the input stream as a BigInteger object.</span>
<span class="line-removed">205      *</span>
<span class="line-removed">206      * @return the integer held in this DER input stream.</span>
<span class="line-removed">207      */</span>
208     public BigInteger getBigInteger() throws IOException {
<span class="line-modified">209         if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="line-removed">210             throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
<span class="line-removed">211         }</span>
<span class="line-removed">212         return buffer.getBigInteger(getDefiniteLength(buffer), false);</span>
213     }
214 
<span class="line-removed">215     /**</span>
<span class="line-removed">216      * Returns an ASN.1 INTEGER value as a positive BigInteger.</span>
<span class="line-removed">217      * This is just to deal with implementations that incorrectly encode</span>
<span class="line-removed">218      * some values as negative.</span>
<span class="line-removed">219      *</span>
<span class="line-removed">220      * @return the integer held in this DER value as a BigInteger.</span>
<span class="line-removed">221      */</span>
222     public BigInteger getPositiveBigInteger() throws IOException {
<span class="line-modified">223         if (buffer.read() != DerValue.tag_Integer) {</span>
<span class="line-removed">224             throw new IOException(&quot;DER input, Integer tag error&quot;);</span>
<span class="line-removed">225         }</span>
<span class="line-removed">226         return buffer.getBigInteger(getDefiniteLength(buffer), true);</span>
227     }
228 
<span class="line-removed">229     /**</span>
<span class="line-removed">230      * Get an enumerated from the input stream.</span>
<span class="line-removed">231      *</span>
<span class="line-removed">232      * @return the integer held in this DER input stream.</span>
<span class="line-removed">233      */</span>
234     public int getEnumerated() throws IOException {
<span class="line-modified">235         if (buffer.read() != DerValue.tag_Enumerated) {</span>
<span class="line-removed">236             throw new IOException(&quot;DER input, Enumerated tag error&quot;);</span>
<span class="line-removed">237         }</span>
<span class="line-removed">238         return buffer.getInteger(getDefiniteLength(buffer));</span>
239     }
240 
<span class="line-removed">241     /**</span>
<span class="line-removed">242      * Get a bit string from the input stream. Padded bits (if any)</span>
<span class="line-removed">243      * will be stripped off before the bit string is returned.</span>
<span class="line-removed">244      */</span>
245     public byte[] getBitString() throws IOException {
<span class="line-modified">246         if (buffer.read() != DerValue.tag_BitString)</span>
<span class="line-removed">247             throw new IOException(&quot;DER input not an bit string&quot;);</span>
<span class="line-removed">248 </span>
<span class="line-removed">249         return buffer.getBitString(getDefiniteLength(buffer));</span>
250     }
251 
<span class="line-removed">252     /**</span>
<span class="line-removed">253      * Get a bit string from the input stream.  The bit string need</span>
<span class="line-removed">254      * not be byte-aligned.</span>
<span class="line-removed">255      */</span>
256     public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified">257         if (buffer.read() != DerValue.tag_BitString) {</span>
<span class="line-removed">258             throw new IOException(&quot;DER input not a bit string&quot;);</span>
<span class="line-removed">259         }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261         int length = getDefiniteLength(buffer);</span>
<span class="line-removed">262 </span>
<span class="line-removed">263         if (length == 0) {</span>
<span class="line-removed">264             return new BitArray(0);</span>
<span class="line-removed">265         }</span>
<span class="line-removed">266 </span>
<span class="line-removed">267         /*</span>
<span class="line-removed">268          * First byte = number of excess bits in the last octet of the</span>
<span class="line-removed">269          * representation.</span>
<span class="line-removed">270          */</span>
<span class="line-removed">271         length--;</span>
<span class="line-removed">272         int excessBits = buffer.read();</span>
<span class="line-removed">273         if (excessBits &lt; 0) {</span>
<span class="line-removed">274             throw new IOException(&quot;Unused bits of bit string invalid&quot;);</span>
<span class="line-removed">275         }</span>
<span class="line-removed">276         int validBits = length*8 - excessBits;</span>
<span class="line-removed">277         if (validBits &lt; 0) {</span>
<span class="line-removed">278             throw new IOException(&quot;Valid bits of bit string invalid&quot;);</span>
<span class="line-removed">279         }</span>
<span class="line-removed">280 </span>
<span class="line-removed">281         byte[] repn = new byte[length];</span>
<span class="line-removed">282 </span>
<span class="line-removed">283         if ((length != 0) &amp;&amp; (buffer.read(repn) != length)) {</span>
<span class="line-removed">284             throw new IOException(&quot;Short read of DER bit string&quot;);</span>
<span class="line-removed">285         }</span>
<span class="line-removed">286 </span>
<span class="line-removed">287         return new BitArray(validBits, repn);</span>
288     }
289 
<span class="line-removed">290     /**</span>
<span class="line-removed">291      * Returns an ASN.1 OCTET STRING from the input stream.</span>
<span class="line-removed">292      */</span>
293     public byte[] getOctetString() throws IOException {
<span class="line-modified">294         if (buffer.read() != DerValue.tag_OctetString)</span>
<span class="line-removed">295             throw new IOException(&quot;DER input not an octet string&quot;);</span>
<span class="line-removed">296 </span>
<span class="line-removed">297         int length = getDefiniteLength(buffer);</span>
<span class="line-removed">298         byte[] retval = new byte[length];</span>
<span class="line-removed">299         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))</span>
<span class="line-removed">300             throw new IOException(&quot;Short read of DER octet string&quot;);</span>
<span class="line-removed">301 </span>
<span class="line-removed">302         return retval;</span>
<span class="line-removed">303     }</span>
<span class="line-removed">304 </span>
<span class="line-removed">305     /**</span>
<span class="line-removed">306      * Returns the asked number of bytes from the input stream.</span>
<span class="line-removed">307      */</span>
<span class="line-removed">308     public void getBytes(byte[] val) throws IOException {</span>
<span class="line-removed">309         if ((val.length != 0) &amp;&amp; (buffer.read(val) != val.length)) {</span>
<span class="line-removed">310             throw new IOException(&quot;Short read of DER octet string&quot;);</span>
<span class="line-removed">311         }</span>
312     }
313 
<span class="line-removed">314     /**</span>
<span class="line-removed">315      * Reads an encoded null value from the input stream.</span>
<span class="line-removed">316      */</span>
317     public void getNull() throws IOException {
<span class="line-modified">318         if (buffer.read() != DerValue.tag_Null || buffer.read() != 0)</span>
<span class="line-removed">319             throw new IOException(&quot;getNull, bad data&quot;);</span>
320     }
321 
<span class="line-removed">322     /**</span>
<span class="line-removed">323      * Reads an X.200 style Object Identifier from the stream.</span>
<span class="line-removed">324      */</span>
325     public ObjectIdentifier getOID() throws IOException {
<span class="line-modified">326         return new ObjectIdentifier(this);</span>
327     }
328 
<span class="line-removed">329     /**</span>
<span class="line-removed">330      * Return a sequence of encoded entities.  ASN.1 sequences are</span>
<span class="line-removed">331      * ordered, and they are often used, like a &quot;struct&quot; in C or C++,</span>
<span class="line-removed">332      * to group data values.  They may have optional or context</span>
<span class="line-removed">333      * specific values.</span>
<span class="line-removed">334      *</span>
<span class="line-removed">335      * @param startLen guess about how long the sequence will be</span>
<span class="line-removed">336      *          (used to initialize an auto-growing data structure)</span>
<span class="line-removed">337      * @return array of the values in the sequence</span>
<span class="line-removed">338      */</span>
339     public DerValue[] getSequence(int startLen) throws IOException {
<span class="line-modified">340         tag = (byte)buffer.read();</span>
<span class="line-removed">341         if (tag != DerValue.tag_Sequence)</span>
<span class="line-removed">342             throw new IOException(&quot;Sequence tag error&quot;);</span>
<span class="line-removed">343         return readVector(startLen);</span>
344     }
345 
<span class="line-removed">346     /**</span>
<span class="line-removed">347      * Return a set of encoded entities.  ASN.1 sets are unordered,</span>
<span class="line-removed">348      * though DER may specify an order for some kinds of sets (such</span>
<span class="line-removed">349      * as the attributes in an X.500 relative distinguished name)</span>
<span class="line-removed">350      * to facilitate binary comparisons of encoded values.</span>
<span class="line-removed">351      *</span>
<span class="line-removed">352      * @param startLen guess about how large the set will be</span>
<span class="line-removed">353      *          (used to initialize an auto-growing data structure)</span>
<span class="line-removed">354      * @return array of the values in the sequence</span>
<span class="line-removed">355      */</span>
356     public DerValue[] getSet(int startLen) throws IOException {
<span class="line-modified">357         tag = (byte)buffer.read();</span>
<span class="line-removed">358         if (tag != DerValue.tag_Set)</span>
<span class="line-removed">359             throw new IOException(&quot;Set tag error&quot;);</span>
<span class="line-removed">360         return readVector(startLen);</span>
361     }
362 
<span class="line-modified">363     /**</span>
<span class="line-modified">364      * Return a set of encoded entities.  ASN.1 sets are unordered,</span>
<span class="line-removed">365      * though DER may specify an order for some kinds of sets (such</span>
<span class="line-removed">366      * as the attributes in an X.500 relative distinguished name)</span>
<span class="line-removed">367      * to facilitate binary comparisons of encoded values.</span>
<span class="line-removed">368      *</span>
<span class="line-removed">369      * @param startLen guess about how large the set will be</span>
<span class="line-removed">370      *          (used to initialize an auto-growing data structure)</span>
<span class="line-removed">371      * @param implicit if true tag is assumed implicit.</span>
<span class="line-removed">372      * @return array of the values in the sequence</span>
<span class="line-removed">373      */</span>
<span class="line-removed">374     public DerValue[] getSet(int startLen, boolean implicit)</span>
<span class="line-removed">375         throws IOException {</span>
<span class="line-removed">376         tag = (byte)buffer.read();</span>
<span class="line-removed">377         if (!implicit) {</span>
<span class="line-removed">378             if (tag != DerValue.tag_Set) {</span>
<span class="line-removed">379                 throw new IOException(&quot;Set tag error&quot;);</span>
<span class="line-removed">380             }</span>
<span class="line-removed">381         }</span>
<span class="line-removed">382         return (readVector(startLen));</span>
383     }
384 
<span class="line-removed">385     /*</span>
<span class="line-removed">386      * Read a &quot;vector&quot; of values ... set or sequence have the</span>
<span class="line-removed">387      * same encoding, except for the initial tag, so both use</span>
<span class="line-removed">388      * this same helper routine.</span>
<span class="line-removed">389      */</span>
<span class="line-removed">390     protected DerValue[] readVector(int startLen) throws IOException {</span>
<span class="line-removed">391         DerInputStream  newstr;</span>
<span class="line-removed">392 </span>
<span class="line-removed">393         byte lenByte = (byte)buffer.read();</span>
<span class="line-removed">394         int len = getLength(lenByte, buffer);</span>
<span class="line-removed">395 </span>
<span class="line-removed">396         if (len == -1) {</span>
<span class="line-removed">397            // indefinite length encoding found</span>
<span class="line-removed">398            buffer = new DerInputBuffer(</span>
<span class="line-removed">399                    DerIndefLenConverter.convertStream(buffer, lenByte, tag),</span>
<span class="line-removed">400                    buffer.allowBER);</span>
<span class="line-removed">401 </span>
<span class="line-removed">402            if (tag != buffer.read())</span>
<span class="line-removed">403                 throw new IOException(&quot;Indefinite length encoding&quot; +</span>
<span class="line-removed">404                         &quot; not supported&quot;);</span>
<span class="line-removed">405            len = DerInputStream.getDefiniteLength(buffer);</span>
<span class="line-removed">406         }</span>
<span class="line-removed">407 </span>
<span class="line-removed">408         if (len == 0)</span>
<span class="line-removed">409             // return empty array instead of null, which should be</span>
<span class="line-removed">410             // used only for missing optionals</span>
<span class="line-removed">411             return new DerValue[0];</span>
<span class="line-removed">412 </span>
<span class="line-removed">413         /*</span>
<span class="line-removed">414          * Create a temporary stream from which to read the data,</span>
<span class="line-removed">415          * unless it&#39;s not really needed.</span>
<span class="line-removed">416          */</span>
<span class="line-removed">417         if (buffer.available() == len)</span>
<span class="line-removed">418             newstr = this;</span>
<span class="line-removed">419         else</span>
<span class="line-removed">420             newstr = subStream(len, true);</span>
<span class="line-removed">421 </span>
<span class="line-removed">422         /*</span>
<span class="line-removed">423          * Pull values out of the stream.</span>
<span class="line-removed">424          */</span>
<span class="line-removed">425         Vector&lt;DerValue&gt; vec = new Vector&lt;&gt;(startLen);</span>
<span class="line-removed">426         DerValue value;</span>
<span class="line-removed">427 </span>
<span class="line-removed">428         do {</span>
<span class="line-removed">429             value = new DerValue(newstr.buffer, buffer.allowBER);</span>
<span class="line-removed">430             vec.addElement(value);</span>
<span class="line-removed">431         } while (newstr.available() &gt; 0);</span>
<span class="line-removed">432 </span>
<span class="line-removed">433         if (newstr.available() != 0)</span>
<span class="line-removed">434             throw new IOException(&quot;Extra data at end of vector&quot;);</span>
<span class="line-removed">435 </span>
<span class="line-removed">436         /*</span>
<span class="line-removed">437          * Now stick them into the array we&#39;re returning.</span>
<span class="line-removed">438          */</span>
<span class="line-removed">439         int             i, max = vec.size();</span>
<span class="line-removed">440         DerValue[]      retval = new DerValue[max];</span>
<span class="line-removed">441 </span>
<span class="line-removed">442         for (i = 0; i &lt; max; i++)</span>
<span class="line-removed">443             retval[i] = vec.elementAt(i);</span>
<span class="line-removed">444 </span>
<span class="line-removed">445         return retval;</span>
<span class="line-removed">446     }</span>
<span class="line-removed">447 </span>
<span class="line-removed">448     /**</span>
<span class="line-removed">449      * Get a single DER-encoded value from the input stream.</span>
<span class="line-removed">450      * It can often be useful to pull a value from the stream</span>
<span class="line-removed">451      * and defer parsing it.  For example, you can pull a nested</span>
<span class="line-removed">452      * sequence out with one call, and only examine its elements</span>
<span class="line-removed">453      * later when you really need to.</span>
<span class="line-removed">454      */</span>
455     public DerValue getDerValue() throws IOException {
<span class="line-modified">456         return new DerValue(buffer);</span>



457     }
458 
<span class="line-removed">459     /**</span>
<span class="line-removed">460      * Read a string that was encoded as a UTF8String DER value.</span>
<span class="line-removed">461      */</span>
462     public String getUTF8String() throws IOException {
<span class="line-modified">463         return readString(DerValue.tag_UTF8String, &quot;UTF-8&quot;, UTF_8);</span>
464     }
465 
<span class="line-removed">466     /**</span>
<span class="line-removed">467      * Read a string that was encoded as a PrintableString DER value.</span>
<span class="line-removed">468      */</span>
469     public String getPrintableString() throws IOException {
<span class="line-modified">470         return readString(DerValue.tag_PrintableString, &quot;Printable&quot;,</span>
<span class="line-removed">471                           US_ASCII);</span>
472     }
473 
<span class="line-removed">474     /**</span>
<span class="line-removed">475      * Read a string that was encoded as a T61String DER value.</span>
<span class="line-removed">476      */</span>
477     public String getT61String() throws IOException {
<span class="line-modified">478         /*</span>
<span class="line-removed">479          * Works for common characters between T61 and ASCII.</span>
<span class="line-removed">480          */</span>
<span class="line-removed">481         return readString(DerValue.tag_T61String, &quot;T61&quot;, ISO_8859_1);</span>
<span class="line-removed">482     }</span>
<span class="line-removed">483 </span>
<span class="line-removed">484     /**</span>
<span class="line-removed">485      * Read a string that was encoded as a IA5String DER value.</span>
<span class="line-removed">486      */</span>
<span class="line-removed">487     public String getIA5String() throws IOException {</span>
<span class="line-removed">488         return readString(DerValue.tag_IA5String, &quot;IA5&quot;, US_ASCII);</span>
489     }
490 
<span class="line-removed">491     /**</span>
<span class="line-removed">492      * Read a string that was encoded as a BMPString DER value.</span>
<span class="line-removed">493      */</span>
494     public String getBMPString() throws IOException {
<span class="line-modified">495         return readString(DerValue.tag_BMPString, &quot;BMP&quot;, UTF_16BE);</span>
496     }
497 
<span class="line-modified">498     /**</span>
<span class="line-modified">499      * Read a string that was encoded as a GeneralString DER value.</span>
<span class="line-removed">500      */</span>
<span class="line-removed">501     public String getGeneralString() throws IOException {</span>
<span class="line-removed">502         return readString(DerValue.tag_GeneralString, &quot;General&quot;,</span>
<span class="line-removed">503                           US_ASCII);</span>
504     }
505 
<span class="line-modified">506     /**</span>
<span class="line-modified">507      * Private helper routine to read an encoded string from the input</span>
<span class="line-removed">508      * stream.</span>
<span class="line-removed">509      * @param stringTag the tag for the type of string to read</span>
<span class="line-removed">510      * @param stringName a name to display in error messages</span>
<span class="line-removed">511      * @param enc the encoder to use to interpret the data. Should</span>
<span class="line-removed">512      * correspond to the stringTag above.</span>
<span class="line-removed">513      */</span>
<span class="line-removed">514     private String readString(byte stringTag, String stringName,</span>
<span class="line-removed">515                               Charset charset) throws IOException {</span>
<span class="line-removed">516 </span>
<span class="line-removed">517         if (buffer.read() != stringTag)</span>
<span class="line-removed">518             throw new IOException(&quot;DER input not a &quot; +</span>
<span class="line-removed">519                                   stringName + &quot; string&quot;);</span>
<span class="line-removed">520 </span>
<span class="line-removed">521         int length = getDefiniteLength(buffer);</span>
<span class="line-removed">522         byte[] retval = new byte[length];</span>
<span class="line-removed">523         if ((length != 0) &amp;&amp; (buffer.read(retval) != length))</span>
<span class="line-removed">524             throw new IOException(&quot;Short read of DER &quot; +</span>
<span class="line-removed">525                                   stringName + &quot; string&quot;);</span>
<span class="line-removed">526 </span>
<span class="line-removed">527         return new String(retval, charset);</span>
528     }
529 
<span class="line-removed">530     /**</span>
<span class="line-removed">531      * Get a UTC encoded time value from the input stream.</span>
<span class="line-removed">532      */</span>
533     public Date getUTCTime() throws IOException {
<span class="line-modified">534         if (buffer.read() != DerValue.tag_UtcTime)</span>
<span class="line-removed">535             throw new IOException(&quot;DER input, UTCtime tag invalid &quot;);</span>
<span class="line-removed">536         return buffer.getUTCTime(getDefiniteLength(buffer));</span>
537     }
538 
<span class="line-removed">539     /**</span>
<span class="line-removed">540      * Get a Generalized encoded time value from the input stream.</span>
<span class="line-removed">541      */</span>
542     public Date getGeneralizedTime() throws IOException {
<span class="line-modified">543         if (buffer.read() != DerValue.tag_GeneralizedTime)</span>
<span class="line-removed">544             throw new IOException(&quot;DER input, GeneralizedTime tag invalid &quot;);</span>
<span class="line-removed">545         return buffer.getGeneralizedTime(getDefiniteLength(buffer));</span>
<span class="line-removed">546     }</span>
<span class="line-removed">547 </span>
<span class="line-removed">548     /*</span>
<span class="line-removed">549      * Get a byte from the input stream.</span>
<span class="line-removed">550      */</span>
<span class="line-removed">551     // package private</span>
<span class="line-removed">552     int getByte() throws IOException {</span>
<span class="line-removed">553         return (0x00ff &amp; buffer.read());</span>
554     }
555 
556     public int peekByte() throws IOException {
<span class="line-modified">557         return buffer.peek();</span>
<span class="line-modified">558     }</span>
<span class="line-modified">559 </span>
<span class="line-modified">560     // package private</span>
<span class="line-removed">561     int getLength() throws IOException {</span>
<span class="line-removed">562         return getLength(buffer);</span>
563     }
564 
<span class="line-removed">565     /*</span>
<span class="line-removed">566      * Get a length from the input stream, allowing for at most 32 bits of</span>
<span class="line-removed">567      * encoding to be used.  (Not the same as getting a tagged integer!)</span>
<span class="line-removed">568      *</span>
<span class="line-removed">569      * @return the length or -1 if indefinite length found.</span>
<span class="line-removed">570      * @exception IOException on parsing error or unsupported lengths.</span>
<span class="line-removed">571      */</span>
572     static int getLength(InputStream in) throws IOException {
573         return getLength(in.read(), in);
574     }
575 
576     /*
577      * Get a length from the input stream, allowing for at most 32 bits of
578      * encoding to be used.  (Not the same as getting a tagged integer!)
579      *
580      * @return the length or -1 if indefinite length found.
581      * @exception IOException on parsing error or unsupported lengths.
582      */
583     static int getLength(int lenByte, InputStream in) throws IOException {
584         int value, tmp;
585         if (lenByte == -1) {
586             throw new IOException(&quot;Short read of DER length&quot;);
587         }
588 
589         String mdName = &quot;DerInputStream.getLength(): &quot;;
590         tmp = lenByte;
591         if ((tmp &amp; 0x080) == 0x00) { // short form, 1 byte datum
</pre>
<hr />
<pre>
605 
606             value = 0x0ff &amp; in.read();
607             tmp--;
608             if (value == 0) {
609                 // DER requires length value be encoded in minimum number of bytes
610                 throw new IOException(mdName + &quot;Redundant length bytes found&quot;);
611             }
612             while (tmp-- &gt; 0) {
613                 value &lt;&lt;= 8;
614                 value += 0x0ff &amp; in.read();
615             }
616             if (value &lt; 0) {
617                 throw new IOException(mdName + &quot;Invalid length bytes&quot;);
618             } else if (value &lt;= 127) {
619                 throw new IOException(mdName + &quot;Should use short form for length&quot;);
620             }
621         }
622         return value;
623     }
624 
<span class="line-removed">625     int getDefiniteLength() throws IOException {</span>
<span class="line-removed">626         return getDefiniteLength(buffer);</span>
<span class="line-removed">627     }</span>
<span class="line-removed">628 </span>
629     /*
630      * Get a length from the input stream.
631      *
632      * @return the length
633      * @exception IOException on parsing error or if indefinite length found.
634      */
635     static int getDefiniteLength(InputStream in) throws IOException {
636         int len = getLength(in);
637         if (len &lt; 0) {
638             throw new IOException(&quot;Indefinite length encoding not supported&quot;);
639         }
640         return len;
641     }
642 
<span class="line-removed">643     /**</span>
<span class="line-removed">644      * Mark the current position in the buffer, so that</span>
<span class="line-removed">645      * a later call to &lt;code&gt;reset&lt;/code&gt; will return here.</span>
<span class="line-removed">646      */</span>
<span class="line-removed">647     public void mark(int value) { buffer.mark(value); }</span>
<span class="line-removed">648 </span>
<span class="line-removed">649 </span>
650     /**
651      * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
652      * call.  A mark is implicitly set at the beginning of
653      * the stream when it is created.
654      */
<span class="line-modified">655     public void reset() { buffer.reset(); }</span>

656 
657 
658     /**
659      * Returns the number of bytes available for reading.
660      * This is most useful for testing whether the stream is
661      * empty.
662      */
<span class="line-modified">663     public int available() { return buffer.available(); }</span>
664 }
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
<span class="line-added"> 30 import java.io.UncheckedIOException;</span>
 31 import java.math.BigInteger;
 32 import java.nio.charset.Charset;
<span class="line-added"> 33 import java.util.Arrays;</span>
 34 import java.util.Date;
<span class="line-added"> 35 import java.util.Iterator;</span>
 36 import java.util.Vector;
 37 
 38 import static java.nio.charset.StandardCharsets.*;
 39 
 40 /**
 41  * A DER input stream, used for parsing ASN.1 DER-encoded data such as
 42  * that found in X.509 certificates.  DER is a subset of BER/1, which has
 43  * the advantage that it allows only a single encoding of primitive data.
 44  * (High level data such as dates still support many encodings.)  That is,
 45  * it uses the &quot;Definite&quot; Encoding Rules (DER) not the &quot;Basic&quot; ones (BER).
 46  *
 47  * &lt;P&gt;Note that, like BER/1, DER streams are streams of explicitly
 48  * tagged data values.  Accordingly, this programming interface does
 49  * not expose any variant of the java.io.InputStream interface, since
 50  * that kind of input stream holds untagged data values and using that
 51  * I/O model could prevent correct parsing of the DER data.
 52  *
 53  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 54  * data encodings which are defined.  That subset is sufficient for parsing
 55  * most X.509 certificates.
 56  *
 57  *
 58  * @author David Brownell
 59  * @author Amit Kapoor
 60  * @author Hemma Prafullchandra
 61  */
 62 
<span class="line-modified"> 63 public class DerInputStream implements Iterable&lt;DerValue&gt; {</span>
 64 
<span class="line-modified"> 65     final byte[] data;</span>
<span class="line-modified"> 66     final int start;</span>
<span class="line-modified"> 67     final int end;</span>
<span class="line-modified"> 68     final boolean allowBER;</span>
<span class="line-modified"> 69     int pos;</span>


 70 
<span class="line-modified"> 71     @Override</span>
<span class="line-modified"> 72     public Iterator&lt;DerValue&gt; iterator() {</span>
<span class="line-added"> 73         return new Iterator&lt;DerValue&gt;() {</span>
<span class="line-added"> 74             @Override</span>
<span class="line-added"> 75             public boolean hasNext() {</span>
<span class="line-added"> 76                 return pos &lt; end;</span>
<span class="line-added"> 77             }</span>
 78 
<span class="line-modified"> 79             @Override</span>
<span class="line-modified"> 80             public DerValue next() {</span>
<span class="line-modified"> 81                 try {</span>
<span class="line-modified"> 82                     DerValue n = new DerValue(data, pos, end, allowBER, false);</span>
<span class="line-modified"> 83                     pos = n.end;</span>
<span class="line-modified"> 84                     return n;</span>
<span class="line-modified"> 85                 } catch (IOException ioe) {</span>
<span class="line-modified"> 86                     throw new UncheckedIOException(ioe);</span>
<span class="line-modified"> 87                 }</span>
<span class="line-added"> 88             }</span>
<span class="line-added"> 89         };</span>
 90     }
 91 
<span class="line-modified"> 92     public DerInputStream(byte[] data, int start, int length, boolean allowBER) {</span>
<span class="line-modified"> 93         this.data = data;</span>
<span class="line-modified"> 94         this.start = start;</span>
<span class="line-modified"> 95         this.end = start + length;</span>
<span class="line-modified"> 96         this.allowBER = allowBER;</span>
<span class="line-modified"> 97         this.pos = start;</span>











 98     }
 99 
<span class="line-modified">100     public DerInputStream(DerValue v) {</span>
<span class="line-modified">101         this(v.buffer, v.start, v.end - v.start, v.allowBER);</span>











102     }
103 
<span class="line-modified">104     public DerInputStream(byte[] data) throws IOException {</span>
<span class="line-modified">105         this(data, 0, data.length, true);</span>






























106     }
107 
<span class="line-modified">108     public DerInputStream(byte[] data, int offset, int len) throws IOException {</span>
<span class="line-modified">109         this(data, offset, len, true);</span>

















110     }
111 




112     public byte[] toByteArray() {
<span class="line-modified">113         return Arrays.copyOfRange(data, start, end);</span>
114     }
115 















116     public int getInteger() throws IOException {
<span class="line-modified">117         return getDerValue().getInteger();</span>



118     }
119 





120     public BigInteger getBigInteger() throws IOException {
<span class="line-modified">121         return getDerValue().getBigInteger();</span>



122     }
123 







124     public BigInteger getPositiveBigInteger() throws IOException {
<span class="line-modified">125         return getDerValue().getPositiveBigInteger();</span>



126     }
127 





128     public int getEnumerated() throws IOException {
<span class="line-modified">129         return getDerValue().getEnumerated();</span>



130     }
131 




132     public byte[] getBitString() throws IOException {
<span class="line-modified">133         return getDerValue().getBitString();</span>



134     }
135 




136     public BitArray getUnalignedBitString() throws IOException {
<span class="line-modified">137         return getDerValue().getUnalignedBitString();</span>






























138     }
139 



140     public byte[] getOctetString() throws IOException {
<span class="line-modified">141         return getDerValue().getOctetString();</span>

















142     }
143 



144     public void getNull() throws IOException {
<span class="line-modified">145         getDerValue().getNull();</span>

146     }
147 



148     public ObjectIdentifier getOID() throws IOException {
<span class="line-modified">149         return getDerValue().getOID();</span>
150     }
151 










152     public DerValue[] getSequence(int startLen) throws IOException {
<span class="line-modified">153         return getDerValue().subs(DerValue.tag_Sequence);</span>



154     }
155 










156     public DerValue[] getSet(int startLen) throws IOException {
<span class="line-modified">157         return getDerValue().subs(DerValue.tag_Set);</span>



158     }
159 
<span class="line-modified">160     public DerValue[] getSet(int startLen, boolean implicit) throws IOException {</span>
<span class="line-modified">161         return getDerValue().subs((byte)0);</span>


















162     }
163 






































































164     public DerValue getDerValue() throws IOException {
<span class="line-modified">165         DerValue result = new DerValue(</span>
<span class="line-added">166                 this.data, this.pos, this.end - this.pos, this.allowBER, false);</span>
<span class="line-added">167         this.pos = result.end;</span>
<span class="line-added">168         return result;</span>
169     }
170 



171     public String getUTF8String() throws IOException {
<span class="line-modified">172         return getDerValue().getUTF8String();</span>
173     }
174 



175     public String getPrintableString() throws IOException {
<span class="line-modified">176         return getDerValue().getPrintableString();</span>

177     }
178 



179     public String getT61String() throws IOException {
<span class="line-modified">180         return getDerValue().getT61String();</span>










181     }
182 



183     public String getBMPString() throws IOException {
<span class="line-modified">184         return getDerValue().getBMPString();</span>
185     }
186 
<span class="line-modified">187     public String getIA5String() throws IOException {</span>
<span class="line-modified">188         return getDerValue().getIA5String();</span>




189     }
190 
<span class="line-modified">191     public String getGeneralString() throws IOException {</span>
<span class="line-modified">192         return getDerValue().getGeneralString();</span>




















193     }
194 



195     public Date getUTCTime() throws IOException {
<span class="line-modified">196         return getDerValue().getUTCTime();</span>


197     }
198 



199     public Date getGeneralizedTime() throws IOException {
<span class="line-modified">200         return getDerValue().getGeneralizedTime();</span>










201     }
202 
203     public int peekByte() throws IOException {
<span class="line-modified">204         if (pos == end) {</span>
<span class="line-modified">205             throw new IOException(&quot;At end&quot;);</span>
<span class="line-modified">206         }</span>
<span class="line-modified">207         return data[pos];</span>


208     }
209 







210     static int getLength(InputStream in) throws IOException {
211         return getLength(in.read(), in);
212     }
213 
214     /*
215      * Get a length from the input stream, allowing for at most 32 bits of
216      * encoding to be used.  (Not the same as getting a tagged integer!)
217      *
218      * @return the length or -1 if indefinite length found.
219      * @exception IOException on parsing error or unsupported lengths.
220      */
221     static int getLength(int lenByte, InputStream in) throws IOException {
222         int value, tmp;
223         if (lenByte == -1) {
224             throw new IOException(&quot;Short read of DER length&quot;);
225         }
226 
227         String mdName = &quot;DerInputStream.getLength(): &quot;;
228         tmp = lenByte;
229         if ((tmp &amp; 0x080) == 0x00) { // short form, 1 byte datum
</pre>
<hr />
<pre>
243 
244             value = 0x0ff &amp; in.read();
245             tmp--;
246             if (value == 0) {
247                 // DER requires length value be encoded in minimum number of bytes
248                 throw new IOException(mdName + &quot;Redundant length bytes found&quot;);
249             }
250             while (tmp-- &gt; 0) {
251                 value &lt;&lt;= 8;
252                 value += 0x0ff &amp; in.read();
253             }
254             if (value &lt; 0) {
255                 throw new IOException(mdName + &quot;Invalid length bytes&quot;);
256             } else if (value &lt;= 127) {
257                 throw new IOException(mdName + &quot;Should use short form for length&quot;);
258             }
259         }
260         return value;
261     }
262 




263     /*
264      * Get a length from the input stream.
265      *
266      * @return the length
267      * @exception IOException on parsing error or if indefinite length found.
268      */
269     static int getDefiniteLength(InputStream in) throws IOException {
270         int len = getLength(in);
271         if (len &lt; 0) {
272             throw new IOException(&quot;Indefinite length encoding not supported&quot;);
273         }
274         return len;
275     }
276 







277     /**
278      * Return to the position of the last &lt;code&gt;mark&lt;/code&gt;
279      * call.  A mark is implicitly set at the beginning of
280      * the stream when it is created.
281      */
<span class="line-modified">282     public void reset() { pos = start; }</span>
<span class="line-added">283     public void mark(int dummy) { }</span>
284 
285 
286     /**
287      * Returns the number of bytes available for reading.
288      * This is most useful for testing whether the stream is
289      * empty.
290      */
<span class="line-modified">291     public int available() { return end - pos; }</span>
292 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerValue.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>